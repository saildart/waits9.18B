COMMENT ⊗   VALID 00026 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	<5-MONITOR>PHYH2.MAC.15, 11-Oct-82 13:52:35, Edit by B.BOMBADIL
C00011 00003	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
C00012 00004	 DO.BA2 DO.CT2 DO.BA1 DO.CT1 DO.IVI DO.RDR DO.WTR DO.DIA DO.AS DO.DA DO.DT DO.LR DO.DRE DO2RCP DO2SCS DO2NBC DO2RGS DI.CPE DI.TRA DI1UNS DI1FNC LG2DBP RH2CNI RH2CNO RH2DTI RH2DTO L.RH2
C00015 00005	 RH2.0 RH2.7 RH2.I CHXFR CHJMP CHLST CHREV CHCNT CHADR CS1MPE CS1NSE CS1NC0 CS1NXM CS1LTE CS1RHE CS1LWC CS1SWC CS1OVR ERETRY ERSTRY
C00017 00006	 CI.BPE CI.EXC CI.LWE CI.SWE CI.MBE CI.DRE CI.RAE CI.MBH CI.OVR CI.MEN CI.ATN CI.2RF CI.ATE CI.1RF CI.DON CI.PIA CI.ERR CO.RAE CO.RST CO.XFR CO.MEN CO.RCL CO.DEL CO.ATE CO.STP CO.DON CO.CLR
C00019 00007	 RH2DSP RH2LTM
C00020 00008	 RH2INI RH2NCH
C00024 00009	 RH2UNL RH2NXU RH2NXT RH2UNS RH2US1
C00030 00010	 RH2IRS RH2IRP RH2IDA RH2IDB RH2IME RH2ITM RH2ITD RH2IT8 DEVXCT FNDUTP FNDTPL
C00033 00011	 RH2POS RH2SIO RH2STK
C00034 00012	 RH2HNG RH2RST RH2CHK
C00037 00013	 RDREG RDREG3 RDREGX RDREGL RDRAE1 RDEXIT RDREGE RDRAE RDRAE2
C00040 00014	 WTREG WTREG3 WTREGX WTREGX WTRAE CLRRAE
C00042 00015	 CLRCHL CHNCNO
C00043 00016	 CHSTRT CHST0 CHST1 CHST2
C00048 00017	 RH2CCW RH2CW1 RH2CCA
C00050 00018	 CKERR CKERR3 CKERR1 CKERR2
C00054 00019	 ERRCNI ERCNI1
C00057 00020	 BLKCNT BLKCNL BLKCT1
C00061 00021	 REVCCW REVCC1 REVCC2 REVCC3 REVCC4 REVCC5 REVCC6 REVCC7 REVIOW
C00065 00022	 RH2INT RH2IN1 ATCHKN ATCHK0 ATCHK1 ATCHK2 NOATTN NOATT1 XFR XFR1 XFR3 XFR4 XFR2
C00074 00023	 ATNIRB WRNGUN WRNGU1 ATNXU BADDON
C00077 00024	 CKCWP CKCWP1 CKCWP2 CKCWP3
C00080 00025	 ECCADR ECCUCL
C00083 00026	WAITS code for ECC  ECCCWF ECCFIX ECFCWL
C00098 ENDMK
C⊗;
;<5-MONITOR>PHYH2.MAC.15, 11-Oct-82 13:52:35, Edit by B.BOMBADIL
; Mods to RH2INT from Rutgers to support shared disk contention
;<5-MONITOR>PHYH2.MAC.14, 16-Jul-82 05:57:02, Edit by ADMIN.MRC
;Pup Ethernet changes:
; Code to initialize a MEIS
; UPD ID= 502, SNARK:<5.MONITOR>PHYH2.MAC.13,   6-Mar-82 12:17:19 by PAETZOLD
;TCO 5.1748 - Make CLRCHL global
; UPD ID= 149, SNARK:<5.MONITOR>PHYH2.MAC.12,   3-Sep-81 16:48:22 by UHLER
;TCO 5.1487 - ADD EXTN FOR WREQ AND MEMSCN
; UPD ID= 148, SNARK:<5.MONITOR>PHYH2.MAC.11,   3-Sep-81 16:36:29 by UHLER
;TCO 5.1487 - ADD CODE TO DETECT CHANNEL WRITE PARITY ERRORS AND CALL MEMSCN
; UPD ID= 1621, SNARK:<5.MONITOR>PHYH2.MAC.10,   2-Mar-81 07:48:41 by WACHS
;TCO 5.1266 - ADD CODE TO REVCCW
; UPD ID= 1502, SNARK:<5.MONITOR>PHYH2.MAC.9,  27-Jan-81 10:24:54 by WACHS
; UPD ID= 1454, SNARK:<5.MONITOR>PHYH2.MAC.8,  20-Jan-81 05:51:46 by WACHS
; TCO 5.1234 - ADD ROUTINE TO REVERSE THE IOWDS FOR TAPE RETRY OPPOSITE
; UPD ID= 1363, SNARK:<5.MONITOR>PHYH2.MAC.7,  18-Dec-80 10:09:05 by WACHS
; TCO 5.1206 CHANGES FOR HANDLING TM78 
; UPD ID= 953, SNARK:<5.MONITOR>PHYH2.MAC.6,  22-Aug-80 16:32:17 by LYONS
;MORE TCO 5.1062 - ALLOW A 0 PAGE ADDR IN THE RH LOGOUN AREA ONLY IF THE
;FUNCTION WAS A READ VALIDITY CHECK
; UPD ID= 574, SNARK:<5.MONITOR>PHYH2.MAC.5,  31-May-80 22:49:28 by DBELL
;MORE TCO 5.1048 - FIX BLKCNT TO HANDLE MULTIPLE CCWS
;TCO 5.1048 - ADD NEW ENTRY POINT TO RETURN ADDRESS FROM CCW WORD
; UPD ID= 483, SNARK:<4.1.MONITOR>PHYH2.MAC.92,  26-Apr-80 11:59:28 by DBELL
;TCO 4.1.1149 - CALL LOWER LEVEL ROUTINES ON HUNG DEVICE CALLS
; UPD ID= 362, SNARK:<4.1.MONITOR>PHYH2.MAC.91,  26-Mar-80 11:07:04 by DBELL
;TCO 4.1.1119 - ADD SUPPORT FOR RP20 DISKS
;<4.MONITOR>PHYH2.MAC.90, 17-Oct-79 14:01:08, EDIT BY DBELL
;PUT IN ADDITIONAL DATA NAMES INTO BUGCHKS, ETC.
;<4.MONITOR>PHYH2.MAC.89, 20-Sep-79 15:06:28, EDIT BY DBELL
;TCO 4.2476 - ADD DISPATCH FOR CHECKING UNIT EXISTANCES
;<OSMAN.MON>PHYH2.MAC.1, 10-Sep-79 15:58:54, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>PHYH2.MAC.86, 11-Jun-79 14:05:34, Edit by MCLEAN
;<4.MONITOR>PHYH2.MAC.85,  8-Jun-79 12:48:05, Edit by MCLEAN
;ADD CHECK FOR LEGAL LOGOUT ON DISK TRANSFERS
;<4.MONITOR>PHYH2.MAC.84,  8-Jun-79 11:52:20, Edit by MCLEAN
;FIX SO CHANNEL STATUS IS STORED
;<4.MONITOR>PHYH2.MAC.83,  5-Mar-79 15:48:55, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<2BOSACK>PHYH2.MAC.3, 14-Feb-79 22:30:14, EDIT BY BOSACK
;CLEANUP RAE DURING DYNAMIC CONFIGURATIONS
;<4.MONITOR>PHYH2.MAC.81,  1-Feb-79 17:49:42, Edit by MCLEAN
;<4.MONITOR>PHYH2.MAC.80, 22-Jan-79 16:11:18, EDIT BY MILLER
;FIX ERRCNO AGAIN TO CHECK FOR STATUS VALID
;<4.MONITOR>PHYH2.MAC.79, 21-Jan-79 21:56:57, Edit by MCLEAN
;<4.MONITOR>PHYH2.MAC.78, 21-Jan-79 17:52:56, Edit by MCLEAN
;.DGPDL SUPPORT
;<4.MONITOR>PHYH2.MAC.76, 19-Jan-79 18:05:25, EDIT BY BOSACK
;FIX ERRCNI TO CHECK STATUS 1 CORRECTLY
;<4.MONITOR>PHYH2.MAC.75, 19-Jan-79 14:26:13, EDIT BY MILLER
;FIX CODE THAT CALLS APRRPT TO PASS CORRECT CHANNEL NUMBER
;<4.MONITOR>PHYH2.MAC.74, 17-Jan-79 10:49:49, EDIT BY MILLER
;FIX ERRCNI NOT TO REPORT RETRIES OF MEM ERRORS
;<4.MONITOR>PHYH2.MAC.73, 16-Jan-79 14:14:35, EDIT BY MILLER
;ADD CODE TO ERRCNI TO CHECK FOR MEM ERROR AND CALL APRRPT IF SO
;<4.MONITOR>PHYH2.MAC.72,  1-Jun-78 14:16:44, EDIT BY BOSACK
;<3A-NEW>PHYH2.MAC.71, 25-May-78 11:42:23, Edit by FORTMILLER
;ADD CODE FOR DX20
;<3A.MONITOR>PHYH2.MAC.70, 27-Mar-78 18:52:40, EDIT BY BOSACK
;ENSURE NONSKIP RETURN FROM CKERR UNDER ALL ERROR CONDITIONS
;<3A.MONITOR>PHYH2.MAC.69, 23-Mar-78 15:04:40, EDIT BY MILLER
;ADD SOME MORE
;<3A.MONITOR>PHYH2.MAC.68, 23-Mar-78 14:56:51, EDIT BY MILLER
;ADD SOME OPTIONAL DATA TO SOME OF THE BUGCHKS
;<3A.MONITOR>PHYH2.MAC.67, 11-Mar-78 21:05:01, Edit by MCLEAN
;REMOVE CODE THAT DISABLES A CHANNEL IF IT HAS NO UNITS.  THIS
;IS FOR THE NEW CODE THAT BRINGS UNITS ON LINE WHEN THEY APPEAR.
;<3A.MONITOR>PHYH2.MAC.66,  8-Mar-78 22:41:59, EDIT BY OPERATOR
;<2BOSACK>PHYH2.MAC.62, 24-Feb-78 01:21:06, EDIT BY BOSACK
;FLAG DEVICE (NOT DATA) ERROR ON CHANNEL ERROR
;<4.MONITOR>PHYH2.MAC.64,  1-Feb-78 14:50:42, Edit by MCLEAN
;FIX PHYALC FOR NEW CALLING SEQ
;<1MCLEAN>PHYH2.MAC.63, 30-Jan-78 21:29:04, Edit by MCLEAN
;ADDITIONS FOR SELECTING UNIT THAT COMES ON LINE


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

	SEARCH PROLOG		;PARAMETER FILE
	TTITLE (PHYH2,,< - CHANNEL DEPENDENT CODE FOR RH20 CONTROLLER>)
	SUBTTL T. HESS, T. WACHS, L. BOSACK/LB 29-JUL-75

	SEARCH PHYPAR		;PHYSIO PARAMETERS
	EXTN <WREQ,MEMSCN>

IFWAITS<	Printx	% This is the WAITS version of PHYH2>
;⊗ DO.BA2 DO.CT2 DO.BA1 DO.CT1 DO.IVI DO.RDR DO.WTR DO.DIA DO.AS DO.DA DO.DT DO.LR DO.DRE DO2RCP DO2SCS DO2NBC DO2RGS DI.CPE DI.TRA DI1UNS DI1FNC LG2DBP RH2CNI RH2CNO RH2DTI RH2DTO L.RH2
	SUBTTL PARAMETERS

;RH20 REGISTERS

DO.BA2==70B5			;SECONDARY BLOCK ADDRESS
DO.CT2==71B5			;SECONDARY TRANSFER CONTROL
DO.BA1==72B5			;PRIMARY BLOCK ADDRESS
DO.CT1==73B5			;PRIMARY TRANSFER CONTROL
DO.IVI==74B5			;INTERRUPT VECTOR INDEX
DO.RDR==75B5			;READ REGISTER
DO.WTR==76B5			;WRITE REGISTER
DO.DIA==77B5			;DIAGNOSTIC CONTROL REGISTER

;DEVICE INDEPENDENT REGISTERS

DO.AS==4B5			;ATTENTION SUMMARY REGISTER
DO.DA==5B5			;DESIRED ADDRESS REGISTER
DO.DT==6B5			;DRIVE TYPE REGISTER

DO.LR==1B6			;LOAD REGISTER ENABLE
DO.DRE==1B9			;DISABLE RAE STOP

;BITS IN DATAO STCR

DO2RCP==1B7			;RESET CHANNEL PC
DO2SCS==1B10			;STORE CHANNEL STATUS
DO2NBC==MASKB(20,29)		;NEGATIVE BLOCK COUNT
DO2RGS==MASKB(0,5)		;REGISTER SELECT FIELD

;COMMON DATAI BITS

DI.CPE==1B8			;CONTROL BUS PARITY ERROR
DI.TRA==1B10			;TRA (MASSBUSS SIGNAL)
DI1UNS==MASKB(15,17)		;UNIT SELECT FIELD IN PTCR
DI1FNC==MASKB(30,35)		;FUNCTION CODE IN PTCR

;LOGOUT AREA FIELDS

LG2DBP==MASKB(14,26)		;LOGOUT WORD 2 DATA BUFFER PAGE NUMBER

;DEVICE DEPENDENT DEFINITIONS IN THE CDB

RH2CNI==CDBDDP+0		;CONI RH2,T1
RH2CNO==CDBDDP+1		;CONO RH2,T2
RH2DTI==CDBDDP+2		;DATAI RH2,T1
RH2DTO==CDBDDP+3		;DATAO RH2,T2

L.RH2==CDBDDP+4-CDBINT		;LENGTH OF RH20 CDB
;⊗ RH2.0 RH2.7 RH2.I CHXFR CHJMP CHLST CHREV CHCNT CHADR CS1MPE CS1NSE CS1NC0 CS1NXM CS1LTE CS1RHE CS1LWC CS1SWC CS1OVR ERETRY ERSTRY

RH2.0==540B11			;DEVICE CODE OF FIRST RH20
RH2.7==574B11			;DEVICE CODE OF LAST RH20
RH2.I==0			;EPT ADDRESS OF FIRST RH20

CHXFR==1B0			;INDICATE XFER WORD
CHJMP==2B2			;INDICATE CHANNEL JUMP
CHLST==1B1			;INDICATE LAST XFER
CHREV==1B2			;INDICATE REVERSE
CHCNT==MASKB(3,13)		;MASK FOR WORD COUNT IN CCW
CHADR==MASKB(14,35)		;MASK FOR PHYSICAL ADDRESS IN CCW

;CCYADR:	POINT 22,T1,35		;BYTE POINTER TO CCW ADDRESS FIELD
;CCYCNT:	POINT 11,T1,13		;BYTE POINTER TO CCW COUNT FIELD

;BITS IN CHANNEL LOGOUT AREA

CS1MPE==1B1			;MEMORY PARITY ERROR
CS1NSE==1B2			;NEGATION OF SBUS ERR
CS1NC0==1B3			;NEGATION OF WORDCOUNT = 0
CS1NXM==1B4			;NONEXISTANT MEMORY
CS1LTE==1B9			;LAST TRANSFER ERROR
CS1RHE==1B10			;RH20 ERROR
CS1LWC==1B11			;LONG WORD COUNT (RH20 FINISHED BEFORE CHANNEL)
CS1SWC==1B12			;SHORT WORD COUNT (CHANNEL FINISHED BEFORE RH20)
CS1OVR==1B13			;OVERRUN (MBOX BUFFER)

;SOFTWARE FLAGS IN FUNCTION (USED BY CHSTRT)
ERETRY==200
ERSTRY==400
;⊗ CI.BPE CI.EXC CI.LWE CI.SWE CI.MBE CI.DRE CI.RAE CI.MBH CI.OVR CI.MEN CI.ATN CI.2RF CI.ATE CI.1RF CI.DON CI.PIA CI.ERR CO.RAE CO.RST CO.XFR CO.MEN CO.RCL CO.DEL CO.ATE CO.STP CO.DON CO.CLR

;RH20 CONI/CONO BITS

;CONI (RH)

CI.BPE==1B18			;DATA BUS PARITY ERROR
CI.EXC==1B19			;EXCEPTION
CI.LWE==1B20			;LONG WORD COUNT ERROR
CI.SWE==1B21			;SHORT WORD COUNT ERROR
CI.MBE==1B22			;MBOX ERROR
CI.DRE==1B23			;DRIVE RESPONSE ERROR
CI.RAE==1B24			;REGISTER ACCESS ERROR
CI.MBH==1B25			;MBOX HALTED
CI.OVR==1B26			;DATA OVERRUN
CI.MEN==1B27			;MASSBUS ENABLE
CI.ATN==1B28			;DRIVE ATTENTION
CI.2RF==1B29			;SECONDARY COMMAND REGISTER FULL
CI.ATE==1B30			;ATTENTION ENABLE
CI.1RF==1B31			;PRIMARY COMMAND REGISTER FULL
CI.DON==1B32			;CHANNEL DONE
CI.PIA==7			;PRIORITY ASSIGNMENT
CI.ERR==555000			;BITS THAT CAUSE ERRORS

;CONO

CO.RAE==1B24			;CLEAR REGISTER ACCESS ERROR
CO.RST==1B25			;CONTROLLER RESET
CO.XFR==1B26			;CLEAR TRANSFER ERROR
CO.MEN==1B27			;MASSBUS ENABLE
CO.RCL==1B28			;RESET MBOX COMMAND LIST POINTER
CO.DEL==1B29			;DELETE SECONDARY COMMAND
CO.ATE==1B30			;ENABLE ATTENTION INTERRUPTS
CO.STP==1B31			;STOP CURRENT COMMAND
CO.DON==1B32			;CLEAR DONE
CO.CLR=005010			;CLEAR BITS THAT CAUSE INTERRUPTS
;⊗ RH2DSP RH2LTM

;CHANNEL DISPATCH TABLE FOR RH20

RH2DSP::JRST RH2INI		;0 - INITIATION
	JRST RH2STK		;1 - STACK SECOND CHANNEL COMMAND
	JRST RH2SIO		;2 - START I/O
	JRST RH2POS		;3 - POSITION REQUEST
	JRST RH2LTM		;4 - RETURN BEST XFER
	JRST RH2INT		;5 - INTERRUPT PROCESSING
	JRST RH2CCW		;6 - MAKE CHANNEL XFER WORD
	JRST RH2HNG		;7 - TRANSFER HUNG
	JRST RH2RST		;10 - RESET CHANNEL
	JRST RH2CHK		;11 - PERIODIC CHECK
	JRST EXTKDB		;12 - CHECK UNIT EXISTANCE
	JRST RH2CCA		;13 - EXTRACT ADDRESS FROM CCW WORD

;DUMMIES

RH2LTM:	RET
;⊗ RH2INI RH2NCH
	SUBTTL INITIALIZATION

RH2INI:	MOVSI Q1,(RH2.0)	;INITIAL CHANNEL DEVICE ADDRESS
	PUSH P,Q1		;SAVE ON PDL
RH2NCH:	CALL DEVXCT		;SET PIA
	 CONO 0,CO.MEN+7
	CALL DEVXCT		;READ DEVICE REGISTER
	 CONI 0,T1		;STATUS INTO T1
	TRNN T1,7		;EXISTS?
	JRST RH2NXT		;NO - TRY NEXT
	CALL DEVXCT		;YES - DO CONTROLLER RESET
	 CONO 0,CO.RST		;...
	CALL DEVXCT		;NOW SET MASSBUS ENABLE
	 CONO 0,CO.MEN
	MOVEI T1,L.RH2		;GET LENGTH OF CDB
	CALL PHYALC		;ALLOCATE SOME STORAGE
	 JRST PA1		;FAILURE QUIT INITALIZATION
	MOVEI P1,-CDBINT(T1)	;CDB BASE ADDRESS TO P1
	HRRZ P4,(P)		;GET ACTUAL CHANNEL ADDRESS
	MOVEM P1,CHNTAB(P4)	;SAVE CDB IN CHANNEL TABLE
	HRRZM P4,CDBADR(P1)	;STORE CHNTAB INDEX
	EXCH P1,P3		;GET CDB IN P3
	MOVEI T1,.BTCDB		;MARK AS CDB
	DPB T1,USYBKT		; ...
	EXCH P1,P3		;RESTORE
	MOVEI T1,.CTRH2		;SET TYPE
	DPB T1,CSYTYP		;..
	MOVEI T1,PHYCHN		;*** TEMPORARY ***
	DPB T1,CSYPIA		;SET PIA IN CONFIGURATION INFORMATION
	MOVSI T1,(CS.STK)	;INDICATE CHANNEL CAN DO COMMAND
	IORM T1,CDBSTS(P1)	;STACKING
	MOVE T1,[CONO 0,CO.MEN(T2)] ;SET UP IOT'S
	IOR T1,Q1		;WITH CORRECT DEVICE CODES
	MOVEM T1,RH2CNO(P1)	;STASH IN CDB
	MOVE T1,[CONI 0,T1]	;CONI STATUS
	IOR T1,Q1		;SET DEVICE CODE
	MOVEM T1,RH2CNI(P1)	;STORE IN CDB
	MOVE T1,[DATAO 0,T2]	;DATAO INSTRUCTION
	IOR T1,Q1		;SET DEVICE CODE
	MOVEM T1,RH2DTO(P1)	;STASH IN CDB
	MOVE T1,[DATAI 0,T1]	;DATAI INSTRUCTION
	IOR T1,Q1		;SET DEVICE CODE
	MOVEM T1,RH2DTI(P1)	;INTO CDB

	HRRZ T1,(P)		;GET RH NUMBER
	LSH T1,2		;TIMES 4
	MOVEI T2,KIEPT+3(T1)	;IN UNUSED LOGOUT AREA
	HRLZM T2,CDBICP(P1)	;AND STORE AS INTERRUPT VECOTOR
	MOVEI T3,CDBINT(P1)	;ADDRESS FOR XPCW ON INTERRUPT
	HRLI T3,(<XPCW>)	;BUILD INSTRUCTION
	MOVEM T3,0(T2)		;STORE IN PAGE 0
	MOVEI T3,CDBINT+4(P1)	;SET JUMP ADDRESS
	MOVEM T3,CDBINT+3(P1)	;SET IN XFER VECTOR
	SETZM CDBINT+2(P1)	;SET FLAGS TO 0
	ADDI T1,RH2.I+KIEPT	;ADDRESS OF CHANNEL ICP AREA
	HRRM T1,CDBICP(P1)	;STASH IN CDB
; ...
;⊗ RH2UNL RH2NXU RH2NXT RH2UNS RH2US1

	MOVE T1,[MOVEM P1,CDBSVQ]
	ADDI T1,0(P1)		;INSTRUCTION TO STORE P1 IN CDB
	MOVEM T1,CDBINT+4(P1)	;BUILD INTERRUPT CODE
	MOVE T1,[JSP P1,PHYINT]
	MOVEM T1,CDBINT+5(P1)	;DISPATCH TO PHYSIO
	MOVE T1,[BLT 17,17]	;INSTRUCTION TO RESTORE ACCUMULATORS
	MOVEM T1,CDBJEN(P1)	;PUT IN CDB
	MOVEI T1,CDBRST(P1)	;BUILD DATAO CDBRST, TO RESET THE
	HRLI T1,(DATAO T1,0)	; RH20 PREPARATION REGISTER
	IOR T1,Q1
	MOVEM T1,CDBJEN+1(P1)	;STORE IT IN THE EXIT SEQUENCE
	MOVEI T1,CDBINT(P1)	;ADDRESS OF INTERRUPT PC
	HRLI T1,(<XJEN 0>)	;BUILD XJEN INSTRUCTION
	MOVEM T1,CDBJEN+2(P1)	;STORE
	MOVEI T1,RH2DSP		;INSERT DISPATCH VECTOR
	MOVEM T1,CDBDSP(P1)	;SET UP DISPATCH
				;NOW FIND UNITS & TYPES
	MOVE Q3,[-MAXRH,,CDBUDB] ;AOBJN POINTER TO UDB TABLE
	ADDI Q3,0(P1)		;RELOCATE POINTER
	MOVEM Q3,CDBCUN(P1)	;STORE IN CDB
	MOVEM Q3,CDBIUN(P1)	;...
	SETOM CDBXFR(P1)	;INDICATE CHANNEL FREE

	MOVEI Q2,0		;FIRST UNIT #
RH2UNL:	MOVEI T2,CO.RAE		;RESET RAE (IN CASE)
	XCT RH2CNO(P1)
	SETZM P3		;IN CASE NOT WANTED
	SETOM P5		;INDICATE TO CREATE ALL UDBS AND KDBS
	CALL RH2UNS		;SEARCH UNIT TYPE
RH2NXU:	MOVEM P3,0(Q3)		;STORE IN CDB IF ANY (0 IF NONE)
	AOS Q2			;NEXT UNIT #
	AOBJN Q3,RH2UNL		;KEEP GOING
	MOVEI T2,CO.RAE		;CLEAR REGISTER ACCESS ERROR
	XCT RH2CNO(P1)		;...
	SETOM CDBCAD(P1)	;CLEAR THIS WORD SINCE RH2RST WON'T
	MOVEI T1,0		;CONTROLLER ONLY RESET
	CALL RH2RST		; ...
;	MOVE T1,CDBIUN(P1)	;CHECK IF ANY DEVICES FOUND.
;RH2CKU:	SKIPE (T1)		;UNIT PRESENT?
;	JRST RH2NXT		;YES, GO ON TO NEXT CHANNEL
;	AOBJN T1,RH2CKU		;NO, LOOP FOR MORE
;	MOVSI T1,(CS.OFL)	;NONE PRESENT, MARK OFFLINE.
;	IORM T1,CDBSTS(P1)	; ...
;	MOVE Q1,(P)		;RECOVER DEVXCT ARGUMENT
;	CALL DEVXCT		;COMPLETELY DISABLE RH
;	 CONO 0,0		; ...
RH2NXT:	AOS Q1,0(P)		;RESTORE DEVICE CODE
	ADD Q1,[4B11]		;ADVANCE TO NEXT CHANNEL
	MOVEM Q1,0(P)		;STASH NEW ADDRESS
	TRZ Q1,-1		;CLEAR CHANNEL #
	CAMLE Q1,[RH2.7]	;BEYOND LAST?
	AOJA P4,PA1		;INCR MAXCHN AND EXIT
	JRST RH2NCH		;TRY NEXT
;
; ROUTINE TO DETERMINE THE TYPE OF DISK/TAPE
;
;
RH2UNS::MOVSI T2,(DO.DT)	;DEVICE TYPE REGISTER
	TLO T2,(Q2)		;SET UNIT NUMBER
	XCT RH2DTO(P1)		;SEND OUT
	XCT RH2DTI(P1)		;AND READ BACK
	TLNN T1,(DI.TRA)	;NORMAL RESPONSE?
	JRST RH2US1		;NO - GO CLEAR RAE AND EXIT
	LDB T1,[POINT 9,T1,35]	;GET DEVICE TYPE CODE
	CAIG T1,TY.RPH		;WITHING RP04,5,6 RANGE?
	CAIGE T1,TY.RPL		; ??
	SKIPA			;NO.
	JRST RH2IRP		;YES - INITIALIZE IT
	CAIN T1,TY.RS4		;RS04 TYPE?
	JRST RH2IRS		;YES - INITIALIZE IT
	CAIN T1,TY.DXA		;DX20A TYPE?
	JRST RH2IDA		;YES - INITIALIZE IT
	CAIN T1,TY.DXB		;DX20B TYPE?
	JRST RH2IDB		;YES - INITIALIZE IT
IFN PUPSW,<
	CAIN T1,TY.MEI		;MEIS TYPE?
	JRST RH2IME		;YES - INITIALIZE IT
>;IFN PUPSW
	CAIG T1,TY.T3H		;WITHIN TM03 RANGE
	CAIGE T1,TY.T3L		; ???
	SKIPA			;NO
	JRST RH2ITM		;YES
	CAIG T1,TY.T2H		;GREATER THAN HIGHEST TM02 TYPE
	CAIGE T1,TY.T2L		;OR LOWER THAN LOWEST?
	SKIPA			;YES - NOT TM02
	JRST RH2ITM		;IS TM02 - GO INITIALIZE
	CAIN T1,TY.T78		;TM78 TYPE?
	JRST RH2IT8		;YES, INITIALIZE IT
	RET			;NOT A KNOWN DEVICE

;HERE IF UNIT WAS NONEXISTANT

RH2US1:	MOVEI T2,CO.RAE		;CLEAR RAE
	XCT RH2CNO(P1)		; ...
	RET			;RETURN
;⊗ RH2IRS RH2IRP RH2IDA RH2IDB RH2IME RH2ITM RH2ITD RH2IT8 DEVXCT FNDUTP FNDTPL

;ROUTINE TO INVOKE RP04/RS04 INITIATION

RH2IRS:	SKIPA T1,[.UTRS4]	;RS04 TYPE
RH2IRP:	MOVEI T1,.UTRP4		;RP04 TYPE
	CALL FNDUTP		;FIND TABLE ENTRY
	 CALL UDSINI(T1)	;CALL INITIALIZE IF FOUND
	RET			;ADVANCE TO NEXT UNIT

;HERE TO INITIALIZE A DX20

RH2IDA:	SKIPA T1,[.UTDXA]	;SEARCH FOR DX20A (TAPE CONTROLLER)
RH2IDB:	MOVEI T1,.UTDXB		;OR FOR DX20B (DISK CONTROLLER)
	JRST RH2ITD		;GO SEARCH FOR DX20

IFN PUPSW,<
;HERE TO INITIALIZE A MEIS

RH2IME:	MOVX T1,.UTMEI		;SEARCH FOR A MEIS
	JRST RH2ITD		;AND TREAT LIKE A TAPE
>;IFN PUPSW

;HERE TO INITIALIZE A TM02/3

RH2ITM:	MOVEI T1,.UTTM2		;SEARCH FOR TM02
RH2ITD:	MOVEI P2,0		;IN CASE NOT FOUND IN TABLES
	CALL FNDUTP		; ...
	 CALL UDSINI(T1)	;FOUND - CALL INITIALIZE, RETURN KDB IN P2
	MOVE P3,P2		;COPY KDB TO WHERE COMMON CODE WANTS IT
	RET			;LOOP FOR MORE

;HERE TO INITIALIZE A TM78
RH2IT8:	MOVEI T1,.UTTM7		;SEARCH FOR TM78
	JRST RH2ITD		;GO SEARCH

;ROUTINE USED TO EXECUTE IOT FOUND AT CALL+1
;NOTE - INSTRUCTION MUST NOT CAUSE SKIP!

DEVXCT:	MOVE T4,@(P)		;FETCH IOT
	IOR T4,Q1		;OR IN DEVICE CODE
	XCT T4			;EXECUTE IT
	RETSKP			;RETURN - SKIP OVER INSTRUCTION

;ROUTINE TO SCAN CHANNEL/UNIT TABLES FOR TYPE GIVEN IN T1
;RETURNS TABLE ENTRY IN T1 (SKIP RETURN ON NOT FOUND)

FNDUTP:	MOVE T2,[PHYUNL,,PHYUNT] ;ENTRY FOR UNIT TABLE
FNDTPL:	HLRZ T3,0(T2)		;GET LH = TYPE CODE
	CAME T1,T3		;TYPES MATCH?
	AOBJN T2,FNDTPL		;NO - TRY NEXT
	JUMPGE T2,RSKP		;SKIP RETURN IF NO MATCH
	HRRZ T1,0(T2)		;MATCH - GET DISPATCH ADDRESS
	RET			;RETURN
;⊗ RH2POS RH2SIO RH2STK
	SUBTTL START I/O AND POSITIONING

;HERE TO START POSITIONING (P3 := UDB)

RH2POS:	HRRZ T1,UDBDSP(P3)	;ADDRESS OF DEVICE ROUTINE
	CALLRET UDSPOS(T1)	;START IT

;HERE TO START ACTUAL OPERATION (P3 := UDB , P4 := IORB)

RH2SIO:	HRRZ T1,CDBICP(P1)	;GET STATUS AREA
	SETZM 1(T1)		;CLEAR CS1
	HRRZ T1,UDBDSP(P3)	;DISPATCH TO DEVICE CODE
	CALL UDSSIO(T1)		;ATTEMPT TO START IO
	 JRST CLRCHL		;LOSE
	RETSKP			;WIN

;HERE TO STACK A SECOND COMMAND TO THE RH20

RH2STK:	HRRZ T1,UDBDSP(P3)	;GET UNIT DISPATCH
	CALLRET UDSSTK(T1)
;⊗ RH2HNG RH2RST RH2CHK
	SUBTTL HUNG, RESET AND CHECK ENTRIES
;HERE ON A HUNG TRANSFER
;CALLED WITH PI OFF

RH2HNG:	MOVEI T1,0		;CONTROLLER ONLY RESET
	CALL RH2RST		;RESET THE RH20
	HRRZ T1,UDBDSP(P3)	;GET DISPATCH ADDRESS
	CALLRET UDSHNG(T1)	;RESET CONTROLLER AND UNIT ALSO


;HERE TO RESET THE CHANNEL AND ALL UNITS
;T1/ 0 TO RESET JUST THE CHANNEL
;T1/ 1 FOR FULL RESET

RH2RST:	SKIPE T4,T1		;COPY ARG TO SAFE PLACE
	SETOM CDBCAD(P1)	;CLEAR PRIMARY CCW ADDRESS ONLY IF FULL RESET
	SETOM CDBCAD+1(P1)	;ALWAYS CLEAR SECONDARY ADDRESS
	MOVEI T1,CO.DEL!CO.DON	;DELETE ANY SECONDARY COMMAND
	CALL CHNCNO		;DO CONO
	MOVEI T1,CO.STP		;STOP ANY TRANSFER
	CALL CHNCNO		;DO CONO
	MOVEI T2,CO.RST		;CONO RESET
	SKIPE T4		;IF GENTLE RESET, SKIP MBINIT
	XCT RH2CNO(P1)		;DO CONO DIRECTLY
	HLRZ T2,CDBICP(P1)	;SETUP INTERRUPT VECTOR ADDRESS
	HRLI T2,(DO.IVI)
	CALL WTREGX		;WRITE IN CONTROLLER
	CALLRET CLRCHL		;AND REINIT CHANNEL


;HERE EVERY NOW AND THEN (ABOUT 1 SEC) TO CHECK PIA.

RH2CHK:	MOVE T1,CDBSTS(P1)	;GET STATUS BITS
	TXNE T1,CS.OFL		;IS RH20 MARKED OFFLINE?
	RET			;YES, DON'T CHECK ANYTHING
	XCT RH2CNI(P1)		;GET CONI
	ANDI T1,7		;MASK PIA
	LDB T2,CSYPIA		;GET WHAT IT SHOULD BE
	CAMN T1,T2		;ARE THEY THE SAME?
	RET			;YES
	HRRZ T2,CDBADR(P1)	;GET CHANNEL #
	BUG(PH2PIM,<<T2,CHAN>>)
	LDB T2,CSYPIA		;GET CORRECT PIA
	MOVSI T1,(CS.ACT)	;IS CHANNEL ACTIVE?
	TDNN T1,CDBSTS(P1)	; ??
	TRO T2,CO.ATE		;NO, SET ATTENTION EN
	XCT RH2CNO(P1)		;SEND TO CHANNEL
	RET
;⊗ RDREG RDREG3 RDREGX RDREGL RDRAE1 RDEXIT RDREGE RDRAE RDRAE2

	SUBTTL CHANNEL UTILITY ROUTINES

;ROUTINE TO READ A MASS-BUSS REGISTER
;CALL - C(T2) := REGISTER TO BE READ
;	C(P3) := UDB POINTER
;	C(P1) := CDB POINTER
;RETURNS VALUE IN T1 , PRESERVES T4

RDREG::	HRRZ T3,UDBAKA(P3)	;GET UNIT #
	SKIPL T2		;INTERNAL REGISTER?
	TLO T2,(DO.DRE)		;NO - TRY FIRST WITH DRAES ON
	TLOA T2,(T3)		;SET UNIT NUMBER
RDREG3::TLO T2,<(DO.DRE)>(Q2)	;UNIT # IN Q2
RDREGX:	MOVEI T3,↑D10		;INITIALIZE RETRY COUNTER
RDREGL:	XCT RH2DTO(P1)		;DATAO RH2,T2
	XCT RH2DTI(P1)		;NOW READ REGISTER (DATAI RH2,T1)
	PUSH P,T1		;SAVE RESULT
	XCT RH2CNI(P1)		;GET CONI
	TRNE T1,CI.RAE		;REGISTER ACC ERR?
	JRST RDRAE		;YES - BAD NEWS
RDRAE1:	POP P,T1		;NO - RESTORE RESULT
	SKIPGE T2		;READING AN INTERNAL RH REGISTER?
	RET			;YES - DONE
	TLNN T1,(DI.CPE)	;CONTROL BUS PAR ERR?
	TLNN T1,(DI.TRA)	;OR NOT TRA
	JRST RDREGE		;YES - ERROR
RDEXIT:	ANDI T1,177777		; CLEAR OUT GARBAGE
	RET			;EXIT

;HERE WHEN CBPE OR MISSING TRA

RDREGE:	SOJG T3,RDREGL		;LOOP IF RETRY STILL POSITIVE
	TLZ T2,(DO.DRE)		;TRY ONE MORE TIME - IF RAE, BOMB WORLD
	JUMPL T3,RDEXIT		;IF NOW NEGATIVE, DEPART, TRAGIC ERROR
	JRST RDREGL		;TRY AGAIN

;HERE WHEN A REGISTER ACCESS ERROR IS DETECTED

RDRAE:	PUSH P,T2		;SAVE ANOTHER REGISTER
	TLNE T2,(DO.DRE)	;DRAES?
	JRST RDRAE2		;YES - JUST CLEAR RAE
	MOVE T2,T1		;COPY CONI
	XCT RH2DTI(P1)		;GET DATAI
	PUSH P,T3
	HRRZ T3,CDBADR(P1)
	BUG(P2RAE1,<<T1,DATAI>,<T2,CONI>,<T3,CHAN>>)
	POP P,T3
	CALL CLRRAE		;RESET RAE
	POP P,T2		;RESTORE REGISTERS
	POP P,T1		; ...
	JRST RDEXIT		;ALL WE COULD DO...

RDRAE2:	CALL CLRRAE		;CLEAR ERROR
	POP P,T2
	JRST RDRAE1		;CONTINUE ATTEMPT
;⊗ WTREG WTREG3 WTREGX WTREGX WTRAE CLRRAE
;ROUTINE TO WRITE A MASS-BUSS REGISTER
;CALL - C(T2) := REGISTER TO BE WRITTEN & DATA
;	C(P1) := CDB , C(P3) := UDB
;PRESERVES T1,T4

WTREG::	HRRZ T3,UDBAKA(P3)	;GET UNIT #
	TLOA T2,<(DO.LR)>(T3)	;SET IN LHS AND LR ENABLE
WTREG3::TLO T2,<(DO.LR)>(Q2)	;SET LR AND UNIT NUMBER FROM Q2
IFE PUPSW,<
WTREGX:
>;IFE PUPSW
IFN PUPSW,<
WTREGX::
>;IFN PUPSW
	TLO T2,(DO.LR)		;WRITE A REGISTER WHEN THE DRIVE NUMBER DOESNT MATTER
	XCT RH2DTO(P1)		;ZAP
	PUSH P,T1		;SAVE REGISTER
	XCT RH2CNI(P1)		;GET CONI
	TRNE T1,CI.RAE		;REGISTER ACC ERR?
	JRST WTRAE		;YES - BAD NEWS
	POP P,T1		;NO - RESTORE REGISTER
	RET			;RETURN

;HERE WHEN RAE ON WRITE

WTRAE:	PUSH P,T3		;SAVE REGISTER
	MOVE T3,T1		;COPY CONI
	XCT RH2DTI(P1)		;GET DATAI
	PUSH P,T4
	HRRZ T4,CDBADR(P1)	;GET CHANNEL NUMBER
	BUG(P2RAE2,<<T1,DATAI>,<T2,DATA>,<T3,CONI>,<T4,CHAN>>)
	POP P,T4		;RESTORE REG
	MOVE T3,T2		;SAVE ATTEMPTED REGISTER
	CALL CLRRAE		;CLEAR RAE
	MOVE T2,T3		;RESTORE
	POP P,T3		;RESTORE
	POP P,T1
	RET

;HERE TO CLEAR RAE
;USES ONLY T2.

CLRRAE:	LDB T2,CSYPIA		;GET PIA
	TRO T2,CO.RAE		;CLEAR RAE
	XCT RH2CNO(P1)		;DO CLEAR
	RET
;⊗ CLRCHL CHNCNO

;ROUTINE TO CLEAR RH20 CONTROLLER OR DO A CONO
;PRESERVES T4

CLRCHL:: MOVEI T1,CO.CLR!CO.ATE	;ENABLE FOR ALL INTERRUPTS
CHNCNO:	LDB T2,CSYPIA		;GET PI ASSIGNMENT
	IOR T2,T1		;BUILD CONO
	XCT RH2CNO(P1)		;...
	RET			;RETURN
;⊗ CHSTRT CHST0 CHST1 CHST2

;ROUTINE TO START CHANNEL I/O
;CALLED WITH PI OFF
;C(T2) := DATAO , C(Q1) := FUNCTION , C(P3) := UDB POINTER
;C(Q1) = -1 IMPLIES ONLY DATAO FROM T2
;GIVES SKIP RETURN TO SHOW ALL OK

CHSTRT::SKIPE T2		;CHECK FOR VALID OPS
	SKIPN Q1		; ...
	BUG(RH2ICF)
	HRRZ T1,UDBAKA(P3)	;GET UNIT NUMBER
	SKIPL CDBXFR(P1)	;IF NON DATA TRANSFER
	CAMN T1,CDBXFR(P1)	;OR SAME AS UNIT HOLDING CHANNEL
	SKIPA Q2,[CO.ATE]	;CONSIDER ATTENTION ENABLE
	MOVEI Q2,0		;ELSE DISABLE ATTENTION INTERRUPTS
	CAMN Q1,[EXP -1]	;NON CHANNEL FUNCTION?
	JRST [	MOVEI Q1,0	;YES
		JRST CHST1]	;DO JUST ONE DATAO
	CAIGE Q1,50		;DATA TRANSFER OPERATION?
	JRST CHST1		;NO
	MOVEI Q2,0		;OPERATION USES CHANNEL, DISABLE ATTENTION
	PUSH P,T2		;SAVE DATAO
	MOVX T2,CS.CWP		;GET CHANNEL WRITE PARITY ERROR BIT
	ANDCAM T2,CDBSTS(P1)	;CLEAR IT IN THE CDB
	TRZE Q1,ERSTRY		;CHAN LIST ALREADY SET UP?
	JRST CHST0		;YES, SKIP SETUP
	MOVSI T2,(CS.ACL)	;TOGGLE CCW LIST
	XORM T2,CDBSTS(P1)	; ..
	MOVEI T1,CDBCCL(P1)	;DO setup in case of ECC retry
IFWAITS<
	SKIPE	CDBCCL+1(P1)	;Skip if this is a halt word
	SKIPA	T2,CDBEAD(P1)	;Here's where to halt in error recovery
>;IFWAITS
	MOVEI T2,CDBCCL+1(P1)
	TRZN Q1,ERETRY		;ECC RETRY?
	CALL PHYXFL		;NO - GET HEAD OF TRANSFER LIST (Set T1, T2)
	MOVE T4,T1		;REMEMBER BEGINNING OF LIST
	HRL T4,T2		;AND END OF LIST
IFWAITS<
	MOVEM	T4,CDBXFL(P1)
>
	MOVEI T3,CDBCAD(P1)	;GET ADDRESS OF PRIMARY CCW ADDRESS WORD
	SKIPL 0(T3)		;IS IT IN USE?
	AOS T3			;YES, STEP ADDRESS TO SECONDARY CCW ADDRESS WRD
	HRRZM T1,0(T3)		;STORE CCW ADDRESS IN APPROPRIATE WORD
	SETMM (T1)		;INSURE REFERENCE
	MAP T1,(T1)		;GET PHYSICAL ADDRESS
	TLZ T1,777760		;FLUSH ACCESS BITS ETC
	TLO T1,(CHJMP)		;BUILD CHANNEL JUMP
	HRRZ T3,CDBICP(P1)	;AND STORE IN
	MOVEM T1,(T3)		;CHANNEL ICPC
	MOVSI T3,(CHLST)	;SET LAST TRANSFER
	IORM T3,-1(T2)		;IN CCW LIST
	MOVE T1,T4		;RESTORE TRANSFER LIST POINTER
CHST0:	CALL BLKCNT		;GET BLOCK COUNT FROM TRANSFER LIST
	MOVNS T1		;AS NEGATIVE NUMBER
	STOR T1,DO2NBC,Q1	;STORE IN DATAO STCR
	TXO Q1,DO.CT2!DO2RCP!DO2SCS ;FINISH STCR DATAO
	POP P,T2		;RECOVER DATAO
	LOAD T1,DO2RGS,T2	;GET REGISTER
	CAIN T1,<(DO.DA)>←-↑D12	;DESIRED ADDRESS?
	TLC T2,(75B5)		;YES XOR TO PRODUCE SBAR

CHST1:	HRRZ T3,UDBAKA(P3)	;GET UNIT ADDRESS
	TLO T2,<(DO.LR)>(T3)	;SET UNIT AND LOAD
	XCT RH2DTO(P1)		;WRITE REG
	JUMPE Q1,CHST2		;SECOND DATAO TO DO?
	MOVE T2,Q1		;YES - GET CONTROL REGISTER
	TLO T2,<(DO.LR)>(T3)	;SET UNIT AND LOAD
	MOVEM T2,CDBICR(P1)	;SAVE INITIAL TCR FOR LOGGER
	XCT RH2DTO(P1)		;WRITE REG
	MOVEI T1,4		;DELAY **TEMP**
	SOJG T1,.		; **TEMP**
CHST2:	LDB T2,CSYPIA		;GET PI ASSIGNMENT
	IOR T2,Q2		;SET ATTENTION ENABLE IF DECIDED ABOVE
	XCT RH2CNO(P1)		;DO CONO
	RETSKP			;INDICATE SUCCESS
;⊗ RH2CCW RH2CW1 RH2CCA

;ROUTINE TO GENERATE A CHANNEL XFER WORD FOR THE RH20
;CALL - C(T1) := MODE,,+COUNT(1B0 IF BACKWARDS) , C(T2) := PHYSICAL-ADDRESS
;RETURNS+1(ALWAYS):
;T1/ CCW FOR THIS TRANSFER
;NOTE: THE MAXIMUM TRANSFER WHICH WILL ALWAYS WORK IS 1 PAGE.
;	THE CALLER IS EXPECTED TO WORRY ABOUT PAGE CROSSING PROBLEMS

RH2CCW:	PUSH P,T1		;SAVE ARGUMENT
	HRRZ T3,T1		;GET WORD COUNT
	HLRZS T1		;GET MODE IN CORRECT PLACE
	TRZ T1,(1B0)		;CLEAR BACKWARDS BIT FROM MODE
	CAIN T1,IRMWRD		;SPECIAL CASE CHECK FOR COMMON CASE
	JRST RH2CW1		;IS WORD MODE, DO IT FAST
	SKIPLE T1		;CHECK MODE FOR LEGALITY
	CAILE T1,IRMMAX		; ...
	JRST [	BUG(PH2IHM)
		MOVEI T1,IRMWRD	;ASSUME WORD MODE
		JRST .+1]
	IDIV T3,MODTAB(T1)	;CONVERT TO WORDS
	SKIPE T4		;ROUND?
	AOS T3			;YES
RH2CW1:	POP P,T4		;GET ARGUMENT BACK
	MOVSI T1,(CHXFR)	;BUILD CCW
	STOR T3,CHCNT,T1	;STORE COUNT IN T1
	STOR T2,CHADR,T1	;STORE ADDRESS IN T1
	SKIPGE T4		;BACKWARDS?
	TLO T1,(CHREV)		;YES
	RET			;RETURN




;RH2CCA - EXTRACT THE PHYSICAL MEMORY ADDRESS FROM A CCW TRANSFER WORD.
;ARGUMENT:
;  T1/	CCW WORD
;RETURNS:
;  T1/	ADDRESS, OR ZERO IF NONE


RH2CCA:	LOAD T1,CHADR,T1	;GET PHYSICAL ADDRESS FROM CCW
	RET			;DONE
;⊗ CKERR CKERR3 CKERR1 CKERR2

;ROUTINE TO DETERMINE IF ANY CHANNEL DEPENDENT ERROR OCCURED.
;NOTICE:  CONI OVERRUNS (LONG WORD COUNTS) ARE IGNORED IF THE TRANSFER WAS
;TO A DISK AND THE LENGTH OF THE TRANSFER WAS NOT AN EXACT MULTIPLE OF
;THE SECTOR SIZE.  (IN THIS CASE, WE EXPECT THE LONG WORD COUNT).
;RETURN +1 IF ERROR , +2 IF NONE


CKERR::	MOVE T2,CDBCNI(P1)	;GET CONI AT INTERRUPT
	ANDI T2,CI.ERR		;ANY ERRORS?
	HRRZ T1,CDBICP(P1)	;CHECK CHANNEL
	SKIPN T1,1(T1)		;GET STATUS WORD 1
	JUMPE T2,RSKP		;IF NO LOGOUT AND  NO  CONI ERRS, GOOD XFR
	JUMPN T2,[CAIN T2,CI.OVR ;CONI ERRORS, ONLY OVERRUN?
		TXNN T1,CS1SWC	;AND WORD LENGTH ERROR FROM LOGOUT?
		CALL CKERR1	;NO, FLAG AN ERROR
		JRST .+1]	;PROCEED
	TXNE T1,CS1NSE		;SBUS ERROR?
	TXNE T1,CS1MPE!CS1NXM!CS1RHE!CS1OVR ;OR OTHER DEFINITE ERRORS?
	JRST [	TXNE T1,CS1MPE	;YES, A PARITY ERROR?
		AOS CDBPAR(P1)	;YES - NOTE
		TXNE T1,CS1NXM	;NONEXISTANT MEMORY?
		AOS CDBNXM(P1)	;YES - NOTE
		TXNE T1,CS1OVR	;AN OVERRUN?
		AOS CDBOVR(P1)	;YES - NOTE
		CALL CKERR1	;INDICATE SOME ERROR HAPPENED
		JRST .+1]	;AND CONTINUE WITH LENGTH ANALYSIS
	MOVX T2,CS1LWC!CS1SWC	;WORD COUNT ERROR BITS
	MOVE T3,UDBSTS(P3)	;GET STATUS BITS
	TXNE T3,US.TAP		;MAGTAPE?
	TXZ T2,CS1LWC		;YES - IGNORE RECORD SHORTER THAN BUFFER
	TDNN T1,T2		;LENGTH ERROR?
	JRST CKERR2		;NO - CHECK COUNT FROM LOGOUT AREA
	TXNN T1,CS1LWC		;RECORD TOO SHORT?
	TXNN T3,US.DSK		;OR NOT A DISK?
	JRST CKERR3		;YES, THEN MARK THE ERROR
	CALL PHYCNT		;GET LENGTH OF TRANSFER WE TRIED
	MOVEI T2,PGSIZ		;AND SIZE OF A PAGE
	MOVE T3,UDBSIZ(P3)	;GET POINTER TO SIZE TABLE
	IDIV T2,SECPAG(T3)	;COMPUTE LENGTH OF DISK SECTOR
	TRNE T1,-1(T2)		;IS THE LENGTH ERROR TO BE EXPECTED?
	JRST CKERR2		;YES, THAT'S OK THEN
CKERR3:	MOVX T1,IS.RTL		;FLAG LENGTH ERROR IN IORB
	IORM T1,IRBSTS(P4)	; ...
CKERR1:	MOVX T2,IS.DVE		;DECLARE A DEVICE ERROR
	IORM T2,IRBSTS(P4)	; ...
	RET

CKERR2:	MOVX T1,IS.DVE		;WERE ANY ERRORS DETECTED ALREADY?
	TDNE T1,IRBSTS(P4)	; ???
	RET			;YES - ERROR
NOWAITS<
	SKIPL 0(P4)		;CHECK FOR SHORT IORB
	RETSKP			;RETURN OK FOR LONG ONES
	HRRZ T1,CDBICP(P1)	;GET ADDRESS OF LOGOUT
	MOVE T1,2(T1)		;GET ADDRESS OF LOGOUT DONE
	MOVEI T4,-CST5(P4)	;GET ADDRESS TO FINISH AT
	LOAD T3,LG2DBP,T1	;PAGE NUMBER FROM LOGOUT
	SUBI T3,1
	CAME T3,T4		;BETTER BE THE SAME
	JRST [	LDB T1,IRYFCN	;GET THE FUNCTION CODE
		CAIN T1,IRFRVC	;READ VALIDITY?
		AOSE T3		;WAS IT FOR PAGE 0 (SKIP FUNCTION)?
		BUG(ILLGO)
		RETSKP]		;HERE IF READ VALIDITY, AND PAGE 0
>;NOWAITS
	RETSKP			;NO
;⊗ ERRCNI ERCNI1

;ROUTINE TO GET CONI AND DATAI'S ON ERROR
;RETURNS T1=CONI, T2=PTCR, T3=PBAR
ERRCNI::HRRZ T1,CDBICP(P1)	;GET CHANNEL LOGOUT AREA
	DMOVE T2,(T1)		; CS0,1
	DMOVEM T2,CDBCS0(P1)	;SAVE
	TXNE T3,CS1NSE		;A NON-SPECIFIC MEMORY ERROR?
	TXNE T3,CS1MPE!CS1NXM	;ANY MEMORY ERRORS?
	CALL [	JUMPGE T3,R	;IF NO STATUS, NO REPORT
		SAVET		;YES. SAVE TEMPS
		MOVE T2,T3	;COPY STATUS 1
		MOVE T3,2(T1)	;GET UPDATED CCW
		CAMN T3,CDBCS2(P1) ;PREVIOUS ERROR ON SAME PAGE?
		CAME T2,CDBCS0(P1) ;AND A MEM ERROR ALSO?
		SKIPA		;NO. REPORT THIS ONE THEM
		RET		;YES. NO REPOORTING RETRIES
		HRRZ T1,CDBADR(P1) ;GET CHANNEL #
		LSH T1,2	;*4
		ADDI T1,<RH2.0>←<11-35>
		CALLRET APRRPT]	;AND DO REPORT
	MOVE T2,2(T1)		;GET CS2
	MOVEM T2,CDBCS2(P1)	;SAVE
	MOVE T1,(T1)		;GET ICCW
	TLNN T1,(CHXFR)		;IF NOT A JUMP,
	JRST ERCNI1		;DONT TRY FOR CCWS
	LOAD T1,CHADR,T1	;GET ADDRESS PART OF JUMP
	LSH T1,-PGSFT		;AS A PAGE
	PIOFF			;INTERLOCK WINDOW
	CALL MAPRCA		;MAP THIS PAGE
	HRRZ T2,CDBICP(P1)	;GET CHAN BLOCK AGAIN
	MOVE T3,(T2)		;GET JUMP CCW BACK
	ANDI T3,777		;GET ADDRESS WITHIN PAGE
	ADD T3,T1		;GET INDEX INTO WINDOW PAGE
	MOVE T4,(T3)		;GET FIRST POSSIBLE CCW
	MOVEM T4,CDBCC1(P1)	;SAVE IN CDB
	ADDI T3,1		;INCREMENT POINTER
	MOVEI T4,0		;DONT STORE GARBAGE IF OVERFLOW
	TRNE T3,777		;STILL WITHIN WINDOW BOUND?
	MOVE T4,(T3)		;YES - FETCH SECOND POSSIBLE CCW
	MOVEM T4,CDBCC1+1(P1)	;SAVE IN CDB
	CALL UNMRCA		;FREE WINDOW
	PION			;ALLOW INTERRUPTS AGAIN
ERCNI1:	MOVSI T2,(DO.BA1)	;READ PRIMARY BLOCK ADDRESS REGISTER
	CALL RDREGX
	MOVE T4,T1		;SAVE BAR IN T4
	MOVSI T2,(DO.CT1)	;READ PRIMARY TRANSFER CONTROL REGISTER
	CALL RDREGX
	MOVE T2,T1		;INTO T2
	MOVE T3,T4		;GET BAR INTO T3
	MOVE T1,CDBCNI(P1)	;GET CONI
	RET
;⊗ BLKCNT BLKCNL BLKCT1

;BLKCNT - ROUTINE TO COMPUTE NUMBER OF DEVICE BLOCKS NEEDED TO DO I/O
;  T1/	END OF TRANSFER LIST,,BEGINNING OF TRANSFER LIST
;  P3/	UDB
;  P4/	IORB
;RETURNS+1(ALWAYS):
;  T1/	NUMBER OF DEVICE BLOCKS NEEDED FOR THIS TRANSFER LIST


BLKCNT:	MOVX T2,US.TAP		;TAPE?
	TDNE T2,UDBSTS(P3)	; ???
	JRST BLKCT1		;YES

NOWAITS<			;This code stupidly assumes contiguous list
	HLRZ T2,T1		;GET TAIL OF CCW LIST
	SUBM T1,T2		;SUBTRACT TO GET NEGATIVE LENGTH OF LIST
	HRLZ T2,T2		;START BUILDING AOBJN POINTER
	HRR T2,T1		;INSERT HEAD ADDRESS TO FINISH IT
	SETZ T3,		;INITIALIZE TOTAL
BLKCNL:	MOVE T1,(T2)		;GET NEXT CCW WORD
	LOAD T1,CHCNT,T1	;EXTRACT WORD COUNT
	ADDB T1,T3		;ADD INTO TOTAL
	AOBJN T2,BLKCNL		;LOOP OVER ALL CCW WORDS
>;NOWAITS


IFWAITS<			;This code follows the CCW list until it finds a halt
	SETZ	T3,		;INITIALIZE TOTAL
	HRRZ	T1,T1
	TLO	T1,400000	;Set negative: meaning EXEC virtual addresss
BLKCNL:	SKIPGE	T1		;Skip if we lapsed into physical addressing
	SKIPA	T2,(T1)		;Fetch T2 from exec virtual address in T1.  SKIP
	CALL	PHYMOV		;fetch T2 from physical address in T1
	TLNN	T2,(CHXFR)	;Is this a data CCW?
	JRST	BLKCNM		;No.
	LOAD	T4,CHCNT,T2	;Yes, Get the WORD COUNT
	ADD	T3,T4
	TLNN	T2,(CHLST)	;Is this marked as the last transfer?
	AOJA	T1,BLKCNL	;Not the last.  Loop
	AOJA	T1,BLKCNX	;Point to putative halt word

BLKCNM:	TLNN	T2,(CHJMP)	;Is this a jump word?
	JRST	BLKCNX		;No, it must be a halt word (all zero)
	LOAD	T1,CHADR,T2	;Copy address to T1.  Now T1 is PHYSICAL Address
	JRST	BLKCNL

BLKCNX:	HLRZ	T2,CDBXFL(P1)	;Get the specified ending address of XFR
	SKIPL	T1		;Skip if in virtual addresses
	MAP	T2,(T2)		;Get the corresponding physical address
	MOVE	T4,T1		;(Save T1 for BUG)
	XOR	T4,T2
	TDNE	T4,[17777777]	;Test for equality
	BUG	(BLKXFL,<<T1,CLENDA>,<T2,CDBXLA>,<P1,CDB>>)
	MOVE	T1,T3
>;IFWAITS

	MOVE	T2,UDBSIZ(P3)	;GET POINTER TO DISK SIZE TABLE
	IMUL	T1,SECPAG(T2)	;MULTIPLY BY NUMBER OF SECTORS IN A PAGE
	ADDI	T1,PGSIZ-1	;ROUND UP IF DOING PARTIAL SECTORS
	LSH	T1,-PGSFT	;DIVIDE BY PAGE SIZE TO GET SECTORS NEEDED
	RET			;DONE

BLKCT1:	MOVEI T1,1		;MAGTAPE IS ALWAYS 1
	RET
;⊗ REVCCW REVCC1 REVCC2 REVCC3 REVCC4 REVCC5 REVCC6 REVCC7 REVIOW
;REVCCW - ROUTINE TO REVERSE THE CHANNEL IOWD LISTS FOR REREAD IN OPPOSITE DIRECTION
;  T2/	WORDCOUNT OF RECORD
;  P4/	IORB
;RETURNS+1(ALWAYS):
;T1/ORIG LH OF CHANGED IOWD,,ITS ADDRESS IF IT GOT CHANGED (CHLST LIT, WDCNT CHANGED)
;  AND IOWD LIST SET UP TO READ IN THE OPPOSITE DIRECTION

REVCCW::JUMPE T2,[SETZ T1,
		  RET]		;WORDCOUNT OF 0 IS HIGHLY ILLEGAL
	SAVEQ			;NEED SOME ACS
	SETZ Q2,		;Q2 WILL POINT AT CHANGED IOWD
	HRRZ T3,IRBXFL(P4)	;GET START OF LIST
REVCC1:	SKIPN T1,(T3)		;GET AN IOWD
	SOJA T3,REVCC4		;UNTERMINATED LIST, ENDS AT PREVIOUS IOWD
	LOAD T4,CHCNT,T1	;GET WORDCOUNT OF IOWD
	CAMLE T4,T2		;LAST IOWD?
	JRST REVCC2		;YES, IO LIST IS TOO LONG. FIX IT
	SUB T2,T4		;ACCOUNT FOR THE WORDS IN THIS IOWD
	JUMPE T2,REVCC3		;LIGHT CHLST IF IOWD FINISHES THE RECORD
	TLNE T1,(CHLST)		;NO. END OF LIST (RECORD TOO LONG)?
	JRST REVCC4		;YES, WE'RE AT END. REVERSE THEM
	AOJA T3,REVCC1		;NOT AT END. TRY NEXT IOWD
REVCC2:	STOR T2,CHCNT,T1	;FIX IOLIST - SET CORRECT LENGTH
REVCC3:	TLO T1,(CHLST)		;INDICATE IT IS THE LAST IOWD
REVCC4:	MOVE Q2,(T3)		;SAVE ORIGINAL IOWD (LH)
	HRR Q2,T3		;SAVE ITS ADDRESS
	MOVEM T1,(T3)		;SAVE MODIFIED IOWD WHERE THE RH20 WILL SEE IT
	HRRZ T2,IRBXFL(P4)	;POINT T2 AT START OF LIST
REVCC5:	CAML T2,T3		;HAVE A PAIR OF IOWDS TO EXCHANGE?
	JRST REVCC6		;NO, AT A SINGLE IOWD (MIDDLE), OR DONE
	MOVE Q1,(T3)		;GET LAST IOWD
	MOVE T1,(T2)		;GET 1ST IOWD
	TLZE Q1,(CHLST)		;LAST IOWD?
	TLO T1,(CHLST)		;YES, LIGHT BIT IN CORRESPONDING NEW IOWD
	CALL REVIOW		;SET IT FOR READ OPPOSITE
	MOVEM T1,(T3)		;AND SAVE AWAY
	MOVE T1,Q1		;GET LAST IOWD
	CALL REVIOW		;REVERSE IT
	MOVEM T1,(T2)		;AND SAVE
	SUBI T3,1		;POINT AT NEXT TO LAST
	AOJA T2,REVCC5		;POINT AT 2ND, AND REVERSE NEXT PAIR
REVCC6:	CAME T2,T3		;EVEN NO OF IOWDS?
	JRST REVCC7		;YES, DONE
	MOVE T1,(T2)		;NO, GET MIDDLE IOWD (OR ONLY ONE)
	CALL REVIOW		;REVERSE IT
	MOVEM T1,(T2)		;SAVE UPDATED IOWD
REVCC7:	MOVE T1,Q2		;RETURN VALUE IN T1
	RET			;AND WE'RE DONE

;REVERSE 1 IOWD
REVIOW:	LOAD T4,CHCNT,T1	;GET COUNT OF IOWD
	TLCE T1,(CHREV)		;REVERSE DIRECTION
	JRST [SUBI T1,-1(T4)	;WAS REVERSE, SET FOR FORWARD
	      RET]
	ADDI T1,-1(T4)		;WAS FORWARD, POINT AT END
	RET
;⊗ RH2INT RH2IN1 ATCHKN ATCHK0 ATCHK1 ATCHK2 NOATTN NOATT1 XFR XFR1 XFR3 XFR4 XFR2

	SUBTTL INTERRUPT ROUTINE

;ENTER FROM PHYSIO W/ C(P1) := CDB CAUSING INTERRUPT.

RH2INT:	XCT RH2DTI(P1)		;GET REGISTER RH WAS CONNECTED TO
	TLZ T1,007770		; CLEAR UNNEEDED BITS
	MOVEM T1,CDBRST(P1)	;SAVE FOR EXIT SEQUENCE TO RESTORE (DATA0 RH,CDBRST)
	XCT RH2CNI(P1)		;GET CONI
	MOVEM T1,CDBCNI(P1)	;AND SAVE FOR ERROR LOGGING, ETC.
	TRNN T1,CI.RAE		;IS RAE SET?
	JRST RH2IN1		;NO - GO ON
	MOVE T2,T1		;COPY CONI
	XCT RH2DTI(P1)		;GET DATAI
	HRRZ T3,CDBADR(P1)	;GET CHANNEL ADDR
	BUG(P2RAE3,<<T1,DATAI>,<T2,CONI>,<T3,CHAN>>)
	CALL CLRRAE		;CLEAR RAE
	MOVE T1,CDBCNI(P1)	;RECOVER CONI
RH2IN1:	MOVEI Q1,0		;INITIAL UNIT #
	TRNN T1,CI.ATN		;ANY ATTENTIONS?
	JRST NOATTN		;NO
	MOVSI T2,(DO.AS)	;SET TO READ ATTENTION SUMMARY REGISTER
	CALL RDREGX		; READ (ANY UNIT WILL DO)
	ANDI T1,377		;MASK OUT IMPOSSIBLE BITS
	TRNN T1,377		;ANY ATTENTION ON?
	JRST NOATTN		;NO - CHECK DATA TRANSFER
ATCHKN:	LSHC T1,-1		;SHIFT 1 BIT OVER
	JUMPGE T2,ATCHK2	;JUMP IF NOT THIS UNIT
	PUSH P,T1		;SAVE REMAINDER
	HRRZ T1,Q1		;GET UNIT #
	CALL SETUDB		;SET UP P3 := UDB ADDRESS, T2 := DISPATCH
	JUMPE P3,ATNXU		;SPURIOUS INTERRUPT IF NO UNIT THERE
	SETZ P4,		;P4=0 IF NO ERRORS
	CALL UDSATN(T2)		;INFORM LOWER LEVEL
				;SETS LH(Q1) TO -1 IF POS DONE INTERRUPT
	 JRST ATCHK0		;NORMAL RETURN
	POP P,T1		;"REALLY-A-TRANSFER-DONE-INTERRUPT" RETURN
	JRST XFR3		; (TM78 SENSE AFTER IO). CLEAN UP XFER
ATCHK0:	JUMPN P4,ATNIRB		;JUMP IF IORB DONE OR ERROR
ATCHK1:	POP P,T1		;RESTORE ATTENTION REGISTER
ATCHK2:	SKIPE T1		;DONE IF ZERO
	AOJA Q1,ATCHKN		;INCR UNIT # AND TRY NEXT

NOATTN:	MOVE T1,CDBCNI(P1)	;GET CONI AT INTERRUPT
	SKIPL T4,CDBXFR(P1)	;TRANSFER IN PROGRESS?
	JRST XFR		;YES - ANALYZE
	TRNE T1,CI.DON		;IS DONE UP NOW?
	JRST BADDON		;EVIL EVENT
NOATT1:	HLLE P4,Q1		;NO TRANSFER, SET P4=-1 OR 0
IFE STANSW,<
	RETSKP			;AND LET PHYSIO DO ITS THING
>;IFE STANSW
IFN STANSW,<
	CAIG P4,0		;IF N,,0 - SPECIAL FROM RP4ATU
	RETSKP			;ELSE LET PHYSIO DO ITS THING
;All of the code here is needed because the code here
; is unable to do anything interesting for more than one unit
; at a time.  We could get attn done from one and another
; interrupt from another.  The code here is designed to handle
; the case where RP4ATU has found that a shared drive is now
; available.  Its sets Q1 to indicate that we should ask
; PHYSIO to restart I/O on that drive.  This is fine, but if
; another kind of interrupt happened at the same time, it is
; possible that we will go to XFR and handle it, or that
; P1 could now be pointing to the UDB of a different unit.
; Thus the code here is designed to make sure that we are still
; set up for the same unit that RP4ATU found.  If so, we set P4
; to -1, which is a flag to PHYINT to continue I/O on the unit.
; if not, we clear P4.  In this case we are ignoring the fact
; that the shared drive is now available.  Since the US.OIR
; bit is still set, the once a second code will eventually notice
; that the drive is back and restart I/O.  RP4ATU set LH(Q1) to
; unit number+1.  The +1 is to guarantee that it is non-zero,
; since zero is a null request.
	HLRZ P4,Q1		;GET UNIT NUMBER+1, FROM RP4ATU REQUEST
	ADD P4,P1		;ACCESS BELOW IS CDBUDB+.P4-1(P1)
	CAME P3,CDBUDB-1(P4)	;COMPARE CURRENT UNIT WITH RP4ATU'S
	JRST [  SETZ P4,	;WRONG UNIT, FORGET REQUEST
		RETSKP]
	MOVX T1,<US.OFS!US.OIR!US.OMS> ;THIS IS GOING TO WORK, SO
	ANDCAM T1,UDBSTS(P3)	;CLEAR BITS SAYING WE'RE IN TROUBLE
	SETO P4,		;NOW ASK FOR CONTINUING I/O
	RETSKP			;FROM PHYINT
>;IFN STANSW
XFR:	TRNN T1,CI.DON		;IS CONTROLLER BUSY?
	JRST [	SETZ P4,	;YES, MUST BE FROM ERRPSI (PHYRP4)
		RETSKP]		; SO JUST DISMISS THE INTERRUPT
	SKIPLE WREQ		;NEED TO CHECK FOR CHANNEL WRITE PARITY ERRORS?
	CALL CKCWP		;YES, DO SO
	MOVSI T2,(DO.CT1)	;READ RH20 CONTROL REGISTER
	CALL RDREGX
	LOAD T1,DI1UNS,T1	;GET UNIT RH20 IS TALKING TO
	CAME T1,T4		;RIGHT UNIT?
	JRST WRNGUN		;NO, TRY AGAIN
	CALL SETUDB		;YES, SET UP P3, T2
XFR1:	CALL UDSINT(T2)		;CALL INTERRUPT SERVICE
	 JRST XFR2		;INDICATE ERRORS
	JUMPLE P4,XFR3		;DON'T SET BITS IF NO IORB
	MOVX T1,CS.CWP		;GET CHANNEL WRITE PARITY BIT
	TDNE T1,CDBSTS(P1)	;CHANNEL WRITE PARITY ERROR DETECTED ON THIS CHANNEL?
	JRST XFR4		;YES, FLAG THEM AS SUCH
XFR3:	SETOM T1		;T1:=-1
	EXCH T1,CDBCAD+1(P1)	;GET OLD CONTENTS, CLEAR SECONDARY CCW ADDR WORD
	MOVEM T1,CDBCAD(P1)	; AND MOVE IT INTO THE PRIMARY WORD
	MOVSI T1,(CS.AC2)	;STACKED COMMANDS?
	TDNN T1,CDBSTS(P1)	; ??
	JRST [	CALL CLRCHL	;NO - RESET CHANNEL
		RETSKP]		;INDICATE NO ERRORS
	MOVEI T1,CO.DON		;YES - JUST CLEAR DONE
	CALL CHNCNO		; ...
	RETSKP

;HERE WHEN THERE WAS A CHANNEL WRITE PARITY ERROR DETECTED BY THE APR THAT
;WAS CAUSED BY THIS CHANNEL.  P4/IORB

XFR4:	MOVX T1,IS.DVE		; AND DEVICE ERROR BIT FOR IORB
	IORM T1,IRBSTS(P4)	;YES, SET DEVICE ERROR BIT

;HERE WHEN THERE HAS BEEN AN ERROR DETECTED AT A LOWER LEVEL

XFR2:	SETOM CDBCAD(P1)	;CLEAR PRIMARY CCW ADDRESS WORD
	SETOM CDBCAD+1(P1)	; AND SECONDARY
	MOVEI T1,CO.DEL		;DELETE STACKED COMMAND
	CALL CHNCNO		; ...
	MOVEI T1,CO.DON		;EXPLICITLY CLEAR DONE FIRST
	CALL CHNCNO		; ...
	CALLRET CLRCHL		;AND RESET ERRORS
;⊗ ATNIRB WRNGUN WRNGU1 ATNXU BADDON

;HERE IF AN IORB FINISHES DURING ATTENTION PROCESSING OR
;IF THERE WAS A SEEK ERROR

ATNIRB:	HRRZS P4		;CLEAR ERROR FLAG
	POP P,(P)		;SCRAP STACK
	RETSKP			;RETURN TO PHYSIO, NEVER SET CHAN ERR

;HERE IF WE GOT AN INTERRUPT FROM THE WRONG DRIVE
WRNGUN:	MOVE T1,T4		;DRIVE PHYSIO IS TALKING TO
	CALL SETUDB		;SET UP P3
	PUSH P,T2		;SAVE DISPATCH ADDRESS
	CALL SETIRB		;SET UP P4
	MOVE T2,IRBSTS(P4)	;DRIVE STATUS
	TLOE T2,(IS.WGU!IS.ERR)	;HAVE WE SEEN THIS ERROR BEFORE?
	JRST WRNGU1		;YES, BADNESS
	MOVEM T2,IRBSTS(P4)	;NO, SAVE ERROR BITS
	POP P,T2		;RETRIEVE DISPATCH ADDRESS
	JRST XFR1		;AND RETRY THE OPERATION

WRNGU1:	MOVEM T2,IRBSTS(P4)	;SAVE ERROR BITS
	LDB T2,IRYFCN		;IF THIS IS A WRITE WE'D BETTER HALT
	CAIE T2,IRFWRT		;BEFORE WE WIPE OUT SOME DISK
	CAIN T2,IRFWTF
	BUG (PH2WUI)
	JRST PA1		;RETURN AN ERROR

;HERE ON AN INTERRUPT FROM A NONEXISTANT UNIT.

ATNXU:	PUSH P,Q1		;SAVE REGISTER
	HRRZ Q2,Q1		;GET UNIT NUMBER
	CALL RH2UNS		;SELECT UNIT
	HRRZ Q2,Q1		;GET UNIT NUMBER
	ADD Q2,P1		;POINT TO CDB+UNIT
	MOVEM P3,CDBUDB(Q2)	;STORE NEW ENTRY
	POP P,Q1		;RESTORE REGISTER
	MOVEI T2,1		;CLEAR ATTENTION DIRECTLY
	LSH T2,(Q1)		;POSITION BIT
	HRLI T2,(DO.AS)		;IN ATTENTION SUMMARY REGISTER
	CALL WTREGX		;SPECIAL REGISTER, NEEDS NO UNIT
	JRST ATCHK1		;AND CONTINUE LOOKING


;HERE WHEN DONE IS UP AND THE CHANNEL IS NOT OCCUPIED.

BADDON:	HRRZ T2,CDBADR(P1)	;GET CHANNEL #
	BUG(PH2DNA,<<T2,CHAN>>)
	LDB T2,CSYPIA		;GET PI ASSIGNMENT
	TRO T2,CO.RAE!CO.XFR!CO.ATE!CO.DON ;CLEAR RAE,XFRERR,DON. 
	XCT RH2CNO(P1)		;SEND TO CHANNEL
	SKIPLE WREQ		;NEED TO CHECK FOR CHANNEL WRITE PARITY ERRORS?
	CALL CKCWP		;YES, DO SO
	SETOM CDBCAD(P1)	;CLEAR PRIMARY AND SECONDARY CCW
	SETOM CDBCAD+1(P1)	; ADDRESS WORDS
	JRST NOATT1
;⊗ CKCWP CKCWP1 CKCWP2 CKCWP3

;ROUTINE TO CALL MEMSCN FOR EACH TRANSFER WORD IN THE CHANNEL COMMAND LIST
;IF A CHANNEL WRITE PARITY ERROR WAS DETECTED BY THE APR WHILE THIS
;TRANSFER WAS GOING.  FIRST CHECK TO SEE IF THE FUNCTION CODE FROM THE PTCR
;WAS FOR A WRITE TO MEMORY (READ FROM DEVICE) AND THEN FOLLOW THE CHANNEL
;COMMAND LIST CALLING MEMSCN FOR EACH TRANSFER WORD.
;CALL:
;    P1/CDB
;RETURN +1 ALWAYS WITH CS.CWP SET IN CDB+CDBSTS AND CDB+CDBPAR
;	   INCREMENTED IF A MEMORY ERROR WAS DETECTED BY MEMSCN
;PRESERVES THE T AND Q AC'S

CKCWP:	SAVET			;SAVE THE T AC'S
	MOVX T2,DO.CT1		;REGISTER SELECT FOR PTCR
	CALL RDREGX		;READ IT
	LOAD T1,DI1FNC,T1	;GET THE FUNCTION CODE
	CAIGE T1,70		;WAS THE FUNCTION A MEMORY WRITE (DEVICE READ)?
	RET			;NO, JUST RETURN
	SAVEQ			;SAVE THE Q AC'S
	SKIPG Q1,CDBCAD(P1)	;GET THE ADDRESS OF THE CHANNEL COMMAND LIST
	RET			;CONFUSION?
CKCWP1:	MOVE Q2,(Q1)		;GET THE NEXT WORD IN THE LIST
	TXNN Q2,CHXFR		;WAS THE OPCODE A TRANSFER?
	RET			;NO, DONE WITH THE LIST
	LOAD T1,CHADR,Q2	;GET THE ADDRESS FROM THE CCW
	JUMPE T1,CKCWP3		;NO ADDRESSES TO SCAN IF CHANNEL SKIP
	LOAD T2,CHCNT,Q2	;GET THE WORD COUNT TO SCAN
	TXNE Q2,CHREV		;WAS IT A REVERSE TRANSFER?
	SUBI T1,-1(T2)		;YES, SET THE ADDRESS TO THE BEGINNING
CKCWP2:	CALL MEMSCN		;SCAN THE WORDS DESCRIBED BY THIS POINTER
	 JRST [	MOVX T1,CS.CWP	;GET CHANNEL WRITE PARITY ERROR BIT
		IORM T1,CDBSTS(P1) ;SET IT IN THE CDB
		AOS CDBPAR(P1)	;INCREMENT THE PARITY ERROR COUNT IN THE CDB
		JRST CKCWP3]	;CONTINUE
CKCWP3:	TXNN Q2,CHLST		;TRANSFER AND HALT?
	AOJA Q1,CKCWP1		;NO, INCREMENT THE ADDRESS AND TRY NEXT ONE
	RET			;YES, DONE WITH THE LIST
;⊗ ECCADR ECCUCL

NOWAITS<		;ENTIRE PAGE

	SUBTTL ECC CHANNEL LOGIC


;THE FOLLOWING ROUTINES, AS IN SEVERAL OTHER PLACES, ASSUME THE
;CCW LIST IS EXACTLY ONE WORD LONG.

;HERE TO RETURN THE PHYSICAL ADDRESS OF THE START OF THE LAST BLOCK
;TRANSFERRED.  CALL:
;  P1/  CDB
;  P3/  UDB
;RETURNS:  +1: ALWAYS
;		T1/  PHYSICAL ADDRESS OF START OF LAST SECTOR TRANSFERRED


ECCADR::MOVEI T1,PGSIZ		;GET SIZE OF A PAGE
	HRRZ T2,UDBSIZ(P3)	;AND POINTER TO DISK SIZE TABLE
	IDIV T1,SECPAG(T2)	;COMPUTE SIZE OF A SECTOR
	MOVEI T2,-1(T1)		;CREATE MASK
	HRRZ T1,CDBICP(P1)	;GET STATUS AREA
	MOVE T1,2(T1)		;GET CS2, THE UPDATED CCW
	LOAD T1,CHADR,T1	;GET ADDRESS PART
	SUBI T1,1		;BACK UP INTO LAST SECTOR TRANSFERRED
	TRZ T1,(T2)		;MASK TO START OF SECTOR
	RET			;DONE



;HERE TO UPDATE THE CCW LIST TO TRANSFER ANY DATA AFTER THE SECTOR
;WHICH WAS ECC CORRECTED.
;
;	CALL ECCUCL
;RETURNS+1:
;	NO MORE DATA TO TRANSFER
;RETURNS+2:
;	UPDATED CCW AT CDBCCL(P1)
;T1/ NUMBER OF WORDS TRANSFERED INCLUDING SECTOR ECC CORRECTED


ECCUCL::HRRZ T4,CDBICP(P1)	;GET STATUS AREA
	MOVE T1,2(T4)		;GET UPDATED CCW
	LOAD T3,CHCNT,T1	;GET WORD COUNT
	JUMPE T3,R		;IF 0, ALL DONE.
	TLO T1,(CHXFR!CHLST)	;FORCE LAST TRANSFER
	MOVEM T1,CDBCCL(P1)	;STORE IN CDB
	SETZM CDBCCL+1(P1)	;CLEAR TAIL
	CALL PHYCNT		;GET IORB COUNT
	SUB T1,T3		;LESS WORDS TRANSFERRED
	RETSKP

>;NOWAITS
;WAITS code for ECC ;⊗ ECCCWF ECCFIX ECFCWL

IFWAITS<			;Entire page, not including TNXEND

;Unlike the routines above, these assume the CCW list is incredibly hairy.

;JJW 9/85 - This code was difficult for me to understand, so here are some
;comments that will hopefully help the next person.  Comments below are for
;RP07 disks and may not apply to other types.

;The disk stores ECC data on a per-sector basis.  Whenever a sector with bad
;ECC bits is read, the transfer is stopped (unless the Inhibit flag is on but
;we'll ignore that), and information needed to correct the error is returned.
;This consists of an 11-bit mask which must be XORed into the data at a given
;position within the sector.  More exactly, the 36*128 bits of data in the
;sector and 32 ECC bits following it are treated as a single bit-stream, and any
;contiguous 11 bits within it may be indicated.  Errors not contained within 11
;consecutive bits (called a "burst") are uncorrectable or undetectable.

;When we started the transfer, we presented the channel with a CCW list.  CCWs
;do not need to start or end on disk sector boundaries; a new CCW is generally
;started whenever data is not contiguous in physical memory, i.e. when crossing
;a page boundary, or reading into user core in buffered mode.  Thus the sector
;being corrected may be handled by one or more CCWs.  After correcting the data
;that had ECC errors, we need to restart the transfer, which might mean
;restarting a modified version of the CCW last transferred, if it went beyond
;the corrected sector, or starting the next CCW in the list.  The channel helps
;us in computing the updated CCW to be restarted, but we still need to do some
;tricky analysis to find the word(s) to be corrected, and to continue the rest
;of the CCW list after the restarted CCW.

;ECCCWF finds the first CCW corresponding to the failed sector.  It returns in
;T2 a modified version of the CCW, set up to point to the start of the data in
;the bad sector.

;ECCFIX finds an actual word to be fixed and applies the mask bits.  It may
;involve chasing further down the CCW list, because the CCW in T2 might end
;before the sector does.

;ECFCWL fixes things up to restart the transfer, using the CCW that was updated
;by the channel, following it if necessary with a jump to the remainder of the
;as-yet unprocessed CCW list.

;JJW - end of my comments.  Have fun!

;Here to locate the CCW corresponding to the failed sector.
;CALL:
;	P1/CDB
;	P3/UDB
;
;Returns:
;	T1/ Physical Address of the CCW failing sector
;	T2/ CCW of the failing sector
;		 (different than contents of word addressed by T1)
;	T3/ count of words transferred through ecc-correctable sector

ECCCWF::STKVAR	<SECSIZ,CCWCNT,CCWADR,CURCWA,CURCCW,CHNCCW,XFRCNT>
	MOVEI	T1,PGSIZ	;GET SIZE OF A PAGE
	HRRZ	T2,UDBSIZ(P3)	;AND POINTER TO DISK SIZE TABLE
	IDIV	T1,SECPAG(T2)	;T1 := SIZE OF A SECTOR
	MOVEM	T1,SECSIZ	;Save sector size.
	SETZM	CCWCNT		;Number of data words xfered since start of sector.
	SETZM	XFRCNT		;Number of data words since start of transfer
	HRRZ	T1,CDBICP(P1)	;GET STATUS AREA
	MOVE	T2,2(T1)	;Get the channel's ending CCW
	MOVEM	T2,CHNCCW
	MOVE	T2,0(T1)	;Get the initial command word (usually a jump)
;Follow CCW words until we find a transfer whose end matches CS2, the updated CCW
ECWFLP:	TLNE	T2,(CHREV)	;This must be zero for all known types
	BUG	(ECCREV,<<P1,CDB>,<T1,CCWADR>,<T2,CCWORD>>);Can't interpret this CCW word.
	TLNE	T2,(CHXFR)
	JRST	ECWFL1		;Jump if this is a data command
	TLNN	T2,(CHJMP)	;Skip if it's a jump CCW
	BUG	(ECCHL0,<<P1,CDB>,<T2,CCWORD>>)	;Halt CCW.  Can't find the right CCW!
	LOAD	T1,CHADR,T2	;Get the address part
ECWFL0:	CALL	PHYMOV		;Follow the jump. (Fetch from physical addr in T1)
	JRST	ECWFLP
	
ECWFL1:	SKIPE	XFRCNT		;Start a data CCW.  Any previous data CCW?
	SKIPE	CCWCNT		;There was previous.  Skip if it expired at Sector
	JRST	ECWF1A		;No previous or previous did not end at Sector
;The previous CCW expired on a sector boundary.  If that sector was in error,
; the channel has stored the next data CCW in the channel logout area
	CAMN	T2,CHNCCW	;Does this CCW match the logout area?
	JRST	ECWFL3		;Yes!  Thus, previous CCW is error CCW
;continuation within a data CCW
ECWF1A:	SKIPE	CCWCNT		;process data command.  Is this a sector start?
	JRST	ECWFL2		;No. continue in current sector
	MOVEM	T1,CURCWA	;Save address of current CCW
	MOVEM	T2,CURCCW	;Save the CCW itself.
ECWFL2:	LOAD	T3,CHCNT,T2	;Get the count from this ccw
	MOVE	T4,T3		;Copy it
	MOVEM	T1,CCWADR
	MOVE	T1,SECSIZ
	SUB	T1,CCWCNT	;T1 is number of words left in this sector
	CAML	T3,T1		;Does CCW count exceed balance of sector?
	MOVE	T3,T1		;Yes, reduce count to finish this sector
;T3 is smallest of <Balance of Sector Size> and <number of words in the CCW>
	TDNE	T2,[17777777]	;Skip if this is a DATA SKIP CCW
	ADD	T2,T3		;update address within current CCW
	SUB	T4,T3		;T4 is remaining count in current CCW
	ADDM	T3,XFRCNT	;Count words processed by CCW list
	ADDB	T3,CCWCNT	;count words processed in this CCW
	STOR	T4,CHCNT,T2	;Store the new count in the CCW
	MOVE	T1,CCWADR	;Reload T1 with the address of this CCW word
	CAMN	T2,CHNCCW	;Does this match the channel ending CCW?
	JRST	ECWFL3		;Yes! 
	CAMN	T3,SECSIZ	;Did this portion exhaust the sector?
	SETZM	CCWCNT		;Yes.  Next (or continuation of this) starts sect
	JUMPG	T4,ECWFL1	;If data count remains, do more in this CCW
	TLNE	T2,(CHLST)	;Is the halt bit set in this CCW?
	BUG	(ECCHL1,<<P1,CDB>,<T2,CCWORD>>)	;Last CCW.  Can't find the right CCW!
	AOS	T1,CCWADR	;Advance to next physical address
	JRST	ECWFL0		;fetch next CCW word & interpret

;Here we found a CCW word (in CURCCW), (a modification of) the CCW located 
;in the physical word addressed by CCWADR, which (begins) the transfer
;of the failing sector.
ECWFL3:	MOVE	T1,CURCWA	;Return: T1/Address of start of current CCW
	MOVE	T2,CURCCW	;T2/CCW word (updated to point to start of sector)
	MOVE	T3,XFRCNT	;T3/number of words transferred,
	RET			; (counting ECC correctable sector)

;Here to fix one word in error in the transfer.
;CALL:
;	P1/CDB
;	P3/UDB
;	T1/Physical address of the CCW of the failing sector (from ECCCWF)
;	T2/CCW of the failing sector (from ECCCWF)
;	Q3/Word number within sector
;	P5/Data to XOR into the word specified by Q3

ECCFIX::STKVAR	<SAVT1,SAVT2,CCFSWD>
	MOVEM	T1,SAVT1
	MOVEM	T2,SAVT2
	SETZM	CCFSWD		;Word number in sector, so far.
ECCFX1:	LOAD	T3,CHCNT,T2	;Get the word count
	ADD	T3,CCFSWD	;Sum is how far thru sector we've gone
	CAMG	T3,Q3		;Have we gone far enough?
	AOJA	T1,ECCFX2	;No.  Advance T1 to next addr & fetch CCW
	MOVE	T3,Q3		;This is the in-sector location
	SUB	T3,CCFSWD	;T3:=number of words past this CCW's origin
	TLZ	T2,777760	;Mask off bits that aren't physical addr.
	JUMPE	T2,ECCFX0	;Zero means data skip!
	ADD	T2,T3		;Offset T2 to be physical addr of error word
	MOVE	T1,T2
	CALL	PHYMOV
	XOR	T2,P5
	CALL	PHYSTO
ECCFX0:	MOVE	T1,SAVT1
	MOVE	T2,SAVT2
	RET

ECCFX2:	MOVEM	T3,CCFSWD	;Update current count
	TLNE	T2,(CHLST)	;Reached the last CCW yet?
	BUG	(ECCHL3,<<P1,CDB>,<T1,CCWADR>,<T2,CCWORD>>);Unexpected Last Data Word
ECCFX3:	CALL	PHYMOV		;Get another CCW word
	TLNE	T2,(CHXFR)
	JRST	ECCFX1		;Jump if this is a data command
	TLNN	T2,(CHJMP)
	BUG	(ECCHL4,<<P1,CDB>,<T1,CCWADR>,<T2,CCWORD>>);Unexpected Halt Word
	LOAD	T1,CHADR,T2	;Must be channel jump. Get address part
	JRST	ECCFX3		;follow it.

;Here to build a new CCW list to transfer any data following the sector
;which we just corrected.
;
;	CALL ECFCWL		;ECC Fix CcW List
;RETURNS+1:
;	NO MORE DATA TO TRANSFER
;RETURNS+2:
;	New CCW list starts at CDBCCL(P1)
;	CDBCCL+1(P1) contains a channel jump to the balance of the list
;		(Unless this is the last CCW)

ECFCWL::HRRZ	T4,CDBICP(P1)	;GET STATUS AREA
	MOVE	T1,2(T4)	;GET UPDATED CCW
	LOAD	T3,CHCNT,T1	;GET remaining WORD COUNT 
	TLNE	T1,(CHLST)	;Is this the last transfer?
	JUMPE	T3,R		;Yes, If word count is zero, we're done
	MOVEM	T1,CDBCCL(P1)	;STORE IN CDB
	MOVE	T2,1(T4)	;Get the next CCW address from logout region
	TLZ	T2,777760	;clear all but physical address
	CAIN	T2,CDBCCL+1(P1)	;see if next CCW address is the CCW patch jump
	MOVE	T2,CDBCCL+1(P1)	;yes, it is, use it again (unless will halt)
	TLO	T2,(CHJMP)	;Set to jump to balance of transfer
	TLNE	T1,(CHLST)	;Is this the last channel word?
	MOVEI	T2,0		;Yes.  So we halt instead of jumping
	MOVEM	T2,CDBCCL+1(P1)	;Store zero or jump CCW as next CCW
	JUMPE	T2,ECFCW1
	MOVE	T2,CDBXFL(P1)	;When CDBCCL+1 is non-zero,
	HLRZM	T2,CDBEAD(P1)	;we store the original CCW ending address here.
ECFCW1:	RETSKP

>;IFWAITS
	
	TNXEND
	END
