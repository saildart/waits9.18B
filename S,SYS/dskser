COMMENT ⊗   VALID 00082 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00017 00002	 TRIES ERRBOX UFDEXT MFDENT MFDEXT MFDPRO MFDLOC UNAM UEXT UPRO UPPN ULEN UTIME UREFT UQINFO UOFFST UFDLEN DRTVOP DUDPOP DNOPRE DSATOP DWRITE DUSER DCMPBF DSYSBF DSYSB1 DSWAP C1BITP MSGPPN
C00021 00003	$	Index to ''Interrupt'' Subroutines. 
C00029 00004	 GOBIT READB WRITEB ALTERB RENAMB DELETB NTRUFD PNTDIF IOSET LOSBIG UFDDIF HDRDIF DSKFGS RAQBIT DMPBIT GARBIT PHUBIT DSKDSP
C00033 00005	 SETDDB RSTDDB SETDB0 SETDD1 CLRDDB CLRD98 CLRD99 DMES1 DMES2 CLRDD1 CLRD11 CLRD19 CLRDD2 CLRDD3 CLRDD3 CLRDD4
C00042 00006	CORE ALLOCATION ROUTINES  GCOR0 GCOR3 GCOR1 GCOR2 BUFCOR BUFCO1 RTNBUF RTNCSH CSHCOR CSHCO1 RTNUDB UDPCOR UDPCO1 GETCOR GETCO1 RTNCOR RCOR3 RCOR1
C00048 00007	 DSKTM1 EXTTIM TIMCNV TIMCN0 DSKSTP OSAT
C00052 00008	 DSKINI DKINI1 DKINI2 DKIN2A DKINI3 DKIN3A DKINI4
C00059 00009	 DKSINI PASCHK PASOK PAKERR PASTRY PASERR PASIOE NOSAT DQINI ACISTT ACIST1 MRKITB
C00066 00010	 DKSINI DKSIN1 DKSIN2 SNOFIL DKSSTO DKSNX1 DKSFST DKSNXT DKSNLS
C00072 00011	New format swapping on RH  DKSINI DKSINB DKSINC DKSIND DKSINE DKSING
C00078 00012	RH: Initialize File System.   PRSNAM RHSBIT PGSFT PGSIZ FILINI RILSS0 RILSS1 RILIN1 RILIN2 RILIN3 FILINE NSSDB MAKSTR MAKST1
C00088 00013	RH: MOUNT and DISMOUNT  STRMOU STRMO1 STRMO2 STROFL STROF1 STROF2 STRDMO STRDM0 STRDM1 STRDM3 CHKH30 CHKH31
C00098 00014	RH Support: SAT & Disk Address Manipulations  REC2BK REC2B1 REC2B0 R2BERR RRTNRC RMRKRZ RMRKRC RMRKRY RMRKRX RRTNRE RMRKRE RRTNE1 RRTNRF RMRKRF RASNBK RASNB1 RASNB2 RASNB3 RASNB4 RASNB5 BLK2RC BLK2RE ACIST2 ACIST3 ACIST4 ACIST5 ACIST6 ACIST7 ACIS7A ACIS7B ACIS7C ACIS7Z STRADR STRAD1 STRAD2 GETUDB
C00123 00015	 DBUFI DBUFI1 DIEOF TSTEOF DBFIC DIBUFI DIBFI1 DIBFI2 DIBFI3 DBFSET DBFXC DBFICI DBFCI1 DBFCI2
C00134 00016	 DBUFO DBUFOA DBFOGO DBUFO1 DBUFO2 DBUFO3 DBFOC DIBUFO DIBFO1 DIBOFW DIBFO3 DIBFO4
C00143 00017	 DDMPI SXDMPI DDXIT DDICO0 DDICO2 DDICO4 DDICO3 DDIC0 DDIC1 DDIC1A DDICO5 DDIGO DDIGOD DDIGOC DDMIEF DDCALC DIDMPI DIDMI1 DIDMI2 DMIEF1
C00154 00018	 DDMPO SXDMPO DDOCO0 DDOCO2 DDOCO4 DDOC0 DDOC1 DDMPO3 DDMPO4 DDOGOD DDMPO5 DDOCO5 DIDMPO DIDMO1
C00162 00019	CLOSE UUO  DCLOSI DCLSI1 DCLOSO DCLSO3 DCLSOC DCLSOD DCLS2V DCLSOF DCLSO2 DCLSOE DCLSOR DRDEL DRDEL1 DRDEL2 FIRVAL FIRCLK DCLOI DCLSO5 DCLOI DCLOI1 DCLOI2 DCLOI3
C00175 00020	 DRELES DRELS1 DRELS2
C00178 00021	 DSETI DSETC0 DSETC1 DSETC2 DSETO DGETF CNGSTS CNGST1 DGETL DGETL1 DSETC DFLSHO
C00184 00022	MTAPE  DGETW DGETW1 GODDIS GDSXRD GDSXWR GODLEN GETPNT DGODZ
C00190 00023	 GDWRIT GDWRI1 GDREAD GRDIDA GDRED0 GDRED1 GDRED2 DEPOPJ
C00199 00024	 SETSAT CLRSAT
C00200 00025	 SATWRT SATRD SATSUP SATFRC
C00203 00026	 RDGRP REAINF WRTINF LINOUT WRTINS WRTINX WRTIN1 WRTING WRTINZ
C00211 00027	 WRTOFF WOFFOK WRTOFS WRTOF1 WRTOF2 RDOFF
C00215 00028	 GETRTR
C00218 00029	 INFCOM ADDBLK ADDLOS FILEUP TKSFRE DSKRES DKRES1 VOLID UNITYP UNITYC UNITYB
C00226 00030	 SIXRD SIXCHK SIXWRT
C00230 00031	 LUPUFD DRPTMT DRPTM1 DRPTME DRPTI DRPTI1 DRPTIL DRPTIS
C00235 00032	LOOKUP UUO  DLOOK DLOOKF SRCERR DLK2 DLK1 DLK3 DRPT DRPTRT DRPT4X DLOK DPOPJ1 DPOPJ DPJRST DPJRA3 DPJRSC GOSET DSIOS LOOKI LOOKI1 LOOKI1 LOOKI2 LOOKI4 LOOKU
C00251 00033	ENTER UUO  DENTER DNTMFD DENTX0 DENT1A DENT1 DENT4 DENT2 DENT2A DENT3D DENT3 DENT3A NENUFD WENUFD NENUFD WENUFD DENT0 ENTREN DALTER
C00264 00034	RENAME UUO  DRENAM DRE0 DRE0A DRE0B DRE1 DRNMC DRE2 DRE3D DRE3 DREC1 DREC2 DREC0 DREC99 DRAUFX DRAUFD DRAUFY DRAUFZ UOLDAT UNEWDA REWRIT DRINT DRINT1 DFPOPJ DRINL DRINL2 DR2INT DR2INS SREWRIT
C00284 00035	FILE ACCESS CONTROL  ACCENT ACCESS ACCES1 ACCEST ACCST1 PROTEC PROTEK PROT0 PROT01 PROT6 PROT1 PROT2 PROT3 PROT4 PROT5 UPROTC UPROTK
C00292 00036	SEARCH MFD AND UFD FOR FILE.  FILSRC UFDSRC SRCH SRCH1 SRCHM CUSSRC SRCHM1 SRCHM2 SRCHM3 SRCHU
C00299 00037	 DIRINS DIRINX DIRI1 DIRI1W DIRI2 DIRI4 DIRIHF
C00312 00038	 UFDRTR UFDNEW UFDRCL UFDRCX
C00316 00039	 DIRSRC DIRSB DIRSA DIRS1 DIRS2 DIRSX DIRSRZ DIRSN DIRSE
C00324 00040	 SETLOS SPREAD SPREDL SPREDI SPREDI AUDINF AUDCHK AUDHAK AUDRD NEWFIL NEWFI1 LR2BLK LR2BK1 SETRD SETWRT BK2SEC BKMAP BKMAP1
C00332 00041	 GETRET TSTRET MAKBLK MAKBL2 MAKB3 MAKB3 MAKB3A ASNGRP ASNGR1 ASNGR2 ASNG2A ASNG2B GETBLK GETBK1 GGRETI GGRTI0 GGBLK1 GGNXT GETBKA GGRETD GGRET1 GGNXTD
C00344 00042	 CUSATO SATGLZ SATOUT SATIN
C00349 00043	Manipulate new style UDP SAT table  SATGET SATGT0 SATGT1 SATGL1 USATIN USATOUT USATWAT
C00356 00044	 ASNBLK ASNBLT RB4WCK RB4WLS RB4WER ASNST1 RASNB9 IASNBK ASNSL1 ASNSL2 RTNBLK MRKBLK CSATID MRKBAD MRKBD0 MRKBD1 MRKBD2
C00369 00045	DELETE A FILE, FREE DISK BLOCKS  DELETE DELFIL DELF2 DELF3 DELBLK DELBK1
C00372 00046	ERROR HANDLING  ENOFIL ENOUFD EPROT EFWRIT EDNAME EXFIL EANAME ENODEV EGARB1 EGARB2 EFULLZ ERRC2 ERRC1 ERZIOS ENTFUL ENTFUL EDFULL ENOENT ENOLUK ELOSE EGARB BADRET BADRE2 EGARC EACMFD EDMPLS
C00379 00047	USER DISK PACK SERVICE  UDPINI UDPDSP UDPMTP UDPIN SXUDIN UDPOUT SXUDOU UDPSER UDPSE1 UDPSE2 UDPS2A UDPS2C UDPS2B UDPSE3 UDPSE5 UDPSE4
C00391 00048	UDP PASS WORD STUFF  GPASIN PASSIT PASSI1 PASSET PASSE1 PASSIN PASOUT CHKSAT
C00397 00049	 PQIN PQINNS PQIN2 PQIN1 PQIN1B PQIN1A PQIN3 PQINSW PQINSE PQOUT PQOUT1 PQOUT2 PQOUT3 PQOUT5 PQOUT4 PQOUT6 PQOUT7 PQOUT8
C00407 00050	 PQADDR PQADD2 PQADD3 PQADDL WRAPOK PQANSB PQADD1 PQADE0 PQADE1 PQADE2 PQADE3 PQADDE PQSWL1 PQSWAP PQSWLS PQSWAP PQSWAP C1WHCH
C00415 00051	SWAPPER INTERFACE  DFGO DSKONJ DSSTRT SQGOX SQGOXL SQGO2A SQGO2 SNOERR SWPLZ1 SQBADB SWPLUZ SQGOX SQGOX0
C00424 00052	 UFDREQ UFDRE4 UFDRE2 UFDRE1 UFDRE3 UFDCL1 UFDCL2 UFDRQX DDBWAK UFDRQY UFDRQZ UFDSCN UFDSC1 UFDSC2 UFDREM UFDINT devent
C00440 00053	System Buffer Initialization, Assignment, Release.  SBAINI SBAIN1 GETSBA GETSBB GETSB2 RELSBA RLSBA1 RLSBA2 SBACHK SBACKE SBACK1 GETSBE RLSBAE GTSBAE
C00447 00054	 UEWAIT XWSYNC NEWAIT NENTER RENTER QEWAIT QENTER QE1 DIGO DNSTR2 DNSTR3 DRQDN DRQDN1 MESSCO MESS1 MESS2 MESS3 MESS4 MESS5 MESS6 MESS7 MESS8
C00454 00055	 STSTA1 STSTART TSTART WLOCK TREDO TGO TGO1 DKTIMA DKTIMB
C00460 00056	 C1GO C1GO1 C1GO2 C1GO3 C1GOGO C1STRT C1DSCN C1DSC1 CNTDOP CNTDO1 ERRCLR ERRCLL
C00466 00057	 NDSKUP DISKUR DISKUE DISKUN DISKUM DISKRS DISKUP DISKU0 DISKU1 DISKU2 DQUIET DQUI00 DQUI0 DQUI1 DQUI2 DQUI3 DQUIEL C1REGO C1REG0 C1REG1 C1REGA DHUNG DHNGD3 DHNGD2 DHNGDC CHN A B C D ZMA C1Z FF C10 C11 CSI CGRONK CRELOD CSCKRN CCCKRN CCKSTR CSC CRSTCH CMPCNT CSCHF1 CCCHF1 CCINTF CSD CMCADR CMCLD CMPSTP CMSTB CSDIAG CCDIAG HBRKIN NCHNS C1ALSV C1ADSV C1APSV C1AGSV C1BLSV C1BDSV C1BPSV C1BGSV C1SAVE C1DUMP C1DMP0 C1DMP1 C1DMP2 C1DMP3 C1DMP5 C1DMP4 C1DMPX EXZ80M XZ80M CPOPJX QSSTEP SETHBP SETHB2 DPZMEM DPZME2 Z8MLD Z80GO
C00487 00058	 C1MPIS C1MPI4 C1MPSU C1MPIL C1MPIW C1MPW1 C1MPW2 C1MPWR C1RECB C1MPIB C1MPI7 C1MPI1 C1MPI2 C1MPI3 C1MPIA C1MPI6 C1MPI9 C1MPW4 C1MPW5 C1MPI8 C1MPIC C1MPR1 C1MPR2 C1MPUE
C00500 00059	 C1AINT C1BINT C1INT C1INTX C1CNFS C1CNF1 C1CNF2 C1CERR C1ERRI C1ERI1 C1ERI2 C1ERI3 C1ASYN C1ASY3 C1ASY2 C1ASY1 C1SYNI C1ERET C1SYN5 C1SYN6 C1SYN3 C1SYN2 C1SYN4
C00510 00060	 C1ACSV C1SYN1 C1SEL1 C1NOSE NONXM PARL0 PARL1 PARL2 BPAR
C00516 00061	 NOPAR SNSDON SNSDO3 SNSDO2 SNSDO1 SNSFLD SNSFL1 SNSDOX SNSDN1 NORJCT SKCHKA SKCHKB NOCL13
C00522 00062	 EUSPNT ERRU1 ERRU2 ERRU3 ERRU4 ERRU5
C00525 00063	 TYPE0 TYPE1 F2DERR NOEXT NOFIL NOFIL1 NSWAP2 NSWAP1 SATPNT NSWAP CLLOP NOCL NODIE SNSLOP NULSNS TYPDON ERRGO NOSTOP WOVNST WOVSWP WOVDDT NOTWOV NOSTP1 C1HUNG DRIVEP ISKNWN PCURDA
C00539 00064	ERROR CLASS DESCRIPTIONS 
C00541 00065	 ERROR5 SYSLOS SYSLOZ DSKETY SYSLOX SYSLOY ERROR4 ERROR1 ERROR0 ERROR2 ERRORX TBAD TYTST TYPIT ERROR3 DORCL1 DORCL2 SENSE SENSE1 SENSE3 SENSE2
C00549 00066	 FIXERR FIXSRC NOECRM FIXSC2 FIXSCN FIXSC1 CANFIX CANFX1 CANFX2 FIXER1 FIXOUT FIXMES SUPECL SUPEC3 SUPEC4 SUPEC2 SUPEC5 FXSATL FXNOTK FXETKL FXKNWN FXNETK NEWECC NEWEC1 NEWEC0 NEWEC2 NEWEC3 FXMSGX DFNODS DFNOST FIXDN FIXDN1 FIXDN3 HDCRSH HDCRS1 HDCRS2 FIXERP FIXRP2 FIXRP1 FIXLS1
C00576 00067	Start of many pages of IFN FTF2  NUNTBT NCYLBT NSRFBT NSECBT ENDBIT SELBIT DSKIFG F2DCNT NDTRY S.ANY S.NACT S.SERR S.WRP S.NRDY S.SKER S.FALT S.NBSY S.HECC S.SECC S.ROVRN S.WOVRN S.IPE C.USC C.REL C.REC C.FCLR C.DSL C.DSE C.SOM C.COP C.CFM OP.RD OP.WRT OP.CTRL C.32B C.IENA C.IEND L.INIT L.START
C00582 00068	This whole page IFN FTF2  DHUNG
C00584 00069	This whole page IFN FTF2  C1SIMG C1SIM C1SIM2 F2DPAK F2DJM2 F2DJMP F2DADE F2DAD2
C00589 00070	This whole page IFN FTF2  F2MWRT F2MRED NOSEEK F2DREA F2DWRI NOPRER
C00595 00071	This whole page IFN FTF2  F2DEN0 F2DEND F2DEN2 F2DXIT F2DISM F2DSTR F2DST3 STRER0 STRERR SAVCUR
C00602 00072	This whole page IFN FTF2  WHERED WHEREL WHEXIT WHEREX WHERX2 WHERX0 WHERX1 WHERX3 WHERX4
C00612 00073	This whole page IFN FTF2  F2WBLT F2WBL2 F2WBL3 F2WBL4 F2WBLY F2WBLZ F2WBL5 F2WBL6 F2WBL7
C00619 00074	This whole page IFN FTF2  F2RBLT F2RBL2 F2RBL3 F2RBL4 F2RBL5 F2RBL6 F2WBLX F2RBLX
C00625 00075	This whole page IFN FTF2  F2DWRP F2CWRP F2DBUF F2DBGT
C00628 00076	This whole page IFN FTF2  F2DINT F2DIN2 F2DIN3 F2DIN4 F2DINE
C00633 00077	Last of several whole pages IFN FTF2  WASER0 WASERR GO GOL RECAL RECBUZ RECALE RECSTO DERRO1 F2DWAK F2DERI DERRO4 DERRO5 DERRO6 DERRO7
C00642 00078	 IS.SHT IS.DON IS.ERR IS.NRT IS.WGU IS.TPM IS.EOT IS.WLK IS.IER IS.DTE IS.DVE IS.BOT IS.RTL IS.IEL IRMWRD IRM6BT IRM7BT IRM8BT IRMHID RCNTOP RCNTO1 RHGO RHGO1 RHGO1A RHGO2 RHGO2B RHGO3 RHGO4 RHSIRB RHICCW RHGERR RHGER1
C00660 00079	Mount SAT table for RH disk  GTSATX GTSATW GETSAT NOFS PUTSAT GETSA1 QDSKIO TSTOFL UDISIE TSTOF0
C00668 00080	RHGO - multi block operations: old-mode UDP or swapping  RHGOUD RHGOSW RHSWPE
C00672 00081	 DSKSPY
C00673 00082	 RUDPUP
C00685 ENDMK
C⊗;
;⊗ TRIES ERRBOX UFDEXT MFDENT MFDEXT MFDPRO MFDLOC UNAM UEXT UPRO UPPN ULEN UTIME UREFT UQINFO UOFFST UFDLEN DRTVOP DUDPOP DNOPRE DSATOP DWRITE DUSER DCMPBF DSYSBF DSYSB1 DSWAP C1BITP MSGPPN

BEGIN DSKSER ↔ 	SUBTTL	DSKSER	DISK SERVICE ROUTINE

;HISYS	;THIS CARRIES THROUGH DSKSER,DSKINT,MTCSER,DTCSER,FBPACK,TVSER,LPTSER
	;ELFSER,CARSER;


; PRELIMINARIES, STORAGE CONTROL

;THIS CODE DEPENDS HEAVILY UPON:
; 1) NO RESCHEDULING AT UUO LEVEL
; 2) JOB NOT SWAPPED WHEN IO ACTIVE.

TRIES←←1			;ASK DSKINT TO TRY A TRANSFER THIS MANY TIMES
ERRBOX←←1			;PLACE FOR ENTER, LOOKUP ERROR CODES
UFDEXT←←'UFD'			;SIXBIT UFD.

↑MFDENT:'  1  1'		;'DIRECTORY ENTRY' FOR MFD
MFDEXT:	'UFD   '
MFDPRO:	155740,,0		;ANYONE CAN READ THE MFD

NoStructure,<
MFDLOC:	1			;DISK ADDRESS OF FIRST MFD TRACK
>;NoStructure
IfStructure,<
DEFINE	MFDLOC	<↔.FATAL use ST.MFA(SDB) instead of MFDLOC>
>;IfStructure

IFN FTSBP,<SYSBUF←←SYBEXP⊗9>

;UFD ENTRY FORMAT (ALSO LOOKUP FORMAT EXCEPT USE UPPN INSTEAD OF ULOC)
;IF CHANGED YOU MUST ALSO CHANGE THE CODE AT UFDNEW AND DRPTIS
UNAM←←0
UEXT←←1
UPRO←←2
UPPN←←3 ↔ ULOC←←3
IFN FTLUFD,<
ULEN←←4				;FILE LENGTH IN UFD
UTIME←←5			;EXTENDED TIME LAST WRITTEN
UREFT←←6			;REFTIME
;UDMPT←←7			;DMPTIME
;UNUSED←←10			;(DGRP1R)
;UNUSED←←11			;(DNXTGP)
;USATID←←12			;DSATID
UQINFO←←13; 14, 15, 16		;DQINFO
UOFFST←←17			;DOFFST
>;IFN FTLUFD

↑UFDLEN←←20			;LENGTH IN WORDS OF UFD (AND MFD) ENTRIES 


;LEFT HALF TFRCTL BITS
IFN FTRH,<
DRTVOP←←2000	;Flag that an operation includes movement of retrieval data
>;IFN FTRH
DUDPOP←←1000	;Flag for multi-block UDP (old mode) operation.
IFN FTF2,<
DNOPRE←←400	;FLAG TO AVOID PRE-READ EVEN IF WRITE DOESN'T REACH END OF DISK PAGE
>;IFN FTF2
DSATOP←←200	;FLAG SAT TABLE OPERATION
DWRITE←←100	;FLAG TO WRITE, ELSE READ
DUSER←←40	;FLAG FOR USER REL TRANSFER, ELSE ABSOUTE
DCMPBF←←20	;FLAG FOR C1MPIL TO USE BUFBUF FOR ADDRESSES
DSYSBF←←10	;FLAG THIS TRANSFER USES SYSBUF (READ PAUSE OR RPW)
DSYSB1←←4	;FLAG TO SET TFRIOW FROM DD.SBB FOR THIS PACK
DSWAP←←2	;FLAG TO USE TFRIOW IN FUNNY WAY FOR SWAPPING
;THE LOW ORDER BIT DETERMINES WHICH CHANNEL IS USED FOR THE TRANSFER

↑C1BITP:POINT 1,TFRCTL(DDB),17	;0 FOR C1A 1 FOR C1B

;RIGHT HALF OF TFRCTL USED FOR ERROR COUNT DOWN AT TSTART

MSGPPN:	'  2  2'		;PPN OF MESSAGE AREA

Comment $	Index to ''Interrupt'' Subroutines. ;⊗

In the old days, an ''interrupt subroutine'' represented a critical section
which, once started, would be completed without any other disk activity going on.
Interrupt subroutines made use of various resources, e.g., SYSBUF, that couldn't
be shared since the subroutine intended to read, modify, and write the contents
of the buffer.  All disk activity was interlocked so that ''none'' occured
at UUO level.  Calls to interrupt subroutines were queued; assuming the
queue wasn't empty, the UUO level code would pause by calling WSYNC (XWSYNC).
If the queue was empty, the interrupt channel was disabled and the I subr
was started.  When it blocked (by calling TSTART), it ''dismissed'' back
to the UUO context which re-enabled the pi level and called WSYNC pending
completion of the ISUBR.

The routine TSTART is the entry for initiating all IO activity.

Nowdays, SYSBUF isn't used so often.  DUMP mode I/O goes
directly between the disk and user memory.  BUFFERED mode I/O, which formerly
used SYSBUF, now uses a series of commands found in BUFBUF(DDB) to govern
the transfer of individual disk sectors in or out of user memory.

Jeff Rubin added one SYSBUF for each spindle.  In his scheme, such
operations that require Read-Modify-Write as an ''indivisible'' operation,
one such operation can be undertaken on each pack individually.  Access to
a UFD is interlocked via calls to UFDREQ.  Other R-M-W operations are
interlocked by giving highest priority to subsequent sysbuf requests from
the DDB using sysbuf (so long as the disk address is the same); see code
at PQIN and C1GO.

Ralph Gorin discarded the one SYSBUF per spindle in favor of a pool of
system buffers.  An ISUBR that needs a sysbuf will call STSTART or STSTAR1
and get a buffer allocated for the duration of the ISUBR.  When the ISUBR
exits, any buffer so allocated is released.  An implicit interlock on UFDs
that was provided by the per-spindle sysbufs, no longer is dependable.
(The implicit interlock to allow UFD entry update operations to occur with
impunity worked because such operations stay within one block; since that
block could reside in precisely one system buffer, and that buffer was
controlled by the ISUBR doing the modification, then nothing could go
wrong.)  In Gorin's scheme, the UFD interlock system (UFDREQ) must be used
for such update operations.

Further comments (JJW): the UFD interlock system is inadequate.  In
particular, it allows any number of read accessors to a UFD even while write
accesses are taking place.  This causes numerous errors, which became more
apparent after Ralph's scheme was implemented.  The correct way to do this
is to apply a solution to the well-known "readers and writers" problem, so
that no reads are allowed to overlap with write accesss.

CHKSAT		;Read UDP SAT to SYSBUF.  Return IDSAT word in TFRCTL
DCLOI		;Close Output.  Update RTVL.  Enter in UFD.
			;Also called from RELEASE and FILEUP MTAPE
DCLSO5		;obsolete (inconsistently conditionaled out)
DELFIL		;Delete file.  Called from DELETE.
DIBUFI		;Buffered Input (by block)
DIBUFO		;Buffered Output (by block)
DIDMPI		;Dump Input  (by group)
DIDMPO		;Dump Output (by group)
DIRSRC		;Look in MFD for user's UFD.  Queued from FILSRC
			;Called also from DRAUFD/DRAUFY; DR2INT; DIRI1
DIRI1		;Call from DIRINS to add a new name to a UFD
DRAUFD		;Rename.  Call from DRINT
			;Call from DRDEL for clearing UFD entry of deleted file
			;Call from DRELES delete UFD entry for created file at RESET
DRAUFY		;Alternate DRAUFD; no error if can't find old entry.
			;Call from output close of superseding file to fix UFD entry
DR2INT		;Rename change PPN.  Remove entry from old UFD.  Calls DRINT1.
DRINT		;Rename.  Use DRAUFD to change one UFD.  calls DRINT1
DRINT1		;Rename change name, etc. within the file.  Spread RTVL
			;if the affected file is a UFD, grab the UFD interlock
DRPTI		;Report extended RTVL for LUPUFD - MTAPE 26.
GGRETD		;Get RTVL of Group containing USETP into DDB
GGRETI		;As GGRETD, & read first Blk of G into SYSBUF
LOOKI		;LOOKUP.  Change reference date in file RTVL & UFD.
LOOKU		;Read file's protection & group access word
PASOUT		;Write Old-Style UDP PASSWORD BLOCK
PASSIN		;READ Old-Style UDP PASSWORD BLOCK 
RB4WCK		;Read before write check.  Called from ASNBLK
SATIN		;Main SAT input
SATOUT		;Main SAT output
SPREAD		;Spread RTVL from DDB throughout current group.
STSTA1		;Start SYSBUF transfer.  Set TFRIOW from assigned buffer address
STSTART		;Start SYSBUF transfer
TSTART		;Start Transfer
USATIN		;New format UDP SAT input
USATOUT		;New format UDP SAT output
USATWAT		;Wait for someone else to bring new fmt UDP SAT into core
WRTINS		;Write Info for MTAPE 11
WRTOFS		;Write Offset for MTAPE 21

$
;⊗ GOBIT READB WRITEB ALTERB RENAMB DELETB NTRUFD PNTDIF IOSET LOSBIG UFDDIF HDRDIF DSKFGS RAQBIT DMPBIT GARBIT PHUBIT DSKDSP

;IOS BITS,  DISPATCH TABLE

;BITS IN LH IOS INDICATE FILE STATUS:

↑GOBIT←←400000		;SET TO PREVENT ↑C FROM STOPPING US IN THE MIDDLE OF A UUO
↑READB←←200000		;DDB IS READING
↑WRITEB←←100000		;DDB IS WRITING
↑ALTERB←←40000		;DDB IS ALTERING
RENAMB←←20000		;DDB IS CHANGING RETRIEVAL.
DELETB←←10000		;THIS FILE SHOULD BE DELETED WHEN LAST READER FINISHES.
NTRUFD←←4000		;DDB IS SUPERSEDING.  UFD NEEDS TO BE CHANGED IN CLOSE
PNTDIF←←2000		;SET IF NEED TO SPREAD RETRIEVAL FOR CURRENT GROUP
;UUOCON DEVSBB←←1000
IOSET←←400		;USETI, USETO, AND UGETF USE THIS TO ABORT CLOSE.
LOSBIG←←200		;bad retrieval seen (if IODERR and IODTER are off)
IFN FTLUFD,<
UFDDIF←←100		;NEED TO UPDATE UFD ENTRY
>;IFN FTLUFD
;UUOCON IOEND←←40
;UUOCON IO←←20
;UUOCON 10 RESERVED
;UUOCON IOFST←←4
HDRDIF←←4		;SET TO SPREAD RTVL FOR FIRST GROUP (SAME AS IOFST)
;UUOCON IOBEG←←2
;UUUCON IOW←←1

↑DSKFGS←←GOBIT	;BITS THAT CAUSE COMMANDS TO BE DELAYED (SEE STOPCK IN CLKSER)

;USER STATUS BITS IN RH IOS:

RAQBIT←←1000	;READ-ALTER QUICK BIT.  DON'T CHANGE ANY DATE/TIMES ON R/A
DMPBIT←←400	;6-WORD LOOKUP,ENTER,RENAME.  DON'T CHANGE ACCESS TIME
GARBIT←←200	;ALLOW ERROR RETURN FROM BAD RETRIEVAL.
PHUBIT←←100	;MAKE ALL USET REFERENCES BE TO PHYSICAL RECORDS NOT LOGICAL


	JRST CNGSTS		;HERE FROM SETSTS UUO.
	JRST CLRDDB		;GIVE BACK DDB
	JRST SETDDB		;MAKE DDB
	JRST DSKINI		;INITIALIZATION (SYSINI)
	JRST DHUNG		;SHOULDN'T HANG
↑DSKDSP:JRST DRELES		;RELEASE
	JRST DCLOSO		;CLOSE OUTPUT
	JRST DBUFO		;BUFFERED OUTPUT
	JRST DBUFI		;BUFFERED INPUT
	JRST DENTER		;ENTER
	JRST DLOOK		;LOOKUP
	JRST DDMPO		;DUMP OUTPUT
	JRST DDMPI		;DUMP INPUT
	JRST DSETO		;USETO
	JRST DSETI		;USETI
	JRST DGETF		;UGETF
	JRST DRENAM		;RENAME
	JRST DCLOSI		;CLOSE INPUT
	POPJ P,			;UTPCLR
	JRST DGETW		;MTAPE
;⊗ SETDDB RSTDDB SETDB0 SETDD1 CLRDDB CLRD98 CLRD99 DMES1 DMES2 CLRDD1 CLRD11 CLRD19 CLRDD2 CLRDD3 CLRDD3 CLRDD4

;CALLED BY ASSASG IN IOCSS FOR INIT UUO.  Called for ASSIGN Command
;	CALL WITH 	DDB/ Left half data,,address of model DDB
;	Return With	DDB/ Left half preserved,,address of newly created DDB
;
SETDDB:					;Enter to create a DDB
IFN FTRH,<
	LDB	AC1,PUNIT
	CAMG	AC1,[UPACKS]
	JRST	SETDB0			;Get FS for a small (Ampex) DDB.
RSTDDB:	PUSHJ	P,GCOR0			;FS for large (RH) DDB.  from FILINI only
	SKIPA
SETDB0:
>;IFN FTRH
	PUSHJ P,GCOR1			;Return address of new DDB in TAC
	PUSH P,TAC1			
	LDB TAC1,PUNIT
NoStructure,<
	JUMPE TAC1,SETDD1
	AOS UDPCNT-1(TAC1)		;BUMP COUNT OF DDBS FOR THIS UDP
IFE FTF2,<
PRINTX ALL REFERENCES TO "CAR" ARE FOR UDP1 ONLY
	CAIN TAC1,1
	CONO CAR,1			;SET UDP IN USE LIGHT
>;IFE FTF2
SETDD1:	MOVE TAC1,DKDBML(TAC1)		;GET ADDRESS OF MODEL DDB
>;NoStructure

IfStructure,<
IFE FTF2,<
PRINTX ALL REFERENCES TO "CAR" ARE FOR UDP1 ONLY
	CAIN TAC1,1
	CONO CAR,1			;SET UDP IN USE LIGHT
>;IFE FTF2
	MOVE TAC1,SDBPTR(DDB)		;Get SDB address
	AOS ST.CNT(TAC1)		;Count one more DDB for this structure
	MOVE TAC1,ST.MDB(TAC1)		;GET ADDRESS OF MODEL DDB
>;IfStructure

	HRRI DDB,DDBSKW(TAC)		;SAVE GOOD BITS IN LH
	HRLI TAC,-DDBSKW(TAC1)		;SOURCE ADDRESS IN LH
	BLT TAC,DMPBUF(DDB)		;CLEAR, INITIALIZE DDB
	HRLM DDB,DEVSER(TAC1)		;NEW LINK IN DUMMY
	MOVEI TAC1,DEVIOS(DDB)
	MOVEM TAC1,DEVSPT(DDB)
	POP P,TAC1
	SETZB IOS,DEVLOG(DDB)		;CLEAR LOGICAL NAME AND IOS
	SETZM UFDPPN(DDB)		;(DRELS2 WILL CLEAR DEVIOS)
	SETZM UFDADR(DDB)
	JRST DRELS2			;CLEAR CRUD AND RETURN

;CALLED BY RELEASE IN UUOCON FOR RELEASE UUO.
↑CLRDDB:PUSHJ P,DRELS2
	LDB TAC1,PUNIT			;GET UNIT NUMBER
NoStructure,<
	JUMPE TAC1,CLRDD3		;JUMP IF MAIN DISK
	SOSE TAC,UDPCNT-1(TAC1)		;DECREMENT USE COUNTER
	JRST CLRD99			;THERE ARE STILL OTHER DDBS IN USE

;THERE ARE NO OTHER DDBS.  GIVE AWAY THE FS FOR THE SAT TABLE
	SETOM UDPOWN-1(TAC1)		;MAKE PUBLIC FOR NEXT INIT OR ASSIGN
IFE FTF2,<
	CAIN TAC1,1
	CONO CAR,400001			;TURN OFF THE "IN USE" LIGHT
>;IFE FTF2
	MOVE AC3,DKDBML(TAC1)
	MOVEI TAC,DSKDSP
>;NoStructure
IfStructure,<
	MOVE AC3,SDBPTR(DDB)
	SOS TAC,ST.CNT(AC3)		;DECREMENT USE COUNTER
	JUMPE TAC1,CLRDD3		;JUMP IF MAIN DISK
IFN FTRH,<
	CAMLE TAC1,[UPACKS]
	JRST CLRDD3			;Jump if any RH-disk
>;IFN FTRH
	JUMPG TAC,CLRD99		;JUMP IF THERE ARE OTHER DDBS IN USE
	SETOM ST.JOB(AC3)		;MAKE PUBLIC FOR NEXT INIT OR ASSIGN
;THERE ARE NO OTHER DDBS.  GIVE AWAY THE FS FOR THE SAT TABLE

IFE FTF2,<
	CAIN TAC1,1
	CONO CAR,400001			;TURN OFF THE "IN USE" LIGHT
>;IFE FTF2
	MOVEI TAC,DSKDSP		;Assume old style disk
	MOVE TAC1,AC3			;Keep SDB address in TAC1
	MOVE AC3,ST.MDB(AC3)
>;IfStructure
	HRRM TAC,DEVSER(AC3)
	MOVSI TAC,DVDSK
	IORM TAC,DEVMOD(AC3)
NoStructure,<
	SKIPLE AC1,SATADR(TAC1)
	PUSHJ P,RCOR1			;GIVE AWAY THE FS BLOCK FOR SAT
	SETZM SATADR(TAC1)
	SETZM SATMOD(TAC1)
>;NoStructure
IfStructure,<
	SKIPLE AC1,ST.SAD(TAC1)
	PUSHJ P,RCOR1			;GIVE AWAY THE FS BLOCK FOR SAT
	SETZM ST.SAD(TAC1)		;no SAT anymore
	SETZM ST.SMD(TAC1)		;not been modified
	SETZM ST.NAM(TAC1)		;no structure name either
>;IfStructure
IFN FTECCT,<
IFN FTRH,<
	LDB TAC1,PUNIT
	CAMLE TAC1,[UPACKS]
	JRST CLRD98			;Jump if RH-based
>;IFN FTRH
	MOVEI TAC,FPACKS-1(TAC1)	;GET PACK NUMBER (NOT UNIT #) OF THIS UDP
	IMULI TAC,NECCTK*TRKCYL		;MAKE INDEX INTO ECCTKT
	HRLI TAC,-NECCTK		;MAKE AOBJN POINTER
	SETZM ECCTKT(TAC)		;CLEAR OUT OUR DATA
	AOBJN TAC,.-1
CLRD98:
>;IFN FTECCT
	SKIPA TAC,[DMES1]
CLRD99:	MOVEI TAC,DMES2
	PUSH P,DDB
	PUSH P,TAC			;SAVE MESSAGE
	CONSO PI,400			;IN PROG ON 7?
	JRST CLRDD1
;deassign command
	PUSHJ P,TTYFND			;J SET UP FROM COMMAND DECODER WE HOPE
	PUSH P,-1(P)			;GET UDP DDB TO (P) FOR ERNAM
	PUSHJ P,ERNAM			;TYPE "DEVICE UDPN"
	POP P,(P)
	POP P,TAC			;SETUP MESSAGE
	PUSHJ P,CONMES
	JRST CLRDD2			;RELEASE DDB

DMES1:	ASCIZ / may be unloaded
/
DMES2:	ASCIZ / still in use - DON'T unload
/

;release by UUO
CLRDD1:
NoStructure,<
	SKIPG UDPCNT-1(TAC1)		;RELEASE BY UUO:
	JRST CLRD19			;ALWAYS GIVE DMES1 IF APPROPRIATE,
	MOVE TAC,DKDBML(TAC1)
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	SKIPG ST.CNT(TAC1)		;RELEASE BY UUO:
	JRST CLRD19			;ALWAYS GIVE DMES1 IF APPROPRIATE,
	MOVE TAC,ST.MDB(TAC1)
>;IfStructure
;DON'T GIVE DMES2 IF THIS JOB HAS OTHER DDBS FOR THIS UDP
CLRD11:	HLRZ TAC,DEVSER(TAC)	
	JUMPE TAC,CLRD19		;THIS CAN'T HAPPEN
	MOVE TAC1,DEVNAM(TAC)
	CAME TAC1,DEVNAM(DDB)
	JRST CLRD19			;NO MORE DDBS, GIVE THE MESSAGE
	LDB TAC1,[POINT JOBNSZ,DEVJBN(TAC),JOBNPS] ;PJOBN
	CAIE TAC,(DDB)			;THE DDB WE'RE FLUSHING DOESN'T COUNT
	CAME TAC1,JOB
	JRST CLRD11			;NOT OUR DDB, KEEP LOOKING
	POP P,TAC			;OUR DDB, DON'T DO THE MESSAGE
	JRST CLRDD2

CLRD19:	SKIPN JBTPAG(J)			;SKIP IF JOB IS INCORE
	JRST CLRDD2			;NO MESSAGE IF NO CORE
	PUSHJ P,TTYFUW
	PUSH P,-1(P)			;UDP DDB TO (P) FOR ERNAM
	PUSHJ P,ERNAM			;TYPE "DEVICE UDPN"
	POP P,(P)
	POP P,TAC
	PUSHJ P,CONMES
	PUSHJ P,TYPGO
CLRDD2:	POP P,DDB
NoStructure,<
	LDB TAC1,PUNIT
CLRDD3:	MOVE AC1,DKDBML(TAC1)		;SEARCH FOR THIS DDB - START AT MODEL
>;NoStructure
IfStructure,<
CLRDD3:	MOVE TAC1,SDBPTR(DDB)		;Search for this DDB - Start at Model
	MOVE AC1,ST.MDB(TAC1)		;Start at model DDB
>;IfStructure
CLRDD4:	HRRZ TAC1,AC1			;TAC1 is ''previous''
	HLRZ AC1,DEVSER(TAC1)		;get link to next
	JUMPE AC1,CPOPJ			;SHOULDN'T HAPPEN
	CAIE AC1,(DDB)			;RIGHT ONE YET?
	JRST CLRDD4			;NO. KEEP SEARCHING
	MOVE DDB,DEVSER(AC1)		;LINK TO ONE AFTER LOSER
	HLLM DDB,DEVSER(TAC1)		;SPLICE AROUND IT
	SUBI AC1,DDBSKW			;CALC ADDRESS OF FREE STG BLOCK
	JRST RCOR1			;RETURN TO DISK FREE STG. AND POPJ

;CORE ALLOCATION ROUTINES ;⊗ GCOR0 GCOR3 GCOR1 GCOR2 BUFCOR BUFCO1 RTNBUF RTNCSH CSHCOR CSHCO1 RTNUDB UDPCOR UDPCO1 GETCOR GETCO1 RTNCOR RCOR3 RCOR1

IFN FTRH,<
GCOR0:	MOVEI AC3,RHDBSZ		;Set size of DDB for RH disks.
	PUSHJ P,FSGET			;GET FREE STORAGE
	 JRST GCOR3			;HAVE TO WAIT
	MOVEI TAC,(AC1)			;RETURN ADDRESS IN TAC
	POPJ P,

GCOR3:	CONSO PI,400⊗<7-PHYCHN>	;are we in the RH channel? (can't be above it)
	JRST GCOR2		;no, hope we're in clock level from cmd
	MOVE AC3,[400000,,RHDBFS] ;yes, try this spares list (don't allow failure)
	PUSHJ P,SFSGET		;get FS from spares list
	MOVEI TAC,(AC1)		;return adr in TAC
	POPJ P,
>;IFN FTRH

GCOR1:	MOVEI AC3,DDBSIZ		;SET SIZE
	PUSHJ P,FSGET			;GET FREE STORAGE
	 JRST GCOR2			;HAVE TO WAIT
	MOVEI TAC,(AC1)			;RETURN ADDRESS IN TAC
	POPJ P,

GCOR2:	SUB P,[4,,4]			;CALLED FROM COMMAND DECODER
	JRST DLYCM1


;get the buffered mode buffer pointers.  As many as one block's worth of records
;per use.
BUFCOR:	HLRZ AC1,BUFBUF(DDB)
	JUMPN AC1,BUFCO1		;USE WHAT WE HAVE
NoStructure,<
	MOVEI AC3,RCPBLK		;number of records per block
>;NoStructure
IfStructure,<
	MOVE AC3,DD.RPB(DDB)		;number of records per block
>;IfStructure
	PUSHJ P,UFSGET
BUFCO1:	HRLZM AC1,BUFBUF(DDB)
	HRRM AC1,BUFBUF(DDB)		;initialize both halves of BUFBUF
	POPJ P,

RTNBUF:	HLRZ AC1,BUFBUF(DDB)
	SETZM BUFBUF(DDB)
	JRST RCOR3

IFN FTDCSH,<
RTNCSH:	HLRZ AC1,CSHBUF(DDB)		;RELEASE CACHE SWEEP BUFFER
	SETZM CSHBUF(DDB)
	JRST RCOR3

CSHCOR:	HLRZ AC1,CSHBUF(DDB)
	JUMPN AC1,CSHCO1		;USE WHAT WE HAVE
NoStructure,<
	MOVEI AC3,2*RCPBLK
>;NoStructure
IfStructure,<
	MOVE AC3,DD.RPB(DDB)	
	LSH AC3,1			;two words per record
>;IfStructure
	PUSHJ P,UFSGET
CSHCO1:	HRLZM AC1,CSHBUF(DDB)
	POPJ P,
>;IFN FTDCSH

RTNUDB:	SKIPN AC1,UDPBUF(DDB)
	POPJ P,
	PUSHJ P,FSGIVE
	SETZM UDPBUF(DDB)
	LDB TAC,PUNIT
	MOVEI AC1,-1(TAC)
	IMULI AC1,C1PRLU
	ADDI AC1,C1APH+FPACKS*C1PRGL
	DPB AC1,[POINT 22,C1APT+C1PPTR+FPACKS-1(TAC),35]
	ADDI AC1,C1BPH-C1APH
	DPB AC1,[POINT 22,C1BPT+C1PPTR+FPACKS-1(TAC),35]
	POPJ P,

UDPCOR:	SKIPE AC1,UDPBUF(DDB)
	JRST UDPCO1			;USE WHAT WE ALREADY HAVE
	MOVEI AC3,C1UDPL
	PUSHJ P,FSGET
	 JRST GCOR2
	MOVEM AC1,UDPBUF(DDB)
UDPCO1:	LDB TAC,PUNIT			;CALLED FROM C1REGO
	DPB AC1,[POINT 22,C1APT+C1PPTR+FPACKS-1(TAC),35]	;CLOBBER PRG TBL
	DPB AC1,[POINT 22,C1BPT+C1PPTR+FPACKS-1(TAC),35]	;CLOBBER PRG TBL
	MOVEI TAC,C1BW!<DSKCHN⊗3>!DSKCHN
	MOVEM TAC,C1PCW(AC1)		;SETUP PROGRAM CONTROL WORD
	POPJ P,

;dump mode command pointers.  Each transfer is broken into blocks.
;as much is done as fits within one group.  2 words per block
;one for TFRIOW, one for TFRSEC.
GETCOR:	HLRZ AC1,DMPBUF(DDB)
	JUMPN AC1,GETCO1		;USE WHAT WE HAVE
IfStructure,<
	MOVE AC3,DD.BPG(DDB)		;get number of blocks per group
	LSH AC3,1			;account 2 words per block
	ADDI AC3,2			;a couple more for good measure
>;IfStructure
NoStructure,<
	MOVEI AC3,2*40+2		;Twice the number of blocks/group
>;NoStructure				; plus room for mistakes
	PUSHJ P,UFSGET			;GET DUMP MODE COMMAND BUFFER. UUO level
GETCO1:	HRLZM AC1,DMPBUF(DDB)
	POPJ P,

RTNCOR:	HLRZ AC1,DMPBUF(DDB)		;Release dump mode pointer buffer
	SETZM DMPBUF(DDB)
RCOR3:	JUMPE AC1,CPOPJ			;IF NONE, LEAVE QUICK
RCOR1:	JRST FSGIVE			;RETURN IT
;⊗ DSKTM1 EXTTIM TIMCNV TIMCN0 DSKSTP OSAT

;TIME CONTROL. INFORMATION KEPT AS FOLLOWS:
;DATE CREATED IN UFD (FILEXT) [DEC - DATE LAST WRITTEN]
;TIME LAST WRITTEN IN UFD (FILPRO) [DEC - TIME CREATED]
;TIME LAST REFERENCED IN FILE - DREFTM
;TIME LAST DUMPED IN FILE - DDMPTM
;LATTER TWO ARE ACCESSED THRU 6-WORD ENTER-LOOKUP BLOCKS IF
;DMPBIT SET BY INIT.

;CALLED FROM UUOCON (SETCRD UUO) AND FROM ENTER (DENT2)
↑DSKTM1:MOVE TAC,TIME
	IDIVI TAC,=3600			;JIFFIES/MIN.
	HRRZ TAC1,THSDAT
	DPB TAC,[POINT 11,TAC1,23]
	LDB TAC,[POINT 3,THSDAT,35-12]	;EXTRA BITS IN TAC - RPH/DATE75
	POPJ P,				;RETURN RESULT IN TAC1.

IFN FTLUFD,<
EXTTIM:	CONO PI,CLKOFF
	MOVE TAC,PSTIME		;TIME IN 60THS
	LSH TAC,-2		;TIME IN 15THS
	TRZ TAC,1		;CLEAR DAYLIGHT SAVINGS BIT
	SKIPE DAYLIT
	IORI TAC,1		;STORE DAYLIGHT BIT AS LOW 15THS OF SEC
	MOVE TAC1,PSDATE	;15 BIT DATE
	CONO PI,CLKON
	DPB TAC1,[POINT 15,TAC,14]	;BYTE (15)DATE (21)TIME IN 15THS
	MOVEM TAC,DATWRT(DDB)	;STORE EXTENDED DATE WRITTEN (USING PST ALWAYS)
	POPJ P,

;CONVERT USER SPECIFIED TIME WRITTEN INTO EXTENDED TIME WRITTEN FORMAT
TIMCNV:	LDB TAC,[POINT 3,ACCEXT(DDB),20]	;HI 3 BITS OF DATE WRITTEN
	LDB TAC1,[POINT 12,ACCPRO(DDB),35]	;LO 12 BITS
	DPB TAC,[POINT 3,TAC1,23]		;15 BITS OF DATE WRITTEN
	LDB TAC,[POINT 11,ACCPRO(DDB),23]	;11 BITS TIME WRITTEN
	IMULI TAC,=60*=15			;15THS SINCE MIDNIGHT
;BOTTOM BIT ALREADY GUARANTEED ZERO
	SKIPE DAYLIT				;ASSUME CURRENT DAYLIGHT SVG STATE
	SUBI TAC,=60*=60*=15-1			;SET DAYLITE BIT AND SOS AN HOUR
	JUMPGE TAC,TIMCN0
	ADD TAC,[=24*=60*=60*=15]		;WRAPPED BACK TO YESTERDAY
	SUBI TAC1,1
TIMCN0:	DPB TAC1,[POINT 15,TAC,14]		;EXTENDED DATE WRITTEN FORMAT
	MOVEM TAC,DATWRT(DDB)
	POPJ P,
>;IFN FTLUFD

;DSKSTP CALLED FROM AUTORELOAD CODE IN OUTER TO PRESERVE THE SAT TABLE
↑DSKSTP:PUSHJ P,DQINI		;CLEAR QUEUE AND BLAST THE DISK
	CONO PI,PION!DSKON	;TURN ON PI AND CH6
OSAT:	MOVEI DDB,DSKDDB
	SETZM JOB		;CAUSE XWSYNC TO LOOP
	JRST CUSATO


;⊗ DSKINI DKINI1 DKINI2 DKIN2A DKINI3 DKIN3A DKINI4

;DSKINI CALLED VIA DISPATCH FROM IOGO IN SYSINI 

DSKINI:	PUSHJ P,DQINI			;CLEAR QUEUES AND BLAST THE DISK
	PUSHJ P,SBAINI			;Initialize list of available system buffers
	MOVEI DDB,DSKDDB		;MAKE SURE WE KNOW WHAT DDB WE USE
	SETZB IOS,DEVIOS(DDB)
	SETZM IBMTWC			;ZERO STATISTICS
	SETZM DSKTWC
	SETZM SWPTWC
	SETZM JOB			;CAUSE XWSYNC TO LOOP BUSY-WAITING
	SETZM CUSLOC			;FORGET CUSLOC ON RESTARTS
	SETZM UFDUSE
	SETZM UFDWAT
	SETZM UFDWAK
IFN FTF2,<
	SETOM PRECAL			;Force Recal on each pack before using it
IFG NPACKS-1,<
	MOVE TAC,[PRECAL,,PRECAL+1]
	BLT TAC,PRECAL+NPACKS-1		;Force Recal for each pack
>;IFG NPACKS-1
>;IFN FTF2
	SYSPIN				;CERTAINLY ISN'T ON YET
IFE FTC1MAIN,<
;Don't read old disk SAT if not main disk, but leave code here in case we
;want to patch system to use it.
	JRST DKIN2A
>;IFE FTC1MAIN
	SKIPN SATDIR			;READ IF -1.(FIRST TIME ONLY)
	JRST DKINI1			;ELSE WRITE
	MOVE TAC,SATID+SATTAB		;MAKE SURE COPIES OF SATID AGREE
	MOVEM TAC,SATID1
	MOVEM TAC,SATID2
	MOVEI DAT,SATIN
	PUSHJ P,NEWAIT			;READ SAT TABLE AND WAIT
	MOVE TAC,SATID+SATTAB		;NOW COPY GOOD SATID
	MOVEM TAC,SATID1
	MOVEM TAC,SATID2
	SETZM SATDIR			;FROM NOW ON, WRITE THE SAT TABLE
IFN FTECCT,<
	SETZM ECCTKT			;CLEAR ECCTKT ENTRIES FOR SYSTEM PACKS
	MOVE TAC,[ECCTKT,,ECCTKT+1]
	BLT TAC,ECCEND
>;IFN FTECCT
	PUSHJ P,ACISTT			;COUNT THINGS IN THE SAT 
	JRST DKINI2

DKINI1:	PUSHJ P,OSAT			;WRITE SAT TABLE ON RESTARTS
DKINI2:	MOVE TAC,DSKDDB+DEVIOS		;GET IOS BITS
	TRNE TAC,IODERR!IODTER		;DID IT WORK?
	JRST NOSAT			;NO
	MOVEI DDB,DSK.NX		;LINK OUT CRUFTY OLD DISK DDB'S
	SETZB IOS,DEVIOS(DDB)
	HRLM DDB,DSKDDB+DEVSER
DKIN2A:
NoStructure,<
	SETZM SATADR+1
IFG UPACKS-1,<
	MOVE TAC,[SATADR+1,,SATADR+2]
	BLT TAC,SATADR+UPACKS
>;IFG UPACKS-1
	SETOM UDPOWN
IFG UPACKS-1,<
	MOVE TAC,[UDPOWN,,UDPOWN+1]
	BLT TAC,UDPOWN+UPACKS-1
>;IFG UPACKS-1
	SETZM UDPCNT
IFG UPACKS-1,<
	MOVE TAC,[UDPCNT,,UDPCNT+1]
	BLT TAC,UDPCNT+UPACKS-1
>;IFG UPACKS-1
	SETZM SATMOD			;SAT not yet Modified
IFG UPACKS,<
	MOVE TAC,[SATMOD,,SATMOD+1]	;SAT for UDPs not yet modified
	BLT TAC,SATMOD+UPACKS
>;IFG UPACKS
>;NoStructure

IfStructure,<
	MOVSI	AC1,-STRMAX
DKINI3:	SKIPN	AC2,SDBADR(AC1)		;skip if we have a structure data block
	JRST	DKINI4
	TRNN	AC1,-1			;Skip unless structure # zero
	JRST	DKIN3A
	SETZM	ST.SAD(AC2)		;clear address of SAT table
	SETZM	ST.NAM(AC2)		;No structure name yet
DKIN3A:	SETOM	ST.JOB(AC2)		;Set owner to -1 to mean public
	SETZM	ST.CNT(AC2)		;count of DDBs for this structure
	SETZM	ST.SMD(AC2)		;SAT not yet Modified
DKINI4:	AOBJN	AC1,DKINI3
>;IfStructure


IFN FTDSTT,<				;DSK STATISTICS
	MOVEI TAC,DSTBUF-1
	MOVEM TAC,DSTPUT		;INITIAL PUTTER
	SETZM DSTCNT			;COUNT A NEW GENERATION OF STATS.
>;IFN FTDSTT

IFE FTF2,<
	CONO CAR,400001			;TURN OFF THE "IN USE" LIGHT
>;IFE FTF2

IFE FTRHRAW,<	; don't initialize file system if RH disks are raw (no data)
IFN FTRH,<
	PUSHJ P,FILINI			;initialize for RH-based file system
>;IFN FTRH

	PUSHJ P,DKSINI			;Initialize new swapping service
>;IFE FTRHRAW

IFE FTC1MAIN,<

IFN FTRH,<				;if you really mean it!
;here we make DSKDDB be device OSK, and RSK structure be device named DSK.
	MOVSI	TAC,'OSK'
	MOVEM	TAC,DSKDDB+DEVNAM	;clobber name of old-style DSK device
	MOVEI	TAC,ASSCON		;set assigned by console to job 0
	IORM	TAC,DSKDDB+DEVMOD	;Meaning: device is detached
	MOVE	TAC,PRSNUM		;Number of the primary RH structure
	MOVEM	TAC,DSKNUM		;for WHOSER
	MOVE	TAC,SDBADR(TAC)		;SDB for prime structure
	MOVE	DDB,ST.MDB(TAC)		;model ddb of PRS
	MOVSI	TAC1,'DSK'
	MOVEM	TAC1,DEVNAM(DDB)	;this is the genuine waranted DSK
	MOVE	TAC1,DD.RPB(DDB)
	MOVSI	TAC,1(TAC1)		;# of R per B +1 = optimal buffer count
	LSH	TAC1,RECWSH		;Size of a block in words
	HRR	TAC,TAC1
	MOVEM	TAC,346			;Magic cell in LOWCOR

>;IFN FTRH and you really mean it.

>;IFE FTC1MAIN

	POPJ P,				;Exit from DSKINI
;⊗ DKSINI PASCHK PASOK PAKERR PASTRY PASERR PASIOE NOSAT DQINI ACISTT ACIST1 MRKITB

IFE FTNSWP,<				;OLD STYLE UDP SWAPPING CODE
DKSINI:	SETZM SWPDDB			;ASSUME WE'RE NOT SWAPPING ON THE UDP
PASCHK:	MOVEI DDB,UDP1DD		;THE FIRST UDP
	MOVEI TAC,ASSCON!ASSPRG
	IORM TAC,DEVMOD(DDB)		;ASSIGN THIS UDP
	MOVE TAC,['*SWAP*']
	MOVEM TAC,DEVLOG(DDB)		;ANNOUNCE THAT UDP IS USED FOR SWAPPING
	SETZB TAC,DEVIOS(DDB)
	DPB TAC,PJOBN			;TO JOB 0
	LDB TAC,PUNIT
	SETZM UDPOWN-1(TAC)		;RESERVE PRIVATE UDP FOR JOB ZERO
	MOVEI DAT,PASSIN		;READ PASSWORD BLOCK
	PUSHJ P,NEWAIT
	MOVE TAC,DEVIOS(DDB)
	TRNE TAC,IODERR!IODTER!IOIMPM
	JRST PASERR			;IO ERRORS OCCURED
	MOVE TAC,['PASS  ']		;IS IT INITIALIZED
	CAMN TAC,DSKDAT(DDB)
	CAME TAC,DSKDAT+1(DDB)
	JRST PASOK			;NO. IT IS GRUNGY
	SKIPE TAC,DSKDAT+2(DDB)		;PASSWORD MUST BE NULL FOR SWAPPING
	CAMN TAC,['*SWAP*']		;SWAPPING PACK?
	JRST PASOK			;YES.
	JRST PAKERR			;BARF

PASOK:	MOVEI DAT,PASOUT		;NOW TRY WRITING
	PUSHJ P,NEWAIT
	MOVE TAC,DEVIOS(DDB)
	TRNE TAC,IODERR!IODTER!IOIMPM
	JRST PASERR			;POSSIBLY WRITE-LOCKED
	MOVEM DDB,SWPDDB		;SAVE DDB ADDRESS FOR SWAP OPS
	POPJ P,

PAKERR:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /WRONG PACK (NOT THE SWAPPING PACK) IS MOUNTED ON UDP1!
/
PASTRY:	PUSHJ P,DISMES
IFKL10,< ASCIZ /FIX IT.  TYPE RN<CR> TO TRY AGAIN.
/>;IFKL10
NOKL10,< ASCIZ /FIT IT.  Push CONTINUE to try again.
/>;NOKL10
	PUSHJ P,DISFLUSH
	POPACS
	HALT PASCHK			;TRY ALL OVER AGAIN


PASERR:	PUSHACS
	PUSH P,TAC
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /SWAPPING DRIVE - UDP1 - /
	POP P,TAC
	TRNN TAC,IOIMPM			;OFFLINE OR WRITE-LOCK?
	JRST PASIOE			;NO.  REAL IO ERROR
	PUSHJ P,DISMES
	 ASCIZ /OFF LINE OR WRITE LOCKED
/
	JRST PASTRY

PASIOE:	PUSHJ P,DISMES
	 ASCIZ /IO ERROR
/
	JRST PASTRY
>;IFE FTNSWP

NOSAT:	PUSHACS
	MOVE TAC,[JRST AUTOLOAD]	;MAKE THEM START FROM THE FRONT
	MOVEM TAC,SYSDSP
	MOVEM TAC,SYSDSP+2
	MOVE TAC,[SYSDSP+2,,SYSDSP+3]
	BLT TAC,SYSDSP+7
	MOVE TAC,UPTIME
	MOVEM TAC,LASTRESTART		;DON'T DO A 200 RESTART
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /FAILED TO GET SAT TABLE READ IN.  CHECK DISK, THEN RELOAD.
/
	PUSHJ P,DISFLUSH
	POPACS
	HALT AUTOLOAD

DQINI:	SETZM PQUEUE
	MOVE TAC,[PQUEUE,,PQUEUE+1]
	BLT TAC,PQZEND-1
	PUSHJ P,DISKUP			;MAKE THE DISK LISTEN TO US
	SETZM SQREQ
	POPJ P,

;ENTER HERE FROM SATGET AT UUO LEVEL FOR NEW STYLE UDP SERVICE
ACISTT:	LDB AC3,PUNIT			;GET THE DISK UNIT NUMBER
IFN FTRH,<
	CAMLE AC3,[UPACKS]
	JRST ACIST2			;Mount RH-based SAT (see other RH SAT ops)
>;IFN FTRH
IFN FTECCT,<
	JUMPE AC3,ACIST1		;DO THIS HERE ONLY FOR UDPS
	MOVEI TAC,FPACKS-1(AC3)		;GET PACK NUMBER (NOT UNIT #) OF THIS UDP
	IMULI TAC,NECCTK		;MAKE INDEX INTO ECCTKT
	HRLI TAC,-NECCTK		;MAKE AOBJN POINTER
	SETZM ECCTKT(TAC)		;CLEAR OUT OUR DATA
	AOBJN TAC,.-1
ACIST1:
>;IFN FTECCT
NoStructure,<
	MOVE TAC,LSTBTB(AC3)		;NUMBER OF BITS IN THIS SAT TABLE
	ADDI TAC,43
	IDIVI TAC,44
	IMULI TAC,44			;CALC NUMBER OF WORDS IN SAT TABLE
	MOVE AC3,SATADR(AC3)		;ADDRESS OF SAT TABLE
>;NoStructure
IfStructure,<
	MOVE AC3,SDBPTR(DDB)
	MOVE TAC,ST.SAD(AC3)		;ADDRESS OF SAT TABLE
	MOVE TAC,SATID(TAC)
	MOVEM TAC,ST.NAM(AC3)		;Save SAT name in the SDB
	MOVE TAC,ST.BTB(AC3)		;NUMBER OF BITS IN THIS SAT TABLE
	ADDI TAC,43
	IDIVI TAC,44
	IMULI TAC,44			;CALC NUMBER OF WORDS IN SAT TABLE
	MOVE AC3,ST.SAD(AC3)		;ADDRESS OF SAT TABLE
>;IfStructure
	MOVE TAC1,[POINT 1,SATBIT(AC3)]	;PREPARE TO COUNT SAT BITS!
	SETZB AC1,BADCHK(AC3)		;BIT COUNT, BAD TRACK CHECKSUM
	ILDB AC2,TAC1			;LOAD A BIT
	ADDI AC1,(AC2)			;SEE THE CLEVER PROGRAMMER COUNT BITS
	SOJGE TAC,.-2			;COUNT THEM ALL
	MOVEM AC1,DSKUSE(AC3)		;SET HONEST DSKUSE
	SKIPG AC2,BADCNT(AC3)		;ANY BAD TRACKS TO TURN ON?
	POPJ P,				;NO.
	CAILE AC2,BADMAX
	MOVEI AC2,BADMAX
	HRLOI AC2,-1(AC2)
	EQVI AC2,BADTRK(AC3)		;FORM AOBJN POINTER
MRKITB:	MOVE TAC,(AC2)
	ADDM TAC,BADCHK(AC3)		;ACCUMULATE CHECKSUM
	PUSHJ P,MRKBLK			;MARK BAD TRACK SO IT WON'T GET USED
	AOBJN AC2,MRKITB
	POPJ P,

;⊗ DKSINI DKSIN1 DKSIN2 SNOFIL DKSSTO DKSNX1 DKSFST DKSNXT DKSNLS

;DKSINI - INITIALIZE FOR NEW FORMAT SWAPPING

IFN FTNSWP,<				;TWO PAGES (both non-RH and RH versions)

IFE FTRH,<				;Remainder of this page

DKSINI:	MOVEI DDB,DSKDDB
	SETZB J,JOB
	PUSHJ P,SETDDB			;MAKE A DDB TO SWAP ON
	MOVEM DDB,SWPDDB		;AND REMEMBER IT.
	DPB J,PJOBN			;ASSIGN TO JOB 0
	MOVEI TAC,ASSCON!ASSPRG		;SET SOME BITS IN THE DDB
	IORB TAC,DEVMOD(DDB)	
	MOVSI TAC,[	'[SWAP]'
			'SYS   '
			0
			'  1  4'   ]
	HRRI TAC,ACCNAM(DDB)
	BLT TAC,ACCPPN(DDB)		;STORE FOR FILSRC
	PUSHJ P,FILSRC			;SEEK SWAPPING FILE
	 JRST SNOFIL			;NO UFD FOUND FOR 1,4
	SKIPG SRCTMP(DDB)
	JRST SNOFIL			;NOT FOUND
NoStructure,<
	SKIPLE TAC,SRCLOC(DDB)
	CAMLE TAC,LSTBTB		;DISK ADDRESS IN RANGE?
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	SKIPLE TAC,SRCLOC(DDB)
	CAML TAC,ST.LSA(TAC1)		;DISK ADDRESS IN RANGE?
>;IfStructure
	JRST SNOFIL			;LOSE
	MOVE TAC,SRCEXT(DDB)
	MOVEM TAC,ACCEXT(DDB)
	MOVE TAC,SRCPRO(DDB)
	MOVEM TAC,ACCPRO(DDB)
	MOVE IOS,[READB!ALTERB,,17]
	PUSHJ P,ACCEST			;ESTABLISH ACCESS.
	MOVEI DAT,LOOKI
	PUSHJ P,QEWAIT			;SEEK FILE ON DISK. READIN RETRIEVAL
	TLNE IOS,LOSBIG
	JRST SNOFIL			;ANOTHER WAY TO LOSE.
	MOVE TAC,DDLNG(DDB)		;LENGTH OF [SWAP].SYS[1,4]
	CAME TAC,[SWPAKS*NSWCYL*TRKCYL*BKDSIZ]	;SHOULD BE THIS SIZE
	JRST SNOFIL
	MOVEI UUO,SWPAKS*NSWCYL*TRKCYL	;NUMBER OF SWAPPING TRACKS
	MOVSI TEM,-2*SWPAKS*NSWCYL	;AOBJN POINTER TO SWBAND TABLE
	PUSHJ P,DKSFST			;Initialize, get first band address & skip.
DKSIN1:	PUSHJ P,DKSNXT			;GET ADDRESS OF BEGINNING OF NEXT BAND
	PUSHJ P,DKSSTO			;STORE IT IN THE RIGHT PLACE IN SWBAND
	AOS AC1,TAC			;EXPECTED NEXT TRACK
	MOVEI TAC1,8			;8 MORE TRACKS TO EAT
	TRNE TEM,1
	MOVEI TAC1,9			;OR 9 FOR ODD NUMBERED BANDS
DKSIN2:	PUSHJ P,DKSNXT			;GET ADDRESS OF NEXT TRACK
	CAME AC1,TAC
	JRST SNOFIL
	ADDI AC1,1
	SOJG TAC1,DKSIN2
	AOBJN TEM,DKSIN1
	POPJ P,

SNOFIL:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /IMPROPER SWAPPING FILE DATA.  FIND A WIZARD!  DON'T RELOAD!!!
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	HALT .

DKSSTO:	PUSH P,TAC			;SAVE DISK ADDRESS
	HRRZ TAC,TEM
	IDIVI TAC,2*NSWCYL
	LSH TAC,1
	ANDCMI TAC1,1
	IMULI TAC1,SWPAKS
	ADDI TAC1,(TAC)
	DPB TEM,[POINT 1,TAC1,35]
	POP P,TAC
	MOVEM TAC,SWBAND(TAC1)
	POPJ P,


DKSNX1:
NoStructure,<
	MOVEI DAT,RCPGRP
>;NoStructure
IfStructure,<
	MOVE DAT,DD.RPG(DDB)
>;IfStructure
	ADDM DAT,USETP(DDB)		;USET POINTER POINTS TO NEXT GROUP
	MOVEI DAT,GGRETD		;GET GROUP RETRIEVAL INTO DDB
	PUSHACS
	PUSHJ P,QEWAIT
	TLNE IOS,LOSBIG
	JRST DKSNLS
	POPACS
	SKIPA
DKSFST:	AOS (P)				;here for first call to DKSNXT.  Skips
NoStructure,<
	MOVEI DAT,BKPGRP
	MOVE DSER,[POINT 18,DPTR(DDB)]
>;NoStructure
IfStructure,<
	MOVE DAT,DD.BPG(DDB)
	CAIE DAT,FWRTVL			;Skip if fullword retrieval
	SKIPA DSER,[POINT 18,DPTR(DDB)]	;use 32 halfword addresses/group
	MOVE DSER,[POINT 36,DPTR(DDB)]	;Use 112 full word addresses/group
>;IfStructure
DKSNXT:	JUMPE DAT,DKSNX1		;NO MORE ENTRIES THIS GROUP
	ILDB TAC,DSER			;GET NEXT ENTRY FROM DPTR TABLE
	SOJA DAT,CPOPJ

DKSNLS:	POPACS
	JRST SNOFIL

>;IFE FTRH

;New format swapping on RH ;⊗ DKSINI DKSINB DKSINC DKSIND DKSINE DKSING

IFN FTRH,<

DKSINI:	MOVE	TAC,PRSNUM
	MOVE	TAC,SDBADR(TAC)
	MOVE	DDB,ST.MDB(TAC)		;Model DDB for primary RH structure
	SETZB	J,JOB
	PUSHJ	P,SETDDB		;MAKE A DDB TO SWAP ON
	MOVEM	DDB,SWPDDB		;AND REMEMBER IT.
	DPB	J,PJOBN			;ASSIGN TO JOB 0
	MOVEI	TAC,ASSCON!ASSPRG	;SET SOME BITS IN THE DDB
	IORB	TAC,DEVMOD(DDB)	
	MOVE	TAC,['*SWAP*']
	MOVEM	TAC,FILNAM(DDB)		;For WHO - not really a file!
;Compute the size of a band
	MOVE	AC3,SDBPTR(DDB)		;Point again to SDB table
	MOVE	AC2,ST.TYP(AC3)		;Get the disk type characteristics
	MOVE	TAC,SECCYL(AC2)		;Number of sectors per cylinder
	LSH	TAC,RECWSH		;Number of words per cylinder
	IDIVI	TAC,MINSBS		;Divide by minimum desired band size
	SKIPG	TAC1,TAC		;Skip if more than zero bands per cyl
	MOVEI	TAC1,1			;Well, use a smaller band size.
	MOVN	AC1,TAC1		;Save -<number of bands per cyl>
	LSH	TAC1,PGSFT		;#of bands * size of a page
	MOVE	TAC,SECCYL(AC2)		;Size of the cylinder again
	LSH	TAC,RECWSH		;Size of cylinder in words
	IDIV	TAC,TAC1		;result is number of pages per band
	LSH	TAC,PGSFT
	MOVEM	TAC,RHSBSZ		;Save as band size.
	MOVE	TAC,NSSUN		;Number of sectors/unit for swapping
	IDIV	TAC,SECCYL(AC2)		;result is number of cylinders/Unit
	MOVN	AC2,TAC			;Save - number of cylinders/unit
;Initialize the band tables
;	AC3 : SDB (ST.UIS is number of units/structure)
;	AC2 : - Number of cylinders/unit
;	AC1 : - Number of bands/cylinder
;
	MOVSI	TAC,-BNDTSZ		;AOBJN pointer to band table
	HRLZ	TAC1,AC2		;-number of cylinders,,0
DKSINB:	MOVN	DSER,ST.UIS(AC3)	;-number of units
	HRLZ	DSER,DSER		;-number of units,,0
DKSINC:	HRLZ	DAT,AC1			;-number of bands/cyl,,0
DKSIND:	JUMPGE	TAC,DKSINE		;Jump if exhausted band table
	SETZM	SWBAND(TAC)
	DPB	DSER,RHSUNP		;Store the unit number
	DPB	TAC1,RHSCYP		;Store the cylinder number
	DPB	DAT,RHSBNP		;Store the band in cylinder number
DKSINE:	ADD	TAC,[1,,1]
	AOBJN	DAT,DKSIND		;Advance to next band
	AOBJN	DSER,DKSINC		;Advance to next unit
	AOBJN	TAC1,DKSINB
	SKIPL	TAC1,TAC		;are there un-initialized bands?
	JRST	DKSING			;no.  we filled band table
	SETOM	SWBAND(TAC1)		;Yes.  Set them unusable
	AOBJN	TAC1,.-1		; (job field is non-zero)
Repeat 0,<
	HLRO	TAC,TAC			;-count of extra space
	MOVN	TAC,TAC
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/[Swapping band table exceeds allocated disk space by /]
	POP	P,TAC
	PUSHJ	P,DISDEC
	PUSHJ	P,DISMES
	 ASCIZ	/ entries.]
/
	POPACS
>;Repeat 0
	POPJ	P,

DKSING:	TLNN	TAC,-1
	POPJ	P,
	HLRZ	TAC,TAC
	PUSHACS
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/[Allocated swapping space exceeds the capacity of the band table by /]
	POP	P,TAC
	PUSHJ	P,DISDEC
	PUSHJ	P,DISMES
	 ASCIZ	/ bands.]
/
	POPACS
	POPJ	P,

>;IFN FTRH

>;IFN FTNSWP
;RH: Initialize File System.  ;⊗ PRSNAM RHSBIT PGSFT PGSIZ FILINI RILSS0 RILSS1 RILIN1 RILIN2 RILIN3 FILINE NSSDB MAKSTR MAKST1

IFN FTRH,<	;to end of p.14
NoStructure,<	.Fatal	The RH disks won't work unless FTSTRUCTURE is non-zero>

PRSNAM:	'RSK   '		;Name of primary structure (Arg to MAKSTR)
RHSBIT==RECSIZ			;Bit table starts 1 record into SAT table

PGSFT==9			;Amount to shift to convert page # to address
PGSIZ==<1⊗PGSFT>
EXTERN	CHKHOM			;routines in PHYDAT

;UDB and CDB cells & bits
EXTERN	UDBCDB,UDBADR,CDBADR,UDBSTR
EXTERN	IS.ERR,IS.NRT,US.OFS,US.CHB,UDBSTS,US.DSK,CDBUDB,UDBSIZ,MS%FAT,MS%DOM

INTERN	STROFL
INTERN	PGSFT,DWRITE,STRMOU,STRDMO
INTERN	MAKSTR,STRADR,FILINE	;called from PHYDAT
INTERN	SYBEXP			;used in PHYDAT for initialization I/O

DEFINE	BKPGRP	<↔.FATAL use DD.BPG   Number of blocks per group.    done?>
DEFINE	RCPBLK	<↔.FATAL use DD.RPB   Number of records per block    done?>
DEFINE	RCPGRP	<↔.FATAL use DD.RPG   number of records per group.   done?>
DEFINE	SECSIZ	<↔.FATAL use DD.SSZ   WC of rec 0 of blk             done?>
DEFINE	BKDSIZ	<↔.FATAL use DD.RBB Shifted by RECWSH>
;DEFINE	BLKWDS  <↔.FATAL use DD.RRB Shifted by RECWSH + DD.SSZ>

;transliterations:
; DD.RTL(DDB)	for	......	number of useful words of rtvl info (for Foonly
;				  disks, this is 40 though Secsiz is 200) 


FILINI:	SETZM	RHDTWC		;RH Disk Total Word Count
	SETZM	RHDTWO		;RH Disk Total Write Op
	SETZM	RHDTRO		;RH Disk Total Read Op
	SETZM	RHDRWO		;RH Disk Retrieval Write Operations
	SETZM	RHDRRO		;RH Disk Retrieval Read Operations
	SETZM	RHDDWO		;RH Disk Data Write Operations
	SETZM	RHDDRO		;RH Disk Data Read Operations

	SETZM	DMXQTM		;Longest duration transfer
	SETZM	DMXQTM+1	; High precision timer doubleword
	SETZM	DMXQWC		;WC corresponding to longest duration Xfer.

	MOVEI	TAC,RHDQTB-1	;Pointer to table of debugging entries
	MOVEM	TAC,RHDDBQ

	MOVEI	DDB,DSKDDB		;Create Model DDB for RSK
	SETZB	J,JOB
	PUSHJ	P,RSTDDB		;Make a large DDB for RH Disks.
	MOVE	TAC,SDBPTR(DDB)
	SOS	ST.CNT(TAC)		;decrement number of main DSK ddbs in use
	MOVEI	TAC,0			;search for an available structure number
RILSS0:	SKIPN	SDBADR(TAC)
	JRST	RILSS1
	CAIGE	TAC,STRMAX		;have we reached the max value yet?
	AOJA	TAC,RILSS0		;no..
	JSP	TAC,FILINE		;no structure # available for primary S
	
RILSS1:	MOVEM	TAC,PRSNUM		;Save number of primary RH structure
	MOVE	TAC1,PRSNAM		;Name of primary RH structure
	PUSHJ	P,MAKSTR
	MOVEI	TAC,DSKDDB		;Start at model DDB for main disk
RILIN1:	MOVE	TAC1,TAC		;copy previous to TAC1
	HLRZ	TAC,DEVSER(TAC1)	;Advance TAC to NEXT.
	SKIPN	TAC			;SHOULDN'T HAPPEN
	JSP	TAC,FILINE
	CAME	TAC,DDB			;Have we got the right one yet?
	JRST	RILIN1			;NO. KEEP SEARCHING
	MOVE	AC1,DEVSER(DDB)		;LINK out of our DDB
	HLLM	AC1,DEVSER(TAC1)	;  becomes Link out of previous
;now splice it in where we want it....past all the UDPs
	HRRZ	AC1,AC1			;Keep device service disp tbl addr
	MOVE	TAC,TAC1
RILIN2:	MOVE	TAC1,TAC		;previous DDB to TAC1
	HLRZ	TAC,DEVSER(TAC1)	;get next DDB address to TAC
	JUMPE	TAC,RILIN3		;TAC1 = last old style dsk ddb
	HRRZ	AC3,DEVSER(TAC)
	CAMN	AC3,AC1
	JRST	RILIN2			;TAC is another dsk-like ddb
RILIN3:	MOVE	TAC,DEVSER(TAC1)	;Link out of last DSK DDB
	HRLM	DDB,DEVSER(TAC1)	;after the last DSK, add RSK
	HRRI	TAC,DSKDSP		;new device service disp tbl
	MOVEM	TAC,DEVSER(DDB)		
	MOVEI	TAC1,SYBEXP
	PUSHJ	P,GETEMP		;read map for SYSBUF
	SKIPN	TAC
	JSP	TAC,FILINE		;Lose.
	ANDI	TAC,17777		;leave only physical page #
	MOVEM	TAC,FSIPPG		;Store physical page #
	LSH	TAC,PGSFT
	MOVEM	TAC,FSIPPA		;Store physical address
IFE FTRHRAW,<	; don't do this if no home blocks yet, I suppose
	PUSHJ	P,CHKHOM		;read home blocks, build SDBs
>;IFE FTRHRAW
	POPJ	P,

FILINE:	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISUSR
	 'FILINE'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: Error in file system initialization - Called from /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL

↑NSSDB←←2	;number of spare SDBs to keep handy in spare FS list

;Enter with TAC1=Structure name; TAC=Structure Number.
;Returns DDB/new ddb address; AC1/SDB address.
;Exception: if TAC matches PRSNUM then no DDB is created; call with DDB setup.
MAKSTR:	PUSH	P,TAC1
	PUSH	P,TAC
repeat 0,<
	MOVEI	AC3,ST.LEN		;get the needed length
	PUSHJ	P,FSGET			;make the SDB
	 JSP	TAC,FILINE		;I can't wait
>;repeat 0
	MOVE AC3,[400000,,SDBFS]	;spares list to use, no failure allowed
	PUSHJ P,SFSGET			;get FS from spares list
	SETZM	(AC1)
	MOVSI	AC3,(AC1)
	HRRI	AC3,1(AC1)
	BLT	AC3,ST.LEN-1(AC1)
	MOVE	TAC,(P)
	HRRZM	AC1,SDBADR(TAC)		;enter this in the structure table
	CAMN	TAC,PRSNUM		;If this is primary structure, 
	JRST	MAKST1			;  we already have DDB set up w/model
	MOVE	AC1,PRSNUM		;Otherwise, we need a model DDB for
	MOVE	AC1,SDBADR(AC1)		; SETDDB to use, so select the model
	MOVE	DDB,ST.MDB(AC1)		; from the model for Primary Structure
	SOS	ST.CNT(AC1)		;Decrement. Anticipate AOS in SETDDB
	PUSHJ	P,SETDDB		;Make a new DDB
MAKST1:	POP	P,TAC			;Structure number again
	DPB	TAC,PUNIT		;as unit number in DDB
	MOVE	AC1,SDBADR(TAC)	
	MOVEM	AC1,SDBPTR(DDB)		;point to the given SDB
	MOVEM	DDB,ST.MDB(AC1)		;make the SBD point to the model DDB
	POP	P,TAC1
	MOVEM	TAC1,ST.NAM(AC1)
	MOVEM	TAC1,DEVNAM(DDB)
	POPJ	P,
;RH: MOUNT and DISMOUNT ;⊗ STRMOU STRMO1 STRMO2 STROFL STROF1 STROF2 STRDMO STRDM0 STRDM1 STRDM3 CHKH30 CHKH31

;This is called from CHKHOM at system initialization.
;[Also, it's called from PHYCHN when a pack comes on line!  NOT IMPLEMENTED!]

;Mount SAT for structure whose prototype DDB is in DDB.
STRMOU:	PUSHJ	P,STKACS		;Save all ACS
	MOVE	AC3,SDBPTR(DDB)		;point to the SDB
	MOVE	TAC,ST.STN(AC3)		;Get the structure number
	CAME	TAC,PRSNUM		;Is this the primary structure?
	JRST	STRMO1			;Not primary.  Avoid some tests.
	SKIPN	TAC,SDBNSS(AC3)		;Get # OF SWAPPING SECTORS
	JRST	CHKH30			;no swapping space defined on PS!
	MOVEM	TAC,NSSUN		;Save for DKSINI
	MOVE	TAC,SDBFSS(AC3)		;FIRST SWAPPING SECTOR
	MOVEM	TAC,FSSUN		;IN THE PUBLIC STRUCTURE
	MOVE	TAC,[MS%DOM]		;SAY THAT THIS IS A DOMESTIC STRUCTURE
	IORB	TAC,ST.STS(AC3)
	TDNE	TAC,[MS%FAT]		;fatal errors in this structure?
	JRST	CHKH31			;Yes.
	SETOM	ST.JOB(AC3)		;Mark as a sharable device
	PUSHJ	P,GETSAT		;Mount the SAT.
	 JRST	FILINE			;Failure: TAC set with error PC
	MOVE	AC3,SDBPTR(DDB)		;check sat name
	MOVE	TAC,ST.SAD(AC3)		;Address of the SAT
	MOVE	TAC,SATID(TAC)		;Fetch SAT ID from the table
	CAME	TAC,ST.NAM(AC3)		;Does it agree with name from home blocks?
	JSP	TAC,FILINE
	PUSHJ	P,ACISTT		;Mount SAT
	MOVE TAC,UPTIME			;don't say anything if system just started
	CAIG TAC,JIFSEC			;avoid msg if up less than a second
	POPJ P,				;omit redundant msg
	PUSHJ	P,DISGST		;print time on CTY
	PUSHJ	P,DISMES
	 ASCIZ	/Primary structure /
	MOVE	TAC1,PRSNUM
	MOVE	TAC1,SDBADR(TAC1)
	MOVE	TAC1,ST.NAM(TAC1)
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/ mounted
/
	POPJ	P,

;Here to mount other than primary structure.  Errors are not fatal.
; [If called from CLOCK LEVEL some errors mean can't get free stg!!!]
;
STRMO1:	MOVE	TAC,ST.STS(AC3)		;Get status of this structure
	TDNE	TAC,[MS%FAT]		;Fatal error in structure?
	JSP	TAC,STRMO2		;Yes.  Can't mount SAT
	SETOM	ST.JOB(AC3)		;Mark as a sharable device
	PUSHJ	P,GETSAT		;Mount the SAT.
	 JRST	STRMO2			; Failure: TAC set with error PC
	MOVE	AC3,SDBPTR(DDB)		;check sat name, get ID from SDB
	MOVE	TAC,ST.SAD(AC3)		;get SAT adr
	MOVE	TAC,SATID(TAC)		;get ID from SAT
	CAME	TAC,ST.NAM(AC3)
	JSP	TAC,STRMO2
	PUSHJ	P,ACISTT		;Mount SAT
	PUSH	P,DDB
	PUSHJ	P,DISUSR
	 'STRMOU'
	PUSHJ	P,DISMES
	 ASCIZ	/Structure /
	POP	P,DDB
	MOVE	AC3,SDBPTR(DDB)
	MOVE	TAC1,ST.NAM(AC3)
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/ mounted
/
	POPJ	P,

;here from any error in mounting non-Primary Structure
STRMO2:	PUSH	P,DDB
	PUSH	P,TAC
	PUSHJ	P,DISUSR
	 'STRMOU'
	PUSHJ	P,DISMES
	 ASCIZ	/Failed to Mount Structure /
	MOVE	DDB,-1(P)
	MOVE	AC3,SDBPTR(DDB)
	MOVE	TAC1,ST.NAM(AC3)
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/; error PC = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POP	P,DDB
	PUSHJ	P,STRDMO	;Dismount structure
	POPJ	P,


;Here from PHYSIO (PHYOFL) at interrupt level.  A unit has gone offline.
;Think about dismounting the structure.  DDB is setup to the model DDB
;of this structure.  All ACs have been saved in PHYSIO.
STROFL:	LDB	AC3,PUNIT
	CAME	AC3,PRSNUM
	JRST	STROF1
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/A unit of the primary file structure has gone offline.
You'll have to fix it before this system does any more useful work
/
	PUSHJ	P,DISFLU
	PUSHJ	P,WDDTCA		;give him a chance to fix it
	POPJ	P,

STROF1:	MOVE	AC3,SDBPTR(DDB)
	PUSH	P,DDB			;Save the DDB
	PUSH	P,ST.NAM(AC3)		;Save the name.  We use it in either msg
	SKIPG	ST.CNT(AC3)
	JRST	STROF2			;no users of the structure.  Take it out
	PUSHJ	P,DISUSR
	 'UDPOFL'
	PUSHJ	P,DISMES
	 ASCIZ	/A unit of structure /
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/ has gone offline while DDBs for this structure still exist.
No new pack will be usable on this drive until the old pack comes
back and the DDBs referencing that pack are released.
/
	POP	P,DDB
	POPJ	P,


STROF2:	PUSHJ	P,DISUSR
	 'STRDMO'
	PUSHJ	P,DISMES
	 ASCIZ	/[Dismounting structure /
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/]
/
	POP	P,DDB		;restore from stack.  Fall into STRDMO

;Dismount structure.
;The count of DDBs should have been reduced to zero (or is it one?)
;someone should check that before calling us...
STRDMO:	LDB	AC3,PUNIT
	CAMN	AC3,PRSNUM
	POPJ	P,			;Can't Dismount Primary Structure
	MOVE	AC3,SDBPTR(DDB)
	HRRZ	DDB,DDB
	CAME	DDB,ST.MDB(AC3)
	POPJ	P,			;Can't Dismount Except from Proto DDB
	MOVEI	AC1,0
	EXCH	AC1,ST.SCW(AC3)
	SKIPE	AC1
	PUSHJ	P,FSGIVE		;Release the CCW list for the SAT
	MOVEI	AC1,0
	EXCH	AC1,ST.SAD(AC3)
	SKIPE	AC1
	PUSHJ	P,FSGIVE		;Releaae the SAT itself
	MOVN	TAC,ST.UIS(AC3)		;- Number of units in structure
	HLRZ	TAC,TAC
	HRRI	TAC,ST.UIL(AC3)		;Pointer to UDBs
STRDM0:	HRRZ	TAC1,(TAC)
	SETOM	UDBSTR(TAC1)		;Unit is not part of structure anymore
	AOBJN	TAC,STRDM0
	LDB	AC2,PUNIT
	MOVEI	AC1,0
	EXCH	AC1,SDBADR(AC2)
	SKIPE	AC1
	PUSHJ	P,FSGIVE		;Release the SDB
	SETZM	SDBPTR(DDB)
	MOVE	TAC,PRSNUM
	MOVE	TAC,SDBADR(TAC)
	SKIPA	TAC,ST.MDB(TAC)		;Start search for DDB Here.
STRDM1:	MOVE	TAC,TAC1		;Advance to next in chain
	HLRZ	TAC1,DEVSER(TAC)	;Get the link to the next
	JUMPE	TAC1,STRDM3		;Isn't supposed to happen
	CAME	TAC1,DDB		;Does DEVSER(TAC) point to our Proto DDB?
	JRST	STRDM1			;No.  Advance to next DDB
	HLL	TAC1,DEVSER(DDB)	;Get link out of us
	HLLM	TAC1,DEVSER(TAC)	;Store as link out of previous
STRDM3:	MOVEI	AC1,-DDBSKW(DDB)
	PUSHJ	P,FSGIVE
	POPJ	P,


;No Swapping Space on Primary Structure
CHKH30:	PUSHJ	P,DISUSR
	 'NOSWSP'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: No swapping space on primary structure
/
	PUSHJ	P,DISFLU
	JRST	FDDTCALL

CHKH31:	PUSHJ	P,DISUSR
	 'FATSTR'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: error(s) in definition of primary structure
Fix them and reload
/
	PUSHJ	P,DISFLU
	JRST	FDDTCALL

;RH Support: SAT & Disk Address Manipulations ;⊗ REC2BK REC2B1 REC2B0 R2BERR RRTNRC RMRKRZ RMRKRC RMRKRY RMRKRX RRTNRE RMRKRE RRTNE1 RRTNRF RMRKRF RASNBK RASNB1 RASNB2 RASNB3 RASNB4 RASNB5 BLK2RC BLK2RE ACIST2 ACIST3 ACIST4 ACIST5 ACIST6 ACIST7 ACIS7A ACIS7B ACIS7C ACIS7Z STRADR STRAD1 STRAD2 GETUDB

;Internally, the SAT table works on block numbers.  EVERYTHING else in the
;RH-disk service works on record numbers.  Thus, the disk address of the MFD,
;the location of swapping space, of the sat table on disk, and all
;disk addresses within file retrieval areas are held as record numbers.
;
;SAT operations take/return block numbers.
;We need to deal in record numbers.  Hence



;REC2BK	convert a record number to a block number
; Calling:	TAC/	Record Number
;		DDB/	DDB for appropriate structure
;	Returns +1 always, with TAC containing a record number.
;	Fatal DDT entry if the given record number isn't aligned with block origin
;
;REC2B1 as above, but no error from misalignment of RN with Block origin.
; (use REC2B1 to convert e.g., a bad sector to the block containing the sector).

REC2BK:	PUSH	P,AC1
	SETZ	AC1,		;flag: barf on misalignment
	JRST	REC2B0

REC2B1:	PUSH	P,AC1
	SETO	AC1,		;flag: don't report misalignment
REC2B0:	PUSH	P,AC2
	PUSH	P,AC3
	PUSH	P,TAC1
	PUSH	P,TAC		;Save argument for error print
	HRR	AC1,SDBPTR(DDB)
	SKIPL	TAC		;Skip if argument illegal
	CAML	TAC,ST.LAD(AC1)	;Skip if legal record number
	JRST	R2BERR		;Lose.
	IDIV	TAC,ST.RPC(AC1)	;cylinder number in TAC; relative rec num in TAC1
	IMUL	TAC,ST.BPC(AC1)	;TAC:=block number of cylinder origin
	MOVE	AC2,TAC1	;copy cylinder-relative record number to AC1
	MOVE	AC3,ST.RPB(AC1)	;Number of data records per block
	IDIVI	AC2,1(AC3)	;divisor is number of allocated recs per blk
				;AC2:=cyl-relative BN in AC1;  AC3:= RN in Blk
	SKIPL	AC1		;skip if ignore misalignment
	JUMPN	AC3,R2BERR	;Jump if bad record number was given!
	ADD	TAC,AC2		;combine the parts
	ADJSP	P,-1		;Discard saved argument (TAC)
	POP	P,TAC1
	POP	P,AC3
	POP	P,AC2
	POP	P,AC1
	POPJ	P,

R2BERR:	POP	P,TAC		;restore argument
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISUSR
	 'R2BERR'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: Illegal or misaligned Record Number at REC2BK.  RN =
/
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL

;Return a block to SAT for RH disks.
;Call with TAC = record nmber on the disk
RRTNRC:	PUSH	P,AC3
	PUSH	P,TAC1
	MOVE	AC3,SDBPTR(DDB)
	JUMPL	TAC,RRTNRF		;negative is a loser.
	CAML	TAC,ST.LAD(AC3)
	JRST	RRTNRF			;too big is a loser.
	PUSHJ	P,REC2BK		;convert given record to a block number
	IDIVI	TAC,=36			;convert to word address in sat
	ADD	TAC,ST.SAD(AC3)		;Add the base address of the SAT
	MOVE	TAC1,BITTAB(TAC1)	;get the right bit
	TDNE	TAC1,RHSBIT(TAC)	;Skip if the bit is marked as free
	JRST	RRTNRE			;make it clear we're clearing twice.
	SETOM	ST.SMD(AC3)		;SAT has been modified
	IORM	TAC1,RHSBIT(TAC)	;Clear the block (1 means free)
	MOVE	TAC,ST.SAD(AC3)
	XORM	TAC1,SATCHK(TAC)
	SOS	DSKUSE(TAC)
	JRST	RMRKRX			;pop ACS and return


;Claim a block from SAT for RH disks
;Call with TAC = record number on disk
RMRKRZ:	PUSH	P,AC3			;here if RN may be other than blk org
	TLO	AC3,400000		;and we want no message about re-marking
	JRST	RMRKRY

RMRKRC:	PUSH	P,AC3
	SETZ	AC3,			;flag zero = aligment and previously free
RMRKRY:	PUSH	P,TAC1
	HRR	AC3,SDBPTR(DDB)		;preserve flag in left half
	JUMPL	TAC,RMRKRF		;negative is a loser.
	CAML	TAC,ST.LAD(AC3)
	JRST	RMRKRF			;too big is a loser.
	SKIPL	AC3			;skip if inexact conversion wanted
	PUSHJ	P,REC2BK		;find BN that starts at RN
	SKIPGE	AC3			;skip if exact conversion was performed
	PUSHJ	P,REC2B1		;Find BN that contains RN
	IDIVI	TAC,=36			;convert to word address in sat
	ADD	TAC,ST.SAD(AC3)		;Add the base address of the SAT
	MOVE	TAC1,BITTAB(TAC1)	;get the right bit
	TDNN	TAC1,RHSBIT(TAC)	;Skip if the bit is marked as free
	JRST	RMRKRE			;remark that we're marking twice.
	SETOM	ST.SMD(AC3)		;SAT has been modified
	ANDCAM	TAC1,RHSBIT(TAC)	;Mark the block (0 means in use)
	MOVE	TAC,ST.SAD(AC3)
	XORM	TAC1,SATCHK(TAC)
	AOS	DSKUSE(TAC)
RMRKRX:	POP	P,TAC1
	POP	P,AC3
	POPJ	P,


RRTNRE:
	jrst rmrkrx	;for now, avoid the message, something makes this happen
			;that shouldn't
;JJW - Yes, this is because of brain-damaged code at DCLOSI and DCLOSO to
;delete file with multiple readers ... needs to be rewritten.

	PUSHACS
	SUB	TAC,ST.SAD(AC3)		;back to the word number only
	IMULI	TAC,=36
	PUSH	P,TAC
	MOVE	TAC,TAC1
	JFFO	TAC,.+1
	ADDM	TAC1,(P)		;form block number
	PUSH	P,ST.NAM(AC3)
	PUSHJ	P,DISUSR
	 'RRTNRE'
	PUSHJ	P,DISMES
	 ASCIZ	/Freeing an already free block.  Structure /
	JRST	RRTNE1

RMRKRE:	JUMPL	AC3,RMRKRX		;jump if don't care about already claimed
	PUSHACS
	SUB	TAC,ST.SAD(AC3)
	IMULI	TAC,=36
	PUSH	P,TAC
	MOVE	TAC,TAC1
	JFFO	TAC,.+1
	ADDM	TAC1,(P)		;form block number
	PUSH	P,ST.NAM(AC3)
	PUSHJ	P,DISUSR
	 'RMRKRE'
	PUSHJ	P,DISMES
	 ASCIZ	/Claiming an already claimed block.  Structure /
RRTNE1:	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/ BN = /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,WDDTCALL
	JRST	RMRKRX

RRTNRF:	
RMRKRF:	PUSHACS
	PUSH	P,TAC
	PUSH	P,ST.NAM(AC3)
	PUSHJ	P,DISUSR
	 'RMRKRF'
	PUSHJ	P,DISMES
	 ASCIZ	/FATAL: Illegal record number, argument to RMRKRC or RRTNRC.  Structure /
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/ RN = /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL


;Assign a free block from SAT & Mark SAT for RH disks
;Called (via JRST) from IASNBK.  Will return to IASNBK if disk is full.
;Call with TAC negative to specify any block acceptable, or with record number
;of a desirable assignment; that means that you want a block that is at least 2
;blocks after the block represented by the record in TAC (see ADDI TAC,1 below).
RASNBK:	SKIPL	TAC			;Skip if my free choice
	PUSHJ	P,REC2BK		;convert to a block number
	MOVE	AC3,SDBPTR(DDB)		;SDB address
	MOVE	AC2,ST.SAD(AC3)		;Address of the SAT itself
	SKIPN	LSTBLK(AC2)		;LSTBLK zero signifies 2nd pass.
	AOS	LSTBLK(AC2)		;so change it for first pass.
	PUSH	P,TAC			;remember if constrained or not.
	JRST	RASNB2			;Start first pass

;Here to start second pass.  Examine whole SAT bit table.
RASNB1:	POP	P,TAC			;discard constraint indicator
	SKIPN	LSTBLK(AC2)		;Have we been here before?
	JRST	RASNB9			;Yes.  disk is full. (In IASNBK)
	SETZB	TAC,LSTBLK(AC2)		;flag start of second pass.  Set TAC
	PUSH	P,[-1]			;this is my unconstrained choice
;Here at start of first or second pass.
RASNB2:	MOVE	AC3,SDBPTR(DDB)		;SDB address
	MOVE	AC3,ST.SSZ(AC3)		;Size of the SAT
	ADD	AC3,AC2			;First word beyond SAT
	SKIPGE (P)		;skip if constrained
	JRST RASNB3		;else use main loop
	ADDI TAC,1		;this is the last block we don't want
	IDIVI TAC,=36		;compute the word in SAT where we start
	ADDI TAC,RHSBIT(AC2)	;offset to the word itself
	CAML TAC,AC3		;skip if in range
	JRST RASNB1		;out of range.  do 2nd pass
	MOVE TAC1,BITTAB(TAC1)	;bit for last blk we don't want
	SUBI TAC1,1		;mask of later blocks
	CONO PI,DSKOFF		;nobody else look while I do
	TDNN TAC1,(TAC)		;skip if useful blk in this word
	AOJA TAC,[CONO PI,DSKON	;first word indicated no free blocks,
		  JRST RASNB4]	; use main loop
	AND TAC1,(TAC)		;leave bits for acceptable blocks
	JRST RASNB5

;Look through SAT bit table for a free block.  Disk channel is left on while
;searching, then turned off to recheck when we think we've found one.
RASNB3:	MOVE TAC,LSTBLK(AC2)	;my choice.  Start where I left off
	IDIVI TAC,=36		;compute the word in SAT where we start
	ADDI TAC,RHSBIT(AC2)	;offset to the word itself
RASNB4:	CAML TAC,AC3		;skip if in range
	JRST RASNB1		;out of range.  do 2nd pass
	SKIPN (TAC)		;skip if free blks in this word
	AOJA TAC,RASNB4		;All full here.  Advance to next & loop
	CONO PI,DSKOFF		;nobody else look while I do
	SKIPN TAC1,(TAC)	;skip if free blks in this word
	AOJA TAC,[CONO PI,DSKON	;Hmm, block just now went away, scan more
		  JRST RASNB4]
RASNB5:	MOVE	AC3,TAC			;Save the address of this bit table word 
	MOVE	TAC,TAC1		;Copy the bits data to TAC
	JFFO	TAC,.+1			;Bit number to TAC1
	MOVE	TAC,BITTAB(TAC1)	;get the single bit leftmost bit in word
	ANDCAM	TAC,(AC3)		;Mark this block as in use
	XORM	TAC,SATCHK(AC2)		;update checksum.
	AOS	DSKUSE(AC2)		;Count another in use
	CONO	PI,DSKON		;LET THEM BACK IN
	MOVE	TAC,SDBPTR(DDB)
	SETOM	ST.SMD(TAC)		;Flag SAT table has been changed
	SUBI	AC3,RHSBIT(AC2)		;word number from bittable origin
	IMULI	AC3,=36			;convert to blocks past SAT origin
	ADD	TAC1,AC3		;compute block number of this assignment
	POP	P,AC3
	SKIPGE	AC3			;Don't set LSTBLK if constrained choice
	MOVEM	TAC1,LSTBLK(AC2)	;Remember the last block that we used.
	MOVE	TAC,TAC1
	;...				;Fall in. Convert BN to RN
;BLK2RC	convert a block number to a record number
; Calling:	TAC/	Block Number
;		DDB/	DDB for appropriate structure
;	Returns +1 always, with TAC containing a record number.
	;...
BLK2RC:	PUSH	P,AC3
	PUSH	P,TAC1
	MOVE	AC3,SDBPTR(DDB)	;Get the SDB for structure
	SKIPL	TAC
	CAML	TAC,ST.BTB(AC3)	;Skip if legal block number
	JRST	BLK2RE
	IDIV	TAC,ST.BPC(AC3)	;quotient is the number of cylinders
	IMUL	TAC,ST.RPC(AC3)	;times number of records per cylinder
	ADD	TAC,TAC1	;Add number of RTVL records.
	IMUL	TAC1,ST.RPB(AC3);in-cyl blk number * number of data rec/block
	ADD	TAC,TAC1
	POP	P,TAC1
	POP	P,AC3
	POPJ	P,

BLK2RE:	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: Illegal block number, BN = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL

;Alternate ACISTT.  Mount RH-Based SAT.
ACIST2:	MOVE	AC3,SDBPTR(DDB)		;SBD address
	MOVE	AC2,ST.SAD(AC3)		;Address of the SAT itself
	MOVE	AC1,SATID(AC2)		;Get the SAT ID
	MOVEM	AC1,ST.NAM(AC3)		;Save it as the structure name
	MOVE	TAC,ST.BTB(AC3)		;number of blocks in this structure
	IDIVI	TAC,=36			;Word num & bit num of first non-ex B
	ADDI	TAC,RHSBIT(AC2)		;Make TAC point to last useful word in SAT.
	JUMPE	TAC1,ACIST3		;Jump if table fills last word.
	MOVN	TAC1,BITTAB-1(TAC1)	;Bit MASK to select bits for extant blks
	ANDM	TAC1,(TAC)		;Set zeros (USED!) in bits for non-ex blks.
	ADDI	TAC,1			;Point to next word in SAT
ACIST3:	HRRZ	TAC1,ST.SSZ(AC3)	;get the size of the entire SAT in words
	ADD	TAC1,AC2		;Add the origin.  TAC1 := first non-ex wrd
ACIST4:	CAML	TAC,TAC1		;are we in bounds?
	JRST	ACIST5			;no
	SETZM	(TAC)			;set zeros: USED blocks
	AOJA	TAC,ACIST4		;advance address & loop

ACIST5:	MOVE	TAC1,[POINT 1,RHSBIT(AC2)]	;pointer to all the bits
	MOVE	TAC,ST.BTB(AC3)		;Size of all space. = iteration count
	MOVE	AC3,TAC			;Total size will be decremented by free blks
	ILDB	AC1,TAC1
	SUB	AC3,AC1			;decrement if free blk
	SOJG	TAC,.-2			;loop thru SAT.
	MOVEM	AC3,DSKUSE(AC2)		;Save count of used space
	SETZM	BADCHK(AC2)
	SKIPG	AC3,BADCNT(AC2)		;ANY BAD TRACKS TO TURN ON?
	JRST	ACIST7			;NO.
	CAILE	AC3,BADMAX
	MOVEI	AC3,BADMAX
	HRLOI	AC3,-1(AC3)
	EQVI	AC3,BADTRK(AC2)		;FORM AOBJN POINTER
ACIST6:	MOVE	TAC,(AC3)
	ADDM	TAC,BADCHK(AC2)		;ACCUMULATE CHECKSUM
	PUSHJ	P,RMRKRZ		;MARK BAD TRACK SO IT WON'T GET USED
	AOBJN	AC3,ACIST6
ACIST7:	PUSH	P,DSKUSE(AC2)		;Save this count.
	MOVE	AC3,SDBPTR(DDB)
	MOVE	TAC,ST.SSZ(AC3)		;Size of SAT in words
	ADDI	TAC,RECSIZ-1
	LSH	TAC,-RECWSH		;Size of SAT in records
	MOVE	TAC1,DD.RPB(DDB)	;Number of data records per block
	IDIVI	TAC,1(TAC1)		;divisor is number of allocated R per B
					;TAC:=Size of SAT in blocks & fraction
	SKIPE	TAC1			;Is there a fraction?
	ADDI	TAC,1			;Size of SAT in blocks.
	PUSH	P,TAC
	PUSH	P,ST.STA(AC3)		;get the address of the SAT
ACIS7A:	MOVE	TAC,(P)
	PUSHJ	P,RMRKRZ
	MOVE	TAC,DD.RPB(DDB)		;Number of data records per block
	ADDI	TAC,1			;number of allocated R per B
	ADDM	TAC,(P)			;Advance to record # of next block
	SOSLE	-1(P)
	JRST	ACIS7A
	ADJSP	P,-2
	SKIPN	TAC,ST.NSS(AC3)		;Is there swapping space allocated?
	JRST	ACIS7Z			;No.  Easy.
	PUSHJ	P,REC2BK		;convert count of records to BN
	PUSH	P,TAC
	MOVN	AC1,ST.UIS(AC3)		;-number of units
	HRLZ	AC1,AC1			;-number of units,,Unit number
ACIS7B:	PUSH	P,(P)			;copy # of blks/unit for swapping.
	MOVE	TAC,ST.TYP(AC3)
	MOVE	TAC,SECUNT(TAC)		;number of sectors per unit
	IMULI	TAC,(AC1)		;starting sector on this unit
	ADD	TAC,ST.FSS(AC3)		;origin of swapping space on Unit
	PUSHJ	P,REC2BK		;Convert to a block number.
	PUSH	P,TAC			;Save the BN on the stack.
ACIS7C:	MOVE	TAC,(P)			;Get the BN
	PUSHJ	P,BLK2RC		;convert to record number
	PUSHJ	P,RMRKRZ
	AOS	(P)			;increment block number
	SOSLE	-1(P)			;decrement block count
	JRST	ACIS7C			;loop to mark swapping space in 1 unit
	ADJSP	P,-2			;discard from stack
	AOBJN	AC1,ACIS7B		;loop for all units
	ADJSP	P,-1			;Discard from stack (blks per unit)
ACIS7Z:	POP	P,TAC			;old value of DSKUSE
	CAMN	TAC,DSKUSE(AC2)
	POPJ	P,
	PUSHACS
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/Some Swapping or SAT space wasn't marked in the bit table.
/
	POPACS
	POPJ	P,


;Validity check and convert a disk address in TAC1 to absolute in TAC1.
;	Formats:
;		TAC1
;		1B0 is zero:
;			Bits 1:5 are structure number; if zero, use PUNIT.
;			Bits 6:35 are structure-relative record number.
;			Return absolute address in TAC1
;		1B0 is one:
;			Bits 1:3 are channel number;
;			Bits 4:6 are unit number;
;			Bits 7:35 are unit-relative record number.
;			Returns TAC1 unchanged, after verifying the
;			existence of the channel/unit and validity of
;			the disk address.
;Convert a structure-relative disk address in TAC1 to absolute in TAC1.
;returns zero if illegal address
STRADR:	PUSH	P,TAC
	PUSH	P,AC1
	PUSH	P,AC2
	PUSH	P,AC3
	LDB	TAC,[POINT 5,TAC1,5]	;get structure number
	SKIPN	TAC
	LDB	TAC,PUNIT
	CAML	TAC,PRSNUM		;must be at least first RH structure
	CAIL	TAC,STRMAX		;within reason?
	JRST	STRAD1			;address error
	SKIPN	TAC,SDBADR(TAC)		;is the structure defined?
	JRST	STRAD1			;no.  Tough.
	MOVEI	AC1,0
	DPB	AC1,[POINT 6,TAC1,5]	;clear structure number
	MOVE	AC1,ST.TYP(TAC)		;get the disk type parameters
	MOVE	AC2,TAC1		;rn in structure
	IDIV	AC2,SECUNT(AC1)		;number of records per unit
	MOVE	TAC1,AC3		;copy rn in unit to TAC1
	CAML	AC2,ST.UIS(TAC)		;is the quotient ok?
	JRST	STRAD1			;no.  specified rn is beyond all units
	ADDI	AC2,ST.UIL(TAC)		;point to udb address of unit.
	MOVE	AC1,(AC2)		;AC1 := UDB of selected unit.
	HRRZ	AC2,UDBCDB(AC1)		;get the channel data block address
	HRRZ	AC2,CDBADR(AC2)		;get the channel number from CDB
	DPB	AC2,[POINT 3,TAC1,3]	;channel number
	HRRZ	AC2,UDBADR(AC1)
	DPB	AC2,[POINT 3,TAC1,6]	;physical unit number
	TLOA	TAC1,400000		;set disk absolute address
STRAD1:	MOVEI	TAC1,0			;return zero for loser
STRAD2:	POP	P,AC3
	POP	P,AC2
	POP	P,AC1
	POP	P,TAC
	POPJ	P,

;AC3 := the UDB address for the C/U abs address in TAC1. (disk devices only!)
GETUDB:	PUSH	P,TAC
	MOVEI	AC3,0			;return zero if error
	LDB	TAC,[POINT 3,TAC1,3]	;get channel number
	SKIPN	TAC,CHNTAB(TAC)		;Does a CDB exist here?
	JRST	TPOPJ			;no. return illegal address
	LDB	AC3,[POINT 3,TAC1,6]	;Get the unit number
	ADDI	AC3,CDBUDB(TAC)		;point to the UDB entry
	SKIPN	AC3,(AC3)		;Get the UDB.
	JRST	TPOPJ
	MOVE	TAC,UDBSTS(AC3)
	TDNN	TAC,[US.DSK]		;Is this device a disk?
	MOVEI	AC3,0			;not a disk
	JRST	TPOPJ
>;IFN FTRH ;from beginning of p. 12
;⊗ DBUFI DBUFI1 DIEOF TSTEOF DBFIC DIBUFI DIBFI1 DIBFI2 DIBFI3 DBFSET DBFXC DBFICI DBFCI1 DBFCI2

;BUFFERED INPUT - DBUFI

DBUFI:	TLNN IOS,READB!WRITEB!ALTERB	
	JRST ENOLUK			;NO LOOKUP
	TRNE IOS,IODERR!IODTER		;ERROR LAST TIME?
	POPJ P,				;YES
	TLNE IOS,LOSBIG			;BAD RETRIEVAL?
	JRST EGARB			;YES PRINT MESSAGE
	MOVSI IOS,IO
	ANDCAB IOS,DEVIOS(DDB)		;MARK AS READING
	JSP AC1,TSTEOF			;RETURN NOW IF PAST EOF
	 JRST DIEOF
	PUSHJ P,DBFSET			;Set up common to input and output
	PUSHJ P,ADVIBX
	 PUSHJ P,DBFIC			;ROUTINE TO CALL FOR EACH FREE USER BUFFER

IFKL10,<
IFN FTRH,<
	LDB DAT,PUNIT
	CAMLE DAT,[UPACKS]
	JRST DBUFI1			;RH-Based disks don't need sweep
>;IFN FTRH
;;;	PUSHJ P,SWEEPA			;SWEEP CACHE
	PUSHJ P,VALCOR			;SWEEP THE CACHE VALIDATING CORE ONLY
;this sweep only needs to be a validate core.  The purpose is to take care of the
;case where the user has written into the buffer just before giving the IN UUO and
;so the written bit is on in the cache.  Now when the input transfer is finished
;and we do a complete sweep, the new data in core will be clobbered from the
;stale cache data that has the written bit set.
>;IFKL10

DBUFI1:	MOVEI DAT,DIBUFI
	JRST QENTER			;QUEUE TASK. USER PGM CAN PROCEED

DIEOF:	TLO IOS,IOEND
	JRST DSIOS			;STORE IOS, AND POPJ.

TSTEOF:	MOVE TAC,USETP(DDB)		;GET USET POINTER
	SUBI TAC,1
	ASH TAC,RECWSH			;RECORD NUMBER * 200 = WORD NUMBER
	CAMGE TAC,FILLNG(DDB)		;PAST EOF?
	JRST 1(AC1)			;NO.  OK TO READ MORE
	JRST (AC1)			;PAST EOF

;HERE FROM ADVIBX.  TAC1 HAS USER ADDRESS OF FULL BUFFER
DBFIC:	PUSHJ P,DBFXC
	 JUMPL TAC1,ADRERR		;jump if write protected on input
	 JFCL
	SKIPA
	AOS (P)
	POPJ P,



;***INTERRUPT SUBR***

DIBUFI:	PUSHJ P,GETBKA			;GET ADDRESS OF BLOCK INTO TFRSEC(DDB)
	JUMPE TAC,SETLOS		;NON EX = BAD RETRIEVAL
	MOVE TAC,USETP(DDB)		;RECORD NUMBER TO READ
	SUB TAC,DGRP1R(DDB)		;CALCULATE RECORD NO. IN THIS GROUP
NoStructure,<
	IDIVI TAC,RCPBLK		;TAC1←RECORD NUMBER IN THIS BLOCK
	MOVEI TAC,1(TAC1)		;STARTING DISK RECORD FOR READ
					;offset by 1 to skip rtvl record
	IORM TAC,TFRSEC(DDB)		;SET STARTING RECORD NUMBER FOR READ
	MOVEI TAC,RCPBLK		;records per block
>;NoStructure
IfStructure,<
	IDIV TAC,DD.RPB(DDB)		;TAC1←RECORD NUMBER IN THIS BLOCK
	MOVEI TAC,1(TAC1)		;STARTING DISK RECORD FOR READ
	ADDM TAC,TFRSEC(DDB)		;SET STARTING RECORD NUMBER FOR READ
	MOVE TAC,DD.RPB(DDB)		;records per block
>;IfStructure
	SUBI TAC,(TAC1)			;TAC←MAXIMUM NUMBER OF RECORDS LEFT IN BLOCK
	MOVE DAT,FILLNG(DDB)
	ADDI DAT,2*RECSIZ-1		;round to end of record, add 1 record since
					;usetp is too big by 1 = next r to read
	LSH DAT,-RECWSH			;RN of LAST RECORD IN FILE
	SUB DAT,USETP(DDB)		;DAT := number of records left in file.
	CAMLE DAT,TAC
	MOVE DAT,TAC			;MINIMUM OF RECORDS LEFT IN FILE AND TRACK
	HLRZ TAC,BUFBUF(DDB)
	HRRZ AC1,BUFBUF(DDB)
	SUB AC1,TAC			;NUMBER OF FREE USER BUFFERS
	CAMLE DAT,AC1
	MOVE DAT,AC1			;THIS IS AMOUNT TO READ
	JUMPE DAT,DIBFI3		;NOTHING TO DO
	HRRM DAT,BUFBUF(DDB)		;STORE NUMBER OF RECORDS TO READ FOR C1MPIL
	MOVSI TAC,DCMPBF!DUSER		;TELL C1MPIL TO USE BUFBUF
	MOVEM TAC,TFRCTL(DDB)
	PUSHJ P,TSTART			;At most, do one block.
	PUSHJ P,MAPSET			;SET UP MAP
DIBFI1:	HRRZ TAC,DEVIAD(DDB)		;GET REL. ADDR. OF USER BUFFER
	AOS TAC1,USETP(DDB)
	SUBI TAC1,1
	ASH TAC1,RECWSH
	SUB TAC1,FILLNG(DDB)
	MOVEI DAT,RECSIZ		;SET UP WORD COUNT
	JUMPL TAC1,DIBFI2		;IF NOT PAST EOF
	TLO IOS,IOEND			;EOF; TELL USER
	SUB DAT,TAC1			;ADJUST WORD COUNT
DIBFI2:	XCTR XRW,[HRRM DAT,1(TAC)]	;GIVE WD CT TO USER
	PUSHJ P,ADVBFF
	 JRST DIBFI3			;NO EMPTY BUFFERS
	TLNE IOS,IOEND			;QUIT IF END OF FILE
	JRST DIBFI3
	SOS TAC1,BUFBUF(DDB)		;COUNT DOWN NUMBER OF RECORDS READ
	TRNE TAC1,-1
	JRST DIBFI1			;MORE TO DO
DIBFI3:	PUSHJ P,RTNCOR			;RETURN BUFFERS
	PUSHJ P,RTNBUF
IFN FTDCSH,<
	PUSHJ P,RTNCSH
>;IFN FTDCSH

IFKL10,<
IFN FTRH,<
	LDB AC1,PUNIT
	CAMLE AC1,[UPACKS]
	POPJ P,				;RH-Based disks don't need sweep
>;IFN FTRH
	PUSHJ P,SWEEPA			;SWEEP CACHE
;after the transfer is done, the cache may have valid bits on for words in the
;buffer that are now correct only in core.  These bits need to be turned off.
;However, the invalidate cache instruction also turns off any written bits that
;may be on.  So we have to validate core at the same time.
>;IFKL10

	POPJ P,				;RESTORE MAP



;Buffered input/output common code.  Setup BUFBUF, get user's map setup.
DBFSET:	PUSHJ P,BUFCOR			;GET FREE STORAGE FOR USER BUFFER ADDRESSES
IFN FTDCSH,<
	PUSHJ P,CSHCOR			;AND FOR CACHE SWEEP ADDRESSES
	HLRS CSHBUF(DDB)
>;IFN FTDCSH
IFE FTMPP2,<
	MOVE AC2,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	PUSHJ P,JOBMAP			;GET UPMP INTO EXEC VIRTUAL ADDR SPACE
	 JFCL				;MUST BE A UPMP
	MOVEI AC2,(AC1)			;EXEC VIRTUAL PAGE NUMBER IN AC1
>;IFN FTMPP2
	LSH AC2,9			;AC2:= EVA of page map
NoStructure,<
	MOVEI AC1,RCPBLK		;maximum number of buffers to process
>;NoStructure
IfStructure,<
	MOVE AC1,DD.RPB(DDB)		;maximum number of buffers to process
>;IfStructure
	POPJ P,

DBFXC:	HRRZ TEM,BUFBUF(DDB)
	MOVEI TAC,2(TAC1)		;ADDRESS OF START OF USER'S BUFFER
	MOVEI TAC1,RECSIZ-1(TAC)
	PUSH P,AC1
	PUSHJ P,RELOCA			;ADDRESS CHECK END OF BUFFER
	 JRST ADRERR
	XCT @-1(P)			;for input: JUMPL TAC1,ADRER
	MOVEI TAC1,(TAC)
	PUSHJ P,RELOCB			;ADDRESS CHECK START OF BUFFER
	 JRST ADRERR
	XCT @-1(P)
	POP P,AC1
	AOS (P)				;skip over first in-line argument
	HRRZ TAC1,TAC1			;FLUSH SIGN BIT FROM RELOCB
	HRLI TAC,-RECSIZ
	MOVEM TAC,(TEM)			;STORE USER BUFFER WCMA IN THE BUFFER BUFFER
	XCT @(P)			;FTF2 OUTPUT: AOS DSKLAD(DDB)
	AOS (P)				;skip second in-line argument
	AOS BUFBUF(DDB)			;ADVANCE BUFFER POINTER
IFN FTDCSH,<
	MOVEI TAC,RECSIZ-1(TAC1)	;END OF HIS BUFFER
	LSH TAC1,-9
	LSH TAC,-9
	ADD TAC1,AC2
	ADD TAC,AC2
	LDB TAC1,[POINT 13,(TAC1),35]	;PHYSICAL PAGE NUMBER OF START OF BUFFER
	LDB TAC,[POINT 13,(TAC),35]	;AND OF END OF BUFFER
	PUSHJ P,DBFICI			;INSERT TAC IN CACHE SWEEP PAGE BUFFER
	MOVE TAC,TAC1			;AND ALSO TAC1
	PUSHJ P,DBFICI
>;IFN FTDCSH
	SOJG AC1,CPOPJ			;COUNT DOWN NUMBER OF BUFFERS
	JRST CPOPJ1			;NO MORE WILL FIT ON A TRACK

IFN FTDCSH,<
DBFICI:	MOVE TEM,CSHBUF(DDB)
	HLR TEM,TEM
DBFCI1:	CAMN TEM,CSHBUF(DDB)		;At the end yet?
	JRST DBFCI2			;Yes, CSHBUF doesn't have this entry
	CAMN TAC,(TEM)			;No.  Does this match?
	POPJ P,				;YES, no need to put in another
	AOJA TEM,DBFCI1			;Advance pointer & loop

DBFCI2:	MOVEM TAC,(TEM)			;Store new item
	AOS CSHBUF(DDB)			;advance end of list pointer
	POPJ P,
>;IFN FTDCSH
;⊗ DBUFO DBUFOA DBFOGO DBUFO1 DBUFO2 DBUFO3 DBFOC DIBUFO DIBFO1 DIBOFW DIBFO3 DIBFO4

;BUFFERED OUTPUT - DBUFO

DBUFO:	TLNN IOS,WRITEB!ALTERB
	JRST ENOENT
	MOVSI IOS,IO
	IORB IOS,DEVIOS(DDB)		;FLAG OUTPUT FOR UUOCON
	TLNE DDB,OCLOSB			;CALLED BY CLOSE?
	JRST DBUFO1			;YES, DO OUTPUT NOW
DBUFOA:	TRNE IOS,IODERR!IODTER		;ERROR RECENTLY
	POPJ P,				;YES, TELL HIM
	TLNE IOS,LOSBIG			;OR BAD RETRIEVAL
	JRST EGARB			;YES
	HLR TAC,DEVBUF(DDB)		;PTR TO OBUFF HDR
	XCTR XR,[HRR TAC,(TAC)]		;GET PTR TO NEXT FREE BFR
	XCTR XR,[SKIPL TAC1,(TAC)]
	JRST DBFOGO			;NEXT BUFFER IS FREE.
	TRNN IOS,IOACT			;NEXT BUFFER IS FULL.
	PUSHJ P,DBUFO1			;IF NOT ACTIVE, START OUTPUT.
	PUSHJ P,WSYNC			;WAIT FOR OUTPUT TO HAPPEN.
	JRST DBUFOA			;RETURN OR START NEXT OUTPUT.

DBFOGO:	XCTR XR,[SKIPGE (TAC1)]		;CHECK ONE AFTER.
	TRNE IOS,IOACT			;IT'S FULL, OUTPUT ALREADY GOING?
	POPJ P,				;YES, LET USER RUN.
DBUFO1:	HRRZ TAC,DEVOAD(DDB)		;GET BUFFER ADDRESS
	XCTR XR,[SKIPE 1(TAC)]		;SKIP IF CURRENT BUFFER IS EMPTY
	JRST DBUFO2			;NOT EMPTY.  QUEUE UP I-SUBR
	PUSHJ P,ADVBFE			;SKIP EMPTY BUFFER. GET NEXT.
	 POPJ P,			;NONE LEFT.  RETURN HAVING DONE NOTHING.
	JRST DBUFO1			;LOOK AT ANOTHER BUFFER

DBUFO2:	PUSHJ	P,DBFSET		;Common setup routine for disk i/o
IFN FTF2,<
	PUSH P,USETP(DDB)		;Record where xfer will start
	POP  P,DSKLAD(DDB)		;Initialize nbr of rec after last one written
>;IFN FTF2
	PUSHJ P,ADVOBX
	 PUSHJ P,DBFOC			;ROUTINE TO CALL FOR EACH FREE USER BUFFER
	PUSHJ P,MAKBLK			;SET UP BLOCK TO WRITE (MAY SET PNTDIF)

IFKL10,<
IFN FTRH,<
	LDB DAT,PUNIT
	CAMLE DAT,[UPACKS]
	JRST DBUFO3			;RH-Based disks don't need sweep
>;IFN FTRH
;;;	PUSHJ P,SWEEPA			;SWEEP THE CACHE
	PUSHJ P,VALCOR			;SWEEP THE CACHE VALIDATING CORE ONLY
;really only need to validate core just before output
>;IFKL10

DBUFO3:	MOVEI DAT,DIBUFO		;CALL INT LEVEL SUBR
	JRST QENTER			;USER PGM CAN PROCEED

;HERE FROM ADVOBX.  TAC1 HAS USER ADDRESS OF FULL BUFFER
DBFOC:	PUSHJ P,DBFXC
	 JFCL				;no write protect for output
IFN FTF2,<AOS DSKLAD(DDB);>JFCL		;F2: update final USETP for pre-read check
	POPJ P,
	JRST CPOPJ1


;*** INTERRUPT SUBR ***

DIBUFO:	MOVE TAC,USETP(DDB)		;FIRST RECORD TO WRITE
	SUB TAC,DGRP1R(DDB)		;CALCULATE RECORD NO. IN THIS GROUP
NoStructure,<
	IDIVI TAC,RCPBLK		;TAC1←RECORD NUMBER IN THIS BLOCK
	MOVEM TAC1,DSKFAD(DDB)		;SAVE RELATIVE STARTING RECORD NUMBER
	MOVEI DAT,RCPBLK		
>;NoStructure
IfStructure,<
	IDIV TAC,DD.RPB(DDB)		;TAC1←RECORD NUMBER IN THIS BLOCK
	MOVEM TAC1,DSKFAD(DDB)		;SAVE RELATIVE STARTING RECORD NUMBER
	MOVE DAT,DD.RPB(DDB)		
>;IFStructure
	SUBI DAT,(TAC1)			;DAT←MAXIMUM NUMBER OF RECORDS LEFT IN BLOCK
	HLRZ TAC,BUFBUF(DDB)
	HRRZ AC1,BUFBUF(DDB)
	SUB AC1,TAC			;NUMBER OF FULL USER BUFFERS
	CAMLE DAT,AC1
	MOVE DAT,AC1			;THIS IS AMOUNT TO WRITE
	JUMPE DAT,DIBFO3		;NOTHING TO DO
	HRRM DAT,BUFBUF(DDB)		;STORE NUMBER OF RECORDS TO WRITE FOR C1MPIL
	MOVSI TAC,DCMPBF!DUSER!DWRITE	;TELL C1MPIL TO USE BUFBUF
	MOVEM TAC,TFRCTL(DDB)
	PUSHJ P,AUDINF
IFN FTF2,<
	MOVSI TAC1,DNOPRE	;Bit meaning suppress pre-read at end of file
	MOVE TAC,DSKLAD(DDB)	;Get value USETP will have after xfer
	SUBI TAC,1		;Make it number of last record we're writing
	LSH TAC,RECWSH		;Convert to word count for file to that point
	CAML TAC,FILLNG(DDB)	;Will this xfer reach the end of file?
	IORM TAC1,TFRCTL(DDB)	;Yes, set flag for WHERX3 to avoid pre-read
>;IFN FTF2
	MOVE	TAC,USETP(DDB)		;SET UP TRANSFER
	PUSHJ	P,LR2BLK		;return block addr in TAC, record # in AC3
	JUMPE	TAC,SETLOS		;NON EX = BAD RETRIEVAL
	CAIN	AC3,1			;Skip unless writing record 1
	TLNN	IOS,PNTDIF		;Record 1 going.  Skip if RTVL update needed
	CAIA				;not record 1 or no RTVL update needed
	MOVEI	AC3,0			;Set to include record 0 in transfer
	PUSHJ	P,BKMAP			;combine TAC and AC3 as a disk address
NoStructure,<
	LDB AC1,PUNIT
	ADD TAC,BFSETS(AC1)		;ADD IN OFFSET
>;NoStructure
IfStructure,<
	MOVE AC1,SDBPTR(DDB)
	ADD TAC,ST.BSS(AC1)		;ADD IN OFFSET
>;IfStructure
	MOVEM TAC,TFRSEC(DDB)
	PUSHJ P,TSTART			;do at most one block (maybe RTVL from DDB)
	PUSHJ P,MAPSET			;SET UP MAP
DIBFO1:	HRRZ TAC,DEVOAD(DDB)		;GET BUFFER ADDRESS
	ADDI TAC,2			;ADVANCE TO DATA AREA OF BUFFER
	XCTR XR,[SKIPG AC1,-1(TAC)]	;ANY WORDS IN THIS BUFFER
	JRST DIBFO4			;NO, SKIP OVER IT
	CAILE AC1,RECSIZ		;MAKE SURE WC IS REASONABLE
	MOVEI AC1,RECSIZ
	AOS TAC,USETP(DDB)		;POINT TO NEXT RECORD FOR OUTPUT
	SUBI TAC,2			;CALCULATE LENGTH OF ALL PREVIOUS RECORDS
	ASH TAC,RECWSH
	ADDI TAC,(AC1)			;ADD WC OF THIS RECORD
	CAMG TAC,FILLNG(DDB)		;DID FILE GROW?
	JRST DIBOFW			;NO.
	MOVEM TAC,FILLNG(DDB)		;MARK NEW FILE LENGTH.
IFE FTDOPS,<
	TLO IOS,PNTDIF!HDRDIF		;NEED TO UPDATE RETRIEVAL
>;IFE FTDOPS
IFN FTDOPS,<
	TLO IOS,IFN FTLUFD,<UFDDIF!>HDRDIF	;LENGTH NEEDS TO BE RIGHT IN 1ST TK
>;IFN FTDOPS
DIBOFW:	PUSHJ P,ADVBFE
	 JRST DIBFO3			;NO MORE BUFFERS READY
	SOS TAC1,BUFBUF(DDB)		;COUNT DOWN NUMBER OF RECORDS written
	TRNE TAC1,-1
	JRST DIBFO1			;MORE TO DO
DIBFO3:	PUSHJ P,RTNCOR			;RETURN BUFFERS
	PUSHJ P,RTNBUF
IFN FTDCSH,<
	PUSHJ P,RTNCSH
>;IFN FTDCSH
	POPJ P,				;RESTORE MAP

DIBFO4:	PUSHJ P,ADVBFE			;ADVANCE THE BUFFERS
	 JRST DIBFO3			;NONE LEFT, ALL DONE
	JRST DIBFO1
;⊗ DDMPI SXDMPI DDXIT DDICO0 DDICO2 DDICO4 DDICO3 DDIC0 DDIC1 DDIC1A DDICO5 DDIGO DDIGOD DDIGOC DDMIEF DDCALC DIDMPI DIDMI1 DIDMI2 DMIEF1

;DUMP MODE INPUT  -  DDMPI, SXDMPI, DDCALC, DDXIT

DDMPI:
IFN FTSIX,<
	SETZM IOWDSX(DDB)	;FLAG A NORMAL DUMP MODE TRANSFER
SXDMPI:				;ENTER HERE FROM GODMODE MTAPE TO READ INTO P3 MEM
>;IFN FTSIX
	TLNN IOS,READB!WRITEB!ALTERB
	JRST ENOLUK
	JSP AC1,TSTEOF		;SEE IF IMMEDIATE EOF
	 JRST DDMIEF		;YES. TELL LOSER.
	TLZ IOS,IO		;FLAG INPUT
	TLO IOS,GOBIT		;MAKE US UNSTOPPABLE.
	MOVEM IOS,DEVIOS(DDB)
	PUSHJ P,GETCOR		;GET CORE FOR COMMAND LIST NOW
	PUSHJ P,GETRET		;GET GROUP DIRECTORY
	 JRST SETLOS		;BAD RETRIEVAL
	PUSHJ P,DDICO2
IFN FTSIX,<
	SKIPN IOWDSX(DDB)
	JRST DDXIT
	MOVE AC1,ECCSIX(DDB)
	XCTR XW,[MOVEM AC1,3(UUO)]
	MOVE AC1,ECCLOS(DDB)
	XCTR XW,[MOVEM AC1,4(UUO)]
>;IFN FTSIX
;DUMP MODE I/O UUOS EXIT THROUGH HERE.
DDXIT:	PUSHJ P,RTNCOR		;RETURN COMMAND BUFFER TO FREE STG
	TRNN IOS,IODERR!IODTER	;IF DATA OR DEVICE ERROR, LET USER SEE IT!
	TLNN IOS,LOSBIG		;ELSE IF BAD RETRIEVAL PRINT MESSAGE
	JRST DPOPJ
	JRST EGARB

DDICO0:
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	SOJA UUO,CPOPJ		;JUST 1 IOWD FOR P3 (KEEP UUO HONEST)
>;IFN FTSIX
DDICO2:
IFN FTSIX,<
	SKIPE TAC1,IOWDSX(DDB)
	JRST DDICO5
>;IFN FTSIX
	PUSHJ P,DMPCMD		;GET AN IOWD (STARTING ADDR IN TAC1, -WC IN TAC)
	 POPJ P,		;END OF LIST.
	JUMPL TAC1,ADRERR	;LOSE IF INPUT TO A WRITE-PROTECTED AREA
DDICO4:	HRRZM TAC1,CORFAD(DDB)	;SAVE STARTING ADDRESS (USER-RELATIVE)
	MOVE AC1,USETP(DDB)
	SUBI AC1,1
	ASH AC1,RECWSH		;7
	MOVEM AC1,DSKFAD(DDB)
	SUB AC1,TAC		;CALC DISK LAST ADDR
	CAMG AC1,FILLNG(DDB)
	JRST DDICO3
	TLO IOS,IOEND
	MOVE AC1,FILLNG(DDB)	;STOP AT EOF
DDICO3:	MOVEM AC1,DSKLAD(DDB)

DDIC0:	HLRS DMPBUF(DDB)
DDIC1:	PUSHJ P,DDCALC			;FIND BLOCK END.
	CAMLE DAT,DSKLAD(DDB)		;COMPARE WORD COUNTS.
	MOVE DAT,DSKLAD(DDB)
	SUB DAT,DSKFAD(DDB)		;THIS GIVES TFR WORD COUNT.
	JUMPE DAT,DDMIEF		;ATTEMPTING TO READ A ZERO LENGTH RECORD
					;THIS CAN HAPPEN IF YOU ARE POSITIONED
					;EXACTLY AT THE END OF THE FILE AND THERE
					;ARE STILL MORE COMMANDS LEFT IN THE
					;COMMAND LIST.
	MOVN TAC,DAT
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	JRST DDIC1A
>;IFN FTSIX
	HRRZ TAC1,CORFAD(DDB)		;RELATIVE STARTING ADDRESS
	PUSHJ P,RELOCC			;ADDRESS CHECK STARTING ADDRESS
	 JRST ADRERR			;MUST BE ATTEMPT TO REFERENCE HIGH CORE
DDIC1A:	HRRZ TAC1,CORFAD(DDB)		;RELATIVE STARTING ADDR
	HRL TAC1,TAC			;PUT IN -WD COUNT.  -WC,,REL START ADDR
	AOS TEM,DMPBUF(DDB)
	MOVEM TAC1,-1(TEM)		;ENTER IN COMMAND LIST
	ADDM DAT,CORFAD(DDB)		;BUMP FIRST ADDR BY WD CT
	ADDB DAT,DSKFAD(DDB)
	ADDI DAT,RECSIZ+RECSIZ-1	;ROUND UP TO RECORD
	ASH DAT,-RECWSH
	MOVE TAC,USETP(DDB)
	MOVEM DAT,USETP(DDB)
	PUSHJ P,LR2BLK
	JUMPE TAC,SETLOS		;NON EX = BAD RETRIEVAL
	PUSHJ P,BKMAP
	MOVEM TAC,(TEM)
	AOS TEM,DMPBUF(DDB)		;BUMP COMMAND POINTER
	HLRZ TAC,TEM			;END CHECK COMMAND LIST
IfStructure,<
	ADD TAC,DD.BPG(DDB)		;To start of command list, add 2*
	ADD TAC,DD.BPG(DDB)		;the number of blks/group. (2 cmd wds/blk)
	CAIGE TAC,(TEM)			;Skip unless TEM has advanced too far
>;IfStructure
NoStructure,<
	CAIGE TAC,-2*40(TEM)		;Test for command list overflow
>;NoStructure
	JRST EDMPLS			;ILL FMT COMMAND LIST.
	MOVE TAC,DSKFAD(DDB)
	CAME TAC,DSKLAD(DDB)		;SEE IF REQUEST COMPLETED
	PUSHJ P,TSTRET			;START XFER IF GRP OFLOW
	 JRST DDIGO			;RTVL NOT IN MEANS GRP OFLOW
	JRST DDIC1			;NO OFLOW YET, DO MORE

IFN FTSIX,<
DDICO5:	HLRE TAC,TAC1			;-WC IN TAC
	MOVEI TAC1,1(TAC1)		;STARTING ADDRESS IN TAC1
	JRST DDICO4
>;IFN FTSIX

DDIGO:
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	JRST DDIGOD
>;IFN FTSIX

IFKL10,<
IFN FTRH,<
	LDB DAT,PUNIT
	CAMLE DAT,[UPACKS]
	JRST DDIGOD			;RH-Based disks don't need sweep
>;IFN FTRH
;;;	NOCACHE (CSHDSK)		;FLUSH CACHE HERE
	PUSHJ P,SWEEPA			;SWEEP THE CACHE
;this situation is slightly different than the one at DBUFI.  Here, the user
;cannot procede (or be swapped out) and so he cannot reference the buffer while
;the disk is filling it.  The only place that may reference the buffer is FIXERR,
;which happens after the transfer, and so it is alright to let it get the data
;into the cache.  Here we clear the valid bits so that later when we reference the
;buffer, we will get the good data from memory.
>;IFKL10

DDIGOD:	MOVEI DAT,DIDMPI		;START I-LEVEL SUBR - Transfer up to 1 GRP
	PUSHJ P,QEWAIT
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	JRST DDIGOC			;DON'T SKIP OVER CACHE MACRO
>;IFN FTSIX

;;;	CACHE (CSHDSK)
;there is no need to do any cache sweep here, since we have already cleared the
;valid bits, and no new valid bits were set before the transfer finished.

DDIGOC:	TRNE IOS,IODERR!IODTER		;IF DEVICE SCREW-UP
	POPJ P,				;QUIT NOW!
	MOVE TAC,DSKFAD(DDB)
	CAME TAC,DSKLAD(DDB)
	JRST DDIC0			;WORDS LEFT; DO ANOTHER GROUP
	TLNN IOS,IOEND			;END FILE?
	AOJA UUO,DDICO0			;NO, DO NEXT IOWD
DDMIEF:	IOR IOS,[IOEND,,IODEND]
	JRST DSIOS			;STORE IOS, AND POPJ.

DDCALC:	MOVE AC1,USETP(DDB)		;LOCATE END OF BLOCK
NoStructure,<
	ADDI AC1,RCPBLK-1		;CONTAINING USETP
	MOVEI DAT,RCPBLK
	IDIVM AC1,DAT			;SEE US CLEVERLY AVOID A REMAINDER !
	IMULI DAT,RCPBLK
>;NoStructure
IfStructure,<
	ADD AC1,DD.RPB(DDB)		;Find end of BLK that contains USETP
	SUBI AC1,1
	MOVE DAT,DD.RPB(DDB)		;locate end of block 
	IDIVM AC1,DAT			;SEE US CLEVERLY AVOID A REMAINDER !
	IMUL DAT,DD.RPB(DDB)
>;IfStructure
	LSH DAT,RECWSH			;CONVERT TO WORD COUNT.
	POPJ P,

;*** INTERRUPT SUBR ***

DIDMPI:	MOVE TEM,DMPBUF(DDB)
	HLRS TEM			;STARTING COMMAND,,STARTING COMMAND
	MOVSI TAC1,DUSER
	MOVEM TAC1,TFRCTL(DDB)		;INDICATE USER RELATIVE TRANSFER
DIDMI1:	MOVE TAC1,(TEM)			;WCMA FROM COMMAND LIST
	MOVEM TAC1,TFRIOW(DDB)		;STORE USER RELATIVE WCMA FROM COMMAND LIST
	MOVE TAC1,1(TEM)
NoStructure,<
	LDB AC1,PUNIT
	ADD TAC1,BFSETS(AC1)
>;NoStructure
IfStructure,<
	MOVE AC1,SDBPTR(DDB)
	ADD TAC1,ST.BSS(AC1)
>;IfStructure
	MOVEM TAC1,TFRSEC(DDB)
	PUSHJ P,TSTART		;At most, do one block
	TRNE IOS,IODERR!IODTER	;Return immediately if errors
	POPJ P,
	ADDI TEM,2
	CAMGE TEM,DMPBUF(DDB)
	JRST DIDMI1
DIDMI2:	MOVE TAC,DSKFAD(DDB)
	CAMN TAC,DSKLAD(DDB)		;IF LAST TFR,JUST RETURN
	POPJ P,
	SKIPN TAC,DNXTGP(DDB)		;ELSE GET RTVL FOR NEXT GRP.
	JRST DMIEF1			;FLAG END
	PUSHJ P,SETRD			;SET UP TFRSEC AND TFRCTL (CLEARS DUSER)
NoStructure,<
	MOVEI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
	HRLI	TAC,-SECSIZ
>;NoStructure
IfStructure,<
	MOVN	TAC,DD.SSZ(DDB)		;-size of rtvl area
	HRLZ	TAC,TAC
	HRRI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
>;IfStructure
	MOVEM TAC,TFRIOW(DDB)
	PUSHJ P,TSTART			;Read RTVL into DDB
	PUSHJ P,AUDCHK
	POPJ P,

DMIEF1:	TLO IOS,IOEND
	POPJ P,
;⊗ DDMPO SXDMPO DDOCO0 DDOCO2 DDOCO4 DDOC0 DDOC1 DDMPO3 DDMPO4 DDOGOD DDMPO5 DDOCO5 DIDMPO DIDMO1

;DUMP MODE OUTPUT  -  DDMPO, SXDMPO

DDMPO:
IFN FTSIX,<
	SETZM IOWDSX(DDB)	;FLAG A NORMAL DUMP MODE TRANSFER
SXDMPO:				;ENTER HERE FROM GODMODE MTAPE TO WRITE FROM P3 MEM
>;IFN FTSIX
	TLNN IOS,WRITEB!ALTERB
	JRST ENOENT
	TLO IOS,IO!GOBIT	;FLAG OUTPUT AND MAKE UNSTOPPABLE
	MOVEM IOS,DEVIOS(DDB)
	PUSHJ P,GETCOR		;GET BUFFER FOR COMMAND LIST
	PUSHJ P,DDOCO2
	JRST DDXIT

DDOCO0:
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	POPJ P,			;JUST 1 IOWD FOR P3
>;IFN FTSIX
DDOCO2:
IFN FTSIX,<
	SKIPE TAC1,IOWDSX(DDB)
	JRST DDOCO5
>;IFN FTSIX
	PUSHJ P,DMPCMD		;GET IOWD
	 POPJ P,		;END OF COMMAND LIST.
	HRRZ TAC1,TAC1		;ADDRESS ONLY.
	CAIGE TAC1,20		;NO ADDRESSES IN THE ACS PLEASE
	JRST ADRERR
	MOVEM TAC1,CORFAD(DDB)	;USER-RELATIVE STARTING ADDRESS

	PUSHJ P,RELOCC		;BELT AND SUSPENDERS. MAKE SURE, SETUP TAC = -WC
	 JRST ADRERR
DDOCO4:	MOVE AC1,USETP(DDB)
	SUBI AC1,1
	ASH AC1,RECWSH
	MOVEM AC1,DSKFAD(DDB)
	SUB AC1,TAC		;TAC: -WD CT FROM RELOCC
	MOVEM AC1,DSKLAD(DDB)
	CAMG AC1,FILLNG(DDB)	;DID FILE GROW?
	JRST DDOC0		;NO.
	MOVEM AC1,FILLNG(DDB)
	TLO IOS,IFN FTLUFD,<UFDDIF!>HDRDIF	;INDICATE NEW FILLNG TO SPREAD.
	MOVEM IOS,DEVIOS(DDB)	;GET IT INTO THE DDB
DDOC0:	HLRS DMPBUF(DDB)
DDOC1:	PUSHJ P,MAKBLK		;ASSIGN BLOCK, PUT INTO RETRIEVAL (MAY SET PNTDIF)
	JUMPE TAC,SETLOS	;NON EX = BAD RETRIEVAL
	PUSHJ P,DDCALC		;LOCATE BLOCK'S END.
	CAMLE DAT,DSKLAD(DDB)	;COMPARE WORD COUNTS.
	MOVE DAT,DSKLAD(DDB)
	SUB DAT,DSKFAD(DDB)	;THIS GIVES TFR WORD COUNT.
	MOVN TAC,DAT
	HRRZ TAC1,CORFAD(DDB)
	HRL TAC1,TAC		;-WC,,RELATIVE STARTING ADDR.
	AOS TEM,DMPBUF(DDB)
	MOVEM TAC1,-1(TEM)	;ENTER IN COMMAND LIST
	ADDM DAT,CORFAD(DDB)	;UPDATE STARTING ADDRESSES
	ADDB DAT,DSKFAD(DDB)
	ADDI DAT,RECSIZ+RECSIZ-1
	ASH DAT,-RECWSH
	MOVE TAC,USETP(DDB)
	MOVEM DAT,USETP(DDB)
	PUSHJ P,LR2BLK
	JUMPE TAC,SETLOS	;NON EX = BAD RETRIEVAL
	PUSHJ P,BKMAP
	MOVEM TAC,(TEM)
	AOS TEM,DMPBUF(DDB)
	HLRZ TAC,TEM			;TAC := origin of DMPBUF
IfStructure,<
	ADD TAC,DD.BPG(DDB)		;To start of command list, add twice
	ADD TAC,DD.BPG(DDB)		;the number of blks/group. (2 cmd wds/blk)
	CAIGE TAC,(TEM)			;Skip unless TEM has advanced too far
>;IfStructure
NoStructure,<
	CAIGE TAC,-2*40(TEM)		;Test for command list overflow
>;NoStructure
	JRST EDMPLS		;ILL FMT COMMAND LIST.
	MOVE TAC,DSKFAD(DDB)
	CAMN TAC,DSKLAD(DDB)	;ALL WORDS ACCOUNTED FOR?
	JRST DDMPO4		;YES, DO OUTPUT
	PUSHJ P,TSTRET		;RTVL NOT IN MEANS GRP OFLOW
	 JRST DDMPO3		;GRP OFLOW, DO OUTPUT
	JRST DDOC1		;NO OFLOW, DO NEXT BLOCK

DDMPO3:	SKIPE DNXTGP(DDB)	;NEXT GROUP EXIST?
	JRST DDMPO4		;YES, OUTPUT THIS BLOCK.
	PUSHJ P,ASNGRP		;NO, SET IT UP.
DDMPO4:
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	JRST DDOGOD
>;IFN FTSIX

IFKL10,<
IFN FTRH,<
	LDB DAT,PUNIT
	CAMLE DAT,[UPACKS]
	JRST DDOGOD			;RH-Based disks don't need sweep
>;IFN FTRH
;;;	NOCACHE (CSHDSK)	;SWEEP THE CACHE
	PUSHJ P,VALCOR		;SWEEP THE CACHE, VALIDATING CORE ONLY
;really only need to validate core just before output
>;IFKL10

DDOGOD:	MOVEI DAT,DIDMPO	;WRITE THIS GROUP OUT.
	PUSHJ P,QEWAIT
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	JRST DDMPO5		;DON'T SKIP OVER CACHE MACRO
>;IFN FTSIX

;;;	CACHE (CSHDSK)

DDMPO5:	TRNE IOS,IODERR!IODTER
	POPJ P,			;QUIT NOW IF ERROR!
	MOVE TAC,DSKFAD(DDB)
	CAME TAC,DSKLAD(DDB)
	JRST DDOC0		;WORDS LEFT, DO ANOTHER GROUP
	AOJA UUO,DDOCO0		;GET NEXT IOWD

IFN FTSIX,<
DDOCO5:	HLRE TAC,TAC1			;-WC IN TAC
	MOVEI TAC1,1(TAC1)		;STARTING ADDRESS IN TAC1
	MOVEM TAC1,CORFAD(DDB)		;USER-RELATIVE STARTING ADDRESS
	JRST DDOCO4
>;IFN FTSIX

;***INTERRUPT SUBR***

DIDMPO:
IFE FTDOPS,<
	TLZE IOS,PNTDIF
	PUSHJ P,SPREAD
>;IFE FTDOPS
	MOVE TEM,DMPBUF(DDB)
	HLRS TEM
	MOVEI TAC1,DWRITE!DUSER
	MOVSM TAC1,TFRCTL(DDB)
IFN FTF2,<
	MOVSI TAC1,DNOPRE	;Bit meaning suppress pre-read at end of file
	MOVE TAC,DSKLAD(DDB)	;Get final disk word address plus one
	CAML TAC,FILLNG(DDB)	;Will this xfer reach the end of file?
	IORM TAC1,TFRCTL(DDB)	;Yes, set flag for WHERX3 to avoid pre-read
>;IFN FTF2
DIDMO1:	MOVE TAC1,(TEM)		;GET -WC,,REL ADRESSS FROM DMPBUF
	MOVEM TAC1,TFRIOW(DDB)	;STORE USER RELATIVE WCMA FROM COMMAND LIST
	MOVE TAC1,1(TEM)	;FETCH DISK ADDRESS
NoStructure,<
	LDB DAT,PUNIT
	ADD TAC1,BFSETS(DAT)
>;NoStructure
IfStructure,<
	MOVE DAT,SDBPTR(DDB)
	ADD TAC1,ST.BSS(DAT)
>;IfStructure
	MOVEM TAC1,TFRSEC(DDB)
	PUSHJ P,TSTART		;At most, do one block
	TRNE IOS,IODERR!IODTER	;Return immediately if errors
	POPJ P,
	ADDI TEM,2
	CAMGE TEM,DMPBUF(DDB)
	JRST DIDMO1
	POPJ P,
;CLOSE UUO ;⊗ DCLOSI DCLSI1 DCLOSO DCLSO3 DCLSOC DCLSOD DCLS2V DCLSOF DCLSO2 DCLSOE DCLSOR DRDEL DRDEL1 DRDEL2 FIRVAL FIRCLK DCLOI DCLSO5 DCLOI DCLOI1 DCLOI2 DCLOI3

;BOTH INPUT & OUTPUT CLOSE ARE ALWAYS CALLED FROM UUOCON.

;CLOSE INPUT.

;JJW note - the use of ACCESS in these routines is inappropriate since it
;ignores DDBs with DELETB set and can cause an "error return" from a CLOSE
;or RELEAS UUO, storing the error code in a random user word.  All of the
;code here looks suspicious and should be reworked.

DCLOSI:	TLNE IOS,IOSET		;USET IN PROGRESS?
	JRST DSIOS		;YES. RETURN.
	TLZE IOS,READB		;READING?
	TLZN IOS,DELETB		;YES. NEED TO DELETE (FILE SUPERSEDED)?
	JRST DSIOS		;NOT READING OR NOT SUPERSEDED. RETURN.
	JSP AC1,ACCESS		;IS ANYONE ELSE READING?
	 JRST DCLSI1		;YES. THE LAST ONE OUT WILL DELETE IT.
	 JFCL			;WRITERS ARE IRRELEVANT
	 JFCL			;CLOSED ACCESSORS WERE ALL FLUSHED.
	PUSHJ P,GOSET		;MAKE US UNSTOPPABLE.
	MOVE TAC,FILLOC(DDB)	;NO ONE ELSE LOOKING, SO...
	PUSHJ P,DELETE		;DELETE FILE.
	PUSHJ P,CUSATO		;OUT SAT IF NEEDED AND WAIT FOR IT
DCLSI1:	SETZM FILNAM(DDB)	;DISABLE FUTURE RENAME
	JRST DPOPJ

;CLOSE OUTPUT

DCLOSO:	TLNN IOS,WRITEB!ALTERB	;WRITING OR ALTERING?
	JRST DSIOS		;NO.  CLOSE OUTPUT IS NO-OP.
	TLNN DDB,OUTBFB+OUTPB	;ANY OUTPUT BUFFERS SET UP?
	JRST DCLSO3		;NO.  NOTHING TO FLUSH  --ME
	LDB TAC,PIOMOD		;#-EATING APRSER SHOULD DO THIS
	CAIGE TAC,DR
	PUSHJ P,OUT		;LAST OUTPUT FOR BUFFERED MODES
DCLSO3:	PUSHJ P,WAIT1		;FINISH IT 
	TLNE IOS,IOSET		;USET IN PROGRESS?
	POPJ P,			;Yes.  Leave now.
	LDB J,PJOBN		;MAKE SURE J IS RIGHT
	SOS DDBCNT(J)		;NO LONGER WRITING FILE
	PUSHJ P,GOSET
	MOVEI DAT,DCLOI		;CLOSE FILE IF RTVL INCORRECT
	TLNE IOS,IFN FTLUFD,<UFDDIF!>PNTDIF!HDRDIF	;RTVL CORRECT?
	PUSHJ P,NEWAIT		;NO, OUTPUT FILE AND RETRIEVAL
	TLNN IOS,NTRUFD		;NOW FIX UP UFD.  Was it SUPERSEDE?
	JRST DCLS2V		;No.  It is CREATE - UFD already correct
	TLZ IOS,DELETB		;Supersede.  Mark all readers of old file
	MOVSI AC2,DELETB
	JSP AC1,ACCESS
	 JRST DCLSOR		;READER FOUND.  SPREAD DELETEB
	 PUSHJ P,ELOSE		;THERE SHOULDN'T BE OTHER WRITERS
	 SETZM FILNAM(TAC)	;CLOSED ACCESSORS GET RENAME DISABLED.
	PUSHJ P,UFDSRC		;GET POINTER TO UFD
	 PUSHJ P,ELOSE		;ERROR IF UNABLE TO FIND IT
	SETZM DRAUFO(DDB)	;ENABLE US FOR ERROR FROM DRAUFD
	PUSH P,SRCLOC(DDB)	;SAVE UFD ADDRESS IF NEEDED FOR DIRINS
	MOVEI DAT,DRAUFY	;USE RENAME CODE TO...
	PUSHJ P,QEWAIT		;  CHANGE UFD TO NEW FILE
;IF SUPERSEDED FILE WAS RENAMED OR DELETED, THE UFD ENTRY FOR IT WILL NOT BE FOUND
;  IN THIS CASE, DRAUFO(DDB) IS POSITIVE, AND UFD ENTRY FOR SUPERSEDING FILE MUST
;  BE INSERTED.
	POP P,TAC		;UFD ADDRESS (SRCLOC CLOBBERED BY DRAUFY)
	SKIPE DRAUFO(DDB)	;WIN? (I.E., WAS OLD UFD ENTRY RENAMED?)
	JRST DCLSOF		;NO.  WE MUST INSERT NEW UFD ENTRY.
	TLZE IOS,DELETB		;WAS ANYONE READING?
	JRST DCLSO2		;YES, DON'T DELETE NOW
DCLSOC:	MOVE TAC,SRCLOC(DDB)	;OLD FILE LOCATION
DCLSOD:	PUSHJ P,DELETE		;DELETE IT (ENTER HERE FROM DRELES)
	LDB TAC,PUNIT
IFE FTRH,<
	TRNE IOS,IOIMPM!IODERR
	JUMPN TAC,SATGLZ	;WRITE LOCKED UDP
>;IFE FTRH
IFN FTRH,<
	TRNE IOS,IOIMPM!IODERR
	CAMN TAC,PRSNUM		;Skip if not primary structure
	CAIA
	JRST SATGLZ		;Write locked UDP
>;IFN FTRH
	TLNN IOS,NTRUFD		;If superseding, no change in user list in MFD
DCLS2V:	PUSHJ P,FIRVAL		;If file is a UFD, request a VALMAK job for MAIL
	JRST DCLSO2

;Here for supersede. The old file has no UFD entry. It must have been
;renamed or deleted.   Insert a new entry.
DCLSOF:	MOVEM TAC,SRCLOC(DDB)	;UFD ADDRESS.  UFD NAME IN DDNAM FROM DRAUFY
	PUSHJ P,DIRINS		;INSERT FILE NAME IN UFD.
	TLZ IOS,DELETB
DCLSO2:	PUSHJ P,CUSATO		;OUT SAT IF NEEDED AND WAIT FOR IT
DCLSOE:	TLZ IOS,WRITEB!ALTERB!NTRUFD	;CLEAR OUTPUT BITS
	JRST DPOPJ

;HERE FROM ACCESS TO SPREAD THE DELETE BIT
DCLSOR:	IORM AC2,DEVIOS(TAC)	;FOUND READER, MARK TO DELETE
	TLO IOS,DELETB		;FLAG FILE STILL IN USE
	JRST ACCES1		;KEEP LOOKING

;JJW note - DRDEL doesn't prevent others from opening the file for reading
;while we're deleting it.  This code needs fixing.

;HERE FROM RENAME UUO TO DO A DELETE
DRDEL:	TLNE IOS,WRITEB!ALTERB	;Were we writing?
	SOS DDBCNT(J)		;Yes, one less writer (bits turned off at DCLSOE)
	TLNE IOS,NTRUFD		;Superseding?
	JRST DRDEL2		;Yes, no other readers, delete new file
	TLZ IOS,READB!DELETB	;Close read access, prepare to check for readers
	MOVSI AC2,FILNAM(DDB)	;SOURCE OF BLT
	HRRI AC2,ACCNAM(DDB)
	BLT AC2,ACCPPN(DDB)	;COPY FILXXX TO ACCXXX FOR ACCESS TO WORK
	MOVSI AC2,DELETB
	JSP AC1,ACCESS		;MARK READERS OF OLD FILE.
	 JRST DCLSOR		;   TO DELETE IT WHEN THRU
	 JFCL			;SUPERSEDERS ARE IRRELEVANT FOR DELETE.
	 SETZM FILNAM(TAC)	;CLOSED ACCESSORS HAVE RENAME DISABLED
	SETZM ACCNAM(DDB)	;PREPARE TO DELETE UFD ENTRY
	PUSHJ P,UFDSRC		;GET UFD RTVL IN
	 PUSHJ P,ELOSE		;ERROR IN DSKSER
	MOVEI DAT,DRAUFD	;AND USE RENAME CODE TO
	PUSHJ P,QEWAIT		;  CHANGE UFD TO NEW FILE
	TLZE IOS,LOSBIG
	JRST DRDEL1		;report errors....
	MOVEI TAC,DCLSOC	;ASSUME WE NEED TO DO DELETE NOW.
	TLZE IOS,DELETB		;WAS THERE SOME READER?
	MOVEI TAC,DCLS2V	;YES, DON'T DELETE NOW
	PUSHJ P,(TAC)		;CLOSE DDB, POSSIBLY DOING DELETE.
DRDEL1:	SETZM FILNAM(DDB)	;DISABLE RENAME AFTER DELETE.
	LDB TAC,PUNIT
IFE FTRH,<
	TRNE IOS,IODERR!IOIMPM	;WRITE ERROR?
	JUMPN TAC,SATGLZ	;LOSE. WRITE LOCKED UDP
	JRST DPOPJ1		;RETURN TO USER
>;IFE FTRH
IFN FTRH,<
	TRNE IOS,IOIMPM!IODERR
	CAMN TAC,PRSNUM		;Skip if not primary structure
	JRST DPOPJ1		;Return to user
	JRST SATGLZ		;Write locked UDP
>;IFN FTRH

;Delete superseding file, leaving old file untouched.
DRDEL2:	MOVE TAC,FILLOC(DDB)	;Location of new file
	PUSHJ P,DCLSOD		;Delete it
	JRST DRDEL1

;Routine called when new file entered or old file deleted.  If the file is/was
;a UFD, then the VALMAK phantom is started up to make new validated MAIL list.
;Come here at time of CLOSE after ENTER, or upon RENAME to delete.
;Clobbers TAC,TAC1,TEM.
FIRVAL:	MOVE TAC,FILPPN(DDB)
	CAME TAC,SYSPPN		;Is/was this a UFD?
	POPJ P,			;NO
	HLRZ TAC,FILEXT(DDB)
	CAIE TAC,UFDEXT
	POPJ P,
FIRCLK:	MOVEI TAC,['VALMAK' ↔ 'MAISYS' ↔ LUPPRV,,0 ↔ 0]
	PUSHJ P,FIREUP		;Start up a VALMAK phantom, clobbers TEM,TAC1
	 SKIPA TAC,[FIRCLK,,0]	;Lost, no fireup slots, plant clk req
	POPJ P,
	SYSPIFF
	IDPB TAC,CLKQ		;Try again next tick, use DPYSER clock queue
	SYSPIN
	POPJ P,


; *** INTERRUPT LEVEL ROUTINE ***
; UPDATE FIRST RTVL (LENGTH) &∨ LAST (PTRS).
; !!! THIS ROUTINE CLOBBERS USETP FOR MULTIPLE-GROUP FILES
;	THIS IS NO PROBLEM IN CLOSE, BUT IN USETS AND MTAPE 17 (FILEUP)
;	YOU MUST REMEMBER TO SAVE USETP

IFE FTLUFD,<
DCLOI:	TLZN IOS,HDRDIF		;HEADER PTRS OK?
	JRST DCLSO5		;YES, FIX LAST PTRS
	MOVEI TAC,1		;HEADER IS WRONG
	CAMN TAC,DGRP1R(DDB)	;LOOKING AT HEADER?
	JRST DCLSO5		;YES, GO FIX IT
IFN FTDOPS,<
	TLNE IOS,PNTDIF		;LAST POINTERS OK?
>;IFN FTDOPS
	PUSHJ P,DCLSO5		;NO, FIX THEM TOO
	MOVEI TAC,1
	MOVEM TAC,USETP(DDB)	;!!!CLOBBER USETP.  UNLESS THIS IS CLOSE
				;!!!YOU MAY HAVE JUST LOST
	PUSHJ P,GGRETD		;GET HEADER POINTERS
DCLSO5:	TLZ IOS,PNTDIF
	PUSHJ P,AUDINF		;FIX UP
	PUSHJ P,SPREAD		;OUTPUT POINTERS
IFE FTDOPS,<
	TLNE IOS,HDRDIF		;WERE BLOCKS REASSIGNED AT INTERRUPT LEVEL?
	JRST DCLOI		;YES.
>;IFE FTDOPS
	POPJ P,
>;IFE FTLUFD

IFN FTLUFD,<
DCLOI:	TLZN IOS,PNTDIF		;CURRENT POINTERS OK?
	JRST DCLOI1		;YES
	PUSHJ P,AUDINF		;FIX UP RETRIEVAL
	PUSHJ P,SPREAD		;SPREAD IN GROUP
	MOVE TAC,DGRP1R(DDB)
	CAIN TAC,1		;DID WE JUST FIX HEADER BY LUCK?
	TLZ IOS,HDRDIF
DCLOI1:	TLZN IOS,HDRDIF		;DOES THE HEADER NEED FIXING UP?
	JRST DCLOI3		;NO
	MOVEI TAC,1
	CAMN TAC,DGRP1R(DDB)	;LOOKING AT HEADER?
	JRST DCLOI2		;YES, GO FIX IT
	MOVEM TAC,USETP(DDB)	;!!!CLOBBER USETP.  UNLESS THIS IS CLOSE
				;!!!YOU MAY HAVE JUST LOST
	PUSHJ P,GGRETD		;GET HEADER POINTERS
DCLOI2:	PUSHJ P,AUDINF		;FIX UP
	PUSHJ P,SPREAD		;SPREAD IN HEADER
DCLOI3:	TLNE IOS,NTRUFD
	POPJ P,			;IF SUPERSEDE, THERE IS NO UFD ENTRY YET.
	TLZE IOS,UFDDIF		;NEED TO FIX UFD?
	PUSHJ P,UFDRTR		;BASH SOME RETRIEVAL INTO UFD
	POPJ P,
>;IFN FTLUFD
;⊗ DRELES DRELS1 DRELS2

;RELEASE UUO (FROM RESET)  DRELES, DRELS2

DRELES:	PUSHJ P,WAIT1		;MAKE SURE RESET WAITS FOR DISK TO STOP
	PUSHJ P,DCLOSI		;MAYBE DELETE FILE WE READ.
	LDB J,PJOBN		;MAKE SURE J IS RIGHT
repeat 1,<		;This loses disk blocks for RA-mode files
			;that have been extended  -- JJW 5/84
	TLNE IOS,WRITEB!ALTERB	;WRITING?
	SOS DDBCNT(J)		;YES, BUT NOT ANY MORE
	TLNN IOS,WRITEB		;IS A PARTIALLY WRITTEN FILE?
	JRST DRELS2		;NO, CLEAR DDB.
	PUSHJ P,GOSET		;WE GET HERE ON RESET ONLY.
	MOVEI DAT,DCLOI		;MAKE SURE RETRIEVAL IS OUT.
	PUSHJ P,QEWAIT
>;repeat 1
repeat 0,<		;This is an attempted fix, but it may cause
			;UFD retrieval clobberage  -- JJW 5/84
	TLNN IOS,WRITEB!ALTERB	;IS A PARTIALLY WRITTEN FILE?
	JRST DRELS2		;NO, CLEAR DDB.
	SOS DDBCNT(J)		;One less DDB open for writing
	PUSHJ P,GOSET		;WE GET HERE ON RESET ONLY.
	MOVEI DAT,DCLOI		;MAKE SURE RETRIEVAL IS OUT.
	PUSHJ P,QEWAIT
	TLNN IOS,WRITEB		;Skip if creating or superseding
	JRST DRELS2		;NO, CLEAR DDB.
>;repeat 0
	MOVE TAC,FILLOC(DDB)
	TLNE IOS,NTRUFD
	JRST DRELS1		;SUPERSEDE -  NO UFD ENTRY - DELETE FILE
	PUSHJ P,UFDSRC		;CREATE.  FIRST DELETE UFD ENTRY
	 PUSHJ P,ELOSE		;ERROR IF NOT FOUND.
	SETZM ACCNAM(DDB)
	MOVEI DAT,DRAUFD
	PUSHJ P,QEWAIT
	MOVE TAC,SRCLOC(DDB)	;THEN DELETE THE FILE.
DRELS1:	PUSHJ P,DCLSOD		;DELETE NEW FILE.
DRELS2:	TDNE IOS,[DEVSBB,,IOACT]	;HERE FROM SETDDB,CLRDDB TO CLEAR OUT CRUFT
	PUSHJ P,WAIT1		;THIS SHOULDN'T HAPPEN, BUT IT DOES.
	MOVSI TAC,DEVIBF
	ANDCAM TAC,DEVCMR(DDB)
	PUSHJ P,RTNCOR
	PUSHJ P,RTNBUF
IFN FTDCSH,<
	PUSHJ P,RTNCSH
>;IFN FTDCSH
	PUSHJ P,RTNUDB
	SETZM ACCNAM(DDB)
	HRLI TAC,ACCNAM(DDB)
	HRRI TAC,ACCNAM+1(DDB)
	BLT TAC,DDEND-1(DDB)
	SETZB IOS,DEVIOS(DDB)
	JRST DPOPJ
;⊗ DSETI DSETC0 DSETC1 DSETC2 DSETO DGETF CNGSTS CNGST1 DGETL DGETL1 DSETC DFLSHO

DSETI:	TLNN IOS,READB
	JRST ENOLUK
	PUSH P,UUO		;SAVE THIS FOR LATER
	HRRI UUO,CLSOUT		;DON'T AFFECT OUTPUT
DSETC0:	PUSHJ P,DSETC		;FLUSH BUFFERS, FINISH IO
	POP P,TAC1
	HRRE TAC1,TAC1
	TRNN IOS,PHUBIT		;MAYBE WANTS TO IGNORE OFFSET
	ADD TAC1,DOFFST(DDB)	;ADD OFFSET
	SKIPG TAC1		;IF LESS THAN 1
	MOVEI TAC1,1		;MAKE IT 1 (LOSERS)
	PUSHJ P,DGETL		;GET RECORD EOF+1
	CAMG TAC,TAC1		;SET TO END IF NOT IN FILE
	JRST DSETC1		;Not inside file.
	MOVE TAC,TAC1		;IT'S OK - USE IT
	JRST DSETC2

DSETC1:	CAML TAC,TAC1		;skip if it's far off the end
	TRNN UUO,CLSIN		;right at the end. skip if USETO - NO IOEND for USETO
	TDOA IOS,[IOEND,,IODEND];OFF END of file.  Set IODEND
DSETC2:	TDZ  IOS,[IOEND,,IODEND];INSIDE FILE, NO EOF
	MOVEM TAC,USETP(DDB)	;STORE NEW POINTER
	TLNE IOS,WRITEB!ALTERB	;COULD HE BE WRITING?
	SKIPN TAC1,DGRP1R(DDB)	;AND DO WE HAVE ANY RETRIEVAL?
	JRST DSIOS		;NOTHING TO DO
NoStructure,<
	CAIGE TAC,RCPGRP(TAC1)	;Skip if new record is beyond current group
	CAIGE TAC,(TAC1)	;IS NEW RECORD IN CURRENT RETRIEVAL?
	TLZN IOS,PNTDIF		;NO, POINTERS NEED UPDATE?
	JRST DSIOS		;NO UPDATE!
>;NoStructure
IfStructure,<
	MOVE TAC1,DD.RPG(DDB)	;number of records in group
	ADD TAC1,DGRP1R(DDB)	;Compute RN of first R in next G
	CAMGE TAC,TAC1		;Skip if new record is beyond current G
	CAMGE TAC,DGRP1R(DDB)	;Is new record in current Group?
	TLZN IOS,PNTDIF		;New R not in curr.G. Skip if pointers need update
	JRST DSIOS		;NO UPDATE!
>;IfStructure
IFE FTDOPS,<
	PUSH P,USETP(DDB)
	MOVEI DAT,DCLSO5
	PUSHJ P,NEWAIT
	POP P,USETP(DDB)
>;IFE FTDOPS
IFN FTDOPS,<
	CAIN TAC1,1
	TLZ IOS,HDRDIF		;SPREADING FIRST GROUP, SO CLEAR HDRDIF
	PUSHJ P,AUDINF
	MOVEI DAT,SPREAD
	PUSHJ P,NEWAIT		;GO
>;IFN FTDOPS
	JRST DSIOS		;STO IOS AND RETURN

DSETO:	TLNN IOS,WRITEB!ALTERB
	JRST ENOENT
	PUSH P,UUO
	HRRI UUO,CLSIN		;LEAVE INPUT ALONE
	JRST DSETC0

DGETF:	PUSHJ P,CNGST1		;FLUSH ALL BUFFERS.
	PUSHJ P,DGETL		;NOW GET END OF FILE
	MOVE TAC1,TAC		;SAVE COPY
	TRNN IOS,PHUBIT		;MAYBE WANTS TO IGNORE OFFSET
	SUB TAC1,DOFFST(DDB)	;UN-OFFSET FOR LOSER
	XCTR XRW,[HRRM TAC1,(UUO)]	;GIVE TO USER
	JRST DSETC1		;AND USETP TO THERE

CNGSTS:	LDB TAC,[POINT 4,UUO,35];GET NEW MODE.
	LDB TAC1,PIOMOD		;GET OLD MODE
	CAIL TAC,SD		;SKIP IF GOING TO BUFFERED MODE
	CAIL TAC1,SD		;GOING TO DUMP.  SKIP IF CHANGING
	POPJ P,			;NO BUFFERS TO FLUSH.
CNGST1:	PUSH P,UUO		;HERE FOR UGETF, SETSTS.
	HRRI UUO,CLSIN!CLSOUT	;CLOSE BUFFERS IN CASE HE WANTS DUMP MODE
	TLNE IOS,READB
	TRZ UUO,CLSIN		;DO INPUT CLOSE SINCE INPUT IS ACTIVE
	TLNE IOS,WRITEB!ALTERB
	TRZ UUO,CLSOUT		;DO OUTPUT CLOSE
	PUSHJ P,DSETC		;FLUSH BUFFERS, FINISH IO
	POP P,UUO
	POPJ P,

DGETL:	MOVE TAC,FILLNG(DDB)	;FIND NEXT FREE RECORD
↑DGETL1:ADDI TAC,RECSIZ-1	;ROUND UP TO NEXT FULL RECORD
	ANDCMI TAC,RECSIZ-1
	ASH TAC,-RECWSH
	AOJA TAC,CPOPJ

DSETC:	MOVSI IOS,IOSET		;FLAG FOR CLOSE
	IORB IOS,DEVIOS(DDB)	;FOR WAIT1 AT CLSOUT (UUOCON)
	PUSH P,DDB
	PUSHJ P,CLOSE1		;TO FLAG BUFFERS EMPTY.
	POP P,DDB		;RE-OPEN
	TLZ IOS,IOSET		;MAKE SURE THIS IS OFF!
	MOVEM IOS,DEVIOS(DDB)
	HLLM DDB,USRJDA(UCHN)	;AND REPLACE IN USER TABLE
	POPJ P,

↑DFLSHO:PUSH P,UUO		;HERE FROM OUT UUO TO MOVE BUFFERS
	HRRI UUO,CLSIN		;LEAVE INPUT ALONE
	PUSHJ P,DSETC		;FLUSH OUT ALL THE BUFFERS
	POP P,UUO
	JRST WAIT1
;MTAPE ⊗ DGETW DGETW1 GODDIS GDSXRD GDSXWR GODLEN GETPNT DGODZ

;MTAPE UUO -- BY R. HELLIWELL -- 16 JAN 72  -  DGETW

;	IF FIRST WORD = SIXBIT/GODMOD/	:
;		THEN SECOND WORD IS DISPATCH INTO GODDIS
;		SEE ROUTINE FOR FURTHER DESCRIPTION
;
;	ANYTHING ELSE IN FIRST WORD GETS THE USET POINTER!

DGETW:	PUSHJ P,WAIT1			;FINISH ANYTHING IN PROGRESS
	XCTR XR,[MOVE TAC,(UUO)]	;PICK UP FIRST ARG!!!
	CAMN TAC,[-1]			;OLD MTAPE?
	JRST UUOERR			;YES: OLD FORM OF MTAPE NO LONGER EXISTS
	CAME TAC,['GODMOD']		;REQUESTING NEW GOD MODE
	JRST GETPNT			;NO. GET THE USET POINTER
	ADDI UUO,1
	XCTR XR,[HRRZ TAC,(UUO)]	;RESERVE LEFT HALF FOR OTHER MODIFIERS. REG
	CAIL TAC,GODLEN			;OFF END OF TABLE?
	JRST UUOERR			;YES, TELL HIM HE LOST
	SKIPL GODDIS(TAC)		;PROTECTED MTAPE?
	JRST DGETW1			;NO, DISPATCH
	MOVE TAC1,JBTPRV(J)		;YES, CHECK PRIV.
	TLNN TAC1,INFPRV		;USE THIS PRIVILEGE
	JRST UUOERR			;LOSER
DGETW1:	MOVE TAC1,GODDIS(TAC)		;IN CASE UDP, SEE IF WE NEED SAT IN
	TLNN TAC1,200000		;DEPENDS ON WHICH MTAPE
	JRST @GODDIS(TAC)		;NO, JUST DISPATCH
	PUSH P,TAC			;YES, DO IT
	PUSHJ P,SATGET
	POP P,TAC
	PUSHJ P,@GODDIS(TAC)
	POPJ P,

;IF SIGN BIT ON IN TABLE, MUST HAVE INFPRV TO DO THIS UUO!!!!!!!!
;200000,,0 BIT MEANS UDP SAT TABLE MUST BE IN CORE

GODDIS:		GETPNT		;0	GET USET POINTER
	400000,,GDREAD		;1	READ DISK BLOCK
		GDWRIT		;2	WRITE DISK BLOCK
	200000,,SETSAT		;3	SET SAT BIT
	200000,,CLRSAT		;4	CLEAR SAT BIT
	200000,,SATRD		;5	READ WORDS FROM SAT TABLE
	200000,,SATWRT		;6	WRITE WORDS IN SAT TABLE
	200000,,SATFRC		;7	FORCE OUT SAT
		REAINF		;10	READ 4 WORDS OF FILE INFO
		WRTINF		;11	WRITE 4 WORDS OF FILE INFO
		GETPNT	;DIAGL	;12	DIAGNOSTIC LOAD
		GETPNT	;DIAGW	;13	DIAGNOSTIC WRITE
		GETRTR		;14	GET FILE RETRIEVAL DATA
		INFCOM		;15	COMPARE A WORD IN DQINFO
		ADDBLK		;16	FIX RETRIEVAL TO INCLUDE AN EXISTING BLOCK
		FILEUP		;17	UPDATE ALL POINTERS AND HEADER INFO
		RDOFF		;20	READ FILE RECORD OFFSET
		WRTOFF		;21	SET FILE RECORD OFFSET
	200000,,TKSFRE		;22	HOW MANY FREE TRACKS LEFT
	200000,,VOLID		;23	TELL USER THE SATID
IFN FTSIX,<
GDSXRD:		SIXRD		;24	READ THE DISK IN DUMP MODE INTO SIX CORE
GDSXWR:		SIXWRT		;25	WRITE THE DISK IN DUMP MODE FROM SIX CORE
>;IFN FTSIX
IFE FTSIX,<
		GETPNT		;24
		GETPNT		;25
>;IFE FTSIX
IFN FTLUFD,<
		LUPUFD		;26	LOOK UP UFD ENTRY FOR A GIVEN FILE
>;IFN FTLUFD
IFE FTLUFD,<
		GETPNT		;26
>;IFE FTLUFD
IFN FTGRP,<
		RDGRP		;27	READ GROUP ACCESS BITS
>;IFN FTGRP
IFE FTGRP,<
		GETPNT		;27
>;IFE FTGRP
		DFLSHO		;30	FLUSH OUTPUT (PSEUDO-CLOSE)
		UNITYP		;31	Report unit characteristics
IFN FTRH,<
		RUDPUP		;32	check RH UDP(s) that just came online
>;IFN FTRH
IFE FTRH,<
		GETPNT		;32
>;IFE FTRH
GODLEN←←.-GODDIS

;	MTAPE CHN,[	≠-1 ∧ ≠SIXBIT/GODMOD/	]
;  OR
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			0		];POINTER COMES BACK HERE

GETPNT:	MOVE TAC,USETP(DDB)		;GET USET POINTER
	TRNN IOS,PHUBIT			;MAYBE WANTS TO IGNORE OFFSET
	SUB TAC,DOFFST(DDB)		;DO OFFSET
	XCTR XW,[MOVEM TAC,(UUO)]	;AND GIVE IT TO USER
	POPJ P,

;CHECK DISK ABSOLUTE WRITE PRIVILEGE
DGODZ:	MOVSI AC1,DAWPRV
	TDNN AC1,JBTPRV(J)		;SKIP IF DISK ABSOLUTE WRITE PRIV
	JRST UUOERR			;LOSER
	POPJ P,
;⊗ GDWRIT GDWRI1 GDREAD GRDIDA GDRED0 GDRED1 GDRED2 DEPOPJ

;	GDWRIT, GDREAD
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			1=READ 2=WRITE.
;			IOWD WC,MA
;			<RECORD #>,,<DISK BLOCK ADDRESS>	]
;	IO ERROR RETURN
;	SUCCESS RETURN
;Note: the WC must reference only one disk block.
;
;For the RH-based disks, the disk address word has the following format:
;	If bit 0 is zero, the address is a structure number and record in structure.
; 			bits 1:5 are the structure number;
;			bits 6:35 are the record number in structure
;	If bit 0 is one, the address is a physical address:
;			bits 1:3 are the channel number
;			bits 4:6 are the unit number
;			bits 7:35 are the record number in unit
;	The transfer must not cross a cylinder boundary.


GDWRIT:
IFN FTRH,<
	LDB TAC,PUNIT
	CAMLE TAC,[UPACKS]
	JRST GDWRI1			;Jump if RH-based unit.  SAT isn't at ZERO!
>;IFN FTRH
	XCTR XR,[HRRZ TAC,2(UUO)]	;MUST NOT WRITE SAT DIRECTLY
	JUMPE TAC,UADRER		;(DON'T BE FOOLED BY A RECORD # - REG)
GDWRI1:	PUSHJ P,DGODZ			;IS HE LEGAL?
	SKIPA TAC,[DWRITE!DUSER]	;MAKE IT A WRITE
GDREAD:	MOVEI TAC,DUSER			;READ
	MOVSM TAC,TFRCTL(DDB)		;SAVE WHICH DIRECTION
	XCTR XR,[SKIPL 1(UUO)]		;MAKE SURE THERE'S A NON-ZERO WC.
	JRST ADRERR			;LOSE
	ADDI UUO,1			;FOR DMPCMD
	PUSHJ P,DMPCMD			;ADDRESS CHECK THE IOWD
	 POPJ P,			;(END OF LIST - CAN'T HAPPEN)
	MOVE AC1,TFRCTL(DDB)		;READ OR WRITE?
	TLNN AC1,DWRITE			;SKIP IF WRITE.
	JUMPL TAC1,UADRER		;READING. JUMP IF CORE WRITE PROTECTED.
	HRL TAC,TAC1			;MA,,-WC
	MOVSM TAC,TFRIOW(DDB)
	SUBI UUO,1			;READJUST UUO.
NoStructure,<
	LDB TAC1,PUNIT			;GET UNIT (DSK OR UDP?)
	CAMLE TAC,LSTRKT(TAC1)		;MUST BE IN RANGE FOR THIS DEVICE
	POPJ P,				;LET THE USER FIGURE OUT WHAT'S WRONG. (REG)
	LSH TAC,6			;POSITION FOR TRACK ADDRESS
	ADD TAC,BFSETS(TAC1)
	XCTR XR,[HLRZ TAC1,2(UUO)]	;GET RECORD #
	CAILE TAC1,RCPBLK		;LEGAL RECORD?
	JRST UADRER
	IOR TAC,TAC1			;MERGE ADDRESS
	MOVEM TAC,TFRSEC(DDB)		;DISK ADDRESS (TRACK & RECORD) TO DDB
	XCTR XR,[HLRO TAC,1(UUO)]	;GET WC AGAIN
	IMULI TAC1,RECSIZ		;RECORD NUMBER OF FIRST RECORD*RECORD SIZE
	SKIPE TAC1
	SUBI TAC1,RECSIZ-SECSIZ		;RECORD ZERO IS SMALLER
	SUB TAC1,TAC			;AND "ADD" WC
	CAILE TAC1,BLKWDS		;RUN OFF END OF BLOCK?
	JRST UADRER			;YES.  ERROR.
	PUSHJ P,GOSET			;MAKE US UNSTOPPABLE
	;fall thru
>;NoStructure

IfStructure,<
IfN FTRH,<
	LDB	TAC,PUNIT
	CAMG	TAC,[UPACKS]
	JRST	GDRED0			;process God mode operation on old disk
	XCTR	XR,[SKIPL TAC1,2(UUO)]	;Get Full wd Disk address.  Skip if Absolute
	PUSHJ	P,STRADR		;convert structure & record to absolute
	JUMPE	TAC1,GRDIDA		;jump if can't translate disk address
	MOVEM	TAC1,TFRSEC(DDB)	;disk address Chan/Unit/record to DDB
	PUSHJ	P,GETUDB		;Get the UDB for TAC1 into AC3
	JUMPE	AC3,GRDIDA		;Jump if no such channel/Unit
	MOVE	AC1,UDBSIZ(AC3)		;Pointer to the size table
	LDB	TAC,[POINT 29,TAC1,35]	;Get the in-unit record number
	CAML	TAC,SECUNT(AC1)		;Skip if legal record number.
	JRST	GRDIDA			;No suc record on this unit.
	IDIV	TAC,SECCYL(AC1)		;Divide by Rec per Cyl. TAC1 is REC in CYL
	XCTR	XR,[HLRO TAC,1(UUO)]	;-WC
	MOVN	TAC,TAC
	ADDI	TAC,RECSIZ-1
	LSH	TAC,-RECWSH		;number of records in transfer
	ADD	TAC1,TAC		;compute end of transfer in R past Cyl Org
	MOVE	AC2,UNIRPB(AC1)		;Number of data records per block
	CAIG	TAC,1(AC2)		;skip if more than one block (incl rtvl)
	CAMLE	TAC1,SECCYL(AC1)	;skip if within one cylinder
	JRST	UADRER			;is bigger than 1 blk or it crosses a CYL
	PUSHJ	P,GOSET			;MAKE US UNSTOPPABLE
	JRST	GDRED2

GRDIDA:	XCTR	XW,[SETZM 2(UUO)]	;Failure:  illegal disk address
	POPJ	P,			;Return zero and no skip
>;IFN FTRH

GDRED0:	XCTR	XR,[HRRZ TAC,2(UUO)]	;Pick up disk address
	MOVE	TAC1,SDBPTR(DDB)
	CAMLE	TAC,ST.LAD(TAC1)	;MUST BE IN RANGE FOR THIS DEVICE
	POPJ	P,			;LET THE USER FIGURE OUT WHAT'S WRONG. (REG)
	LSH	TAC,6			;POSITION FOR TRACK ADDRESS
	ADD	TAC,ST.BSS(TAC1)
	XCTR	XR,[HLRZ TAC1,2(UUO)]	;GET RECORD #
	CAMLE	TAC1,DD.RPB(DDB)	;LEGAL RECORD?
	JRST	UADRER
	IOR	TAC,TAC1		;MERGE Record number into disk ADDRESS
	MOVEM	TAC,TFRSEC(DDB)		;DISK ADDRESS (TRACK & RECORD) TO DDB
	XCTR	XR,[HLRO TAC,1(UUO)]	;GET -WC AGAIN
;compute number of words to skip in this track before getting to desired record.
	JUMPE	TAC1,GDRED1		;no words to skip before record zero
	SUB	TAC,DD.SSZ(DDB)		;"add" size of record zero to wc
	SOSE	TAC1			;we've accounted for record zero
	IMULI	TAC1,RECSIZ		;count of real data recs*RECORD SIZE
GDRED1:	SUB	TAC1,TAC		;AND "ADD" WC.  TAC1 is count to end of blk
	MOVE	TAC,DD.RPB(DDB)		;How many records in a block
	LSH	TAC,RECWSH		;this is wc of data region of blk
	ADD	TAC,DD.SSZ(DDB)		;plus rtvl. Sum is total length of a blk
	CAMLE	TAC1,TAC		;Does this transfer run off the end of blk?
	JRST	UADRER			;YES.  ERROR.
	PUSHJ P,GOSET			;MAKE US UNSTOPPABLE
>;IfStructure

IFKL10,<
;;;	NOCACHE (CSHDSK)
	TLNE AC1,DWRITE
	PUSHJ P,VALCOR			;IF WRITING, JUST VALIDATE CORE
	TLNN AC1,DWRITE
	PUSHJ P,SWEEPA			;IF READING, SWEEP ENTIRE CACHE
;see comments for dump mode input and output
>;IFKL10

GDRED2:	MOVEI DAT,TSTART		;At most, transfer one block
	PUSHJ P,QEWAIT			;DO IT

;;;	CACHE (CSHDSK)

	SETZM DDLOC(DDB)
DEPOPJ:	TRNE IOS,IODERR!IODTER!IOIMPM	;ANY ERRORS?
	JRST DPOPJ			;YES, NO SKIP
	JRST DPOPJ1			;NO, SKIP RETURN
;⊗ SETSAT CLRSAT

;	SETSAT, CLRSAT
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			3=SET BIT	4=CLEAR BIT
;			DISK ADDRESS]
;
;	CLEAR OR SET SAT BIT CORRESPONDING TO DISK ADDRESS

SETSAT:	SKIPA AC2,[MRKBLK]
CLRSAT:	MOVEI AC2,RTNBLK
	PUSHJ P,DGODZ			;MUST BE GOD TO TWIDDLE BITS
NoStructure,<
	LDB TAC1,PUNIT
	XCTR XR,[SKIPLE TAC,1(UUO)]	;GET BLOCK ADDRESS
	CAMLE TAC,LSTBTB(TAC1)		;IN SAT TABLE?
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	XCTR XR,[SKIPLE TAC,1(UUO)]	;GET BLOCK ADDRESS
	CAML TAC,ST.LSA(TAC1)		;IN SAT TABLE?
>;IfStructure
	JRST UADRER			;NO
	JRST (AC2)			;SET OR CLEAR A BIT, AND POPJ
;⊗ SATWRT SATRD SATSUP SATFRC

;	SATWRT, SATRD, SATFRC
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			5=READ  6=WRITE
;			IOWD WC,MA
;			RELATIVE ADDRESS IN SAT TABLE]
;
; ADDRESS IS RELATIVE TO SATTAB, NOT SATBIT!!!!!
; READ OR WRITE PORTIONS OF SAT TABLE IN CORE!

SATWRT:	PUSHJ P,DGODZ			;CHECK FOR GOD
	PUSHJ P,SATSUP			;SAT SET UP
	MOVS TAC1,TAC1			;SWAP POINTERS TO BLT INTO SYSTEM
	ADDI TAC,-1(TAC1)		;GET LAST LOC
	XCTR XBLTR,[BLT TAC1,(TAC)]	;AND DO BLT (USER TO SYSTEM)
	POPJ P,

SATRD:	PUSHJ P,SATSUP			;SAT SET UP
	ADDI TAC,-1(TAC1)		;GET LAST LOC
	XCTR XBLTW,[BLT TAC1,(TAC)]	;BLT SYSTEM TO USER
	POPJ P,

;RETURNS: TAC=+NUMBER OF WORDS, TAC1=SATADR,,USER ADDR
SATSUP:	ADDI UUO,1			;FOR DMPCMD
	XCTR XR,[SKIPGE (UUO)]		;SKIP UNLESS PROPER IOWD.
	PUSHJ P,DMPCMD			;ADDRESS CHECK IOWD (DON'T RELOCATE)
	 JRST UADRER			;IOWD WRONG. (DMPCMD WILL SKIP)
	MOVM TAC,TAC			;TAC←+WC
	XCTR XR,[SKIPGE AC1,1(UUO)]	;GET RELATIVE SAT ADDRESS
	JRST UADRER
	MOVE AC2,TAC			;AC2←WC
	ADD AC2,AC1			;GET RELATIVE END OF SAT
NoStructure,<
	LDB AC3,PUNIT			;GET UNIT AS INDEX TO SAT TAB TABLES
	CAMLE AC2,TSATSZ(AC3)		;INSIDE SAT?
	JRST UADRER			;NO
	MOVE AC3,SATADR(AC3)		;ORIGIN OF SAT FOR THIS DEVICE
>;NoStructure
IfStructure,<
	MOVE AC3,SDBPTR(DDB)
	CAMLE AC2,ST.SSZ(AC3)		;INSIDE SAT?
	JRST UADRER			;NO
	MOVE AC3,ST.SAD(AC3)		;ORIGIN OF SAT FOR THIS DEVICE
>;IfStructure
	ADDI AC3,(AC1)			;FIRST WORD TO TRANSFER
	HRLI TAC1,(AC3)			;LH(TAC1)←CORE ADDRESS OF FIRST WORD OF SAT
	POPJ P,				;RETURN TO DO BLT

;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			7		]
;
;FORCE SAT TABLE TO BE WRITTEN OUT!

SATFRC:
NoStructure,<
	LDB TAC,PUNIT
	SETOM SATMOD(TAC)		;LET ANYBODY FORCE SAT OUT
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SETOM ST.SMD(TAC)		;LET ANYBODY FORCE SAT OUT
>;IfStructure
	JRST CUSATO			;OUTPUT THE RIGHT SAT TABLE AND WAIT
;⊗ RDGRP REAINF WRTINF LINOUT WRTINS WRTINX WRTIN1 WRTING WRTINZ

;CALL:	MTAPE CHN,[	SIXBIT /GODMOD/
;			27
;			UFD'S PROTECTION WORD STORED HERE
;			UFD'S FILE INFO WORD 3 STORED HERE (DEFAULT PRO/GRP ACCESS)
;				]
;	ERROR RETURN, NO LOOKUP DONE
;	SUCCESS RETURN

RDGRP:	TLNN IOS,READB
	POPJ P,				;NO LOOKUP DONE
	MOVE TAC,UFDPRO(DDB)		;GIVE HIM UFD'S PROTECTION WORD
	XCTR XW,[MOVEM TAC,1(UUO)]
	MOVE TAC,UFDPR1(DDB)		;GIVE HIM UFD'S DEFAULT PROT/GRP ACCESS WORD
	XCTR XW,[MOVEM TAC,2(UUO)]
	JRST CPOPJ1

;CALL:
;	MTAPE CHN,[	SIXBIT /GODMOD/
;			10
;			ADDRESS TO PUT INFO (4 WORDS)	]
;	ERROR RETURN, NO LOOKUP DONE
;	SUCCESS RETURN

REAINF:	TLNN IOS,READB			;LOOKUP DONE?
	POPJ P,				;NO
	MOVSI TAC1,DQINFO(DDB)		;GET INFO FROM HERE
	XCTR XR,[HRR TAC1,1(UUO)]	;THIS IS THE DESTINATION ADDRESS
	MOVEI TAC,DQLEN-1(TAC1)		;FINAL ADDRESS
	XCTR XBLTW,[BLT TAC1,(TAC)]	;BLT SYSTEM TO USER.
	MOVSI TAC,INFPRV
	TDNE TAC,JBTPRV(J)		;IS SHE PRIVILEGED?
	JRST CPOPJ1			;YES, ALL DONE
	MOVE TAC,DDPPN(DDB)		;HMM.  WAS SHE PEEKING AT A UFD?
	XCTR XR,[MOVE TAC1,1(UUO)]	;TAC1 ← ADDR OF PASSWORD
	CAMN TAC,MFDENT
	XCTR XW,[SETZM (TAC1)]		;SORRY, YOU CAN'T DO THAT!
	JRST CPOPJ1

;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			11
;			ADDRESS OF 4 WORDS TO WRITE INTO RETRIEVAL	]
;	ERROR RETURN
;	SUCCESS RETURN

WRTINF:	PUSHJ P,DGODZ
	TDNE IOS,[DEVSBB,,IOACT]
	PUSHJ P,WAIT1
	SKIPE FILNAM(DDB)	;NO FILE TO RENAME?
	TLNE IOS,DELETB		;OR GOING AWAY?
	POPJ P,			;LOSSAGE RETURN
	XCTR XR,[MOVE TAC1,1(UUO)]
	ADDI TAC1,DQLEN-1
	PUSHJ P,RELOCA		;ADDRESS CHECK END OF SOURCE
	 JRST UADRER
	XCTR XR,[MOVE TAC1,1(UUO)]
	PUSHJ P,RELOCB		;ADDRESS CHECK BEGINNING OF SOURCE
	 JRST UADRER
	XCTR XR,[MOVE TAC1,1(UUO)]
	HRLM TAC1,(P)		;SAVE USER RELATIVE ADDRESS FOR BLT.
REPEAT 0,<
	MOVE TAC1,JBTSTS(J)
	TLNE TAC1,JACCT		;DON'T PRINT THIS FOR LOGIN/OUT
	JRST LINOUT
	LDB TAC1,PUNIT
	JUMPN TAC1,LINOUT	;NOR FOR UDP
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /WRINFO/
	PUSHJ P,DISMES
	 ASCIZ /WRITE INFO, USER = /
	MOVE TAC,PRJPRG(J)
	PUSHJ P,DISPPN
	PUSHJ P,DISTAB
	PUSHJ P,DISJOB		;JOBNAME AND NUMBER
	PUSHJ P,DISMES
	 ASCIZ /   FILE = /
	MOVEI TAC,FILNAM(DDB)
	PUSHJ P,DISFIL
	PUSHJ P,DISCRLF
>;REPEAT 0
LINOUT:	MOVEI AC3,DQLEN		;GET BLOCK OF FREE STORAGE
	PUSHJ P,UFSGET		;GET IT
	PUSH P,AC1
	HLLZ TAC1,-1(P)		;GET SAVED USER ADDR
	HRR TAC1,AC1		;SYSTEM ADDR
	XCTR XBLTR,[BLT TAC1,DQLEN-1(AC1)]	;COPY USER DATA TO FREE STORAGE.
	PUSHJ P,FILEUP		;FORCE OUT POINTERS IF NECESSARY
	POP P,SRCTMP(DDB)	;SAVE ADDRESS
	TRZ IOS,IODERR!IODTER	;NO ERRORS YET!
	TLO IOS,RENAMB		;LOCK UP FILE WHILE WE'RE IN IT
	PUSHJ P,GOSET		;LEST WE GET STOPPED
	PUSH P,USETP(DDB)	;SAVE CURRENT USET
	MOVEI DAT,WRTINS	;I SUBR
	PUSHJ P,NEWAIT
	POP P,USETP(DDB)	;RESTORE USET
	MOVE AC1,SRCTMP(DDB)
	PUSHJ P,FSGIVE		;RETURN BLOCK
	TLZ IOS,RENAMB		;UNLOCK FILE
	JRST DEPOPJ

;***** I-SUBR FOR SMEARING OUT 4 WORD CHANGE TO DQINFO *****
WRTINS:	MOVE TAC,FILLOC(DDB)	;HERE IS WHERE WE START
	PUSHJ P,NEWFIL		;INITIALIZE FILE
	MOVE TAC,FILPPN(DDB)
	CAME TAC,SYSPPN		;MORE WORK IF THIS IS A UFD
	JRST WRTIN1
	MOVE TAC,FILNAM(DDB)	;TRYING TO SPREAD NEW RTVL IN A UFD.
	MOVEM TAC,UFDNAM(DDB)	;SET UP FOR UFDREQ
	PUSHJ P,UFDREQ		;GET UNIQUE ACCESS TO UFD & WAIT IF NEEDED
				;(Next POPJ returns via UFDCLR)
	SETZM DGRP1R(DDB)	;MAKE SURE WE READ
	PUSHJ P,WRTING		;SPREAD INFO THROUGHOUT (ONLY) GROUP
WRTINX:
IFN FTLUFD,<
	HRLZ TAC,SRCTMP(DDB)	;BLT FROM FS TO FILINX
	HRRI TAC,FILIN0(DDB)
	BLT TAC,FILIN0+DQLEN-1(DDB)
>;IFN FTLUFD
	POPJ P,

WRTIN1:	PUSHJ P,WRTING		;DO ONE GROUP
	SKIPN DNXTGP(DDB)	;ANOTHER TO GO?
IFE FTLUFD,<
	POPJ P,			;NO, EXIT
>;IFE FTLUFD
IFN FTLUFD,<
	JRST WRTINZ		;NO. GO UPDATE UFD ENTRY
>;IFN FTLUFD
NoStructure,<
	MOVEI TAC,RCPGRP
>;NoStructure
IfStructure,<
	MOVE TAC,DD.RPG(DDB)	;number of records per group
>;IfStructure
	ADDM TAC,USETP(DDB)	;Increase USETP to point to next GROUP
	JRST WRTIN1		;AND LOOP

WRTING:	PUSHJ P,GGRETD		;GET RETRIEVAL INTO DDB
	HRLZ TAC1,SRCTMP(DDB)	;GET FREE STORAGE ADDRESS
	HRRI TAC1,DQINFO(DDB)	;AND DDB ADDRESS
	BLT TAC1,DQINFO+DQLEN-1(DDB);BLT IN 4 WORDS
	JRST SPREAD		;SPREAD RET. OVER GROUP

IFN FTLUFD,<
;Update UFD entry for these info words just changed
;I have fixed two bugs here.  The exit now jumps to WRTINX, and,
; we now seize the UFD interlock.
WRTINZ:	MOVE TAC,FILPPN(DDB)	;WRITE NEW INFO IN UFD ENTRY
	MOVEM TAC,UFDNAM(DDB)	;SET UP FOR UFDREQ
	PUSHJ P,UFDREQ		;Get the UFD interlock
	PUSHJ P,UFDRCL
	 JRST [	JRST WRTINX	;Didn't find UFD entry, abort change
		'WRTINZ']	;Error argument to UFDRCL
	HRLZ TAC,SRCTMP(DDB)	;ADDRESS OF INFO WORD 0
	HRRI TAC,UQINFO(TAC1)	;ADDRESS OF INFO WORD 0 IN UFD ENTRY IN CORE
	BLT TAC,UQINFO+DQLEN-1(TAC1)	;CHANGE INFO WORDS IN UFD ENTRY
	PUSHJ P,SREWRIT		;WRITE UFD BACK OUT
	JRST WRTINX		;FIX FILINX AND EXIT
>;IFN FTLUFD
;⊗ WRTOFF WOFFOK WRTOFS WRTOF1 WRTOF2 RDOFF

;	WRTOFF, RDOFF
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			21
;			NEW FIRST RECORD	]
;	ERROR RETURN
;	SUCCESS RETURN

WRTOFF:	TDNE IOS,[DEVSBB,,IOACT]
	PUSHJ P,WAIT1
	SKIPE FILNAM(DDB)	;NO FILE TO RENAME?
	TLNE IOS,DELETB		;OR GOING AWAY?
	POPJ P,			;LOSSAGE RETURN
	MOVE AC2,FILPPN(DDB)
	CAMN AC2,SYSPPN
	JRST EPROT		;SORRY, NO RECORD OFFSETS ON 1,1 PLEASE.
	TLNE IOS,WRITEB		;ALREADY WRITING?
	JRST WOFFOK		;YES, OK
	MOVSI DAT,100000	;CHANGE; IS IT LEGAL?
	MOVE AC3,FILPRO(DDB)
	JSP AC1,PROTEK
WOFFOK:	XCTR XR,[MOVE TAC1,1(UUO)]	;GET USER OFFSET REQUEST
	SOJL TAC1,CPOPJ		;NORMALIZE AND TEST FOR TOO SMALL
	PUSH P,TAC1
	PUSHJ P,FILEUP		;MAKE POINTERS OK BEFORE CHANGING THEM
	POP P,SRCTMP(DDB)
	TRZ IOS,IODERR!IODTER	;NO ERRORS YET!
	TLO IOS,RENAMB		;LOCK UP FILE WHILE WE'RE IN IT
	PUSHJ P,GOSET		;LEST WE GET STOPPED
	PUSH P,USETP(DDB)	;SAVE CURRENT USET
	MOVEI DAT,WRTOFS	;I SUBR
	PUSHJ P,NEWAIT
	POP P,USETP(DDB)	;RESTORE USET
	TLZ IOS,RENAMB		;UNLOCK FILE
	JRST DEPOPJ

;***** I-SUBR FOR SMEARING OUT DOFFST CHANGE *****
WRTOFS:	MOVE TAC,FILLOC(DDB)	;HERE IS WHERE WE START
	PUSH P,USETP(DDB)
	PUSHJ P,NEWFIL		;INITIALIZE FILE
WRTOF1:	PUSHJ P,GGRETD		;GET RETRIEVAL INTO DDB
	MOVE TAC1,SRCTMP(DDB)	;GET NEW OFFSET
	MOVEM TAC1,DOFFST(DDB)	;SET INTO RETRIEVAL
	PUSHJ P,SPREAD		;SPREAD RET. OVER GROUP
	SKIPN DNXTGP(DDB)	;ANOTHER TO GO?
	JRST WRTOF2
NoStructure,<
	MOVEI TAC,RCPGRP	;INC USET TO NEXT GROUP
>;NoStructure
IfStructure,<
	MOVE TAC,DD.RPG(DDB)	;number of records per group
>;IfStructure
	ADDM TAC,USETP(DDB)
	JRST WRTOF1		;AND LOOP

WRTOF2:	POP P,USETP(DDB)
IFE FTLUFD,<
	POPJ	P,
>;IFE FTLUFD
IFN FTLUFD,<
	MOVE TAC,FILPPN(DDB)	;WRITE NEW OFFSET IN UFD ENTRY
	MOVEM TAC,UFDNAM(DDB)	;ARGUMENT TO UFDREQ
	PUSHJ P,UFDREQ		;Get the UFD interlock
	PUSHJ P,UFDRCL		;Recall info from the UFD
	 JRST [	POPJ P,		;DIDN'T FIND UFD ENTRY
		'WRTOF2']	;Argument to UFDRCL error
	MOVE TAC,SRCTMP(DDB)	;GET THE NEW OFFSET
	MOVEM TAC,FILOFF(DDB)	;REMEMBER IN AUDIT
	MOVEM TAC,UOFFST(TAC1)	;STORE IN OFFSET WORD IN UFD ENTRY IN CORE
	JRST SREWRIT		;WRITE UFD BACK OUT
>;IFN FTLUFD

;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			20
;			RECORD OFFSET STORED HERE
;			ACTUAL FILE LENGTH	]
;	ERROR RETURN
;	SUCCESS RETURN
RDOFF:	MOVE TAC,DOFFST(DDB)
	ADDI TAC,1
	XCTR XW,[MOVEM TAC,1(UUO)]	;REPORT STARTING RECORD #
	MOVE TAC,FILLNG(DDB)
	XCTR XW,[MOVEM TAC,2(UUO)]	;REPORT ACTUAL FILE LENGTH
	POPJ P,
;⊗ GETRTR

;	GETRTR
;CALL:	
;	MTAPE CHN,['GODMOD'
;			14
;		     IOWD WC,MA]	;WC≤40
;	<ERROR - NO LOOKUP OR ENTER>
;PLACE UP TO 40 WORDS OF FILE RETRIEVAL AT USER'S ADR.
;RETRIEVAL IS COPIED FROM THE DDB FOR THIS CHANNEL.
;USER MUST HAVE A FILE LOOKED UP SUCESSFULLY ALREADY.

GETRTR:	TLNN IOS,READB+WRITEB+ALTERB	;LOOKUP OR ENTER DONE?
	POPJ P,				;NO
	XCTR XR,[HRRZ TAC1,1(UUO)]	;GET HIS ADDRESS
	XCTR XR,[HLRO TAC,1(UUO)]	;AND THE WC
	CAMGE TAC,[-40]
	JRST UADRER
	SUB TAC1,TAC			;COMPUTE LAST ADDRESS OF TRANSFER
	PUSHJ P,RELOCA
	 JRST UADRER
	JUMPL TAC1,UADRER		;WRITE PROTECTED
	XCTR XR,[HRRZ TAC1,1(UUO)]	;GET THE ADDRESS HE SAID
	ADDI TAC1,1			;MAKE IT HONEST
	PUSHJ P,RELOCB
	 JRST UADRER
	JUMPL TAC1,UADRER		;WRITE PROTECTED
	XCTR XR,[HRRZ TAC1,1(UUO)]	;RELATIVE ADDRESS AGAIN.
	ADDI TAC1,1			;MAKE IT HONEST
	HRLI TAC1,DDNAM(DDB)		;GET INFO FROM HERE
	XCTR XR,[HLRO TAC,1(UUO)]	;GET -WC
	MOVN TAC,TAC			;+WC
	MOVE AC2,TAC			;REMEMBER THE WC
	MOVEI AC1,(TAC1)		;REMEMBER BEGINNING ADDRESS
	ADDI TAC,(TAC1)			;COMPUTE ENDING ADDRESS
	XCTR XBLTW,[BLT TAC1,-1(TAC)]	;MOVE DATA.  SYSTEM TO USER
	MOVE TAC,JBTPRV(J)		;GET THIS GUY'S PRIVILEGES
	CAILE AC2,DQINFO-DDNAM		;DID THIS USER READ SPECIAL STUFF?
	TLNE TAC,INFPRV			;IS HE ALLOWED TO SEE ALL RETRIEVAL?
	JRST CPOPJ1			;PRIVILEGED OR DIDN'T ATTEMPT TO READ DQINFO
	MOVE TAC1,DDPPN(DDB)		;BH 1/20/75 DON'T ZERO THE STUFF
	CAMN TAC1,MFDENT		;  EXCEPT FOR UFDS, & THEN ONLY PASSWORD--ME
	XCTR XW,[SETZM DQINFO-DDNAM(AC1)]	;ZERO DQINFO IN USER'S CORE.
	JRST CPOPJ1			;  LET USERS FIND OUT WHO WROTE THE FILE
;⊗ INFCOM ADDBLK ADDLOS FILEUP TKSFRE DSKRES DKRES1 VOLID UNITYP UNITYC UNITYB

;	INFCOM, ADDBLK, FILEUP, TKSFRE, DSKRES
;CALL:	
;	MTAPE CHN,['GODMOD'
;			15
;			0-3		;WHICH WORD TO COMPARE WITH
;		       DATA  ]		;DATA TO BE COMPARED
;	<NO LOOKUP OR ENTER OR COMPARE NOT EQUAL>
;THIS IS A UUO TO COMPARE A WORD FROM THE USER WITH ONE FROM
;THE SPECIAL 4 WORD RETRIEVAL BLOCK IN A FILE

INFCOM:	TLNN IOS,READB!WRITEB!ALTERB
	POPJ P,
	XCTR XR,[MOVE TAC,1(UUO)]	;PICK UP INDEX INTO 5 WORD RETRIEVAL BLOCK
	JUMPL TAC,UADRER		;CHECK IT
	CAIL TAC,DQLEN
	JRST UADRER
	ADDI TAC,DQINFO(DDB)		;CALC ADDR OF WORD
	MOVE TAC,(TAC)			;PICK IT UP
	XCTR XR,[CAMN TAC,2(UUO)]	;EQUAL TO LOSERS WORD?
	AOS (P)				;YES, SKIP
	POPJ P,

;CALL:
;	MTAPE CHN,['GODMOD'
;			16
;		     LOGICAL RECORD # (SET PHUBIT IF YOU WANT PHYSICAL REC #)]
;	<NO LOOKUP OR ENTER OR NON-EX BLOCK>
;THIS UUO ALLOWS THE USER TO INCLUDE AN EXISTING BLOCK IN HIS WORD COUNT

ADDBLK:	TLNE IOS,ALTERB!WRITEB!READB	;FILE OPEN SOMEHOW?
	XCTR XR,[SKIPG TAC,1(UUO)]	;PICK UP LOSERS REC. NO.
	POPJ P,				;AVOID CONFUSION
	PUSH P,USETP(DDB)		;SAVE OLD USET POINTER IN CASE HE LOSES
	TRNN IOS,PHUBIT			;MAYBE WANTS TO IGNORE OFFSET
	ADD TAC,DOFFST(DDB)		;DO OFFSET
	MOVEM TAC,USETP(DDB)
	PUSHJ P,GOSET			;MAKE US UNSTOPPABLE IN CASE BAD POINTER
	PUSHJ P,GETRET			;GET RETRIEVAL FOR RECORD
	 JRST ADDLOS			;NO SUCH GROUP
	PUSHJ P,LR2BLK			;THE GROUP EXISTS, DOES THE BLOCK?
	JUMPE TAC,ADDLOS		;0 MEANS NO SUCH BLOCK
	SUB P,[1,,1]			;BLOCK EXISTS, LOSE OLD USETP
	MOVE TAC,USETP(DDB)		;NOW INCLUDE THIS BLOCK IN WC
	LSH TAC,RECWSH			;MAKE IT WORDS
	CAMG TAC,FILLNG(DDB)
	JRST DPOPJ1			;ALREADY IN WC
	MOVEM TAC,FILLNG(DDB)		;UPDATE FILE LENGTH
	TLNE IOS,ALTERB!WRITEB		;WRITING?
	TLO IOS,IFN FTLUFD,<UFDDIF!>HDRDIF	;YES, MAKE SURE IT GETS WRITTEN OUT
	TDZ IOS,[IOEND,,IODEND]		;CAN'T BE EOF ANY MORE
	JRST DPOPJ1

ADDLOS:	POP P,USETP(DDB)		;NO SUCH RECORD, GET BACK OLD ONE
	JRST DPOPJ			;AND GIVE ERROR RETURN

;CALL
;	MTAPE CHN,['GODMOD'
;			17   ]
FILEUP:	TLNE IOS,ALTERB!WRITEB	;FILE OPEN?
	TLNN IOS,IFN FTLUFD,<UFDDIF!>PNTDIF!HDRDIF	;YES, ANYTHING TO DO?
	POPJ P,			;NO, NO-OP
	PUSH P,USETP(DDB)	;DCLOI CLOBBERS THIS ON MULTI-GROUP FILES
	MOVEI DAT,DCLOI
	PUSHJ P,NEWAIT		;ENTER REQUEST AND WAIT.
	POP P,USETP(DDB)
	POPJ P,

;MTAPE TO FIND OUT NUMBER OF FREE TRACKS ON A STRUCTURE
;CALL
;	MTAPE CHN,['GODMOD'
;			22
;			ADDRESS	TO STORE RESULT]

TKSFRE:	LDB TAC1,PUNIT			;FIND OUT THE ANSWER
	PUSHJ P,DSKRES			;RESULT IN TAC
	XCTR XR,[HRRZ TAC1,1(UUO)]	;GET USER'S ADDRESS
	XCTR XW,[MOVEM TAC,(TAC1)]	;RETURN RESULT TO THE USER
	POPJ P,

↑DSKRES:			;CALC FREE BLOCKS FOR UNIT IN TAC1 (CLOBBERS TAC1!)
NoStructure,<
	MOVE TAC,LSTBTB(TAC1)	
	SKIPG TAC1,SATADR(TAC1)	
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBADR(TAC1)
	MOVE TAC,ST.BTB(TAC1)	
	SKIPG TAC1,ST.SAD(TAC1)	
>;IfStructure
	JRST DKRES1		;NO SAT, NO TRACKS!
	SUB TAC,DSKUSE(TAC1)	;SUBTRACT THE NUMBER IN USE
	SUBI TAC,=200		;MINUS MAGIC BUFFER
	JUMPGE TAC,CPOPJ
DKRES1:	MOVEI TAC,0
	POPJ P,

;MTAPE TO FIND OUT SATID OF A STRUCTURE
;CALL
;	MTAPE CHN,['GODMOD'
;			23
;			ADDRESS	TO STORE RESULT]

VOLID:
NoStructure,<
	LDB TAC1,PUNIT			;TELL USER THE SATID
	SKIPLE TAC,SATADR(TAC1)
	MOVE TAC,SATID(TAC)		;IT SAYS HERE THERE HAS TO BE A SAT
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	MOVE TAC,ST.NAM(TAC1)
>;IfStructure
	XCTR XR,[HRRZ TAC1,1(UUO)]
	XCTR XW,[MOVEM TAC,(TAC1)]
	POPJ P,

;MTAPE to report characteristics of the disks from which a structure is composed
;CALL
;	MTAPE	CHN,['GODMOD'
;			31
;			Structure number. (if FTSTRUCT is zero, this is ignored)
;			  (If negative, reports for current structure.)
;			Address of an n-word block to store the results in]
;	<return here always>
;
UNITYP:	XCTR	XR,[MOVE TAC1,2(UUO)]		;Address where to put result
	MOVEI	DAT,DTYPLN-1(TAC1)		;Compute ending address for BLT
IfStructure,<
	XCTR	XR,[SKIPGE TAC,1(UUO)]		;Get structure number
	LDB	TAC,PUNIT			;convert negative to current struct
	CAIGE	TAC,STRMAX			;Bound check.  SKip if bad.
	SKIPN	TAC,SDBADR(TAC)			;In bound.  skip if defined
	JRST	UNITYB				;Bad struc num
	HRL	TAC1,ST.TYP(TAC)		;Address of disk type table
>;IfStructure
NoStructure,<
	HRLI	TAC1,DSKSZZ			;No structures.  Use this table
>;NoStructure
IFN FTRH,<
UNITYC:
>;IFN FTRH
	XCTR	XBLTW,[BLT TAC1,(DAT)]		;BLT system to user
	POPJ	P,

UNITYB:
IFN FTRH,<
	HRLI TAC1,DSKSZ1		;maybe this is special request for RP06
	CAIN TAC,100
	JRST UNITYC			;return RP06 characteristics
>;IFN FTRH
	XCTR	XR,[SETOM (TAC1)]		;return ''bad args'' msg to user
	POPJ	P,
;⊗ SIXRD SIXCHK SIXWRT

IFN FTSIX,<
;MTAPE TO READ THE DISK IN DUMP MODE INTO P3 MEMORY
;CALL
;	MTAPE CHN,['GODMOD'
;			24
;			IOWD FOR TRANSFER RELATIVE TO BEGINNING OF P3 MEMORY
;			ADDRESS OF USER MODE PLACE TO STORE ECC INFO
;			 (THIS AREA MUST BE WRITABLE AND AT LEAST 38. WORDS LONG)
;			ECC STATUS WORD 1 IS STORED HERE
;			ECC STATUS WORD 2 IS STORED HERE
;			DISK ADDRESS FOR OLD MODE TRANSFER
;			]

;THE ECC INFO IS TWO WORDS PER ENTRY IN THE FOLLOWING FORMAT:
; BYTE (12) BYTEC (24) BITS  ↔  P3 AOBJN POINTER TO RECORD
;WHERE BYTEC IS THE BYTE COUNT FROM THE BEGINNING OF THE RECORD AND BITS
;ARE THE 3 BITS FIELD TO BE XORED WITH THE DATA.

;ECC STATUS WORD 1 HAS THE FOLLOWING FORMAT:
;-N,,USER ADDRESS OF NEXT LOCATION TO STORE ECC INFO AT (N MAY BE ZERO)
;IF THE LEFT HALF IS 1 THEN SOME ECC INFO IS LOST.  IF SO, THE ECC STATUS
;WORD 2 IS THE FIRST P3 ADDRESS OF THE FIRST RECORD WHOSE ECC INFO WAS LOST.

SIXRD:	PUSHJ P,SIXCHK
	XCTR XR,[HRRZ TAC,2(UUO)]	;GET ECC POINTER
	XCTR XRW,[MOVES (TAC)]		;MUST HAVE WRITE ACCESS ...
	XCTR XRW,[MOVES 2*RCPTRK-1(TAC)]; ... TO THIS MANY WORDS
	XCTR XRW,[MOVES 3(UUO)]		;ALSO TO HERE
	XCTR XRW,[MOVES 4(UUO)]		;AND HERE
	HRLI TAC,-<2*CRMAX>		;AOBJN POINTER TO USER'S ECC AREA
	MOVEM TAC,ECCSIX(DDB)		;STORE ECC POINTER
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK			;SKIP IF OLD STYLE UDP
	JRST SXDMPI
	ADDI UUO,5-1			;SO REF TO 1(UUO) AT UDPSER WORKS
	JRST SXUDIN

SIXCHK:	LDB TAC,PIOMOD
	CAIGE TAC,DR			;MUST BE IN SOME DUMP MODE
	JRST UUOERR
	XCTR XR,[MOVE TAC,1(UUO)]	;GET TRANSFER IOWD
	HLRE TAC1,TAC
	JUMPGE TAC1,UADRER
	HRRZ AC1,TAC			;STARTING ADDRESS - 1
	SUB AC1,TAC1			;ENDING ADDRESS OF TRANSFER
	CAIL AC1,P3PGS*1000		;SKIP IF IT ENDS WITHIN P3 MEMORY
	JRST UADRER
	MOVEM TAC,IOWDSX(DDB)
	POPJ P,

;MTAPE TO WRITE THE DISK IN DUMP MODE FROM P3 MEMORY
;CALL
;	MTAPE CHN,['GODMOD'
;			25
;			IOWD FOR TRANSFER RELATIVE TO BEGINNING OF P3 MEMORY
;			DISK ADDRESS FOR OLD MODE TRANSFER
;			]

SIXWRT:	PUSHJ P,SIXCHK
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK			;SKIP IF OLD STYLE UDP
	JRST SXDMPO
	ADDI UUO,2-1			;SO REF TO 1(UUO) AT UDPSER WORKS
	JRST SXUDOU
>;IFN FTSIX
;⊗ LUPUFD DRPTMT DRPTM1 DRPTME DRPTI DRPTI1 DRPTIL DRPTIS

;MTAPE TO LOOKUP A FILE, AND RETURN ITS UFD ENTRY
;	MTAPE CHN,['GODMOD'
;			26
;			'FILENAME'
;			'EXTENSION',,ERROR CODE
;			UNUSED (MUST BE ZERO)
;			'PPN'
;			ADDRESS OF UFDLEN WORD BLOCK FOR UFD ENTRY TO BE STORED IN
;			]
;	ERROR RETURN
;	SUCCESS RETURN
;THE CONDITIONS FOR THIS UUO ARE PRECISELY THE SAME AS FOR LOOKUP

IFN FTLUFD,<

LUPUFD:	XCTR XR,[MOVE TAC1,1+UPPN+1(UUO)]	;GET ADDRESS FOR DATA
	ADDI TAC1,UFDLEN-1
	PUSHJ P,RELOCA			;ADDRESS CHECK END OF BLOCK
	 JRST UADRER
	JUMPL TAC1,UADRER		;BLOCK IS WRITE PROTECTED
	XCTR XR,[MOVE TAC1,1+UPPN+1(UUO)]
	PUSHJ P,RELOCB			;ADDRESS CHECK BEGINNING OF BLOCK
	 JRST UADRER
	JUMPL TAC1,UADRER
	ADDI UUO,1			;POINT AT FILENAME
	LDB UCHN,PUUOAC			;RESTORE UCHN FROM UUO
	HLL DDB,USRJDA(UCHN)		;RESTORE UUO BITS
	JRST UDLK			;BACK TO UUOCON WHICH WILL GO TO DLOOK

;HERE FROM DRPT TO REPORT DATA, UUO POINTS AT FILENAME
DRPTMT:	XCTR XR,[MOVE TAC,UPPN+1(UUO)]	;GET ADDRESS FOR DATA
	MOVEM TAC,TFRSEC(DDB)		;SAVE FOR INT SUBR
DRPTM1:	MOVEI DAT,DRPTI
	PUSHJ P,QEWAIT
	SKIPN SRCTMP(DDB)		;SKIP IF FAILED TO FIND UFD ENTRY
	JRST DRPTRT			;RETURN TO DRPT
	PUSH P,TFRSEC(DDB)
	PUSHJ P,FILSRC			;WILL SET UP UFDTRK AND UFDMEM
	 JRST DRPTME			;ERROR FROM FILSRC
	SKIPG SRCTMP(DDB)
	JRST DRPTME			;DIDN'T FIND IT
	MOVE TAC,FILLOC(DDB)
	PUSHJ P,NEWFI1
	PUSHJ P,GGRETD			;GET BACK RETRIEVAL OF FILE
	POP P,TFRSEC(DDB)		;RESTORE USER ADDRESS
	JRST DRPTM1

DRPTME:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /ERROR OR NOT FOUND RETURN FROM FILSRC AT DRPTMT.
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCAL
	JRST EGARB1

;*** INTERRUPT SUBR ****
DRPTI:	MOVE TAC,FILPPN(DDB)
	CAMN TAC,SYSPPN
	JRST DRPTIS			;NO INFO FOR 1,1
	PUSH P,TFRSEC(DDB)		;SAVE USER ADDRESS
					;No UFD interlock.  Read only operation
	PUSHJ P,UFDRCL			;TRY TO RECALL THE UFD ENTRY
	 JRST [	JRST DRPTIL		;CAN'T REMEMBER WHERE WE PUT IT
		'DRPTI ']		;Argument to UFDRCL
	POP P,TFRSEC(DDB)		;GET BACK USER ADDRESS
DRPTI1:	PUSHJ P,MAPSET
	HRRZ TAC,TFRSEC(DDB)
	HRLI TAC,(TAC1)			;BLT AC
	MOVEI AC1,UFDLEN-1(TAC)		;END OF BLT
	XCTR XBLTW,[BLT TAC,(AC1)]	;BLT UFD ENTRY TO USER
	SETZM SRCTMP(DDB)		;FLAG SUCCESS
	POPJ P,				;RETURN THROUGH MAPSET

DRPTIL:	POP	P,TFRSEC(DDB)		;Here after error from UFDRCL.
	POPJ	P,

DRPTIS:	PUSHJ P,MAPSET
	HRRZ TAC,TFRSEC(DDB)		;USER DESTINATION
	MOVEI TAC,-1(TAC)
	XCTR XSTKW,[PUSH TAC,DDNAM(DDB)]
	XCTR XSTKW,[PUSH TAC,DDEXT(DDB)]
	XCTR XSTKW,[PUSH TAC,DDPRO(DDB)]
	XCTR XSTKW,[PUSH TAC,DDLOC(DDB)]
	XCTR XSTKW,[PUSH TAC,DDLNG(DDB)]
	XCTR XSTKW,[PUSH TAC,[0]]	;EXTENDED TIME WRITTEN
	XCTR XSTKW,[PUSH TAC,DREFTM(DDB)]
	XCTR XSTKW,[PUSH TAC,DDMPTM(DDB)]
	XCTR XSTKW,[PUSH TAC,[0]]	;UNUSED
	XCTR XSTKW,[PUSH TAC,[0]]	;UNUSED
	XCTR XSTKW,[PUSH TAC,DSATID(DDB)]
	XCTR XSTKW,[PUSH TAC,[0]]	;DQINFO (PASSWORD)
	XCTR XSTKW,[PUSH TAC,DQINFO+1(DDB)]
	XCTR XSTKW,[PUSH TAC,DQINFO+2(DDB)]
	XCTR XSTKW,[PUSH TAC,DQINFO+3(DDB)]
	XCTR XSTKW,[PUSH TAC,DOFFST(DDB)]
	SETZM SRCTMP(DDB)		;SUCCESS
	POPJ P,

>;IFN FTLUFD
;LOOKUP UUO ;⊗ DLOOK DLOOKF SRCERR DLK2 DLK1 DLK3 DRPT DRPTRT DRPT4X DLOK DPOPJ1 DPOPJ DPJRST DPJRA3 DPJRSC GOSET DSIOS LOOKI LOOKI1 LOOKI1 LOOKI2 LOOKI4 LOOKU

;INPUT SIDE HAS ALREADY BEEN CLOSED

DLOOK:	TLNE IOS,WRITEB!ALTERB
	JRST EXFIL			;THIS DDB IS ALREADY WRITING
	TLZ IOS,IO!READB
	SETZM FILNAM(DDB)		;DISABLE RENAME (I.E., SET NO ACCESS)
	JSP AC1,ACCENT
IFN FTSUAI,<
	JRST DLOOKF		;Make it easy to patch it in
;Find refs to files that are going away
	MOVE AC1,ACCPPN(DDB)
	CAME AC1,['HSTNET']
	JRST DLOOKF
	MOVE AC1,ACCNAM(DDB)
	CAMN AC1,['TTYLOC']	;looking for TTYLOC.TXT[HST,NET]
	PUSHJ P,FBI		;report user
	 JFCL 7			;feature nbr 7
DLOOKF:
;end of ref trap
>;IFN FTSUAI
	SKIPN ACCNAM(DDB)		;WAS THE SPECIFIED NAME BLANK?
	JRST ENOFIL			;YES. LOSE.
	PUSHJ P,GOSET
	PUSHJ P,SATGET			;MAKE SURE SAT TABLE IS IN (FOR UDP)
	JSP AC1,ACCESS			;CHECK WHO'S DIDDLING FILE
	 JRST DLK1			;We found another reader.  Borrow data
	 JRST DLK2			;WRITE ENTRY
	 JFCL				;IGNORE CLOSED ACCESSORS
	PUSHJ P,FILSRC			;SEARCH DIRECTORY FOR FILE
	 JRST SRCERR			;NO SUCH UFD (OR BAD RETR)
	SKIPG SRCTMP(DDB)
	JRST ENOFIL			;NO SUCH FILE
	;Now check again in case things changed while we were searching.
	JSP AC1,ACCESS			;CHECK WHO'S DIDDLING FILE
	 JRST DLK1			;We found another reader.  Borrow data
	 JRST DLK2			;WRITE ENTRY
	 JFCL				;IGNORE CLOSED ACCESSORS
	MOVE TAC,SRCEXT(DDB)
	MOVEM TAC,ACCEXT(DDB)
	MOVE TAC,SRCPRO(DDB)
	MOVEM TAC,ACCPRO(DDB)
IFN FTLUFD,<
	MOVE TAC,SRCDAT(DDB)
	MOVEM TAC,DATWRT(DDB)
>;IFN FTLUFD
	JRST DLK3			;GO CHECK PROTECTION.

SRCERR:	TLNE IOS,LOSBIG			;ERROR FROM FILSRC
	JRST EGARB			;BAD RETR
	JRST ENOUFD			;OR NO UFD

DLK2:	TLNN TAC1,NTRUFD		;WRITING; IS THERE AN OLD FILE?
	JRST ENOFIL			;NO THERE IS ONLY A NEW ONE, REPORT NON EX
	JRST ACCES1			;THERE IS AN OLD ONE, SEEK IT

DLK1:	MOVE TAC1,FILEXT(TAC)		;READ ENTRY FOUND. - BORROW DATA
	MOVEM TAC1,SRCEXT(DDB)
	MOVEM TAC1,ACCEXT(DDB)
	MOVE TAC1,FILPRO(TAC)
	MOVEM TAC1,SRCPRO(DDB)
	MOVEM TAC1,ACCPRO(DDB)
	SKIPN TAC1,FILLOC(TAC)
	MOVE TAC1,SRCLOC(TAC)
	MOVEM TAC1,SRCLOC(DDB)
	MOVEM TAC1,FILLOC(DDB)
	MOVE TAC1,UFDPRO(TAC)
	MOVEM TAC1,UFDPRO(DDB)
	MOVE TAC1,UFDPR1(TAC)
	MOVEM TAC1,UFDPR1(DDB)
IFN FTLUFD,<
	MOVE TAC1,UFDTRK(TAC)
	MOVEM TAC1,UFDTRK(DDB)
	MOVE TAC1,UFDMEM(TAC)
	MOVEM TAC1,UFDMEM(DDB)
	MOVE TAC1,DATWRT(TAC)
	MOVEM TAC1,DATWRT(DDB)
>;IFN FTLUFD
DLK3:
IFN FTGRP,<
	MOVEI DAT,LOOKU		;Prepare to read UFD's RTVL to get group access bits
	MOVE TAC,ACCPPN(DDB)
	CAMN TAC,SYSPPN		;Skip if file isn't on [1,1]
	PUSHJ P,QEWAIT		;READ UFD'S RETRIEVAL TO GET GROUP ACCESS BITS
>;IFN FTGRP
	MOVSI DAT,200000
	JSP AC1,UPROTC		;CHECK READ ACCESS TO UFD
	MOVSI DAT,200000		
	JSP AC1,PROTEC		;CHECK READ ACCESS TO FILE
	TLO IOS,READB
	PUSHJ P,ACCEST		;OK, ACCESS ESTABLISHED
NoStructure,<
	LDB DAT,PUNIT
	SKIPLE TAC,SRCLOC(DDB)	;IS THE DISK ADDRESS OK?
	CAMLE TAC,LSTBTB(DAT)	
>;NoStructure
IfStructure,<
	MOVE DAT,SDBPTR(DDB)
	SKIPLE TAC,SRCLOC(DDB)	;IS THE DISK ADDRESS OK?
	CAML TAC,ST.LSA(DAT)	;Should be positive & smaller than size of Struct
>;IfStructure
	JRST EGARB1		;NO. THE UFD HAS BAD POINTER IN IT.
	MOVEI DAT,LOOKI
	PUSHJ P,QEWAIT		;UPDATE TIMES, GET LENGTH, INFO, OFFSET
	TLNE IOS,LOSBIG
	JRST EGARB2		;WRONG FILE FOUND AT LOC.
DRPT:	MOVN TAC1,DDLNG(DDB)	;REPORT DATA TO USER.
	TLNE IOS,ALTERB		;ARE WE GETTING INTO ALTER MODE?
	MOVN TAC1,FILLNG(DDB)	;YES, USE HONEST FILE LENGTH!
	MOVNM TAC1,FILLNG(DDB)
	MOVE AC2,DREFTM(DDB)
	MOVEM AC2,REFTIM(DDB)
	MOVE AC3,DDMPTM(DDB)
	MOVEM AC3,DMPTIM(DDB)
IFN FTLUFD,<
	LDB TAC,[POINT 9,UUO,8]	;GET UUO OPCODE
	CAIN TAC,<MTAPE>⊗-=27
	JRST DRPTMT		;FROM MTAPE, REPORT UFD DATA
>;IFN FTLUFD
	MOVEI TAC,(UUO)
	XCTR XSTKW,[PUSH TAC,FILEXT(DDB)]
	XCTR XSTKW,[PUSH TAC,FILPRO(DDB)]
	TRNN IOS,PHUBIT		;MAYBE WANTS TO IGNORE OFFSET
	SKIPA AC1,DOFFST(DDB)
	TDZA AC1,AC1		;IGNORE OFFSET
	LSH AC1,RECWSH		;MAKE IT WORDS
	ADD TAC1,AC1		;REPORT ADJUSTED SIZE TO USER
	SKIPLE TAC1
	MOVEI TAC1,0		;ACCOUNT FOR DOFFST BEING EOF
	MOVS TAC1,TAC1
	XCTR XSTKW,[PUSH TAC,TAC1]	;REPORT LENGTH TO USER.
	TRNE IOS,DMPBIT
	XCTR XSTKW,[PUSH TAC,AC2]	;REPORT REFERENCE TIME, IF DUMPER
	TRNE IOS,DMPBIT
	XCTR XSTKW,[PUSH TAC,AC3]

DRPTRT:					;RETURN FROM DRPTMT
IFN FTDSTT,<				;GATHER LOOKUP/ENTER HISTORY
	PUSHJ P,DSKTM1			;GET DATE AND TIME
	LDB TAC1,[POINT 11,TAC1,23]	;TIME IN MINUTES
	HRL TAC1,THSDAT			;DATE IN LH.
	MOVE TAC,DSTPUT			;GET THE PUTTER.
	PUSH TAC,TAC1			;0 STORE DATE,,TIME
	MOVS TAC1,JOB
	HRRI TAC1,(DDB)
	PUSH TAC,TAC1			;1 JOB,,DDB ADDRESS
	PUSH TAC,FILNAM(DDB)		;2 FILE NAME
	PUSH TAC,FILEXT(DDB)		;3 EXT
	PUSH TAC,FILPRO(DDB)		;4 PROTECTION, TIME, ETC
	PUSH TAC,FILPPN(DDB)		;5 PPN
	PUSH TAC,FILLNG(DDB)		;6 FILE LENGTH
	PUSH TAC,IOS			;7 SAVE IOS (ACCESS MODE)
	ANDI TAC,-1			;RIGHT SIDE ONLY.
	CAIGE TAC,DSTBUF+DSTBLN-1	;AT END OF BUFFER?
	JRST DRPT4X			;NO.
	MOVEI TAC,DSTBUF-1
	AOS DSTCNT			;COUNT A NEW GENERATION OF STATS.
DRPT4X:	MOVEM TAC,DSTPUT		;SAVE NEW PUTTER
>;END IFN FTDSTT			;DSK STATISTICS

DLOK:	PUSHJ P,DGETL
	TRNN IOS,PHUBIT			;MAYBE WANTS TO IGNORE OFFSET
	SKIPA TAC1,DOFFST(DDB)
	SETZ TAC1,			;IGNORE OFFSET
	ADDI TAC1,1			;INIT USETP POINTER TO OFFSET
	CAMLE TAC,TAC1			;DOFFST INSIDE FILE?
	MOVE TAC,TAC1			;OK, USE DOFFST
	MOVEM TAC,USETP(DDB)

DPOPJ1:	AOS (P)
DPOPJ:	TLZ IOS,GOBIT
	MOVEM IOS,DEVIOS(DDB)
	CONSZ PI,177B27			;ARE WE AT UUO LEVEL?
	POPJ P,				;NO, CAN'T DO ANYTHING HERE!
	PUSH P,AC3
	MOVE J,JOB
	MOVE AC3,JBTLIN(J)
	CAMN AC3,[-1]			;DETACHED?
	JRST DPJRA3
	PUSH P,AC2
	PUSH P,AC1

	MOVSI AC1,DLYBIT
	MOVSI AC2,COMBIT
	OFFSCN				;TURN OFF SCANNER CHANNEL
	TDNN AC1,TTYTAB(AC3)		;SKIP IF COMMAND DELAYED
	JRST DPJRSC			;NO DELAYED COMMAND
	ANDCAM AC1,TTYTAB(AC3)		;TURN OFF DELAY BIT
	TDNE AC2,TTYTAB(AC3)		;ANOTHER COMMAND ALREADY IN?
	JRST DPJRSC			;YES.
	AOS COMCNT			;COUNT ANOTHER TTY NEED SCANNING
	IORM AC2,TTYTAB(AC3)		;TURN ON COMMAND BIT
	SETOM COMFLG			;MAKE SURE WE CALL COMMAND IN CH7
	ONSCN				;TURN ON SCANNER CHANNEL

;;;	PUSHJ P,WSCHED
	PUSHJ P,USRXTS			;SCHEDULE WHEN WE GET BACK TO USRXIT
					;THIS WAY UUO WILL FINISH (IT'S ALREADY
					;CLOBBERED THE LOOKUP BLOCK!!)
DPJRST:	POP P,AC1
	POP P,AC2
DPJRA3:	POP P,AC3
	POPJ P,

DPJRSC:	ONSCN				;TURN ON SCANNER CHANNEL
	JRST DPJRST

GOSET:	TLO IOS,GOBIT
DSIOS:	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

;*** INTERRUPT SUBR ***

;UPDATE THE REFERENCE TIME IN THE FIRST TRACK ONLY AND IN THE UFD ENTRY
LOOKI:	MOVE TAC,SRCLOC(DDB)		;GET RTVL INTO DDB
	MOVEM TAC,FILLOC(DDB)
	PUSHJ P,NEWFIL
	PUSHJ P,GGRETI			;Read RTVL to DDB, first block to SYSBUF
IFN FTLUFD,<
	PUSHJ P,AUDRD			;SET UP FILINx AND FILOFF
>;IFN FTLUFD
	PUSHJ P,AUDCHK
	TLNN IOS,LOSBIG			;RETURN QUICK IF LOST.
	TRNE IOS,DMPBIT			;MAKE IT "TRN" TO NOT UPDATE REFTIM
	POPJ P,
	MOVE TAC,FILPPN(DDB)
	CAMN TAC,SYSPPN
	POPJ P,				;DON'T UPDATE REFTIME OF UFDS
	MOVE TAC1,THSDAT		;USE DATE ONLY FOR REFERENCE TIME
	MOVE TAC,DREFTM(DDB)	;GET LAST DATE REFERENCED
	CAIN TAC1,(TAC)		;ALREADY REF'D TODAY?
	POPJ P,			;YUP
	ADD TAC,[1,,0]		;COUNT ANOTHER DAY REF'D
	HLL TAC1,TAC		;COMBINE INCREMENTED COUNT WITH TODAY'S DATE
	SKIPN TTYLOK		;IN MAINTMODE, DON'T WRITE 
	SKIPE MAINTM
	POPJ P,
Comment $
In the new scheme of pooled system buffers, I hope this works ok.
This update isn't interlocked against other forms of access to this
file.  I think it's probably ok, since there can be no writer, no
renamer of a file that we've established read access to.
$
	MOVEM TAC1,REFTIM(DDB)
	MOVEM TAC1,DREFTM(DDB)
NoStructure,<
	MOVEI	TAC,DSKDAT(DDB)		;Write from DDB
	HRLI	TAC,-SECSIZ		;rewrite only file rtvl
>;NoStructure
IfStructure,<
	MOVN	TAC,DD.SSZ(DDB)		;-size of rtvl area
	HRLZ	TAC,TAC
	HRRI	TAC,DSKDAT(DDB)		;Write from DDB.  Rewrite only RTVL
>;IfStructure
	MOVEM	TAC,TFRIOW(DDB)		;ReWrite only RTVL.
	LDB	TAC1,PUNIT		;UDP?
IFE FTRH,<
	JUMPE	TAC1,LOOKI1		;Jump to rewrite RTVL if main disk
>;IFE FTRH
IFN FTRH,<
	CAMN TAC1,PRSNUM	;Skip unless primary structure
	JRST LOOKI1		;Jump to rewrite RTVL if main disk
>;IFN FTRH
	TRNE	IOS,IOIMPM!IODERR	;Skip if no errors
	POPJ	P,			;Errors on UDP.  Don't rewrite
IFE FTLUFD,<
LOOKI1:	JRST	SREWRIT			;Rewrite RTVL
>;IFE FTLUFD
IFN FTLUFD,<
	PUSHJ	P,SREWRIT			;Rewrite RTVL
	TDZE IOS,[LOSBIG,,IOIMPM!IODERR]	;DON'T REPORT WRITE LOCK.
	POPJ P,					;if write lock, return quick
	JRST LOOKI2

LOOKI1:	PUSHJ P,SREWRIT		;WRITE THE RETRIEVAL BACK OUT
LOOKI2:	SKIPE DAT,DD.SBA(DDB)
	PUSHJ P,RELSBA		;Release system buffer before getting UFD interlock
	MOVE TAC,FILPPN(DDB)	;Write new data in UFD Entry.
	MOVEM TAC,UFDNAM(DDB)	;Argument to UFDREQ
	PUSHJ P,UFDREQ		;Get the UFD interlock
	PUSHJ P,UFDRCL
	 JRST [	POPJ P,		;DIDN'T FIND UFD ENTRY abort ref time update
		'LOOKI2']	;error code for UFDRCL
	MOVE TAC,REFTIM(DDB)	;GET THE REFERENCE TIME
	EXCH TAC,UREFT(TAC1)	;STORE IN UFD ENTRY, GET OLD VALUE
	CAME TAC,UREFT(TAC1)	;HAVE WE WRITTEN IT YET TODAY?
	PUSHJ P,SREWRIT		;NO, WRITE UFD BACK OUT
IFN FTREFBUG,<	
	PUSHJ P,UFDRCL		;Not only do we already have the UFD interlock
	 JRST [	POPJ P,		;DIDN'T FIND UFD ENTRY abort ref time update
		'LOOKI2']	;error code for UFDRCL
	MOVE TAC,REFTIM(DDB)
	CAME TAC,UREFT(TAC1)
	JRST LOOKI4
>;IFN FTREFBUG
	POPJ P,

IFN FTREFBUG,<
LOOKI4:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /REFERENCE TIME WRONG IN UFD ENTRY AT LOOKI
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCAL
	JRST LOOKI2
>;IFN FTREFBUG
>;IFN FTLUFD

IFN FTGRP,<
;**** INTERRUPT SUBR ****
LOOKU:	MOVE TAC,SRCLOC(DDB)
	PUSHJ P,NEWFIL
	PUSHJ P,GGRETD		;Read RTVL to DDB
	SETZM DGRP1R(DDB)	;MAKE SURE GGRETI AT LOOKI DOES A READ
	MOVE TAC,DQINFO+3(DDB)	;DEFAULT PROT/GROUP ACCESS WORD
	MOVEM TAC,UFDPR1(DDB)	;STORE
	POPJ P,
>;IFN FTGRP
;ENTER UUO ;⊗ DENTER DNTMFD DENTX0 DENT1A DENT1 DENT4 DENT2 DENT2A DENT3D DENT3 DENT3A NENUFD WENUFD NENUFD WENUFD DENT0 ENTREN DALTER

DENTER:	JSP AC1,ACCENT			;GET PARAMETERS FROM USER
	SKIPN TAC,ACCNAM(DDB)
	JRST ENOFIL			;BLANK NAME LOSES
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,5		;signature of this event
>;IFN FTUFDB
	CAME TAC,SYSPPN			;DON'T ALLOW ENTER ON MFD
	JRST DNTMFD
	HLRZ TAC,ACCEXT(DDB)
	CAIE TAC,UFDEXT
	JRST DNTMFD
	MOVE TAC,ACCPPN(DDB)
	CAMN TAC,SYSPPN
	JRST EACMFD
DNTMFD:	PUSHJ P,GOSET
	TLNE IOS,READB			;HAS LOOKUP BEEN DONE?
	JRST DALTER			;YES, THIS MUST BE ALTER MODE
	PUSHJ P,SATGET			;MAKE SURE SAT TABLE IS IN (UDP)
	SETZM FILNAM(DDB)		;DISABLE RENAME.
	SETOM SRCTMP(DDB)		;INITIALIZE FLAG
	JSP AC1,ACCESS			;SEE WHO'S LOOKING
	 JRST DENT0			;READ - SAVE DATA
	 JRST EFWRIT			;WRITE - LOSE
	 JFCL				;IGNORE CLOSED ACCESSORS UNTIL OCLOSE
	TLO IOS,IO
	MOVEM IOS,DEVIOS(DDB)		;SET DIRECTION
	SKIPLE SRCTMP(DDB)		;DID ACCESS FIND A READER?
	JRST DENTX0			;YES.  NO NEED TO LOOK ON THE DISK.
	PUSHJ P,FILSRC			;NO.  LOOK ON THE DISK.
	 JRST SRCERR
DENTX0:	JSP AC1,ACCESS			;MAKE SURE NO ONE ELSE IS WRITING
	 JFCL				;READERS DON'T MATTER
	 JRST EFWRIT			;LOSE IF ANOTHER WRITER.
	 JFCL				;IGNORE CLOSED ACCESSORS UNTIL OCLOSE
	PUSHJ P,ACCEST			;ESTABLISH OUR ACCESS - WRITEB (MAYBE
					;  NTRUFD) ARE SET BEFORE BLOCKING
	MOVSI DAT,100000		;CHECK WRITE PROTECTION OF UFD
	JSP AC1,UPROTC
	SKIPG SRCTMP(DDB)		;THIS NAME IN USE?
	JRST DENT1			;NO.  (THIS IS A CREATE)
	MOVSI DAT,100000		;SUPERSEDE. CHECK PROTECTION OF OLD.
	JSP AC1,PROTEC			;WRITE ACCESS REQUIRED.
	LDB AC1,[POINT 9,FILPRO(DDB),8]
	JUMPN AC1,DENT1A		;JUMP IF USER SPECIFIED PROTECTION
	LDB AC1,[POINT 9,SRCPRO(DDB),8]	;USE OLD FILE'S PROT
	DPB AC1,[POINT 9,FILPRO(DDB),8]	;  AS NEW FILE'S PROTECTION
DENT1A:	TLOA IOS,NTRUFD!WRITEB		;NEED TO CHANGE UFD AT CLOSE.
DENT1:	TLOA IOS,WRITEB			;CREATE. PUT IN UFD NOW.
	SKIPA TAC1,SRCEXT(DDB)		;USE OLD CREATION DATE AS DEFAULT
	MOVE TAC1,THSDAT		;USE CURRENT DATE AS DEFAULT
;	LDB TAC,[POINT 15,ACCEXT(DDB),35];BELIEVE ANY CREATE DATE
;	JUMPN TAC,DENT4			;USER TELLS US.
	MOVE TAC,TAC1
	DPB TAC,[POINT 15,ACCEXT(DDB),35]
DENT4:	DPB TAC,[POINT 15,FILEXT(DDB),35]
;Rejoin here from DALTER code.
DENT2:	MOVEM IOS,DEVIOS(DDB)		;Set appropriate access bits
	LDB J,PJOBN			;MAKE SURE J IS RIGHT
	AOS DDBCNT(J)			;COUNT A FILE BEING WRITTEN
	TLNE IOS,ALTERB
	TRNN IOS,RAQBIT
	CAIA
	JRST DENT3			;ALTER MODE AND RAQUICK BIT--CHANGE NOTHING
	TRNE IOS,DMPBIT
	JRST DENT3D			;DON'T INIT TIME IF DUMPER
	SETZM DDMPTM(DDB)		;NEW FILE NEVER DUMPED.
	SETZM DMPTIM(DDB)
	MOVE TAC1,THSDAT		;REFERENCE DATE.
	MOVEM TAC1,REFTIM(DDB)
	MOVEM TAC1,DREFTM(DDB)
IFN FTLUFD,<
	PUSHJ P,EXTTIM			;SET UP DATWRT TO EXTENDED DATE WRITTEN
>;IFN FTLUFD
	PUSHJ P,DSKTM1			;GET DATE AND TIME LAST WRITTEN
	DPB TAC,[POINT 3,ACCEXT(DDB),20];STORE EXTRA BITS
	DPB TAC,[POINT 3,FILEXT(DDB),20]
	MOVSI TAC,777000		;USE SPECIFIED PROTECTION
	AND TAC,FILPRO(DDB)		;GET PROTECTION THUS FAR
	JUMPN TAC,DENT2A		;JUMP IF THERE'S NON-ZERO ALREADY
	TLNE IOS,NTRUFD!ALTERB		;SKIP IF NEW FILE.
	JRST DENT2A			;SUPERSEDE OR ALTER - KEEP 0 PROT
;HERE WE USE UFD'S DEFAULT PROTECTION WORD FOR PROTECTION OF THIS NEW FILE
	MOVSI TAC,777000
	AND TAC,UFDPR1(DDB)		;DEFAULT PROTECTION VALUE FROM UFD
DENT2A:	IOR TAC1,TAC			;MERGE PROT WITH LOW 12 BITS OF DATE WRITTEN
	DPB IOS,[POINT 4,TAC1,12]	;DATA MODE
	MOVEM TAC1,FILPRO(DDB)
	MOVEM TAC1,ACCPRO(DDB)
	MOVSI IOS,IFN FTLUFD,<UFDDIF!>HDRDIF
	IORB IOS,DEVIOS(DDB)		;MAKE SURE DATE GOES OUT EVENTUALLY
	JRST DENT3

DENT3D:	
IFN FTLUFD,<
	PUSHJ P,TIMCNV			;CONVERT USER SPECIFIED TIME TO EXTENDED FMT
>;IFN FTLUFD
DENT3:	TLNE IOS,ALTERB
	JRST ENTREN			;PUT OUT DATE IF ALTER MODE
	LDB TAC1,PUNIT
	PUSHJ P,DSKRES			;TAC←NUMBER OF FREE BLOCKS (CLOBBERS TAC1)
	JUMPLE TAC,ENTFUL		;SOFT STOP WITH 200 BLOCKS LEFT.
					;GIVE NO ROOM MESSAGE. ERROR RETURN
DENT3A:	PUSHJ P,ASNBLK			;Get space for new file (any block OK)
	MOVEM TAC,FILLOC(DDB)
	MOVE TAC,DDLOC(DDB)		;UFD LOCN FOR DIRINS
	MOVEM TAC,SRCLOC(DDB)
	SETZM FILLNG(DDB)		;ZERO LENGTH SO DIRINS CAN WRITE IT
IFE FTLUFD,<
	TLNN IOS,NTRUFD
	PUSHJ P,DIRINS			;NEW FILE TO UFD NOW.
	SETZM DQINFO(DDB)		;INITIALIZE MAGIC FILE INFO
	SETZM DQINFO+1(DDB)
	HLRZ TAC,FILEXT(DDB)
	CAIE TAC,UFDEXT
	JRST NENUFD			;NOT ENTERING A UFD
	MOVE TAC,FILPPN(DDB)
	CAME TAC,SYSPPN
	JRST NENUFD
	SETZM DQINFO+2(DDB)		;CLEAR WORDS WHEN ENTERING A UFD
	SETZM DQINFO+3(DDB)
	JRST WENUFD

NENUFD:	MOVE TAC,JOBNAM(J)		;UPDATE PPN AND JOB OF WRITER
	MOVEM TAC,DQINFO+2(DDB)
	MOVE TAC,PRJPRG(J)
	MOVEM TAC,DQINFO+3(DDB)
WENUFD:	SETZM DOFFST(DDB)		;INIT OFFSET
>;IFE FTLUFD
IFN FTLUFD,<
	SETZM FILIN0(DDB)		;INITIALIZE MAGIC FILE INFO
	SETZM FILIN1(DDB)
	HLRZ TAC,FILEXT(DDB)
	CAIE TAC,UFDEXT
	JRST NENUFD			;NOT ENTERING A UFD
	MOVE TAC,FILPPN(DDB)
	CAME TAC,SYSPPN
	JRST NENUFD
	SETZM FILIN2(DDB)		;CLEAR WORDS WHEN ENTERING A UFD
	SETZM FILIN3(DDB)
	JRST WENUFD

NENUFD:	MOVE TAC,JOBNAM(J)		;UPDATE PPN AND JOB OF WRITER
	MOVEM TAC,FILIN2(DDB)
	MOVE TAC,PRJPRG(J)
	MOVEM TAC,FILIN3(DDB)
WENUFD:	SETZM FILOFF(DDB)		;INIT OFFSET
	TLNN IOS,NTRUFD			;Skip if supersede. Postpone DIRINS to close
	PUSHJ P,DIRINS			;NEW FILE TO UFD NOW.
>;IFN FTLUFD
	PUSHJ P,AUDINF
	MOVE TAC,FILLOC(DDB)
	PUSHJ P,NEWFI1			;SET UP DDLOC AND USETP
	PUSHJ P,ASNGR1			;SET UP DPTR, DNXTGP, DGRP1R (SETS PNTDIF)
	MOVEI DAT,SPREAD
	TLNN IOS,NTRUFD			;IF NEW FILE,
	PUSHJ P,QEWAIT			;PUT RTVL OUT.
	LDB TAC,PUNIT
IFE FTRH,<
	TRNE IOS,IODERR!IOIMPM
	JUMPN TAC,SATGLZ		;WRITE LOCKED UDP
	JRST DRPT			;REPORT DATA TO USER
>;IFE FTRH
IFN FTRH,<
	TRNE IOS,IODERR!IOIMPM
	CAMN TAC,PRSNUM		;Skip if not primary structure
	JRST DRPT		;Report data to user
	JRST SATGLZ		;Write locked UDP
>;IFN FTRH

DENT0:	MOVE TAC1,FILPRO(TAC)		;READER FOUND, SAVE PROTECTION.
	MOVEM TAC1,SRCPRO(DDB)
	MOVE TAC1,FILEXT(TAC)
	HRRM TAC1,SRCEXT(DDB)
	MOVE TAC1,UFDPRO(TAC)
	MOVEM TAC1,UFDPRO(DDB)
	MOVE TAC1,UFDPR1(TAC)
	MOVEM TAC1,UFDPR1(DDB)
IFN FTLUFD,<
	MOVE TAC1,UFDTRK(TAC)
	MOVEM TAC1,UFDTRK(DDB)
	MOVE TAC1,UFDMEM(TAC)
	MOVEM TAC1,UFDMEM(DDB)
	MOVE TAC1,DATWRT(TAC)
	MOVEM TAC1,DATWRT(DDB)
>;IFN FTLUFD
	MOVEI TAC1,1			;SET FLAG: TEM FOUND
	MOVEM TAC1,SRCTMP(DDB)
	JRST ACCES1			;KEEP LOOKING FOR WRITERS

ENTREN:	TRNE IOS,RAQBIT
	JRST DRPT			;RAQUICK, DON'T DO RENAME CODE
	PUSHJ P,FILSRC			;WRITE NEW DATE INTO UFD AND FILE.
	 PUSHJ P,ELOSE			;SHOULDN'T HAPPEN
	PUSHJ P,DRE2			;FINISH RENAME. (COPIES CREATION TO ACCEXT)
	 JFCL
	JRST DRPT			;RETURN LOOKUP INFO

DALTER:	TLNN IOS,DELETB			;FAIL IF FILE MARKED FOR DELETE.
	TLOE IOS,ALTERB
	JRST EFWRIT			;ALREADY ALTERING?
	MOVE TAC,FILNAM(DDB)		;SAME FILE?
	CAME TAC,ACCNAM(DDB)
	JRST EANAME
	HLLZ TAC,FILEXT(DDB)
	HLLZ TAC1,ACCEXT(DDB)
	CAME TAC,TAC1
	JRST EANAME
	MOVE AC2,FILPPN(DDB)
	CAME AC2,ACCPPN(DDB)
	JRST EANAME
	MOVSI DAT,100000
	JSP AC1,UPROTC			;SEE IF UFD ALLOWS THIS ACCESS
	MOVSI DAT,100000		;NEEDS WRITE ACCESS
	MOVE AC3,FILPRO(DDB)
	JSP AC1,PROTEK

;FIRST PASS OF ACCESS VERIFIES THERE ARE NO ACTIVE USERS OF THIS FILE.
;SECOND PASS CLEARS ANYONE WHO HAD CLOSED ACCESS TO THE FILE.
;THIS MUST TAKE 2 PASSES, SINCE IT WOULD BE A BUG TO CLEAR ANY CLOSED ACCESSORS
;IF WE DON'T ACTUALLY GO INTO ALTER MODE.

	MOVEI AC2,0			;COUNT CLOSED ACCESSORS
	JSP AC1,ACCESS			;IS ANYONE USING FILE?
	 JRST EFWRIT			;IF SO, LOSE
	 JRST EFWRIT
	 ADDI AC2,1			;COUNT CLOSED ACCESSORS DURING FIRST PASS
	JUMPE AC2,DENT2			;JUMP IF NO ONE AT ALL IS USING THE FILE
	JSP AC1,ACCESS			;DISABLE RENAME BY ANY CLOSED ACCESSORS
	 JFCL	
	 JFCL
	 SETZM FILNAM(TAC)		;DISABLE RENAME BY CLOSED ACCESSORS
	JRST DENT2

;RENAME UUO ;⊗ DRENAM DRE0 DRE0A DRE0B DRE1 DRNMC DRE2 DRE3D DRE3 DREC1 DREC2 DREC0 DREC99 DRAUFX DRAUFD DRAUFY DRAUFZ UOLDAT UNEWDA REWRIT DRINT DRINT1 DFPOPJ DRINL DRINL2 DR2INT DR2INS SREWRIT

;Labels used from off this page are
;    DRENAM, DRE2, DRAUFY, DRAUFD, REWRIT, SREWRIT

DRENAM:	TDNE IOS,[DEVSBB,,IOACT]
	PUSHJ P,WAIT1				;FINISH CURRENT BUSINESS
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,3		;signature of this event
>;IFN FTUFDB
	SKIPN FILNAM(DDB)
	JRST EXFIL				;LOSE IF NO ACCESSED FILE.
	TLNE IOS,DELETB				;IF FILE TO BE DELETED,
	JRST ENOFIL				;  CAN'T RENAME.
	TLNE IOS,WRITEB!ALTERB			;IF WRITING WE HAVE UNIQUE ACCESS.
	JRST DRE0
	XCTR XR,[MOVE AC2,(UUO)]		;NEW FILE NAME

;TWO PASSES ARE NEEDED - SEE DALTER
;ACTUALLY THIS IS A BUG BECAUSE CLOSED ACCESSORS SHOULDN'T BE FLUSHED
;UNTIL THE RENAME IS SUCCESSFUL

	JSP AC1,ACCESS				;IS ANYONE ELSE RENAMING FILE?
	 JUMPN AC2,EFWRIT			;LOSE UNLESS DELETING
	 JFCL					;CAN'T AFFECT FOREIGN WRITER
	 JFCL					;FIX CLOSED ACCESSORS IN NEXT PASS
	JSP AC1,ACCESS				;FIX ANY CLOSED ACCESSORS
	 JFCL
	 JFCL
	 SETZM FILNAM(TAC)			;DISABLE RENAME BY CLOSED ACCESSORS
DRE0:	PUSHJ P,FILEUP				;FORCE RETRIEVAL SO WE DON'T MUNG IT
	PUSHJ P,GOSET
	TRNE IOS,DMPBIT
	JRST DRE0A				;DON'T INIT TIME IF DUMPER
	MOVE TAC1,THSDAT			;GET REFERENCE DATE
	MOVE TAC,DREFTM(DDB)	;GET LAST DATE REFERENCED
	CAIE TAC1,(TAC)		;ALREADY REF'D TODAY?
	ADD TAC,[1,,0]		;NO, COUNT ANOTHER DAY REF'D
	HLL TAC1,TAC		;COMBINE INCREMENTED COUNT WITH TODAY'S DATE
	MOVEM TAC1,REFTIM(DDB)			;UPDATE REFTIM FOR RANDOM LOSER
DRE0A:	JSP AC1,ACCENT				;JUST US. PICK UP UUO ARGS.
	SKIPN TAC,ACCNAM(DDB)
	JRST DRNMC				;DELETING, CHECK WRITE PROT
	MOVE TAC,ACCPRO(DDB)
	XOR TAC,FILPRO(DDB)			;PROTECTION CHANGE?
	TLNN TAC,777000
	JRST DRE1				;NOT A PROTECTION CHANGE
	MOVE AC2,FILPPN(DDB)
	CAME AC2,SYSPPN
	JRST DRE0B				;NOT ACCESS TO [1,1]
	HLLZ AC2,FILEXT(DDB)			;GET EXTENSION.
	CAME AC2,MFDEXT				;'UFD   '?
	JRST DRE0B				;NO.   SOME RANDOM FILE ON [1,1]
	MOVE AC2,FILNAM(DDB)			;UFD ACCESS.  TO MFD?
	CAMN AC2,SYSPPN
	JRST EPROT				;CHANGE PROT OF MFD NOT ALLOWED
	MOVE AC1,JBTPRV(J)
	TLNN AC1,PROPRV				;PRIVILEGED?
	CAMN AC2,PRJPRG(J)			;NO. BUT ACCESS TO OWN UFD OK
	JRST DRE1
	JRST EPROT

DRE0B:	MOVSI DAT,400000
	JSP AC1,UPROTK				;LEGAL TO CHANGE IN THIS UFD?
	MOVSI DAT,400000
	MOVE AC3,FILPRO(DDB)
	JSP AC1,PROTEK				;LEGAL TO CHANGE THIS FILE?

DRE1:	MOVE TAC,FILNAM(DDB)
	CAME TAC,ACCNAM(DDB)
	JRST DRNMC				;NAME CHANGE.
	HLLZ TAC1,FILEXT(DDB)
	XOR TAC1,ACCEXT(DDB)
	TLNE TAC1,777777			;EXT CHANGE?
	JRST DRNMC
	MOVE TAC1,FILPPN(DDB)
	CAME TAC1,ACCPPN(DDB)			;NEW PROJ.-PROG?
	JRST DRNMC				;YES, NEW PPN
	TLNE IOS,NTRUFD				;SUPERSEDING? (CAN'T BE A UFD)
	JRST DRE2				;YES.  HAVE UFD RTVL FROM CLOSE.
	PUSH P,USETP(DDB)
	PUSHJ P,FILSRC				;LITTLE OR NO CHANGE. GET RTVL IN.
	 JRST [	POP P,USETP(DDB)
		PUSHJ P,ELOSE			;SHOULDN'T HAPPEN
 		JRST DRE2   ]
	POP P,USETP(DDB)
	JRST DRE2

DRNMC:	MOVSI DAT,100000			;NAME CHANGE REQUIRES WRITE ACCESS
	MOVE AC2,FILPPN(DDB)
	JSP AC1,UPROTK				;UFD ALLOWS WRITE ACCESS?
	MOVSI DAT,100000
	MOVE AC3,FILPRO(DDB)
	JSP AC1,PROTEK				;FILE ALLOWS WRITE ACCESS?
	JUMPE TAC,DRDEL				;0 = DELETE.
	MOVE AC1,FILPPN(DDB)
	CAMN AC1,SYSPPN				;DON'T ALLOW NAME CHANGE ON [1,1]
	JRST EPROT				;(EXCEPT FOR DELETE)
	JSP AC1,ACCESS				;NEW NAME, SEE IF IN USE.
	 JRST EDNAME				;LOSE.
	 JRST EDNAME				;LOSE.
	 JRST EDNAME				;EVEN CLOSED ACCESS MEANS WE LOSE.
	TLO IOS,RENAMB				;ESTABLISH UNIQUE ACCESS NOW!
	MOVEM IOS,DEVIOS(DDB)
	PUSH P,UFDPRO(DDB)			;THIS GETS CLOBBERED BY FILSRC
	PUSH P,UFDPR1(DDB)
	PUSH P,USETP(DDB)
	PUSHJ P,FILSRC				;SEE IF IN DIRECTORY.
	 JRST [	POP P,USETP(DDB)
		POP P,UFDPR1(DDB)
		POP P,UFDPRO(DDB)
		JRST SRCERR  ]			;BAD RETR OR NO UFD
	POP P,USETP(DDB)
	TLZ IOS,RENAMB				;IN CASE OF ACCIDENT, RELEASE ACCESS
	MOVE AC2,UFDPR1(DDB)			;SAVE DEF PROT/GRP ACCESS OF DEST UFD
	MOVE AC3,UFDPRO(DDB)			;GET PROT OF DESTINATION UFD IN AC3
	POP P,UFDPR1(DDB)
	POP P,UFDPRO(DDB)
	SKIPLE TAC,SRCTMP(DDB)			;DOES FILE NAME EXIST?
	JRST EDNAME				;FILE NAME IS IN USE. (STORES IOS)
	TRNN IOS,DMPBIT
	SETZM DMPTIM(DDB)			;CLEAR DUMP DATE, UNLESS DUMPER

;HERE FROM ALTER (ENTREN) TO WRITE OUT DATE CHANGES
DRE2:	TLO IOS,RENAMB				;KEEP HACKERS OUT WHILE...
	MOVEM IOS,DEVIOS(DDB)			;CHANGING THINGS.
	MOVE TAC,FILEXT(DDB)			;COPY CREATION DATE FROM RETRIEVAL
	DPB TAC,[POINT 15,ACCEXT(DDB),35]	;INTO USER'S VARIABLES
IFN FTLUFD,<
	TLNE IOS,ALTERB
	JRST DRE3				;AVOID CLOBBERING DATWRT
>;IFN FTLUFD
	MOVE TAC,ACCEXT(DDB)
	TRNE TAC,700000				;CHECK THIS PART OF DATE
	JRST DRE3D				;USER IS SPECIFYING DATE & TIME
	MOVE TAC,ACCPRO(DDB)
	TDNE TAC,[777,,777777]			;ANY DATE AND TIME? OR MODE?
	JRST DRE3D				;YES, USE IT
	MOVE TAC,FILPRO(DDB)			;NO, USE THOSE FROM RETRIEVAL
	TLZ TAC,777000				;CLEAR PROT.
	IORM TAC,ACCPRO(DDB)
	LDB TAC,[POINT 3,FILEXT(DDB),20]
	DPB TAC,[POINT 3,ACCEXT(DDB),20]
	JRST DRE3

DRE3D:
IFN FTLUFD,<
	MOVE TAC,ACCEXT(DDB)			;USER HAS SPECIFIED DATE OR TIME,
	XOR TAC,FILEXT(DDB)			;SO WE MUST CONVERT TO EXTENDED
	MOVE TAC1,ACCPRO(DDB)			;FORMAT, UNLESS USER-SPECIFIED
	XOR TAC1,FILPRO(DDB)			;DATE/TIME IS EQUAL TO THE OLD ONE,
	TRNN TAC,700000				;IN WHICH CASE THIS KLUDGE AVOIDS
	TDNE TAC1,[37,,777777]			;SCREWING UP THE DAYLITE SAVING BIT.
	PUSHJ P,TIMCNV				;CONVERT USER SPEC TIME FOR DATWRT
>;IFN FTLUFD
DRE3:	MOVE TAC,DDLOC(DDB)			;POINTS TO DESTINATION UFD ALWAYS
	MOVEM TAC,SRCLOC(DDB)			;TELL DIRSRC WHERE TO LOOK.
	MOVE TAC,ACCPPN(DDB)			;COMPARE PPN
	CAMN TAC,FILPPN(DDB)
	JRST DREC1				;SAME PPN, CHANGE 1 UFD
	MOVSI DAT,100000			;REQUIRES WRITE ACCESS TO OTHER UFD
	EXCH AC2,UFDPR1(DDB)			;PUT DEST UFD'S UFDPR1 BACK
	MOVE TAC,AC2				;SAVE SOURCE UFDPR1 IN TAC
	MOVE AC2,ACCPPN(DDB)			;GET PPN OF DESTINATION. AC3 SETUP
	JSP AC1,PROT0				;SEE IF ACCESS ALLOWED.
	MOVEM TAC,UFDPR1(DDB)			;RESTORE UFDPR1
	TLNE IOS,NTRUFD				;SUPERSEDE?
	JRST DREC2				;Yes. No old UFD entry exists yet
	PUSH P,USETP(DDB)			;Change 2 UFDs.
	PUSHJ P,DIRINS				;Insert in new
	MOVEI TEM,FILNAM(DDB)
	PUSHJ P,SRCH1				;Now, find old UFD
	 JRST [	PUSHJ P,ELOSE			;not there or bad RTVL
		JRST DREC99 ]
	MOVEI DAT,DR2INT			;and remove the old entry
	JRST DREC0

DREC1:	MOVEI DAT,DRINT				;Rename same ppn. Change 1 UFD
	TLNE IOS,NTRUFD				;Skip unless supersede.
DREC2:	MOVEI DAT,DRINT1			;Supersede: no old UFD entry
	PUSH P,USETP(DDB)			;Preserve USETP
DREC0:	PUSHJ P,NEWAIT				;Don't lock incore for this
DREC99:	POP P,USETP(DDB)
	TLZ IOS,RENAMB
	LDB TAC,PUNIT
IFE FTRH,<
	TRNE IOS,IODERR!IOIMPM			;WRITE ERROR?
	JUMPN TAC,SATGLZ			;LOSE. WRITE LOCKED UDP
	JRST DPOPJ1				;RETURN TO USER
>;IFE FTRH
IFN FTRH,<
	TRNE IOS,IODERR!IOIMPM
	CAMN TAC,PRSNUM		;Skip if not primary structure
	JRST DPOPJ1		;Return to user
	JRST SATGLZ		;Write locked UDP
>;IFN FTRH

;***INTERRUPT LEVEL SUBRS***

DRAUFX:	AOSE DRAUFO(DDB)			;IS CALLER ENABLED FOR ERROR?
	POPJ P,					;YES.  RETURN IT TO HIM.
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /ERROR IN DSKSER AT DRAUFD - FILE NOT FOUND IN UFD: /
	MOVEI TAC,FILNAM(DDB)
	PUSHJ P,DISFIL
	PUSHJ P,DISMES
	 ASCIZ /;  NEW NAME = /
	MOVEI TAC,ACCNAM(DDB)
	PUSHJ P,DISFIL
	PUSHJ P,DISCRLF
	DEBCHECK(POPACS)			;CALL DDT IF DEBUGGING
	POPJ P,

;ENTER AT DRAUFY WITH DRAUFO(DDB) ZERO TO ALLOW ERROR RETURN (OUTPUT CLOSE)
DRAUFD:	SETOM DRAUFO(DDB)			;FLAG ERROR IS ILLEGAL
DRAUFY:	SKIPN TAC,FILNAM(DDB)			;FIND ENTRY FOR OLD NAME
	JRST DRAUFX				;NULL NAME? RETURN NO FILE FOUND.
	MOVEM TAC,SRCNAM(DDB)			;(UFD WAS FOUND BY FILSRC)
	MOVE TAC,FILPPN(DDB)
	MOVEM TAC,UFDNAM(DDB)			;Argument to UFDREQ
	PUSHJ P,UFDREQ				;Lock this UFD
	MOVE TAC,FILEXT(DDB)
	HLLZM TAC,SRCEXT(DDB)
	PUSHJ P,DIRSRC				;FIND UFD ENTRY
	SKIPG SRCTMP(DDB)
	JRST DRAUFX				;NO OLD FILE FOUND!
	MOVE TAC,ACCNAM(DDB)			;CHANGE IT
	MOVEM TAC,UNAM(TAC1)			;(ALSO USED FOR DELETE)
repeat 0,<
;JJW 8/85 turned off this fix; DRDEL now SOSes DDBCNT, and KILL command
;shouldn't be allowed to interrupt with GOBIT set.  If it does, this change
;isn't sufficient.

;Avoid timing race, turn off WRITEB now if deleting, lest KILL cmd interrupt soon.
;(Maybe need to worry about ALTERB too, but make sure DRELES still works.)
	JUMPN TAC,DRAUFZ		;jump unless deleting file
	TLZE IOS,WRITEB			;not writing file any more
	SOS DDBCNT(J)			;one less DDB open for writing
DRAUFZ:
>;repeat 0
	MOVE TAC,ACCEXT(DDB)
	HLLM TAC,UEXT(TAC1)
	MOVE TAC,UEXT(TAC1)			;NOW COPY CREATION DATE BACK
	DPB TAC,[POINT 15,ACCEXT(DDB),35]	;RPH/DATE75
	LDB TEM,[POINT 3,ACCEXT(DDB),20]	;GET DATE
	MOVE TAC,ACCPRO(DDB)			;AND TIME
	TDNN TAC,[777,,777777]			;DID HE SPECIFY ANY?
	JUMPE TEM,UOLDAT			;CHECK IT ALL
	JRST UNEWDA				;USER SPECIFYING DATE AND TIME

UOLDAT:	LDB TEM,[POINT 3,FILEXT(DDB),20]	;COPY 3 EXTRA BITS
	DPB TEM,[POINT 3,ACCEXT(DDB),20]
	MOVE TAC,FILPRO(DDB)			;NOW REST OF DATE AND TIME
	DPB TAC,[POINT 23,ACCPRO(DDB),35]
	MOVE TAC,ACCPRO(DDB)
UNEWDA:	DPB TEM,[POINT 3,UEXT(TAC1),20]		;STORE BITS IN UFD ENTRY
	MOVEM TAC,UPRO(TAC1)			;AND THE REST TOO
	MOVE TAC,FILLOC(DDB)			;NEW FILE LOCATION.
	EXCH TAC,ULOC(TAC1)			;OLD ONE USED BY CLOSE OUTPUT.
	MOVEM TAC,SRCLOC(DDB)
IFE FTLUFD,<	
	JRST SREWRIT
>;IFE FTLUFD
IFN FTLUFD,<
	TLNN IOS,ALTERB
	JRST UFDNEW				;STORE REST OF UFD, CLEAR UFDDIF
	MOVE TAC,JOBNAM(J)			;MAKE SURE FILE INFO IS CORRECT
	MOVEM TAC,FILIN2(DDB)			;IN ALTER MODE
	MOVE TAC,PRJPRG(J)
	MOVEM TAC,FILIN3(DDB)
	JRST UFDNEW
>;IFN FTLUFD

REWRIT:	MOVEI TAC,DWRITE			;START A WRITE TRANSFER
	MOVSM TAC,TFRCTL(DDB)
	JRST TSTART				;WRITE IT BACK OUT.

DRINT:	PUSHJ P,DRAUFD				;CHANGE FILXXX ENTRY TO ACCXXX
DRINT1:	MOVE TAC,FILNAM(DDB)			;SETUP SRCNAM IN CASE DRAUFD WASN'T
	MOVEM TAC,SRCNAM(DDB)			;   CALLED.
	MOVE TAC,FILEXT(DDB)
	HLLZM TAC,SRCEXT(DDB)
	PUSHJ P,ACCST1				;UPDATE NAME.
	DPB TAC,[POINT 15,FILEXT(DDB),35]	;RESTORE CREATION TIME. REG 11/29/74
	MOVE TAC,FILLOC(DDB)			;PREPARE TO SPREAD IT
	PUSHJ P,NEWFIL
	MOVE TAC,FILPPN(DDB)
	CAME TAC,SYSPPN
	JRST DRINL
	SKIPE DD.SBA(DDB)		;Skip unless we have no system buffer
	PUSHJ P,RELSBA			;Release our system buffer before UFD lock
	MOVE TAC,FILNAM(DDB)		;TRYING TO SPREAD NEW RTVL IN A UFD.
	MOVEM TAC,UFDNAM(DDB)		;SET UP FOR UFDREQ
	PUSHJ P,UFDREQ			;GET UNIQUE ACCESS TO UFD & Wait if needed
					;(Next POPJ releases the UFD lock)
	SETZM DGRP1R(DDB)		;MAKE SURE WE READ
	PUSHJ P,GGRETD			;GET GOOD RTVL TO DDB
	PUSHJ P,AUDINF			;BLT IN THE NEW STUFF
	PUSHJ P,SPREAD			;AND WRITE IT BACK OUT
DFPOPJ:
IFN FTDOPS,<
	TLZ IOS,HDRDIF!PNTDIF		;WE'VE DONE ENOUGH SPREADING
>;IFN FTDOPS
	POPJ P,

;Spread new name, etc. 
DRINL:	PUSHJ P,GGRETD			;WRITE NEW NAME OVER FILE
	TLNN IOS,ALTERB			;ARE WE ENTERING R-A MODE,
	JRST DRINL2			;No.
IFE FTLUFD,<
	MOVE TAC,JOBNAM(J)		;Alter mode: UPDATE JOB AND PPN OF CULPRIT
	MOVEM TAC,DQINFO+2(DDB)
	MOVE TAC,PRJPRG(J)
	MOVEM TAC,DQINFO+3(DDB)
>;IFE FTLUFD
IFN FTLUFD,<
	MOVE TAC,JOBNAM(J)		;Alter mode: UPDATE JOB AND PPN OF CULPRIT
	MOVEM TAC,FILIN2(DDB)
	MOVE TAC,PRJPRG(J)
	MOVEM TAC,FILIN3(DDB)
>;IFN FTLUFD
DRINL2:	PUSHJ P,AUDINF			;COPY NEW INFO IN RETRIEVAL AREA
	PUSHJ P,SPREAD
	SKIPN DNXTGP(DDB)
	JRST DFPOPJ			;END FILE, RETURN
NoStructure,<
	MOVEI TAC,RCPGRP
>;NoStructure
IfStructure,<
	MOVE TAC,DD.RPG(DDB)		;number of R per G
>;IfStructure
	ADDM TAC,USETP(DDB)
	JRST DRINL

;ISUBR to delete the file's entry in the UFD out from which it is being renamed.
;A new entry (in the new UFD) has already been inserted.
DR2INT:	PUSHJ	P,DR2INS		;Call subr due to co-return from UFDREQ
	JRST	DRINT1			;SPREAD RETRIEVAL

DR2INS:	MOVE TAC1,FILPPN(DDB)		;This is a subroutine only to let the UFD
	MOVEM TAC1,UFDNAM(DDB)		; interlock be released before doing DRINT1
	PUSHJ P,UFDREQ			;Obtain interlocked access to old UFD
	SETOM DRAUFO(DDB)		;ERROR IN DSKSER IF CAN'T FIND OLD
	PUSHJ P,DIRSRC			;FIND ENTRY IN OLD UFD
	SKIPG SRCTMP(DDB)		;IS IT REALLY THERE?
	JRST DRAUFX			;NO, LOSE LOSE
	SETZM UNAM(TAC1)		;DELETE ENTRY IN UFD
	SETZM UEXT(TAC1)		;fall into rewrite the ufd
SREWRIT:MOVEI TAC,DWRITE		;Start a SYSBUF Write transfer
	MOVSM TAC,TFRCTL(DDB)
	JRST STSTART			;WRITE IT BACK OUT.
;FILE ACCESS CONTROL ;⊗ ACCENT ACCESS ACCES1 ACCEST ACCST1 PROTEC PROTEK PROT0 PROT01 PROT6 PROT1 PROT2 PROT3 PROT4 PROT5 UPROTC UPROTK

;COPY USER'S PARAMETERS TO ACCXXX(DDB)
ACCENT:	MOVE J,JOB
	XCTR XR,[MOVE TAC,UNAM(UUO)]	;NAME
	MOVEM TAC,ACCNAM(DDB)
	XCTR XR,[MOVE TAC,UEXT(UUO)]	;EXT
	MOVEM TAC,ACCEXT(DDB)
	XCTR XR,[MOVE TAC,UPRO(UUO)]	;PROT
	MOVEM TAC,ACCPRO(DDB)
	XCTR XR,[SKIPN TAC,UPPN(UUO)]	;PPN
	SKIPE TAC,DSKPPN(J)		;PICK UP DISK ALIAS PPN IF ANY
	CAIA
	MOVE TAC,PRJPRG(J)		;USE USER'S PPN IF BLANK
	TLNE DDB,SYSDEV			;SYS?
	MOVE TAC,CUSPPN			;YES, USE CUSP PPN
	MOVEM TAC,ACCPPN(DDB)
	TRNN IOS,DMPBIT
	JRST (AC1)
	XCTR XR,[MOVE TAC,4(UUO)]
	MOVEM TAC,REFTIM(DDB)
	XCTR XR,[MOVE TAC,5(UUO)]
	MOVEM TAC,DMPTIM(DDB)
	JRST (AC1)

;JJW note - ACCESS needs to consider the case of other DDBs renaming a file
;to the one being scanned.

;ACCESS CONTROL.  FOR EACH DDB WHOSE FILXXX MATCHES OUR ACCXXX
;EXECUTE 0(AC1) FOR READERS, 1(AC1) FOR WRITERS, 2(AC1) FOR CLOSED DDBS

ACCESS:
NoStructure,<
	LDB TAC,PUNIT
	MOVE TAC,DKDBML(TAC)		;FIRST DDB IS DUMMY
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	MOVE TAC,ST.MDB(TAC)		;FIRST DDB IS DUMMY
>;IfStructure
	HLLZ DAT,ACCEXT(DDB)		;IN CASE RH NOT 0.
ACCES1:	HLRZ TAC,DEVSER(TAC)		;GET NEXT DDB
	MOVE TAC1,DEVNAM(TAC)		;GET DEVICE NAME
	CAME TAC1,DEVNAM(DDB)		;IS IT SAME AS US
	JRST 3(AC1)			;NO, ALL DONE, RETURN
	CAIN TAC,(DDB)			;DON'T LOOK AT OWN DDB
	JRST ACCES1
	MOVE TAC1,FILNAM(TAC)		;COMPARE NAME
	CAME TAC1,ACCNAM(DDB)
	JRST ACCES1
	HLLZ TAC1,FILEXT(TAC)
	CAME TAC1,DAT
	JRST ACCES1
	MOVE TAC1,FILPPN(TAC)
	CAME TAC1,ACCPPN(DDB)
	JRST ACCES1
	MOVE TAC1,DEVIOS(TAC)		;FOUND ONE, SEE WHAT IT'S DOING
	TLNE TAC1,DELETB
	JRST ACCES1			;IGNORE IF TO BE DELETED.
	TLNE TAC1,ALTERB!RENAMB		;ALTERING?
	JRST EFWRIT			;YES, LOSE
	TLNE TAC1,READB			;READING?
	XCT 0(AC1)			;YES
	TLNE TAC1,WRITEB		;WRITING?
	XCT 1(AC1)			;YES
	TLNN TAC1,READB!WRITEB		;EITHER READING OR WRITING?
	XCT 2(AC1)			;NO.  MUST BE A CLOSED DDB.
	JRST ACCES1			;OK, LOOK FOR MORE.


;ESTABLISH OUR ACCESS TO A FILE.  SET BITS IN DEVIOS(DDB).
;COPY ACCXXX TO FILXXX
ACCEST:	MOVEM IOS,DEVIOS(DDB)		;ACCESS ESTABLISHED
ACCST1:	MOVE TAC1,ACCNAM(DDB)
	MOVEM TAC1,FILNAM(DDB)
	MOVE TAC1,ACCEXT(DDB)
	MOVEM TAC1,FILEXT(DDB)
	MOVE TAC1,ACCPRO(DDB)
	MOVEM TAC1,FILPRO(DDB)
	MOVE TAC1,ACCPPN(DDB)
	MOVEM TAC1,FILPPN(DDB)
	POPJ P,

PROTEC:	MOVE AC2,ACCPPN(DDB)
	MOVE AC3,SRCPRO(DDB)
PROTEK:	CAMN AC2,SYSPPN			;ACCESS TO A UFD?
	JRST PROT3			;YES.
PROT0:	CAME AC2,DSKPPN(J)		;SAME AS ALIAS PPN?
	 JRST PROT01
	MOVSI TAC1,AAOPRV		;THE "ALIAS AS OWNER" PRIVILEGE
	TDNE TAC1,JB2PRV(J)		;DOES S/HE HAVE IT?
	 JRST PROT1			;YES, GIVE OWNER ACCESS
PROT01:
IFN FTGRP,<
	LDB TAC1,[POINT 26,UFDPR1(DDB),35]	;GET GROUP ACCESS BITS
	AND TAC1,JB2PRV(J)		;DOES ACCESSOR HAVE CORRESP GRP ACC PRV?
	JUMPE TAC1,PROT6		;NO MATCH, TREAT AS USUAL
	CAIE TAC1,MASPRV
	JRST PROT1			;MATCH OTHER THAN MAS, GIVE HIM OWNER ACCESS
	MOVE TAC1,AC2			;UFD BEING ACCESSED
	XOR TAC1,PRJPRG(J)		;ACCESSOR
	TRNN TAC1,-1
	JRST PROT1			;SAME PROGRAMMER AND MAS SO GIVE OWNER ACC
PROT6:
>;IFN FTGRP
	CAMN AC2,PRJPRG(J)		;OWNER ACCESS TO FILE?
	JRST PROT1			;YES.  DO OWNER ACCESS TESTS
	LSH AC3,3			;NOT OWNER. SHIFT TO LOCAL-USER BITS
	MOVE TAC1,JB2PRV(J)		;PASSIVE PRIVS
	TLNN TAC1,LUPPRV		;LOCAL USER?
	LSH AC3,3			;NO. SHIFT TO REMOTE-USER FIELD
	MOVE TAC1,JBTPRV(J)		;
	LSH TAC1,2			;SHIFT PRIVILEGE BITS TO CHECK PRIV ACCESS
	TDNE TAC1,DAT			;IS ACCESS ALLOWED BY PRIVILEGE?
	JRST (AC1)			;YES. PRIV. ACCESS TO FILE
	JRST PROT2			;CHECK NON-OWNER ACCESS

PROT1:	TLZ DAT,600000			;OWNER CAN READ OR RENAME
PROT2:	TDNN DAT,AC3
	JRST (AC1)			;OK
	JRST EPROT			;LOSE

PROT3:	TLNE DAT,500000			;WRITE OR RENAME ACCESS TO UFD?
	JRST PROT4			;YES. THIS IS USUALLY ILLEGAL
	MOVE AC2,ACCNAM(DDB)		;USE THE NAME INSTEAD OF PPN FOR LEGALITY
	JRST PROT0			;OTHERWISE, CONSIDER OTHER CLASS OF USERS

PROT4:	JUMPGE DAT,PROT5		;JUMP UNLESS 400000 ACCESS REQUESTED
	MOVE TAC1,FILNAM(DDB)		;GET NAME OF THIS UFD
	CAMN TAC1,PRJPRG(J)		;BELONGS TO US?
	JRST (AC1)			;YES.  PROTECTION CHANGE IS OK.
PROT5:	MOVE TAC1,JBTPRV(J)		;WRITE OR RENAME ACCESS TO UFD
	LSH TAC1,2
	TDNN TAC1,DAT
	JRST EPROT
	JUMPL DAT,(AC1)			;LEGAL FOR PRIV' USER TO CHANGE PROT
	SKIPN ACCNAM(DDB)		;WRITE IS LEGAL ONLY IF DELETING
	JRST (AC1)
	JRST EPROT

;HERE TO CHECK ACCESS TO A UFD
UPROTC:	MOVE AC2,ACCPPN(DDB)
UPROTK:	SKIPN AC3,UFDPRO(DDB)
	JRST (AC1)			;AVOID WORK IF THIS IS A UFD ACCESS
IFE FTGRP,<
	JRST PROT0
>;IFE FTGRP
IFN FTGRP,<
	CAME AC2,SYSPPN			;IF CHECKING ACCESS TO A UFD, I.E. IF THE
	JRST PROT0			;FILE'S UFD IS 1,1 THEN FORGET ABOUT GROUP
	JRST PROT6			;ACCESS TO MFD.
>;IFN FTGRP

;SEARCH MFD AND UFD FOR FILE. ;⊗ FILSRC UFDSRC SRCH SRCH1 SRCHM CUSSRC SRCHM1 SRCHM2 SRCHM3 SRCHU
;PUT DIRECTORY DATA IN SRCNAM,SRCEXT,SRCPRO,SRCLOC.
;FLAG IS LEFT IN SRCTMP.

; MFD, UFD FORMAT:
;	NAME
;	EXT, DATE CREATED
;	PROT, MODE, TIME LAST WRITTEN
;	LOCATION (LOGICAL BLOCK NO.)
;IFN FTLUFD,<
;	FILE LENGTH IN WORDS (FOR UFDS ONLY, 0 IN MFD)
;>;IFN FTLUFD
;
;CALLING
;	SETUP ACCNAM, ETC. WITH FILE NAME
;	PUSHJ P,FILSRC
;	<HERE IF LOSING>		;NO SUCH UFD, OR BAD RETR.
;	<HERE WHEN OP FINISHED, SRCTMP .GT. 0 MEANS FILE EXISTS>
;
;CALLING
;	SET UP ACCNAM...
;	PUSHJ P,UFDSRC
;	<SRCH FAILED, NO SUCH UFD OR BAD RETR>
;	<HERE IF UFD WAS FOUND>
;

FILSRC:	PUSHJ P,SRCH
	 POPJ P,			;RETURN IF LOSING SOMEHOW
	SKIPE DAT			;WANT MFD?
	PUSHJ P,QEWAIT			;NO, READ DIRECTORY
	TLNN IOS,LOSBIG			;LOSING?
	AOS (P)				;WINING.
	POPJ P,

UFDSRC:	PUSHJ P,SRCH
	 POPJ P,			;DIRECT RETURN IF LOSING (NO UFD, ETC)
	JUMPN DAT,CPOPJ1		;RETURN OK.
	JRST EACMFD			;ILLEG MFD OP.

SRCH:	MOVEI TEM,ACCNAM(DDB)
SRCH1:					;HERE FROM DRE3 WITH TEM SETUP
NoStructure,<
	MOVE DAT,MFDLOC			;Get disk address of MFD
>;NoStructure
IfStructure,<
	MOVE DAT,SDBPTR(DDB)		;Address of the SDB
	MOVE DAT,ST.MFA(DAT)		;Get disk address of the MFD
>;IfStructure
	MOVEM DAT,SRCLOC(DDB)		;ASSUME MFD
	MOVE TAC,UPPN(TEM)
	MOVSI TAC1,UFDEXT
	HLLZ AC3,UEXT(TEM)
	CAME TAC,SYSPPN			;LOOKING FOR [1,1] FILE?
	JRST SRCHM			;No, Look in MFD for UFD
	CAMN TAC1,AC3			;Yes, it is a [1,1] file, is it a UFD?
	CAME TAC,UNAM(TEM)		;Yes, it is a UFD. Is it the MFD?
	JRST SRCHU			;No, search MFD for it
	MOVEM DAT,SRCTMP(DDB)		;Yes.  We know where the MFD is.
	MOVE DAT,MFDEXT			;PLUG IN MFD STUFF
	MOVEM DAT,SRCEXT(DDB)
	MOVE DAT,MFDPRO
	MOVEM DAT,SRCPRO(DDB)
	MOVEM DAT,UFDPRO(DDB)		;DEFINE ACCESS ALLOWED TO MFD
	MOVEI DAT,0			;MFD FLAG
	JRST CPOPJ1

;Search MFD for UFD
SRCHM:	MOVEM TAC,SRCNAM(DDB)		;STORE PPN AS NAME TO SEARCH FOR
	MOVEM TAC1,SRCEXT(DDB)		;STORE 'UFD' AS EXTENSION TO SEARCH FOR
	CAMN TAC,UFDPPN(DDB)		;Is pointer to the right UFD in the DDB?
	SKIPN TAC1,UFDADR(DDB)		;If so, Just gobble it.
	JRST .+2
	JRST CUSSRC
	LDB TAC1,PUNIT
IFE FTRH,<
	JUMPN TAC1,SRCHM1		;CUSLOC and JBTUFD invalid for UDP
>;IFE FTRH
IFN FTRH,<
	CAME TAC1,PRSNUM	;see if this is primary structure's unit number
	JRST SRCHM1		;CUSLOC and JBTUFD are only for main disk
>;IFN FTRH
	CAMN TAC,CUSPPN			;IS THIS THE BLOODY CUSP?
	SKIPN TAC1,CUSLOC		;YES, DO WE REMEMBER WHERE IT IS?
	CAIA				;NO TO ONE OF THESE
	JRST CUSSRC			;YES, GO SEARCH IT
	SKIPG JOB
	JRST SRCHM1			;FOR JOB 0, IGNORE JBTUFD
	SKIPN TAC1,DSKPPN(J)
	MOVE TAC1,PRJPRG(J)
	CAMN TAC,TAC1			;HIS OWN UFD?
	SKIPN TAC1,JBTUFD(J)		;DO WE KNOW WHERE IT IS?
	JRST SRCHM1			;NO. LOOK IN MFD FOR ITS LOC.
CUSSRC:	MOVEM TAC1,SRCLOC(DDB)		;TRY HERE.
	JRST SRCHU			;GO GET UFD (BYPASS MFD SEARCH)

SRCHM1:	MOVEI DAT,DIRSRC		;LOOK IN MFD FOR USER'S UFD
	PUSHJ P,QEWAIT
	TLNN IOS,LOSBIG
	SKIPG SRCTMP(DDB)		;FOUND IT?
	POPJ P,				;NO, LOSE
	SKIPG JOB
	JRST SRCHU			;FOR JOB ZERO, STORE NOTHING
	MOVE TAC1,SRCLOC(DDB)		;SAVE MOST RECENT UFD ADDR IN DDB
	LDB TAC,PUNIT
IFE FTRH,<
	JUMPN TAC,SRCHM2		;Jump if UDP. CUSLOC & JBTUFD meaningless
>;IFE FTRH
IFN FTRH,<
	CAME TAC,PRSNUM		;see if this is primary structure's unit number
	JRST SRCHM2		;CUSLOC and JBTUFD are only for main disk
>;IFN FTRH
	CAME TAC1,JBTUFD(J)
	CAMN TAC1,CUSLOC
	JRST SRCHM3
SRCHM2:	MOVE TAC,SRCNAM(DDB)		;save this UFD name & address
	MOVEM TAC,UFDPPN(DDB)		;on speculation that we'll use it later
	MOVEM TAC1,UFDADR(DDB)
SRCHM3:	LDB TAC,PUNIT
IFE FTRH,<
	JUMPN TAC,SRCHU			;IF UDP, DON'T SAVE address IN JBTUFD
>;IFE FTRH
IFN FTRH,<
	CAME TAC,PRSNUM		;see if this is primary structure's unit number
	JRST SRCHU		;CUSLOC and JBTUFD are only for main disk
>;IFN FTRH
	MOVE TAC,SRCNAM(DDB)		;DID WE JUST LOOK AT GUY'S OWN UFD?
	SKIPN DAT,DSKPPN(J)
	MOVE DAT,PRJPRG(J)
	CAMN TAC,DAT	
	MOVEM TAC1,JBTUFD(J)		;main disk & current ppn.  save it.
	CAMN TAC,CUSPPN
	MOVEM TAC1,CUSLOC		;main disk & cusp ppn
SRCHU:	HLLZ TAC1,UEXT(TEM)		;Search current directory for a file
	MOVEM TAC1,SRCEXT(DDB)
	MOVE TAC,UNAM(TEM)		;LOOK IN UFD FOR FILE
	MOVEM TAC,SRCNAM(DDB)
	MOVEI DAT,DIRSRC
	JRST CPOPJ1
;⊗ DIRINS DIRINX DIRI1 DIRI1W DIRI2 DIRI4 DIRIHF

;Insert a file name in UFD.  Use ACCNAM, ACCEXT, ACCPRO, FILLOC for new entry.
;UFD disk address must be in SRCLOC (for call to DIRSRC).
;UFD name must be in DDNAM(DDB) which is what DIRI1 uses for the call to
;UFDREQ.  The rest of the retrieval can be stale since DIRI1 will
;call DIRSRC which will get fresh retrieval.
;
DIRINS:	SETOM SRCTMP(DDB)		;"CLEAR" FLAG
	MOVEI DAT,DIRI1			;TRY TO PUT NEW NAME IN
	PUSHJ P,QEWAIT			;Without adding a block to the UFD
	SKIPGE SRCTMP(DDB)		;SUCCESSFUL?
	POPJ P,				;YES, RETURN
;There wasn't room in the existing blocks.  Prepare to extend the UFD.
;First, prohibit expansion beyond first group.
	MOVE TAC,DDLNG(DDB)		;present length of the UFD
	ADDI TAC,UFDLEN+RECSIZ-1	;speculative future length & fill record
	LSH TAC,-RECWSH			;convert to number of records needed in file
NoStructure,<
	CAILE TAC,RCPGRP		;skip if fits in one group
>;NoStructure
IfStructure,<
	CAMLE TAC,DD.RPG(DDB)		;skip if fits in one group
>;IfStructure
	JRST DIRINX			;UFD would become bigger than 1 group
;now, add another block to this UFD
IFE FTRH,<
	PUSHJ P,ASNBLK			;GET NEW BLOCK
>;IFE FTRH
IFN FTRH,<
	MOVE TAC,DDLNG(DDB)	;Current UFD length
	LSH TAC,-RECWSH		;In records = logical rec. no. of last record
	PUSHJ P,LR2BLK		;Lookup block address
	SKIPN TAC		;Just to make sure...
	SETO TAC,		;Assign any block if LR2BLK failed
	PUSHJ P,ASNBLT		;Try for a nearby block
>;IFN FTRH
	MOVEM TAC,SRCTMP(DDB)		;SAVE IT AS FLAG
	MOVEI DAT,DIRI1
	PUSHJ P,QEWAIT			;TRY IT ALL AGAIN,SOMETHING MAY HAVE CHANGED
IFN FTUFDB,<
	SKIPL SRCTMP(DDB)		;successful?
	PUSHJ P,BUGTRP			;no!
>;IFN FTUFDB
	POPJ P,				;GUARANTEED TO WIN

DIRINX:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /UFD expanding beyond first group /
	MOVEI TAC,DDNAM(DDB)
	PUSHJ P,DISFIL
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCAL
	SETOM SRCTMP(DDB)		;UGH BLETCH, GIVE SUCCESS RETURN
	POPJ P,				;return via release UFD interlock.



;*** INTERRUPT SUBRS ***

DIRI1:	MOVE TAC,DDNAM(DDB)		;UFD NAME
	MOVEM TAC,UFDNAM(DDB)		;SET UP FOR UFDREQ
	PUSHJ P,UFDREQ			;GET UNIQUE ACCESS TO UFD & Wait if needed
					;(Next POPJ releases the UFD lock)
	PUSH P,SRCTMP(DDB)		;SAVE FLAG
	SETZM SRCNAM(DDB)		;SEARCH FOR A HOLE.
	PUSHJ P,DIRSRC			;LOOK FOR A HOLE.  GET UFD RTVL IN DDB
	SKIPL SRCTMP(DDB)		;FOUND ONE?
	JRST DIRI4			;YES.  POINTER TO IT IN TAC1.
	SKIPN AC2,DDLNG(DDB)		;Get the word count of this UFD
	JRST DIRI1W			;EMPTY UFD HAS ROOM.
NoStructure,<
	IDIVI AC2,BKDSIZ		;ROOM IN THIS BLOCK?
	CAIG AC3,BKDSIZ-UFDLEN
	JUMPN AC3,DIRI1W		;JUMP IF BLOCK HAS ROOM LEFT.
>;NoStructure
IfStructure,<
	MOVE TAC,DD.RPB(DDB)		;number of records per block
	LSH TAC,RECWSH			;compute # of words per block
	IDIV AC2,TAC			;divide UFD SIZE by # words per block
	SUBI TAC,UFDLEN			;Blk size diminished by one ufd entry
	CAMG AC3,TAC
	JUMPN AC3,DIRI1W		;jump if last partial B has room for more
>;IfStructure
	POP P,SRCTMP(DDB)		;GET FLAG
	AOSN TAC,SRCTMP(DDB)		;IS FLAG SET?
	POPJ P,				;NO, RETURN TO UUO LEVEL TO GET ANOTHER BLK
	SUBI TAC,1			;YES, UNDO AOSN TO GET DISK ADDRESS
NoStructure,<
	MOVEI DAT,RCPBLK
>;NoStructure
IfStructure,<
	MOVE DAT,DD.RPB(DDB)
>;IfStructure
	ADDM DAT,USETP(DDB)		;ADVANCE USET POINTER TO NEW BLK
	PUSH P,TAC			;SAVE ADDRESS OF NEW TRACK
	PUSHJ P,SETRD			;SET TFRSEC AND TFRCTL TO READ
	PUSHJ P,STSTA1			;Read the new track to seize SYSBUF
	POP P,TAC			;RESTORE TRACK ADDRESS
	MOVE TAC1,USETP(DDB)		;get record number
	PUSHJ P,MAKBL2			;ADD NEW TRACK TO THE RETRIEVAL IN THE DDB
	HRRZ AC1,DD.SBB(DDB)		;Address of SYSBUF
	MOVEI TAC1,1(AC1)
	HRLI TAC1,(AC1)
	SETZM (AC1)
	HLRO TAC,DD.SBB(DDB)		;-WC of useful part of buffer
	MOVN TAC,TAC			;+WC
	ADD TAC,AC1			;Ending address +1 of buffer
	BLT TAC1,-1(TAC)
	MOVSI TAC,DSKDAT(DDB)		;BLT some fractional RTVL into block
	HRRI TAC,(AC1)
NoStructure,<
	MOVEI TAC1,SECSIZ(AC1)		;TAC1 POINTS AT NEW ENTRY
>;NoStructure
IfStructure,<
	MOVEI TAC1,(AC1)		;Address of the SYSBUF
	ADD TAC1,DD.SSZ(DDB)		;TAC1 points to the new entry in SYSBUF
>;IfStructure
	BLT TAC,-1(TAC1)		;Copy RTVL to SYSBUF
	PUSH P,[-1]			;FLAG FOR DIRI2.  Fall into DIRI1W
;Here to extend in the last allocated block of the UFD.  The new entry starts
;at (TAC1).  We already have the UFD interlock; DDB contains the current retrieval.
;The last block of the UFD is already present in a SYSBUF.
DIRI1W:
Repeat 0,<
;Near as I can tell, we just read this block.  Hence, TFRIOW and TFRSEC are
;setup.  Let's do without this belt and see if the suspenders are adequate.
	PUSH P,TAC1			;save address of new entry
	MOVE TAC,DD.SBB(DDB)
	MOVEM TAC,TFRIOW(DDB)		;Rewrite entire blk incl. RTVL
	MOVE TAC,USETP(DDB)		;DIRSRC LEFT USETP AT START OF LAST TK
	PUSHJ P,LR2BLK			;Map logical record number to block address
	PUSHJ P,BK2SEC			;Write entire block (a minor waste)
					;We have to spread RTVL later.
NoStructure,<
	LDB AC3,PUNIT
	ADD TAC,BFSETS(AC3)
>;NoStructure
IfStructure,<
	MOVE AC3,SDBPTR(DDB)
	ADD TAC,ST.BSS(AC3)
>;IfStructure
	MOVEM TAC,TFRSEC(DDB)
	POP P,TAC1
>;REPEAT 0.

	PUSHJ P,DIRIHF			;WRITE THE DATA PART OF THE NEW ENTRY
	MOVEI DAT,UFDLEN		;EXTEND UFD LENGTH (UFD HAD BETTER NOT
	ADDM DAT,DDLNG(DDB)		;EVER GET BIGGER THAN 1 GRP)
	PUSHJ P,SPREAD			;SPEAD DDLNG IN UFD
DIRI2:	POP P,TAC			;GET FLAG
	SKIPL TAC			;Skip unless a new block was allocated
	PUSHJ P,RTNBLK			;There was a new block: return it
	POPJ P,				;RETURN via UFDCLR

;Here if we found a hole within defined portion of UFD.  We use it.
DIRI4:	PUSHJ P,DIRIHF			;INSERT ENTRY AT TAC1, SET SUCCESS
	JRST DIRI2

;HERE TO MAKE NEW ENTRY AT TAC1 AND REWRITE THE BLOCK.
DIRIHF:	SETOM SRCTMP(DDB)		;FLAG SUCCESSFUL.
IFN FTLUFD,<
	MOVE TAC,TFRSEC(DDB)		;instead of shifting (which isn't right)
	MOVEM TAC,UFDTRK(DDB)		;Store TFRSEC as disk address of Blk w/hole
	MOVE TAC,DD.SBB(DDB)		;Get the base address of this SYSBUF
	MOVEM TAC,UFDMEM(DDB)
	HRRZ TAC,TAC1			;Address of this UFD entry
	SUBM TAC,UFDMEM(DDB)		;Store RELATIVE address of UFD entry
IFN FTUFDB,<
;	pushj p,devent		;record this event
;	 tro tac,3		;signature of this event
>;IFN FTUFDB
	MOVEI TAC,-1(TAC1)		;MAKE PDL POINTER
	PUSH TAC,ACCNAM(DDB)
	PUSH TAC,ACCEXT(DDB)
	PUSH TAC,ACCPRO(DDB)
	PUSH TAC,FILLOC(DDB)
	PUSH TAC,FILLNG(DDB)
	JRST UFDNEW			;CLEARS UFDDIF
>;IFN FTLUFD
IFE FTLUFD,<
	MOVEI TAC1,-1(TAC1)		;POINTER TO PLACE IN THE UFD
	MOVEI TAC,1(TAC1)		;COPY INDEX FOR BLT
	PUSH TAC1,ACCNAM(DDB)
	PUSH TAC1,ACCEXT(DDB)
	PUSH TAC1,ACCPRO(DDB)
	PUSH TAC1,FILLOC(DDB)
	SETZM 4(TAC)			;CLEAR NEXT WORD
	MOVSI TAC1,4(TAC)		;CLEAR REMAINDER WITH BLT.
	HRRI TAC1,5(TAC)
	BLT TAC1,UFDLEN-1(TAC)
	JRST SREWRIT			;SPIT IT BACK OUT
>;IFE FTLUFD


;⊗ UFDRTR UFDNEW UFDRCL UFDRCX

;UFDNEW IS CALLED FROM DRAUFD AND DIRINS TO WRITE THE REST OF THE UFD ENTRY.

;UFDRTR stores some retrieval into the ufd entry for this file.
;Called ONLY from DCLOI when UFDDIF is set

IFN FTLUFD,<
UFDRTR:	MOVE TAC,FILPPN(DDB)
	CAMN TAC,SYSPPN
	POPJ P,			;DON'T TRY TO MUNG MFD
	MOVEM TAC,UFDNAM(DDB)	;Store argument for UFDREQ
	PUSHJ P,UFDREQ		;Get the UFD interlock
	PUSHJ P,UFDRCL		;TRY TO RECALL UFD ENTRY
	 JRST [	POPJ P,		;Can't find it.  Abort.
		'UFDRTR']	;Error argument for UFDRCL
;TAC1 HAS POINTER TO THE UFD ENTRY, BASH IN RETRIEVAL AND WRITE BACK OUT
UFDNEW:	TLZ IOS,UFDDIF		;UFD WILL NOW BE CORRECT
	MOVEI TAC,ULEN-1(TAC1)	;MAKE A PDL POINTER
	PUSH TAC,FILLNG(DDB)
	PUSH TAC,DATWRT(DDB)	;EXTENDED DATE WRITTEN
	PUSH TAC,REFTIM(DDB)
	PUSH TAC,DMPTIM(DDB)
	PUSH TAC,[0]
	PUSH TAC,[0]
	PUSH TAC,DSATID(DDB)
	PUSH P,AC1
	MOVE AC1,FILPPN(DDB)
	CAME AC1,SYSPPN
	PUSH TAC,FILIN0(DDB)
	CAMN AC1,SYSPPN
	PUSH TAC,[0]		;DONT WRITE PASSWORD IN CASE WRITING UFD'S UFD ENTRY
	POP P,AC1
	PUSH TAC,FILIN1(DDB)
	PUSH TAC,FILIN2(DDB)
	PUSH TAC,FILIN3(DDB)
	PUSH TAC,FILOFF(DDB)
	JRST SREWRIT		;WRITE THE UFD BACK OUT

UFDRCL:	SKIPN TAC,UFDTRK(DDB)
	JSP TAC,UFDRCX		;DON'T KNOW WHERE IT IS
	MOVEM TAC,TFRSEC(DDB)
	SETZM TFRCTL(DDB)	;SET TO READ
	PUSHJ P,STSTA1		;READ UFD TRACK INTO SYSBUF
	HRRZ AC1,DD.SBB(DDB)	;Address of the SYSBUF used here.
	MOVE TAC,DDNAM-DSKDAT(AC1)
	HLRZ TAC1,DDEXT-DSKDAT(AC1)
	MOVE AC2,DDPPN-DSKDAT(AC1)
	CAMN TAC,FILPPN(DDB)
	CAIE TAC1,UFDEXT
	JSP TAC,UFDRCX
	CAME AC2,SYSPPN
	JSP TAC,UFDRCX
	HRRZ TAC1,DD.SBB(DDB)	;Address of this SYSBUF
	ADD TAC1,UFDMEM(DDB)	;Add relative CORE LOCATION OF ENTRY AT DIRSRC TIME
	MOVE TAC,FILNAM(DDB)
	HLLZ AC1,FILEXT(DDB)
	XOR AC1,DDEXT-DSKDAT(TAC1)
	TLNN AC1,-1
	CAME TAC,DDNAM-DSKDAT(TAC1)
	JSP TAC,UFDRCX
	JRST CPOPJ1

UFDRCX:	MOVE	AC2,@(P)	;word at return address.  JRST FOO
	MOVE	AC2,1(AC2)	;Word at FOO+1.  Sixbit error name
	PUSHACS
	PUSH	P,TAC
	PUSH	P,AC2
	PUSHJ	P,DISUSR
	 'UFDRCX'
	PUSHJ	P,DISMES
	 ASCIZ	/Failure to find old UFD information at UFDRCL.
Caller = /
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	 ASCIZ	/; error PC within UFDRCL = /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	JRST	WDDTCALL
>;IFN FTLUFD
;⊗ DIRSRC DIRSB DIRSA DIRS1 DIRS2 DIRSX DIRSRZ DIRSN DIRSE

;*** I-SUBR TO READ DIRECTORY INTO SYSBUF & SEARCH.
;RETURNS FLAG IN SRCTMP: -1 IF NOT FOUND
;	+N IF EXACT MATCH FOUND (I.E., DISK ADDRESS, ALSO IN SRCLOC)
;CALL WITH SRCLOC=DISK ADDRESS OF UFD YOU WANT SEARCHED
;SRCNAM AND SRCEXT = NAME AND EXTENSION TO SEARCH FOR.
;RETURNS UPDATED SRCEXT,SRCPRO, AND SRCLOC.  ALSO RETURNS SRCDAT FROM
;EXTENDED DATE WRITTEN WORD OF UFD ENTRY.

DIRSRC:	MOVE TAC,SRCLOC(DDB)		;LOCATION OF UFD FILE
	PUSHJ P,NEWFIL
	SETZM SRCTMP(DDB)
	PUSHJ P,GETBLK			;read (start of) UFD into SYSBUF
	HRRZ AC1,DD.SBB(DDB)		;Address of the SYSBUF
	MOVE TAC,DDPPN-DSKDAT(AC1)	;BLOCK SHOULD LOOK LIKE UFD.
	HLLZ TAC1,DDEXT-DSKDAT(AC1)
	CAMN TAC,SYSPPN
	CAME TAC1,MFDEXT
	JRST AUDHAK			;BLOCK DOESN'T LOOK LIKE UFD.
NoStructure,<
	MOVE TAC,MFDLOC
	MOVE TAC1,DSATID-DSKDAT(AC1)	;SATID FROM DISK
	LDB DAT,PUNIT
	MOVE DAT,SATADR(DAT)
	CAMN TAC,SRCLOC(DDB)		;IS THIS THE MFD ?
	CAMN TAC1,SATID(DAT)		;YES. AGREES WITH MASTER COPY?
	JRST DIRSA			;YES
	CAME DAT,SATADR			;IS THIS THE MAIN DISK?
	JRST AUDHAK			;NO. SOMEONE SWAPPED PACKS!
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)		;Get the SDB
	MOVE TAC,ST.MFA(TAC)		;Get the address of the MFD
	MOVE TAC1,DSATID-DSKDAT(AC1)	;SATID FROM DISK
	MOVE DAT,SDBPTR(DDB)
	MOVE DAT,ST.SAD(DAT)
	CAMN TAC,SRCLOC(DDB)		;IS THIS THE MFD ?
	CAMN TAC1,SATID(DAT)		;YES. AGREES WITH MASTER COPY?
	JRST DIRSA			;Not MFD or SATID is ok.
	CAME DAT,SDB0+ST.SAD		;IS THIS THE MAIN DISK?
	JRST AUDHAK			;NO. SOMEONE SWAPPED PACKS!
>;IfStructure
	MOVE TAC,SATID(DAT)		;GET SATID FROM CORE
	CAMN TAC,SATID1
	CAME TAC,SATID2
	JRST DIRSB			;HERE IF BACKUP SATIDS DISAGREE
	PUSHACS				;BACKUP ID'S AGREE IN CORE.
	PUSH P,TAC
	PUSH P,AC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /SATID READ FROM DISK IS WRONG.  SATID IN SYSBUF = /
	POP P,AC1
	MOVE TAC,DSATID-DSKDAT(AC1)
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	 ASCIZ /
SATID (AND BACKUPS) IN CORE = /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCALL
	JRST DIRSRC

DIRSB:	EXCH TAC1,SATID(DAT)		;MAKE IT GOOD, WE HOPE
	MOVE TAC,SATID(DAT)		;MAKE LIFE EASIER IN TYPEOUT
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	 [ASCIZ /SATID CLOBBERED!
SATID IN CORE=/]
	 DISARG(OCH,<-20+TAC1(P)>)	;SATID IN CORE
	 [ASCIZ /
SATID ON DISK=/]
	 DISARG(OCH,<-20+TAC(P)>)
	 -1
	MOVE TAC,SATID+SATTAB		;MAKE SURE ALL THE SATID'S AGREE
	MOVEM TAC,SATID1
	MOVEM TAC,SATID2
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCALL		;MAKE HIM DO A CPOPJ$G
DIRSA:	MOVE TAC1,DQINFO+3-DSKDAT(AC1)	;GET DEFAULT FILE PROTECTION
	MOVEM TAC1,UFDPR1(DDB)		;AND GROUP ACCESS BITS
	MOVSI TAC1,777000
	AND TAC1,DDPRO-DSKDAT(AC1)
	MOVEM TAC1,UFDPRO(DDB)		;SAVE PROTECTION OF THIS UFD
NoStructure,<
	MOVEI TAC1,SECSIZ(AC1)
>;NoStructure
IfStructure,<
	HRRZ TAC1,AC1
	ADD TAC1,DD.SSZ(DDB)
>;IfStructure
	MOVN TEM,DDLNG-DSKDAT(AC1)	;GET -WORD COUNT
	JUMPE TEM,DIRSN			;EMPTY DIRECTORY
DIRS1:
NoStructure,<
	MOVEI TAC1,SECSIZ(AC1)
	HRLI TAC1,-BKDSIZ		;AOBJN POINTER TO DATA AREA
>;NoStructure
IfStructure,<
	MOVN TAC1,DD.RPB(DDB)		;-size of data area in records
	LSH TAC1,RECWSH+=18		;convert to -WC in left half
	HRR TAC1,AC1			;base address of block incl rtvl
	ADD TAC1,DD.SSZ(DDB)		;offset to start at data area
>;IfStructure
DIRS2:	MOVE DAT,(TAC1)
	CAME DAT,SRCNAM(DDB)
	JRST DIRSX			;NOT THIS ONE
	JUMPE DAT,DIRSRZ		;LOOKING FOR HOLE, FOUND ONE
	MOVE DAT,1(TAC1)		;NAME SAME, SAVE STUFF ...
	MOVEM DAT,SRCTMP(DDB)		;FOR EXT CHECK.
	MOVE TAC,2(TAC1)
	MOVEM TAC,SRCPRO(DDB)
	MOVE TAC,3(TAC1)		;FILE LOCN (MUST BE +)
	MOVEM TAC,SRCLOC(DDB)
	XOR DAT,SRCEXT(DDB)		;COMPARE EXTENSION
	TLNE DAT,-1
	JRST DIRSX			;NOT A MATCH
IFN FTLUFD,<
	MOVE DAT,DDNAM-DSKDAT(AC1)
	CAMN DAT,SYSPPN
	JRST DIRSE			;DON'T CLOBBER UFDTRK AND UFDMEM ON MFD SRCH
	MOVE DAT,TFRSEC(DDB)
	MOVEM DAT,UFDTRK(DDB)		;REMEMBER DISK ADDR OF UFD SECTOR
	MOVE DAT,DD.SBB(DDB)
	MOVEM DAT,UFDMEM(DDB)
	HRRZ DAT,TAC1
	SUBM DAT,UFDMEM(DDB)		;Remember relative core address of UFD entry
	MOVE DAT,UTIME(TAC1)		;REMEMBER EXTENDED TIME WRITTEN
	MOVEM DAT,SRCDAT(DDB)		;SO LOOKUP CAN WRITE IT IN DATWRT
>;IFN FTLUFD
	JRST DIRSE

DIRSX:	ADDI TEM,UFDLEN			;INDEXING.
	ADD TAC1,[UFDLEN,,UFDLEN]
	JUMPGE TEM,DIRSN		;OUT OF ENTRIES, RETURN FAIL.
	JUMPL TAC1,DIRS2
NoStructure,<
	MOVEI TAC1,RCPBLK
>;NoStructure
IfStructure,<
	MOVE TAC1,DD.RPB(DDB)
>;IfStructure
	ADDM TAC1,USETP(DDB)
	PUSHJ P,GETBLK			;Get next block of UFD into SYSBUF
	HRRZ AC1,DD.SBB(DDB)		;Address of SYSBUF
IfStructure,<
	TLNE IOS,LOSBIG			;GETBLK/GGRETI find blk ptr out of range?
	JRST AUDHAK			;yes, bad UFD
>;IfStructure
	JRST DIRS1

DIRSRZ:	TDZA TAC,TAC			;RETURN ZERO (LOOKING FOR A HOLE)
DIRSN:	MOVNI TAC,1			;RETURN FAILURE
DIRSE:	EXCH TAC,SRCTMP(DDB)		;ENDFILE OR ENTRY FOUND
	MOVEM TAC,SRCEXT(DDB)
	POPJ P,
;⊗ SETLOS SPREAD SPREDL SPREDI SPREDI AUDINF AUDCHK AUDHAK AUDRD NEWFIL NEWFI1 LR2BLK LR2BK1 SETRD SETWRT BK2SEC BKMAP BKMAP1

SETLOS:	TDO IOS,[LOSBIG!IOEND,,IODEND]	;SCREW THE BASTARD
	JRST DSIOS			;STO IOS AND GO UP ONE LEVEL

;SPREAD UPDATED RTVL OVER BLOCKS IN CURRENT GROUP.
;NORMALLY WRITES FROM DDB

;SPREDT:MOVE AC2,USETP(DDB)		;OUT RTVL UP TO CURR BLOCK.
;	SUBI AC2,RCPBLK
;	JRST SPREDF

SPREAD:	SKIPN AC2,DGRP1R(DDB)		;OUT RTVL OVER WHOLE GROUP
	POPJ P,				;There's none to be done!
	MOVE TEM,AC2			;TEM := RN of first block to spread
NoStructure,<
	ADDI AC2,RCPGRP			;AC2 := RN past last block to spread.
	MOVEI TAC1,DSKDAT(DDB)
	HRLI TAC1,-SECSIZ
>;NoStructure
IfStructure,<
	ADD AC2,DD.RPG(DDB)		;AC2 := RN past last block to spread
	MOVN TAC1,DD.SSZ(DDB)		;-sector size
	HRLZ TAC1,TAC1
	HRRI TAC1,DSKDAT(DDB)		;form -sector size,,DSKDAT address
>;IfStructure
	MOVEM TAC1,TFRIOW(DDB)		;Write RTVL from DDB
SPREDL:	MOVE TAC,TEM		
	PUSHJ P,LR2BLK
	JUMPE TAC,SPREDI		;NON EX BLOCK
IFN FTUFDB,<
	CAMN TAC,[4104052]		;is this [CAN,JJW]?
	PUSHJ P,DDTCAL			;stop before we clobber retrieval
>;IFN FTUFDB
	PUSHJ P,SETWRT			;SET TFRSEC AND TFRCTL TO WRITE
	PUSHJ P,TSTART			;Write RTVL from DDB
NoStructure,<
SPREDI:	ADDI TEM,RCPBLK
>;NoStructure
IfStructure,<
SPREDI:	ADD TEM,DD.RPB(DDB)
>;IfStructure
	CAMGE TEM,AC2
	JRST SPREDL			;continue till we pass thru all group
	POPJ P,				;DONE WITH GROUP


AUDINF:	MOVSI TAC1,FILNAM(DDB)
	HRRI TAC1,DDNAM(DDB)		;BLT AUDIT INFO INTO RTVL
	BLT TAC1,DDMPTM(DDB)
IFN FTLUFD,<
	MOVSI TAC1,FILIN0(DDB)
	HRRI TAC1,DQINFO(DDB)
	BLT TAC1,DOFFST(DDB)
>;IFN FTLUFD
NoStructure,<
	LDB TAC1,PUNIT
	MOVE TAC1,SATADR(TAC1)
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	MOVE TAC1,ST.SAD(TAC1)
>;IfStructure
	MOVE TAC1,SATID(TAC1)
	MOVEM TAC1,DSATID(DDB)
	POPJ P,

AUDCHK:	MOVE TAC,FILNAM(DDB)		;name we expect
	CAME TAC,DDNAM(DDB)		;name we got
	TLO IOS,LOSBIG			;not same!
	HLLZ TAC,FILEXT(DDB)
	HLLZ TAC1,DDEXT(DDB)
	CAME TAC,TAC1
	TLO IOS,LOSBIG
	MOVE TAC,FILPPN(DDB)
	CAME TAC,DDPPN(DDB)
AUDHAK:	TLO IOS,LOSBIG
	TLNE IOS,LOSBIG
	MOVEM DDB,ACDDB			;SAVE LOSER FOR DEBUGGING
	POPJ P,

IFN FTLUFD,<
AUDRD:	MOVSI TAC,DQINFO(DDB)		;COPY CURRENT FILE INFO AND OFFSET TO DDB
	HRRI TAC,FILIN0(DDB)
	BLT TAC,FILOFF(DDB)
	POPJ P,
>;IFN FTLUFD

;SET UP GGRETI TO READ A NEW FILE, WHOSE RTVL ISN'T IN.
NEWFIL:	CAME TAC,DDLOC(DDB)		;IS RIGHT RTVL IN?
NEWFI1:	SETZM DGRP1R(DDB)		;NO, FORCE IT TO BE READ
	MOVEM TAC,DDLOC(DDB)
	MOVEI TAC1,1
	MOVEM TAC1,USETP(DDB)
	POPJ P,

;Logical Record to Block Conversion. Correct group is assumed.
;Call with TAC containing the USET pointer
;Returns	OLD:			NEW:
;		TAC: track number	TAC: (fullword) record number of blk origin
;		AC3: physical record	AC3: record offset in block
;		     in track.
LR2BLK:	SUB TAC,DGRP1R(DDB)		;compute relative RN within group
NoStructure,<
	CAIL TAC,0
	CAIL TAC,RCPGRP
	MOVEI TAC,1			;WRONG GROUP.DEFAULT SELECT REC1.
	IDIVI TAC,RCPBLK		;Block in Group in TAC, Record in TAC1
	MOVEI AC3,1(TAC1)		;AC3:=physical record in Blk (INCL RTRVL)
>;NoStructure
IfStructure,<
	SKIPL TAC
	CAML TAC,DD.RPG(DDB)		;skip if within current group
	MOVEI TAC,1			;WRONG GROUP.DEFAULT SELECT REC1.
	IDIV TAC,DD.RPB(DDB)
	MOVEI AC3,1(TAC1)		;AC3:=physical record in Blk (INCL RTRVL)
	MOVE TAC1,DD.BPG(DDB)		;get the number of blocks per group
	CAIE TAC1,FWRTVL		;Skip if 112 full-word block addresses
	JRST LR2BK1			;must be old way: 32 halfwords
	ADDI TAC,DPTR(DDB)
	MOVE TAC,(TAC)			;new way.  return fullword RN of B origin
	POPJ P,
>;IfStructure

LR2BK1:	LSHC TAC,-1			;old format.
	ADDI TAC,DPTR(DDB)
	MOVE TAC,(TAC)
	SKIPL TAC1
	HLRS TAC
	HRRZS TAC
;note that if there's more than one block per track, at this point
;you should divide TAC by the number of blocks per track, and
;add to AC3 the remainder times the number of records (incl rtvl) per blk.
	POPJ P,

SETRD:	PUSHJ P,BK2SEC			;Setup to read RTVL & Data
NoStructure,<
	LDB AC3,PUNIT
	ADD TAC,BFSETS(AC3)		;ADD IN OFFSET
>;NoStructure
IfStructure,<
	MOVE AC3,SDBPTR(DDB)
	ADD TAC,ST.BSS(AC3)
>;IfStructure
	MOVEM TAC,TFRSEC(DDB)
	SETZM TFRCTL(DDB)		;SET UP TO READ (NON-USER MODE)
	POPJ P,

SETWRT:	PUSHJ P,SETRD			;Set to do one block
	MOVEI AC3,DWRITE
	MOVSM AC3,TFRCTL(DDB)
	POPJ P,

;BK2SEC - convert track number to disk address of rtvl record of track.
;if there is more than one block per track, this loses!
BK2SEC:	MOVEI AC3,0
;BKMAP - maps a track number and record number to a disk address.
;      - in new mode, it maps a record number of blk origin + offset
;	call with TAC=block address; AC3 = record number
BKMAP:
IfStructure,<
	PUSH P,TAC1
	MOVE TAC1,DD.BPG(DDB)		;number of blocks per group
	CAIE TAC1,FWRTVL		;Skip if new format (112 fullwords)
	JRST BKMAP1
	POP P,TAC1
	ADD TAC,AC3
	POPJ P,

BKMAP1:	POP P,TAC1
>;IfStructure
	LSH TAC,6			;make room for RN in low end
	DPB AC3,[POINT 6,TAC,35]	;Store RN in low bits of TAC
	POPJ P,
;⊗ GETRET TSTRET MAKBLK MAKBL2 MAKB3 MAKB3 MAKB3A ASNGRP ASNGR1 ASNGR2 ASNG2A ASNG2B GETBLK GETBK1 GGRETI GGRTI0 GGBLK1 GGNXT GETBKA GGRETD GGRET1 GGNXTD

GETRET:	MOVEI DAT,GGRETD
	PUSHJ P,TSTRET			;IS IT?
	 PUSHJ P,QEWAIT			;NO, GO GET IT. THEN TEST IT
TSTRET:	MOVE TAC,USETP(DDB)
	SKIPN TAC1,DGRP1R(DDB)		;SKIP IF RTVL IS IN.
	POPJ P,				;NOT IN, RETURN
NoStructure,<
	CAIGE TAC,RCPGRP(TAC1)
>;NoStructure
IfStructure,<
	ADD TAC1,DD.RPG(DDB)		;Compute first RN beyond current G
	CAMGE TAC,TAC1			;Skip if RN is beyond current G
>;IfStructure
	CAMGE TAC,DGRP1R(DDB)
	POPJ P,				;LOSE, WRONG GROUP IN
	JRST CPOPJ1			;IN, SKIP

MAKBLK:	PUSHJ P,GETRET			;GET GROUP RETRIEVAL IN!
	 PUSHJ P,ASNGRP			;NO SUCH GROUP, MAKE ONE
	MOVE TAC,USETP(DDB)
	PUSHJ P,LR2BLK			;LOOK UP BLOCK IN RTVL.
	JUMPN TAC,CPOPJ			;IT EXISTS, RETURN
IFE FTRH,<
	PUSHJ P,ASNBLK			;IT DOESN'T, GET ONE FROM SAT
>;IFE FTRH
IFN FTRH,<
	MOVE TAC,USETP(DDB)
	SUB TAC,DD.RPB(DDB)	;Look up a record in previous block
	PUSHJ P,LR2BLK		;(Handles negative TAC or wrong group)
	SKIPN TAC		;Skip if record number found
	SETO TAC,		;Else accept any block assignment
	PUSHJ P,ASNBLT		;Assign a block near the last one
>;IFN FTRH
	TLO IOS,PNTDIF			;NOTE RTVL NOT OUT!!!
MAKBL2:	MOVE AC1,USETP(DDB)		;MAKE RTVL ENTRY (HERE FROM DIRI2)
	SUB AC1,DGRP1R(DDB)		;PUT ABS BLK PTR IN CORR HALFWD.
NoStructure,<
	IDIVI AC1,RCPBLK
	LSHC AC1,-1
	ADDI AC1,DPTR(DDB)
	JUMPL AC2,MAKB3
	HRLM TAC,(AC1)			;EVEN IN LEFT HALF
	POPJ P,

MAKB3:	HRRM TAC,(AC1)			;ODD IN RIGHT HALF
	POPJ P,
>;NoStructure
IfStructure,<
	IDIV AC1,DD.RPB(DDB)		;get block number within this group
	MOVE AC2,DD.BPG(DDB)		;get number of blocks per group
	CAIN AC2,FWRTVL			;skip unless new format
	JRST MAKB3A			;new format: 1 per word past DPTR
	LSHC AC1,-1			;old, halfword format.
	ADDI AC1,DPTR(DDB)
	JUMPL AC2,MAKB3
	HRLM TAC,(AC1)			;EVEN IN LEFT HALF
	POPJ P,

MAKB3:	HRRM TAC,(AC1)			;ODD IN RIGHT HALF
	POPJ P,

MAKB3A:	ADDI AC1,DPTR(DDB)		;to bn in G, add address of DPTR
	MOVEM TAC,(AC1)			;store address of new block
	POPJ P,
>;IfStructure

;ASSIGN A BLOCK FOR A NEW GROUP.

ASNGRP:	PUSHJ P,ASNBLK			;GET BLOCK FROM SAT
ASNGR1:	MOVEM TAC,DNXTGP(DDB)		;PUT INTO LINK
	SKIPN TAC,DGRP1R(DDB)		;SKIP IF THERE IS A CURRENT GROUP
	JRST ASNGR2
IFN FTDOPS,<
	CAIN TAC,1
	TLZ IOS,HDRDIF			;SPREADING FIRST GROUP, SO CLEAR HDRDIF
>;IFN FTDOPS
	PUSHJ P,AUDINF
	MOVEI DAT,SPREAD		;SMEAR EXISTING RTVL OUT
	PUSHJ P,QEWAIT
ASNGR2:	MOVEI TAC,0
	EXCH TAC,DNXTGP(DDB)		;NEW BLOCK...
IfStructure,<
	MOVE TAC1,DD.BPG(DDB)		;get the number of blocks per group
	CAIE TAC1,FWRTVL		;Skip if 112 full-word block addresses
	JRST ASNG2A			;must be old way: 32 halfwords
	MOVEM TAC,DPTR(DDB)		;Full word rtvl.
	SETZM DPTR+1(DDB)
	MOVSI TAC1,DPTR+1(DDB)
	HRRI TAC1,DPTR+2(DDB)
	BLT TAC1,DSKDAT+RECSIZ-1(DDB)
	JRST ASNG2B
>;IfStructure

ASNG2A:	HRLZM TAC,DPTR(DDB)		;IS FIRST OF NEW GRP.
	SETZM DPTR+1(DDB)		;CLEAR OUT REST OF RTVL.
	HRLI TAC1,DPTR+1(DDB)
	HRRI TAC1,DPTR+2(DDB)
	BLT TAC1,DDEND-1(DDB)
ASNG2B:	MOVE TAC,USETP(DDB)
	MOVEM TAC,DGRP1R(DDB)
	TLO IOS,PNTDIF			;NOTE NEW RTVL NOT OUT.
	POPJ P,

;Get RTVL & block containing USETP into SYSBUF.  - called from DIRSRC (only?)
GETBLK:	PUSHJ P,GGRETI			;Get group RTVL into DDB.  Data in SYSBUF
	JUMPE TAC,CPOPJ			;NON EX=EOF
	MOVE TAC,USETP(DDB)
	SKIPN TFRIOW(DDB)		;DID GGRETI READ? (If so, data in SYSBUF)
	JRST GETBK1			;NO, GO READ BLOCK
NoStructure,<
	MOVE TAC1,DGRP1R(DDB)		;We're at the first block of this group
	CAIGE TAC,RCPBLK(TAC1)		;is the one we want in this block?
	POPJ P,				;YES, RETURN.
>;NoStructure
IfStructure,<
	SUB TAC,DGRP1R(DDB)		;calc (RN within group) for sought block
	CAMGE TAC,DD.RPB(DDB)		;is the RN we want within this block?
	POPJ P,				;YES, RETURN.
	MOVE TAC,USETP(DDB)		;no.  compute block within group for this RN
>;IfStructure
GETBK1:	PUSHJ P,LR2BLK
	JUMPE TAC,CPOPJ			;NON EX = EOF
	PUSHJ P,SETRD			;SET TFRSEC AND TFRCTL TO READ
	JRST STSTA1			;START THE TRANSFER

;Get RTVL for group into DDB if not already there.
;Call with USETP(DDB) containing RN within the group whose rtvl is wanted.
;This reads the first block of the group into SYSBUF and BLTs RTVL to DDB
;Returns:  TAC=0 if EOF.  TFRIOW(DDB)=0 if no IO was done (no SYSBUF contents)
GGRETI:	SETZM TFRIOW(DDB)		;FLAG FOR GETBLK.
GGRTI0:	SKIPN TAC1,DGRP1R(DDB)		;If no RTVL is present yet,
	JRST GGBLK1			;  go get block 1.
	MOVE TAC,USETP(DDB)		;Get the desired RN.
NoStructure,<
	CAIL TAC,RCPGRP(TAC1)		;Skip if USETP is at or before current G
	JRST GGNXT			;Must advance to next G
>;NoStructure
IfStructure,<
	ADD TAC1,DD.RPG(DDB)		;compute RN of first R past current G
	CAML TAC,TAC1			;Skip if RN is before end of current G
	JRST GGNXT			;Desired RN is beyond current G
>;IfStructure
	CAML TAC,DGRP1R(DDB)		;Skip if USETP is prior to current G
	POPJ P,				;We found it in this G
GGBLK1:	SKIPA TAC,DDLOC(DDB)		;START AT BEGINNING.
GGNXT:	MOVE TAC,DNXTGP(DDB)		;GO ON TO NEXT GROUP
	JUMPE TAC,CPOPJ			;RETURN IF EOF
IfStructure,<
	LDB TAC1,PUNIT			;get structure number
	CAIGE TAC1,STRMAX		;Bound check.  Skip if bad.
	SKIPN TAC1,SDBADR(TAC1)		;In bound.  skip if defined, get SDB
	JRST AUDHAK			;Bad struct num
	CAML TAC,ST.LAD(TAC1)		;make sure DDLOC or DNXTGP is reasonable
	JRST AUDHAK			;lose!  don't try to read w/bad blk addr
	JUMPL TAC,AUDHAK		;negative block numbers are bad too
>;IfStructure
	PUSHJ P,SETRD			;SET TFRSEC AND TFRCTL TO READ
	PUSHJ P,STSTA1			;...IN CASE SOMEONE WANTS IT.
	HRLZ TAC,DD.SBB(DDB)		;BLT RETRIEVAL & Audit from SYSBUF
	HRRI TAC,DSKDAT(DDB)		;   ... TO DDB.
NoStructure,<
	BLT TAC,DSKDAT+SECSIZ-1(DDB)
>;NoStructure
IfStructure,<
	MOVEI TAC1,DSKDAT-1(DDB)
	ADD TAC1,DD.SSZ(DDB)		;Calc. ending address of RTVL in DDB
	BLT TAC,(TAC1)
>;IfStructure
	JRST GGRTI0			;test for arrival & do more if needed


;GET ADDRESS OF BLOCK CONTAINING USETP.  RETURN TAC=0 FOR EOF
GETBKA:	PUSHJ P,GGRETD			;GET RTVL INTO DDB
	JUMPE TAC,CPOPJ			;NON EX = EOF
	MOVE TAC,USETP(DDB)
	PUSHJ P,LR2BLK
	JUMPE TAC,CPOPJ			;NON EX = EOF
	PUSHJ P,SETRD			;SET TFRSEC AND TFRCTL TO READ
	JRST AUDCHK			;CHECK RETRIEVAL AND RETURN

;Get RTVL for Group into DDB unless already there.  Return TAC=0 for EOF
;Call with USETP(DDB) = RN of a record within the group whose rtvl is wanted.
GGRETD:	SKIPN TAC1,DGRP1R(DDB)		;If no RTVL is present yet,
	JRST GGRET1			;  go get block 1.
	MOVE TAC,USETP(DDB)		;Get the desired RN.
NoStructure,<
	CAIL TAC,RCPGRP(TAC1)		;Skip if USETP is at or before current G
	JRST GGNXTD			;Must advance to next G
>;NoStructure
IfStructure,<
	ADD TAC1,DD.RPG(DDB)		;compute RN of first R past current G
	CAML TAC,TAC1			;Skip if RN is before end of current G
	JRST GGNXTD			;Desired RN is beyond current G
>;IfStructure
	CAML TAC,DGRP1R(DDB)		;Skip if USETP is prior to current G
	POPJ P,				;We found it in this G
GGRET1:	SKIPA TAC,DDLOC(DDB)		;START AT BEGINNING.
GGNXTD:	MOVE TAC,DNXTGP(DDB)		;GO ON TO NEXT GROUP
	JUMPE TAC,CPOPJ			;RETURN IF EOF
	PUSHJ P,SETRD			;SET TFRSEC AND TFRCTL TO READ
NoStructure,<
	MOVEI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
	HRLI	TAC,-SECSIZ
>;NoStructure
IfStructure,<
	MOVN	TAC,DD.SSZ(DDB)		;-size of rtvl area
	HRLZ	TAC,TAC
	HRRI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
>;IfStructure
	MOVEM TAC,TFRIOW(DDB)		;READ RETRIEVAL INTO DDB
	PUSHJ P,TSTART			;IN CASE SOMEONE WANTS IT.
	JRST GGRETD			;check we're done & do more if needed
;⊗ CUSATO SATGLZ SATOUT SATIN

;SAT output.  
;	The old main disk uses SATOUT
;	The old (AMPEX, CDC) UDPs use USATOUT
;	All RH disks use PUTSAT

CUSATO:					;Output SAT from UUO Level
NoStructure,<
	LDB TAC,PUNIT			;SAT OUT FROM UUO LEVEL
	SKIPGE SATMOD(TAC)		;SKIP IF UNCHANGED OR ON WAY OUT
	SKIPG TAC1,SATADR(TAC)		;ADDRESS OF SAT TABLE
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SKIPGE ST.SMD(TAC)		;SKIP IF UNCHANGED OR ON WAY OUT
	SKIPG TAC1,ST.SAD(TAC)		;ADDRESS OF SAT TABLE
>;IfStructure
	POPJ P,				;NO CHANGE, RETURN
	MOVE DAT,TIME			;GET CURRENT TIME
	MOVEM DAT,DTIME(TAC1)		;SAVE IN SAT TABLE
	MOVE DAT,THSDAT
	MOVEM DAT,DDATE(TAC1)		;AND CURRENT DATE
	LDB TAC,PUNIT
IFN FTRH,<
	CAMLE TAC,[UPACKS]		;Skip unless RH disks.
	JRST PUTSAT			;No.  Queue for RH SAT ops
>;IFN FTRH
	MOVEI DAT,SATOUT
	JUMPE TAC,NEWAIT		;IF MAIN DISK, QUEUE THIS AND POPJ
IFN UPACKS,< ;can't get here, supposedly, if no UDPs
	HRLI TAC1,-USATSZ
	MOVEM TAC1,TFRIOW(DDB)		;SET THIS FOR USATOUT
	MOVEI DAT,USATOUT
	PUSHJ P,NEWAIT
	TRNN IOS,IODERR!IOIMPM
	POPJ P,
>;IFN UPACKS
SATGLZ:	PUSHJ P,ERZIOS			;UN-INITIALIZED UDP.
	JSP TAC,ERRPTU
	 ASCIZ /UDP offline or write locked/
	JRST EXCALP

;*** I-SUBR ***		SAT OPS for Old-Style MAIN disk only!
;
;This wouldn't work for RH based disks.  BLKWDS is wrong.
;Shifts by 6 are wrong.  Location of second SAT track is wrong.
;
SATOUT:
NoStructure,<
	SKIPL SATMOD			;DOES IT STILL NEED TO GO OUT
>;NoStructure
IfStructure,<
	SKIPL SDB0+ST.SMD		;Does it still need to go out?
>;IfStructure
	POPJ P,				;NO (PROB ON WAY OUT ALREADY)
	SKIPA TAC,[DWRITE!DSATOP]	;WRITE SAT
SATIN:	MOVEI TAC,DSATOP		;READ SAT (HERE FROM DSKINI ONLY)
	MOVSM TAC,TFRCTL(DDB)
IFG SATSIZ-BLKWDS,<
	MOVE TAC,[-BLKWDS,,SATTAB]	;DO FIRST TRACK OF SAT
;>	MOVE TAC,[-SATSIZ,,SATTAB]	;DO WHOLE SAT, ALL WITHIN ONE TRACK
	MOVEM TAC,TFRIOW(DDB)		;IOWD FOR THIS TRANSFER
	SETZM TFRSEC(DDB)		;FIRST SAT TRACK IS ALWAYS TRACK 0
NoStructure,<
	HRRZM P,SATMOD			;POSITIVE MEANS IN TRANSIT
>;NoStructure
IfStructure,<
	HRRZM P,SDB0+ST.SMD		;POSITIVE MEANS IN TRANSIT
>;IfStructure
	PUSHJ P,TSTART			;At most, read one block
IFG SATSIZ-BLKWDS,<
	MOVE TAC,[BLKWDS-SATSIZ,,SAT2BK]
	MOVEM TAC,TFRIOW(DDB)		;DO REST OF SAT BIT TABLE
	MOVE TAC,SATTAB+NXTSAT		;DISK ADDRESS OF SECOND SAT TRACK
	LSH TAC,6
	IORI TAC,SAT2RC			;STARTING RECORD NUMBER ON SECOND SAT TRACK
	MOVEM TAC,TFRSEC(DDB)
	PUSHJ P,TSTART			;FINISH SAT OP (read at most one block)
>;IFG SATSIZ-BLKWDS
NoStructure,<
	SETZM SATMOD			;MARK SAT TABLE NOW NOT MODIFIED
>;NoStructure
IfStructure,<
	SETZM SDB0+ST.SMD		;MARK SAT TABLE NOW NOT MODIFIED
>;IfStructure
	POPJ P,


;Manipulate new style UDP SAT table ;⊗ SATGET SATGT0 SATGT1 SATGL1 USATIN USATOUT USATWAT
;
; SATADR = 0 Idle. No SAT
;        < 0 RH is address.  Someone has queued a request to run USATIN
;        > 0 Ready for use.
;
SATGET:	TRZ IOS,IOIMPM!IODERR!IODTER	;No errors yet.  Make sure SAT is in (UDP)
NoStructure,<
	LDB TAC1,PUNIT			
	SKIPLE AC3,SATADR(TAC1)		;Is the SAT in for this device?
	POPJ P,				;Yes.  Use it.
	JUMPL AC3,SATGT1		;Jump if core assigned.  Someone else
					;   is trying to bring in the SAT
	MOVEI AC3,USATSZ		;SIZE OF SAT TABLE
	PUSHJ P,UFSGET			;GET FS. WAIT IF NEEDED
	LDB TAC1,PUNIT
	SKIPE SATADR(TAC1)		;Is anyone else working here?
	JRST SATGT0			;yes.  Oops.  Give back FS & wait
	HRROM AC1,SATADR(TAC1)		;Save location of SAT in core
	HRLI AC1,-USATSZ		;FORM WCMA
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	SKIPLE AC3,ST.SAD(TAC1)		;Test incore address of the SAT
	POPJ P,				;SAT is in.
	JUMPL AC3,SATGT1		;Jump if someone else is working on it
IFN FTRH,<
	LDB	TAC,PUNIT		;Is this an RH disk?
	CAMLE	TAC,[UPACKS]
	JRST	GTSATX			;Yes.  Do it that way.
>;IFN FTRH
	MOVE AC3,ST.SSZ(TAC1)		;SIZE OF SAT TABLE
	PUSHJ P,UFSGET			;GET FS. WAIT IF NEEDED
	MOVE TAC1,SDBPTR(DDB)		;We may have waited for FS.
	SKIPE ST.SAD(TAC1)		;Has someone else been working here?
	JRST SATGT0			;Yes.  Oops.  Return FS & Wait
	HRROM AC1,ST.SAD(TAC1)		;Save address of new SAT.  FLAG We're Here
	MOVN AC3,ST.SSZ(TAC1)		;-WC
	HRL AC1,AC3			;FORM WCMA
>;IfStructure
	MOVEM AC1,TFRIOW(DDB)		;SET IT IN THE DDB
	MOVEI DAT,USATIN
	PUSHJ P,NEWAIT			;CAUSE SAT TO BE READ AND WAIT FOR IT.
NoStructure,<
	LDB TAC,PUNIT
	HRRZS AC1,SATADR(TAC)		;Clear LH.  SAT input complete
	SETZM SATMOD(TAC)
	TRNE IOS,IOIMPM!IODERR		;ERROR?
	JRST SATGL1			;YES.  Return FREE STG & give message
	MOVE TAC1,IDSAT(AC1)
	CAMN TAC1,['SATID ']
	JRST ACISTT			;FORM DSKUSE, BADCHK, ETC,
	SETZM SATADR(TAC)
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SETZM ST.SMD(TAC)
	HRRZS AC1,ST.SAD(TAC)		;Clear LH.  SAT input complete
	TRNE IOS,IOIMPM!IODERR		;ERROR?
	JRST SATGL1			;YES.  GIVE BACK FREE STG
	MOVE TAC1,IDSAT(AC1)
	CAMN TAC1,['SATID ']
	JRST ACISTT			;FORM DSKUSE, BADCHK, ETC,
	SETZM ST.SAD(TAC)
>;IfStructure
	PUSHJ P,FSGIVE			;Return Free Storage (AC1)
	PUSHJ P,ERZIOS			;UN-INITIALIZED UDP.
	JSP TAC,ERRPTU
	 ASCIZ /Not a new format UDP/
	JRST EXCALP

;Here when SATADR is non-zero after it was zero.  Someone else is reading SAT in.
SATGT0:	PUSHJ	P,FSGIVE		;Return free storage.
	JRST	SATGET			;Maybe it's done, or get to SATGT1

SATGT1:	MOVEI	DAT,USATWAT		;SATADR is negative.  Work in progress
	PUSHJ	P,NEWAIT		;Won't finish until someone else does it.
	JRST	SATGET			;Start over

;Lost trying to read SAT. Probably no pack mounted?
;Return free storage and give offline complaint
SATGL1:	
NoStructure,<
	SETZM	SATADR(TAC)
>;NoStructure
IfStructure,<
	SETZM	ST.SAD(TAC)
>;IfStructure
	PUSHJ	P,FSGIVE		;RETURN THE BLOCK
	JRST	SATGLZ			;Error.  Drive offline

;*** I-LEVEL SUBR ***
;TFRIOW SETUP BY CALLER!
USATIN:	SETOM	UFDNAM(DDB)		;SET UP FOR UDP SAT INTERLOCK
	PUSHJ	P,UFDREQ		;Seize SAT interlock (not supposed to wait)
	TDZA	TAC,TAC
USATOUT:MOVEI	TAC,DWRITE
	MOVSM	TAC,TFRCTL(DDB)		;SET READ/WRITE MODE
NoStructure,<
	LDB TAC,PUNIT
	MOVE TAC,BFSET(TAC)		;DISK ADDRESS OF SAT TABLE
>;NoStructure
IfStructure,<
	MOVE AC3,SDBPTR(DDB)
	MOVE TAC,ST.STA(AC3)		;Disk address of SAT
	ADD  TAC,ST.BFS(AC3)		;Offset to pack origin
>;IfStructure
	PUSHJ P,BK2SEC			;CONVERT BLOCK TO SECTOR
	MOVEM TAC,TFRSEC(DDB)
	PUSHJ P,TSTART			;Read one block
	POPJ P,

;Here to wait for the UFD interlock to be released.
;We got here because we found SATADR was negative, meaning space is assigned
;  and the disk operation has be queued, but ACISTT is still needed.
USATWAT:
NoStructure,<
	LDB TAC,PUNIT
	SKIPL SATADR(TAC)		;SAT SHOULD BE ON THE WAY IN
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SKIPL ST.SAD(TAC)		;SAT SHOULD BE ON THE WAY IN
>;IfStructure
	POPJ P,
	SETOM UFDNAM(DDB)		;SET UP FOR UDP SAT INTERLOCK
	PUSHJ P,UFDREQ			;This should wait
	POPJ P,				;And this should release the interlock.

;⊗ ASNBLK ASNBLT RB4WCK RB4WLS RB4WER ASNST1 RASNB9 IASNBK ASNSL1 ASNSL2 RTNBLK MRKBLK CSATID MRKBAD MRKBD0 MRKBD1 MRKBD2

;Assign a disk block for a file. (Calls IASNBK, which calls RASNBK.)

;Enter at ASNBLK to accept any disk block assignment.
ASNBLK:	SETO TAC,		;accept any block
;Enter at ASNBLT with TAC containing record number of desirable assignment.
;(Only the RH code currently uses this.)
ASNBLT:	PUSHJ P,IASNBK		;ASSIGN SUITABLE BLOCK
	PUSH P,TAC
	MOVEM TAC,TFRSEC(DDB)		;SAVE HERE FOR I SUBR
	MOVEI DAT,RB4WCK		;READ BEFORE WRITE CHECKER
	PUSHJ P,QEWAIT
	POP P,TAC
	SKIPE TFRIOW(DDB)		;SUCCESS?
	POPJ P,				;YES
REPEAT 0,<
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /ASNBLK/
	PUSHJ P,DISMES
	 ASCIZ /ASNBLK OVERWITE CHECK, DSKOVC = /
	MOVE TAC,DSKOVC
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	POPACS
>;END REPEAT 0
	JRST ASNBLK		;BLOCK IN USE, ASSIGN ANOTHER BLOCK

;*** I SUBR ****   READ BEFORE WRITE CHECKER 
RB4WCK:	SKIPN TAC,TFRSEC(DDB)		;GET LOGICAL DISK ADDRESS
	JRST RB4WLS			;LOSE IF ADDRESS IS 0
	PUSHJ P,SETRD			;SET TFRSEC AND TFRCTL TO READ
	PUSHJ P,STSTA1			;USE APPROPRIATE SYSBUF
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,IODERR!IODTER		;LOSE ON READ?
	JRST RB4WER			;YES, USE ANOTHER
	HRRZ AC1,DD.SBB(DDB)
	SKIPE DDNAM-DSKDAT(AC1)		;NULL FILE NAME?
	SKIPN DDPPN-DSKDAT(AC1)		;OR PPN?
	POPJ P,				;YES, OK TO WRITE HERE
NoStructure,<
	LDB TAC,PUNIT
	MOVE TAC,SATADR(TAC)
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	MOVE TAC,ST.SAD(TAC)
>;IfStructure
	MOVE TAC,SATID(TAC)		;GET SATID FROM CORE
	CAME TAC,DSATID-DSKDAT(AC1)	;SAME AS ON DISK?
	POPJ P,				;NO. INVALID SATID MEANS HE CAN WRITE HERE
RB4WLS:	AOS DSKOVC			;COUNT OVERWRITE CHECK
RB4WER:	SETZM TFRIOW(DDB)		;FLAG ILLEGAL BLOCK
	POPJ P,

;THIS CODE BLOWS HORNY TOADS, SOMEONE OUGHT TO FIX IT. - REG

ASNST1:	CONO PI,DSKON			;TURN DSK BACK ON
	SUB P,[1,,1]
IFN 1,<	;DON'T LET HIM CONTINUE UNTIL SYSTEM IS FIXED NOT TO CLOBBER UFD RETRIEVAL
RASNB9:	MOVSI AC2,JERR			;ERROR BIT WILL PREVENT CONTINUE CMD
	LDB AC3,PJOBN
	IORM AC2,JBTSTS(AC3)		;FLAG ERROR IN JOB STATUS
PRINTX Here is the Full Disk non-continue fix.  Someday make continue work.
>;IFN 1
	PUSHJ P,EDFULL			;"DISK IS FULL" MESSAGE
					;LET HIM TRY AGAIN, IF HE SAYS CONTINUE
IASNBK:
NoStructure,<
	LDB AC3,PUNIT
	PUSH P,LSTBTB(AC3)		;Save block number of last blk in sat
	MOVE AC3,SATADR(AC3)		;ADDRESS OF SAT TABLE FOR THIS DEV
>;NoStructure
IfStructure,<
IFN FTRH,<
	LDB AC1,PUNIT
	CAMLE AC1,[UPACKS]
	JRST RASNBK			;use RH-SAT Assignment routine
>;IFN FTRH
	MOVE AC3,SDBPTR(DDB)
	PUSH P,ST.BTB(AC3)		;blk number of last blk in sat
	MOVE AC3,ST.SAD(AC3)
>;IfStructure
	MOVE AC2,LSTBLK(AC3)		;LAST PLACE WE ASSIGNED BLOCK
	AOJA AC2,ASNSL2			;START BEYOND THAT
ASNSL1:	CONO PI,DSKON			;LET THE IOP IN FOR A QUICK LOOK.
ASNSL2:	CONO PI,DSKOFF
	CAML AC2,(P)			;OFF THE END YET?
	MOVEI AC2,1			;YES. START OVER.
	CAMN AC2,LSTBLK(AC3)		;WRAP TO WHERE WE STARTED?
	JRST ASNST1			;YES. ICK. THERE'S NO DISK LEFT
	MOVE TAC,AC2			;CONVERT BLOCK NUMBER TO BIT AND WORD #
	IDIVI TAC,44			;WORD NUMBER IN TAC, BIT NUMBER IN TAC1
	MOVEI AC1,1			;MAKE A BIT MASK
	ROT AC1,(TAC1)
	ADDI TAC,(AC3)
	TDNE AC1,SATBIT(TAC)		;THIS BLOCK IN USE?
	AOJA AC2,ASNSL1			;YES, KEEP LOOKING
	IORM AC1,SATBIT(TAC)		;MARK IN USE
NoStructure,<
	LDB TAC,PUNIT
	SETOM SATMOD(TAC)		;FLAG SAT TABLE IS BEING CHANGED
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SETOM ST.SMD(TAC)		;FLAG SAT TABLE IS BEING CHANGED
>;IfStructure
	XORM AC1,SATCHK(AC3)		;UPDATE CHECKSUM.
	CONO PI,DSKON			;LET THEM BACK IN
	SUB P,[1,,1]
	MOVEM AC2,LSTBLK(AC3)		;REMEMBER THE LAST BLOCK THAT WAS USED
	AOS TAC,AC2			;RETURN EXCESS 1 IN TAC.  (AVOID 0)
	AOS DSKUSE(AC3)			;COUNT ANOTHER BLOCK IN USE
	SKIPG AC1,BADCNT(AC3)
	POPJ P,
	CAILE AC1,BADMAX
	MOVEI AC1,BADMAX
	HRLOI AC1,-1(AC1)
	EQVI AC1,(AC3)			;-BADCNT,,ADDRESS OF SAT TABLE
	CAMN TAC,BADTRK(AC1)		;SKIP UNLESS THIS BLOCK IS BAD
	JRST IASNBK			;ASSIGN SOME OTHER BLOCK.
	AOBJN AC1,.-2
	POPJ P,


;mark a block as free in the SAT.  Call with Block number in TAC.
;		for RH-Based disks, the argument is a record number.
RTNBLK:
NoStructure,<
	LDB AC1,PUNIT
	CAMG TAC,LSTBTB(AC1)		;SKIP IF INVALID BLOCK.
>;NoStructure
IfStructure,<
IFN FTRH,<
	LDB AC1,PUNIT
	CAMLE AC1,[UPACKS]
	JRST RRTNRC			;use RH-Return routine
>;IFN FTRH
	MOVE AC1,SDBPTR(DDB)
	CAMG TAC,ST.BTB(AC1)		;SKIP IF INVALID BLOCK.
>;IfStructure
	SOJGE TAC,.+2			;REMOVE EXCESS 1 AND JUMP IF VALID
	POPJ P,				;INVALID BLOCK
	IDIVI TAC,44
NoStructure,<
	ADD TAC,SATADR(AC1)
>;NoStructure
IfStructure,<
	ADD TAC,ST.SAD(AC1)
>;IfStructure
	MOVEI AC1,1
	ROT AC1,(TAC1)
	TDNN AC1,SATBIT(TAC)
	POPJ P,				;ALREADY OFF!
	ANDCAM AC1,SATBIT(TAC)
NoStructure,<
	LDB TAC,PUNIT
	SETOM SATMOD(TAC)		;FLAG SAT TABLE NEEDS OUTPUT
	MOVE TAC,SATADR(TAC)
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SETOM ST.SMD(TAC)		;FLAG SAT TABLE NEEDS OUTPUT
	MOVE TAC,ST.SAD(TAC)
>;IfStructure
	XORM AC1,SATCHK(TAC)		;UPDATE CHECKSUM.
	SOS DSKUSE(TAC)			;DECREASE COUNT
	POPJ P,

MRKBLK:
NoStructure,<
	LDB AC1,PUNIT
	CAMG TAC,LSTBTB(AC1)		;SKIP IF INVALID BLOCK.
	SOJGE TAC,.+2			;REMOVE EXCESS 1 AND JUMP IF VALID
	POPJ P,				;INVALID BLOCK
	IDIVI TAC,44
	ADD TAC,SATADR(AC1)
>;NoStructure
IfStructure,<
IFN FTRH,<
	LDB AC1,PUNIT
	CAMLE AC1,[UPACKS]
	JRST RMRKRC			;use RH-SAT Mark routine
>;IFN FTRH
	MOVE AC1,SDBPTR(DDB)
	CAMG TAC,ST.BTB(AC1)		;SKIP IF INVALID BLOCK.
	SOJGE TAC,.+2			;REMOVE EXCESS 1 AND JUMP IF VALID
	POPJ P,				;INVALID BLOCK
	IDIVI TAC,44
	ADD TAC,ST.SAD(AC1)
>;IfStructure
	MOVEI AC1,1
	ROT AC1,(TAC1)
	TDNE AC1,SATBIT(TAC)
	POPJ P,				;ALREADY ON!
	IORM AC1,SATBIT(TAC)
NoStructure,<
	LDB TAC,PUNIT
	SETOM SATMOD(TAC)		;FLAG SAT TABLE NEEDS OUTPUT
	MOVE TAC,SATADR(TAC)
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SETOM ST.SMD(TAC)		;FLAG SAT TABLE NEEDS OUTPUT
	MOVE TAC,ST.SAD(TAC)
>;IfStructure
	XORM AC1,SATCHK(TAC)		;UPDATE CHECKSUM.
	AOS DSKUSE(TAC)			;DECREASE COUNT
	POPJ P,

REPEAT 0,<		;This code is not called anywhere

CSATID:	PUSH P,DDB
	MOVE DDB,C1DDBS
	LDB TAC,PUNIT
	POP P,DDB
	JUMPN TAC,CPOPJ			;DON'T BOTHER CHECKING SATID FOR UDPS
	MOVE TAC,SATID+SATTAB
	CAMN TAC,SATID1
	CAME TAC,SATID2
	CAIA
	POPJ P,
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	 [ASCIZ /BACKUP SATID'S DISAGREE.
SATID = /]
	 DISARG OCH,SATID+SATTAB
	 [ASCIZ /
SATID1 = /]
	 DISARG OCH,SATID1
	 [ASCIZ /
SATID2 = /]
	 DISARG OCH,SATID2
	 [ASCIZ /
YOU MUST GET A WIZARD!
/]
	 -1
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCAL
	JRST CSATID

;CALLED FROM ERROR2 IN DSKERR INSIDE PUSHACS
MRKBAD:	MOVE DDB,C1DDBS
	SKIPGE TAC,DSKLRN(DDB)
	POPJ P,				;IF SAT OR SWAP IGNORE.
NoStructure,<
	LDB AC1,PUNIT			;DOUBLE CHECK THAT THERE'S A SAT
	SKIPG AC1,SATADR(AC1)
>;NoStructure
IfStructure,<
	MOVE AC1,SDBPTR(DDB)
	SKIPG AC1,ST.SAD(AC1)
>;IfStructure
	POPJ P,				;ELSE FORGET IT
	SKIPN TAC1,BADCNT(AC1)		;GET NUMBER OF ENTRIES IN TABLE
	JRST MRKBD1			;NONE YET
	CAILE TAC1,BADMAX		;ONLY CHECK EXISTING TABLE
	MOVEI TAC1,BADMAX
MRKBD0:	MOVEI AC2,(AC1)
	ADDI AC2,(TAC1)
	CAMN TAC,BADTRK-1(AC2)		;IS THIS BAND ALREADY IN TBL ?
	POPJ P,				;YES. DON'T ENTER IT AGAIN.
	SOJG TAC1,MRKBD0
MRKBD1:	AOS TAC1,BADCNT(AC1)		;INC. NO. OF BAD TRACKS IN TABLE.
	CAIGE TAC1,BADMAX		;TOO MANY FOR ONE UNIVERSE ?
	JRST MRKBD2			;NO, GO ON
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
IFKL10,< ASCIZ /TOO MANY BAD DISK TRACKS.  Get a wizard, or type RN<cr>
/>;IFKL10
NOKL10,< ASCIZ /TOO MANY BAD DISK TRACKS.  Get a wizard, or push CONTINUE.
/>;NOKL10
	PUSHJ P,DISFLUSH
	HALT CPOPJ

MRKBD2:	ADDI TAC1,(AC1)
	MOVEM TAC,BADTRK-1(TAC1)	;ADD CURRENT TRACK TO BAD TRACK TABLE.
	ADDM TAC,BADCHK(AC1)		;UPDATE THE CHECKSUM.
	PUSH P,BADCNT(AC1)		;(MRKBLK CLOBBERS AC1)
	PUSHJ P,MRKBLK			;MARK TRACK IN SAT TABLE, SO IT WON'T GET USED
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /NEW BAD DISK TRACK.  BADCNT=/
	POP P,TAC
	PUSHJ P,DISDCP
	PUSHJ P,DISMES
	 ASCIZ /	BADMAX=/
	MOVEI TAC,BADMAX
	PUSHJ P,DISDCP
	JRST DISCRLF

>;REPEAT 0
;DELETE A FILE, FREE DISK BLOCKS ;⊗ DELETE DELFIL DELF2 DELF3 DELBLK DELBK1

DELETE:	PUSHJ P,NEWFIL			;SET UP RTVL FETCH
	MOVEI DAT,DELFIL
	MOVE AC1,FILLNG(DDB)
	CAILE AC1,=50*2000
	JRST NEWAIT			;MARK ALL BLOCKS EMPTY, CLEAR RTVL
	JRST QEWAIT

;*** INTERRUPT SUBR ***

DELFIL:	PUSHJ P,DELBLK
	TRZE IOS,IODTER			;WAS THERE AN ERROR ?
	JRST DSIOS
	MOVE TAC,USETP(DDB)
DELF2:	PUSHJ P,LR2BLK			;RETURN BLOCKS TO SAT
	JUMPE TAC,.+2			;NO SUCH BLOCK
	PUSHJ P,RTNBLK
NoStructure,<
	MOVEI TAC,RCPBLK
	ADDB TAC,USETP(DDB)
	MOVE TAC1,DGRP1R(DDB)
	CAIGE TAC,RCPGRP(TAC1)		;HAVE WE GOT TO NXT GRP?
	JRST DELF2			;STILL IN THIS ONE, CONTINUE
>;NoStructure
IfStructure,<
	MOVE TAC,DD.RPB(DDB)		;number of records per block
	ADDB TAC,USETP(DDB)		;add to USETP to get past this block
	MOVE TAC1,DD.RPG(DDB)
	ADD TAC1,DGRP1R(DDB)		;compute RN at end of this group
	CAMGE TAC,TAC1			;HAVE WE GOT TO NXT GRP?
	JRST DELF2			;STILL IN THIS ONE, CONTINUE
>;IfStructure
DELF3:	SKIPE DNXTGP(DDB)		;IS THERE A NEXT GROUP?
	JRST DELFIL			;YES, DO IT
	POPJ P,

DELBLK:	PUSHJ P,GGRETD			;GET GROUP RETRIEVAL INTO DDB
	PUSHJ P,AUDCHK
	TLZE IOS,LOSBIG
	JRST DELBK1			;DON'T TOUCH THIS BLOCK IF BAD RETRIEVAL
	LDB AC2,PJOBN			;GET JOB # OF LOSER DELETING FILE
	MOVE AC1,JOBNAM(AC2)		;NOW REMEMBER SOMETHING ABOUT HIM
	MOVEM AC1,DQINFO+2(DDB)
	MOVE AC1,PRJPRG(AC2)
	MOVEM AC1,DQINFO+3(DDB)
	SETZM DSATID(DDB)		;JUST CLEAR SATID TO FREE THIS BLOCK
	JRST SPREAD			;AND POOT IT BACK OUT

DELBK1:	TRO IOS,IODTER
	JRST DSIOS
;ERROR HANDLING ;⊗ ENOFIL ENOUFD EPROT EFWRIT EDNAME EXFIL EANAME ENODEV EGARB1 EGARB2 EFULLZ ERRC2 ERRC1 ERZIOS ENTFUL ENTFUL EDFULL ENOENT ENOLUK ELOSE EGARB BADRET BADRE2 EGARC EACMFD EDMPLS

;ERRORS, CLASS 1. ENTER, ETC. RETURN CODES IN E+1

ENOFIL:	JSP TAC,ERRC1		;0 - ZERO FILE NAME
ENOUFD:	JSP TAC,ERRC1		;1 - NO UFD
EPROT:	JSP TAC,ERRC1		;2 - PROTECT VIOLATION
EFWRIT:	JSP TAC,ERRC1		;3 - FILE BEING WRITTEN
EDNAME:	JSP TAC,ERRC1		;4 - NAME IN USE
EXFIL:	JSP TAC,ERRC1		;5 - NO LOOKUP OR ENTER - RENAME
				;    OR LOOKUP WHILE STILL WRITING
EANAME:	JSP TAC,ERRC1		;6 - ENTER (ALTER) NAME DISAGREES
ENODEV:	JSP TAC,ERRC1		;7 - NO DEVICE (NO INIT)
EGARB1:	JSP TAC,ERRC2		;10 - GARBAGED UFD (POINTER OUT OF RANGE)
				;  - AND OLD UDPS ACCESSED BY NEW UDPSER
EGARB2: JSP TAC,ERRC2		;11 - GARBAGED FILE (POINTER WRONG)
EFULLZ:	JSP TAC,ERRC1		;12 - DISK IS FULL, TRY AGAIN LATER

ERRC2:	TRNN IOS,GARBIT			;SUPPRESS "BAD RTVL" MESSAGE??
	JRST EGARB			;NO. NOT A SPECIAL PERSON.
	TRNE IOS,IODERR!IODTER
	JRST ERRC1			;hardware disk error of some sort
	PUSHACS
	PUSHJ P,BADRET			;type msg on cty for bad retr
	POPACS
ERRC1:	SUBI TAC,ENOFIL+1		;GET ERROR CODE
	XCTR XRW,[HRRM TAC,ERRBOX(UUO)]	;STUFF ERROR CODE
	ANDI TAC,-1
	CAIE TAC,11			;ALLOW RENAME OF FILE WITH BAD RETRIEVAL
	SETZM FILNAM(DDB)		;DISABLE RENAME.
ERZIOS:	TLZ IOS,GOBIT!LOSBIG!READB!WRITEB!ALTERB
	SETZM DGRP1R(DDB)		;ANY RTVL WE HAVE IS CONSIDERED STALE
	JRST DPOPJ			;TUCK IOS AWAY. DON'T LET USER DO ANYTHING.

;ERRORS, CLASS 2. FLUSH USER, GO TO SYSTEM.

REPEAT 0,<	;BUGGY?  CLOBBERS UFD RETRIEVAL!
ENTFUL:	TRNE IOS,GARBIT			;IS HE ENABLED FOR DIRECT RETURN?
	JRST EFULLZ			;YES. GIVE FUNNY ERROR CODE
	PUSHJ P,EDFULL			;STOP HIM
	JRST DENTER			;TRY IT AGAIN
>;REPEAT 0

ENTFUL:	PUSHJ P,EFULLZ			;GIVE FUNNY ERROR CODE
	TRNE IOS,GARBIT			;IS HE ENABLED FOR DIRECT RETURN?
	POPJ P,				;YES. DO IT
EDFULL:	PUSH P,IOS			;SAVE THE RELEVANT ACS
	PUSHJ P,DPOPJ			;CLEAR GOBIT IF SET AND SAVE ITS STATE
	PUSH P,DDB
	PUSHJ P,TTYFUW			;FIND TTY
	PUSHJ P,INLMES
	 ASCIZ /
Disk is FULL!/;  Type CONTINUE to try again/
	PUSHJ P,PRCRCC			;TYPE CRLF ↑C
	PUSHJ P,TTYSTC			;SET TTY INTO COMMAND MODE.
	PUSHJ P,STOP1			;STOP THE JOB
	POP P,DDB
	POP P,IOS			; RESTORE THE ACCUMULATORS
	POPJ P,				; AND RETURN TO SENDER.

ENOENT:	JSP TAC,ERRPTU
	 ASCIZ /Need ENTER before OUTPUT/
	JRST EXCALP

ENOLUK:	JSP TAC,ERRPTU
	 ASCIZ /Need LOOKUP before INPUT/
	JRST EXCALP

ELOSE:	POP P,TAC			;RETURN ADDRESS TO TAC.
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	 ASCIZ /  ERROR IN DSKSER - CALLED FROM /
	MOVE TAC,TAC-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCALL		;STOP AND LOOK
	JSP TAC,ERRPTU
	 ASCIZ /Error in DSKSER/
	JRST EXCALP

EGARB:	PUSHJ P,ERZIOS			;HOLD ALL I/O.
	TRNE IOS,IODTER!IODERR		;MACHINE OR DATA ERRORS?
	JRST EGARC			;disk screwed up
	PUSHJ P,BADRET			;type bad retr msg on cty
	JSP TAC,ERRPTU			;type msg on job's tty
	 ASCIZ /Bad retrieval/
	JRST EXCALP

;Record bad retrieval filename on cty.
BADRET:	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /BADRET/
	PUSHJ P,DISMES
	 ASCIZ /Bad retrieval: found "/
	MOVEI TAC,DDNAM(DDB)		;print name found in retr on disk
	PUSHJ P,DISFIL
	PUSHJ P,DISMES
	 ASCIZ/" when trying to get "/
	MOVS TAC1,DEVNAM(DDB)
	CAIN TAC1,'DSK'			;don't bother with device if DSK
	JRST BADRE2
	MOVE TAC1,DEVNAM(DDB)
	PUSHJ P,DISSIX			;PRINT DEVICE NAME (UDP)
	PUSHJ P,DISMES
	 ASCIZ/(/
	MOVE TAC1,DSATID(DDB)		;GET SATID (UDP NAME)
	PUSHJ P,DISSIX
	PUSHJ P,DISMES
	 ASCIZ/):/
BADRE2:	MOVEI TAC,ACCNAM(DDB)		;print filename we were expecting
	PUSHJ P,DISFIL
	PUSHJ P,DISMES
	 ASCIZ/"
/
	POPJ P,

EGARC:	JSP TAC,ERRPTU
	 ASCIZ /Disk transmission error/
	JRST EXCALP

EACMFD:	JSP TAC,ERRPTU
	 ASCIZ /Can't ENTER or RENAME MFD/
	JRST EXCALP

EDMPLS:	JSP TAC,ERRPTU
	 ASCIZ /Illegal format dump mode command list/
	JRST EXCALP
;USER DISK PACK SERVICE ;⊗ UDPINI UDPDSP UDPMTP UDPIN SXUDIN UDPOUT SXUDOU UDPSER UDPSE1 UDPSE2 UDPS2A UDPS2C UDPS2B UDPSE3 UDPSE5 UDPSE4

IFN UPACKS,<
;SYSTEM INITIALIZATION:
; CLEAR DEVIOS FOR EACH UDP
; SET DVDSK IN DEVMOD - DEFAULT NEW STYLE
; LINK MODEL DDBS TOGETHER, LINKING OUT COPIED DDBS THAT WERE IN FREE STG

UDPINI:	MOVSI TAC1,DVDSK
	MOVEI TAC,DSKDSP
FOR @$ UNUM←1,UPACKS
<	SETZM UDP$UNUM$DD+DEVIOS
	IORM TAC1,UDP$UNUM$DD+DEVMOD		;INITIALLY DVDSK IN UDP DDBS
IFN UNUM-1,<
	HRLI TAC,UDP$UNUM$DD
	MOVEM TAC,DEVSER+CAT(CAT(UDP,\<UNUM-1>),DD)
>>
	HRLI TAC,UDP1.NX	;Address of first DDB after UDPs
	MOVEM TAC,DEVSER+CAT(CAT(UDP,\UPACKS),DD)
	POPJ P,

	POPJ P,			;SETSTS - FOR OLD UDP, ONLY DUMP MODE IS LEGAL
	JRST CLRDDB		;GIVE BACK DDB
	JRST SETDDB		;MAKE DDB
	JRST UDPINI		;INITIALIZE
	JRST DHUNG		;HUNG TIMEOUT
↑UDPDSP:JRST ERZIOS		;RELEASE, DISABLE WRITE
	JRST ERZIOS		;CLOSE OUTPUT, SAME
	JRST UUOERR		;BUFFERED OUTPUT
	JRST UUOERR		;BUFFERED INPUT
	JRST PASSIT		;ENTER, CHECK PASS WORD
	JRST UUOERR		;LOOKUP
	JRST UDPOUT		;DUMP OUTPUT
	JRST UDPIN		;DUMP INPUT
	JRST UUOERR		;USETO
	JRST UUOERR		;USETI
	JRST UUOERR		;UGETF
	JRST PASSET		;RENAME, SET PASS WORD
	POPJ P,			;CLOSE INPUT
	POPJ P,			;UTPCLR
IFE FTSIX,<
	JRST UUOERR		;MTAPE
>;IFE FTSIX
IFN FTSIX,<
	JRST UDPMTP		;MTAPE

UDPMTP:	PUSHJ P,WAIT1			;FINISH ANYTHING IN PROGRESS
	XCTR XR,[MOVE TAC,(UUO)]	;PICK UP FIRST ARG
	CAME TAC,['GODMOD']		;REQUESTING NEW GOD MODE
	JRST UUOERR
	ADDI UUO,1
	XCTR XR,[HRRZ TAC,(UUO)]
	CAIE TAC,GDSXRD-GODDIS		;MUST BE READ P3 OR ...
	CAIN TAC,GDSXWR-GODDIS		; ... WRITE P3 MEMORY
	JRST @GODDIS(TAC)		;Ok.  Go do it.
	JRST UUOERR
>;IFN FTSIX

;Just for the record, if you try to read multiple tracks from the UDP in
;OLD mode in one operation, the C1 reads 19. tracks (with heads already
;positioned) in 57. ticks (thus missing TWO revolutions per track!), since
;in OLD mode each track is read starting at record 0 (wrap record = 0).  If
;the wrap record is record 1 instead, then the C1 can read 19. tracks in
;21. ticks (much faster!).

UDPIN:
IFN FTSIX,<
	SETZM IOWDSX(DDB)
SXUDIN:	
>;IFN FTSIX
	MOVEI TAC1,DUSER!DUDPOP
	JRST UDPSER

UDPOUT:
IFN FTSIX,<
	SETZM IOWDSX(DDB)
SXUDOU:
>;IFN FTSIX
	TLNN IOS,WRITEB			;ENTER DONE?
	JRST ENOENT			;NO
	MOVEI TAC1,DWRITE!DUSER!DUDPOP
UDPSER:	MOVSM TAC1,TFRCTL(DDB)
	PUSHJ P,UDPCOR			;MAKE SURE THERE IS A PROGRAM HEADER
IFN FTSIX,<
	SKIPN TAC1,IOWDSX(DDB)		;PDP-6 operation?
	JRST UDPSE1			;No
	HLRE TAC,TAC1			;-WC
	MOVEI TAC1,1(TAC1)		;MA
	JRST UDPSE2
>;IFN FTSIX

UDPSE1:	XCTR XR,[SKIPL (UUO)]		;DMPCMD DOES BRANCHING. SKIP IF IOWD.
	JRST ADRERR
	PUSHJ P,DMPCMD			;ADDRESS CHECK IOWD
	 POPJ P,			;(END OF LIST - CAN'T HAPPEN)
UDPSE2:	MOVE AC1,TFRCTL(DDB)		;READ OR WRITE?
	TLNN AC1,DWRITE			;SKIP IF WRITE.
	JUMPL TAC1,UADRER		;READING. JUMP IF CORE WRITE PROTECTED.
	HRL TAC1,TAC			;-WC INTO LEFT
	MOVEM TAC1,TFRIOW(DDB)
NoStructure,<
	CAMGE TAC,[-BLKWDS*TRKCYL]	;SKIP IF FITS IN 1 CYLINDER
	JRST ADRERR
	XCTR XR,[HRRZ TAC1,1(UUO)]	;GET UDP BLOCK ADDR.
	LDB DAT,PUNIT
	MOVE DAT,NCYL+FPACKS-1(DAT)	;NUMBER OF CYLS ON THIS PACK
	IMULI DAT,BKPTRK*TRKCYL		;MULTIPLY TO GET TOTAL NUMBER OF BLOCKS
	CAIL TAC1,(DAT)			;TOO BIG?
	JRST UADRER			;NO GOOD.
;	MOVE TAC,JBTPRV(J)
;	TLNN TAC,UDPPRV			;ALLOW PRIVILEGED USER TO SEE LAST BLOCK
;	CAIE TAC1,-1(DAT)		;LAST LOGICAL BLOCK?
;	CAIA				;SPECIAL USER, OR NOT THE LAST BLOCK
;	JRST UADRER
	LDB TAC,PUNIT			;GET UNIT NUMBER
	ADD TAC1,BFSET(TAC)		;KLUGE UP START ADDR OF UDP.
	LSH TAC1,6			;PRETEND RECORD ZERO.
	XCTR XR,[HLRZ TAC,1(UUO)]
	CAILE TAC,RCPBLK		;LEGAL RECORD NUMBER?
	JRST UADRER
	IOR TAC1,TAC			;OR IT IN
	MOVEM TAC1,TFRSEC(DDB)
>;NoStructure

IfStructure,<
IFN FTRH,<
	LDB	DAT,PUNIT		;Get the unit number
	CAMG	DAT,[UPACKS]		;is this old-style?
	JRST	UDPS2A			;Yes.
	XCTR	XR,[SKIPGE TAC1,1(UUO)]	;Get Full wd Disk address. 
	JRST	UADRER			;Don't want absolute here
	LDB	AC3,[POINT 5,TAC1,5]	;Get the structure number
	CAME	AC3,DAT			;Same as unit number?
	JUMPN	AC3,UADRER		;No.  If non-zero, an error (zero defaults)
	PUSHJ	P,STRADR		;convert structure & record to absolute
	JUMPE	TAC1,UADRER		;jump if can't translate disk address
	MOVEM	TAC1,TFRSEC(DDB)	;disk address Chan/Unit/record to DDB
	PUSHJ	P,GETUDB		;Get the UDB for TAC1 into AC3
	JUMPE	AC3,UADRER		;Jump if no such channel/Unit
	MOVE	AC1,UDBSIZ(AC3)		;Pointer to the size table
	LDB	TAC,[POINT 29,TAC1,35]	;Get the in-unit record number
	CAML	TAC,SECUNT(AC1)		;Skip if legal record number.
	JRST	UADRER			;No such record on this unit.
	IDIV	TAC,SECCYL(AC1)		;Divide by Rec per Cyl. TAC1 is REC in CYL
	HLRO	TAC,TFRIOW(DDB)		;-WC
	MOVN	TAC,TAC
	ADDI	TAC,RECSIZ-1
	LSH	TAC,-RECWSH		;number of records in transfer
	ADD	TAC1,TAC		;compute end of transfer in R past Cyl Org
	CAMLE	TAC1,SECCYL(AC1)	;skip if within one cylinder
	JRST	UADRER			;Not contained within one CYL
	JRST	UDPS2B
>;IFN FTRH

;Structured, NON-RH disks
UDPS2A:	MOVE	AC3,SDBPTR(DDB)		;Point to the SDB
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;Get UDP block number
	CAML	TAC1,ST.LSA(AC3)	;Within legal addresses?
	JRST	UADRER			;no.
	ADD	TAC1,ST.BFS(AC3)	;KLUGE UP START ADDR OF UDP.
	LSH	TAC1,6			;PRETEND RECORD ZERO.
	XCTR	XR,[HLRZ AC1,1(UUO)]	;get the record number if any
	CAMLE	AC1,DD.RPB(DDB)		;LEGAL RECORD NUMBER?
	JRST	UADRER
	IOR	TAC1,AC1		;OR IT IN
	MOVEM	TAC1,TFRSEC(DDB)	;Starting disk address
;Compute how many words from here to end of the cylinder.
	XCTR	XR,[HRRZ TAC,1(UUO)]	;Get the starting block number
	MOVE	AC2,ST.TYP(AC3)		;Get the pointer to disk physical type
	IDIV	TAC,UNIBPC(AC2)		;Divide by blocks per cylinder
	SUB	TAC1,UNIBPC(AC2)	;TAC1:=negative # of blks left to CYL end
	MOVNI	TAC,RECSIZ		;-record size
	IMUL	TAC,UNIRPB(AC2)		;*number of data records per block
	SUB	TAC,UNIRTS(AC2)		;- physical size of rtvl record = -blk size
	IMUL	TAC,TAC1		;# of words from start of blk to CYL end
	LDB	TAC1,[POINT 6,TFRSEC(DDB),35]	;Get the record number
	JUMPE	TAC1,UDPS2C		;Easy!
	SUB	TAC,UNIRTS(AC2)		;first record is rtvl.
	SUBI	TAC1,1			;Count down.  We did rtvl record already
	LSH	TAC1,RECWSH		;Convert balance of records
	SUB	TAC,TAC1
UDPS2C:	HLRO	TAC1,TFRIOW(DDB)	;TAC has # of words to CYL end
	MOVN	TAC1,TAC1		;TAC1 has # of words in this transfer
	CAMGE	TAC,TAC1		;Skip if xfer fits in this CYL
	JRST	ADRERR
>;IfStructure

UDPS2B:	PUSHJ P,GOSET
	SETOM DDLOC(DDB)		;FLAG A MULTI-TRACK, UDP XFER
IFN FTSIX,<
	SKIPE IOWDSX(DDB)
	JRST UDPSE3
>;IFN FTSIX

IFKL10,<
IFN FTRH,<
	LDB DAT,PUNIT
	CAMLE DAT,[UPACKS]
	JRST UDPSE3			;RH-Based disks don't need sweep
>;IFN FTRH
;;;	NOCACHE (CSHDSK)
	TLNE AC1,DWRITE
	PUSHJ P,VALCOR			;IF WRITING, JUST VALIDATE CORE
	TLNN AC1,DWRITE
	PUSHJ P,SWEEPA			;IF READING, SWEEP ENTIRE CACHE
;see comments for dump mode input and output
>;IFKL10

UDPSE3:	MOVEI DAT,TSTART		;Could be a multi-track transfer
	PUSHJ P,UEWAIT
IFN FTSIX,<
	SKIPN IOWDSX(DDB)
	JRST UDPSE5
	MOVE AC1,TFRCTL(DDB)
	TLNE AC1,DWRITE
	JRST UDPSE4
	MOVE AC1,ECCSIX(DDB)
	XCTR XW,[MOVEM AC1,-1(UUO)]
	MOVE AC1,ECCLOS(DDB)
	XCTR XW,[MOVEM AC1,(UUO)]
	JRST UDPSE4
UDPSE5:
>;IFN FTSIX

;;;	CACHE (CSHDSK)

UDPSE4:	SETZM DDLOC(DDB)
	JRST DPOPJ

>;IFN UPACKS
;UDP PASS WORD STUFF ;⊗ GPASIN PASSIT PASSI1 PASSET PASSE1 PASSIN PASOUT CHKSAT

IFN UPACKS,<
GPASIN:	MOVEI DAT,PASSIN		;READ PASSWORD BLOCK
	PUSHJ P,NEWAIT
	TRNE IOS,IODERR!IODTER		;ERRORS?
	JRST EGARB1			;YES
	MOVE TAC,['PASS  ']		;CHECK FOR INITIALIZATION
	CAMN TAC,DSKDAT(DDB)
	CAME TAC,DSKDAT+1(DDB)
	JRST CPOPJ1			;NOT INITIALIZED. LET HIM IN
	MOVEI DAT,CHKSAT		;Read IDSAT word and return it in TFRSEC
	PUSHJ P,NEWAIT			;CAUSE SAT TO BE READ AND WAIT FOR IT.
	MOVE TAC,TFRSEC(DDB)		;IDSAT RETURNED HERE
	CAME TAC,['SATID ']
	POPJ P,
	JSP TAC,UUOMES
	 ASCIZ /Illegal old-style access to new format UDP. UUO /

PASSIT:	PUSHJ P,UDPCOR			;GET CORE FOR PROGRAM HEADER
	MOVE TAC,JBTPRV(J)
;	TLNE TAC,UDPPRV			;LET DUMPER THROUGH (1,2)
;	JRST PASSI1
	TLZ IOS,WRITEB			;LOSE FOR NOW
	PUSHJ P,GPASIN			;READ PASSWORD BLOCK. SKIP IF NONE THERE
	SKIPN TAC,DSKDAT+2(DDB)		;MAY NOT BE NECESSARY
	JRST PASSI1			;BLANK PASSWORD, OR NO PASS BLOCK
;	CAME TAC,['*SWAP*']		;ALLOW WRITE ACCESS TO SCRATCH PACK
;	XCTR XR,[CAMN TAC,(UUO)]	;GET PASSWORD FROM USER
PASSI1:	TLOA IOS,WRITEB			;ALLOW WRITE ACCESS
	JRST EPROT			;PROTECTION FAILURE
	JRST DPOPJ1

PASSET:	PUSHJ P,UDPCOR			;GET CORE FOR PROGRAM HEADER
	MOVE TAC,JBTPRV(J)
;	TLNE TAC,UDPPRV			;LET DUMPER IN ALWAYS(1,2)
;	JRST PASSE1
	TLZN IOS,WRITEB			;CAN HE DO THIS?
	JRST ENOENT			;NO
	PUSHJ P,GPASIN			;READ PASSWORD BLOCK, SKIP IF NONE
	SKIPA TAC,DSKDAT+2(DDB)
	JRST PASSE1			;NO PASSBLOCK - LET'S MAKE ONE
	CAMN TAC,['*SWAP*']
	JRST EPROT			;CAN'T CHANGE PASSWORD OF SWAPPING PACK
PASSE1:	MOVE TAC,['PASS  ']
	MOVEM TAC,DSKDAT(DDB)
	MOVEM TAC,DSKDAT+1(DDB)
	XCTR XR,[MOVE TAC,(UUO)]	;GET NEW PASS WORD!
	MOVEM TAC,DSKDAT+2(DDB)
	SETZM DSKDAT+3(DDB)
	HRRI TAC,DSKDAT+3(DDB)
	HRL TAC,TAC
	ADDI TAC,1
NoStructure,<
	BLT TAC,DSKDAT+SECSIZ-1(DDB)	;CLEAR THE REST
>;NoStructure
IfStructure,<
	MOVEI DAT,DSKDAT-1(DDB)
	ADD DAT,DD.SSZ(DDB)		;calc last address of rtvl info
	BLT TAC,(DAT)
>;IfStructure
	MOVEI DAT,PASOUT		;WRITE IN PASS WORD BLOCK
	PUSHJ P,NEWAIT
	TRNE IOS,IODERR!IODTER		;ERRORS?
	JRST EGARB1
	JRST PASSI1			;OK

;****** I-LEVEL SUBR ******
PASSIN:	TDZA	TAC,TAC				;READ
PASOUT:	MOVEI	TAC,DWRITE			;WRITE
	MOVSM	TAC,TFRCTL(DDB)
NoStructure,<
	MOVEI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
	HRLI	TAC,-SECSIZ
	MOVEM	TAC,TFRIOW(DDB)
	MOVE	TAC,NCYL+FPACKS-1(TAC1)
	IMULI	TAC,BKPTRK*TRKCYL	;NUMBER OF Blocks ON THIS PACK
	SUBI	TAC,1
	LDB	TAC1,PUNIT
	ADD	TAC,BFSET(TAC1)		;ADD BASE ADDRESS
	LSH	TAC,6			;RECORD 0
	MOVEM	TAC,TFRSEC(DDB)
	JRST	TSTART			;DO IT  RTVL-size operation
>;NoStructure
IfStructure,<
	MOVN	TAC,DD.SSZ(DDB)		;-size of rtvl area
	HRLZ	TAC,TAC
	HRRI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
	MOVEM	TAC,TFRIOW(DDB)
	MOVE	AC3,SDBPTR(DDB)
	MOVE	TAC,ST.BTB(AC3)		;Last legal block number on pack
	ADD	TAC,ST.BFS(AC3)		;ADD BASE ADDRESS
	PUSHJ	P,BK2SEC		;Convert to track & sector
	MOVEM	TAC,TFRSEC(DDB)
	JRST	TSTART			;DO IT.  RTVL-size operation
>;IfStructure

;Read SAT into SYSBUF
CHKSAT:	SETZM TFRCTL(DDB)
NoStructure,<
	LDB TAC,PUNIT
	MOVE TAC,BFSET(TAC)			;DISK ADDRESS OF SAT TABLE
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)
	MOVE TAC,ST.STA(TAC1)			;STR relative addr of SAT track
	ADD TAC,ST.BFS(TAC1)			;Offset to unit org
>;IfStructure
	PUSHJ P,BK2SEC				;CONVERT BLOCK TO SECTOR
	MOVEM TAC,TFRSEC(DDB)
	PUSHJ P,STSTA1				;SYSBUF TRANSFER
	HRRZ TAC,DD.SBB(DDB)			;Address of correct SYSBUF
	MOVE TAC,IDSAT(TAC)
	MOVEM TAC,TFRSEC(DDB)
	POPJ P,
>;IFN UPACKS
;⊗ PQIN PQINNS PQIN2 PQIN1 PQIN1B PQIN1A PQIN3 PQINSW PQINSE PQOUT PQOUT1 PQOUT2 PQOUT3 PQOUT5 PQOUT4 PQOUT6 PQOUT7 PQOUT8

;PACK QUEUE FORMAT AND ALGORITHM:

;PQUEUE IS A TABLE OF POINTERS, ONE FOR EACH DRIVE.
;EACH POINTER POINTS TO THE HEAD OF A LIST OF DDBS CORRESPONDING
;TO TRANSFERS FOR THAT DRIVE.  THE LIST IS LINKED BOTH WAYS THROUGH
;THE DDB.  THE LIST IS KEPT SORTED BY DESIRED CYLINDER NUMBER.
;EACH ENTRY ALSO HAS THE TIME IT WAS WRITTEN IN THE QUEUE.
;A ZERO PQUEUE ENTRY MEANS AN EMPTY QUEUE.

;PCURCY IS A TABLE OF CURRENT CYLINDER POSITIONS FOR EACH DRIVE.

;PTARG IS A TABLE OF TARGET DDBS FOR EACH DRIVE.  FOR A GIVEN DRIVE,
;THE PCURCY AND PTARG ENTRIES DEFINE A WINDOW OF CYLINDERS AND A
;DIRECTION.  THE ENTRY THAT IS REMOVED FROM THE QUEUE IS THE ONE WITHIN
;THE WINDOW THAT IS NEAREST THE CURRENT POSITION.  THE CURRENT POSITION
;IS UPDATED AND THE PROCESS REPEATS.  IT THE TARGET DDB IS REMOVED FROM
;THE QUEUE, THEN A NEW TARGET IS COMPUTED BY SELECTING THE OLDEST ENTRY
;IN THE QUEUE.

;IN THE DISK DDB THE FOLLOWING ARE THE DEFINITIONS FOR LINKING PACK QUEUE
;ENTRIES:
;	PQFOR		;PACK QUEUE FORWARD POINTER
;	PQBAK		;PACK QUEUE BACKWARD POINTER
;	PQTIM		;PACK QUEUE ENTRY TIME
;	PQCYL		;PACK QUEUE DESIRED CYLINDER
;	PQPACK		;PACK QUEUE PACK NUMBER
;	PQHHR		;PACK QUEUE HEAD,,<WRAP REC>⊗9+<REC>

;ENTER A REQUEST INTO THE APPROPRIATE PACK QUEUE
;CALL WITH PQCYL AND PQPACK SET UP IN THE DDB
PQIN:	SKIPGE TFRSEC(DDB)		;SKIP UNLESS A SWAP REQUEST
	JRST PQINSW
REPEAT 0,<				;New scheme to allocate system buffers
;This code, now discarded, is a remanent of the per-pack SYSBUF.
;If the current request is a SYSBUF request and this DDB is the current
;owner of this pack's SYSBUF (RH of PSYSBF(pack) = DDB) and if the
;disk address of this request matches that of the previous SYSBUF request
;(PQCYL(DDB) and PQHHR(DDB) match contents of PSYSBA(pack)) then
;this request is given high priority, by setting the left half of PSYSBF
;to -1.  If not all of the above are true, if this DDB owns SYSBUF for any
;pack, that ownership is relinquished.
;
;In the new way of doing things, an interrupt subroutine is assigned a
;SYSBUF for its duration.  No special priority applies.
	MOVE TAC,TFRCTL(DDB)
	TLNN TAC,DSYSBF			;SKIP IF WE ARE MAKING A SYSBUF REQUEST
	JRST PQINNS
	MOVE TAC,PQPACK(DDB)
	HRRZ TAC1,PSYSBF(TAC)		;GET SYSBUF FLAG FOR REQUESTED PACK
	HRRZ AC1,PQCYL(DDB)
	HLL AC1,PQHHR(DDB)		;DISK ADDRESS OF NEW TRANSFER
	CAMN AC1,PSYSBA(TAC)		;SKIP IF NEW XFER IS TO DIFFERENT ADDRESS
	CAIE TAC1,(DDB)			;IS A NEW REQUEST FROM THE SAME DDB?
	JRST PQINNS			;NO, JUST QUEUE IT
	HRROS PSYSBF(TAC)		;YES, FLAG IT TO DO NEXT
	POPJ P,

PQINNS:
	PUSHJ P,C1DSCN			;SEE IF THERE ARE ANY OLD SYSBUF REQS
	 CAIA				;NONE
	SETZM PSYSBF(TAC)		;FLUSH IT (WILL DO A C1GO LATER)
					;TGO is the only caller of PQIN
>;REPEAT 0
	AOS DQCNT
	MOVE TAC,UPTIME
	MOVEM TAC,PQTIM(DDB)		;STORE TIME OF ENTRY INTO QUEUE
	MOVE TAC,PQPACK(DDB)		;GET PACK NUMBER = QUEUE TABLE INDEX
	SKIPN TAC1,PQUEUE(TAC)		;SKIP IF QUEUE IS NON-EMPTY
	JRST PQIN1			;START A NEW QUEUE
	MOVE AC1,PQCYL(DDB)		;GET DESIRED CYL OF NEW ENTRY
	SKIPA AC2,TAC1
PQIN2:	MOVE TAC1,AC2
	CAMGE AC1,PQCYL(AC2)		;KEEP GOING IF IT'S NOT LESS THAN THIS ONE
	JRST PQIN3
	SKIPE AC2,PQFOR(AC2)
	JRST PQIN2
PQIN1:	SETZM PQFOR(DDB)		;INSERT NEW ENTRY AFTER TAC1
PQIN1B:	MOVEM TAC1,PQBAK(DDB)
	JUMPE TAC1,PQIN1A
	HRRZM DDB,PQFOR(TAC1)
	POPJ P,

PQIN1A:	HRRZM DDB,PQUEUE(TAC)		;SET HEAD OF QUEUE POINTER TO POINT TO ENTRY
	POPJ P,

PQIN3:	MOVEM TAC1,PQFOR(DDB)
	MOVE TAC1,PQBAK(AC2)
	HRRZM DDB,PQBAK(AC2)
	JRST PQIN1B

PQINSW:	MOVE TAC,PQPACK(DDB)		;GET PACK NUMBER
	SKIPE PSWAPR(TAC)
	PUSHJ P,PQINSE			;LAST VALUE NOT CLEARED OUT YET
	HRRZM DDB,PSWAPR(TAC)		;STORE AS SWAPPING REQUEST FOR PACK
	POPJ P,

PQINSE:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /PSWAPR NOT ZERO FOR PACK /
	MOVE TAC,PQPACK(DDB)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ / AT PQINSW
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCAL
	POPJ P,

;FIND THE NEXT REQUEST TO TAKE OUT OF THE PACK QUEUE WHOSE PACK NUMBER IS IN
;TAC.  RETURN THE ENTRY IN DDB AND REMOVE IT FROM THE QUEUE.  SKIP RETURN IF
;THE QUEUE WAS NON-EMPTY.  DOESN'T CLOBBER TAC
PQOUT:	SKIPE DDB,PSWAPR(TAC)		;IS THERE A SWAP REQUEST FOR THIS PACK?
	JRST CPOPJ1			;YES, USE IT
Repeat 0,<
	SKIPGE DDB,PSYSBF(TAC)		;IS THERE A SYSBUF TRANSFER TO DO RIGHT NOW?
	JRST CPOPJ1			;YES, DO IT
>;Repeat 0
	SKIPN TAC1,PQUEUE(TAC)
	POPJ P,
	SKIPN DDB,PTARG(TAC)		;IS THERE A CURRENT TARGET?
	JRST PQOUT6			;NO
	MOVE AC3,PCURCY(TAC)		;CURRENT CYLINDER FOR THIS PACK
	CAMLE AC3,PQCYL(DDB)		;SKIP IF TARGET IS HIGHER THAN CURRENT
	JRST PQOUT2			;TARGET CYLINDER IS SMALLER THAN CURRENT
PQOUT1:	SKIPE AC2,PQBAK(DDB)		;SCAN BACK FROM TARGET UNTIL FIRST ENTRY
	CAMLE AC3,PQCYL(AC2)		;  PAST CURRENT CYL
	JRST PQOUT3
	MOVE DDB,AC2
	JRST PQOUT1

PQOUT2:	SKIPE AC2,PQFOR(DDB)		;SCAN FORWARD FROM TARGET UNTIL FIRST ENTRY
	CAMGE AC3,PQCYL(AC2)		;  BEFORE CURRENT CYL
	JRST PQOUT3
	MOVE DDB,AC2
	JRST PQOUT2

PQOUT3:	CAMN DDB,PTARG(TAC)		;DDB IS THE PICK TO CLICK
	SETZM PTARG(TAC)		;CLEAR PTARG IF WE FINALLY GET THERE
	MOVE TAC1,PQFOR(DDB)		;LINK DDB OUT OF ITS QUEUE
	MOVE AC1,PQBAK(DDB)
	JUMPE AC1,PQOUT4
	MOVEM TAC1,PQFOR(AC1)
PQOUT5:	SOS DQCNT
	JUMPE TAC1,CPOPJ1
	MOVEM AC1,PQBAK(TAC1)
	JRST CPOPJ1

PQOUT4:	MOVEM TAC1,PQUEUE(TAC)
	JRST PQOUT5

PQOUT6:	HRLOI AC1,377777		;OLDEST (SMALLEST) TIME SO FAR
PQOUT7:	CAMG AC1,PQTIM(TAC1)
	JRST PQOUT8
	MOVE DDB,TAC1			;SAVE AS BEST SO FAR
	MOVE AC1,PQTIM(TAC1)		;SAVE AS BEST TIME SO FAR
PQOUT8:	SKIPE TAC1,PQFOR(TAC1)
	JRST PQOUT7
	HRRZM DDB,PTARG(TAC)		;SAVE AS CURRENT TARGET
	JRST PQOUT			;AND START OVER AGAIN
;⊗ PQADDR PQADD2 PQADD3 PQADDL WRAPOK PQANSB PQADD1 PQADE0 PQADE1 PQADE2 PQADE3 PQADDE PQSWL1 PQSWAP PQSWLS PQSWAP PQSWAP C1WHCH

;CALL WITH DDB SET UP, SETS UP PACK NUMBER IN PQPACK(DDB), CYLINDER IN PQCYL(DDB)
;AND HEAD,,<WRAP REC>⊗9+<RECORD> IN PQHHR(DDB)
;This code IS NOT for RH disks.
PQADDR:	SKIPGE TAC,TFRSEC(DDB)
	JRST PQSWAP			;SIGN BIT IN TFRSEC MEANS SWAP OP
	IDIVI TAC,100			;TRACK INTO TAC, RECORD INTO TAC1
	MOVE AC3,TFRCTL(DDB)
	TLNE AC3,DSATOP
	JRST PQADD1			;JUMP IF SAT TABLE OP
	MOVEM TAC,DSKLRN(DDB)		;STORE BLOCK NUMBER
	MOVE AC3,DEVMOD(DDB)
	TLNN AC3,DVDSK			;FILE OP?
	HRROS DSKLRN(DDB)		;NO, DISABLE MRKBAD
IFG BKPTRK-1,<				;ASSEMBLE CODE FOR MULTIPLE BLOCKS/TRACK
	IDIVI TAC,BKPTRK		;DIVIDE BY BLOCKS/TRACKS
>;IFG BKPTRK-1
PQADD2:	CAIL TAC1,RCPTRK		;RECORD OK?
	JRST PQADE3
PQADD3:	CAILE TAC,LSTTRK		;OFF END OF WORLD?
	JRST PQADE0			;LOSER
	MOVSI AC1,-NPACKS		;SEARCH FOR THE PACK CONTAINING THIS TRACK
PQADDL:	CAMLE TAC,PACKAD(AC1)
	AOBJN AC1,PQADDL
	JUMPGE AC1,PQADE1		;THIS IS TOO HORRIBLE TO THINK ABOUT.
	SUB TAC,PACKAD-1(AC1)
	SUBI TAC,1			;AC1=PACK, TAC=TRACK NUMBER ON THAT PACK
	MOVE AC3,DEVMOD(DDB)
IFN FTF2,<
	TRNE TAC1,SWPWRP⊗9		;Maybe already have wrap record set for swap
	JRST WRAPOK			;Yup, don't make it 5 instead of 4!
>;IFN FTF2
	TLNE AC3,DVDSK			;OLD UDP WRAPS TO RECORD 0
	IORI TAC1,1⊗9			;SET WRAP RECORD TO 1
WRAPOK:	MOVEM TAC1,PQHHR(DDB)		;STORE RECORD NUMBER RJ IN RH 
	IDIVI TAC,TRKCYL		;TAC←CYL, TAC1←HEAD
	HRRZM AC1,PQPACK(DDB)
	MOVEM TAC,PQCYL(DDB)
	HRLM TAC1,PQHHR(DDB)		;STORE HEAD NUMBER RJ IN LH
	MOVE TAC,TFRCTL(DDB)		;Get flags
	TLNN	TAC,DSYSB1		;Must we set TFRIOW from assigned buffer?
	POPJ	P,			;no.
	SKIPN	TAC1,DD.SBB(DDB)	;yes. Do so.  Get address of assigned buffer
	JRST	PQANSB			;Bad news
	MOVEM	TAC1,TFRIOW(DDB)	;Set TFRIOW to address this DDB's buffer
	POPJ	P,

PQANSB:	PUSHACS
	PUSHJ	P,DISUSR
	 'PQANSB'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: No system buffer assignment at PQADDR
/
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL

PQADD1:	MOVE AC3,TFRCTL(DDB)
	SETOM DSKLRN(DDB)		;DISABLE MRKBAD
	JUMPN TAC,PQADD2		;DON'T TEST RECORD NUMBER UNLESS TRACK 0
	TLNE AC3,DWRITE			;SAT TABLE FIRST TRACK, IS IT WRITE?
	JUMPN TAC1,PQADE2		;YES, BETTER BE RECORD 0
	JRST PQADD2

PQADE0:	JSP AC1,PQADDE			;Track number out of range
PQADE1:	JSP AC1,PQADDE			;Track number not within PACKAD of any pack
PQADE2:	JSP AC1,PQADDE			;Sat track 0, record number non-zero
PQADE3:	JSP AC1,PQADDE			;Record number too big
PQADDE:	MOVEI AC1,-PQADE0-1(AC1)	;Error index
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	 [ASCIZ /BAD DISK ADDRESS AT PQADDR - FATAL.  Code = /]
	 DISARG LOC,<AC1-20(P)>		;Error index
	 [ASCIZ /
"Track" (TAC) = /]
	 DISARG OCH,<TAC-20(P)>
	 [ASCIZ /   Record (TAC1) = /]
	 DISARG OCH,<TAC1-20(P)>
	 -1
	PUSHJ P,DISCRLF	
PQSWL1:	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	JRST 4,.		;time to reload

IFE FTRH,<			;Not for swapping on the RH based disks
IFE FTDMDP,<
;TAC CONTAINS THE BAND TO SWAP INTO IN THE RIGHT HALF
PQSWAP:	ANDI TAC,777			;KEEP BAND NUMBER
	MOVM TAC1,FINISH		;JOB WE ARE DOING SWAP OP FOR
	LDB AC3,SWPJOB			;JOB OWNING THIS BAND
	CAME AC3,TAC1
	JRST PQSWLS			;BAND DOESN'T BELONG TO US
	MOVE AC3,TAC			;SAVE BAND NUMBER FOR ERROR CHECK
	HRRZ TAC,SWBAND(TAC)		;GET FIRST TRACK NUMBER IN BAND
	HLRE TAC1,TFRIOW(DDB)		;GET - WORD COUNT
	JUMPGE TAC1,PQSWLS		;MUST BE NEGATIVE
	MOVN TAC1,TAC1
	CAILE TAC1,=10*SWDSIZ		;AND MUST BE LESS THAN 10 TRACKS
	JRST PQSWLS
	TRNN AC3,1
	CAIG TAC1,9*SWDSIZ
	CAIA
	JRST PQSWLS			;OR 9 TRACKS IF THE BAND NUMBER IS EVEN
IFN FTF2,<
	MOVEI TAC1,<SWPWRP⊗9>+SWPWRP	;Start at, and wrap to, record 4, page bndry
>;IFN FTF2
IFE FTF2,<
	MOVEI TAC1,1			;START AT RECORD 1
>;IFE FTF2
	HRROM TAC,DSKLRN(DDB)		;DISABLE MRKBAD
	JRST PQADD3			;TAC=TRACK NUMBER, TAC1= RECORD NUMBER+WRAP

PQSWLS:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /LOSSAGE AT PQSWAP - FATAL
/
	JRST PQSWL1
>;IFE FTDMDP
IFN FTDMDP,<
PQSWAP:	MOVEI TAC1,1			;START AT RECORD 1
	HRROM TAC,DSKLRN(DDB)		;DISABLE MRKBAD
	JRST PQADD2
>;IFN FTDMDP
>;IFE FTRH
IFN FTRH,<
PQSWAP:	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 'PQSWAP'
	PUSHJ P,DISMES
	 ASCIZ /Fatal. We're supposed to be using the RH swapper!
/
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL
>;IFN FTRH

;THIS ROUTINE DETERMINES WHICH CHANNEL TO DO THE TRANSFER ON.
;CURRENTLY THERE ARE TWO DRIVE STRINGS, ONE ON EACH CHANNEL.
;THE TABLE C1WCHN IN ALLDAT GIVES THE CHANNEL NUMBER GIVEN THE
;PACK NUMBER
;CALL WITH PACK NUMBER IN TAC, RETURNS CHANNEL NUMBER
;(0 OR 1 FOR C1A OR C1B) IN TAC1
C1WHCH:	MOVE TAC1,C1WCHN(TAC)
	POPJ P,
;SWAPPER INTERFACE ;⊗ DFGO DSKONJ DSSTRT SQGOX SQGOXL SQGO2A SQGO2 SNOERR SWPLZ1 SQBADB SWPLUZ SQGOX SQGOX0

;ENTER HERE FROM SWPSER TO START SWAP OPERATION.
;SERA CONTAINS BAND NUMBER WITH SIGN BIT IF SWAPIN
;SQREQ CONTAINS AN AOBJN POINTER TO THE CORE IMAGE

↑DFGO:	CONO PI,DSKOFF		;CH7 PLAYING AROUND WITH CH6 ACS!
	PUSHJ P,DSSTRT
	MOVSI 17,UUOACS		;RETURN HERE AFTER STARTING XFER
	BLT 17,17		;RELOAD CH7 AC'S (ESP. P)
DSKONJ:	CONO PI,DSKON		;SAFE NOW
	POPJ P,			;EXIT TO SWPXIT

DSSTRT:	POP P,INTRTN
	JSR DSKSV		;SAVE CH7 ACS IN UUOACS
IFE FTDMDP,<
	MOVE DDB,SWPDDB
	MOVEI TAC1,TRIES
	MOVEM TAC1,SERACT
	MOVSI TAC,200000	;PUT IN A BIT...
	IORM TAC,SERA		;TO INDICATE SWAP OP.
	MOVM J,FINISH
>;IFE FTDMDP
	MOVSI P,-C1PDLL
	HRRI P,C1PDL-1(DDB)	;SET UP I-LEVEL PDL
	PUSHJ P,SQGOX		;DO SWAP OP.
	JRST @INTRTN

;SET UP SWAP OPERATION AND EXECUTE IT.
;ENTER WITH DISK ADDRESS (JOB OR BAND NUMBER) IN SERA.  SIGN BIT ON IF SWAPIN.
;SQREQ CONTAINS AN AOBJN POINTER TO THE CORE IMAGE

IFE FTDMDP,<
;DSWAP is used for RH-disks to determine if this is a swap operation,
;since in non-swap operations, the signbit in TFRCTL signifies an
;absolute disk address.  It seems that no current code uses DSWAP
;(Only some code in C1MPIL conditional on demand paging uses it).
SQGOX:	MOVEI DAT,DUSER!DSWAP		;Set user addressing and swapping op.
	SKIPL SERA
	TRO DAT,DWRITE
	MOVSM DAT,TFRCTL(DDB)
	MOVE TAC1,SQREQ
	MOVEM TAC1,SQREQ1
	HLRO TAC1,TAC1
	JRST SQGO2A			;-WC

SQGOXL:	HLRO TAC1,SQREQ1		;Get -WC
	TRNN TAC1,-1			;Anyone there?
	JRST SNOERR			;no. all done.
SQGO2A:	MOVN TAC1,TAC1			;NUMBER OF WORDS BEING TRANSFERRED
	LDB TAC,[POINT 17,SERA,35]	;GET THIS BAND NUMBER
IFE FTRH,<
	MOVEI DAT,9*SWDSIZ		;Assume even band (a short one)
	TRNE TAC,1			;skip unless an odd band.
	MOVEI DAT,=10*SWDSIZ		;Odd bands are 10 tracks long
>;IFE FTRH
IFN FTRH,<
	MOVE DAT,RHSBSZ			;Get the size of a band
>;IFN FTRH
	CAMLE DAT,TAC1			;Does the band exceed request size?
	MOVE DAT,TAC1			;DAT←MINIMUM OF BAND SIZE AND CORE IMAGE
	ADDM DAT,SWPTWC			;Number of words transferred
IFE FTRH,<
	ADDM DAT,IBMTWC
>;IFE FTRH
IFN FTRH,<
	ADDM DAT,RHDTWC
>;IFN FTRH
	MOVE TAC1,DAT
	HRL TAC1,TAC1			;+WC,,+WC
	MOVN DAT,DAT			;-WC
	HRL DAT,SQREQ1			;Mem address in left
	MOVSM DAT,TFRIOW(DDB)		;Store -wc,,mem address
	ADDM TAC1,SQREQ1		;Add WC,,WC to request counter
	ANDI TAC,777			;DISK ADDRESS (BAND NUMBER)
IFE FTRH,<
	CAIL TAC,BNDTSZ			;BETTER BE REASONABLE
	JRST SQBADB
	TLO TAC,400000			;INDICATE SWAP OP - SIGN BIT IN TFRSEC
	MOVEM TAC,TFRSEC(DDB)		;''Disk address'' is 400000,,band #
>;IFE FTRH
IFN FTRH,<
;Compute a real disk address here.
	CAIL	TAC,BNDTSZ		;Is the band number reasonable?
	JRST	SQBADB
	MOVM	TAC1,FINISH		;Job number of job being swapped
	LDB	AC3,SWPJOB
	CAME	AC3,TAC1
	JRST	SQBADB			;Band doesn't belong to the right job
	MOVE	AC3,SDBPTR(DDB)
	LDB	AC2,RHSUNP		;Get the unit number
	CAML	AC2,ST.UIS(AC3)		;Skip if the unit is reasonable
	JRST	SQBADB			;Bad address
	IMUL	AC2,ST.RPU(AC3)		;Times records per unit.
	LDB	AC1,RHSCYP		;Get the cylinder number
	IMUL	AC1,ST.RPC(AC3)		;Convert to record number
	LDB	TAC1,RHSBNP		;Get the band number
	IMUL	TAC1,RHSBSZ		;Time number of words per band
	LSH	TAC1,-RECWSH		;Convert to records per band
	ADD	TAC1,AC1		;Add RN of cylinder origin
	CAML	TAC1,NSSUN		;Must be less than number of swp record/unit
	JRST	SQBADB
	ADD	TAC1,FSSUN		;Add origin of swapping space per unit
	ADD	TAC1,AC2		;Offset to right unit
	MOVEM	TAC1,TFRSEC(DDB)
>;IFN FTRH
	SKIPGE SWBAND(TAC)		;SKIP IF NOT THE LAST BAND ASSIGNED TO JOB
	SKIPA TAC,[777]			;LAST ONE, GENERATE OUT OF BOUNDS FOR NEXT
	LDB TAC,SWPNXT			;NEXT SWAPPING BAND
	HRRM TAC,SERA
SQGO2:	SETZB IOS,DEVIOS(DDB)		;MAKE SURE THERE ARE NO ERROR BITS ON!
	PUSHJ P,SETACT
	AOS NSWPOP
IFKL10,<PUSHJ P,DKTIMA
>;IFKL10
	PUSHJ P,TGO			;ZORCH
IFKL10,<PUSHJ P,DKTIMB
>;IFKL10
	MOVEI IOS,IOACT
	ANDCAB IOS,DEVIOS(DDB)
	TRNE IOS,IOIMPM			;IMMEDIATE ERROR?
	JRST SWPLZ1
	TRNN IOS,IODERR!IODTER
	JRST SQGOXL			;NO ERRORS.  Loop in case of more to send
	SOSLE SERACT			;COUNT DOWN
	JRST SQGO2			;TRY AGAIN
	TRO IOS,IODERR			;TRIED ENOUGH, DIE
SNOERR:	MOVE TAC,IOS
	ANDI TAC,IODERR!IODTER		;GET ERROR BITS, IF ANY.
	MOVEM TAC,SERA			;GIVE TO SWAPPER.
	SETZM SQREQ
	SETZM SWPCNT			;WAKE UP SWAPPER.
	POPJ P,

SWPLZ1:	PUSHJ P,SWPLUZ
	JRST SQGO2

SQBADB:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /SWAPPING BAND NUMBER OUT OF RANGE AT SQGOX - FATAL
/
	PUSHJ P,DISFLUSH
	POPACS
	JRST FDDTCALL
>;IFE FTDMDP

SWPLUZ:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
IFKL10,< ASCIZ /FILE SYSTEM PACK OFF LINE OR IN WRITE LOCK!
PLEASE FIX IT AND TYPE RN<CR>.
/>;IFKL10
NOKL10,< ASCIZ /FILE SYSTEM PACK OFF LINE OR IN WRITE LOCK!
Please fix it and push CONTINUE.
/>;NOKL10
	PUSHJ P,DISFLUSH
	POPACS
	HALT CPOPJ

IFN FTDMDP,<
SQGOX:	LDB DAT,[POINT 3,TFRIOW(DDB),2]	;NUMBER OF PAGES BEING SWAPPED
	LSH DAT,9
	ADDM DAT,SWPTWC
	ADDM DAT,IBMTWC
	AOSA NSWPOP
SQGOX0:	PUSHJ P,SWPLUZ
	SETZB IOS,DEVIOS(DDB)
	PUSHJ P,TSTART		;Multi-block transfer
	TRNE IOS,IOIMPM		;IMMEDIATE ERROR?
	JRST SQGOX0		;report error
	TLNE IOS,LOSBIG		;ANY BAD ERRORS
	JRST SQGOSE		;YES, TOO BAD
	JRST SWPEND		;NO ERRORS, GO CLEAN UP AFTER SWAP FINISHED

>;IFN FTDMDP
;⊗ UFDREQ UFDRE4 UFDRE2 UFDRE1 UFDRE3 UFDCL1 UFDCL2 UFDRQX DDBWAK UFDRQY UFDRQZ UFDSCN UFDSC1 UFDSC2 UFDREM UFDINT devent

;UFDREQ checks through the UFDUSE list for some DDB that is already using
;the UFD specified by UFDNAM.  If it doesn't find it, it makes an
;entry in UFDUSE and skip returns.  If it does find it, it makes an entry
;in UFDWAT and dismisses.  When this interrupt subroutine is started up again
;(which will happen when an interrupt subroutine that has an entry in UFDUSE
;returns via UFDCLR), it will remove itself from the UFDWAT list and loop thru
;UFDREQ again.
;UFDREQ is also used for interlocking of bringing in a UDP SAT.  In this case,
;UFDNAM is set to -1.

IFE 17-DDB,<.FATAL DDB can't be AC 17 here>

UFDREQ:	SKIPE	DD.SBA(DDB)
	PUSHJ	P,UFDRQX	;error to have a SYSBUF resource locked
	SKIPE	DD.ULK(DDB)	;Error to have a lock resource already
	PUSHJ	P,UFDRQZ
	SKIPN	TAC,UFDUSE
	JRST	UFDRE1		;THE LIST IS EMPTY
	PUSHJ	P,UFDSCN	;SCAN UFDUSE FOR A MATCHING ENTRY
	JRST	UFDRE2		;DIDN'T FIND ONE
;begin bugtrap
	CAIN TAC,(DDB)		;make sure the matching entry found isn't our own!
	JRST UFDRQY		;uh oh, were about to be in two lists w/one link wd
;end bugtrap
	SKIPE	TAC,UFDWAT	;FOUND ONE, PUT OURSELVES IN UFDWAT
	HRLM	DDB,UFDLNK(TAC)	;STORE BACKWARD LINK
	MOVEM	TAC,UFDLNK(DDB)
	HRRZM	DDB,UFDWAT
	AOS	UIWCNT		;Ufd Interlock Wait Count
	PUSH	P,[UFDREQ]	;After waiting, loop to UFDRQ0
UFDRE4:	MOVEM	IOS,DEVIOS(DDB)
	MOVEM	17,C1ACS+17(DDB);SAVE THE ACS IN THE DDB (LIKE TGO)
	MOVEI	17,C1ACS(DDB)
	BLT	17,C1ACS+16(DDB)
IFN FT17P,<
	MOVE	17,C1ACS+17(DDB);restore AC 17 (P!)
>;IFN FT17P
REPEAT 0,<
	PUSHJ P,C1DSCN		;SCAN PSYSBF TABLE FOR THIS DDB
	 JRST @INTRTN		;DIDN'T FIND IT
	SETZM PSYSBF(TAC)	;FLUSH SYSBUF REQUEST
	PUSHJ P,C1GO		;AND MAYBE START UP ANOTHER TRANSFER
>;REPEAT 0,
	JRST	@INTRTN		;AND DISMISS

UFDRE2:	MOVE	TAC,UFDUSE	;NO MATCH FOUND, ADD US TO THE FRONT OF UFDUSE
	HRLM	DDB,UFDLNK(TAC)	;STORE BACKWARD LINK IN OLD FIRST ENTRY
UFDRE1:
IFN FTUFDB,<
	movem tac,ufduso	;save old ufduse
	push p,tac
	move tac,ufdlnk(ddb)	;remember old link
	movem tac,ufdlno
	move tac,dd.ulk(ddb)	;remember old lock
	movem tac,ufdulo
	pop p,tac
>;IFN FTUFDB
	MOVEM	TAC,UFDLNK(DDB)	;STORE FORWARD LINK IN NEW FIRST ENTRY
	HRRZM	DDB,UFDUSE
	MOVE	TAC,(P)		;Get the address of the caller
	MOVEM	TAC,DD.ULK(DDB)	;Set that DDB posesses a lock
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,1		;signature of this event
	move tac,ufdnam(ddb)	;which UFD?
	camn tac,ufdts0		;one of interest?
	aosn ufdct0		;yes, count a lock on it, skip if already locked!
	caia
	pushj p,bugtrp		;this is a bug!  this ufd is locked twice now!
	camn tac,ufdts1		;one of interest?
	aosn ufdct1		;yes, count a lock on it, skip if already locked!
	caia
	pushj p,bugtrp		;this is a bug!  this ufd is locked twice now!
	aos tac,nufdlk		;count number locked
	cail tac,3		;3 is too many
	jfcl			;put breakpoint here
>;IFN FTUFDB
	PUSHJ P,@(P)		;return to caller of UFDREQ.  Make him return to us
	 JRST UFDRE3		;non-skip
	AOSA -1(P)		;pass skip return uplevel
	PUSHJ P,BUGTRP		;double skip return!!
UFDRE3:
IFN FTUFDB,<
	skipn tac,ufduse	;we better still be in the lock list
	pushj p,bugtrp		;we're not!!
	pushj p,ufdscn		;find us in the list
	 pushj p,bugtrp		;no match, not even us
	caie tac,(ddb)		;is the match us?
	pushj p,bugtrp		;no!!
	pushj p,devent		;record this event
	 tro tac,2		;signature of this event
	move tac,ufdnam(ddb)	;which UFD?
	camn tac,ufdts0		;one of interest?
	sosge ufdct0		;yes, uncount a lock on it, skip if still locked!
	caia
	pushj p,bugtrp		;this is a bug!  this ufd is locked twice now!
	camn tac,ufdts1		;one of interest?
	sosge ufdct1		;yes, uncount a lock on it, skip if still locked!
	caia
	pushj p,bugtrp		;this is a bug!  this ufd is locked twice now!
	sosge tac,nufdlk	;reduce number locked
	pushj p,bugtrp		;count went negative
>;IFN FTUFDB
	SETZM	DD.ULK(DDB)	;DDB has released lock.
;We get here when an interrupt subr that had previously called UFDREQ and been
;granted indivisible access to a UFD, dismisses via POPJ.  UFDREQ has left this
;routine on the stack as co-routine return.
;UFDCLR removes the DDB from the UFDUSE list and scans the UFDWAT list for
;others who may be waiting for the UFD that's now free.  Such DDBs are moved to
;the UFDWAK list.  To activate the UFDWAK list, an initiated interrupt is generated DSKCHN.
;for DSKCHN
;UFDCLR:
	PUSHJ P,UFDREM		;REMOVE DDB FROM UFDUSE
IFN FTUFDB,<
	 pushj p,[	push p,tac
			pushj p,devent
			 tro tac,4
			pop p,tac
			movem tac,ufduse
			popj p,]
>;IFN FTUFDB
IFE FTUFDB,<
	 MOVEM TAC,UFDUSE	;INSTRUCTION FOR UFDREM TO XCT
>;IFE FTUFDB
	MOVEM DDB,(P)		;Delete return to caller of UFDREQ. Save DDB
UFDCL1:	SKIPE TAC,UFDWAT
	PUSHJ P,UFDSCN		;SCAN UFDWAT FOR A MATCHING ENTRY
	 JRST UFDCL2		;DIDN'T FIND ANY
	MOVE DDB,TAC		;FOUND ONE
	PUSHJ P,UFDREM		;REMOVE IT FROM UFDWAT
	 MOVEM TAC,UFDWAT
	PUSHJ P,DDBWAK		;Add DDB to list of DDBs being woken.
	JRST UFDCL1

UFDCL2:	POP P,DDB		;restore our DDB
	POPJ P,			;Return to caller of UFDREQ's caller

;The problem here is a possible deadly embrace.  If we ensure that all
;users of UFDREQ have no other resources then we can ensure no deadlock.
;The other such resource is a system buffer.  Our rule is that you must
;seize the UFD before the system buffer.
UFDRQX:	MOVE	TAC,-1(P)		;return address
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISUSR
	 'UFDRQX'
	PUSHJ	P,DISMES
	 ASCIZ	/A caller of UFDREQ (/
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	 ASCIZ	/) has a SYSBUF resource already.
/
	POPACS	
	POPJ	P,
	
DDBWAK:	MOVE	TAC1,UFDWAK		;AND ADD IT TO UFDWAK
	MOVEM	TAC1,WAKLNK(DDB)
	HRRZM	DDB,UFDWAK
	CONO	PI,4000!<1⊗<7-DSKCHN>>	;INITIATE INT INTO DSKCHN
	POPJ	P,

;We were already in UFDUSE list when got to UFDREQ.
UFDRQY:	SKIPA TAC,(P)			;return address from UFDREQ
;The problem here is that the DDB already owns a UFD lock.
UFDRQZ:	MOVE	TAC,-1(P)		;return address from UFDREQ
	PUSHACS
	PUSH	P,DD.ULK(DDB)
	PUSH	P,TAC
	PUSHJ	P,DISUSR
	 'UFDRQZ'
	PUSHJ	P,DISMES
	 ASCIZ	/A caller of UFDREQ (/
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	 ASCIZ	/) already has a UFD locked: /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS	
	PUSHJ	P,WDDTCALL
	POPJ	P,

;Scan the list whose pointer is in TAC.  Skip return if a match is found with
;TAC pointing at the first match.  Non-skip if no match.
UFDSCN:	MOVE AC1,UFDNAM(DDB)				;AC1 = sought name
	LDB AC2,PUNIT					;AC2 = Sought unit
UFDSC1:	LDB TAC1,[POINT PUNITS,DEVUNI(TAC),35-PUNITP]	;PUNIT
	CAMN AC1,UFDNAM(TAC)
	CAME TAC1,AC2
	CAIA
	JRST CPOPJ1		;FOUND A MATCH
UFDSC2:	HRRZ TAC,UFDLNK(TAC)	;FORWARD LINK
	JUMPN TAC,UFDSC1
	POPJ P,			;NO MATCH

UFDREM:	HRRZ TAC,UFDLNK(DDB)	;FORWARD
	HLRZ TAC1,UFDLNK(DDB)	;BACK
	SKIPE TAC		;SKIP IF FWD POINTER IS ZERO (WE ARE END OF LIST)
	HRLM TAC1,UFDLNK(TAC)	;STORE OUR BACK PTR AS BACK PTR OF GUY FWD OF US
	SKIPE TAC1		;SKIP IF BACK POINTER IS ZERO (WE ARE HEAD OF LIST)
	HRRM TAC,UFDLNK(TAC1)	;STORE OUR FWD PTR AS FWD PTR OF GUY BACK OF US
	SKIPN TAC1		;SKIP IF BACK POINTER NONZERO (NOT HEAD OF LIST)
	XCT @(P)		;STORE NEW HEAD OF LIST
IFN FTUFDB,<
	setzm ufdlnk(ddb)	;clear our link, we're out of the list
>;IFN FTUFDB
	JRST CPOPJ1


;ENTER AT UFDINT FROM DSKCHN GENERATED INTERRUPT
↑UFDINT:JSR DSKSV
	HRRZ DDB,UFDWAK
	HRRZ TAC,WAKLNK(DDB)
	MOVEM TAC,UFDWAK
IFKL10,<SKIPN TAC		;SKIP IF THERE ARE MORE TO WAKE UP
	CONO PI,20000!<1⊗<7-DSKCHN>>	;CLEAR INITIATED INTERRUPT
>;IFKL10
	POP P,INTRTN		;SAVE RETURN ADDRESS TO DSKSV
	MOVSI 17,C1ACS(DDB)
	BLT 17,17		;RESTORE ACS SAVED AT UFDRE4
	MOVE IOS,DEVIOS(DDB)	;GIVE HIM UP TO DATE IOS
	POPJ P,			;AND RETURN FROM UFDRE4

IFN FTUFDB,<
;Record event in debugging buffer, via DEBWD (COMCSS).
;Call with/	PUSHJ P,DEVENT
;		 TRO TAC,<some low-order code number to add to job name>
;Preserves all ACs.
;Currently stores exactly 8 entries for convenient buffer viewing with WHO!<cr>.
↑devent:push p,tac
	move tac,time		;get time of day
	pushj p,debwd		;record time of event for debugging
	move tac,ufdnam(ddb)	;get UFD name
	pushj p,debwd		;record UFD name
	move tac,ufdmem(ddb)	;see what ptr looked like so far
	pushj p,debwd		;record ufd entry position
	move tac,devios(ddb)	;record status
	pushj p,debwd		; in debugging buffer
	move tac,accnam(ddb)	;save filename
	pushj p,debwd		; in buffer
	move tac,accext(ddb)	;also put extension
	hrr tac,dd.ulk(ddb)	; and locker's addr
	pushj p,debwd		; into buffer
	ldb tac,pjobn		;remember job nbr
	hrl tac,ddb		; and ddb adr
	pushj p,debwd		; in buffer
	ldb tac,pjobn		;job nbr
	move tac,jobnam(tac)	;job name is what we want this time
	trz tac,7		;clear low-order bits of job name, for code
	xct @-1(p)		;mark as this event
	pushj p,debwd		;put into buffer
	jrst tpopj1		;restore TAC and skip over XCT'd instr
>;IFN FTUFDB
;System Buffer Initialization, Assignment, Release. ;⊗ SBAINI SBAIN1 GETSBA GETSBB GETSB2 RELSBA RLSBA1 RLSBA2 SBACHK SBACKE SBACK1 GETSBE RLSBAE GTSBAE

;Call from DSKINI to create an empty wait-list and a full free-list

SBAINI:	SETZM	SBWLH			;No waiters for system buffer assignments
	MOVEI	DAT,SBWLH-DD.SBW	;Tail of Q of SBA waiters points to head
	MOVEM	DAT,SBWLT
Printx BLKWDS must be adequate for the largest of block sizes.
	MOVE	DAT,[-NSBUFS,,SBATAB]	;Initialize table of established buffers
	MOVE	TAC1,[-BLKWDS,,SYSBUF]	;-WC & Addr of the first system buffer
SBAIN1:	MOVEM	TAC1,(DAT)		;Store this as link out of previous buffer
	ADDI	TAC1,BLKWDS		;Advance current by size of buffer
	AOBJN	DAT,SBAIN1
	MOVEI	DAT,NSBUFS
	MOVEM	DAT,SBACNT
	SETZM	UIWCNT		;Ufd Interlock Wait Count
	SETZM	SBWCNT		;System Buffer Wait Count
	POPJ	P,			;marking the end of the SB free list


;Assign a system buffer for use by an interrupt subroutine.
GETSBA:	TLNN	TAC,DSYSB1	;Here from STSTART/STSTA1.  Must have this set
	JRST	GTSBAE		;STSTART wants a buffer and ''knows'' its address?
	SOSGE	TAC,SBACNT	;Decr count of number of buffers available
	JRST	GETSB2		;none present.  Add DDB to wait list
	MOVEI	TAC1,0
	EXCH	TAC1,SBATAB(TAC)
	MOVEM	TAC1,DD.SBA(DDB)	;Save this one
	MOVEM	TAC1,DD.SBB(DDB)	;Save here too
GETSBB:
IfStructure,<
	MOVN	TAC,DD.RPB(DDB)	;Get the number of data records per block
	ASH	TAC,RECWSH	;Convert to words
	SUB	TAC,DD.SSZ(DDB)	;''Add'' size of RTVL area in words
	HRLM	TAC,DD.SBB(DDB)	;Store -Block Size (incl rtvl) in LH of SBB
>;IfStructure
	POPJ	P,

GETSB2:	AOSE	SBACNT		;Bump the count back to zero.
	PUSHJ	P,GETSBE	;BUG!
	AOS	SBWCNT		;System Buffer Wait Count
	MOVE	TAC,SBWLT	;System buffer wait-list TAIL
	SETZM	DD.SBW(DDB)	;Zero link out of this DDB.
	MOVEM	DDB,DD.SBW(TAC)	;Store this DDB in tail of the list
	MOVEM	DDB,SBWLT
	MOVEM	IOS,DEVIOS(DDB)	;Put this transfer to sleep
	MOVEM	17,C1ACS+17(DDB);SAVE THE ACS IN THE DDB (LIKE TGO)
	MOVEI	17,C1ACS(DDB)
	BLT	17,C1ACS+16(DDB)
	JRST	@INTRTN		;AND DISMISS

RELSBA:	MOVE	DAT,DD.SBA(DDB)	;This buffer is being released
	PUSHJ	P,SBACHK	;Validity check this item,
	 POPJ	 P,		;Was invalid.  DD.SBA and DD.SBB are cleared
	SKIPE	TAC,SBWLH	;Is someone waiting for it?
	JRST	RLSBA1		;Yes.  Don't futz with free list
	MOVE	TAC,SBACNT	;Get head of free list
	MOVEM	DAT,SBATAB(TAC)	;Store remainder of list as link out of this one
	AOS	SBACNT		;Store this as head of free list
	POPJ	P,		;Done.


RLSBA1:	SKIPE	SBACNT		;the number of buffers free should be zero!
	PUSHJ	P,RLSBAE	;Another error?
	MOVEM	DAT,DD.SBA(TAC)	;Store buffer address in DDB that's waiting
	MOVEM	DAT,DD.SBB(TAC)	;Here too.
	MOVE	DAT,DD.SBW(TAC)	;Get DDB of next who waits
	MOVEM	DAT,SBWLH	;Store that DDB in head of the list
	JUMPN	DAT,RLSBA2	;jump unless the new list is empty
	MOVEI	DAT,SBWLH-DD.SBW ;empty list--initialize tail to point to head
	MOVEM	DAT,SBWLT
RLSBA2:	PUSH	P,DDB
	MOVE	DDB,TAC
	PUSHJ	P,GETSBB
	PUSHJ	P,DDBWAK	;Re-Activate transfer for DDB
	POP	P,DDB
	POPJ	P,

SBACHK:	MOVSI	TAC,-BLKWDS
	XOR	TAC,DAT		;LH of DAT should cancel the LH of TAC
	TLNE	TAC,-1		;skip if ok
	JRST	SBACKE		;Error
	SUBI	TAC,SYSBUF	;Subtract the buffer are origin
	PUSH	P,TAC1
	IDIVI	TAC,BLKWDS
	SKIPN	TAC,TAC1
	AOS	-1(P)		;Passes tests.  Skip return.
	POP	P,TAC1
	JUMPE	TAC,SBACK1
SBACKE:	PUSHACS
	PUSH	P,DDB
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/Bad buffer IOWD being returned at SBAREL.
DDB = /
	MOVE	TAC,(P)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	 ASCIZ	/;  Bad value, DD.SBA(DDB) = /
	POP	P,DDB
	MOVE	TAC,DD.SBA(DDB)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,WDDTCALL
SBACK1:	SETZM	DD.SBA(DDB)
	SETZM	DD.SBB(DDB)
	POPJ	P,

GETSBE:	PUSHACS
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/SBACNT other than -1 at GETSB2.  Value = /
	SOS	TAC,SBACNT
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	 ASCIZ	/.  Will fix it.
/
	SETZM	SBACNT
	POPACS
	POPJ	P,

RLSBAE:	PUSHACS
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/SBACNT should be zero at RLSBA1.  Actual value is
/
	MOVE	TAC,SBACNT
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,WDDTCALL
	SETZM	SBACNT
	POPJ	P,

GTSBAE:	PUSHACS
	PUSHJ	P,DISUSR
	 'GETSBA'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal.  STSTART called without a system buffer assigned
/
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL
;⊗ UEWAIT XWSYNC NEWAIT NENTER RENTER QEWAIT QENTER QE1 DIGO DNSTR2 DNSTR3 DRQDN DRQDN1 MESSCO MESS1 MESS2 MESS3 MESS4 MESS5 MESS6 MESS7 MESS8

;ENTER HERE FOR HIGH PRIORITY TRANSFER (CURRENTLY ONLY UDP IO).
UEWAIT:	TDZE IOS,[DEVSBB,,IOACT]
	PUSHJ P,XWSYNC
	MOVSI AC1,DEVIBF
	ANDCAM AC1,DEVCMR(DDB)
	PUSHJ P,SETACT
	PUSHJ P,QE1			;MERGE WITH Q-ENTER CODE
XWSYNC:	SKIPE JOB			;FOR JOB 0, WE SIT HERE AND WAIT.
	JRST WSYNC			;AND WAIT FOR FINISH
	MOVE TAC,[DEVSBB,,IOACT]	;SPIN TILL DONE
	TDNE TAC,DEVIOS(DDB)
	JRST .-1			;here only at system initialization
	POPJ P,


;CALL WITH ROUTINE ADDRESS SET UP IN DAT
NEWAIT:	PUSH P,[XWSYNC]			;RETURN FROM NENTER TO XWSYNC
NENTER:	TDZE IOS,[DEVSBB,,IOACT]
	PUSHJ P,XWSYNC
	MOVSI AC1,DEVIBF
	IORM AC1,DEVCMR(DDB)
	TLO IOS,DEVSBB
	MOVEM IOS,DEVIOS(DDB)
	JRST QE1

IFN FTRH,<
;CALL WITH ROUTINE ADDRESS SET UP IN DAT
;Here from QDSKIO.
;Call here in PHYCHN (DSKCHN) to mount a UDP not associated with a job,
;so we can't do any UUO-level waiting.
RENTER:	CONSZ PI,77400			;skip if in any PI level
	JRST NEWAIT			;UUO level, can wait after all
	TDZE IOS,[DEVSBB,,IOACT]
	PUSHJ P,MESS8			;shouldn't be on, can't wait
	MOVSI AC1,DEVIBF
	IORM AC1,DEVCMR(DDB)
	TLO IOS,DEVSBB
	MOVEM IOS,DEVIOS(DDB)
	JRST QE1
>;IFN FTRH

;CALL WITH ROUTINE ADDRESS SET UP IN DAT
QEWAIT:	PUSH P,[XWSYNC]			;QUEUE REQUEST. RETURN TO XWSYNC TO WAIT
QENTER:	TDZE IOS,[DEVSBB,,IOACT]
	PUSHJ P,XWSYNC			;JUST IN CASE SOMEBODY GOOFED.
	MOVSI AC1,DEVIBF
	ANDCAM AC1,DEVCMR(DDB)
	PUSHJ P,SETACT			;STORES IOS
QE1:	CONO PI,DSKOFF			;INTS OFF
	PUSHJ P,DIGO			;SAVE UUO AC'S, START I-LEVEL
	MOVSI 17,UUOACS			;RELOAD UUO AC'S FROM INT. SAVE.
	BLT 17,17			;CH6 INTS INHIBITED UNTIL THIS DONE.
	JRST DSKONJ

;HERE WITH DSKCHN OFF TO SIMULATE RUNNING A DSKCHN INTERRUPT
DIGO:	POP P,INTRTN			;SAVE UUO CONTINUE ADDRESS
	JSR DSKSV			;SAVE UUO AC'S IN UUOACS.  MUST NOT HAVE
					;INTERRUPT UNTIL THESE ARE RESTORED.
	MOVSI P,-C1PDLL
	HRRI P,C1PDL-1(DDB)		;SET UP I-LEVEL PDL
	MOVE IOS,DEVIOS(DDB)
	LDB J,PJOBN
	MOVSI AC1,DEVIBF
	TDNE AC1,DEVCMR(DDB)
	JRST DNSTR2
	TLZE IOS,DEVSBB
	PUSHJ P,MESS2
	SKIPE J
	SKIPE JBTPAG(J)			;SKIP IF NOT IN CORE.
	TRON IOS,IOACT
	PUSHJ P,MESS3
	JRST DNSTR3

DNSTR2:	TRZE IOS,IOACT
	PUSHJ P,MESS4
	TLON IOS,DEVSBB
	PUSHJ P,MESS5
DNSTR3:	SKIPE DD.SBA(DDB)		;There should be no sysbuf assignment
	PUSHJ P,MESS6			;Warn about it
	PUSH P,DAT
	PUSHJ P,(DAT)			;CALL SUBR
DRQDN:	POP P,DAT			;For debugging
	SKIPE DD.ULK(DDB)
	PUSHJ P,MESS7
	SKIPE DAT,DD.SBA(DDB)		;Did the SUBR get a SYSBUF assignment?
	PUSHJ P,RELSBA			;Release it.  Start xfers needing assignment
REPEAT 0,<
	PUSHJ P,C1DSCN			;SCAN PSYSBF FOR DDB
	 JRST DRQDN1			;NOT FOUND
	SETZM PSYSBF(TAC)		;FLUSH THE SYSBUF REQ FLAG
	PUSHJ P,C1GO			;AND MAYBE START UP ANOTHER TRANSFER
>;repeat 0
DRQDN1:	MOVSI AC1,DEVIBF
	ANDCAM AC1,DEVCMR(DDB)
	TDZN IOS,[DEVSBB,,IOACT]	;MOST SUBRS POPJ, THEN
	PUSHJ P,MESS1			;IOACT OFF AT....
	TLZE IOS,IOW			;DO THIS RITUAL TO...
	PUSHJ P,SETIOD			;GET OUT OF IO WAIT
	PUSHJ P,DSIOS			;STORE IOS!
	JRST @INTRTN			;RESTORE USER AC'S, DISMISS

MESSCO:	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISGST
	POP	P,TAC
	HRLI	TAC,440700
	PUSHJ	P,DISTAC
	POPACS
	POP	P,TAC
	JRST	DSIOS
	
MESS1:	PUSH P,TAC
	JSP TAC,MESSCO
	 ASCIZ /IOACT off at DRQDN.
/

MESS2:	PUSH	P,TAC
	JSP	TAC,MESSCO
	 ASCIZ	/DEVIBF off and DEVSBB on at DNSTRT.
/

MESS3:	PUSH	P,TAC
	JSP	TAC,MESSCO
	 ASCIZ 	/IOACT off (or job not in core) at DNSTRT.
/

MESS4:	PUSH	P,TAC
	JSP	TAC,MESSCO
	 ASCIZ	/DEVIBF and IOACT both on at DNSTRT.
/

MESS5:	PUSH	P,TAC
	JSP	TAC,MESSCO
	 ASCIZ	/DEVIBF on and DEVSSB off at DNSTRT.
/

MESS6:	SETZM	DD.SBA(DDB)			;clean slate.
	PUSH	P,TAC
	JSP	TAC,MESSCO
	 ASCIZ	/System buffer already assigned at DNSTRT
/

MESS7:	PUSHACS
	PUSH	P,DAT
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/UFD interlock still held on return from I SUBR.  SUBR = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,WDDTCALL
	POPJ	P,

MESS8:	PUSH	P,TAC
	JSP	TAC,MESSCO
	 ASCIZ	/IOACT or DEVSBB on at RENTER.
/
;⊗ STSTA1 STSTART TSTART WLOCK TREDO TGO TGO1 DKTIMA DKTIMB

Comment $ 
Monument Erected here August 21,1983 by Ralph Gorin who was sick of this.

Nowdays, ''interrupt subroutines'' are
started at UUO level by NEWAIT/QEWAIT immediately (unless IO is pending for
this DDB).  There are three resources used by interrupt subroutines:
	UFD interlock
	System Buffer
	Disk & Channel throughput.

An Interrupt Subroutine must obtain the UFD interlock, if needed, before starting
a (series of) transfer(s).   Note that in the world of multiple system buffers,
it's more important than before to seize the UFD interlock (because some operations
that were performed in the per-pack system buffers now could be done in parallel).

All users of system buffers appear to call STSTART or STSTA1.  If no system buffer
has been assigned for this ISUBR, then one will be assigned at this point. (It
may be necessary to wait for such an assignment; if so, remember, no transfer
has been queued yet.)

Finally the allocation of arm motion, channel throughput, etc. is the
function of C1GO (for the C1), and RHGO for the RH based disks.

If a write transfer is from BUFBUF, we must check to see if
	the disk address specifies relative record zero in a block.
	if so, the first sector's write data comes from the ddb's rtvl area.
$

STSTA1:	SKIPA TAC,[DSYSB1!DSYSBF,,0]	;SETS DSYSB1 AND DSYSBF IN TFRCTL
STSTART:MOVSI TAC,DSYSBF		;SETS DSYSBF IN TFRCTL AND FALLS INTO TSTART
	IORM TAC,TFRCTL(DDB)
	SKIPN DD.SBA(DDB)		;Has a system buffer been assigned here?
	PUSHJ P,GETSBA			;No.  Get one.  (Note: DSYSB1 must be set!)
TSTART:	AOS NTSTART			;START A TRANSFER AT CH6 LEVEL
	MOVE TAC,TFRCTL(DDB)
	TLNE TAC,DWRITE			;Skip
WLOCK:	JFCL				;Write lock instruction.  (error or POPJ?)
	MOVEI TAC,TRIES
	HRRM TAC,TFRCTL(DDB)
TREDO:
IFKL10,<PUSHJ P,DKTIMA
>;IFKL10
	PUSHJ P,TGO
IFKL10,<PUSHJ P,DKTIMB
>;IFKL10
	TRNN IOS,IODERR!IODTER		;ANY ERRORS?
	POPJ P,				;NO, OK RETURN.
	SOS TAC,TFRCTL(DDB)		;COUNT DOWN
	TRNE TAC,-1			;TRIED ENOUGH?
	JRST TREDO			;NO, TRY AGAIN.
	MOVEI TAC,0			;RETURN TAC=0 ON ERROR
	TLO IOS,LOSBIG			;INFORM THE HIGHER-UPS.
	POPJ P,				;RETURN LOSSAGE.

IFE 17-DDB,<.FATAL DDB can't be AC 17 here>
TGO:	TRZ IOS,IODERR!IODTER!IOIMPM
	MOVEM IOS,DEVIOS(DDB)
	MOVEM 17,C1ACS+17(DDB)
	MOVEI 17,C1ACS(DDB)
	BLT 17,C1ACS+16(DDB)	;SAVE ACS AT TIME OF CALL TO TGO
IFN FT17P,<
	MOVE 17,C1ACS+17(DDB)	;restore AC 17 (P!)
>;IFN FT17P
IFN FTRH,<
	LDB TAC,PUNIT
	CAMG TAC,[UPACKS]
	JRST TGO1		;jump to handle old-style disks
	PUSHJ P,RHGO		;Queue transfer
	JRST @INTRTN		;Return to UUO level or dismiss DSKCHN

>;IFN FTRH
TGO1:	PUSHJ P,PQADDR		;SET UP PACK AND CYLINDER IN DDB LOCATIONS
	PUSHJ P,PQIN		;ADD IT TO ITS PACK QUEUE
	PUSHJ P,C1GO		;START WHATEVER TRANSFERS CAN BE STARTED
	JRST @INTRTN		;EITHER RETURN TO UUO LEVEL OR DISMISS DSKCHN

IFKL10,<
DKTIMA:	DATAI TIM,DKATIM		;GET CURRENT TIME
	POPJ P,

DKTIMB:	DMOVEM TAC,DKTIMT		;SAVE SOME ACS
	DATAI TIM,TAC
	DSUB TAC,DKATIM			;GET DIFFERENCE IN TIME
	DADD TAC,DKTIME			;ADD IN TO TOTAL TIME
	DMOVEM TAC,DKTIME
	DMOVE TAC,DKTIMT		;RESTORE ACS
	POPJ P,
>;IFKL10

;⊗ C1GO C1GO1 C1GO2 C1GO3 C1GOGO C1STRT C1DSCN C1DSC1 CNTDOP CNTDO1 ERRCLR ERRCLL

;Find xfer(s) to start up on free drives.  Must preserve only DDB, IOS and P.
C1GO:	MOVSI TAC,-NPACKS
	PUSH P,DDB
C1GO1:
Repeat 0,<
	SKIPG PSYSBF(TAC)	;SKIP IF A SYSBUF TRANSFER ACTIVE ON THIS PACK
>;Repeat 0
	SKIPE PACTIV(TAC)	;SKIP IF PACK IS INACTIVE
	JRST C1GO2		;PACK ALREADY ACTIVE
Repeat 0,<
	SKIPGE PSYSBF(TAC)
	JRST C1GO3		;SIGN BIT MEANS DO SYSBUF XFER FIRST
>;Repeat 0
	SKIPN PQUEUE(TAC)	;PACK INACTIVE, SKIP IF ITS QUEUE IS NON-EMPTY
	SKIPE PSWAPR(TAC)	;QUEUE EMPTY, ANY SWAP REQUEST
	JRST C1GO3
C1GO2:	AOBJN TAC,C1GO1		;NOTHING FOR THIS PACK TO DO
IFN FTF2,<
	PUSHJ P,C1SIM		;SEE IF ANYTHING FOR C1 SIMULATOR TO DO
>;IFN FTF2
	POP P,DDB
	POPJ P,	

C1GO3:	PUSHJ P,PQOUT		;REMOVE BEST ENTRY FROM THIS PACK QUEUE (INTO DDB)
	 JRST 4,.		;THE QUEUE COULDN'T HAVE BEEN EMPTY
Repeat 0,<
	MOVE TAC1,TFRCTL(DDB)
	TLNE TAC1,DSYSBF
	HRRZM DDB,PSYSBF(TAC)	;WE ARE STARTING A SYSBUF TRANSFER
	MOVE TAC1,PQCYL(DDB)
	HLL TAC1,PQHHR(DDB)
	MOVEM TAC1,PSYSBA(TAC)	;STORE DISK ADDRESS OF THIS TRANSFER
>;Repeat 0
	PUSHJ P,C1WHCH		;FIGURE OUT WHICH CHANNEL TO RUN ON (RETURN IN TAC1)
	DPB TAC1,C1BITP		;REMEMBER THE CHANNEL IN TFRCTL
	PUSHJ P,ERRCLR		;CLEAR THE ERROR COUNTS FOR THIS PACK/CHANNEL
	PUSHJ P,C1GOGO		;COMPILE THE PROG AND START IT UP
	PUSHJ P,CNTDOP		;COUNT DISK OPS
	JRST C1GO2		;AND CONTINUE AOBJN LOOP

;CALL WITH DDB SET UP AND TAC SET TO THE PACK (CALLED FROM C1REGO)
C1GOGO:	LDB TAC1,C1BITP		;GET CHANNEL BIT BACK
	PUSHJ P,C1MPIL		;COMPILE THE CHANNEL PROG (RH UCHN POINTS AT HALT)
	LDB TAC1,C1BITP		;GET CHANNEL BIT BACK
	HRRZM UCHN,@C1EXHP(TAC1);STORE EXPECTED HALT ADDRESS FOR THIS PACK/CHANNEL
	HRRZM DDB,PACTIV(TAC)	;INDICATE THIS PACK ACTIVE
	MOVE UCHN,PQCYL(DDB)
	MOVEM UCHN,PCURCY(TAC)	;THIS IS THE NEW CYLINDER LOCATION OF THIS PACK
C1STRT:	MOVE AC1,C1PTP(TAC1)	;GET ADDRESS OF RELEVANT PROGRAM TABLE
	ADDI AC1,C1PPTR(TAC)	;ADD IN THE PACK TO GET ADDR OF PROGRAM POINTER
	MOVEI AC2,4
	DPB AC2,[POINT 5,(AC1),4]	;STORE "START" CODE IN PROGRAM POINTER
	MOVEI AC2,DHNGCT
	MOVEM AC2,DSKHNG(TAC1)	;RESET HUNG COUNT FOR THIS CHANNEL
	POPJ P,

Repeat 0,<
;SCAN PSYSBF TABLE FOR ANY ENTRY THAT MATCHES DDB.  SKIP RETURN WITH AOBJN
;POINTER TO PACK IN TAC IF FOUND.
C1DSCN:	MOVSI TAC,-NPACKS
C1DSC1:	HRRZ TAC1,PSYSBF(TAC)
	CAIE TAC1,(DDB)		;DOES DDB MATCH THIS PSYSBF REQUEST?
	AOBJN TAC,C1DSC1	;NO KEEP SCANNING
	JUMPL TAC,CPOPJ1	;SKIP RETURN WHEN WE FIND ONE
	POPJ P,			;NO MATCHES
>;Repeat 0

;COUNT ANOTHER DISK OP
CNTDOP:	PUSH P,TAC
	SKIPGE TAC,TFRSEC(DDB)
	JRST TPOPJ		;DON'T COUNT SWAP OP
	LDB TAC1,PJOBN
	AOS DSKOPS(TAC1)	;COUNT A DISK ACCESS FOR THIS USER
	HLRE TAC1,TFRIOW(DDB)	;- WC
	MOVM TAC1,TAC1
	ADDM TAC1,DSKTWC	;UPDATE TOTAL DISK WORD COUNT
	ADDM TAC1,IBMTWC
NoStructure,<
	CAIG TAC1,SECSIZ	;SKIP IF XFER IS LONGER THAN RETRIEVAL
	TRNE TAC,77		;IS IT A RETRIEVAL OP?
	JRST CNTDO1		;NO, A DATA OP
>;NoStructure
IfStructure,<			;Not called for RH disks; wouldn't work right for RH
	CAMG TAC1,DD.SSZ(DDB)	;SKIP IF XFER IS LONGER THAN RETRIEVAL
	TRNE TAC,77		;IS IT A RETRIEVAL OP?
	JRST CNTDO1		;NO, A DATA OP
>;IfStructure
	MOVE TAC,TFRCTL(DDB)
	TLNE TAC,DWRITE
	AOSA NDWROP		;ANOTHER WRITE RETRIEVAL OP
	AOS NDRROP		;ANOTHER READ RETRIEVAL OP
	JRST TPOPJ

CNTDO1:	MOVE TAC,TFRCTL(DDB)
	TLNE TAC,DWRITE
	AOSA NDWDOP		;ANOTHER WRITE DATA OP
	AOS NDRDOP		;ANOTHER READ DATA OP
	JRST TPOPJ

;CLEAR THE ERROR COUNTS FOR THE PACK IN TAC, CHANNEL IN TAC1
ERRCLR:	PUSH P,TAC
	HRRZ TAC,TAC
	LSH TAC,1
	ADD TAC,TAC1		;2*PACK+CHANNEL
ERRCLL:	SETZM ERRCL0(TAC)
	CAIL TAC,4*2*NPACKS	;HIGHEST COUNTING CLASS (4) ?
	JRST TPOPJ
	ADDI TAC,NPACKS*2
	JRST ERRCLL
;⊗ NDSKUP DISKUR DISKUE DISKUN DISKUM DISKRS DISKUP DISKU0 DISKU1 DISKU2 DQUIET DQUI00 DQUI0 DQUI1 DQUI2 DQUI3 DQUIEL C1REGO C1REG0 C1REG1 C1REGA DHUNG DHNGD3 DHNGD2 DHNGDC CHN A B C D ZMA C1Z FF C10 C11 CSI CGRONK CRELOD CSCKRN CCCKRN CCKSTR CSC CRSTCH CMPCNT CSCHF1 CCCHF1 CCINTF CSD CMCADR CMCLD CMPSTP CMSTB CSDIAG CCDIAG HBRKIN NCHNS C1ALSV C1ADSV C1APSV C1AGSV C1BLSV C1BDSV C1BPSV C1BGSV C1SAVE C1DUMP C1DMP0 C1DMP1 C1DMP2 C1DMP3 C1DMP5 C1DMP4 C1DMPX EXZ80M XZ80M CPOPJX QSSTEP SETHBP SETHB2 DPZMEM DPZME2 Z8MLD Z80GO

IFE FTF2,<

NDSKUP←←2	;NUMBER OF RETRIES TO START C1 BEFORE WE RELOAD C1 MICROCODE

DISKUR:	HLRE AC1,(P)		;Get back saved retry count
DISKUE:	PUSHACS
	AOS NC1RET		;Count number of retries
	CAIE AC1,NDSKUP		;OMIT TIME ON CONTINUING SAGA
	JRST DISKUN
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /DISKUP/
DISKUN:	SOJLE AC1,DISKUM		;JUMP IF ALREADY RETRIED ENOUGH
	PUSHJ P,DISMES
	 ASCIZ /DISKUP timed out waiting for C1 ready; retrying.
/
	POPACS
	SOJA AC1,DISKU0		;(WE SOJLE'D WHILE ACS PUSHED)

DISKUM:	JUMPL AC1,DISKRS		;JUMP IF ALREADY RELOADED MICROCODE
	AOS NC1RLD			;Count number of times we've done this
	PUSHJ P,DISMES
	 ASCIZ /C1 still not ready, reloading C1 microcode.
/
	CONO C1A,C1SBI!C1RSI!C1MPRL	;RESET ALL CHANNELS, RELOAD MICROCODE
	MOVSI AC2,1
	SOJG AC2,.			;WAIT A WHILE
	POPACS
	SOJA AC1,DISKU0		;(WE SOJLE'D WHILE ACS PUSHED)

DISKRS:	AOS NC1DED		;Count number of times we've given up.
	PUSHJ P,DISMES
	 ASCIZ /C1 even still not ready.  I give up.  Try pushing its RESET button.
/]
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
>;IFE FTF2
DISKUP:	JFCL			;Patch to POPJ to prevent using disk
IFN FTSUAI,<
	POPJ P,			;no more C1 at SAIL
>;IFN FTSUAI
IFN FTF2,<
	DCONO 0			;SHUT OFF DISK INTERRUPTS
	SETOM DSKLUN		;SAY NO OPERATIONS IN PROGRESS
	SETZM C1CHAN		;F2 HAS ONLY ONE CHANNEL (NUMBER 0)
	SETZM PACBSY		;CLEAR FLAGS SAYING SOME PACKS SHOULD INTERRUPT
	MOVE TAC,[PACBSY,,PACBSY+1]
	BLT TAC,F2DERF		;CLEAR MORE FLAGS FOR F2 DISK CONTROLLER STATUS
	MOVE TAC,[S.SERR!S.NRDY!S.IPE,,S.ANY]
	MOVEM TAC,DKERMS	;Set error mask for interrupt routine
>;IFN FTF2
	AOS NC1UP		;Count number of times we've started the C1
IFE FTF2,<
	MOVEI AC1,NDSKUP			;NUMBER OF TIMES WE RETRY
DISKU0:	CONO C1A,C1SBI!C1RSI!C1SRUN!C1CONT	;RESET ALL CHANNELS START CLOCK
	CONO C1A,C1SCH!C1RST!C1MPCN		;RESET CHAN A AND START UP
	CONO C1B,C1SCH!C1RST!C1MPCN		;RESET CHAN B AND START UP
	CONO C1A,C1SCH!C1SCF1!C1LCD!C1SYSR	;TELL C1A TO DO A SYSTEM RESET
	MOVSI TAC,4				;WAIT THIS LONG FOR EACH CHANNEL
	CONSZ C1A,CF1				;WAIT FOR IT TO DROP CF1
	SOJG TAC,.-1
	JUMPLE TAC,DISKUE			;JUMP IF TIMED OUT!
	CONO C1B,C1SCH!C1SCF1!C1LCD!C1SYSR	;TELL C1B TOO
	MOVSI TAC,4				;WAIT THIS LONG
	CONSZ C1B,CF1				; FOR CF1 TO DROP
	SOJG TAC,.-1
	JUMPLE TAC,DISKUE			;JUMP IF TIMED OUT!
	CONO C1A,C1SCH!C1SCF1!C1INTE!C1LCD!C1LPT	;INT THE CHANNEL FOR LD ...
	CONO C1B,C1SCH!C1SCF1!C1INTE!C1LCD!C1LPT	;...PGM TABLE. ALSO ENB INTS
	HRLM AC1,(P)		;Remember retry count in case of late failure
>;IFE FTF2
	SETZM C1ZERO
	MOVE TAC,[C1ZERO,,C1ZERO+1]
	BLT TAC,C1ZEND-1
	MOVE TAC,[DSKCHN⊗=15,,253]		;HAS TO BE 253 (THE CHANNEL CHECKS)
	MOVEM TAC,C1APT+C1CCW
	MOVEM TAC,C1BPT+C1CCW

	MOVEI TAC,C1BW!<DSKCHN⊗3>!DSKCHN	;BUSY WAIT BIT AND PIAS
	MOVE AC1,[BYTE (5)37 (8)0 (1)0 (22)C1APH]
	MOVE AC2,[BYTE (5)37 (8)0 (1)0 (22)C1BPH]
	MOVE TAC1,C1CUAD		;GET CONTROLLER ADDRESS FOR C1A
	DPB TAC1,[POINT 8,AC1,12]	;STORE IN DEVICE ADDRESS FIELD
	MOVE TAC1,C1CUAD+1		;SAME FOR C1B
	DPB TAC1,[POINT 8,AC2,12]
	MOVSI TAC1,-FPACKS
	MOVEI AC3,0
DISKU1:	MOVEM TAC,C1APH+C1PCW(AC3)	;STORE IN PROGRAM CONTROL WORD
	MOVEM TAC,C1BPH+C1PCW(AC3)	;FOR EACH CHANNEL, EACH PROGRAM (=DRIVE)
	MOVEM AC1,C1APT+C1PPTR(TAC1)	;STORE PROGRAM POINTER IN PROGRAM TABLE
	MOVEM AC2,C1BPT+C1PPTR(TAC1)
	ADD AC1,[BYTE (5)0 (8)1 (1)0 (22)C1PRGL]	;BUMP DRIVE #
	ADD AC2,[BYTE (5)0 (8)1 (1)0 (22)C1PRGL]	;BUMP DRIVE #
	ADDI AC3,C1PRGL
	AOBJN TAC1,DISKU1
	MOVSI TAC1,-UPACKS
DISKU2:	MOVEM TAC,C1APH+C1PCW(AC3)	;STORE IN PROGRAM CONTROL WORD
	MOVEM TAC,C1BPH+C1PCW(AC3)	;FOR EACH CHANNEL, EACH PROGRAM (=DRIVE)
	MOVEM AC1,C1APT+C1PPTR+FPACKS(TAC1)	;STORE PGM PTR IN PROGRAM TABLE
	MOVEM AC2,C1BPT+C1PPTR+FPACKS(TAC1)
	ADD AC1,[BYTE (5)0 (8)1 (1)0 (22)C1PRLU]	;BUMP DRIVE #
	ADD AC2,[BYTE (5)0 (8)1 (1)0 (22)C1PRLU]
	ADDI AC3,C1PRLU
	AOBJN TAC1,DISKU2
IFE FTF2,<
	MOVSI TAC,4		;WAIT THIS LONG FOR CHANNEL
	CONSO C1A,CF2			;WAIT FOR CHANNEL TO BE READY FOR PGM TBL
	SOJG TAC,.-1		;DON'T WAIT FOREVER
	JUMPLE TAC,DISKUR	;JUMP IF TIMED OUT
	DATAO C1A,C1PTP			;TELL IT WHERE THE PROGRAM TABLE IS
	CONO C1A,C1SCH!C1CCF1		;CLEAR CF1 (TELL IT WE'VE TOLD IT)
	MOVSI TAC,4		;WAIT THIS LONG FOR CHANNEL
	CONSZ C1A,CF2			;WAIT FOR CHANNEL TO DROP CF2
	SOJG TAC,.-1		;DON'T WAIT FOREVER
	JUMPLE TAC,DISKUR	;JUMP IF TIMED OUT
	MOVSI TAC,4		;WAIT THIS LONG FOR CHANNEL
	CONSO C1B,CF2			;REPEAT FOR SECOND CHANNEL
	SOJG TAC,.-1		;DON'T WAIT FOREVER
	JUMPLE TAC,DISKUR	;JUMP IF TIMED OUT
	DATAO C1B,C1PTP+1
	CONO C1B,C1SCH!C1CCF1
	MOVSI TAC,4		;WAIT THIS LONG FOR CHANNEL
	CONSZ C1B,CF2
	SOJG TAC,.-1		;DON'T WAIT FOREVER
	JUMPLE TAC,DISKUR	;JUMP IF TIMED OUT
>;IFE FTF2
	POPJ P,

IFE FTF2,<
;Wait for all C1 channels to be idle.
;Enter at DQUI00 with a given channel number in AC2 to wait for all other
;channels to be quiet.
DQUIET:	MOVNI AC2,1			;FLAG TO WAIT FOR ALL CHANNELS
DQUI00:	MOVEI TAC1,=100000		;HERE FROM DHUNG WITH HUNG CHANNEL IN AC2
DQUI0:	MOVSI TAC,-NPACKS
DQUI1:	JUMPE AC2,DQUI2			;JUMP IF NOT TO WAIT FOR CHANNEL 0
	LDB AC1,[POINT 5,C1APT+C1PPTR(TAC),4]	;GET STATE CODE
	CAIE AC1,14
	CAIN AC1,37
	JRST DQUI2
	SOJG TAC1,DQUI0			;NOT IDLE, LOOP BACK TO START (UGH)
	JRST DQUIEL

DQUI2:	CAIN AC2,1			;SKIP IF WANT TO WAIT FOR CHANNEL 1
	JRST DQUI3			;DON'T CARE ABOUT THIS CHANNEL
	LDB AC1,[POINT 5,C1BPT+C1PPTR(TAC),4]	;GET STATE CODE
	CAIE AC1,14
	CAIN AC1,37
	JRST DQUI3
	SOJG TAC1,DQUI0			;NOT IDLE, LOOP BACK TO START (UGH)
	JRST DQUIEL

DQUI3:	AOBJN TAC,DQUI1			;LOOP FOR ALL DRIVES
	POPJ P,

DQUIEL:	PUSHACS
	SKIPGE AC2		;ALREADY PRINTED TIME IF FROM DHUNG
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /Timeout waiting for disk channel all quiet
/
	DEBCHECK(POPACS)
	POPJ P,

C1REGO:	MOVEI DDB,DSKDDB		;SEARCH FOR OLD MODE UDP
	MOVE TAC,DEVMOD(DDB)
C1REG0:	TLNE TAC,DVUDP
	PUSHJ P,C1REGA			;RESTORE OLD UDP PROGRAM HEADER
	HLRZ DDB,DEVSER(DDB)
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK!DVUDP
	JRST C1REG0
	MOVSI TAC,-NPACKS		;NOW RESTART ALL ACTIVE TRANSFERS
C1REG1:	SKIPE DDB,PACTIV(TAC)		;IS THERE A TRANSFER ACTIVE ON THIS PACK?
	PUSHJ P,C1GOGO			;YES.  START UP THE CHANNEL
	AOBJN TAC,C1REG1
	POPJ P,

C1REGA:	SKIPN AC1,UDPBUF(DDB)
	POPJ P,
	JRST UDPCO1

;HERE FROM SPECIAL CALL IN DEVCHK WHEN THE DISK GETS A HUNG TIMEOUT
DHUNG:	CONO PI,DSKOFF
	PUSHACS
	CONSO C1A,C1DCI			;DISCONNECT IN ON EITHER CHANNEL?
	CONSZ C1B,C1DCI
	JRST DHNGDC			;YES, CHECK 1 ERR
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /C1/
	SKIPE TEM,DSKHNG+0	;HAS CHANNEL 0 TIMED OUT?
	MOVEI TEM,1		;NO, MUST BE CHANNEL 1
	PUSH P,TEM		;REMEMBER WHICH CHANNEL
	ADDI TEM,"A"
	PUSHJ P,DISTYO		;TYPE OUT "A" OR "B" ACCORDING TO CHANNEL NUMBER
	PUSHJ P,DISMES
	 ASCIZ / Disk Channel hung time out
/
	POP P,AC2		;GET BACK NUMBER OF HUNG CHANNEL
	PUSHJ P,DQUI00		;WAIT FOR NON-HUNG CHANNEL TO BE QUIET
IFN FTC1BUG,<
	PUSHJ P,C1DUMP
	MOVEI TAC,['C1DUMP'↔' SSSYS'↔<ACWPRV!REAPRV!WRTPRV,,0>↔0]
	PUSHJ P,FIREUP
	 JFCL				;TOO BAD
>;IFN FTC1BUG
DHNGD3:	DEBCHECK(POPACS)	;DON'T CALL DDT UNLESS DEBUGGING
DHNGD2:
;DISKUP is called at C1HUNG, so shouldn't need to call it here.
;	PUSHJ P,DISKUP		;BLAST THE DISK
	SETOM HNGFLG
	CONO PI,4000!<1⊗<7-DSKCHN>>	;GET INTO DSKCHN (GO TO C1HUNG FROM CONSZ)
	JRST DSKONJ

DHNGDC:	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /Check-1 Error on disk Control Unit # /
	MOVEI TEM,"0"		;Assume error on CU 0
;;All we have left is CU 0.  Although it's set up as CU 1, it's labelled CU 0.
;;	CONSZ C1B,C1DCI
;;	MOVEI TEM,"1"		;Check-1 error on CU 1
	PUSHJ P,DISTYO		;Type CU number
	PUSHJ P,DISCRLF
	JRST DHNGD3	;JFCL	;patch to JFCL to make system stop on ck1 err
	PUSHJ P,DISFLUSH	;code retained for patching in to stop on check 1
	POPACS
	PUSHJ P,WDDTCAL
	JRST DHNGD2

IFN FTC1BUG,<

BEGIN C1BUG

CHN←4
A←5
B←6
C←7
D←10
ZMA←11
C1Z←12
FF←13

C10←←C1A
C11←←C1B

CSI←←1B18
CGRONK←←1B21
CRELOD←←1B22
CSCKRN←←1B23
CCCKRN←←1B24
CCKSTR←←1B25

CSC←←1B19
CRSTCH←←1B21
CMPCNT←←1B27
CSCHF1←←1B25
CCCHF1←←1B26
CCINTF←←1B22

CSD←←1B20
CMCADR←←1B22
CMCLD←←1B23
CMPSTP←←1B24
CMSTB←←1B25
CSDIAG←←200
CCDIAG←←100

HBRKIN←←367		;Breakpoint instruction: Hex F7
NCHNS←←2

	DEFINE XCONI(BITS)
<	XCT[	FOR @' I=0,NCHNS-1 <
		CONI C1'I,BITS	>](CHN) >

	DEFINE XCONO(BITS)
<	XCT[	FOR @' I=0,NCHNS-1 <
		CONO C1'I,BITS	>](CHN) >

	DEFINE XCONSZ(BITS)
<	XCT[	FOR @' I=0,NCHNS-1 <
		CONSZ C1'I,BITS	>](CHN) >

	DEFINE XCONSO(BITS)
<	XCT[	FOR @' I=0,NCHNS-1 <
		CONSO C1'I,BITS	>](CHN) >

	DEFINE XDATAI(ADDR)
<	XCT[	FOR @' I=0,NCHNS-1 <
		DATAI C1'I,ADDR	>](CHN) >

	DEFINE XDATAO(ADDR)
<	XCT[	FOR @' I=0,NCHNS-1 <
		DATAO C1'I,ADDR	>](CHN) >

DEFINE RETURN <POPJ P,>
DEFINE GO (LAB)<JRST LAB>

REPEAT 0,<
C1ALSV:	BLOCK 10
C1ADSV:	BLOCK 100+10
C1APSV:	BLOCK C1PPTR+NPACKS+1
C1AGSV:	BLOCK NPACKS*C1INST		;PROGRAM HEADERS
C1BLSV:	BLOCK 10
C1BDSV:	BLOCK 100+10
C1BPSV:	BLOCK C1PPTR+NPACKS+1
C1BGSV:	BLOCK NPACKS*C1INST		;PROGRAM HEADERS
C1SAVE::
>;REPEAT 0

↑C1DUMP:MOVEI CHN,1
C1DMP0:	XCONO (C1SDIA!CMPSTP)
	MOVEI A,7
C1DMP1:	XCONO <30(A)>
	XDATAI <C1ALSV(A)>
	SOJGE A,C1DMP1
	CAIA
C1DMP2:	POP P,(P)
	PUSHJ P,QSSTEP
	XDATAI A
	LDB A,[POINT 12,A,12]
	PUSH P,A
	MOVSI A,-1(A)
	PUSHJ P,XZ80M
	CAIE A,335
	CAIN A,355
	JRST C1DMP2
	CAIE A,375
	CAIN A,313
	JRST C1DMP2
	PUSHJ P,SETHBP
	PUSHJ P,Z80GO
	MOVEI FF,=200000
	XCONI A
	TRNN A,1
	SOJG FF,.-2
	JUMPLE FF,C1DMPX

	MOVSI ZMA,-400
	MOVE FF,[POINT 8,C1ADSV]
C1DMP3:	PUSHJ P,EXZ80M
	IDPB A,FF
	AOBJN ZMA,C1DMP3
	MOVE ZMA,[-40,,4000-40]
C1DMP5:	PUSHJ P,EXZ80M
	IDPB A,FF
	AOBJN ZMA,C1DMP5

	HRLZ A,C1PTP(CHN)
	HRRI A,C1APSV
	BLT A,C1APSV+C1PPTR+NPACKS+1-1

	MOVSI A,-NPACKS
	MOVEI C,C1AGSV
C1DMP4:	HRLZ B,C1APSV+C1PPTR(A)
	HRR B,C
	BLT B,C1INST-1(C)
	ADDI C,C1INST
	AOBJN A,C1DMP4

;	HRRZ ZMA,HBRKPT		;Get address of hardware breakpoint
;	MOVE A,HBRKVL		;And old contents
;	PUSHJ P,DPZMEM		;Restore instruction at old breakpoint
	JUMPE CHN,C1DMPX
	MOVE A,[C1ALSV,,C1BLSV]
	BLT A,C1SAVE-1
	SOJA CHN,C1DMP0

C1DMPX:	CONO C1A,CSI!CRELOD	;PRESS THE RESET BUTTON
	MOVSI FF,4
	SOJG FF,.		;WAIT FOR MICROCODE TO RELOAD
	POPJ P,

;
;	E X A M I N E     Z 8 0     M E M O R Y
;
EXZ80M:	HRLZM	ZMA,A		; ADDRESS,,0
XZ80M:	
	XCONO (CSD+CMPSTP+37)
	PUSHJ P,CPOPJX		;a random delay
	XDATAI	C1Z		;...INTO C1Z
	XCONO (CSD+CMPSTP+CMCADR+CMCLD+36)
	XDATAO <[100027,,1]>	;MAKE SURE WE AREN'T IN RELOAD MODE.
	XCONO (CSD+CMPSTP+CMCADR+CMCLD+CMSTB)
	XCONO (CSD+CMPSTP+CMCADR+37)	;SELECT Z80 READ
	XDATAO A		;SELECT ADDRESS
	XCONO (CSD+CMPSTP+CMCADR+36)	;SELECT Z80 READ
	XDATAI A		;EXAMINE CONTENTS
	XCONO (30)
	XDATAO C1Z		;RESTORE THE A REGISTER FROM C1Z.
	XCONO (CSD)		;CLEAR FUNNY MODES.
	ROT	A,8
	ANDI	A,377		; ONE BYTE
CPOPJX:	RETURN

;Quietly single step (for proceed)
QSSTEP:	XCONO (CSD+CMPSTP)
	XCONO (CSC+CMPCNT+33)
	RETURN

;===============================================================;
; Set from hardware breakpoint
;   A&7 will someday become breakpoint number
;   -1(P) is address of new breakpoint
;
SETHBP:	
;;;	ANDI A,7		;Extract breakpoint number
;	PUSH P,A
;	HRRZ ZMA,HBRKPT;;;(A)	;Get address of hardware breakpoint
;	MOVE A,HBRKVL		;And old contents
;	JUMPE ZMA,SETHB1
;	PUSHJ P,DPZMEM		;Restore instruction at old breakpoint
;SETHB1:	POP P,A
	EXCH ZMA,-1(P)		;Get address for breakpoint
	HRRZ ZMA,ZMA
	MOVEM ZMA,HBRKPT
	PUSHJ P,EXZ80M		;Read current contents of location
	MOVEM A,HBRKVL		;Save to be restored later.
	MOVEI A,HBRKIN		;Stuff in breakpoint instruction
	PUSHJ P,DPZMEM
SETHB2:	POP P,-1(P)		;Flush argument by moving return address
	POPJ P,

;
;	D E P O S I T     Z 8 0     M E M O R Y
;
DPZMEM:	
	XCONO (CSD+CMPSTP+37)
	PUSHJ P,CPOPJX
	XDATAI C1Z		;...INTO C1Z
	XCONO (CSD+CMPSTP+CMCADR+CMCLD+37)
	XDATAO <[100027,,1]>	;MAKE SURE WE AREN'T IN RELOAD MODE.
	XCONO (CSD+CMPSTP+CMCADR+CMCLD+CMSTB)
;FIRST BYTE
	HRL	A,ZMA		;ADDRESS,,DATA
	PUSHJ P,Z8MLD
;SECOND BYTE IF NON-ZERO
	LDB A,[POINT 8,A,27]
	SKIPN A
	  GO DPZME2
	AOS	ZMA
	HRL	A,ZMA		;ADDRESS,,DATA
	PUSHJ P,Z8MLD		;LOAD Z80 MEMORY
;
DPZME2:
	XCONO (30)
	XDATAO C1Z		;RESTORE A-REG
	XCONO (CSD)		;CLEAR FUNNY MODES.
	RETURN

Z8MLD:	XDATAO A		;LOAD Z80 MEMORY
	XCONO (CSD+CMPSTP+CMCADR+CMCLD+CMSTB)
;	PUSH P,B
;	PUSH P,A
;	MOVSI B,-5000
;Z8L1:	SKIPL Z80MEM(B)
;	SKIPN PATSW#
;	GO Z8L2
;	MOVE A,(P)
;	XOR A,Z80MEM(B)
;	TLNE A,-1
;	AOBJN B,Z8L1
;	MOVE A,(P)
;	TRZ A,777400
;	MOVEM A,Z80MEM(B)
;
;Z8L2:	POP P,A
;	POP P,B
	RETURN

Z80GO:	  XCONO (CSD)	;LET Z80 GO !
	  XCONO (CSC+CMPCNT)	;LET Z80 GO !
	  RETURN

PURGE XCONI,XCONO,XCONSZ,XCONSO,XDATAO,XDATAI,RETURN,GO
BEND C1BUG

>;IFN FTC1BUG
>;IFE FTF2
;⊗ C1MPIS C1MPI4 C1MPSU C1MPIL C1MPIW C1MPW1 C1MPW2 C1MPWR C1RECB C1MPIB C1MPI7 C1MPI1 C1MPI2 C1MPI3 C1MPIA C1MPI6 C1MPI9 C1MPW4 C1MPW5 C1MPI8 C1MPIC C1MPR1 C1MPR2 C1MPUE

;INITIALIZE PDL POINTING TO PROGRAM, CALL WITH UCHN CONTAINING PACK NUMBER
;AND TAC1 CONTAINING CHANNEL NUMBER, RETURNS PDL IN UCHN
C1MPIS:	CAIL UCHN,FPACKS		;SKIP IF IT IS A FILE PACK
	JRST C1MPI4			;IT'S A UDP
	IMULI UCHN,C1PRGL		;GET INDEX FOR PROGRAM FOR THIS PACK
	ADD UCHN,C1PHP(TAC1)		;ADD ADDRESS OF PRG HEADERS FOR THIS CHAN
	ADD UCHN,[-C1PRGL+C1INST,,C1INST-1]	;MAKE INTO A PUSH DOWN POINTER
	POPJ P,

C1MPI4:	SUBI UCHN,FPACKS		;UDP INDEX
	PUSH P,TAC
 	MOVE TAC,C1PTP(TAC1)		;GET CORRECT PROGRAM TABLE
	ADDI UCHN,C1PPTR+FPACKS(TAC)
	LDB UCHN,[POINT 22,(UCHN),35]	;ADDRESS OF PROGRAM HEADER
	CAML UCHN,SYSTOP		;SKIP IF NEW STYLE UDP (PRG HEAD IN SYS)
	JRST C1MPSU
	ADD UCHN,[-C1PRLU+C1INST,,C1INST-1]	;MAKE INTO A PUSH DOWN POINTER
	JRST TPOPJ

C1MPSU:	ADD UCHN,[-C1UDPL+C1INST,,C1INST-1]	;OLD MODE UDP SIZE
	JRST TPOPJ

;COMPILE A CHANNEL PROGRAM FOR A GIVEN TRANSFER.  CALL WITH DDB SET UP
;TAC1 SHOULD CONTAIN THE CHANNEL NUMBER (0 OR 1 FOR C1A OR C1B)
;CLOBBERS MOST ACS, BUT DOESN'T CLOBBER TAC OR DDB

C1MPIL:	MOVE UCHN,PQPACK(DDB)		;GET PACK NUMBER
	PUSHJ P,C1MPIS			;CALL PDL SETUP ROUTINE
	MOVE AC1,DEVMOD(DDB)
	MOVEI TAC1,2(UCHN)
	TLNN AC1,DVDSK
	CAML TAC1,SYSTOP		;OLD STYLE UDP, MAKE SURE PRG HDR IS IN FS
	CAIA
	JRST C1MPUE
	HRLI TAC1,C1JMP			;MAKE A JUMP .+1
	PUSH UCHN,TAC1			;AND STORE IN FIRST INSTRUCTION (FOR SNS)
	MOVE TAC1,TFRCTL(DDB)		;GET CONTROL BITS
	TLNN TAC1,DWRITE
	PUSH UCHN,C1RMRT		;STORE READ MRT COMMAND
	TLNE TAC1,DWRITE
	PUSH UCHN,C1WMRT		;STORE WRITE MRT COMMAND
	MOVEI AC2,0
	MOVE AC1,PQCYL(DDB)
	DPB AC1,[POINT 16,AC2,15]	;C C
	HLRZ AC1,PQHHR(DDB)
	DPB AC1,[POINT 8,AC2,23]	;H
	LDB UUO,[POINT 9,PQHHR(DDB),35]
	DPB UUO,[POINT 8,AC2,31]	;R (SAVE IN UUO)
	PUSH UCHN,AC2			;C C H R
	MOVSI AC2,<RCPTRK-1>⊗2		;LAST REC IN TRACK IN SECOND BYTE
	MOVE AC1,SECTBL(UUO)		;SET SECTOR VALUE FOR FIRST RECORD
	DPB AC1,[POINT 8,AC2,7]		;SEC
	LDB AC1,[POINT 9,PQHHR(DDB),26]	;WRAP RECORD
	DPB AC1,[POINT 8,AC2,23]
	PUSH UCHN,AC2			;SEC   LAST REC   WRAP REC
	MOVEI AC2,2(UCHN)
	HRLI AC2,C1JMP			;JMP .+1
	PUSH UCHN,AC2
	LDB J,PJOBN
IFE FTDMDP,<
	CAMN DDB,SWPDDB
	MOVM J,FINISH			;GET JOB NUMBER OF JOB BEING SWAPPED
>;IFE FTDMDP
IFE FTMPP2,<
	MOVE J,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	PUSHJ P,JOBMAP			;GET UPMP INTO EXEC MAP
	 JFCL
	MOVEI J,(AC1)			;PAGE NUMBER RETURNED IN AC1
>;IFN FTMPP2
	LSH J,9				;ADDRESS OF PAGE MAP
IFN FTDMDP,<
	TLNE TAC1,DSWAP
	JRST C1MPIW			;SWAP TRANSFER
>;IFN FTDMDP
IFN FTSIX,<
	SKIPE IOWDSX(DDB)		;IF TRANSFER INTO P3 MEM ...
	MOVEI J,SIXPGT			;... THEN USE THE P3 PAGE TABLE
>;IFN FTSIX
IFN FTSBP,<
	TLNE TAC1,DSYSBF
	MOVEI J,EXPGT			;IF SYSBUF REQ USE EXEC PAGE MAP
>;IFN FTSBP
	TLNN TAC1,DCMPBF		;SKIP IF USING BUFBUF FOR ADDRESSES
	JRST C1MPI7
	MOVN AC1,BUFBUF(DDB)
	HRLZ AC1,AC1
	HLR AC1,BUFBUF(DDB)
	MOVEM AC1,TFRIOW(DDB)		;USE TFRIOW AS AOBJN POINTER TO BUFBUF
	JUMPN UUO,C1MPIB		;JUMP UNLESS RETRIEVAL OP IS FIRST
NoStructure,<
	MOVEI	AC1,DSKDAT(DDB)		;Write direct from DDB
	HRLI	AC1,-SECSIZ
>;NoStructure
IfStructure,<
	MOVN	AC1,DD.SSZ(DDB)		;-size of rtvl area
	HRLZ	AC1,AC1
	HRRI	AC1,DSKDAT(DDB)		;Write direct from DDB
>;IfStructure
	TLZ TAC1,DUSER!DCMPBF		;OP from DDB isn't from user, nor bufbuf
	PUSHJ P,C1MPI1			;COMPILE PROG FOR RECORD 0
	ADJSP UCHN,-1			;BACK UP OVER THE ZERO AT THE END
	MOVE TAC1,TFRCTL(DDB)		;RESTORE DUSER AND DCMPBF
	MOVE AC1,TFRIOW(DDB)		;RESTORE AOBJN PTR TO WCMAS
	JRST C1MPIC			;AND JUMP IN AT THE END

IFN FTDMDP,<
C1MPIW:	ADD J,TFRIOW(DDB)		;PAGE TABLE ADDRESS OF 1ST PAGE IN GROUP
	LDB AC1,[POINT 4,J,17]		;GET BITS IN LOW 4 BITS OF AC1
	JUMPE AC1,C1MPWR
	MOVEI AC3,4⊗4			;FOR ADDING INTO CCHR WORD
C1MPW1:	TRNE AC1,1			;SKIP IF THIS PAGE DOESNT NEED TO BE SWAPPED
	JRST C1MPW2
	ADDM AC3,-2(UCHN)		;BUMP R IN CCHR WORD
	LSH AC1,-1			;MOVE IN NEXT BIT
	AOJA J,C1MPW1			;ADVANCE PAGE TABLE POINTER

C1MPW2:	HRL J,AC1			;STORE FOR END TEST
	MOVE AC1,(J)			;GET PAGE TABLE ENTRY
	HRLI AC1,-1000			;TURN INTO ABSOLUTE AOBJN POINTER TO PAGE
	JRST C1MPI1

C1MPWR:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /BITS ALL ZERO IN TFRIOW(DDB) AT C1MPIL - FATAL
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	JRST AUTOLOAD
>;IFN FTDMDP

C1RECB←←200000			;Bit in data ptr word meaning start of record
C1MPIB:	SKIPA AC1,(AC1)
C1MPI7:	MOVE AC1,TFRIOW(DDB)		;TRANSFER WCMA
C1MPI1:	MOVEI AC3,C1RECB		;BIT TO INDICATE START OF RECORD
	HRRZ PROG,RCLTAB(UUO)		;GET LENGTH OF CURRENT RECORD IN WORDS
C1MPI2:	HLRE DSER,AC1			;-REMAINING TRANSFER WC
	MOVN DSER,DSER			;REMAINING TRANSFER WC
	CAILE DSER,(PROG)		;GET MIN OF XFER WC AND REMAINING REC SIZE
	MOVEI DSER,(PROG)
	TLNN TAC1,IFN FTSBP,<DSYSBF!>DUSER	;SKIP IF TRANSFER IS MAPPED
	JRST C1MPI3			;TRANSFER IS ABSOLUTE (TO SYSTEM BUFFER)
	LDB DAT,[POINT 9,AC1,26]	;USER PAGE NUMBER OF BEGINNING OF XFER
NOKL10,<CAIL DAT,600			;MAYBE THIS PAGE MAP ENTRY IS IN THE PSB
	CAIE J,EXPGT			;IT IS IF WE ARE USING THE EXEC'S MAP
	CAIA				;NOPE
	ADDI DAT,PSB-EXPGT		;YES, TURN EXPGT OFFSET INTO PSB OFFSET
>;NOKL10
	ADD DAT,J			;ADDRESS OF CORRESPONDING PAGE MAP ENTRY
	MOVE DAT,(DAT)			;GET THE PAGE MAP ENTRY
	TLNN DAT,P.WRT			;SKIP UNLESS WRITE PROTECTED
	TLNE TAC1,DWRITE		;WRITE PROT.  TRYING TO WRITE MEMORY
	CAIA
	JRST C1MPR1			;WRITE VIOLATION
	TLNN DAT,PREAD			;NOW CHECK READ ACCESS
	TLNN TAC1,DWRITE
	CAIA
	JRST C1MPR1			;NO READ ACCESS ON A DISK WRITE
	ANDI DAT,17777			;PHYSICAL PAGE NUMBER
	LSH DAT,9
	DPB AC1,[POINT 9,DAT,35]	;PHYSICAL ADDRESS OF START OF RECORD
	LDB AC2,[POINT 9,AC1,35]	;OFFSET WITHIN PAGE OF START OF RECORD
	MOVN AC2,AC2
	ADDI AC2,1000			;HOW MUCH FITS INSIDE OF THIS PAGE
	CAILE DSER,(AC2)
	MOVEI DSER,(AC2)		;TRANSFER MIN OF DSER AND THIS
	CAIA
C1MPI3:	HRRZ DAT,AC1
	DPB DSER,[POINT 13,DAT,13]	;STORE WORD COUNT IN COMMAND
	TLO DAT,400000(AC3)		;MAKE IT INTO A TRANSFER COMMAND
	PUSH UCHN,DAT			;STORE WCMA
	MOVEI AC3,0			;CLEAR FIRST WCMA OF RECORD BIT
	SUB PROG,DSER			;PROG←HOW MUCH OF RECORD IS LEFT TO XFER
	HRL DSER,DSER
	ADD AC1,DSER
	JUMPGE AC1,C1MPI6		;JUMP IF NO MORE TO DO
C1MPIA:	JUMPG PROG,C1MPI2		;MORE TO DO IN THIS RECORD
	ADDI UUO,1			;BUMP THE RECORD NUMBER
	CAIN UUO,RCPTRK
	LDB UUO,[POINT 9,PQHHR(DDB),27]	;WRAP RECORD
	JRST C1MPI1

C1MPI6:
IFN FTDMDP,<
	TLNE TAC1,DSWAP			;WCMA EXHAUSTED, IS IT A SWAP OP?
	AOJA J,C1MPW4			;YES, SKIP PAGE MAP ENTRY OF PAGE JUST DONE
>;IFN FTDMDP
	TLNE TAC1,DCMPBF		;WCMA EXHAUSTED, ARE WE USING BUFBUF?
	JRST C1MPI8			;YES
C1MPI9:	PUSH UCHN,[0]			;STORE A HALT AT THE END OF THE CHANNEL PROG
	POPJ P,

IFN FTDMDP,<
C1MPW4:	HLRZ AC1,J			;GET BITS IN LOW 4 BITS OF AC1
	LSH AC1,-1			;SKIP OVER BIT FOR PAGE JUST DONE
	JUMPE AC1,C1MPI9		;NO MORE TO DO
	HRL J,AC1			;STORE FOR END TEST
	TRNE AC1,1			;SKIP IF THIS PAGE DOESNT NEED TO BE SWAPPED
	JRST C1MPW5			;SWAP IT
.FATAL	no more BUFIOW, use  GETSBA to assign a system buffer.
	HRRZ AC1,PQPACK(DDB)
	HRRZ AC1,BUFIOW(AC1)		;SYSBUF ADDRESS FOR THIS PACK
	CAIA
C1MPW5:	MOVE AC1,(J)			;GET PAGE TABLE ENTRY
	HRLI AC1,-1000			;TURN INTO ABSOLUTE AOBJN POINTER TO PAGE
	JRST C1MPIA
>;IFN FTDMDP

C1MPI8:	MOVE AC1,TFRIOW(DDB)		;SEE IF THERE IS MORE WCMA
	AOBJP AC1,C1MPI9		;REALLY NO MORE TO DO
	MOVEM AC1,TFRIOW(DDB)		;STORE UPDATED AOBJN POINTER
C1MPIC:	MOVE AC1,(AC1)			;GET NEXT WCMA
	JRST C1MPIA			;ADVANCE TO NEXT RECORD

C1MPR1:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /READ OR WRITE VIOLATION AT C1MPIL - FATAL
/
C1MPR2:	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	JRST AUTOLOAD

C1MPUE:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /AT C1MPIL FOR OLD-STYLE UDP BUT NEW-STYLE PROG HEADER - FATAL
/
	JRST C1MPR2
;⊗ C1AINT C1BINT C1INT C1INTX C1CNFS C1CNF1 C1CNF2 C1CERR C1ERRI C1ERI1 C1ERI2 C1ERI3 C1ASYN C1ASY3 C1ASY2 C1ASY1 C1SYNI C1ERET C1SYN5 C1SYN6 C1SYN3 C1SYN2 C1SYN4

IFE FTF2,<
↑C1AINT:JSR DSKSV		;SAVE INTERRUPTED ACS, GET A PDL
	MOVEI AC1,0
	EXCH AC1,C1APT+C1ISW	;GET THE INTERRUPT SOURCE WORD AND CLEAR IT
	MOVEI TAC1,0		;CHANNEL NUMBER FOR THIS INTERRUPT
	JRST C1INT

↑C1BINT:JSR DSKSV
	MOVEI AC1,0
	EXCH AC1,C1BPT+C1ISW	;GET THE INTERRUPT SOURCE WORD AND CLEAR IT
	MOVEI TAC1,1		;OTHER CHANNEL
C1INT:	LDB AC2,[POINT 2,AC1,1]	;GET INTERRUPT TYPE BITS
	JRST @[	C1CNFS		;CHANNEL CONFUSED
		C1SYNI		;SYNCHRONOUS INTERRUPT
		C1ASYN		;ASYNCHRONOUS INTERRUPT
		C1ERRI		;ERROR INTERRUPT
			](AC2)

C1INTX:	XCT C1CIFI(TAC1)	;CLEAR CHANNEL INT FLAG FOR THIS CHANNEL
	POPJ P,			;RESTORE THE ACS AND DISMISS THE INTERRUPT


C1CNFS:	PUSHACS
	PUSH P,AC1
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /C1 CHANNEL CONFUSED INTERRUPT
/
C1CNF1:	PUSHJ P,C1CERR
	ADJSP P,-2		;FLUSH AC1 AND TAC1
	DEBCHECK(POPACS)	;CALL DDT IF DEBUGGING
C1CNF2:	PUSHJ P,DISKUP		;BLAST THE CHANNEL
	JRST C1REGO		;RESTART ALL ACTIVE OPERATIONS

C1CERR:	PUSHJ P,DISMES
	 ASCIZ /CHANNEL C1/
	MOVEI TEM,"A"
	SKIPE -1(P)		;LOOK AT CHANNEL NUMBER BACK UP THE STACK
	MOVEI TEM,"B"
	PUSHJ P,DISTYO
	PUSHJ P,DISMES
	 ASCIZ / ISW = /
	MOVE TAC,-2(P)		;GET ISW
	PUSHJ P,DISOCH
	JRST DISCRLF


C1ERRI:	PUSHACS			;C1 ERROR INT (NOT ASSOCIATED WITH A CHN PGM)
	PUSH P,AC1
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /C1 DISK ERROR INTERRUPT:
/
	MOVE AC1,-1(P)
	TLNN AC1,C1PTPE
	JRST C1ERI1
	PUSHJ P,DISMES
	 ASCIZ /PROGRAM TABLE PARITY ERROR
/
	MOVE AC1,-1(P)
C1ERI1:	TLNN AC1,C1PTNX
	JRST C1ERI2
	PUSHJ P,DISMES
	 ASCIZ /PROGRAM TABLE NXM
/
	MOVE AC1,-1(P)
C1ERI2:	TLNN AC1,C1IQF
	JRST C1ERI3
	PUSHJ P,DISMES
	 ASCIZ /INTERRUPT QUEUE FULL
/
C1ERI3:	PUSHJ P,DISMES
	 ASCIZ /MA = /
	LDB TAC,[POINT 22,-1(P),35]
	PUSHJ P,DISADR
	PUSHJ P,DISCRLF
	JRST C1CNF1		;BLAST THE CHANNEL AND RESTART CURRENT OPS


;GET HERE ON AN ASYNCHRONOUS INTERRUPT.  TAC1 HAS THE CHANNEL NUMBER AND
;AC1 HAS THE INTERRUPT SOURCE WORD
C1ASYN:	PUSHACS
	PUSH P,AC1
	PUSH P,TAC1
	MOVE AC2,C1CUAD(TAC1)	;GET CU ADDRESS FOR THIS CHANNEL
	XOR AC2,AC1		;COMPARE WITH DEVICE ADDRESS
	TRNE AC2,360		;MUST BE EQUAL
	JRST C1ASY1		;WRONG CU FOR THIS CHANNEL
	LDB TAC,[POINT 8,-1(P),27]	;GET THE STATUS BYTE FROM THE ISW
	CAIE TAC,DEVEND		;IF STATUS IS JUST DEVICE END, THIS IS A PACK CHANGE
	JRST C1ASY2		;REPORT STATUS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /PACKUP/
	PUSHJ P,DISMES
	 ASCIZ /DISK PACK /
	LDB TAC,[POINT 4,-1(P),35]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ / ON LINE.
/
C1ASY3:	ADJSP P,-2
	POPACS
	JRST C1INTX		;NOW JUST LEAVE

C1ASY2:	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /ASYNCHRONOUS DISK INTERRUPT
/
	PUSHJ P,C1CERR
	JRST C1ASY3

C1ASY1:	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /DISK INTERRUPT FOR UNKNOWN CONTROL UNIT
/
	JRST C1CNF1

;GET HERE ON A SYNCHRONOUS INTERRUPT FROM A CHANNEL.  TAC1 HAS THE CHANNEL
;NUMBER AND AC1 HAS THE INTERRUPT SOURCE WORD.
C1SYNI:	LDB AC2,[POINT 22,AC1,35]	;JUST KEEP ABS ADDRESS OF PRGM POINTER WORD
	MOVE TAC,C1PTP(TAC1)	;GET ADDRESS OF PROGRAM TABLE FOR THIS CHANNEL
	CAIL AC2,C1PPTR(TAC)	;SKIP IF OUT OF RANGE OF PROGRAM POINTERS
	CAIL AC2,C1PPTR+NPACKS(TAC)
	JRST C1SYN6		;CHANNEL GAVE US BAD PRGM POINTER ADDRESS
	SUBM AC2,TAC
	SUBI TAC,C1PPTR		;TAC←PACK NUMBER
	SKIPN DDB,PACTIV(TAC)	;PACK HAD BETTER BE ACTIVE
	JRST C1SYN3
	MOVEI AC3,DHNGCT
	MOVEM AC3,DSKHNG(TAC1)	;RESET HUNG COUNT FOR THIS CHANNEL
	MOVE AC2,(AC2)		;GET ADDRESS OF PROGRAM HEADER
	MOVE UUO,C1STA(AC2)	;GET "STAT A" WORD
	MOVE AC3,C1STB(AC2)	;STAT B (MA)
	TLNE UUO,C1PCMA		;SKIP UNLESS ERROR POINTED AT BY PC
	MOVE AC3,C1STC(AC2)	;STAT C (PC)
	TLZ AC3,777760		;KEEP ONLY ADDRESS BITS
	TDNE UUO,[UCHK,,C1SE!C1PE!C1NXM!C1BPE!C1SSE]	;ANY BAD ERRORS?
	JRST C1SYN1		;YES, REPORT AND RETRY
	TRNN UUO,C1HLT		;NORMAL HALT?
	JRST C1SYN2		;NO, WASN'T ANYTHING
	SKIPE @C1SNFP(TAC1)	;SKIP UNLESS A SENSE IS IN PROGRESS
	JRST SENSE1
	SKIPE @C1RCFP(TAC1)	;OR A RECAL
	JRST DORCL1
	SETZM C1ASEF(TAC1)	;CLEAR SELECT ERROR FLAG
	LDB AC3,[POINT 22,C1STC(AC2),35]	;GET PC (SHOULD POINT 1 PAST HALT)
	SUBI AC3,1		;MAKE IT POINT AT THE HALT
	CAME AC3,@C1EXHP(TAC1)	;COMPARE WITH EXPECTED HALT ADDRESS (TAC HAS PACK)
	JRST C1SYN4
>;IFE FTF2
C1ERET:	SKIPGE TFRSEC(DDB)	;SKIP UNLESS SWAP OP
	SETZM PSWAPR(TAC)
	SETZM PACTIV(TAC)	;THIS PACK IS NO LONGER ACTIVE
IFE FTF2,<
	MOVSI AC1,-NPACKS
C1SYN5:	CAMN TAC1,C1WCHN(AC1)	;IS THIS PACK ON CHANNEL OF INTEREST?
	SKIPN PACTIV(AC1)	;YES, IS THIS PACK STILL ACTIVE?
	AOBJN AC1,C1SYN5	;NO TO ONE OF THESE
	SKIPL AC1		;DID WE FIND AN ACTIVE PACK ON THIS CHANNEL?
	SETZM DSKHNG(TAC1)	;NO, FLUSH HUNG TIMEOUT FOR THIS CHANNEL
	XCT C1CIFI(TAC1)	;CLEAR CHANNEL INT FLAG FOR THIS CHANNEL
>;IFE FTF2
	PUSHJ P,C1GO		;RESCAN FOR MORE TRANSFERS TO START UP
	POP P,INTRTN		;SET INTRTN TO POINT AT DSKSV DISMISS CODE
	MOVSI 17,C1ACS(DDB)
	BLT 17,17		;RESTORE ACS TO STATE AT TIME OF CALL TO TGO
	MOVE IOS,DEVIOS(DDB)	;GET CURRENT STATUS
	POPJ P,			;AND RETURN (LOOKS LIKE RETURN FROM TGO)

IFE FTF2,<
C1SYN6:	PUSHACS
	PUSH P,AC1
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /C1 PROGRAM POINTER OUT OF RANGE
/
	JRST C1CNF1

C1SYN3:	PUSHACS
	PUSH P,AC1
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /PACK NOT ACTIVE AT C1SYNI
/
	JRST C1CNF1

C1SYN2:	PUSHACS
	PUSH P,AC1
	PUSH P,TAC1
	PUSH P,UUO		;STAT A
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /SYNCRONOUS DISK INT BUT NO REASON
STAT A = /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	PUSHJ P,C1CERR
	ADJSP P,-2
	POPACS
	JRST C1INTX		;IGNORE IT

C1SYN4:	PUSHACS
	PUSH P,AC1
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /PC DIFFERENT FROM EXPECTED HALT ADDRESS AT C1SYNI
/
	JRST C1CNF1
>;IFE FTF2
;⊗ C1ACSV C1SYN1 C1SEL1 C1NOSE NONXM PARL0 PARL1 PARL2 BPAR

IFE FTF2,<	;Continues for several whole pages.

C1ACSV:	MOVEM TAC1,C1CHAN
	MOVEM UUO,C1ASAV
	MOVEM AC3,C1ERAD
	MOVEM TAC,C1PKSV
	MOVEM DDB,C1DDBS
	MOVEM AC2,C1PRGS
	POPJ P,

;HERE FROM SYNCHRONOUS INTERRUPT WITH A BAD BIT ON IN STAT A RIGHT HALF
;UUO CONTAINS STAT A, TAC1 CONTAINS THE CHANNEL NUMBER, AC3 HAS ERROR ADDRESS
;TAC HAS THE PACK NUMBER, AC2 HAS PROGRAM HEADER ADDRESS
C1SYN1:	PUSHJ P,C1ACSV			;SAVE ACS IN CORE
	SKIPE @C1SNFP(TAC1)		;SKIP UNLESS SENSE WAS IN PROGRESS
	JRST SENSE2
	SKIPE @C1RCFP(TAC1)		;OR A RECAL
	JRST DORCL2
	SETOM TYPANY			;NO TYPE OUT YET -- TYPE TIME WHEN HITS 0
	SETZM WNTTYP			;NO TYPE OUT WANTED YET
	SETZM SNSTYP
	SETZM CSTOP
	SETZM DEATH
	SETZM DSKFLG			;HAVEN'T FOUND OUT WHY YET
	SETZM REGOFL
	LDB AC3,[POINT 6,C1STC(AC2),11]	;CURRENT RECORD NUMBER
	MOVEM AC3,C1LREC		;SAVE FOR FIXERR
	LDB AC3,[POINT 22,C1STC(AC2),35]	;GET PC
	SUBI AC3,2			;BACK UP TO WORD THAT LOST
	MOVEM AC3,C1LSPC		;SAVE FOR FIXERR
	TRNN UUO,C1SE			;IF SELECT ERROR, CHECK IF OFF LINE
	JRST C1NOSE			;NO
	SKIPE C1ASEF(TAC1)		;SECOND SELECT ERROR?
	JRST C1SEL1			;YES
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /DSKERR/
	PUSHJ P,DISMES
	 ASCIZ /DISK SELECT ERROR
/
	PUSHJ P,C1CNF2			;BLAST THE DISK, RESTART ALL TRANSFERS
	MOVE TAC1,C1CHAN		;GET BACK CHANNEL NUMBER
	SETOM C1ASEF(TAC1)		;SET SELECT ERROR HAS HAPPENED FLAG
	POPJ P,				;DISMISS CHANNEL 6

C1SEL1:	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES			;SECOND SELECT ERROR FOR THIS CHANNEL
	 ASCIZ /DISK IS OFF LINE
/
	SETOM CSTOP
	PUSHJ P,ERROR1
	MOVE UUO,C1ASAV
	MOVE TAC1,C1CHAN	;GET BACK CHANNEL NUMBER (CLOBBERED BY ERROR1)
C1NOSE:	SETZM C1ASEF(TAC1)
	TRNE UUO,C1SSE			;SIGNAL SEQUENCE ERROR?
	PUSHJ P,ERROR0			;CLASS 0 ERROR
	TRNN UUO,C1NXM			;NXM?
	JRST NONXM
	PUSHJ P,DSKETY			;FLAG TYPEOUT, MAYBE PRINT TIME
	PUSHJ P,DISERR
	 [ASCIZ /DISK NON-EX-MEM.   DISK MA = /]
	 DISARG ADR,C1ERAD
	 -1
	PUSHJ P,DISCRLF
	PUSHJ P,ERROR1			;ERROR, CLASS ONE
NONXM:	TRNN UUO,C1PE			;CORE PARITY ERROR?
	JRST BPAR
	PUSHJ P,DSKETY			;FLAG TYPEOUT, MAYBE PRINT TIME
	PUSHJ P,DISERR
	 [ASCIZ /CORE TO DISK PARITY ERROR. DISK MA = /]
	 DISARG ADR,C1ERAD
	 -1
	PUSHJ P,DISCRLF
	SETOM DEATH			;QUIT TRYING AFTER PARITY ERROR
	PUSH P,DSER			;DSER = LOC (IN CORE)
	MOVSI TAC,-GOODPG		;-NUMBER OF PAGES,,PAGE 0
PARL0:	MOVEI DSER,(TAC)		;PAGE NUMBER WE'RE ABOUT TO REFERENCE
	LDB AC3,COREP			;IS IT NXM?
	CAIN AC3,NXMCUS			;NXM CORE USAGE CODE?
	JRST PARL2			;NXM PAGE, DON'T TRY TO READ IT
	MOVSI AC3,PWRT			;READ WRITE EXECUTE ACCESS
	HRRI AC3,(TAC)			;PHYSICAL PAGE NUMBER
	MOVEM AC3,EXPGT+DSKEXP		;STORE IN EXEC PAGE TABLE
NOKL10,<CONO PAG,1			;FLUSH ARS
>;NOKL10
IFKL10,<BLKO KLPAG,DSKEXP⊗9		;CLEAR PAGE MAP RAM FOR DSKEXP
>;IFKL10
	MOVE TAC1,[-1000,,DSKEXP⊗9]	;AOBJN WORD FOR ONE PAGE
PARL1:	SKIP (TAC1)
	AOBJN TAC1,PARL1		;RETURN HERE AFTER ERROR
PARL2:	AOBJN TAC,PARL0			;ADVANCE TO THE NEXT PAGE
	POP P,DSER
	SETZM EXPGT+DSKEXP
NOKL10,<CONO PAG,1			;FLUSH ARS
>;NOKL10
IFKL10,<BLKO KLPAG,DSKEXP⊗9		;CLEAR PAGE TABLE RAM FOR DSKEXP
>;IFKL10
BPAR:	TRNN UUO,C1PE!C1BPE		;PARITY ERROR
	JRST NOPAR			;NO
	PUSHJ P,ERROR1			;ERROR, CLASS ONE

;FALLS THROUGH
;⊗ NOPAR SNSDON SNSDO3 SNSDO2 SNSDO1 SNSFLD SNSFL1 SNSDOX SNSDN1 NORJCT SKCHKA SKCHKB NOCL13

;This whole page IFE FTF2
;		DISK ERRORS

;FALLS THROUGH

NOPAR:	TLNN UUO,UCHK			;WAS THERE A UNIT CHECK?
	JRST TYPE0			;NO, CHECK TYPEOUT AND ERROR FLAGS
	PUSHJ P,SENSE			;DO SENSE
	 CAIA				;SENSE LOST
	JRST SNSDON
	PUSHJ P,SYSLOZ			;FLAG TYPEOUT, MAYBE PRINT TIME, COLD STOP
	PUSHJ P,DISMES
	 ASCIZ /SENSE FAILED.  /
	PUSHJ P,ERROR1			;THIS IS CLASS 1 ERROR
	JRST TYPE0

SNSDON:	LDB TAC,[POINT 8,SNSDAT,23]	;GET SENSE BYTE 2
	LDB UUO,[POINT 8,SNSDAT+1,31]	;BYTE 7 FORMAT/MESSAGE
	TRNE TAC,20			;SKIP IF NOT ENVIRONMENTAL DATA PRESENT
	JRST SNSDO3			;ENV DATA PRES, ERROR LOG OR ERROR/USG
	CAIN UUO,DATCOR			;IS IT CORRECTABLE DATA CHECK?
	JRST FIXERR			;TRY TO USE THE SENSE BYTES TO FIX THE ERROR
	JRST SNSDN1

SNSDO3:	CAIN UUO,DATCOR			;GET HERE IF ENVIRONMENTAL DATA PRESENT
	SKIPE PRTLOG			;DF ECC: SKIP IF WANT TO PRINT ERROR LOG
	JRST SNSDO2
	JRST NOSTOP			;PRTLOG = 0 INHIBITS DF ECC ERROR LOG PRNTG
SNSDO2:	LDB TAC,[POINT 4,UUO,31]	;GET FORMAT PART OF BYTE 7
	CAIN TAC,ERRUSE			;SKIP IF NOT ERROR/USAGE STATISTICS
	JRST EUSPNT			;PRINT ERROR USAGE STATISTICS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /DISK ERROR LOG
/
	CAIL UUO,HACOR
	CAILE UUO,KEYCOR
	JRST .+2			;NOT HA, COUNT, KEY OR DATA CORR ERROR
	JRST SNSDO1
	CAIL UUO,HAUCOR
	CAILE UUO,DATUCO
	JRST .+2			;NOT HA, COUNT, KEY OR DATA UNCORR ERROR
	JRST SNSDO1
	CAIN UUO,SKCHK
	JRST [	PUSHJ P,DISMES
		 ASCIZ /SEEK ERROR
/
		JRST SNSDOX	]
	CAIN UUO,SKINCP
	JRST [	PUSHJ P,DISMES
		 ASCIZ /SEEK INCOMPLETE
/
		JRST SNSDOX	]
	JRST SNSDOX

SNSDO1:	CAIE UUO,HAUCOR
	CAIN UUO,HACOR
	JRST [	PUSHJ P,DISMES
		 ASCIZ /HA /
		JRST SNSFLD	]
	CAIE UUO,CNTUCO
	CAIN UUO,CNTCOR
	JRST [	PUSHJ P,DISMES
		 ASCIZ /COUNT /
		JRST SNSFLD	]
	CAIE UUO,KEYUCO
	CAIN UUO,KEYCOR
	JRST [	PUSHJ P,DISMES
		 ASCIZ /KEY /
		JRST SNSFLD	]
	PUSHJ P,DISMES
	 ASCIZ /DATA /
SNSFLD:	PUSHJ P,DISMES
	 ASCIZ /FIELD /
	TRNE UUO,1⊗4			;SKIP IF IT IS FORMAT 4 (UNCORRECTABLE)
	JRST SNSFL1
	PUSHJ P,DISMES
	 ASCIZ /UN/
SNSFL1:	PUSHJ P,DISMES
	 ASCIZ /CORRECTABLE  /
SNSDOX:	AOS SNSTYP
	JRST NODIE

SNSDN1:	AOS SNSTYP			;INDICATE TYPEOUT OF SENSE DATA
	LDB UUO,[POINT 16,SNSDAT,15]	;GET FIRST TWO BYTES OF SENSE
	TRNE UUO,CMDRJT			;COMMAND REJECT?
	TRNE UUO,WRTINH			;yes, WRITE INHIBITED?
	JRST NORJCT			;YES, CATCH IT AT CLASS 5
;;;	LDB TAC,[POINT 8,SNSDAT+1,31]	;PICK UP BYTE 7      ???why???
	PUSHJ P,ERROR0			;OTHERWISE ERROR CLASS 0
NORJCT:	TRNE UUO,BITCL0			;OTHER CLASS 0 ERROR?
	PUSHJ P,ERROR0			;ERROR, CLASS 0
	TRNE UUO,BITCL1			;BUS OUT PARITY IS
	PUSHJ P,ERROR1			;ERROR, CLASS 1
	TRNN UUO,BITEQU			;EQUIPMENT CHECK IS CLASS 1 OR 3
	JRST NOCL13
	LDB TAC,[POINT 8,SNSDAT+1,31]	;GET SENSE BYTE 7
	CAIE TAC,SKCHK			;SEEK CHECK
	CAIN TAC,SKINCP			;OR SEEK INCOMPLETE
	JRST SKCHKA			;ARE CLASS 3
	CAIN TAC,RTYABT			;COMMAND RETRY ABORTED?
	JRST [	PUSHJ P,ERROR4		;ERROR, CLASS 4
		JRST NOCL13	]
	TRNE UUO,PERM			;REAL EQUIPMENT CHECK, IS IT PERMANENT?
	SETOM CSTOP			;YES, COLD STOP
	PUSHJ P,ERROR1			;ALL ELSE IS CLASS 1
	JRST NOCL13

SKCHKA:	PUSHJ P,ERROR3			;RECODE SEEK CHECK AND DO RECALIBRATE
	 CAIA				;RECALIBRATE FAILED
	JRST SKCHKB
;;;	PUSHACS				;BH 7/23/78 NO MATCHING POPACS!
	PUSHJ P,SYSLOZ			;FLAG TYPEOUT, MAYBE PRINT TIME, COLD STOP
	PUSHJ P,DISMES
	 ASCIZ /RECALIBRATE FAILED!
/
SKCHKB:	LDB UUO,[POINT 16,SNSDAT,15]	;RELOAD UUO
NOCL13:	TRNE UUO,BITCL2			;DATA CHECK?
	PUSHJ P,ERROR2			;ERROR, CLASS 2
	TRNE UUO,BITCL4			;OVERRUN?
	PUSHJ P,ERROR4			;ERROR, CLASS 4
	TRNE UUO,BITCL5			;INTRVNTN REQD OR WRITE LOCK?
	PUSHJ P,ERROR5			;ERROR, CLASS 5
	JRST TYPE0
;⊗ EUSPNT ERRU1 ERRU2 ERRU3 ERRU4 ERRU5

;This whole page IFE FTF2
;		ERROR/USAGE STATISTICS

EUSPNT:	AOS DSKFLG
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /DISK ERROR-USAGE STATISTICS.   /
	PUSHJ P,DRIVEP			;PRINT DRIVE ID
	PUSHJ P,DISMES
	 ASCIZ /  PACK = /
	MOVE TAC,C1PKSV
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ /
TBYTES = /
	LDB TAC,[POINT 32,SNSDAT+2,31]	;BYTES 8-11 TOTAL BYTES
	PUSHJ P,DISDEC			;IN DECIMAL
	LDB UUO,[POINT 16,SNSDAT+3,15]	;BYTES 12-13 CORRECTABLE DATA CHECKS
	JUMPE UUO,ERRU1
	PUSHJ P,DISMES
	 ASCIZ /
CORR DATA CHKS = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU1:	LDB UUO,[POINT 16,SNSDAT+3,31]	;BYTES 14-15 UNCORR DATA CHECKS
	JUMPE UUO,ERRU2
	PUSHJ P,DISMES
	 ASCIZ /
UNCORR DATA CHKS = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU2:	PUSHJ P,DISMES
	 ASCIZ /
NSEEKS = /
	LDB TAC,[POINT 16,SNSDAT+4,15]	;BYTES 16-17 NUMBER OF SEEKS
	PUSHJ P,DISDEC
	LDB UUO,[POINT 8,SNSDAT+4,31]	;BYTE 19 NUMBER OF SEEK ERRORS
	JUMPE UUO,ERRU3
	PUSHJ P,DISMES
	 ASCIZ /
SEEK ERRS = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU3:	LDB UUO,[POINT 8,SNSDAT+5,7]	;BYTE 20 COMMAND OVERRUNS
	JUMPE UUO,ERRU4
	PUSHJ P,DISMES
	 ASCIZ /
COVRRN = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU4:	LDB UUO,[POINT 8,SNSDAT+5,15]	;BYTE 21 DATA OVERRUNS
	JUMPE UUO,ERRU5
	PUSHJ P,DISMES
	 ASCIZ /
DOVRRN = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU5:	PUSHJ P,DISCRLF
>;IFE FTF2
;FALL THROUGH TO TYPE0
;⊗ TYPE0 TYPE1 F2DERR NOEXT NOFIL NOFIL1 NSWAP2 NSWAP1 SATPNT NSWAP CLLOP NOCL NODIE SNSLOP NULSNS TYPDON ERRGO NOSTOP WOVNST WOVSWP WOVDDT NOTWOV NOSTP1 C1HUNG DRIVEP ISKNWN PCURDA

;FALLS THROUGH FROM ERROR USAGE STATISTICS

IFE FTF2,<
TYPE0:	SKIPE DSKFLG
	JRST TYPE1
	PUSHJ P,DSKETY			;FLAG TYPEOUT, MAYBE PRINT TIME
	PUSHJ P,DISMES
	 ASCIZ /UNKNOWN /
TYPE1:	SKIPN WNTTYP			;WANT US TO TYPE?
>;IFE FTF2
F2DERR:	SKIPL TYPANY			;or already TYPE ANYTHING?
	JRST .+2			;YES, type more
	JRST ERRGO			;NO, END OF TYPE CHECKING
	PUSHJ P,DSKETY			;FLAG TYPEOUT, MAYBE PRINT TIME
	PUSHJ P,DISMES
	 ASCIZ /DISK ERROR.  /
	MOVE UUO,C1DDBS			;GET DDB POINTER
	SKIPL DSKLRN(UUO)		;FILE OP?
	SKIPN FILNAM(UUO)		;ANY FILE?
	JRST NOFIL			;NO, DON'T PRINT CRUD
	PUSHJ P,DISMES
	 ASCIZ /File: /
	MOVE TAC1,FILNAM(UUO)
	PUSHJ P,DISSIX
	HLLZ TAC1,FILEXT(UUO)
	JUMPE TAC1,NOEXT
	MOVEI TEM,"."
	PUSHJ P,DISTYO
	HLLZ TAC1,FILEXT(UUO)
	PUSHJ P,DISSIX
NOEXT:	MOVEI TEM,"["
	PUSHJ P,DISTYO
	MOVE TAC1,FILPPN(UUO)
	PUSHJ P,DISSIX
	PUSHJ P,DISMES
	 ASCIZ /]    /
NOFIL:	LDB TAC1,[POINT PUNITS,DEVUNI(UUO),35-PUNITP]
	JUMPE TAC1,NOFIL1		;NOT UDP
NoStructure,<
	SKIPG UUO,SATADR(TAC1)		;ADDRESS OF SAT TABLE FOR THIS UDP
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(UUO)
	SKIPG UUO,ST.SAD(TAC1)		;ADDRESS OF SAT TABLE FOR THIS UDP
>;IfStructure
	JRST NOFIL1			;SAT TABLE NOT IN
	PUSHJ P,DISMES
	 ASCIZ /SATID = /
	MOVE TAC1,SATID(UUO)
	PUSHJ P,DISSIX
	PUSHJ P,DISMES
	 ASCIZ/  /
NOFIL1:
;	MOVE UUO,ERRCMD
;	ADDI UUO,1			;OFFSET SO DIAG WORKS
;	PUSHJ P,DISERR
;	 (UUO)[	ASCIZ/DIAG/		;-1
;		ASCIZ/SEEK/
;		ASCIZ/SRCH/
;		ASCIZ/READ/
;		ASCIZ/WRITE/]		;3
;	 [ASCIZ / OP
;/]
;	 -1
	MOVE DDB,C1DDBS
	MOVE TAC,DSKLRN(DDB)
	AOJE TAC,SATPNT
	PUSHJ P,DISMES
	 ASCIZ /Job = /
	SKIPL DSKLRN(DDB)
	JRST NSWAP2
IFE FTDMDP,<
	MOVM TAC,FINISH		;GET JOB BEING SWAPPED
>;IFE FTDMDP
IFN FTDMDP,<
	LDB J,PJOBN		;GET JOB BEING SWAPPED
>;IFN FTDMDP
	PUSHJ P,DISDCP
	PUSHJ P,DISMES
	 ASCIZ / Swap/
	JRST NSWAP1

NSWAP2:	LDB TAC,PJOBN
	PUSHJ P,DISDCP
NSWAP1:	PUSHJ P,DISERR
	 [ASCIZ /  TFRSEC = /]
	 DISARG OCH,TFRSEC(DDB)
	 [ASCIZ /  TFRIOW = /]
	 DISARG OCH,TFRIOW(DDB)
	 -1
	JRST NSWAP

SATPNT:	PUSHJ P,DISMES
	 ASCIZ /SAT table/
NSWAP:
IFE FTF2,<
	PUSHJ P,DISERR
	 [ASCIZ /
Stat A = /]
	 DISARG OCH,C1ASAV
	 [ASCIZ /  /]
	 -1

;	PUSHJ P,DISMES
;	 ASCIZ /PACK = /
;	LDB TAC,[POINT 3,LSTAT,11]	;GET DEVICE ADDRESS
;	PUSHJ P,DISLOC
;	PUSHJ P,DISMES
;	 ASCIZ /  CYL = /
;	LDB TAC,[POINT 16,SKDAT,31]
;	PUSHJ P,DISLOC
;	PUSHJ P,DISMES
;	 ASCIZ /  HD = /
;	LDB TAC,[POINT 8,SKDAT+1,15]
;	PUSHJ P,DISLOC
;	PUSHJ P,DISMES
;	 ASCIZ /  REC = /
;	LDB TAC,[POINT 8,SCDAT+1,7]
;	PUSHJ P,DISLOC
;	PUSHJ P,DISCRLF
;	SKIPN HAFLAG			;HOME ADDRESS TO PRINT?
;	JRST NOHA
;	PUSHJ P,DISMES
;	 ASCIZ /HA CYL = /
;	LDB TAC,[POINT 16,HA,23]
;	PUSHJ P,DISLOC
;	PUSHJ P,DISMES
;	 ASCIZ /  HA HD = /
;	LDB TAC,[POINT 8,HA+1,7]
;	PUSHJ P,DISLOC
;	PUSHJ P,DISCRLF
;NOHA:
	MOVE UUO,C1PKSV			;START WITH CLASS 0
	LSH UUO,1
	ADD UUO,C1CHAN
	TDZA J,J
CLLOP:	ADDI UUO,NPACKS*2
	SKIPN ERRCL0(UUO)		;ANY ERRORS OF THIS CLASS
	JRST NOCL			;NO
	PUSHJ P,DISERR
	 [ASCIZ /Cl/]
	 DISARG DEC,J
	 [ASCIZ / = /]
	 DISARG DEC,ERRCL0(UUO)
	 [ASCIZ /  /]
	 -1
NOCL:	CAIGE UUO,4*2*NPACKS		;HIGHEST COUNTING CLASS (4) ?
	AOJA J,CLLOP
>;IFE FTF2
IFN FTF2,<
	PUSHJ P,DISCRLF			;Start a new line
	PUSHJ P,PCURDA			;Print disk address from F2 disk address
	PUSHJ P,DISERR
;;	 [ASCIZ/
;;PACK #/]
;;	 DISARG LOC,C1PKSV
	 [ASCIZ/  ERROR BITS: /]
PRINTX Disk error bits for F2 should be decoded.
	 DISARG OCH,ERRBIT
	 -1
>;IFN FTF2
	SKIPN DEATH
	JRST NODIE
	PUSHJ P,DISMES
	 ASCIZ / ** DEATH **   /
NODIE:
IFE FTF2,<
	PUSHJ P,DISMES
	 ASCIZ/Pack /
	MOVE TAC,PQPACK(DDB)
	PUSHJ P,DISLOC			;print pack number (NOT from sense)
	SKIPN SNSTYP
	JRST TYPDON			;NO SENSE DATA, GO CHECK FOR ERRORS
	PUSHJ P,DISMES
	 ASCIZ/  /
	PUSHJ P,DRIVEP			;PRINT DRIVE ID
	PUSHJ P,DISMES
	 ASCIZ/  Head /
	LDB TAC,[POINT 5,SNSDAT+1,23]	;get head
	PUSHJ P,DISDCP
	PUSHJ P,DISMES
	 ASCIZ/  Cyl /
	LDB UUO,[POINT 2,SNSDAT+1,18]	;two high bits of cyl
	LDB TAC,[POINT 8,SNSDAT+1,15]	;8 low bits of cyl
	DPB UUO,[POINT 2,TAC,27]	;whole cyl number
	PUSHJ P,DISDCP
	PUSHJ P,DISCRL
IFN FTSBSUP,<
	LDB UUO,[POINT 8,SNSDAT,7]	;get sense byte 0
	LDB TAC,[POINT 8,SNSDAT+1,31]	;get sense byte 7
	CAMN UUO,SB0SUP		;skip unless matches expected value
	CAME TAC,SB7SUP		;skip if matches expected value
	CAIA
	JRST ERRGO		;sense bytes look like usual, suppress them
>;IFN FTSBSUP
	MOVE UUO,[POINT 8,SNSDAT]
	PUSH P,[0]
SNSLOP:	ILDB TAC,UUO
	JUMPE TAC,NULSNS
	PUSH P,TAC
	PUSHJ P,DISERR
	 [ASCIZ /   /]
	 DISARG DEC,-2(P)
	 [ASCIZ / = /]
	 DISARG HE2,-1(P)
	 -1
	POP P,(P)
NULSNS:	AOS TAC,(P)
	CAIN TAC,SNSLEN/2
	PUSHJ P,DISCRLF		;PROBABLY NOT ALL SENSE DATA FITS ON 1 LINE
	CAIGE TAC,SNSLEN
	JRST SNSLOP
	POP P,(P)
TYPDON:
>;IFE FTF2
	PUSHJ P,DISCRLF
ERRGO:
IFN FTRH,<
	SKIPE CSTOP		;not main disk, so don't stop, but
	SETOM DEATH		; do stop transfer if would've stopped system
>;IFN FTRH
IFE FTRH,<	;don't stop system if this isn't the main disk
	SKIPN CSTOP
	JRST NOSTOP
	PUSHJ P,DISMES
IFKL10,< ASCIZ /Check the disk, then type RN<cr>
/>;IFKL10
NOKL10,< ASCIZ /Check the disk, then push CONTINUE.
/>;NOKL10
	PUSHJ P,DISFLUSH
	HALT .+1
>;IFE FTRH
NOSTOP:	MOVE TAC,C1PKSV
	MOVE TAC1,C1CHAN
IFN FTF2,<
	SKIPN DEATH
	JRST C1SIMG		;DIDN'T DIE, RESTART THIS PACK
	MOVE TAC,ERRBIT		;Get saved error bits from F2
printx Write overruns need to be handled properly.
;We should probably retry transfer with PI's turned off.   Hopefully, calling
;DDT will stop the DMA, but MTCSER and SAMSER may need to be told specially.
	TLNN TAC,S.WOVRN	;Write overrun?
	  JRST NOTWOV		;  No, some other disk error
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	  ASCIZ /Write overrun error! /
	MOVE DDB,C1DDBS		;Check for swap operation.
	MOVE TAC,DSKLRN(DDB)
	AOJN TAC,WOVNST
	PUSHJ P,DISMES
	  ASCIZ/SAT table!! Find a wizard. Don't reload!
/
	JRST WOVDDT
WOVNST:	SKIPGE DSKLRN(DDB)
	  JRST WOVSWP		;It's a swapping operation.  Reload prob. OK
	PUSHJ P,DISMES
	  ASCIZ/Don't reload!  You won't be able to read that disk record.
/
WOVSWP:	PUSHJ P,DISMES
	  ASCIZ/Type <esc>P to retry or find a wizard.
/
WOVDDT:	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCAL
	JRST C1SIMG		;Just keep retrying the transfer
;	---
NOTWOV:	MOVE TAC,C1PKSV
	SETZM PACTIV(TAC)	;FLUSH THIS TRANSFER
>;IFN FTF2
IFE FTF2,<
	SKIPN DEATH
	JRST NOSTP1		;DIDN'T DIE, TRY AGAIN.
	MOVE DDB,C1DDBS		;GET DDB ADDRESS
	MOVEI AC3,IODERR	;START WITH DEVICE ERROR
	LSH TAC,1
	ADD TAC,C1CHAN
	MOVE TAC,ERRCL2(TAC)	;GET DATA ERROR COUNT
	CAML TAC,MAXCL2		;OVER MAX LIMIT?
	TRO AC3,IODTER		;YES, GIVE DATA ERROR ALSO
	IORM AC3,DEVIOS(DDB)
	MOVE TAC,C1PKSV
	SETZM PACTIV(TAC)	;FLUSH THIS TRANSFER
	SKIPE REGOFL
	PUSHJ P,C1REGO		;RESTART ALL THE OTHER TRANSFERS
>;IFE FTF2
	MOVE DDB,C1DDBS		;SET UP DDB FOR C1ERET
	JRST C1ERET		;GO BACK TO CALLER OF TGO (WHICH LOOKS AT DEVIOS)

IFE FTF2,<
;HERE ALSO FROM FIXERR TO RESTART THE MRT AFTER THE ERROR IS FIXED
NOSTP1:	XCT C1CIFI(TAC1)	;CLEAR CIF
	SKIPN REGOFL
	JRST C1STRT		;START US AGAIN
	JRST C1REGO		;RESTART EVERYONE

;HERE FROM CONSZ CHAIN IN DSKCHN IF HNGFLG IS SET
↑C1HUNG:CONO PI,20000!<1⊗<7-DSKCHN>>	;CLEAR THE GENERATED INTERRUPT
	JSR DSKSV
	SETZM HNGFLG
	JRST C1CNF2		;RESTART ALL OPERATIONS IN PROGRESS

DRIVEP:	PUSHJ P,DISMES
	 ASCIZ /Drive /
	LDB TEM,[POINT 6,SNSDAT+1,7]
	JUMPN TEM,ISKNWN	;UNKNOWN?
	PUSHJ P,DISMES		;YES
	 ASCIZ /UNKNOWN/
	POPJ P,

ISKNWN:	ANDI TEM,7		;JUST THE IMPORTANT BITS
	ADDI TEM,"A"
	JRST DISTYO
>;IFE FTF2

IFN FTF2,<
;Print disk address in CURDA, which should be the current one
PCURDA:	PUSHJ P,DISMES
	 ASCIZ /PACK = /
	LDB TAC,[POINT 3,CURDA,6]	;Pack number
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ /  CYL = /
	LDB TAC,[POINT 13,CURDA,19]	;Cylinder
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ /  HD = /
	LDB TAC,[POINT 8,CURDA,27]	;Head
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ /  SEC = /
	LDB TAC,[POINT 8,CURDA,35]	;Physical sector
	PUSHJ P,DISLOC
;;	PUSHJ P,DISERR
	POPJ P,
>;IFN FTF2
;ERROR CLASS DESCRIPTIONS ;⊗
;CLASS 0:		       BYTE    BIT
;	INVALID TRACK FORMAT	1	1
;	END OF CYLINDER		1	2
;	NO RECORD FOUND		1	4
;	FILE MASK VIOLATION	1	5
;	OPERATION INCOMPLETE	1	7
;	TOO MANY LOSING SEARCHES
;	DATA CHAIN ERROR (CHANNEL CONI)
;	ATTENTION (STATUS BYTE)
;	BUSY (STATUS BYTE)
;	UNIT EXCEPTION (STATUS BYTE)
;	COMMAND REJECT		0	0
;		AND NOT:
;			WRITE INHIBITED
;			DIAG LOAD (OR ANY OTHER COMMAND) INVALID DATA
;			DIAG WRITE ERROR

;CLASS 1:
;	BUS OUT PARITY		BYTE 0 BIT 2
;	SELECT ERROR (CHANNEL CONI)
;	NXM (CHANNEL CONI)
;	PARITY ERROR (CHANNEL CONI, CORE TO DISK)
;	SENSE FAILED (ERROR ON SENSE AFTER UNIT CHECK)
;	EQUIPMENT CHECK		BYTE 0 BIT 3
;		AND NOT:
;			SEEK CHECK
;			RETRY ABORTED

;CLASS 2:
;	DATA CHECK		BYTE 0 BIT 4

;CLASS 3:
;	SEEK CHECK		BYTE 0 BIT 3  BYTE 7 = 32 OR 33 (OCTAL)

;CLASS 4:
;	OVERRUN			BYTE 0 BIT 5
;	RETRY ABORTED		BYTE 0 BIT 3  BYTE 7 = 6

;CLASS 5:
;	INTERVENTION REQUIRED	BYTE 0 BIT 1
;	WRITE INHIBITED		BYTE 1 BIT 6
;⊗ ERROR5 SYSLOS SYSLOZ DSKETY SYSLOX SYSLOY ERROR4 ERROR1 ERROR0 ERROR2 ERRORX TBAD TYTST TYPIT ERROR3 DORCL1 DORCL2 SENSE SENSE1 SENSE3 SENSE2

;Here if the someone pushed the wrong button maybe on the drive.
ERROR5:	AOS DSKFLG
	MOVE TAC,C1PKSV
	CAIG TAC,FPACKS-1
	JRST SYSLOS
	SETOM DEATH			;ERROR BIT TO LOSER!!!!
	MOVEI TAC,IOIMPM		;USE IMPROPER MODE BIT TO INDICATE OFF LINE OR WRITE LOCK
	MOVE TAC1,C1DDBS
	IORM TAC,DEVIOS(TAC1)
	POPJ P,

SYSLOS:
IFE FTF2,<
	TRNN UUO,WRTINH			;WRITE INHIBITED?
>;IFE FTF2
IFN FTF2,<
	TLNN UUO,S.WRP			;WRITE LOCK?
>;IFN FTF2
	JRST SYSLOX			;NO, MUST BE OFF LINE
	PUSHJ P,SYSLOZ
	PUSHJ P,DISMES
	 ASCIZ /PACK IN WRITE LOCK!
/
	POPJ P,

SYSLOZ:	SETOM CSTOP		;COLD STOP
DSKETY:	AOSE TYPANY
	POPJ P,
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /DSKERR/
	POPJ P,

SYSLOX:
IFE FTF2,<
	LDB TAC,[POINT 6,SNSDAT+1,7]	;DRIVE ID
	JUMPE TAC,SYSLOY
>;IFE FTF2
IFN FTF2,<
	TLNE UUO,S.SERR		;SELECT ERROR?
	JRST SYSLOY		;YES, NO ID PLUG
>;IFN FTF2
	PUSHJ P,SYSLOZ
	PUSHJ P,DISMES
	 ASCIZ/DRIVE NOT READY!
/
	POPJ P,

SYSLOY:	PUSHJ P,SYSLOZ
	PUSHJ P,DISMES
	 ASCIZ /ID PLUG NOT INSTALLED!
/
	POPJ P,

IFE FTF2,<		;Rest of page
;ERROR CLASS HANDLERS

ERROR4:	MOVEI TAC1,4
	JRST ERRORX

ERROR1:	PUSHJ P,DQUIET		;WAIT FOR ALL CHANNELS TO BE QUIET
	PUSHJ P,DISKUP		;BLAST THE DISK FOR CLASS 1 ERRORS
	AOS REGOFL		;SET FLAG TO RESTART EVERYONE
	MOVEI TAC1,1
	JRST ERRORX

ERROR0:	TDZA TAC1,TAC1		;CLASS 0
ERROR2:	MOVEI TAC1,2		;CLASS 2
ERRORX:	AOS DSKFLG		;INDICATE ERROR SEEN
	AOS TOTCL0(TAC1)
	MOVE TAC,TAC1
	IMULI TAC,NPACKS*2
	ADD TAC,C1PKSV
	ADD TAC,C1PKSV
	ADD TAC,C1CHAN
	AOS TAC,ERRCL0(TAC)
	CAMGE TAC,MAXCL0(TAC1)	;TOO MANY?
	JRST TYTST
TBAD:	SETOM DEATH		;KILL THE TRANSFER
	JRST TYPIT

TYTST:	TDNE TAC,TYMSK0(TAC1)	;SHOULD WE TYPE THIS ONE? (SKIP IF SHOULD TYPE)
	SKIPE TYPCL0(TAC1)	;OR MAYBE ALL OF THEM?
TYPIT:	SETOM WNTTYP		;FORCE TYPE OUT AT TYPE1
	POPJ P,

;ERROR3:MOVEI TAC1,3		;CLASS 3  SEEK CHECK
;	PUSHJ P,ERRORX		;COUNT AND TEST DEATH AND TYPING
;	SETZM ERRHA		;NOW SETUP FOR READ HA AND RECAL.
;	SETZM ERRRCL
;REHA:	PUSHJ P,BLAST		;CLEAR CHANNEL FOR READ HA
;	CONO IBM,CNEWST!CLREND!ACTCLR
;	CONO PMP,NEWST!UNEND!10!DSKCHN
;	DATAO PMP,[HA]
;	DATAO IBM,RDHACM
;	PUSHJ P,ISYNC
;	JRST REHA
;	CAIA
;	JRST DORCLA
;	CONO IBM,2
;	AOS TAC,ERRHA
;	CAMGE TAC,MAXHA
;	JRST REHA
;	PUSHACS
;	PUSHJ P,SYSLOZ			;FLAG TYPEOUT, MAYBE PRINT TIME, COLD STOP
;	PUSHJ P,DISMES
;	 ASCIZ /READ HOME ADDRESS LOST!
;/
;	POPACS
;	POPJ P,
;
;DORCLA:SETOM HAFLAG

ERROR3:	MOVEI TAC1,3		;CLASS 3  SEEK CHECK
	PUSHJ P,ERRORX		;COUNT AND TEST DEATH AND TYPING
	MOVE TAC1,C1CHAN	;GET CHANNEL
	MOVE UCHN,C1PKSV	;AND PACK NUMBER
	XCT C1CIFI(TAC1)	;CLEAR CIF
	PUSHJ P,C1MPIS		;SET UP UCHN AS PDL PNTR TO PROGRAM
	PUSH UCHN,[C1JMP,,C1RCAL]	;STORE THE JUMP AS THE FIRST INSTR
	MOVE TAC,C1PKSV		;GET PACK BACK IN TAC
	POP P,@C1RCFP(TAC1)	;SET RECAL IN PROGRESS FOR THIS PACK
	JRST C1STRT		;SET START CODE AND DISMISS

;HERE FROM C1SYNI WHEN A RECAL COMPLETES NORMALLY, CHANNEL IN TAC1, PACK IN TAC
DORCL1:	PUSHJ P,C1ACSV
	PUSH P,@C1RCFP(TAC1)		;STORE RETURN ADDRESS ON STACK
	SETZM @C1RCFP(TAC1)		;CLEAR RECAL IN PROGRESS FLAG
	JRST SENSE3			;COPY SENSE DATA BACK TO SNSDAT AND FIX PGM

;HERE FROM C1SYN1 IF AN ERROR OCCURRED DURING A RECAL
DORCL2:	PUSH P,@C1RCFP(TAC1)
	SETZM @C1RCFP(TAC1)
	POPJ P,

SENSE:	MOVE TAC1,C1CHAN		;GET CHANNEL ....
	MOVE TAC,C1PKSV			;... AND PACK NUMBER AGAIN
	XCT C1CIFI(TAC1)		;CLEAR CIF
	MOVE UCHN,TAC
	PUSHJ P,C1MPIS			;SET UP UCHN AS PDL PNTR TO PROGRAM
	IMULI TAC,C1SNSL		;LENGTH OF SENSE PROGRAM
	MOVE AC1,C1SNPP(TAC1)		;JUMP TO CORRECT SENSE PGM FOR DRIVE 0
	ADD AC1,TAC			;JUMP TO SENSE PGM FOR OUR DRIVE
	PUSH UCHN,AC1			;STORE THE JUMP AS THE FIRST INSTR
	MOVE DDB,C1DDBS
	MOVE TAC,C1ASAV
	MOVEM TAC,SNSSTA(DDB)		;SAVE STAT A IN DDB
	MOVE TAC,C1PKSV			;GET PACK BACK IN TAC
	POP P,@C1SNFP(TAC1)		;SET SENSE IN PROGRESS FOR THIS PACK
	JRST C1STRT			;SET START CODE AND DISMISS

;HERE FROM C1SYNI WHEN A SENSE COMPLETES NORMALLY, CHANNEL IN TAC1, PACK IN TAC
SENSE1:	PUSHJ P,C1ACSV
	MOVE AC1,SNSSTA(DDB)
	MOVEM AC1,C1ASAV		;RESTORE STAT A TO STATE BEFORE SENSE
	PUSH P,@C1SNFP(TAC1)		;STORE RETURN ADDRESS ON STACK
	SETZM @C1SNFP(TAC1)		;CLEAR SENSE IN PROGRESS FLAG
SENSE3:	MOVE AC1,TAC
	IMULI AC1,6
	ADD AC1,C1SNDP(TAC1)		;ADDRESS OF SENSE DATA
	HRLZ AC1,AC1
	HRRI AC1,SNSDAT
	BLT AC1,SNSDAT+5		;COPY SENSE DATA TO SNSDAT
	MOVE UCHN,TAC
	PUSHJ P,C1MPIS			;SET UP UCHN AS PDL PNTR TO PROGRAM
	MOVEI AC1,2(UCHN)
	HRLI AC1,C1JMP
	PUSH UCHN,AC1			;RESTORE ORIGINAL JUMP .+1 TO THE MRT
	JRST CPOPJ1

;HERE FROM C1SYN1 IF AN ERROR OCCURRED DURING A SENSE
SENSE2:	PUSH P,@C1SNFP(TAC1)
	SETZM @C1SNFP(TAC1)
	POPJ P,
>;IFE FTF2
;⊗ FIXERR FIXSRC NOECRM FIXSC2 FIXSCN FIXSC1 CANFIX CANFX1 CANFX2 FIXER1 FIXOUT FIXMES SUPECL SUPEC3 SUPEC4 SUPEC2 SUPEC5 FXSATL FXNOTK FXETKL FXKNWN FXNETK NEWECC NEWEC1 NEWEC0 NEWEC2 NEWEC3 FXMSGX DFNODS DFNOST FIXDN FIXDN1 FIXDN3 HDCRSH HDCRS1 HDCRS2 FIXERP FIXRP2 FIXRP1 FIXLS1

IFE FTF2,<	;Whole page

;FIXERR  USE SENSE BYTES TO XOR OUT BAD BITS IN CORE
;RESTART DISPLACEMENT IS BYTES 15 THROUGH 17
;ERROR DISPLACEMENT IS BYTES 18 AND 19
;PATTERN IS BYTES 20 THROUGH 22

FIXERR:	MOVE TAC,C1PRGS			;GET ADDRESS OF PROGRAM HEADER
	MOVE TAC1,C1INST+1(TAC)		;GET THE MRT COMMAND
	TLNE TAC1,1			;SKIP IF THE IBM COMMAND IS A READ
	JRST SNSDN1			;CAN'T FIX WRITE ERRORS?!?!?
	MOVE TAC,C1LSPC			;GET PC
	MOVSI AC1,C1RECB		;START OF RECORD BIT IN WCMA
FIXSRC:	TDNN AC1,(TAC)			;SHOULD FIND BIT ON FIRST TIME
	SOJA TAC,FIXSRC
	MOVEM TAC,C1XPNT		;SAVE POINTER TO FIRST WCMA IN DATA CHAIN
	LDB TAC,[POINT 8,SNSDAT+3,31]	;BYTE 15
	LDB AC2,[POINT 16,SNSDAT+4,15]	;BYTES 16-17
	DPB TAC,[POINT 8,AC2,19]	;AC2 ← BYTES 15-17  RESTART DISPLACEMENT
	MOVE TAC,C1LREC			;RECORD NUMBER BEING TRANSFERED
	HRRZ AC1,RCLTAB(TAC)		;RECORD SIZE IN WORDS
	MOVE UCHN,AC1			;SAVE RECORD SIZE IN WORDS IN UCHN
	ASH AC1,-1			;MULTIPLY BY 4 1/2 BYTES PER WORD
	IMULI AC1,9
	CAIE AC1,(AC2)			;SHOULD BE EQUAL TO DISPLACEMENT
	JRST FIXLS1			;COMPLAIN
	LDB TAC,[POINT 16,SNSDAT+4,31]	;BYTES 18-19 ERROR DISPLACEMENT
	JUMPE TAC,FIXDN			;ERROR WAS IN ECC BYTES
	LDB TAC1,[POINT 24,SNSDAT+5,23]	;BYTES 20-22 ERROR PATTERN
	CAIN TAC,2
	TRZ TAC1,377			;ERROR PARTIALLY IN ECC BYTES
	CAIN TAC,1
	TRZ TAC1,177777			;ERROR PARTIALLY IN ECC BYTES
	SUBI AC2,(TAC)			;AC2←RESTART DISPL-ERROR DISPL
;AC2←NUMBER OF BYTES FROM START OF XFER TO FIRST BYTE IN ERROR

	HRRZ DDB,C1DDBS
IFN FTSIX,<
	SKIPN IOWDSX(DDB)		;SKIP IF XFER IS TO P3 MEMORY
	JRST CANFIX
	SKIPL AC3,ECCSIX(DDB)		;SKIP IF THERE IS ANY MORE ROOM IN ECC AREA
	JRST NOECRM
	MOVE AC1,TAC1			;GET ECC BITS
	LDB J,PJOBN
IFE FTMPP2,<
	MOVE UUO,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	PUSH P,AC1
	PUSHJ P,JOBMAP
	 JFCL
	MOVEI UUO,(AC1)
	POP P,AC1
>;IFN FTMPP2
	LSH UUO,9
	LDB TAC1,[POINT 9,AC3,26]	;USER PAGE NUMBER OF ECC AREA
	ADDI UUO,(TAC1)
	LDB TAC,[POINT 13,(UUO),35]	;PHYSICAL PAGE NUMBER OF ECC AREA
	MOVEI TAC1,DSKEXP
	PUSHJ P,ADDEMP
	LDB TAC,[POINT 13,1(UUO),35]
	MOVEI TAC1,DSKEXP+1
	PUSHJ P,ADDEMP
	ANDI AC3,777			;KEEP OFFSET WITHIN PAGE ONLY
	DPB AC2,[POINT 12,AC1,11]	;MAKE BYTE(12)OFFST(24)BITS
	MOVEM AC1,DSKEXP⊗9(AC3)		;STORE IT IN USER
	MOVE UUO,@C1XPNT		;GET FIRST DATA POINTER WORD
	MOVN UCHN,UCHN			;NEGATIVE RECORD SIZE
	HRL UUO,UCHN			;AOBJN POINTER TO RECORD IN P3 MEMORY
	MOVEM UUO,DSKEXP⊗9+1(AC3)	;PUT IN ECC LOG AREA
	MOVE TAC,[2,,2]
	ADDM TAC,ECCSIX(DDB)		;UPDATE USER'S ECC POINTER
	JRST FIXOUT			;FLUSH EXEC PAGES AND TYPE MESSAGE

NOECRM:	TLNE AC3,-1
	JRST FIXMES			;THIS ISN'T THE FIRST ERROR THAT WON'T FIT
	HRLI AC3,1
	MOVEM AC3,ECCSIX(DDB)
	HRRZ AC3,@C1XPNT		;REMEMBER P3 ADDRESS OF START OF LOSING XFER
	MOVEM AC3,ECCLOS(DDB)
	JRST FIXMES
>;IFN FTSIX
IFE FTSIX,<
	JRST CANFIX
>;IFE FTSIX

FIXSC2:	SKIPGE TEM,(UUO)		;GET DATA POINTER, SKIP IF NOT A DATA PNTR
	TLNE TEM,C1RECB			;SKIP IF NOT A NEW RECORD
	POPJ P,
FIXSCN:	LDB TEM,[POINT 12,(UUO),13]	;GET WORD COUNT
	CAIGE AC2,(TEM)
	JRST FIXSC1			;AC2 IS INSIDE THIS BLOCK
	SUBI AC2,(TEM)			;SUBTRACT OF THE SIZE OF THIS BLOCK
	AOJA UUO,FIXSC2			;AND TRY THE NEXT

FIXSC1:	LDB TEM,[POINT 22,(UUO),35]	;STARTING ADDRESS OF BLOCK
	ADD TEM,AC2			;ABSOLUTE ADDRESS OF WORD
	JRST CPOPJ1

;AC2←NUMBER OF BYTES FROM START OF XFER TO FIRST BYTE IN ERROR
CANFIX:	IDIVI AC2,9		;AC2←WORD-PAIR NUMBER, AC3←BYTE #(0 TO 8)
	ASH AC2,1		;AC2=NUMBER OF WORDS FROM START OF XFER
				;TO FIRST WORD OF 2-WD PAIR CONTAINING ERR
	CAIL AC3,7
	ADDI AC2,1		;ERRORS IN 2ND AND 3RD WORD
	MOVE UUO,C1XPNT		;ADDRESS OF FIRST DATA POINTER
	PUSHJ P,FIXSCN
	 JRST FIXMES		;FORGET IT
	PUSH P,TEM
	ADDI AC2,1		;NEXT WORD
	PUSHJ P,FIXSCN
	 TDZA UUO,UUO		;FLAG NO SECOND PAGE
	MOVNI UUO,2		;NEG MEANS BOTH AC2 AND TEM EXIST
				;-2 SO CAN ADDI UUO,1 NEAR CANFX2
				;AND STAY NEGATIVE
	POP P,AC2		;AC2←ABS ADDR OF 1ST, TEM←ABS ADDR OF 2ND
;AC2 IS ADDRESS OF THE FIRST OF TWO WORDS IN WHICH THE FIRST ERRONEOUS BYTE APPEARS

	PUSH P,TAC1		   ;SAVE THE ERROR PATTERN
	LDB TAC,[POINT 13,AC2,26]  ;PAGE NUMBER
	MOVEI TAC1,DSKEXP	   ;SETUP EXEC PAGES TO REFERENCE USER CORE.
	DPB TAC1,[POINT 13,AC2,26] ;CLOBBER ADDRESS TO POINT TO EXEC SPACE
	MOVEI TAC1,DSKEXP
	PUSHJ P,ADDEMP
	JUMPGE UUO,CANFX1
	LDB TAC,[POINT 13,TEM,26]
	MOVEI TAC1,DSKEXP+1
	DPB TAC1,[POINT 13,TEM,26]
	PUSHJ P,ADDEMP
CANFX1:	POP P,TAC1
	CAIGE AC3,7
	JRST CANFX2
	EXCH AC2,TEM
	ADDI UUO,1		;UUO←-1 IF BOTH EXIST, 1 IF 3RD WD NON-EX
CANFX2:	LSH TAC1,=12		;LEFT ADJUST PATTERN BYTE
FIXER1:	MOVEI TAC,0
	LSHC TAC,8
	PUSHJ P,FIXERP
	JUMPN TAC1,FIXER1
FIXOUT:	MOVEI TAC1,DSKEXP	;FLUSH EXEC PAGES
	PUSHJ P,DELEMP
	ADDI TAC1,1
	SKIPGE UUO
	PUSHJ P,DELEMP
FIXMES:
IFN FTECCT,<
	SETZM ECCMSG		;ASSUME NOTHING SPECIAL TO TYPE OUT
>;IFN FTECCT
	LDB TAC,[POINT 8,SNSDAT+1,15]	;LOW 8 CYL BITS
	LDB TEM,[POINT 2,SNSDAT+1,18]	;HIGH 2 CYL BITS
	DPB TEM,[POINT 2,TAC,27]	;CC
	PUSH P,TAC			;SAVE CYLINDER NUMBER
	IMULI TAC,TRKCYL		;CYL*(TRACKS/CYL)
	LDB TEM,[POINT 5,SNSDAT+1,23]	;HEAD
	ADDI TAC,(TEM)		;TRACK NUMBER RELATIVE TO BEGINNING OF PACK
	EXCH TEM,(P)		;TEM←CYL, (P)←HEAD
	PUSH P,TEM		;(P)←CYL, -1(P)←HEAD
IFN FTECCT!FTQECC,<
	LDB TEM,PUNIT		;GET DSK/UDP NUMBER FROM DDB
	JUMPE TEM,.+2		;IF THIS IS A UDP,
	MOVEM TAC,FXTRKN	; REMEMBER TRACK NUMBER WITHIN THIS PACK
>;IFN FTECCT!FTQECC
	MOVE TAC1,C1PKSV
	ADD TAC,PACKAD-1(TAC1)	;ADD THE LAST TRACK NUMBER OF PREVIOUS PACK
	ADDI TAC,1		;PLUS 1 TO MAKE FIRST TRACK OF THIS PACK
	PUSH P,TAC		;(P)←OVERALL TRACK NUMBER, -1(P)←CYL, -2(P)←HEAD
IFN FTECCT!FTQECC,<
	JUMPN TEM,.+2		;IF THIS IS THE SYSTEM DSK STRUCTURE,
	MOVEM TAC,FXTRKN	; REMEMBER TRACK NUMBER WRT ENTIRE STRUCTURE
>;IFN FTECCT!FTQECC
IFN FTQECC,<
	SETZM ECCMS2		;ASSUME NOT SUPPRESSING LATER ECCS FOR THIS TRACK
	SKIPN TAC,FXTRKN	;GET TRACK NUMBER RELATIVE TO DISK UNIT
	JRST SUPEC2		;DON'T SUPPRESS ECC MESSAGES FOR (RELATIVE) TRACK 0
	SKIPN TTYLOK		;Don't suppress ECC when system is down
	SKIPE MAINTM
	JRST SUPEC2		;Print all ECCs -- system is down
	MOVEI TAC1,(TEM)	;UNIT NUMBER
	IMULI TAC1,LECCQU	; TIMES NUMBER OF SUPPRESSABLE ECC TRACKS PER UNIT
	ADDI TAC1,ECCQUI	; PLUS TABLE BASE GIVES ADDR OF BLOCK FOR THIS UNIT
	HRLI TAC1,-LECCQU	;MAKE AOBJN PTR TO ECC SUPPRESS BLOCK FOR THIS UNIT
SUPECL:	CAIN TAC,@(TAC1)	;37,,0 BITS IN TABLE GUARANTEED ZERO, LH NON-ZERO
	JRST [	MOVSI AC1,100	;THIS TRACK IN TABLE, SUPPRESS ECC TYPEOUT
		ADDB AC1,(TAC1)	; BUT COUNT ECCS ON THIS TRACK, IN CORE ONLY
		SETOM ECCMS2	;FLAG MESSAGE ROUTINE TO SAY FURTHER ECCS SUPPRESSED
		TLNN AC1,777600	;IF THIS IS THE FIRST OR 2↑12TH ECC ON THIS TRACK,
		JRST SUPEC2	; THEN PRINT ECC AFTER ALL
		JRST SUPEC3]	;Fix stack and skip around msg typeout
	AOBJN TAC1,SUPECL	;LOOK THROUGH TABLE, FALL THRU IF NOT IN TABLE
IFN FTSECC,<
	AOS TAC1,NECCS
	LDB TEM,[POINT 6,SNSDAT+1,7] ;Find out what drive
	JUMPE TEM,SUPEC2	;IF UNKNOWN, then print ECC
	ANDI TEM,7		;JUST THE IMPORTANT BITS
;The following code can be patched in to suppress ECC msgs from particular drive(s)
	CAIE TEM,"G"-"A"	;Suppress most ECCs from losing LLL drive G
	CAIN TEM,"D"-"A"	;Suppress most ECCs from losing drive D (moved pack)
jfcl;	CAIA			;Drive G or D, suppress!
	JRST SUPEC2		;Not drive G
	TRNN TAC1,377		;SUPPRESS typeout of 377 OUT OF 400 ECCs on G
	JRST SUPEC4		;PRINT ECC MSG
	MOVE TAC1,C1PKSV	;GET BACK PACK NUMBER
	IMULI TAC1,TRKCYL	;PACK*<NUMBER OF HEADS/PACK>+HD
	ADD TAC1,-2(P)		;  FORMS AN INDEX TO RTRHCT
	AOS RTRHCT(TAC1)	;Count ECC although suppressing msg
SUPEC3: ADJSP P,-3		;FLUSH DATA FROM STACK
	JRST FIXDN		; AND JUMP TO BEYOND MESSAGE TYPEOUT

SUPEC4:	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /256ECC/	;Tell how many ECCs this msg represents!
	JRST SUPEC5		;256 decimal is 400 octal

>;IFN FTSECC
SUPEC2:				;DON'T SUPPRESS ECC MSG
>;IFN FTQECC
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /DF ECC/
SUPEC5:	PUSHJ P,DRIVEP		;PRINT DRIVE LETTER
	PUSHJ P,DISMES
	 ASCIZ /  TK = /
	MOVE TAC1,C1PKSV	;GET BACK PACK NUMBER
	IMULI TAC1,TRKCYL	;PACK*<NUMBER OF HEADS/PACK>+HD
	ADD TAC1,-2(P)		;  FORMS AN INDEX TO RTRHCT
IFN FTECCT,<
NoStructure,<
	LDB TEM,PUNIT		;GET BACK UNIT NUMBER, CLOBBERED BY DISMES, ETC.
	SKIPN UUO,SATADR(TEM)	;GET SAT ADDRESS
>;NoStructure
IfStructure,<
	MOVE TEM,SDBPTR(DDB)
	SKIPN UUO,ST.SAD(TEM)
>;IfStructure
	JRST FXNOTK		;HUH? NO SAT
	ADD UUO,ECCAOB		;MAKE AOBJN POINTER TO ECC TRACK DATA
	SKIPN TEM,FXTRKN	;GET TRACK NUMBER
	JRST NEWEC3		;NEVER MIND DF ECC ON TRACK 0
FXSATL:	SKIPN (UUO)		;ZERO ENTRY MEANS NO MORE TRACKS LISTED
	JRST FXNOTK		; SO THIS TRACK ISN'T KNOWN
	CAME TEM,(UUO)		;SEE IF IT IS A KNOWN MARGINAL TRACK
	AOBJN UUO,FXSATL
	JUMPL UUO,FXKNWN	;JUMP IF ALREADY KNOWN AS MARGINAL
	MOVEI UUO,0		;NOT KNOWN, AND TABLE IS FULL
FXNOTK:	AOS RTRHCT(TAC1)	;COUNT ERROR FOR PK/HD NOT ON KNOWN LOSER
	IMULI TAC1,NECCTK	;MAKE INDEX INTO INCORE ECC TRK TABLE FOR THIS HD/PK
	HRLI TAC1,-NECCTK	;MAKE AOBJN POINTER
	MOVE TEM,(P)		;GET THE TRACK NUMBER BACK
FXETKL:	SKIPN ECCTKT(TAC1)	;LOOK THRU TABLE OF TRACKS W/ECC'S IN RUNNING SYSTEM
	JRST FXNETK		;NO MORE ENTRIES, THIS IS A NEW ONE
	CAIE TEM,@ECCTKT(TAC1)	;37,,0 BITS GUARANTEED 0 BUT LH NONZERO
	AOBJN TAC1,FXETKL
	JUMPGE TAC1,HDCRSH	;TOO MANY DISTINCT ECC TRACKS FOR THIS PK/HD
	MOVSI TEM,100		;ALREADY KNOWN, COUNT IT UP
	ADDB TEM,ECCTKT(TAC1)
	TLNN TEM,777400		;4 OR MORE HITS ON SAME TRACK?
	JRST NEWEC3		;NO, THAT'S ALL WE DO
	JUMPN UUO,NEWECC	;YES, RECORD NEW MARGINAL TRACK IF ROOM
	MOVEI TEM,4		;MAKE MESSAGE TYPE OUT "SAT FULL"
	JRST NEWEC2

FXKNWN:	MOVEI TEM,1		;MAKE MESSAGE TYPE OUT "OLD"
	JRST NEWEC2

FXNETK:	HRLI TEM,100		;NEW ENTRY, COUNT=1
	MOVEM TEM,ECCTKT(TAC1)
	MOVEI TEM,2		;MAKE MESSAGE TYPE OUT "NEW"
	JRST NEWEC2

;HERE WHEN IT IS TIME TO LIST A NEWLY REPEATING ECC TRACK INTO SAT'S ECC TABLE
NEWECC:	MOVEI TEM,5		;IF SYSTEM IS DOWN, JUST SAY "REPEATED"
	SKIPE MAINTM
	JRST NEWEC2		;DON'T MODIFY SAT IF SYSTEM IS DOWN
	MOVE TEM,FXTRKN		;GET BACK SAT-FORMAT TRACK NUMBER
	MOVEM TEM,(UUO)		;SAVE IN SAT
NoStructure,<
	LDB TEM,PUNIT		;WHICH SAT IS IT?
	SETOM SATMOD(TEM)	;INDICATE SAT CHANGED
>;NoStructure
IfStructure,<
	MOVE TEM,SDBPTR(DDB)
	SETOM ST.SMD(TEM)	;INDICATE SAT CHANGED
>;IfStructure
	SETZM ECCTKT(TAC1)	;NOW REMOVE THE (REDUNDANT) ECCTKT ENTRY
	AOBJP TAC1,NEWEC0
NEWEC1:	SKIPN TEM,ECCTKT(TAC1)	;COMPACT THE TABLE
	JRST NEWEC0
	MOVEM TEM,ECCTKT-1(TAC1)
	AOBJN TAC1,NEWEC1
	SETZM ECCTKT-1(TAC1)	;IN CASE IT WAS FULL
NEWEC0:	MOVEI TEM,3		;MAKE MESSAGE TYPE OUT "INTO SAT"
NEWEC2:	MOVEM TEM,ECCMSG	;REMEMBER DISPOSITION OF ECC TRACK FOR MESSAGE
NEWEC3:	MOVEI UUO,0		;FLAG NOT A HEAD CRASH
FXMSGX:				;ENTER HERE FROM HDCRSH
>;IFN FTECCT
IFE FTECCT,<
	AOS RTRHCT(TAC1)	;COUNT AN ERROR BY THIS PACK AND HEAD
>;IFE FTECCT
	POP P,TAC		;OVERALL TRACK NUMBER
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ / PK = /
	MOVE TAC,C1PKSV
	PUSHJ P,DISDCP
	PUSHJ P,DISMES
	 ASCIZ /  CY = /
	POP P,TAC		;CYLINDER
	PUSHJ P,DISDCP
	PUSHJ P,DISMES
	 ASCIZ / HD = /
	MOVE TAC,(P)		;HEAD
	PUSHJ P,DISDCP
	PUSHJ P,DISMES
	 ASCIZ /(#/
	POP P,TAC		;HEAD
	MOVE TAC1,C1PKSV	;GET BACK PACK NUMBER
	IMULI TAC1,TRKCYL	;PACK*<NUMBER OF HEADS/PACK>+HD
	ADD TAC1,TAC		;  FORMS AN INDEX TO RTRHCT
	MOVE TAC,RTRHCT(TAC1)	;GET NUMBER OF ERRORS/RETRIES FOR THIS HEAD
	PUSHJ P,DISDCP		; AND PRINT IT
	PUSHJ P,DISMES
	 ASCIZ /) RC = /
	MOVE TAC,C1LREC
	PUSHJ P,DISDCP
IFN FTECCT,<
	SKIPL TEM,ECCMSG	;GET DISPOSITION OF ECC
	CAILE TEM,6		;SKIP IF LEGAL VALUE
	MOVEI TEM,6		;ILLEGAL INDEX
	MOVE AC1,(TEM)[
		[ASCIZ/    /]	;COUNT IS UP TO 2 OR 3, OR THIS IS TRACK 0
		[ASCIZ/ OLD/]	;ALREADY IN SAT TABLE (KNOWN MARGINAL TRACK)
		[ASCIZ/ NEW/]	;NOT IN SAT, 1ST ECC ON THIS TRACK IN THIS SYSTEM
		[ASCIZ/ MRK/]	;4TH ECC ON THIS TRACK IN THIS SYSTEM, NOW IN SAT
		[ASCIZ/ FUL/]	;WOULD'VE GONE INTO SAT TABLE, BUT ECC TABLE FULL
		[ASCIZ/ MDN/]	;WOULD'VE GONE INTO SAT TABLE, BUT SYSTEM DOWN
		[ASCIZ/ ???/]	;INDEX TOO LARGE
		       ]	;GET ADDRESS OF MESSAGE
	PUSHJ P,DISSTR		;TYPE IT
DFNODS:
>;IFN FTECCT
	LDB TAC,PUNIT		;UDP NUMBER
	JUMPE TAC,DFNOST	;IGNORE SATID IF SYS PACK
NoStructure,<
	SKIPN TAC,SATADR(TAC)
>;NoStructure
IfStructure,<
	MOVE TAC,SDBPTR(DDB)
	SKIPN TAC,ST.SAD(TAC)	;SAT Address
>;IfStructure
	JRST DFNOST		;MAYBE OLD STYLE UDP
	PUSH P,SATID(TAC)
	PUSHJ P,DISMES		;PRINT NAME OF (NEW STYLE) UDP
	 ASCIZ /  /
	POP P,TAC1		;get structure name
	PUSHJ P,DISSIX
DFNOST:
IFN FTQECC,<
	MOVEI AC1,[ASCIZ/  LATER ECCs SUPPRESSED/]
	SKIPE ECCMS2
	PUSHJ P,DISSTR		;WE'RE SUPPRESSING FURTHER ECC MSGS FOR THIS TRACK
>;IFN FTQECC
	PUSHJ P,DISCRLF
IFN FTECCT,<
	JUMPN UUO,HDCRS1	;JUMP IF HEAD CRASH
>;IFN FTECCT
FIXDN:	MOVE UUO,C1XPNT		;ADDRESS OF 1ST PNTR IN CHAIN FOR C1LREC
	ADDI UUO,1
FIXDN1:	SKIPGE AC1,(UUO)
	TLNE AC1,C1RECB
	CAIA			;FOUND NEXT RECORD OR END OF MRT
	AOJA UUO,FIXDN1		;FOUND ANOTHER DATA POINTER IN THE CHAIN
	HRLI UUO,C1JMP
	MOVE TAC,C1PRGS
	MOVEM UUO,C1INST+4(TAC)		;STORE THE JUMP TO THE FIRST DATA PTR
REPEAT 1,<
	LDB AC2,[POINT 10,SNSDAT+1,26]	;high 2 cyl bits + 8 don't-care bits
	LDB TEM,[POINT 8,SNSDAT+1,15]	;low 8 cyl bits
	DPB TEM,[POINT 8,AC2,35]	;make cyl number in ac2
	LDB TEM,[POINT 5,SNSDAT+1,23]	;head
	LDB AC1,[POINT 8,C1INST+3(TAC),23] ;wrap record
	MOVE TAC1,C1LREC		;Number of fixed record
	ADDI TAC1,1			;Restart xfer at next record
	CAIE TAC1,RCPTRK		;End of track?
	JRST FIXDN3			;No
	MOVE TAC1,AC1			;Yes, go to wrap record of next track
	ADDI TEM,1			;Use next head
	CAIGE TEM,TRKCYL		;Advancing from last track of cyl?
	JRST FIXDN3			;No
	MOVEI TEM,0			;Yes, use first head on the
	ADDI AC2,1			;  next cylinder
	MOVE AC1,C1PKSV			;Get pack number
	MOVE AC1,NCYL(AC1)		;Number of cyls on this pack
	CAIL AC2,(AC1)			;Advancing off this pack?
	MOVEI AC2,-1(AC1)		;Yes, but don't, probably end of xfer.
FIXDN3:	LSH AC2,=20			;C C 0 0 (cylinder) (8-bit bytes)
	DPB TEM,[POINT 8,AC2,23]	;C C H 0 (head)
	DPB TAC1,[POINT 8,AC2,31]	;C C H R (record)
>;REPEAT 1
REPEAT 0,< ;buggy version, doesn't advance to next track from error in last rec.
	LDB AC2,[POINT 2,SNSDAT+1,18]	;HIGH 2 CYL BITS
	LSH AC2,=28			;C 0 0 0
	LDB TEM,[POINT 8,SNSDAT+1,15]	;LOW 8 CYL BITS
	DPB TEM,[POINT 8,AC2,15]	;C C 0 0
	LDB TEM,[POINT 5,SNSDAT+1,23]	;HEAD
	DPB TEM,[POINT 8,AC2,23]	;C C H 0
	LDB AC1,[POINT 8,C1INST+3(TAC),23]	;WRAP RECORD
	MOVE TEM,C1LREC
	ADDI TEM,1
	CAIN TEM,RCPTRK
	MOVE TEM,AC1
	DPB TEM,[POINT 8,AC2,31]	;C C H R
>;REPEAT 0
	MOVEM AC2,C1INST+2(TAC)		;STORE MRT FIRST PARAMETER WORD
	MOVE AC2,SECTBL(TEM)		;SET SECTOR VALUE FOR FIRST RECORD
	DPB AC2,[POINT 8,C1INST+3(TAC),7]	;FIX MRT SECOND PARAMETER WORD
	MOVE AC2,C1INST+4(TAC)		;GET THE JUMP TO THE FIRST DATA PTR
	SKIPN (AC2)			;SKIP IF THERE IS MORE MRT
	MOVEM AC2,C1INST(TAC)		;JUMP AROUND MRT
	MOVE TAC1,C1CHAN
	MOVE TAC,C1PKSV
	JRST NOSTP1			;RESTART THE MRT

IFN FTECCT,<
HDCRSH:	MOVEI UUO,1		;FLAG TO COME BACK HERE
	MOVEM TAC1,FXTRKN	;SAVE THIS POINTER
	JRST FXMSGX		;FINISH THE MESSAGE

HDCRS1:
printx HEAD CRASH detect code temporarily disabled!
REPEAT 0,<
IFN FTP2,<
	SETOM KABELL		;RING A BELL LOUD ENOUGH TO BE HEARD!
>;IFN FTP2
	PUSHJ P,DISMES
	 ASCIZ /  POSSIBLE HEAD CRASH ON THIS PACK!!!
  OTHER NEW TRACKS: /
	MOVE UUO,FXTRKN		;GET POINTER TO END OF OUR ECCTKT SECTION
	SUBI UUO,NECCTK		;POINTER TO BEGINNING OF SECTION
	HRLI UUO,-NECCTK	;AOBJN POINTER
HDCRS2:	HRRZ TAC,ECCTKT(UUO)	;GET A TRACK
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ / /
	AOBJN UUO,HDCRS2
	PUSHJ P,DISMES
	 ASCIZ /
CALL A WIZARD BEFORE CONTINUING OR RELOADING!
/
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
>;REPEAT 0
	JRST FIXDN		;FALSE ALARM, CORRECT THE DATA
>;IFN FTECCT

;ERROR PATTERN IS IN TAC, ADDRESS IS IN AC2, BYTE NUMBER (0-8) IS IN AC3
FIXERP:	JUMPE TAC,FIXRP2
	CAIN AC3,4		;BYTE 4 IS WEIRD
	JRST FIXRP1
	MOVEI AC1,(AC3)
	CAIG AC1,4
	AOBJP AC1,.+2		;LH(AC1) IS FLAG TO USE FIRST WORD OF 2
	SUBI AC1,4
	LSH AC1,3		;MULTIPLY BY 8 (MOVES FLAG TO 10 BIT)
	CAIL AC3,5
	ADDI AC1,4
	MOVN AC1,AC1		;AND NEGATE (COMPLEMENTS FLAG)
	ROT TAC,(AC1)		;SHIFT PATTERN TO CORRECT PLACE
	TLNN AC1,10
	SKIPLE UUO		;EVEN WD NON-EX IF UUO POSITIVE
	CAIA
	XORM TAC,(AC2)		;CLOBBER 0-4A (EVEN) WORD
	TLNE AC1,10
	SKIPN UUO		;ODD WD NON-EX IF UUO ZERO
	CAIA
	XORM TAC,(TEM)		;CLOBBER 4B-8 (ODD) WORD
FIXRP2:	CAIGE AC3,8
	AOJA AC3,CPOPJ
	MOVEI AC3,0
	POPJ P,

FIXRP1:	LSHC TAC,-4
	XORM TAC,(AC2)
	LSHC TAC,4
	ANDI TAC,17
	ROT TAC,-4
	SKIPE UUO		;FORGET IT IF 4B-8 (ODD) WD DOESN'T EXIST
	XORM TAC,(TEM)
	AOJA AC3,CPOPJ

FIXLS1:	PUSHJ P,DSKETY		;FLAG TYPEOUT, MAYBE PRINT TIME
	PUSHJ P,DISMES
	 ASCIZ /RCLTAB AND RESTART DISPLACEMENT DISAGREE
/
	AOS DSKFLG
	SETOM DEATH		;CAUSE XFER TO BOMB
	AOS SNSTYP
	JRST TYPE0

>;IFE FTF2
;Start of many pages of IFN FTF2 ;⊗ NUNTBT NCYLBT NSRFBT NSECBT ENDBIT SELBIT DSKIFG F2DCNT NDTRY S.ANY S.NACT S.SERR S.WRP S.NRDY S.SKER S.FALT S.NBSY S.HECC S.SECC S.ROVRN S.WOVRN S.IPE C.USC C.REL C.REC C.FCLR C.DSL C.DSE C.SOM C.COP C.CFM OP.RD OP.WRT OP.CTRL C.32B C.IENA C.IEND L.INIT L.START

IFN FTF2,<	;Goes on for many pages.

Comment ⊗

Assumptions about F2 disk controller:

	(1) Will someday be able to do overlapped seeks.
	(2) Cannot start a seek while data is being transferred on another drive.

PACBSY(pack #) is used to indicate that a pack is busy doing something; it
  is also used as a hung time countdown, set positive when pack started.

ACs used by C1 decoder:
TAC/ drive unit number
AC1/ address of C1 instruction (or parameter word) being examined
AC2/ count of data words to transfer for this C1 data pointer word
DSER/ WAITS record number of transfer

Foonly code's ACs have been renamed as follows:
  0→UUO
  A→DAT
  B→UCHN
  C→TEM
  D→TAC

end of comment ⊗

;Four consecutive fields in the F2 disk controller's disk address.
NUNTBT←←=6		;0:5   NUMBER OF BITS IN UNIT FIELD (highest-order field)
			;7     SELECT UNIT
NCYLBT←←=13		;8:19  NUMBER OF BITS IN CYLINDER FIELD
NSRFBT←←=8		;20:27 NUMBER OF BITS IN SURFACE FIELD
NSECBT←←=8		;28:35 NUMBER OF BITS IN SECTOR FIELD

;Specific Left Half Bits in the disk address
ENDBIT←←400000		;Used only by software, must be sign, means no xfer to do
SELBIT←←2000		;Select unit found in unit field

DEFINE CALL {PUSHJ P,}
DEFINE RET {POPJ P,}

;BIT DEFINITIONS FOR F3A DISKS

↑DSKIFG←←000010	;DISK INTERRUPT BIT IN RH DISK "CONI" WORD

F2DCNT←←3	;Number of seconds we give pack to interrupt before timing out.
NDTRY←←10	;Number of retries before we call disk a loser

; HARDWARE ERROR BITS (OBTAINED FROM RC OPERATION)
		;RIGHT HALF ERROR BITS
S.ANY←←200
S.NACT←←20
		;LEFT HALF BITS
S.SERR←←400000	; SELECT ERROR (SELECTED UNIT NOT VALID)
S.WRP←←200000	;UNIT IS WRITE PROTECTED
S.NRDY←←100000	;UNIT NOT READY
S.SKER←←20000	;SEEK ERROR (CODE BELOW DOES AUTO. RECALIBRATE)
S.FALT←←10000	;UNIT FAULT
S.NBSY←←1000	; NOT BUSY (SEQUENCER IS STOPPED)
S.HECC←←400	;HARD ECC ERROR
S.SECC←←200	;SOFT ECC ERROR
S.ROVRN←←100	;DATA READ OVERRUN
S.WOVRN←←40	;DATA WRITE OVERRUN
S.IPE←←10	;INTERNAL PARITY ERROR

; COMMAND BITS FOR LC COMMAND (ALSO RETURNED IN RC)

		; LH BITS
C.USC←←4	; USE SECTOR COUNTER
C.REL←←2	; RELEASE DRIVE FOR USE BY ANOTHER COMPUTER
C.REC←←1	; RECALIBRATE (RESETS SEEK ERROR FLAG ALSO)

		; RH BITS
C.FCLR←←400000	; CLEAR FAULT
C.DSL←←200000	; DATA STROBE LATE
C.DSE←←100000	; DATA STROBE EARLY
C.SOM←←40000	; SERVO OFFSET MINUS
C.COP←←20000	; SERVO OFFSET PLUS
C.CFM←←10000	; COMMAND FROM MEMORY (USE WITH ANY WRITE OP)
    ; THE FOLLOWING ARE MUTUALLY EXCLUSIVE
OP.RD←←0	; READ OPERATION
OP.WRT←←1000	; WRITE OPERATION
OP.CTRL←←4000	; CONTROL FUNCTIONS (RECAL, FAULT CLEAR, ETC)
    ; NOW ON WITH THE REGULAR BITS
C.32B←←400	; 32 BIT MODE (L.O. 4 BITS IGNORED OR ZERO)
C.IENA←←40	; ENABLE INTERRUPTS ON ANY ATTENTION
C.IEND←←10	; ENABLE INTERRUPTS ON TRANSFER DONE

; COMMANDS FOR LE OPERATION

L.INIT←←2	; INITIALIZE THE CONTROLLER
L.START←←1	; START OPERATION

;This whole page IFN FTF2 ;⊗ DHUNG

;HERE FROM SPECIAL CALL IN DEVCHK WHEN THE DISK GETS A HUNG TIMEOUT
;UUO has drive unit number in RH.
;PACBSY(UUO) has just been counted down to zero.
DHUNG:	CONO PI,DSKOFF
	SETOM PRECAL(UUO)	;Force a Recal when starting disk up again
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /Disk drive /
	MOVEI TEM,"0"(UUO)	;Unit number, in ASCII
	PUSHJ P,DISTYO		;TYPE OUT drive number
	PUSHJ P,DISMES
	 ASCIZ / hung time out
/
	PUSHJ P,PCURDA		;Print disk address from F2 disk address
	PUSHJ P,DISCRLF
	DEBCHECK(POPACS)	;DON'T CALL DDT UNLESS DEBUGGING
	DCONO 0			;Shut down the disk
	SETZM F2DACT		;No disk activity
	SETOM DSKLUN		;SAY NO OPERATIONS IN PROGRESS
	PUSHJ P,C1GO		;Find some xfer to start up
	JRST DSKONJ
;This whole page IFN FTF2 ;⊗ C1SIMG C1SIM C1SIM2 F2DPAK F2DJM2 F2DJMP F2DADE F2DAD2

;Routine C1SIM searches for packs with C1 programs "running".
;Starts F2 disk controller as needed.
C1SIMG:	MOVEM TAC,LSTPAK	;Remember number of pack we're servicing
	PUSHJ P,F2DPAK		;Now figure out what to tell this pack to do
C1SIM:	SKIPE F2DACT		;Is controller busy?
	POPJ P,			;Yup, can't start anything else
	MOVE TAC,LSTPAK		;Get number of last pack serviced
	ADDI TAC,1		;Service packs in order -- next pack
C1SIM2:	CAIL TAC,NPACKS		;No more packs?
	MOVEI TAC,0		;No more, start over with first
	SKIPG PACBSY(TAC)	;Are we awaiting an interrupt for this pack?
	SKIPN PACTIV(TAC)	;No, anything for this pack to do?
	CAIA			;Pack already busy, or nothing for it to do
	JRST C1SIMG		;Go service this pack
	CAME TAC,LSTPAK		;Have we searched all the packs?
	AOJA TAC,C1SIM2		;No
	POPJ P,			;Ho, hum, nothing to do

;Here with pack number in TAC.  See what needs to be done on that pack.
;Assumes there is only one "channel" (0) for F2.
F2DPAK:	MOVE AC1,C1APT+C1PPTR(TAC) ;Get pointer to program hdr for this pack
	ADDI AC1,C1INST		;Skip over program control wd and status words
F2DJM2:	TLZ AC1,777760		;Leave only physical address field
	CAML AC1,FSTOP		;Address better be virtual, mapped straight thru
	PUSHJ P,F2DADE		;No, we can't simulate this!!!!  Fatal.
	HLRZ AC2,(AC1)		;Get C1 program opcode
	ANDI AC2,740000		;Clear non-opcode fields
	CAIN AC2,C1JMP		;Is it a jump?
	JRST F2DJMP		;Yes, follow it
;	CAIN AC2,C1CMD		;Or a cmd? (Not used in F2 version, recal and sense handled separately)
;	JRST ...		;Yes, do it
;	JUMPE AC2,F2DHLT	;Jump if a halt (shouldn't ever happen)
	MOVE AC2,(AC1)		;Get entire instruction
	CAMN AC2,C1RMRT		;Is it a MRT read?
	JRST F2MRED		;Yes, do it
	CAMN AC2,C1WMRT		;Is it a MRT write?
	JRST F2MWRT		;Yes, do it
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF ERROR MSG ON CTY
	PUSHJ P,DISERR
	 [ASCIZ/Illegal C1 channel instruction: /]
	 DISARG OCH,<AC2-20(P)>
	 [ASCIZ/  Pack = /]
	 DISARG LOC,<TAC-20(P)>
	 [ASCIZ/  C1 PC = /]
	 DISARG LOC,<AC1-20(P)>
	 -1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,FDDTCA		;Fatal, no $P msg
	JRST .-1		;I don't know how to get out of this!

F2DJMP:	MOVE AC1,(AC1)		;Get jump instruction (mainly physical address)
	JRST F2DJM2		;And continue looking for work

F2DADE:	MOVE AC3,AC1
F2DAD2:	PUSHACS
	PUSHJ P,DISGST		;Print time on CTY
	PUSHJ P,DISERR
	 [ASCIZ/C1 program physical address not in virtual space.
Pack = /]
	 DISARG LOC,<TAC-20(P)>
	 [ASCIZ/   Fatal addr = /]
	 DISARG ADR,<AC3-20(P)>
	 [ASCIZ/   FSTOP = /]
	 DISARG LOC,FSTOP
	 [ASCIZ/Callers = /]
	 DISARG LOC,<-21(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-22(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-23(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-24(P)>
	 -1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,FDDTCA		;Fatal, no $P msg
	JRST .-1
;This whole page IFN FTF2 ;⊗ F2MWRT F2MRED NOSEEK F2DREA F2DWRI NOPRER

;Here to start a drive doing something useful for us.  If the heads
;aren't at the right cylinder, we start a seek.  Otherwise, we analyze
;the C1 program for this drive and uncompile it into necessary transfers
;for the F2 disk controller to do.  Enter here with TAC and AC1 set up.
; TEM/ temporary, arg for some routines
; TAC/ drive number
; AC1/ address of C1 instruction being examined
; AC2/ temporary
; AC3/ address of current C1 data pointer word
; DSER/ F2 record number
; DAT/ next memory address for transfer; address where F2 disk xfer starts
F2MWRT:	TDZA AC2,AC2		;Flag a write
F2MRED:	SETO AC2,		;Flag a read
	MOVEM AC2,F2DRED(TAC)	;Remember direction of transfer
	MOVE AC3,3(AC1)		;Pick up ptr to first data pointer word
	MOVE AC2,2(AC1)		;Save 2nd MRT parameter word
	MOVEM AC2,C1DSK2(TAC)	; in table for easy access, and diddling
	MOVE AC2,1(AC1)		;1st MRT parameter word
	MOVEM AC2,C1DSKA(TAC)	;Save disk address for easy access and diddling
	TLZ AC3,777760		;Leave only physical address bits
	CAML AC3,FSTOP		;Better be a virtual address
	PUSHJ P,F2DAD2		;No, we can't simulate this!!!!  Fatal.
	SKIPL (AC3)		;Skip unless we've reached end of C1 xfer
	JRST F2DEN0		;Go wake up process that requested C1 xfer
REPEAT 0,<	;No seek routine from Foonly yet.
	LDB AC2,[POINT 16,C1DSKA(TAC),15] ;Cylinder of transfer
	CAMN AC2,F2DCYL(TAC)	;Are the heads already positioned?
	JRST NOSEEK		;Yes, no seek needed
	MOVEM AC2,F2DCYL(TAC)	;Remember where we're putting the heads
	...			;Set up seek args in ACs
	PUSHJ P,DSEEK		;Start the seek
	MOVEI AC2,F2DCNT	;Hung time count for pack (maybe DSEEK will do this)
	MOVEM AC2,PACBSY(TAC)	;Flag awaiting interrupt for this pack
>;REPEAT 0
NOSEEK:	SKIPN F2DRED(TAC)	;Skip if doing a read
	JRST F2DWRI		;Doing a write
	SETZM F2BLTA(TAC)	;No previous buffer to BLT
F2DREA:	MOVEM AC3,F2BLT2(TAC)	;Remember data ptr address of next xfer
	PUSHJ P,WHERED		;Figure out what core address to read into
	 SETZM F2BLT2(TAC)	;Next xfer will be direct to final core destination
	MOVEI TEM,OP.RD		;Next command is a read
	JSP AC2,F2DISM		;Start xfer, waiting first if necessary
	SKIPE TEM,F2BLTA(TAC)	;Any previous read need blting?
	PUSHJ P,F2RBLT		;Yes, BLT data to final destination(s)
	SKIPG PACBSY(TAC)	;Did we just request a read?
	JRST F2DEND		;No, must be done with the xfer -- wake up someone
	AOS N2READ		;Count F2 pages read
	MOVE TEM,F2BLT2(TAC)	;Get pointer, if any, to data ptr wds for next read
	MOVEM TEM,F2BLTA(TAC)	;Save for post-read BLTing of data read
	JRST F2DREA		;Loop for next read of same xfer

F2DWRI:	MOVEM AC3,F2BLT2(TAC)	;Save location of first data ptr for next xfer
	PUSHJ P,WHERED		;Find core and disk addresses of xfer
	 SETZM F2BLT2(TAC)	;Direct xfer, will not need to be buffered
	SKIPN F2PRER		;Skip if need to pre-read F2 record
	JRST NOPRER		;No pre-read needed
	MOVEI TEM,OP.RD		;Next command is a read
	JSP AC2,F2DISM		;Start xfer, waiting first if necessary
	AOS N2PRER		;Count number of pages we have had to pre-read
	JSP AC2,F2DISM		;Wait for pre-read to finish (won't start xfer)
	MOVSI TEM,ENDBIT	;In disk address, clear sign bit to re-validate
	ANDCAM TEM,F2DSKA(TAC)	; same old disk address
	ANDCAM TEM,NXTDA	;Same for fast code
NOPRER:	SKIPE TEM,F2BLT2(TAC)	;Skip if no blting into special buffer needed
	PUSHJ P,F2WBLT		;Blt data into buffer for writing from there
	MOVEI TEM,C.CFM!OP.WRT	;Next command is a write
	JSP AC2,F2DISM		;Start xfer, if any, waiting first if necessary
	SKIPG F2DCOR(TAC)	;Did a new xfer get started?
	JRST F2DEND		;No, that means no more data ptrs, all done
	AOS N2WRIT		;Count F2 pages written
	JRST F2DWRI		;Yes, loop until well done
;This whole page IFN FTF2 ;⊗ F2DEN0 F2DEND F2DEN2 F2DXIT F2DISM F2DSTR F2DST3 STRER0 STRERR SAVCUR

;Here when the xfer has been completely finished.  Now we want to call the
;code at C1ERET to start up the next disk xfer and wake up this user, etc.,
;but that is done by calling C1GO, which calls us, and we don't want to PDLOV,
;in case the next xfer gets done immediately, without waiting (e.g., solid
;drive error, or null (?) xfer).
;So we delay the done routine until we enter or exit DSKCHN next, so that
;the address popped into INTRTN at C1ERET will be DSKSV+n (where the ACs will
;be restored), so that C1GO (and thus C1SIM) needn't preserve any ACs
;except IOS, DDB and P.
F2DEN0:	PUSHJ P,BUGTRP		;Null transfer!!!!  Let someone know it happened.
F2DEND:	CAME AC3,C1AEXH(TAC)	;COMPARE WITH EXPECTED HALT ADDRESS (TAC HAS PACK)
	JRST F2DEN2
	SETOM F2DUNF		;Set flag to come back in DSKCHN
	JRST F2DWAK		;Generate int for DSKCHN. Return.

F2DEN2:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	 ASCIZ /PC (AC3) DIFFERENT FROM EXPECTED HALT ADDRESS AT F2DEND
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,FDDTCA		;Fatal error -- no $P msg
	JRST .-1		;WHAT TO DO!

;Here from DSKCHN CONSZ chain (or DSKSV exit code) because F2DUNF flag, set above.
↑F2DXIT:JSR DSKSV		;Save ACs and set up PDL
	SETZM F2DUNF		;Clear interrupt request flag
	SKIPGE TAC,DSKLUN	;WERE WE WAITING FOR SOMETHING TO HAPPEN?
	PUSHJ P,POPTRP		;NO!!  Type msg on CTY, go to DDT, pop up level
	SKIPN DDB,PACTIV(TAC)	;Get DDB address for this transfer
	PUSHJ P,FATTRP		;Oops -- fatal bug, no return!
	SETOM DSKLUN		;No more interrupts expected
	JRST C1ERET		;Rejoin regular C1 code to wake up user

;Here via JSP AC2,F2DISM start new xfer, with direction indicated by cmd in TEM,
;but first we'll wait for any previous xfer (or seek) to finish.
F2DISM:	MOVEM TEM,F2DCMD(TAC)	;Save read or write command
	MOVEM TEM,NXTCMD	;Save for fast code too
	SKIPG PACBSY(TAC)	;Skip if drive is busy -- wait for it
	JRST F2DSTR		;If drive free, start xfer now (if any) and return
	MOVEM AC2,F2DDSP(TAC)	;Remember dispatch address when channel is done.
	MOVEM AC3,F2C1PT(TAC)	;Remember address of next data ptr wd to check
	POPJ P,			;Stop co-routine, wait for disk

F2DSTR:	PUSH P,AC2		;Put return address where POPJ will find it
	MOVEI TEM,F2DCNT	;Re-set timeout/busy flag
	MOVEM TEM,PACBSY(TAC)	;Store for this pack
	MOVEM TAC,DSKLUN	;Remember which drive we're running
	HRROM TAC,F2DACT	;Flag controller busy doing data xfer, not seek
	PUSHJ P,SAVCUR		;Set up new xfer parameters, incl retry count
	SKIPE PRECAL(TAC)	;Is someone forcing us to do a Recal?
	JRST STRER0		;Yes, do it (here for sysini and after hung drive)
F2DST3:	LE [L.INIT]		;INIT THE CONTROLLER.
	MOVE TEM,CURDA		;Get disk address
	LA TEM			;DESELECT
	TLO TEM,SELBIT		;INSTALL SELECT ENABLE BIT
	LA TEM			;SELECT DRIVE AND LOAD DSK ADR.
	RC TEM			;READ STATUS BITS.
	TLNE TEM,S.SERR!S.NRDY	;SELECT ERROR ? DRIVE NOT READY?
	JRST STRERR		;GOT ERROR, GO RETRY
	LM CURMA		;LOAD MEMORY ADDRESS
	LC CURCMD		;SEND THE COMMAND.
	LE [L.START]		;START THE CONTROLLER.
	DCONO DSKCHN		;SET THE DISK INTERRUPT CHANNEL
	POPJ P,

STRER0:	SETZM PRECAL(TAC)	;OK, presumably no Recal needed next time
STRERR:	MOVEM TEM,ERRBIT	;Save the status flags
	MOVSI TEM,400000	;Flag start up error, no recal error yet,
	MOVEM TEM,F2DSER	; in case we lose badly
	SOSLE DSKTRY(TAC)	;Skip if retried enough times
	PUSHJ P,RECAL		;GIVE CLEAR FAULT COMMAND, recalibrate
	 JRST DERRO1		;Lost!  Go process error.
	JRST F2DST3		;OK, now try again

;Remember what current disk parameters are
SAVCUR:	MOVE TEM,F2DSKA(TAC)	;Disk address
	MOVEM TEM,CURDA
	MOVE TEM,F2DCOR(TAC)	;Core address
	MOVEM TEM,CURMA
	MOVE TEM,F2DCMD(TAC)	;Read or write command
	MOVEM TEM,CURCMD	;SAVE STUFF FOR RETRIES
	MOVEI TEM,NDTRY		;RETRY THIS MANY TIMES BEFORE GIVING UP
	MOVEM TEM,DSKTRY(TAC)	;INIT RETRY COUNTER
	MOVSI TEM,ENDBIT	;Turn on sign bit in disk address to mean
	IORM TEM,F2DSKA(TAC)	; no longer any new disk xfer ready to go yet
	IORM TEM,NXTDA		;Same for quick code's cell
	POPJ P,
;This whole page IFN FTF2 ;⊗ WHERED WHEREL WHEXIT WHEREX WHERX2 WHERX0 WHERX1 WHERX3 WHERX4

;Here we combine, when possible C1 data pointer words, up to F2 disk record
;boundary, to discover whether or not we can transfer this data directly.
;If not, then the transfer is buffered an extra time through an F2 disk buffer
;in the system, BLTed between there and the desired actual core location.
;We'll generally have to set up a map page (call ADDEMP) for each BLT,
;except for those BLTs going to areas within the system (below FSTOP).

;Call with AC3 pointing to next data ptr wd.
;Return w/F2DCOR(TAC) holding physical core addr, F2DSKA(TAC) holding formatted
;disk addr, AC3 advanced to first data ptr wd of following F2 disk record,
;F2PRER set iff need to pre-read F2 record before writing (may be set even if read).
;If xfer to be buffered, F2BLT2(TAC) LH set as follows:
; Bit  0    On if should zero extra WAITS records following last WAITS record
;	    written within F2 record (NEITHER SET NOR USED YET).
; Bits 7:8  Number of WAITS records to ignore at beginning of F2 record.
; Bit  17   Number of special buffer being used for this F2 record.
;Skip return taken if xfer has to be buffered and BLTed.
WHERED:	SETZB UCHN,DAT		;Number of data words of xfer analyzed so far
	SETZM F2PRER		;Assume don't need to pre-read before a write
	SKIPL (AC3)		;Any data ptr words left?
	JRST WHEREX		;No, return DAT zero to signal that
	LDB AC2,[POINT 8,C1DSKA(TAC),31] ;Get record number of beginning of transfer
NoStructure,<
	CAILE AC2,RCPBLK	;Skip unless this transfer is wrapping to next trk
>;NoStructure
IfStructure,<
;This doesn't work because DDB isn't set up here.  -- JJW
;	CAMLE AC2,DD.RPB(DDB)	;Skip unless this transfer is wrapping to next trk
PRINTX This needs to be fixed for IfStructure if F2 changes block size
	CAILE AC2,RCPBLK	;Skip unless this transfer is wrapping to next trk
>;IfStructure
	PUSHJ P,F2DWRP		;Advance parameters to next track
	ANDI AC2,3		;Leave only nbr of initial WAITS records to ignore
	MOVEI UCHN,(AC2)	;Number of records we've already "handled"
	JUMPN AC2,WHERX2	;Jump if no start on F2 disk page boundary
	LDB DAT,[POINT 22,(AC3),35] ;Initialize expected memory address
WHEREL:	SKIPL (AC3)		;Is this a data pointer word?
	JRST WHERX0		;Nope
	LDB AC2,[POINT 12,(AC3),13] ;Get word count
	CAIE AC2,RECSIZ		;Is this a full record transferred to one core loc?
	JRST WHERX0		;Nope, must buffer extra time
	LDB AC2,[POINT 22,(AC3),35] ;Get memory address
	CAME AC2,DAT		;This piece of transfer contiguous to previous part?
	JRST WHERX0		;No, gotta buffer this xfer
	ADDI DAT,RECSIZ		;Adjust to next starting address
	ADDI UCHN,1		;Count another record seen
	CAIE UCHN,4		;Is that end of F2 disk record?
	AOJA AC3,WHEREL		;No, check next data pointer
;;Yes!  we can transfer the data directly!
	SUBI DAT,4*RECSIZ	;Back up address to start of F2 record xfer
	ADDI AC3,1		;Next data ptr word
	LDB DSER,[POINT 8,C1DSKA(TAC),31] ;Get record number of beginning of xfer
WHEXIT:	MOVEI AC2,4(DSER)	;Make copy of rec number to update for next xfer
	TRZ AC2,3		;Adjust WAITS rec to start of next F2 record
	DPB AC2,[POINT 8,C1DSKA(TAC),31] ;Store for next xfer (maybe off end of track)
	LSH DSER,-2		;Convert to F2 record number
;Here we need to format ACs for call to disk transfer routine.
;So far we have:
; DAT/ memory address of start of xfer
; DSER/ F2 record number
; TAC/ pack number
REPEAT 0,<	;Cylinder not stored unless seek code enabled.
; F2DCYL(TAC)/ cylinder number
>;REPEAT 0
	MOVEI UCHN,(TAC)	;Copy unit number for complete disk addr in UCHN.
IFN FTCCRMA,<
printx Unit 2 is being mapped into unit 3 (new disk)
	cain uchn,2		;*** Fudge unit number until we can get the right
	  movei uchn,3		;*** size of allen wrench!!!
>;IFN FTCCRMA
	LSH UCHN,NCYLBT		;Make room for cylinder number
	LDB AC2,[POINT 16,C1DSKA(TAC),15] ;Cylinder of transfer
	IORI UCHN,(AC2)		;Include cylinder
	LSH UCHN,NSRFBT		;Make room for head number
	LDB AC2,[POINT 8,C1DSKA(TAC),23] ;Get head number
	IORI UCHN,(AC2)		;Include head
	LSH UCHN,NSECBT		;Make room for record number
	IORI UCHN,(DSER)	;Include record
	MOVEM UCHN,F2DSKA(TAC)	;Remember disk address of next xfer
	MOVEM UCHN,NXTDA	;Remember for fast code too
	TLO UCHN,SELBIT		;Remember copy of disk address with select bit
	MOVEM UCHN,NXTDAS	; on too, to save F2DINT some time
WHEREX:	MOVEM DAT,F2DCOR(TAC)	;Remember core address of next xfer
	MOVEM DAT,NXTMA		;Remember for fast code too
	POPJ P,

WHERX2:	SETOM F2PRER		;If writing, must pre-read for initial skipped recs
;Advance AC3 to one beyond last data ptr word for this F2 record.
WHERX0:	SKIPL AC2,(AC3)		;Get data ptr wd
	JRST WHERX3		;None there, must be end
	TLNN AC2,C1RECB		;Is this beginning of a record?
	AOJA AC3,WHERX0		;No, don't count it, advance to next data ptr wd
	ADDI UCHN,1		;Count another record seen
	CAIG UCHN,4		;Seen all WAITS records that are in this F2 rec?
	AOJA AC3,WHERX0		;No, look for first rec after all WAITS recs
WHERX1:	PUSHJ P,F2DBGT		;Set up DAT with address of special system buffer.
	LDB DSER,[POINT 8,C1DSKA(TAC),31] ;Get record number of beginning of xfer
	DPB DSER,[POINT 2,AC2,26] ;How many WAITS records to ignore in F2 record
	HRLM AC2,F2BLT2(TAC)	;Remember which special buffer, nbr recs to ignore
	AOS (P)			;Skip return means using special system buffer
	JRST WHEXIT		;Format disk address in UCHN and return

WHERX3:	CAIL UCHN,4		;Was WAITS record just seen the last one in F2 rec?
	JRST WHERX1		;Yes, no pre-read needed
	SKIPN AC2,PACTIV(TAC)	;Get DDB address
	JRST WHERX4		;Must be a DDB!  But there isn't!
	MOVE DAT,TFRCTL(AC2)	;Get bits for this xfer
	TLNN DAT,DNOPRE		;Skip if we can suppress pre-read
WHERX4:	SETOM F2PRER		;Have to pre-read F2 record for final unwritten recs
	JRST WHERX1
;This whole page IFN FTF2 ;⊗ F2WBLT F2WBL2 F2WBL3 F2WBL4 F2WBLY F2WBLZ F2WBL5 F2WBL6 F2WBL7

;Here to blt data into special buffer prior to writing to disk.
;TEM contains same as upon call to F2RBLT.
;RH(TEM) points to C1 data ptr words to simulate, bits 0:8 of TEM say how many
;WAITS records to ignore at the beginning of the F2 record, and bits 9:17 of TEM
;specify which special buffer we're using.
;AC usage:
; DSER/	Core address of base of next WAITS record to need BLTing
; UUO/	Beginning source address of next BLT (address within current WAITS record)
; UCHN/	Word count of BLT
; TEM/	Address of current data ptr wd
; AC2/	Physical core address from current data ptr wd -- BLT destination
; AC3,TAC Normal: co-routine data ptr address, unit.
; DAT/	Number of WAITS records (max 4) processed so far.
; TAC1/	Temporary
F2WBLT:	PUSH P,[0]		;No virtual page set up yet
	AOS N2WBLT		;Count a page blted for writing
	LDB DAT,[POINT 2,TEM,8] ;Number of WAITS records to ignore
	LDB DSER,[POINT 1,TEM,17] ;Which special buffer
	MOVE DSER,F2DBUF(DSER)	;Actual buffer address
	MOVEI UCHN,(DAT)
	IMULI UCHN,RECSIZ	;Adjust buffer address by records being ignored
	ADDI DSER,(UCHN)	;Address of next WAITS record to process
;Now we have processed (DAT) of 4 possible WAITS records in an F2 record.
	SKIPL AC2,(TEM)		;Get next data ptr word
	PUSHJ P,FATTRP		;Gotta be at least one data ptr word!!!
F2WBL2:	MOVE UUO,DSER		;UUO pts to beginning of BLT within record
	ADDI DSER,RECSIZ	;DSER always pts to beginning of next record
F2WBL3:	LDB UCHN,[POINT 12,AC2,13] ;Get word count from data ptr wd
	TLZ AC2,777760		;Leave only physical address in AC2
	CAML AC2,FSTOP		;Is this address mapped straight through?
	JRST F2WBL5		;No, must set up map page for BLT
F2WBL4:	MOVE TAC1,UUO		;Find end address of BLT
	ADDI TAC1,(UCHN)	;Address beyond end of BLT, in special buffer
	MOVSI AC2,(AC2)		;Source of BLT
	HRRI AC2,(UUO)		;Dest of BLT is in special buffer
	BLT AC2,-1(TAC1)	;Copy disk data into special buffer
	ADDI UUO,(UCHN)		;Adjust address within current WAITS record
	ADDI TEM,1		;Next data ptr wd
	SKIPL AC2,(TEM)		;Any more?
	JRST F2WBLY		;Nope
	TLNN AC2,C1RECB		;New WAITS record?
	JRST F2WBL3		;No, process more data in same record
	CAIL DAT,3		;Skip unless done all WAITS records in F2 rec
	JRST F2WBLX		;Done with 4 WAITS records
	PUSHJ P,F2WBL7		;Maybe zero last part of previous record
	AOJA DAT,F2WBL2		;Next record

F2WBLY:	SKIPN AC2,PACTIV(TAC)	;Get DDB address
	JRST F2WBLX		;Where'd it go!!  Oh well.
	MOVE AC2,TFRCTL(AC2)	;Get xfer bits
	TLNE AC2,DNOPRE		;Skip if pre-read of this rec was suppressed
F2WBLZ:	CAIL DAT,3		;Did we reach the end of the F2 record?
	JRST F2WBLX		;Yes, finish up and return
	ADDI DSER,RECSIZ	;No, make F2WBL7 clear a WAITS record at end
	AOJA DAT,F2WBLZ		;Count another WAITS record taken care of

;Here when we have to BLT disk data from core not in virtual address space.
F2WBL5:	PUSH P,TAC
	MOVE TAC,AC2
	LSH TAC,-9		;Physical page number we need
	CAMN TAC,-1(P)		;Is this exec page already set up?
	JRST F2WBL6		;Yes
	MOVEI TAC1,F2DEXP	;Use special exec virtual page for BLT
	SKIPE -1(P)		;Had we already set up a different physical page?
	PUSHJ P,DELEMP		;Yes, flush earlier page
	MOVEM TAC,-1(P)		;Remember what exec page we're setting up
	PUSHJ P,ADDEMP		;Insert page in map
F2WBL6:	POP P,TAC
	ANDI AC2,777		;Offset within page of BLT source
	ADDI AC2,F2DEXP⊗9	;Include virtual page address
	JRST F2WBL4

;Here to zero out the unwritten end of a WAITS record, and any whole
;unwritten WAITS records in an F2 record (one page) if the pre-read of this
;F2 record was suppressed.
F2WBL7:	CAIL UUO,(DSER)		;Did we fill up the WAITS record?
	POPJ P,			;Yup (hope we didn't overfill it!!)
	SETZM (UUO)		;No, zero rest of it
	ADDI UUO,1
	CAIL UUO,(DSER)		;If only one word to zero, avoid blt
	POPJ P,			;All done
	HRLI UUO,-1(UUO)	;Source of BLT is first zeroed word
	BLT UUO,-1(DSER)	;End of BLT is word before next WAITS record
	POPJ P,
;This whole page IFN FTF2 ;⊗ F2RBLT F2RBL2 F2RBL3 F2RBL4 F2RBL5 F2RBL6 F2WBLX F2RBLX

;Routine to blt to final destination some data just read in.
;RH(TEM) points to C1 data ptr words to simulate, bits 0:8 of TEM say how many
;WAITS records to ignore at the beginning of the F2 record, and bits 9:17 of TEM
;specify which special buffer the data is in.
;AC usage:
; DSER/	Core address of base of next WAITS record to need BLTing
; UUO/	Beginning source address of next BLT (address within current WAITS record)
; UCHN/	Word count of BLT
; TEM/	Address of current data ptr wd
; AC2/	Physical core address from current data ptr wd -- BLT destination
; AC3,TAC Normal: co-routine data ptr address, unit; unused.
; DAT/	Number of WAITS records (max 4) processed so far.
; TAC1/	Temporary
F2RBLT:	PUSH P,[0]		;No virtual page set up yet
	AOS N2RBLT		;Count a page blted for reading
	LDB DAT,[POINT 2,TEM,8] ;Number of WAITS records to ignore
	LDB DSER,[POINT 1,TEM,17] ;Which special buffer
	MOVE DSER,F2DBUF(DSER)	;Actual buffer address
	MOVEI UCHN,(DAT)
	IMULI UCHN,RECSIZ	;Adjust buffer address by records being ignored
	ADDI DSER,(UCHN)	;Address of next WAITS record to process
;Now we have processed (DAT) of 4 possible WAITS records in an F2 record.
	SKIPL AC2,(TEM)		;Get next data ptr word
	PUSHJ P,FATTRP		;Gotta be at least one data ptr word!!!
F2RBL2:	CAIL DAT,4		;Skip unless done all WAITS records in F2 rec
	JRST F2RBLX		;No data ptr wds or done with 4 WAITS records
	MOVE UUO,DSER		;UUO pts to beginning of BLT within record
	ADDI DSER,RECSIZ	;DSER always pts to beginning of next record
F2RBL3:	LDB UCHN,[POINT 12,AC2,13] ;Get word count from data ptr wd
	TLZ AC2,777760		;Leave only physical address in AC2
	CAML AC2,FSTOP		;Is this address mapped straight through?
	JRST F2RBL5		;No, must set up map page for BLT
F2RBL4:	MOVE TAC1,AC2		;Find end address of BLT
	ADDI TAC1,(UCHN)	;Address beyond end of BLT
	HRL AC2,UUO		;Source of BLT is address within special buffer
	BLT AC2,-1(TAC1)	;Copy disk data to final destination
	ADDI TEM,1		;Next data ptr wd
	SKIPL AC2,(TEM)		;Any more?
	JRST F2RBLX		;Nope
	TLNE AC2,C1RECB		;New WAITS record?
	AOJA DAT,F2RBL2		;Yes, use beginning address of next record
	ADDI UUO,(UCHN)		;No, adjust address within current WAITS record
	JRST F2RBL3

;Here when we have to BLT disk data to core not in virtual address space.
F2RBL5:	PUSH P,TAC
	MOVE TAC,AC2
	LSH TAC,-9		;Physical page number we need
	CAMN TAC,-1(P)		;Is this exec page already set up?
	JRST F2RBL6		;Yes
	MOVEI TAC1,F2DEXP	;Use special exec virtual page for BLT
	SKIPE -1(P)		;Had we already set up a different physical page?
	PUSHJ P,DELEMP		;Yes, flush earlier page
	MOVEM TAC,-1(P)		;Remember what exec page we're setting up
	PUSHJ P,ADDEMP		;Insert page in map
F2RBL6:	POP P,TAC
	ANDI AC2,777		;Offset within page of BLT destination
	ADDI AC2,F2DEXP⊗9	;Include virtual page address
	JRST F2RBL4

F2WBLX:	PUSHJ P,F2WBL7		;Maybe zero final part of last record
F2RBLX:	MOVEI TAC1,F2DEXP	;Prepare to flush exec page if we set one up
	SKIPE (P)		;Skip if no exec page was set up
	PUSHJ P,DELEMP
	ADJSP P,-1		;Flush page data from stack
	POPJ P,
;This whole page IFN FTF2 ;⊗ F2DWRP F2CWRP F2DBUF F2DBGT

;Here when disk xfer wants to wrap around from end of one track to start of next.
F2DWRP:	LDB AC2,[POINT 8,C1DSKA(TAC),23] ;Get head number
	ADDI AC2,1		;Next head
	CAIL AC2,TRKCYL		;Any more heads on this cylinder?
	PUSHJ P,F2CWRP		;No, restart at first head of next cyl
	DPB AC2,[POINT 8,C1DSKA(TAC),23] ;Store new head number
	LDB AC2,[POINT 8,C1DSK2(TAC),23] ;Get wrap around restart record number
	DPB AC2,[POINT 8,C1DSKA(TAC),31] ;Re-set to that record, return rec in AC2
	POPJ P,

;Here when disk xfer wraps to next cylinder from last head of current cyl.
F2CWRP:	LDB AC2,[POINT 16,C1DSKA(TAC),15] ;Pick up cylinder
	ADDI AC2,1		;Next cylinder
	CAIL AC2,NCYL1		;Any more cylinders?
	PUSHJ P,FATTRP		;No, illegal disk transfer request
	DPB AC2,[POINT 16,C1DSKA(TAC),15] ;Store new cylinder number
	MOVEI AC2,0		;Start with head 0 of new cyl
	POPJ P,

;Table of addresses of the two special buffers
F2DBUF:	F2DBF0			;Special buffer number 0
	F2DBF1			;Special buffer number 1

;Here to set DAT to address of special system buffer to use for next xfer.
;Also returns AC2 holding 0 or 1 to specify which buffer we're using.
F2DBGT:	AOS AC2,N2DBUF		;Count times we've special-buffered a xfer
	ANDI AC2,1		;Keep low bit to alternate between buffers
	MOVE DAT,F2DBUF(AC2)	;Get address of buffer
	POPJ P,
;This whole page IFN FTF2 ;⊗ F2DINT F2DIN2 F2DIN3 F2DIN4 F2DINE

;Here on interrupt in DSKCHN from F2 disk.
;We have to act very quickly to ask for next sector, if we want it.
;If we waste any time, we'll be too late and we'll miss a revolution.
;This is the fast disk code.  DISK RUNS ON CH2 ON THE F2.
	BLOCK 10	;Patch space for debugging different speedy versions
;;	DCONO 0		;Patch jump to here if this must be done first
↑F2DINT:MOVEM TAC,DSKSV		;GET US AN ACCUMULATOR
	RC TAC			;READ STATUS BITS.
	TDNE TAC,[S.SERR!S.NRDY!S.IPE,,S.ANY] ;Any error?
	JRST WASERR		;GOT ERROR, GO RETRY
;***** Here when disk data transfer completed successfully.
;This xfer just finished might be the pre-read for a write that doesn't want
;to write the whole F2 disk record (one page).
	SKIPGE TAC,NXTDA	;Get next disk address, if any
	JRST F2DIN2		;None ready (maybe this was a preread)
;;	LE [L.INIT]		;INIT CONTROLLER - PROBABLY NOT NECESSARY if no errs
	LA TAC			;DESELECT
	LA NXTDAS		;SELECT DRIVE AND LOAD DSK ADR.
	LM NXTMA		;LOAD MEMORY ADDRESS
	LC NXTCMD		;SEND THE COMMAND.
	LE [L.START]		;START THE CONTROLLER.
	DCONO DSKCHN		;SET PI CHANNEL (Won't set int flag still see this)
	SKIPA TAC,[F2DCNT]	;Re-set timeout/busy flag
F2DIN2:	MOVEI TAC,0		;Clear busy flag
	MOVEM AC2,F2DAC2	;Save another AC
	SKIPGE AC2,DSKLUN	;Get pack number
	JRST F2DINE		;Ooops, no number set up
	MOVEM TAC,PACBSY(AC2)	;Set busy/timeout/free state for this pack
F2DIN3:	MOVE AC2,F2DAC2		;RESTORE AC
	MOVE TAC,DSKSV		;RESTORE AC
	JSR DSKSV		;Get us a stack, save ACs
	MOVE TAC,DSKLUN		;Get pack number again
	SKIPLE PACBSY(TAC)	;Skip if we didn't just start another xfer
	JRST F2DIN4		;Disk is going, don't touch it!
	DCONO 0			;Clear interrupt req, PI channel
	MOVE AC2,F2DSKA(TAC)	;Get last disk address, to avoid moving heads
	TLZ AC2,ENDBIT		;Clear software bit, leaving good disk address
	LA AC2			;DESELECT, turns the select light off!
	SETZM F2DACT		;No data xfer going now
	SETOM DSKLUN		;No longer expecting any disk interrupts
F2DIN4:	PUSHJ P,SAVCUR		;Remember current disk parameters
	MOVEI AC2,0
	EXCH AC2,F2DDSP(TAC)	;Pick up co-routine dispatch address and clear it
	MOVE AC3,F2C1PT(TAC)	;Get address of next data ptr word to handle
	JUMPN AC2,(AC2)
	PUSHJ P,FATTRP		;NO DISPATCH ADDRESS!!
	JRST 4,.

;Some screw up about unit number 
F2DINE:	MOVE TAC,DSKSV		;Restore the one saved AC
	JSR DSKSV		;Save ACs and get a stack
	PUSHJ P,FATTRP		;Fatal bug -- no return from this call
	DCONO 0			;Clear interrupt req, PI channel
	JRST 4,.
;Last of several whole pages IFN FTF2 ;⊗ WASER0 WASERR GO GOL RECAL RECBUZ RECALE RECSTO DERRO1 F2DWAK F2DERI DERRO4 DERRO5 DERRO6 DERRO7

;Here if there was some kind of error
WASER0:	MOVEI TAC,0		;Data MA didn't end right!  No particular err bits
WASERR:	MOVEM TAC,ERRBIT	;Save error bits
	SETZM F2DSER		;Not a start up error, no recal error yet
	MOVE TAC,DSKSV		;Restore the one saved AC
	JSR DSKSV		;Save ACs and get a stack
	DCONO 0			;Clear interrupt req, PI channel
	HRRZ TAC,F2DACT		;Get number of pack we started
	CAME TAC,DSKLUN		;Is that the pack the interrupt is for?
	PUSHJ P,FATTRP		;No, horrible error -- no return from this call
	MOVEI DAT,OP.WRT	;First check for write protection on write
	MOVE UUO,ERRBIT		;Get back error bits
	TLNE UUO,S.ROVRN	;Read overrun error?
	 AOS NROVRNS		;Yes, bump counter.
	TLNE UUO,S.WOVRN	;Write overrun error?
	 AOS NWOVRNS		;Yes, bump counter.
	TLNE UUO,S.WRP		;Pack write protected?
	TDNN DAT,CURCMD		;Yes!  Skip if trying to write, lose now
	SOSG DSKTRY(TAC)	;Tried enough times?
	JRST DERRO4		;Yes, give up
	PUSHJ P,RECAL		;RECALIBRATE
	 JRST DERRO4		;Lost!!  Go process error.
; WHEN AT FIRST YOU DON'T SUCCEED, RETRY, RETRY AGAIN
	MOVEI TEM,F2DCNT	;Re-set timeout/busy flag
	MOVEM TEM,PACBSY(TAC)	;Store for this pack
	JRST F2DST3		;Restart the xfer

;Do F2 disk op with command in DAT.  Wait for completion and skip if no error.
;This routine is called at interrupt level, where is OK for fault clear, but
;it's probably a bad idea for recalibrate.
GO:	LE [2]			;INIT THE CONTROLLER.
	LC DAT			;SEND THE COMMAND.
	LE [1]			;START THE CONTROLLER.
	MOVEI DAT,60000		;TIMEOUT DELAY
GOL:	RC UUO
	IMULI TAC,1		;STOP USING MEMORY FOR A WHILE.
	TRNN UUO,S.NACT		;CHECK FOR ACTIVE
	SOJG DAT,GOL
	JUMPG DAT,CPOPJ1	;CHECK FOR TIMED OUT -- SKIP RETURN IF NO ERROR
	POPJ P,

;Recalibrate.  Skip if successful.
;
;This must be done after seek errors.  It might be helpful under other
;circumstances.
	PRINTX	RECAL waits at in high priority disk channel for recalibrate
RECAL:	AOS NRECALS		;Count these stupid things
	MOVE TEM,CURDA		;Get disk address to select right unit
	LA TEM			;DESELECT UNIT
	TLO TEM,SELBIT		;Turn on select bit
	LA TEM			;Select unit
	MOVE DAT,[C.REC,,C.FCLR!OP.CTRL] ;RECALIBRATE and clear fault
	PUSHJ P,GO
	 JRST RECALE		;DIE IF THIS TIMES OUT
	TRNN UUO,S.ANY
	JRST CPOPJ1		;SUCCESS
	TLNN UUO,S.NRDY		; WAS IS A SPURIOUS NOT READY?
	 JRST RECALE		; NO, MUST BE REAL ERROR

	MOVE TEM,CURDA		;Get disk address again to select right unit
	LA TEM			;DESELECT UNIT
	TLO TEM,SELBIT		;Turn on select bit
	LA TEM			;Select unit
	MOVE DAT,[C.FCLR!OP.CTRL] ;THIS TIME JUST CLEAR FAULT
	PUSHJ P,GO
	 JRST RECALE		;DIE IF THIS TIMES OUT
	TRNN UUO,S.ANY
	JRST CPOPJ1		;SUCCESS
	TLNN UUO,S.NRDY		; WAS IS A SPURIOUS NOT READY?
	 JRST RECALE		; NO, MUST BE REAL ERROR

	MOVNI TEM,200000	; BUZZ THIS LONG
RECBUZ:	RC UUO			; "WHATEVER I SAY THREE TIMES IS TRUE"
	TRNN UUO,S.ANY		; NOW IS THERE AN ERROR?
	 JRST RECSTO		; SEE NO EVIL, HEAR NO EVIL
	AOJL TEM,RECBUZ		; LOOP AROUND ON IT
RECALE:	MOVEM UUO,ERRBIT	;Remember error bits for typeout
	HLLOS F2DSER		;Flag RECAL failure
	POPJ P,			;LOST IF ANY ERROR OCCURRED

RECSTO:	ADDI TEM,200000		; KEEP TRACK OF LOOP COUNT
	MOVEM TEM,F2RECT	; AND SAVE IT
	JRST CPOPJ1		; GIVE SUCCESS RETURN

;IRRECOVERABLE DISK ERROR
DERRO1:	SETOM F2DERF		;SET ERROR FLAG FOR DSKCHN
	CAME TAC,DSKLUN		;UNIT NUMBER IS PROBABLY ALREADY STORED
	PUSHJ P,BUGTRP		;BUT JUST IN CASE
F2DWAK:	MOVEM TAC,DSKLUN
	CONO PI,4000!<1⊗<7-DSKCHN>>	;INITIATE INT INTO DSKCHN
	POPJ P,			;Return looking like xfer is going

;Here in DSKCHN with generated interrupt to handle irrecoverable disk error.
↑F2DERI:JSR DSKSV		;SAVE ACS, SET UP PDL
	SETZM F2DERF		;CLEAR FLAG THAT GOT US HERE
	DCONO 0			;ZERO OUT CHANNEL
	SKIPGE TAC,DSKLUN	;WERE WE WAITING FOR SOMETHING TO HAPPEN?
	PUSHJ P,POPTRP		;NO, COME ON NOW, WE'RE SUPPOSED TO BE!
;Here to tell someone about the error.  ERRBIT has disk error status.
;F2DSER sign bit is on if this is a startup error, RH nonzero if recal lost.
DERRO4:	MOVEM TAC,C1PKSV	;REMEMBER THE PACK NUMBER
	SKIPN DDB,PACTIV(TAC)	;GET DDB
	  PUSHJ P,FATTRP	;OOPS
	SETOM DSKLUN		;No longer expecting interrupt from F2 disk
	SETZM F2DACT		;No xfer going for C1 simulator any more
	SETZM PACBSY(TAC)	;Pack not busy, don't time it out
	MOVEM DDB,C1DDBS	;PUT WHERE CODE EXPECTS IT
	SETOM TYPANY		;Force time typeout at first message
	MOVE UUO,ERRBIT		;See what caused the lossage (on last retry)
	SETZM DEATH		;Assume we want to retry
	TLNE UUO,S.WRP!S.NRDY!S.SERR ;Write-lock, not up to speed, or no ID plug?
	  JRST DERRO5		;Yes, maybe we can recover with manual intervention
	SETOM DEATH		;Nope, none of those, you lose
	PUSHJ P,DSKETY		;Force error typeout, type time
	JRST DERRO6

DERRO5:	PUSHJ P,ERROR5		;Report probably correctable manual condition
DERRO6:	MOVE UUO,DEATH		;Iff not fatal error, stop the system
	SETCAM UUO,CSTOP	; cold before retry, after disk is checked
	MOVE TAC,C1PKSV		;Get pack number again
	CAIG TAC,FPACKS-1	;Skip if user pack, no CTY message
	  SKIPN UUO,F2DSER	;Startup error or recal failure?
	  JRST F2DERR		;No, go typeout msg, if needed
	PUSHJ P,SYSLOZ		;Yes, force cold stop, type time
	JUMPGE UUO,DERRO7	;Jump if not starting the disk
	PUSHJ P,DISMES
	 ASCIZ/Can't clear errors to start the disk.
/
DERRO7:	TRNN UUO,-1		;Recal fail?
	JRST F2DERR		;No
	PUSHJ P,DISMES
	 ASCIZ/Recalibrate failed.
/
	JRST F2DERR

>;IFN FTF2	;Covers many pages

;⊗ IS.SHT IS.DON IS.ERR IS.NRT IS.WGU IS.TPM IS.EOT IS.WLK IS.IER IS.DTE IS.DVE IS.BOT IS.RTL IS.IEL IRMWRD IRM6BT IRM7BT IRM8BT IRMHID RCNTOP RCNTO1 RHGO RHGO1 RHGO1A RHGO2 RHGO2B RHGO3 RHGO4 RHSIRB RHICCW RHGERR RHGER1

IFN FTRH,<

Extern IRBSTS,IRBMOD,IRBCNT,IRBXFL,IRBIVA,IRBADR,IRBDDB,STKACS,IRMWRD,IRFRED,IRFWRT
Extern RHACCW,WHISIO
Intern RHGERR,DEVIOS,QDSKIO

IFE FTMPP2,<
	.FATAL FTMPP2 must be non-zero
>;IFE FTMPP2

Comment $

Call RHGO with the following set up:
	DDB	DDB that is requesting a transfer
	TFRCTL(DDB)	Control word
		DSYSBF	transfer to system buffer
		DSYSB1	transfer must set TFRIOW from system buffer address
		DWRITE	disk write operation
		DSATOP	Sat Table operation
		DUSER	transfer references user addresses
		DCMPBF	Use BUFBUF(DDB) for addresses (sectors & core addr)
		DSWAP	swap operation
		DUDPOP	Old UDP operation (LONG!)
			
	TFRIOW(DDB)	-WC,,MA of transfer

	TFRSEC(DDB)	disk address
			discard sign bit if this is a swapping operation.
			otherwise, we expect either
				BYTE(1)1(3)Chan,Unit(29)Sector
			   or	BYTE(1)0(5)Structure(30)Sector
			        if structure number is zero, use PUNIT

There are two main divisions of transfers:
	Single block
		All all file operations are done as single block transfers.
		UUO and/or interrupt level code will break down file transfers
		into their component single block transfers.
		File I/O, Godmode I/O, RTVL ops, Directory ops, etc.

	Multi-block
		There are three kinds of multi-block transfers, all flagged
		separately in TFRCTL:
			SAT operations
			SWAP operations
			Old-UDP operations.
		For a multi-block transfer, the DDB must contain a pointer
		to a block of memory that we can use for the CCW list.
		
		For SAT operations, everything is supposed to be setup for a
		jump to RHSIRB.  (The SDB contains a pointer to the CCW list;
		UUO level code copied this pointer to DD.CCW)

Call PHYSIO with the following parameters set up:
  T1/	IORB
	0/	Status,,0			;IRBSTS (Right Half is link to next IORB)
		IS.SHT==1B0			;SHORT FORM (PAGEM) REQUEST
		IS.DON==1B1			;DONE WITH THIS IORB
		IS.ERR==1B2			;ERROR ON THIS OPERATION
		IS.NRT==1B3			;NO MORE RETRIES
		IS.WGU==1B4			;WRONG UNIT INTERRUPTED
		IS.TPM==1B5			;HIT TAPE MARK
		IS.EOT==1B6			;ON WRITE ONLY: HIT PHYSICAL EOT
		IS.WLK==1B7			;WRITE LOCKED
		IS.IER==1B8			;INHIBIT ERROR RECOVERY
		IS.DTE==1B9			;DATA ERROR
		IS.DVE==1B10			;DEVICE (HARDWARE) ERROR
		IS.BOT==1B11			;HIT BEGINING OF TAPE
		IS.RTL==1B12			;RECORD TOO LONG (BUFFER TOO SMALL?)
		IS.IEL==1B13			;INHIBIT ERROR LOGGING
		Bits 14:17 are ISFCN, the function:
			IRFRED = 1 ;read data
			IRFWRT = 3 ;write data
			IRFSEK = 5 ;seek
	1/	priority, density, parity,mode 	;IRBMOD
		Byte(15)0(3)Mode(9)0(4)Priority(1)Parity(4)Density
			Mode
				IRMWRD==1		;WORD MODE
				IRM6BT==2		;SIXBIT
				IRM7BT==3		;SEVEN BIT MODE
				IRM8BT==4		;EIGHT BIT MODE
				IRMHID==5		;HIGH DENSITY MODE

	2/	count of data transferred	;IRBCNT
	3/	Xfr list Tail,,Head		;IRBXFL
	4/	0,,RHIODN			;IRBIVA (routine to call at termination)
	5/	physical device address		;IRBADR
	6/	0,,DDB				;IRBDDB


 T2/	UDB address of affected unit


CCW list formats and sizes
	The first word in a CCW list is an aobjn pointer to the rest of the list.
CCW lists must not cross page boundaries.   Given the starting page # and the
ending page number of a transfer, the transfer requires <end page>-<start page>+1
CCW words.  (A CCW can't span more than one page either.)  The space needed
for a CCW list of N CCWs is 2*N+2, as follows:
	1 word for the aobjn word
	N words wasted to a page boundary (worst case, since we need N+1 contig words)
	N CCW words
	1 zero word.  NOT counted in the AOBJN.  The starting address of the
		AOBJN minus the (negative) AOBJN count, addresses this zero
		word, which will be the channel ending address. (Also this
		is the transfer tail address.)

$

;Count RH disk operations
RCNTOP:	LDB	TAC1,PJOBN	;Get the job #
	AOS	DSKOPS(TAC1)	;COUNT A DISK ACCESS FOR THIS USER
	HLRE	TAC1,TFRIOW(DDB);- WC
	MOVM	TAC1,TAC1
	ADDM	TAC1,DSKTWC	;UPDATE TOTAL DISK WORD COUNT
	ADDM	TAC1,RHDTWC	;Total in RH disks
	MOVE	TAC,TFRCTL(DDB)
	TLNE	TAC,DWRITE
	AOSA	RHDTWO		;ANOTHER WRITE OP
	AOS	RHDTRO		;ANOTHER READ  OP
	LDB	AC1,[POINT 29,TFRSEC(DDB),35]	;Get the record number
	MOVE	AC3,SDBPTR(DDB)
	MOVE	AC3,ST.TYP(AC3)		;pointer to device type table
	IDIV	AC1,SECCYL(AC3)		;Divide by number of records/cylinder
					;AC2 := record number within cylinder
	MOVE	AC3,DD.RPB(DDB)		;# of data records per block
	IDIVI	AC2,1(AC3)		;Divisor is number of allocated R p B
					;(Includes Rtvl).  AC3 := Record # in Blk
	JUMPN	AC3,RCNTO1		;Jump if starting in data portion of blk
	MOVSI	AC1,DRTVOP		;Mark for later this is RTVL op
	IORB	AC1,TFRCTL(DDB)
	TLNE	AC1,DWRITE
	AOSA	RHDRWO			;ANOTHER WRITE RETRIEVAL OP
	AOS	RHDRRO			;ANOTHER READ RETRIEVAL OP
	SUB	TAC1,DD.SSZ(DDB)	;decrement xfer size by RTVL size
	SKIPG	TAC1			;skip if data goes too.
	POPJ	P,
RCNTO1:	MOVE	TAC,TFRCTL(DDB)
	TLNE	TAC,DWRITE
	AOSA	RHDDWO			;ANOTHER WRITE DATA OP
	AOS	RHDDRO			;ANOTHER READ DATA OP
	POPJ	P,

RHGO:	MOVE	AC3,TFRCTL(DDB)
	TLNE	AC3,DSATOP
	JRST	RHSIRB			;For SAT, everything is supposedly ready
	TLNE	AC3,DSWAP		;Is this a swap operation?
	JRST	RHGOSW			;Yes.
	SKIPL	TAC1,TFRSEC(DDB)	;Skip if absolute address disk address
	PUSHJ	P,STRADR		;Convert structure relative to absolute
	JUMPE	TAC1,RHGER1		;Error in disk address.
	MOVEM	TAC1,DSKLRN(DDB)	;Save disk address
	MOVEM	TAC1,TFRSEC(DDB)	;Save here too (in case was struc. rel)
	PUSHJ	P,RCNTOP		;Count disk ops for user.
	TLNE	AC3,DUDPOP		;Is this a multi-block operation?
	JRST	RHGOUD			;Yes.
	MOVE	TAC,TFRCTL(DDB)		;Get flags
	TLNN	TAC,DSYSB1		;Must we set TFRIOW from assigned buffer?
	JRST	RHGO1			;no.
	SKIPN	TAC1,DD.SBB(DDB)	;yes. Do so.  Get address of assigned buffer
	JRST	PQANSB			;Bad news
	MOVEM	TAC1,TFRIOW(DDB)	;Set TFRIOW to address this DDB's buffer
RHGO1:	PUSHJ	P,RHICCW		;initialize CCW area (DD.CCW)
	MOVE	TAC1,TFRCTL(DDB)	;GET CONTROL BITS
	TLNN	TAC1,DUSER		;User mode addresses are wanted?
	JRST	RHGO2			;no! Must be SYSBUF or RTVL to DDB op
	LDB	J,PJOBN			;Job on whose behalf we're running
;Enter here from RHGOSW to complete setup for swapping operation.  J setup
RHGO1A:	PUSHJ	P,JOBMAP		;GET UPMP INTO EXEC MAP
	 JFCL
	LSH	AC1,PGSFT		;Address of the user's page map
	SKIPA
RHGO2:	MOVEI	AC1,EXPGT		;A SYSBUF or DDB request.  Use exec map
	MOVE	TAC1,TFRCTL(DDB)
;(swap in (dev READ) op is permitted even if core isn't otherwise writable)
	TLNN	TAC1,DWRITE!DSWAP	;Skip if write operation or SWAP
	TLO	AC1,(1B0)		;Device Read = Core Write.  Set 1B0
	MOVEM	AC1,DD.MAP(DDB)		;Save map word.
	MOVEI	AC1,0			;Not an AOBJN pointer if not using BUFBUF
	TLNN	TAC1,DCMPBF		;Are we using BUFBUF for addresses?
	JRST	RHGO3			;No.  AC1 = 0 to terminate loop at RHGO3
	MOVN	AC1,BUFBUF(DDB)		;Yes.  Get - the number of items in BUFBUF
	HRLZ	AC1,AC1
	HLR	AC1,BUFBUF(DDB)	
	TLNN	TAC1,DRTVOP		;Does this operation imply RTVL?
	JRST	RHGO2B			;No.  Data only.
;TFRSEC specifies that the operation begins in the RTVL area of the block.
;for this case, we copy DSKDAT(DDB) to the disk (at present this is only for write)
	PUSH	P,AC1			;Save AOBJN pointer to BUFBUF
	MOVN	AC1,DD.SSZ(DDB)		;-size of rtvl area
	HRLZ	AC1,AC1
	HRRI	AC1,DSKDAT(DDB)		;Write direct from DDB
	PUSH	P,DD.MAP(DDB)		;Save established map word
	MOVEM	AC1,TFRIOW(DDB)		;Store IOW for RTVL op
	MOVEI	J,EXPGT			;Use exec page map
	HRRM	J,DD.MAP(DDB)		;
	PUSHJ	P,RHACCW		;Add CCW for record zero
	 JRST	RHGERR			;Horrible error
	POP	P,DD.MAP(DDB)		;restore map word
	POP	P,AC1			;retrieve AOBJN pointer to transfer
RHGO2B:	MOVE	TAC,(AC1)		;fetch IOW word from BUFBUF
	MOVEM	TAC,TFRIOW(DDB)		;Store it as argument for RHACCW
RHGO3:	PUSHJ	P,RHACCW		;build CCWs as appropriate
	 JRST	RHGERR			;Horrible error
	AOBJN	AC1,RHGO2B		;Loop if BUFBUF transfer
;make certain the channel gets exactly a multiple of a sector to chew on
	MOVE	AC1,DD.IRB+IRBCNT(DDB)	;get the size of the transfer
	ANDI	AC1,RECSIZ-1		;Get any record overflow
	JUMPE	AC1,RHGO4		;Jump if exactly integral sectors
	SUBI	AC1,RECSIZ		;-number of words remaining
	PUSH	P,TFRIOW(DDB)
	PUSH	P,DD.MAP(DDB)
	HRLZM	AC1,TFRIOW(DDB)
	SETZM	DD.MAP(DDB)		;special argument to RHACCW
	PUSHJ	P,RHACCW
	 JRST	RHGERR
	POP	P,DD.MAP(DDB)
	POP	P,TFRIOW(DDB)
RHGO4:	MOVE	AC1,DD.CCP(DDB)
	SETZM	(AC1)			;store zero to halt the CCW list
	HLLZ	AC1,DD.CCP(DDB)
	MOVN	AC1,AC1
	ADDM	AC1,DD.CCW(DDB)		;-WC of relevant CCW list
;Start transfer.  
;DDB is set up.
;	TFRSEC is the disk address
;	TFRCTL (left half) DWRITE signifies a write operation.  Read otherwise
;	DD.CCW is the AOBJN pointer to the transfer CCW liist
;	DD.IRB is the place for the IORB.  The caller has set up IRBCNT (word count)
RHSIRB:	MOVEI	AC3,DD.IRB(DDB)		;create IORB
	HRRZM	DDB,IRBDDB(AC3)			;Store DDB so we can find it.
	LDB	AC2,[POINT 29,TFRSEC(DDB),35]	;disk address
	MOVEM	AC2,IRBADR(AC3)			;save device address
	MOVSI	AC2,IRMWRD
	MOVEM	AC2,IRBMOD(AC3)
	MOVE	AC2,TFRCTL(DDB)
	TLNN	AC2,DWRITE
	SKIPA	AC2,[IRFRED,,0]
	MOVSI	AC2,IRFWRT
	MOVEM	AC2,IRBSTS(AC3)
	HRRZ	AC2,DD.CCW(DDB)
	MOVEM	AC2,IRBXFL(AC3)
	HLRO	AC1,DD.CCW(DDB)
	SUB	AC2,AC1				;Points to the zero after the
	HRLM	AC2,IRBXFL(AC3)			;  last data CCW
;WHISIO sets T1 as DD.IRB(DDB) and T2 from the physical disk addr in TFRSEC
	JRST	WHISIO				;Whiz IO in PHYDAT

;Routine to build an AOBJN pointer to a block of words than can be used for CCWs.
RHICCW:	MOVEI	AC1,DD.CCW+1(DDB)		;First possible CCW word
	ANDI	AC1,PGSIZ-1			;Keep only word number in page
	MOVE	AC2,DD.RPB(DDB)			;Number of data records
	ADDI	AC2,3(AC2)			;Possibly 2 CCWs per record+
						;2 more for RTVL rec +1 for halt
	ADD	AC1,AC2				;address in page of next free wd
	CAIG	AC1,PGSIZ			;Skip if list crosses page bounds
	TDZA	AC1,AC1				;On page.  Offset from DD.CCW+1
	MOVE	AC1,AC2				;Off page.  2nd half will be contiguous
	ADDI	AC1,DD.CCW+1(DDB)		;Starting address of CCW space
	MOVN	AC2,AC2				;length of space so allocated
	HRL	AC1,AC2				;-WC of CCW space
	MOVEM	AC1,DD.CCW(DDB)			;Store AOBJN pointer to CCW space
	MOVEM	AC1,DD.CCP(DDB)			;AOBJN pointer for deposit.
	SETZM	DD.IRB+IRBCNT(DDB)		;Zero WC in IORB
	POPJ	P,

RHGERR:	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal error from RHGO.  PC = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ /  File = /
	MOVEI TAC,FILNAM(DDB)	;make ptr to filename block
	PUSHJ P,DISFIL		;print filename of interest
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	POPACS
	JRST FDDTCALL

RHGER1:	PUSHACS
	PUSH	P,DDB
	PUSHJ	P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 'RHGER1'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal.  Bad disk address at RHGO.  TFRSEC = /
	MOVE	DDB,(P)
	MOVE	TAC,TFRSEC(DDB)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	 ASCIZ	/   Structure /
	MOVE	DDB,(P)
	LDB	TAC,PUNIT
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	 ASCIZ	/  /
	POP	P,DDB
	MOVE	TAC,SDBPTR(DDB)
	MOVE	TAC1,ST.NAM(TAC)
	PUSHJ	P,DISSIX
	PUSHJ	P,DISCRLF	
	PUSHJ	P,DISFLUSH
	POPACS
	JRST	FDDTCALL

;Mount SAT table for RH disk ;⊗ GTSATX GTSATW GETSAT NOFS PUTSAT GETSA1 QDSKIO TSTOFL UDISIE TSTOF0

;*** UUO Code ****  (Also called at system initialization)

GTSATX:	PUSHJ	P,GETSAT		;here from SATGET.
	 JRST	SATGLZ			;What to do?
	POPJ	P,

;exit from GETSAT -- someone else was diddling the SAT
GTSATW:	ADJSP	P,-1
	PUSHJ	P,FSGIVE		;return the CCW list to free storage
	POP	P,AC1
	ADJSP	P,-1			;discard return to GTSATX
	JRST	SATGT0			;return FS and delay.

GETSAT:	MOVE	DAT,SDBPTR(DDB)		;Get the SDB address
	MOVE	TAC1,ST.STA(DAT)	;disk address of the SAT
	MOVE	TAC,ST.STN(DAT)		;get the structure number
	DPB	TAC,[POINT 5,TAC1,5]	;Store structure number with disk address
	PUSHJ	P,STRADR		;convert full disk address to C/U/Sec
	SKIPL	TAC1			;skip if good
	JSP	TAC,CPOPJ		;Error
	MOVEM	TAC1,ST.STB(DAT)	;store abs disk address in SDB
	MOVEM	TAC1,TFRSEC(DDB)	;(Argument to RHACCW)
	MOVE	AC1,[1B0+EXPGT]		;device read,,address of EXEC map
	MOVEM	AC1,DD.MAP(DDB)		;(Argument to RHACCW)
	HRRZ	AC3,ST.SSZ(DAT)		;get the size of SAT in words
	MOVNM	AC3,TFRIOW(DDB)		;-WC
	PUSHJ	P,FSGET			;get free storage for SAT
;(Label is referenced by people who analyze failure from GETSAT)
NOFS:	 JSP	TAC,CPOPJ		;error if we can't get it
	PUSH	P,AC1			;Save address of incore SAT
	HRLM	AC1,TFRIOW(DDB)		;MA,,-WC
	MOVSS	TFRIOW(DDB)		;-WC,,MA  (Argument to RHACCW)	
	HRRZ	AC3,ST.SSZ(DAT)		;Size (only!) of buffer area
	ADDI	AC3,-1(AC1)		;Ending address of buffer
	LSH	AC1,-PGSFT		;page number of start of SAT read
	LSH	AC3,-PGSFT		;page number of end of SAT read
	SUB	AC3,AC1			;AC3:= difference of page numbers
	ADDI	AC3,1			;Number of pages in xfer = # of ccw words
	PUSH	P,AC3			;Save the number of contig pages needed.
	ADDI	AC3,2(AC3)		;Double count, add halt word & AOBJN word.
	PUSHJ	P,FSGET			;get FS for CCW list
	 JRST [	ADJSP P,-1		;discard # of pages in xfer
		POP P,AC1		;get FS address
		PUSHJ P,FSGIVE		;return SAT block to FS
		JRST NOFS]		;Error return via  NOFS
;Now, we have the two necessary chunks of free storage.  See if someone beat
;us to it.
	SKIPE	ST.SAD(DAT)		;Skip unless someone is playing here
	JRST	GTSATW			;This has been diddled.  let him finish
	MOVE	AC3,-1(P)		;Address of the SAT
	HRROM	AC3,ST.SAD(DAT)		;Store this now.  Flag we are busy
	POP	P,-1(P)			;backup the stack
	HRRZM	AC1,ST.SCW(DAT)		;Save address of the CCW list.
	ADDI	AC1,1			;First possible word to start CCW list
	MOVE	AC3,(P)			;Number of contig words needed
	ADD	AC3,AC1
	XOR	AC3,AC1
	TRNE	AC3,-PGSIZ
	TDZA	AC3,AC3			;first half fits on the page
	MOVE	AC3,(P)			;Use the second half instead.
	ADD	AC1,AC3			;Form initial address of CCW list
	POP	P,AC3			;Get the size again
	MOVN	AC3,AC3
	HRL	AC1,AC3			;-N,,Address of CCW list
	MOVEM	AC1,@ST.SCW(DAT)	;Store as first cell in FS block.
	MOVEM	AC1,DD.CCP(DDB)		;Store also as argument to RHACCW
	PUSHJ	P,RHACCW		;Convert TFRIOW etc to CCW list
	 POPJ	P,			;Lose somehow.  Error code in TAC
	MOVE	AC1,DD.CCP(DDB)
	SETZM	(AC1)			;Clear last word.
	MOVSI	AC1,DSATOP		;read SAT
	PUSHJ	P,GETSA1		;Do the work.
	 POPJ	P,			;Some error.  Code in TAC
	JRST	CPOPJ1

PUTSAT:	MOVSI	AC1,DWRITE!DSATOP	;Set as SAT operation and WRITE
	PUSHJ	P,GETSA1
	 JRST	SATGLZ			;Type Write locked UDP message
	POPJ	P,

GETSA1:	MOVEM	AC1,TFRCTL(DDB)
	MOVE	AC3,SDBPTR(DDB)
	MOVEI	AC2,DD.IRB(DDB)
	HRRZ	AC1,ST.SSZ(AC3)
	MOVEM	AC1,IRBCNT(AC2)		;Store Word count in IORB
	MOVE	AC1,ST.STB(AC3)		;Get 1B0+CHAN/UNIT/SECTOR
	MOVEM	AC1,TFRSEC(DDB)		;Save the disk address in DDB
	HRRZ	AC1,ST.SCW(AC3)		;-1,,Address of CCW list
	MOVE	AC1,(AC1)		;Get the AOBJN pointer to CCW list
	MOVEM	AC1,DD.CCW(DDB)		;Store it
	MOVEI	DAT,TSTART
	PUSHJ	P,NEWAIT
	MOVE	AC3,SDBPTR(DDB)
	HRRZS	ST.SAD(AC3)
	LDB	TAC,PUNIT
	CAMN	TAC,PRSNUM
	JRST	CPOPJ1
	SKIPE	TFRCTL(DDB)
	JRST	CPOPJ1
	JSP	TAC,CPOPJ

;Initialization I/O.  Call from PHYDAT for reading/writing home blocks.
QDSKIO:	PUSHJ	P,TSTOFL		;Test for unit offline
	MOVEI	DAT,TSTART
	SKIPN	DD.IRB+IRBSTS(DDB)	;Don't do IO if error already (offline?)
	PUSHJ	P,NEWAIT
	MOVE	TAC,DD.IRB+IRBSTS(DDB)	;EXAMINE STATUS BITS
	TDNN	TAC,[IS.ERR]		;ANY ERRORS?
	MOVEI	TAC,0			;NO - RETURN 0
	MOVEM	TAC,TFRCTL(DDB)		;Return zero or error status in TFRCTL
	POPJ	P,

TSTOFL:	SETZM	DD.IRB+IRBSTS(DDB)	;Assume ok.
	MOVE	TAC1,TFRSEC(DDB)	;Argument to GETUDB
	PUSHJ	P,GETUDB		;Get the UDB for this unit (to AC3)
	JUMPE	AC3,TSTOF0		;Jump if no UDB
UDISIE:	MOVE	TAC1,[US.OFS!US.CHB]
	TDNN	TAC1,UDBSTS(AC3)	;Skip if unit is inaccessible
	POPJ	P,			;YES - GO AHEAD
TSTOF0:	MOVE	TAC,[IS.ERR!IS.NRT]	;NO, GET ERROR BITS
	MOVEM	TAC,DD.IRB+IRBSTS(DDB)	;STORE INTO IORB
	POPJ	P,
;RHGO - multi block operations: old-mode UDP or swapping ;⊗ RHGOUD RHGOSW RHSWPE

;UDP operations
RHGOUD:	PUSHACS
	PUSHJ	P,DISGST
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal: unimplemented old-mode UDP operation on RH-disk
/
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL


RHGOSW:	HRRZ	TAC,DDB
	CAME	TAC,SWPDDB
	JSP	TAC,RHSWPE		;Swapping operation not from SWPDDB!
	LDB	TAC,[POINT 6,TFRSEC(DDB),5]
	SKIPE	TAC
	JSP	TAC,RHSWPE		;Bad address (must be structure relative!)
	MOVE	TAC1,TFRSEC(DDB)	;Get the disk address
	PUSHJ	P,STRADR		;Convert structure relative to absolute
	SKIPL	TAC1
	JSP	TAC,RHSWPE		;Error in disk address.
	MOVEM	TAC1,TFRSEC(DDB)
	LDB	TAC1,[POINT 29,TAC1,35]	;get the in-unit record number
	SUB	TAC1,FSSUN		;subtract in-unit origin of swap space
	SKIPGE	TAC1
	JSP	TAC,RHSWPE		;Error if not in swapping region
	MOVE	TAC,RHSBSZ		;get the band size in words
	LSH	TAC,-RECWSH		;shift down to make band size in records
	ADD	TAC,TAC1
	CAMLE	TAC,NSSUN		;transfer must end by this point
	JSP	TAC,RHSWPE
	MOVE	TAC,TFRIOW(DDB)
	TDNE	TAC,[<PGSIZ-1>,,<PGSIZ-1>]
	JSP	TAC,RHSWPE		;Not integral pages or not page aligned
	HLRE	TAC1,TFRIOW(DDB)	;GET - WORD COUNT
	SKIPL	TAC1
	JSP	TAC,RHSWPE		;MUST BE NEGATIVE
	MOVN	TAC1,TAC1
	CAMLE	TAC1,RHSBSZ		;Mustn't be larger than one band
	JSP	TAC,RHSWPE
;All sanity checks have been passed.  Perform the transfer.
;(following is similar to RHICCW)
	MOVEI	AC1,DD.CCW+1(DDB)		;First possible CCW word
	ANDI	AC1,PGSIZ-1			;Keep only word number in page
	MOVE	AC2,TAC1			;Number of words in transfer
	LSH	AC2,-PGSFT			;number of pages in transfer
	ADDI	AC2,1				;Plus one for the halt word
	ADD	AC1,AC2				;address in page of next free wd
	CAIG	AC1,PGSIZ			;Skip if list crosses page bounds
	TDZA	AC1,AC1				;On page.  Offset from DD.CCW+1
	MOVE	AC1,AC2				;Off page.  2nd half will be contiguous
	ADDI	AC1,DD.CCW+1(DDB)		;Starting address of CCW space
	MOVN	AC2,AC2				;length of space so allocated
	HRL	AC1,AC2				;-WC of CCW space
	MOVEM	AC1,DD.CCW(DDB)			;Store AOBJN pointer to CCW space
	MOVEM	AC1,DD.CCP(DDB)			;AOBJN pointer for deposit.
	SETZM	DD.IRB+IRBCNT(DDB)		;Zero WC in IORB
	MOVM	J,FINISH			;use job number of job being swapped.
	JRST	RHGO1A


RHSWPE:	PUSHACS				;Here via JSP TAC,
	PUSH	P,TAC
	PUSHJ	P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 'RHSWPE'
	PUSHJ	P,DISMES
	 ASCIZ	/Fatal - Error in parameters to an RH Swapping operation.
Error PC = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	POPACS
	JRST	FDDTCALL
;⊗ DSKSPY

;Special UUO for use in restoring file system.  Normally no one uses this
;code.  Patch the left half of UCLJMP+21 (the dispatch address for the SPY
;UUO) to point here, for special code in DART to spread out files being
;restored among the disk units.

;Here (from CALLI dispatch) with TAC containing block number to store
;into SAT of primary structure.

DSKSPY:	MOVE AC1,PRSNUM
	MOVE AC1,SDBADR(AC1)	;Get SDB for primary structure
	MOVE AC1,ST.SAD(AC1)	;Get SAT address
	MOVEM TAC,LSTBLK(AC1)	;Store the last block pointer
	POPJ P,
;⊗ RUDPUP

;Check the home blocks and read the SAT of any UDP(s) that just came online.
;Which drives just came online are indicated by ...
RUDPUP:

	;UNIMPLEMENTED

	POPJ P,

>;IFN FTRH
BEND DSKSER
