COMMENT ⊗   VALID 00033 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	CORE ROUTINES FOR SWAPPING SYSTEM. 4 AUG 67 ↔ BEGIN CORE
C00012 00003		NON-SHUFFLING SYSTEM
C00016 00004	CORINI CORCON CORCO1 CORCP2 CORCOD CORI1 CORI49 CORI4 CORI6 CORI69 CORI3 CORI5 MAPPG1 MAPPG3 MAPPG2 SYBPG1 SYBPG3 SYBPG2 ADJCOR ADJCO2 CORIPF CORIP1 YORNIN
C00032 00005	CALL CORUUO ZERCOR UCORE CORCSO CORCS3 CORCSL CORCS2 CORXOK CORYOK RUNCOR
C00038 00006	SPWCNT
C00039 00007	ANYACT ANYAC1 ANYA1A ANYAC2 ANYAC3 ANYA3A ANYAC4 ANYAC5 ANY ANY2 ANY2A ANY7 ANY7A ANY7B ANYHCC
C00046 00008	CORE0 CORE0B CORE0K
C00050 00009	CORE0A CORE1 CORE1Z COR1ZG COSUPA COR1ZF COR1ZA COR1ZE
C00056 00010	COREFC CORFC0 FCGOTM CORFC1 FCZERO FCZER1 CNEWFC CNEWF1 XVDMPW POPDBJ
C00064 00011	CORHGT CORGET CORG1 CORG2 CORGT0 CORGT1 CORGT2 CORGT3 CORGT4 CORGTA GETPAG GETNPG GETPG1 GETPG3 GETPG2 GETPG4
C00073 00012	DIDLEA DIDLE2 CSTAT1 CSTAT2 DIDL4A DIDL4B DIDL4C DIDLE4 DIDLEX
C00078 00013	CORCHK CORCH0 CRCH1A CORCH8 CORC8A CRCH8B CORC8C CORCH2 CRCH2E CORCH3 CORTCK CORCKL CORCK1 CORCKN CORCK0 CRCK0A CORCK2 CORCKZ CORCKC CORCKD CORCKE CORCKX
C00086 00014	 CORGBP CORGB1 COREP COREPA CORSGT CORSG1 LOW128
C00088 00015	GETPR GETPR5 GETPR3 GETPR2 GETPR1 GETPR4 GETPR6
C00092 00016	RELOCA RELOC1 RELOC4 RELOC2 RELC2A RELOC3 RELOCB RELOC5 RELOCC RELOCD
C00099 00017	UNLOKC UNLOCK LOCK0 LOCK0A LOCK0B LOCK LOCK2 LOCK1 LOCKCK LOCKC1
C00103 00018	LTHUUO LTHMOV LTHM1 LTHM1B LTHM2 LTHM2A LTHM2Z LTHM3 HTLMOV HTLMV1 HTLMV2 HTLFIN HTLFN1 HTLFN2 HTLFN3 HCBUG HCB1 HCB1A HCB1B HCB2
C00112 00019	FREE STORAGE	AND OTHER POLITICAL PRISONERS
C00113 00020	FSINIT FSINI3 FSINI5 FSHIN0 HFSIN3 HFSINI HFSIN2 HFSIN5 FSACSV NFSACSV FSACRS
C00124 00021	CALLING FSSBYP FSSBP1 FSGETP HFSGTU HFSGET FSGET FSGETU FSGETV FSGETT FSGT0 FSGT1 FSGCL FSGCLX FSGTBX FSGTB0 FSGTB1 FSGTB2 FSHGB1 FSHGB2 FSHGLZ FSGPAG FSGPG1 FSGPG2 FSGPG3 FSGTC FSGTC1 FSCLP FSCNEW FSCEND FSGTC2 FSGTC5 FSGTC3 FSGTC6 FSGTC4 FSGTCR FSGRT1 FSGTW FSGTWX FSGTW5 FSGFAI FSGLUZ
C00146 00022	FSGETK FSGTKZ FSGTKQ FSGTKY FSSWAP FSWP3A FSSWP3 FSWAKE FSWAK1
C00152 00023	FSHGTK FSHGK9 FSHGK0 FSHGK1 FSHEVM FSHSWP FSHP3A FSHWP3
C00157 00024	FSCLK FSCKY FSCLK1 FSGVK1 FSGVK3 FSCKZ FSCLK3 FSCLK4 FSCKX
C00164 00025	CALLING FSECHK FSCLP1 FSCEN1 FSECK0 FSECK1 FSECK2 FSECK3 FSECK4 FSECK5 FSECK6 FSECKX FSGIVE FSGIH0 FSGIVX FSGIVY FSGV0 FSGV1 FSGV2 FSGV2A FSGV5 FSGV61 FSGV6 FSGV7 FSGV8 FSXPOP FSPOP FSQUIK FSQUK1 FSVBCK FSVBC1 FSVBC2 FSVBC3 FSVBE1 FSVBE2 FSVBE3 FSVBE4 FSVBE0 FSVBX1 FSVBX2 FSVBX3 FSVBX4 FSVBX5 FSVBX6 FSVBX7 FSVBX8 FSVBXT FSVBXY FSVBXZ
C00184 00026	UFSGET UFSGT1
C00186 00027	RELPDL
C00188 00028	SFSINI SFSIOL SFSIIL SFSI3 SFSI2 SFSCLK SFSCL1 SFSCLL SFSCL2
C00191 00029	SFSGET SFGFS SFSCLP SFSCNE SFSCEN SFSXIT SFSWIN SFSGTS SFSGOK SFGSF SFGTS SFSLUZ SFULUZ
C00196 00030	SFILUZ
C00197 00031	SFSGIV SFSREL SFSRLL
C00201 00032	RELEX RELX1 RELX2 RELXI RELXL RELXO
C00204 00033	GETMAP GIVMAP JOBMAP JOBEVP GETMAP GIVMAP GETMP3 HIDVBG DEVBEG
C00210 ENDMK
C⊗;
SUBTTL	CORE ROUTINES FOR SWAPPING SYSTEM. 4 AUG 67 ↔ BEGIN CORE

;Core is allocated on a 512-word page basis.
;Each entry in the CORTAB table is marked with one of the following codes:

;Core USage codes:

;	0	;Block is available (MUST BE ZERO)
;     1:JOBN-1	;Block is in use by the job named in this code
↑SYSCUS←←4001	;Block is occupied by the system
↑NXMCUS←←4003	;Block does not exist (NXM)
↑FSCUS←← 4005	;Block is in use by system as free storage.
↑IOBCUS←←4007	;Block is in use as an I/O buffer (SYSBUF for example)
↑PGTCUS←←4010	;Block is in use as a page table (not as free storage)
↑P2MCUS←←4011	;Block is part of P2 memory

IFGE JOBN-4000,<.FATAL JOBN is too big for CORTAB core usage codes>

COMMENT $

When the system is initialized, CORINI sets the CORTAB table to
reflect blocks in use by the system and non-existant blocks.

FSINIT completes the task of initializing core.  FSINIT is called for
every 200 restart, initialization, or reload.  FSINIT unlocks any
locked core, returns any claimed free storage to the general core
pool and then initializes free storage to contain one block of size
FSNINIT*1024 words. 

Core Allocation Routines:

Generally TAC must be setup to the desired core size for the job
whose number is in J.

CORUUO is called by the CORE UUO, CORE2 and REMAP UUOs.  For lowers,
there is already core in core.  For uppers, there may not be any
physical core assigned.  CORUUO calls UCORE.  CORUUO stores the
number of free blocks available by calling STOTAC.

UCORE is called by CORUUO and by BUFCLC, always at UUO level.  UCORE
calls IOWAIT to wait for IO to stop, then calls either CORE1 or CORE0
(CORE0 if there's no core assigned to this job), upon return WSCHED
is called, because resulting core may be assigned on swapping disk.

RUNCOR is called at UUO level (monitor job) for SAVGET.  Core already
is assigned to the job.  Calls CORE1 then WSCHED.  Unlike CORUUO,
RUNCOR does not store the number of free blocks into user's core.

CORE0 is called at clock level.  If job already has core in core, it calls
CORE1.  CORE0 is used by ZEROSEG, FINOUT (to release core), by KILCM7
and RUNCOM (to assign a job data area) and by the console CORE
command to change a job's core assignment without running that job.
If a job has no core in core (either swapped out, or NULQ) then CORE0
will assign core on the disk.

CORE1 is called at any level.  Job must already have some core.  The
new core assignment may be zero.

CORGET is called if a job has no core (or when it's core has been
temporarily marked free prior to assigning new core).  Called by
CORE1 and INJOB.

CORGET assigns core to a job, if possible, sets the use code in
CORTAB, and moves the job if this assignment is at a different place
than the old core.  If CORGET can't assign new core, it restores the
old assignment, if any, and calls XPAND to cause the job to be
swapped out.  Then the swap-in process will assign new core.

The table, JBTPAG, is updated by the core routines.  For each job in core,
JBTPAG is the number of pages,,hi pages.  Also, JOBREL in the user's core
image is modified by the core routines.  If the current job is changing its
core allocation, the APR map is changed accordingly.  JBTMAP entries
for each job are maintained to correspond to JBTPAG.

$
COMMENT ⊗	NON-SHUFFLING SYSTEM

The system will be in one piece (i.e., HISYS will be turned off) and
will be followed in low core by all of DDT and system symbols.  SYSTOP
and SYSPAG will point at the first page after this.

Free storage will begin at SYSTOP and will grow upwards to an assembled
in limit FSLIMIT.  The cell FSTOP contains the dynamic value of the end
of free storage and the beginning of user core.

All of the remaining core, including any core above the low moby, is user
core.  It does not need to be contiguous, i.e., there may be holes in it.

The system will never reference user core by absolute address.  It will
always use either an XCTR or an exec page.  The system's virtual address
space (on both processors)  will be straight through starting at 0 and
going until FSLIMIT.  Pages from FSLIMIT through page 777 will be exec
pages (which are not necessarily the same on both processors.)  Exec pages
will be assigned from 777 down so as to enable FSLIMIT to (potentially)
be as large as possible.


In the non-shuffling system, jobs that are locked in may live only above
FSLIMIT.  Otherwise, free storage may be prohibited from expanding by a
locked in job.  In order to implement this, it is necessary to maintain
several separate counts:

LOFREE:		the number of free pages below FSLIMIT
LOKTOT:		the number of pages locked in core (above FSLIMIT)
HIFREE:		the number of free pages above FSLIMIT
HIUSED:		the number of user-claimed pages above FSLIMIT
RH(JBTPAG):	the number of pages in this job above FSLIMIT

The process of locking a job in core is reduced to the following:
	swap him out and enter a request to swap him in above FSLIMIT
	when HIFREE is big enough.  The swapper needs the other cells
	to determine if it should swap out jobs to make room above
	FSLIMIT.

⊗


;Special AC names (also TAC, TAC1, PROG, IOS, DDB, and P are used)

;;BLK←AC1	;HIGHEST REL. ADR. IN USER AREA (now AC1 is used explicitly)
;;LOC←DSER	;ABS. LOC. OF FIRST BLOCK IN USER AREA (now DSER used explicitly)
;CORINI CORCON CORCO1 CORCP2 CORCOD CORI1 CORI49 CORI4 CORI6 CORI69 CORI3 CORI5 MAPPG1 MAPPG3 MAPPG2 SYBPG1 SYBPG3 SYBPG2 ADJCOR ADJCO2 CORIPF CORIP1 YORNIN

;CORINI	INITIALIZE CORE TABLES

↑CORINI:MOVE TAC,[CORBEG,,CORBEG+1]
	SETZM CORBEG
	BLT TAC,COREND
IFE FTF2,<
NOKL10,<CONO APR,NXM	>	;CLEAR NXM
IFKL10,<CONO APR,KLCLRF!7740	;CLEAR NXM, ETC.
	PUSH P,KLUPT+KLPFNP	;SAVE STANDARD PAGE FAULT TRAP
	MOVEI TAC,CORIPF	;OUR TRAP HANDLER
	MOVEM TAC,KLUPT+KLPFNP	;NEW PC FOR PAGE FAIL
>;IFKL10
>;IFE FTF2

;MAP IS ALREADY SUPPOSED TO BE TURNED ON!
;TRAPS (WHICH SHOULDN'T HAPPEN) WILL GO TO INITRP IN SYSINI

	MOVSI TAC,PWRT		;PAGE TABLE POINTER TO 0
	MOVEM TAC,EXPGT+PAREXP	;CLOBBER MAP

;FIRST WE SEE IF ALL THE CORE BOXES ARE THERE
	MOVSI AC3,-LMEMCON
CORCON:	LDB TAC1,[POINT 13,MEMCON(AC3),26] ;GET PAGE NUMBER
	HRRM TAC1,EXPGT+PAREXP	;STORE IN PAGE TABLE
NOKL10,<
IFE FTF2,<
	CONO PAG,1		;CLEAR ARS MAPPING EXEC PAGES.
>;IFE FTF2
IFN FTF2,<
	DATAO PAG,PAREXP⊗9	;CLEAR PAGE TABLE ENTRY FOR PAREXP
>;IFN FTF2
>;NOKL10
IFKL10,<BLKO KLPAG,PAREXP⊗9	;CLEAR PAGE TABLE RAM FOR PAREXP
>;IFKL10
	LDB TAC,[POINT 9,MEMCON(AC3),35]
IFN FTF2,<
	MOVEI AC1,0
	EXCH AC1,PAREXP⊗9(TAC)	;Put a zero into memory and read it
	EXCH AC1,PAREXP⊗9(TAC)	;back, restoring original data to memory
	SKIPN AC1		;NXM on F2 returns -1: skip if NXM
>;IFN FTF2
IFE FTF2,<
	CAM PAREXP⊗9(TAC)	;REFERENCE MEMORY
NOKL10,<CONSO APR,NXM		;SKIP IF NXM
>;NOKL10
IFKL10,<CONSO APR,KLNXM		;SKIP IF NXM
>;IFKL10
>;IFE FTF2
CORCO1:	AOBJN AC3,CORCON
	JUMPGE AC3,CORCOD	;EVERYONE IS HOME
IFE FTF2,<			;With F2, there is no NXM flag to clear
NOKL10,<CONO APR,NXM		;CLEAR NXM
>;NOKL10
IFKL10,<CONO APR,KLCLRF!KLNXM	;CLEAR NXM
>;IFKL10
>;IFE FTF2
	SKIPLE CORNXM
	JRST CORCP2		;HE WANTS TO IGNORE THESE
	PUSHACS
	MOVE TAC,MEMNXT(AC3)
	HRLI TAC,440700
	JSR DDTTYPE
	MOVE TAC,[POINT 7,[ASCIZ / is off line.  /]]
	JSR DDTTYPE
NOKL10,<MOVE TAC,[POINT 7,[ASCIZ/Check all memories and reload.
Else push CONTINUE to ignore further NXM errors and run with reduced memory.
/]]
>;NOKL10
IFKL10,<MOVE TAC,[POINT 7,[ASCIZ /Check all memories and reload.
Else type RN to ignore further NXM errors and run with reduced memory.
/]]
>;IFKL10
	SKIPGE CORNXM		;LT 0 means set from SYSINI flag, no halt
	MOVE TAC,[POINT 7,[ASCIZ /Will run with reduced memory.
/]]
	JSR DDTTYPE
	SKIPL CORNXM		;Don't halt if he expected this
	JRST 4,.+1
	MOVEI TAC,-1
	MOVEM TAC,CORNXM	;Set flag that we've typed some stuff out
	POPACS
CORCP2:
IFN FTP2,<
	PUSH P,TAC
	HLRZ TAC,MEMCON(AC3)	;GET MOBY NUMBER
	CAIN TAC,P2BASE⊗-=9	;IS THIS P2 MEMORY?
	SETOM NOP2		;FLAG P2 AS DOWN
	POP P,TAC
>;IFN FTP2
	JRST CORCO1

CORCOD:	MOVSI AC3,-PHYMEM*2	;NUMBER OF PAGES OF PHYSICAL CORE TO SCAN.
CORI1:	MOVEI TAC1,(AC3)	;GET PAGE NUMBER
	LSH TAC1,9		;SHIFT TO MAKE PHYSICAL ADDRESS
	HRRM AC3,EXPGT+PAREXP  	;STORE PAGE NUMBER TO REFERENCE
NOKL10,<
IFE FTF2,<
	CONO PAG,1		;CLEAR ARS MAPPING EXEC PAGES.
>;IFE FTF2
IFN FTF2,<
	DATAO PAG,PAREXP⊗9	;CLEAR PAGE TABLE ENTRY FOR PAREXP
>;IFN FTF2
>;NOKL10
IFKL10,<BLKO KLPAG,PAREXP⊗9	;CLEAR PAGE TABLE RAM FOR PAREXP
>;IFKL10
	CAM 20!PAREXP⊗9 	;REFERENCE MEMORY
	CAM 21!PAREXP⊗9
	CAM 22!PAREXP⊗9
	CAM 23!PAREXP⊗9
	MOVEI DAT,0
IFN FTHSYS,<
	MOVEI TAC,(AC3)
	CAIL TAC,1000
	CAML TAC,FHUPAG		;SKIP IF THIS IS A HISYS ADDR
>;IFN FTHSYS
	CAMGE TAC1,SYSTOP	;SKIP IF ADDRESS IS BEYOND SYSTEM.
	JRST CORI3		;SYSTEM PAGE
IFN FTF2,<
	MOVEI TAC,0
	EXCH TAC,21!PAREXP⊗9
	EXCH TAC,21!PAREXP⊗9	;Restore contents, get -1 if NXM
	SKIPE TAC		;SKIP UNLESS NXM
>;IFN FTF2
IFE FTF2,<
NOKL10,<CONSZ APR,NXM		;SKIP UNLESS NXM
>;NOKL10
IFKL10,<CONSZ APR,KLNXM		;SKIP UNLESS NXM
>;IFKL10
>;IFE FTF2
	JRST CORI6		;NXM
	HRRZ TAC,AC3		;PHYSICAL PAGE NUMBER
IFN FTP2,<
	CAIL TAC,P2BASE		;SKIP IF BELOW P2 MEMORY
	CAIL TAC,P2BASE+P2SIZE	;SKIP IF NOT ABOVE P2 MEMORY
	JRST CORI49		;JUMP IF NOT P2 MEMORY
	MOVEI DAT,P2MCUS	;P2 MEMORY, SPECIAL CODE
	JRST CORI4
CORI49:
>;IFN FTP2
	CAIL TAC,GOODPG		;COUNT ONLY GOOD PAGES
	JRST CORI4
	CAMGE TAC,FSLIMIT
	AOSA LOFREE
	AOS HIFREE
CORI4:	MOVEI DSER,(AC3)
	PUSHJ P,CORGBP		;COMPUTE BYTE POINTER TO CORTAB
	DPB DAT,TAC		;MARK CORTAB FOR THIS PAGE.
IFE FTF2,<			;F2 HAS NO NXM BIT TO CLEAR
NOKL10,<CONO APR,NXM		;CLEAR NXM
>;NOKL10
IFKL10,<CONO APR,KLCLRF!KLNXM	;CLEAR NXM
>;IFKL10
>;IFE FTF2
	AOBJN AC3,CORI1		;LOOP IF STILL WITHIN CONFIGURATION LIMIT
	JRST CORI5

CORI6:
IFN FTP2,<
	CAIL TAC,P2BASE		;SKIP IF BELOW P2 MEMORY
	CAIL TAC,P2BASE+P2SIZE	;SKIP IF NOT ABOVE P2 MEMORY
	JRST CORI69		;JUMP IF NOT P2 MEMORY
	SETOM NOP2		;*** NXM IN P2 MEMORY, DECLARE IT DEAD
CORI69:
>;IFN FTP2
	TROA DAT,NXMCUS		;NXM CORE USAGE CODE 
CORI3:	MOVEI DAT,SYSCUS	;SYSTEM PAGE CORE USAGE CODE
	JRST CORI4

CORI5:
IFN FTMPP2∨¬FTMAPP,<
IFN FTHIFS,<
	MOVE DSER,FSLIMIT	;FIRST EXEC VIRTUAL PAGE ASSIGNABLE AS FS
	MOVEM DSER,HIFSEV	;HIGH FS EXEC VIRTUAL PAGE NUMBER
>;IFN FTHIFS
>;IFN FTMPP2∨¬FTMAPP
IFN FTMAPP,<
	MOVE DSER,FSLIMIT	;START ASSIGNING PAGES HERE
	MOVN AC1,JOBNM1		;number of page map pages we need, one per job
	HRLZ AC1,AC1		;make aobjn cnt in lh
	HRRI AC1,1		;skip null job, start with job 1
	MOVEI AC3,PGTCUS	;CODE FOR PAGE MAP
MAPPG1:	LDB TAC,COREP		;GET CORTAB CODE FOR THIS PAGE
	JUMPE TAC,MAPPG2	;JUMP IF FREE
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CAN'T ASSIGN CONTIGUOUS PAGE MAP PAGES AT CORINI.
/
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCAL
	JRST AUTOLOAD

MAPPG3:	AOJA DSER,MAPPG1	;TRY NEXT PHYSICAL PAGE

MAPPG2:	DPB AC3,COREP		;STORE CODE
	SOS HIFREE
	MOVEM DSER,JBTMA2(AC1)	;STORE PAGE NUMBER FOR JOB'S PAGE MAP
IFE FTMPP2,<
	MOVE TAC1,DSER
	PUSHJ P,ADDEVP		;SETUP EXEC MAP AS STRAIGHT THROUGH
>;IFE FTMPP2
	AOBJN AC1,MAPPG3
IFE FTMPP2,<
IFN FTHIFS,<
	ADDI DSER,1		;FIRST UNUSED EXEC VIRTUAL PAGE
	MOVEM DSER,HIFSEV	;IS USABLE FOR HIGH FS
>;IFN FTHIFS
>;IFE FTMPP2
>;IFN FTMAPP
IFN FTSBP,<
	MOVEI TAC1,SYBEXP	;SET UP EXEC PAGES FOR SYSBUF
	MOVE DSER,FSLIMIT	;START ASSIGNING PAGES HERE
	MOVEI AC1,NSYPGS	;NUMBER OF PAGES TO GET
	MOVEI AC3,IOBCUS	;CODE FOR I/O BUFFER
SYBPG1:	LDB TAC,COREP		;GET CORTAB CODE FOR THIS PAGE
	JUMPE TAC,SYBPG2	;JUMP IF FREE
SYBPG3:	AOJA DSER,SYBPG1	;TRY NEXT PHYSICAL PAGE

SYBPG2:	DPB AC3,COREP		;STORE CODE
	SOS HIFREE
	MOVEI TAC,(DSER)	;PHYSICAL PAGE
	PUSHJ P,ADDEMP		;MAKE AN ENTRY IN THE EXEC PAGE MAP
	ADDI TAC1,1		;NEXT VIRTUAL PAGE
	SOJG AC1,SYBPG3
>;IFN FTSBP
	MOVE TAC,LOFREE		;SET CORMAX AND USRMAX FROM HIFREE, LOFREE
	ADD TAC,HIFREE
	LSH TAC,9		;MAKE IT NUMBER OF WORDS
	MOVEM TAC,CORMAX	;INITIAL AMOUNT OF USER CORE
	PUSHJ P,ADJCO2		;INITIALIZE USRMAX
	SETZM EXPGT+PAREXP	;FLUSH RANDOMNESS FROM EXPGT
NOKL10,<
IFE FTF2,<			;NO NXM BIT ON F2
	CONO PAG,1		;CLEAR ARS MAPPING EXEC PAGES.
	CONO APR,NXM		;CLEAR NXM
>;IFE FTF2
IFN FTF2,<
	DATAO PAG,PAREXP⊗9	;CLEAR PAGE TABLE ENTRY FOR PAREXP
>;IFN FTF2
>;NOKL10
IFKL10,<BLKO KLPAG,PAREXP⊗9	;CLEAR PAGE TABLE RAM FOR PAREXP
	CONO APR,KLCLRF!7740	;CLEAR NXM, ETC.
	POP P,KLUPT+KLPFNP
>;IFKL10
	MOVE TAC,[%SWPL]
	MOVEM TAC,SWAPLI	;SET SYSTEM SWAPLIMIT.
	POPJ P,

;After initialization, routines diddle CORMAX and USRMAX by putting amount
;of change for CORMAX into TAC and calling ADJCOR.
↑ADJCOR:ADDB TAC,CORMAX		;ADJUST CORMAX BY AMOUNT OF CHANGE
ADJCO2:	CAILE TAC,776000
	MOVEI TAC,776000	;BH 7/22/78 510 PAGES MAX
	MOVEM TAC,USRMAX	;MAXIMUM JOB SIZE (CLIP AT 776)
	POPJ P,

IFKL10,<
CORIPF:	CONSO APR,KLNXM		;SEEN A NXM?
	JRST CORIP1		;NO.  NO REASON TO FAULT.
	CONO APR,KLCLRF!7740-KLNXM ;CLEAR PARITY ERRORS, KEEP NXM
	AOS KLUPT+KLPFPC	;ADVANCE OVER FAILING INSTR.
IFN FTKLB,<
	XJRSTF KLUPT+KLPFFG	;restore flags and PC from double word
>;IFN FTKLB
IFE FTKLB,<
	JRST 2,@KLUPT+KLPFPC
>;IFE FTKLB

CORIP1:
IFN FTKLB,<	;KL model B microcode has no core clearing instruction (yet)
	MOVE TAC,[POINT 7,[ASCIZ /
Page fault other than NXM from CORINI (probably parity errors).
Clear all of core and then reload again.

/]]
	JSR DDTTYPE
IFN FTARM10M,<
	MOVE TAC,[POINT 7,[ASCIZ/Type Y to clear the ARM-10M at usual starting address: /]]
	PUSHJ P,YORNIN		;type msg, get answer, skip if No
	 JRST CLRARM		;zero the whole ARM-10M
>;IFN FTARM10M
	PUSHJ P,DDTCAL		;give him a chance to do whatever from DDT
	JRST 4,.

IFN FTARM10M,<
CLRARM:	MOVSI 16,CLRAMC
	BLT 16,CLRAML
	JRST 1

;Code to run in ACs to zero from ARMBEG through ARMLEN⊗-9 pages
CLRAMC:	-<ARMLEN⊗-9>,,<ARMBEG⊗-9>		;0
	HRRM 0,EXPGT+PAREXP			;1
	BLKO KLPAG,PAREXP⊗9			;2
	SETZM PAREXP⊗9				;3
	SKIPA 16,5				;4
	PAREXP⊗9,,PAREXP⊗9+1			;5
	BLT 16,PAREXP⊗9+777			;6
	AOBJN 0,1				;7
	HALT DDT				;10
CLRAML==.-CLRAMC
>;IFN FTARM10M


>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,[POINT 7,[ASCIZ /
Page fault other than NXM from CORINI (probably parity errors).
Clear all of core (then reload again); use DATAO PI,[starting address
					       length]

/]]
	JSR DDTTYPE
IFN FTARM10M,<
	MOVE TAC,[POINT 7,[ASCIZ/Type Y to clear the ARM-10M at usual starting address: /]]
	PUSHJ P,YORNIN		;type msg, get answer, skip if No
	 DATAO PI,[ARMBEG↔ARMLEN] ;zero the whole ARM-10M (less shadow ACs per moby)
		;Note: This DATAO will zero the ACs!!
	MOVE P,[-ERRPLN,,ERRPD-1] ;Need stack briefly, ACs may have been zeroed!
>;IFN FTARM10M
	MOVE TAC,[POINT 7,[ASCIZ/Type Y to clear the MGs (0 through 777777): /]]
	PUSHJ P,YORNIN		;type msg, get answer, skip if No
	 DATAO PI,[0↔777777]	;clear first moby (clobbering this code!)
		;Note: This DATAO will zero the ACs and probably DDT!!
	PUSHJ P,DDTCAL		;give him a chance to do whatever from DDT
	JRST 4,.
>;IFE FTKLB

;type msg, get Y or N answer, skip if N.
YORNIN:	JSR DDTTYPE		;type msg pointed to by TAC
	PUSHJ P,CTGETC		;look for typein.
	 JRST .-1		;none, keep looking
	PUSHJ P,CTPUTU		;make the char upper case and echo it with CRLF
	CAIE TAC,"Y"		;what was answer?
	AOS (P)			;skip on No
	POPJ P,			;direct on Yes
>;IFKL10

;CALL CORUUO ZERCOR UCORE CORCSO CORCS3 CORCSL CORCS2 CORXOK CORYOK RUNCOR

SUBTTL	CORE UUO

COMMENT $

CALL:	MOVEI AC,<HIGHEST RELATIVE ADDRESS DESIRED>
	CORE AC,
	<ERROR RETURN: CAN'T ASSIGN CORE>
	OK RETURN.  JOB MAY HAVE BEEN SHUFFLED OR SWAPPED.

The number of 1K blocks that a job may have is returned in the AC.
If called with AC containing zero, then the core allocation is not
changed and the error return is taken with AC returing the number of
free blocks.

CORUUO is called for the CORE UUO, and by REMAP and CORE2 UUOs.
For the CORE2 UUO, J will be setup to the job number of the upper
that's being affected.  Only in the case of the CORE2 UUO is there
the possibility that the job involved has no core assigned prior to
the UUO.

UCORE is called by CORUUO and by BUFCLC (always at UUO level).

RUNCOR is called at UUO level (monitor job) for SAVGET.

$


↑CORUUO:JUMPE TAC,ZERCOR	;IS ARGUMENT ZERO?
	AOS (P)			;ASSUME SUCCESS RETURN.
	PUSHJ P,UCORE		;DO IT.  (CORE1 WILL FORCE UNLOCK)
	SOS (P)			;BAD ASSUMPTION. FAILURE RETURN.
ZERCOR:	MOVE TAC,USRMAX		;GET CURRENT FREE SPACE.
	CAMLE TAC,SWAPLIMIT	;MORE THERE THAN HE CAN HAVE?
	MOVE TAC,SWAPLIMIT	;YES. TELL HIM MAX WE'LL ALLOW.
	ASH TAC,-=10		;IN 1 K BLOCKS (KEEP IT THE OLD WAY)
	JRST STOTAC		;RETURN USRMAX TO USER

;(HERE FROM BUFCLC WITH TAC←DESIRED JOBREL, TO EXPAND CORE FOR IO BUFFERS)
↑UCORE:	IORI TAC,1777		;ROUND UP TO A 1K BOUNDARY.
	MOVE TAC1,JBTSTS(J)	;GET JOB STATUS
	TLNN TAC1,JSEG		;AND SKIP IF THIS IS AN UPPER.
	JRST CORCS2		;NOT AN UPPER.
	PUSH P,J		;SAVE UPPER'S JOB NUMBER.
	MOVEI J,JOBN-1		;LOOK THRU ALL JOBS...
CORCSO:	LDB TAC1,PSEGN		;DOES THIS GUY POINT TO ME?
	CAME TAC1,(P)		;SKIP IF A USER OF THIS UPPER.
	JRST CORCSL		;NO.
	MOVE TAC1,J		;TAC1 ← JOB NUMBER OF THIS LOWER.
	PUSHJ P,CORSGT		;GET THE SIZE OF THIS LOWER INTO TAC1
	ADDI TAC1,1(TAC)	;LOWER SIZE + MY REQUEST SIZE.
CORCS3:	CAMG TAC1,SWAPLIMIT	;SKIP IF TOO BIG TO SWAP
	CAMLE TAC1,USRMAX	;SKIP UNLESS TOO BIG TO FIT IN CORE
	JRST .+2		;TOO BIG
	JRST CORCSL		;NOT TOO BIG. CHECK OTHER LOWERS.
	POP P,J			;THIS LOWER AND ME WONT FIT
	POPJ P,			;GIVE THE ERROR RETURN.

CORCSL:	SOJG J,CORCSO		;CONTINUE SCAN THRU ALL JOBS.
	POP P,J			;RESTORE J
	JRST CORXOK		;SO FAR, SO GOOD.

CORCS2:	LDB TAC1,PSEGN		;NOT A SEGMENT. HAS IT AN UPPER?
	SKIPE DAT,TAC1		;SKIP IF NO UPPER. GET NUMBER IN DAT
	PUSHJ P,CORSGT		;GET SIZE OF UPPER IN TAC1.
	ADDI TAC1,1(TAC)	;UPPER'S SIZE + THIS REQUEST.
	CAMG TAC1,SWAPLIMIT	;IS COMBINATION TOO BIG?
	CAMLE TAC1,USRMAX	;DOES IT FIT?
	POPJ P,			;NOPE.
CORXOK:	PUSH P,TAC		;SAVE SIZE WE WANT TO BE.
	PUSH P,UUO		;SAVE
	PUSH P,J		;SAVE J IF THIS IS A SEGMENT.
	PUSHJ P,IOWAIT		;WAIT FOR ALL IO TO STOP.
	JRST .+2
CORYOK:	PUSHJ P,WSCHED
	PUSHJ P,ANYACT		;MAKE SURE WE CAN BE MOVED.
	JRST CORYOK		;NO. WAIT UNTIL WE CAN.
	POP P,J			;RESTORE J
	POP P,UUO
	POP P,TAC		;HIGHEST REL. LOCATION DESIRED
	MOVEI TAC1,CORE0	;CALL CORE0 IF THERE'S NO CORE ALREADY
	SKIPE JBTPAG(J)		;SKIP IF THERE IS NO OLD CORE ASSIGNMENT
↑RUNCOR:MOVEI TAC1,CORE1	;CALL CORE1 IF THERE'S CORE ALREADY.
	AOS (P)			;SET SKIP RETURN.
	PUSHJ P,(TAC1)		;REASSIGN CORE, OR GET NEW CORE ON DISK
	SOS (P)			;FAILURE RETURN.
	PUSHJ P,WSCHED		;IN CASE CORE IS NOW ON DISK, STOP JOB
	MOVE TAC1,JBTSTS(J)
	TLNE TAC1,JSEG		;SKIP IF THIS IS A LOWER.
	PUSHJ P,UAPPLY		;CONTINUE SPACWAR FOR ALL LOWERS
	 PUSHJ P,SPWCNT		;(ARG TO UAPPLY) CONTINUE SPACEWAR FOR LOWER
	POPJ P,
;SPWCNT

↑SPWCNT:			;CONTINUE A SPW JOB
	SKIPN JBTST2(J)		;IS THERE A SPW JOB HERE??
	POPJ P,			;NO.
	MOVSI TAC,SPWST1!SPWST2	;CLEAR SUSPENSION STATUS
	ANDCAM TAC,JBTST2(J)
	POPJ P,
;ANYACT ANYAC1 ANYA1A ANYAC2 ANYAC3 ANYA3A ANYAC4 ANYAC5 ANY ANY2 ANY2A ANY7 ANY7A ANY7B ANYHCC

SUBTTL	ANYACT	ROUTINE TO TEST FOR ANY ACTIVE DEVICES
COMMENT  $
CALLING
	MOVE J,JOB NUMBER
	PUSHJ P,ANYACT
	<HERE IF DEVICES ACTIVE>
	<HERE IF NO DEVICE IS ACTIVE, EXCEPT POSSIBLY TTY>
$

↑ANYACT:MOVE UCHN,JBTSTS(J)	;GET JOB STATUS
	TLNN UCHN,JSEG		;SKIP IF THIS IS AN UPPER
	JRST ANYAC3		;THIS IS A LOWER
	PUSH P,PROG		;SAVE VITAL DATA.
	PUSH P,J		;SAVE THIS JOB NUMBER.
	AOS -2(P)		;ASSUME SUCCESS RETURN.
	MOVEI J,JOBN-1		;SEARCH THRU ALL JOBS.
ANYAC1:	LDB UCHN,PSEGN		;LOOKING FOR LOWERS THAT POINT HERE
	CAME UCHN,(P)		;DOES THIS POINT TO ME.
ANYA1A:	SOJG J,ANYAC1		;NO. DECREMENT J AND LOOP
	JUMPLE J,ANYAC2		;JUMP IF WE HAVE EXHAUSTED THE LOOP
	PUSHJ P,ANYAC3		;CALL ROUTINE FOR A LOWER SEGMENT
	SOSA -2(P)		;CAN'T MOVE THIS LOWER.  SET NO-SKIP
	JRST ANYA1A		;THIS LOWER DOESN'T CARE IF WE MOVE
ANYAC2:	POP P,J
	POP P,PROG
	POPJ P,

;HERE FOR A LOWER SEGMENT ONLY. 

ANYAC3:	SKIPN JBTPAG(J)		;ANY CORE THERE?
	JRST CPOPJ1		;NO CORE MEANS NO IO ACTIVE.
	SKIPN SPWGO(J)		;IS A P1 SPACEWAR JOB RUNNING?
	JRST ANYAC4		;NO SPACEWAR WORRIES.
	MOVE IOS,JBTST2(J)
	TLC IOS,SPWST1!SPWST2
	TLCN IOS,SPWST1!SPWST2
	JRST ANYA3A		;SPW IS SUSPENDED.
	MOVSI IOS,SPWSUS	;NO. MARK IT FOR SUSPENSION
	TDNN IOS,JBTST2(J)	;SKIP IF SUSPENSION REQUEST SET ALREADY.
	IORM IOS,JBTST2(J)	;SET THE BIT THAT REQUESTS SPW SUSPENSION
	POPJ P,			;CAN'T MOVE JOB UNTIL SPACEWAR IS SUSPENDED

ANYA3A:
ANYAC4:	SKIPN JBTIIP(J)		;INTERRUPT IN PROGRESS?
	SKIPE JBTGLU(J)		;NO.  IS SOMEONE GLUEING HIM?
	POPJ P,			;(JBTGLU OR INTIIP) FAKE ACTIVE DEVICE.
	AOS (P)			;ASSUME SUCCESS (IT DOES HAPPEN SOMETIMES)
	PUSH P,TAC		;IMPORTANT THAT WE SAVE TAC!
	PUSHJ P,ANYAC5
	SOS -1(P)
	JRST TPOPJ		;RESTORE TAC AND SKIP OR NOT

ANYAC5:	PUSHJ P,MAPSET
	CAMN J,JOB		;IS THIS THE CURRENT JOB
	PUSHJ P,S2U		;YES.  COPY USRDAT TO JOBDAT.
	MOVEI IOS,IOACT		;IO DEVICE ACTIVE BIT
	XCTR XR,[SKIPGE AC2,JOBHCU] ;AC2←NUMBER OF USER IO CHANNELS IN USE
	MOVNI AC2,JOBJDA-JOBHCU	;C(JOBHCU) POINTS TO SAVGET DDB
	CAILE AC2,17		;IS HIGHEST CHANNEL LEGAL?
	JRST ANYHCC		;JOBHCU IS CLOBBERED.
	MOVSI TAC1,DVTTY	;DEVICE IS A TTY BIT
ANY:	XCTR XR,[HRRZ DDB,JOBJDA(AC2)] ;IS A DEVICE ASSIGNED TO THIS CHANNEL?
	JUMPE DDB,ANY2		;NO.
	CAIL DDB,CHKBEG		;OK IF IN LOW SYSTEM CORE
	CAML DDB,SYSTOP		;NOT OK IF IN CHECKSUMMED SYSTEM
	CAML DDB,FSTOP		;OK IF IN FS
	JRST ANY7
	TDNE IOS,@DEVSPT(DDB)	;YES, IS IT ACTIVE?
	TDNE TAC1,DEVMOD(DDB)	;YES.  SKIP IF IS NOT A TTY.
	JRST ANY2
	POPJ P,

ANY2:	SOJGE AC2,ANY		;THIS CHANNEL IS OK.
	SKIPA UCHN,JBTIOP(J)	;GET THE JBTPDL (IF ANY) AND SKIP.
ANY2A:	ADD UCHN,[2,,2]		;ADVANCE TO NEXT DDB
	JUMPGE UCHN,CPOPJ1 	;JUMP IF IOPDL EXHAUSTED.
	SKIPN DDB,(UCHN)	;GET DDB POINTER
	JRST ANY2A		;IGNORE ONES THAT AREN'T THERE
	TDNE IOS,@DEVSPT(DDB)	;IOACT ON?
	TDNE TAC1,DEVMOD(DDB)	;YES, TTY?
	JRST ANY2A		;TTY OR NOT IOACT.
	POPJ P, 		;ACTIVE IO

ANY7:	PUSHACS			;DDB ADDRESS IS OUT OF BOUNDS.
	XCTR XW,[SETZM JOBJDA(AC2)] ;BLAST ILLEGAL DDB POINTER
	SKIPGE AC2
	XCTR XW,[SETZM JOBJDA]	;IN CASE IT WAS SAVGET, ZERO CHANNEL 0
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / ANY7: ILLEGAL DDB ADDRESS = /
	HRRZ TAC,DDB-17(P)	;PICK UP ADDRESS
	PUSHJ P,DISLOC		;TYPE ADDRESS IN OCTAL
	PUSHJ P,DISMES
	ASCIZ /;  USER IO CHANNEL /
	SKIPGE TAC,AC2-17(P)
	JRST ANY7A
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	JRST ANY7B

ANY7A:	PUSHJ P,DISMES
	ASCIZ / SAVGET
/
ANY7B:	POPACS
	JRST ANY2

ANYHCC:	PUSHACS	
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / JOBHCU CLOBBERED AT ANYACT. JOBHCU = /
	MOVE TAC,AC2-17(P)
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	POPACS
	XCTR XW,[SETZM JOBHCU]	;SET ONLY USER CHANNEL 0 IN USE.
	XCTR XW,[SETZM JOBJDA]	;CLEAR USER CHANNEL 0.
	JRST CPOPJ1		;FAKE SUCCESS RETURN.
;CORE0 CORE0B CORE0K

SUBTTL	CORE0 CORE0K

COMMENT $

CORE0 is called by the CORE command or for the initial core
assignment of just a job data area for the RUN command, etc.  Devices
may be active, or the job may have no previous core.  When CORE0 is
called for a job that either has no core or is swapped out, the new
"core" assigned will be swapped out.  If IMGOUT is zero (i.e., we are
assigning new core where there was none before) then the swapper will
clear the job data area (CLRJB1) and clear JOBSA.

CALL--	MOVE TAC,HIGHEST LEGAL ADDRESSABLE LOCATION DESIRED
	MOVE J,JOB NUMBER
	PUSHJ P,CORE0
	<ERROR>			;EITHER JOB HAS ACTIVE IO, OR NOT ENOUGH CORE
	<OK>

The success return will be given even if the "core"
assigned is swapped out.  CORE0 does not wait for the core to be
swapped in.

$


↑CORE0:	CAML TAC,SWAPLIMIT	;IS HE BEING TOO GREEDY.
	POPJ P,			;FLUSH THE GREEDY BASTARD
	LDB TAC1,PSEGN
	IOR TAC1,JBTPR2(J)	;Set segment flag if real or peek-poke segment
	CAIL TAC,400000		;SKIP IF HE DOESN'T WANT MORE THAN 128K
	JUMPN TAC1,CPOPJ	;CAN'T HAVE LOWER BIGGER THAN 128K IF HAVE AN UPPER
IFN FTP2,<
IFG XGPNUM,<
	CAME J,XFCJN1		;OUR VERSION OF THE FONT COMPILER JOB NUMBER
	CAMN J,XFCJN		;IS THIS THE FONT COMPILER?
	JRST COREFC		;YES, SPECIAL ROUTINE TO GIVE IT P2 CORE
>;IFG XGPNUM
>;IFN FTP2
	SKIPE JBTPAG(J)		;SKIP IF THERE IS NO CORE ASSIGNED IN CORE
	JRST CORE0A		;JOB HAS CORE IN CORE.
	MOVSI TAC1,SWP		;IS THERE CORE ON THE DISK?
	TDNN TAC1,JBTSTS(J)
	DPB TAC1,IMGOUT		;NO CORE ON THE DISK.  ZERO IMGOUT.
	IORM TAC1,JBTSTS(J)	;MARK CORE AS SWAPPED OUT (IF ZERO CORE)
	JUMPE TAC,CORE0B	;JUMP IF REQUESTING NO CORE.
	IORI TAC,777
	ADDI TAC,1
	LSH TAC,-9		;CONVERT CORE REQUEST TO PAGE COUNT
	JRST CORE0K

;ENTER AT CORE0K TO ADJUST CORE IMAGE SIZE WHILE JOB IS ON DISK.
;(THIS IS CALLED FROM THE COMMAND DECODER TO SHRINK BEFORE COMAND)

CORE0B:	ANDCAM TAC1,JBTSTS(J)	;REQUESTING NO CORE.  CLEAR "CORE ON DISK" BIT.
↑CORE0K:
PRINTX HERE'S AN EVEN-PAGE CROCK!
	TRNE TAC,1
	ADDI TAC,1
	DPB TAC,IMGIN		;STORE NEW CORE IMAGE BLOCK SIZE (IN PAGES)

IFN FTSTAT,<
	PUSH P,TAC
	LSH TAC,6
	TRO TAC,CSZSTA
	PUSHJ P,STAPUT
	POP P,TAC
>;IFN FTSTAT

	SETZM SWPCNT		;WAKE UP SWAPPER NEXT TICK
	LDB TAC1,IMGOUT		;SIZE ON DISK (PAGES)
	CAMGE TAC,TAC1		;IS NEW SIZE LESS THAN AMOUNT ON DISK?
	DPB TAC,IMGOUT		;YES, REPLACE DISK SIZE
	JRST CPOPJ1		;GIVE SKIP RETURN
;CORE0A CORE1 CORE1Z COR1ZG COSUPA COR1ZF COR1ZA COR1ZE

COMMENT $

CORE1 is called from UCORE (CORE, CORE2, REMAP UUOs, and BUFCLC), and
from RUNCOR when the RUN command reassigns the proper amount of core
after reading the retrieval to see how big the file is.  The job must
already have core assigned and no active devices.  CORGET is called
to get new core if the job is expanding.

$

CORE0A:	PUSHJ P,ANYACT		;(HERE FROM CORE0)  ANY ACTIVE DEVICE?
	POPJ P,			;YES, CANNOT ASSIGN CORE
↑CORE1:
IFN FTP2,<
IFG XGPNUM,<
	CAME J,XFCJN1		;OUR VERSION OF THE FONT COMPILER JOB NUMBER
	CAMN J,XFCJN		;IS THIS THE FONT COMPILER?
	JRST COREFC		;YES, SPECIAL ROUTINE TO GIVE IT P2 CORE
>;IFG XGPNUM
>;IFN FTP2
	ANDI TAC,-1		;LOOK AT RIGHT HALF ONLY.
	CAMGE TAC,USRMAX	;IS THIS TOO MUCH?
	CAML TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ P,			;NO
	LDB TAC1,PSEGN
	IOR TAC1,JBTPR2(J)	;Set segment flag if real or peek-poke segment
	CAIL TAC,400000		;SKIP IF HE DOESN'T WANT MORE THAN 128K
	JUMPN TAC1,CPOPJ	;CAN'T HAVE LOWER BIGGER THAN 128K IF HAVE AN UPPER
IFN FTSTAT,<
	MOVE PROG,JBTPAG(J)	;SAVE FOR COMPARISON AT DIDLE
>;IFN FTSTAT
	MOVE DSER,JBTSTS(J)
	TRNE DSER,JLOCK
	PUSHJ P,UNLOCK		;RELEASE LOCKED CORE
	ADDI TAC,1		;CONVERT REQUEST TO WORD COUNT
	LSH TAC,-9		;CONVERT REQUEST TO PAGES
	JUMPE TAC,CORE1Z	;JUMP IF DESIRED ASSIGNMENT IS ZERO
	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES OF OLD ASSIGNMENT.
	CAIN TAC,(AC1)		;IF HE IS THE SAME
	JRST DIDLEA		;LEAVE NOW
	CAILE TAC,(AC1)		;SKIP IF HE IS SHRINKING
	JRST CORG1		;LET HIM EXPAND
	SUBI AC1,(TAC)		;AC1←NUMBER OF PAGES TO GIVE BACK
	PUSHJ P,ZMAPL		;CLEAR OUT THESE PAGE MAP ENTRIES
	 PUSHJ P,COR1ZA		;ALSO CLEAR CORTAB AND FIX FREE COUNTS
	HRLM TAC,JBTPAG(J)	;UPDATE SIZE OF JOB IN PAGES
	JRST DIDLEA

CORE1Z:	HLRZ AC1,JBTPAG(J)
	PUSHJ P,SMAPL		;LOOP THROUGH EXISTING PAGE MAP ENTRIES
	 PUSHJ P,COR1ZA		;ZEROING MAP AND CORTAB ENTRIES
	HRRZ AC1,JBTPAG(J)
	JUMPN AC1,COR1ZF
COR1ZG:	SETZM JBTPAG(J)
IFKL10,<PUSHJ P,COSUPA		;Suppress saving ACs in non-ex core now
>;IFKL10
	AOS NCORCALLS
	JRST DIDLE2

IFKL10,<
;Here when have just flushed user's core.
;Make sure same user's ACs don't get stored by ACTOSH later (in EXEC shadow!).
;Clobbers TAC.
COSUPA:	LDB TAC,PAGJOB		;Is this the job that the map is set up for?
	CAME TAC,J		;Skip if it is
	POPJ P,
	MOVSI TAC,SAC2SH	;Bit checked by ACTOSH
	IORM TAC,PAGREG		;Suppress saving of ACs in shadow next APRMAP call
	POPJ P,			;  since the USER shadow area no longer exists!
>;IFKL10

COR1ZF:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JBTPAG RIGHT HALF NON-ZERO AT CORE1Z
/
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	POPACS
	JRST COR1ZG

COR1ZA:	MOVEI DSER,(AC2)
IFN FTCORBUG,<
	LDB AC2,COREP		;GET CURRENT CORTAB ENTRY
	CAIE AC2,(J)
	PUSHJ P,COR1ZE
>;IFN FTCORBUG
	MOVEI AC2,0		;ZERO PAGE MAP ENTRY
	DPB AC2,COREP		;AND CORTAB ENTRY
	CAMGE DSER,FSLIMIT
	AOSA LOFREE
	AOSA HIFREE
	POPJ P,
	SOS HIUSED
	SOS JBTPAG(J)
	POPJ P,

IFN FTCORBUG,<
COR1ZE:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CORTAB ENTRY AND J DISAGREE AT COR1ZA
CORTAB = /
	MOVE TAC,AC2-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /  J = /
	MOVE TAC,J-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	POPACS
	POPJ P,
>;IFN FTCORBUG
;COREFC CORFC0 FCGOTM CORFC1 FCZERO FCZER1 CNEWFC CNEWF1 XVDMPW POPDBJ

IFN FTP2,<			;Whole page
IFG XGPNUM,<			;Whole page

COMMENT ⊗
When the font compiler job (the one whose job number is stored in XFCJN)
asks to allocate or deallocate core, it comes here.  Any allocation other
than zero gives it all of the available P2 memory.  A request for zero
core clears the map.  The JLOCK bit is set in the job's JBTSTS whenever
it has core, although its core is NOT included in LOKTOT.  Also, since
all of P2 memory is always marked as in use by the system, this routine
does not change CORTAB, HIFREE, etc.  Beware: don't execute any bug trap
which checks the CORTAB use field for this job's core.
⊗

COREFC:	SKIPN XFCJN1		;DO WE ALREADY KNOW ABOUT A FC JOB?
	MOVEM J,XFCJN1		;NO, THIS IS A NEW ONE
	CAMN J,XFCJN1		;J MUST AGREE WITH BOTH SAVED NUMBERS NOW
	CAME J,XFCJN
	JRST CNEWFC		;NO, SOMEONE IS TRYING TO MAKE A 2ND ONE
CORFC0:	MOVE PROG,JBTPAG(J)	;SAVE FOR COMPARISON AT DIDLE, also used at CORFC1
	SKIPE JBTMAP(J)		;IS THERE A MAP ALREADY?
	JRST FCGOTM		;YES
	PUSH P,AC1
	PUSHJ P,GETMAP		;TRY TO GET A PAGE MAP FOR THIS JOB
	 JRST POPAJ		;CAN'T DO IT
	MOVEM AC1,JBTMAP(J)
	POP P,AC1
FCGOTM:	JUMPE TAC,FCZERO	;JUMP IF FC JOB GOING AWAY
IFE FTMPP2,<
	MOVE UCHN,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE UCHN,AC1		;SAVE AC1
	PUSHJ P,JOBMAP		;GET UPMP INTO EVM
	 POPJ P,
	EXCH UCHN,AC1		;EXEC VIRTUAL PAGE IN UCHN, RESTORE AC1
>;IFN FTMPP2
	LSH UCHN,9
	MOVE TAC1,UCHN		;NEXT ADDRESS TO ASSIGN
	MOVSI UCHN,JWP
	TDNE UCHN,JBTSTS(J)
	SKIPA UCHN,[PREAD,,]
	MOVSI UCHN,PWRT
	MOVEI AC1,P2SIZE	;GET NUMBER OF PAGES AVAILABLE FOR FC
	CAMGE AC1,P2SPAG	;	(DRD: CHECK THAT P2SPAG IS
	POPJ P,			;	WITHIN P2SIZE)
	SUB AC1,P2SPAG		; = P2 PHYS MEMORY SIZE MINUS P2SYS SIZE
	HRLZM AC1,JBTPAG(J)	;NEW FC SIZE
	MOVEI DSER,P2BASE	;FIRST PHYSICAL PAGE NUMBER TO ASSIGN
	ADD DSER,P2SPAG		; = P2 PHYS MEMORY START PLUS P2SYS SIZE
CORFC1:	MOVEM UCHN,(TAC1)	;STORE ACCESS BITS
	HRRM DSER,(TAC1)	;STORE PHYSICAL PAGE NUMBER IN MAP
	ADDI DSER,1
	ADDI TAC1,1		;BUMP PAGE TABLE ADDRESS
	SOJG AC1,CORFC1		;ANY MORE PAGES TO ASSIGN?
	MOVEI TAC1,JLOCK
	IORM TAC1,JBTSTS(J)
	TLNE PROG,-1		;DID JOB HAVE CORE ALREADY?
	JRST DIDLEA		;YES, ALL DONE
	PUSHJ P,MAPSET		;SET UP USER MAP FOR THIS JOB
	XCTR XW,[SETZM JOBSA]	;CLEAR JOB DATA AREA
	XCTR XW,[SETZM JOBPRT]	;FIRST LOCATION PROTECTED FROM USER
	MOVE TAC,[JOBPRT,,JOBPR1]
	XCTR XBLTRW,[BLT TAC,JOBPFI]
	XCTR XW,[SETZM JOBENB]	;ALSO CLEAR APR ENABLE WORD
	XCTR XW,[SETZM JOBINT]	;AND MOORER RELOCATER
	JRST DIDLEA

FCZERO:	HLRZ AC1,JBTPAG(J)
	MOVEI TAC1,JLOCK
	ANDCAM TAC1,JBTSTS(J)
	PUSHJ P,SMAPL		;LOOP THROUGH EXISTING PAGE MAP ENTRIES
	 PUSHJ P,FCZER1		;ZEROING MAP
	JRST COR1ZG		;Re-join normal-job code

FCZER1:	MOVEI DSER,(AC2)
	MOVEI AC2,0		;ZERO PAGE MAP ENTRY
	POPJ P,

CNEWFC:	JUMPN TAC,CNEWF1	;MUST DO THE HARD THING IF NONZERO CORE REQUEST
	CAME J,XFCJN1		;IS OLD JOB TRYING TO FLUSH?
	JRST CNEWF1		;NO, NEW JOB FLUSHING.  WEIRD.
	PUSH P,XFCJN		;YES.  WE CAN JUST TELL OURSELF ABOUT THE NEW JOB
	POP P,XFCJN1		;(I COULD PROBABLY FIND AN AC BUT I'M LAZY)
	PUSHJ P,XVDMPW		;MAYBE WAKE UP ANY WAITING XGP/VRN DUMP MODE USER
	JRST CORFC0		;THEN GO AHEAD AND FLUSH THE OLD ONE

CNEWF1:	PUSHACS
	PUSH P,XFCJN		;SAVE NEW NUMBER
	MOVE J,XFCJN1		;GET OLD FC JOB NUMBER
	MOVEM J,XFCJN		;MAKE IT LOOK CONSISTENT
	SETZM JOBNAM(J)		;MAKE IT NOT BE THE FC'S NAME
	MOVEI TAC,0
	PUSHJ P,CORE0		;FLUSH OLD JOB'S CORE
	 JFCL
	POP P,XFCJN
	MOVE TAC,XFCJN		;GET NEW NUMBER
	MOVEM TAC,XFCJN1	;WE NOW KNOW ABOUT IT
	PUSHJ P,STOP1		;STOP -- RETURN ONLY IF NOT CURRENT JOB OR NOT UUO
	PUSHJ P,TTYSRC		;GET (DETACHED) TTY DDB OF OLD FC
	PUSHJ P,KILALL		;RELEASE ALL ITS DDBS EXCEPT TTY DDB
	PUSHJ P,JOBKL1		;KILL THIS JOB ALTOGETHER
	PUSHJ P,XVDMPW		;MAYBE WAKE UP ANY WAITING XGP/VRN DUMP MODE USER
	POPACS
	CAME J,XFCJN		;DID WE GET HERE FROM OLD FC JOB REQUEST AT CLK LVL?
	POPJ P,			;YES, GIVE IT ERROR RETURN
	JRST CORFC0		;GIVE FC JOB ITS CORE

;Here after possibly doing away with (last version of) the font compiler.
;If there is a VRN/XGP dump mode user waiting for FC to go away, wake that user.
XVDMPW:	SKIPN XFCJN
	SKIPE XFCJN1
	POPJ P,			;SOME FONT COMPILER STILL EXISTS
	PUSH P,DDB		;PRESERVE ALL ACS
	SKIPN DDB,P2DDB
	JRST POPDBJ
	PUSH P,TAC
	PUSH P,IOS
	MOVE IOS,@DEVSPT(DDB)	;NEED IOS TO GET IO MODE
	LDB TAC,PIOMOD
	POP P,IOS
	CAIL TAC,SD		;A DUMP MODE?
	PUSHJ P,STTIOD		;YES, WAKE UP JOB QUICKLY
	POP P,TAC
POPDBJ:	POP P,DDB
	POPJ P,

>;IFG XGPNUM	;Whole page
>;IFN FTP2	;Whole page
;CORHGT CORGET CORG1 CORG2 CORGT0 CORGT1 CORGT2 CORGT3 CORGT4 CORGTA GETPAG GETNPG GETPG1 GETPG3 GETPG2 GETPG4

COMMENT $

CORGET assigns core.  Called when a job has no core assigned (from the swapper,
or after CORE1 sees a request to expand).  If the new request cannot be granted,
the job is marked for swapout by calling XPAND.

CORHGT is called only by the swapper to get core in high half for swapin.

Pages are allocated starting at the highest available address in memory, and
proceeding downward.  These are assigned to the job starting at the highest page
requested, going down to the lowest new page needed.  This has the effect of
(a) keeping the lowest physical pages available for FS expansion, and (b) trying
to make consecutive virtual pages occupy consecutive physical pages, which
reduces disk operations on the F2.

$

↑CORHGT:CAMGE TAC,USRMAX	;IS THIS TOO MUCH?
	CAML TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ P,
	LDB TAC1,PSEGN
	IOR TAC1,JBTPR2(J)	;Set segment flag if real or peek-poke segment
	CAIL TAC,400000		;SKIP IF HE DOESN'T WANT MORE THAN 128K
	JUMPN TAC1,CPOPJ	;CAN'T HAVE LOWER BIGGER THAN 128K IF HAVE AN UPPER
	ADDI TAC,1
	LSH TAC,-9		;CONVERT REQUEST TO PAGE COUNT
	CAMLE TAC,HIFREE	;IS THERE ENOUGH HIGH SPACE AVAILABLE?
	JRST DIDLE4		;NO, LOSE
	MOVE DSER,FSLIMIT	;YES, SET LAST POSSIBLE PAGE TO ASSIGN
	JRST CORG2

↑CORGET:CAMGE TAC,USRMAX	;IS THIS TOO MUCH?
	CAML TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ P,
	LDB TAC1,PSEGN
	IOR TAC1,JBTPR2(J)	;Set segment flag if real or peek-poke segment
	CAIL TAC,400000		;SKIP IF HE DOESN'T WANT MORE THAN 128K
	JUMPN TAC1,CPOPJ	;CAN'T HAVE LOWER BIGGER THAN 128K IF HAVE AN UPPER
	ADDI TAC,1
	LSH TAC,-9		;CONVERT REQUEST TO PAGE COUNT
CORG1:	MOVE DSER,FSPAG		;SET DSER TO LAST ALLOWABLE PAGE TO ASSIGN
CORG2:	AOS NCORCALLS
IFN FTSTAT,<
	MOVE PROG,JBTPAG(J)	;SAVE FOR COMPARISON AT DIDLE
>;IFN FTSTAT
	HLRZ AC1,JBTPAG(J)
	SUBM TAC,AC1		;AMOUNT TO INCREASE CORE ASSIGNMENT BY
	MOVE TAC1,LOFREE
	ADD TAC1,HIFREE
	CAMLE AC1,TAC1		;WILL IT FIT IN CORE NOW?
	JRST CORGTA		;NO
	HRLM TAC,JBTPAG(J)	;Save new job size
	MOVEI TAC1,-1(TAC)	;Highest new page to assign
IFE FTMPP2,<
	MOVE UCHN,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE UCHN,AC1		;SAVE AC1
	PUSHJ P,JOBMAP		;GET UPMP INTO EVM
	 JFCL
	EXCH UCHN,AC1		;EXEC VIRTUAL PAGE IN UCHN, RESTORE AC1
>;IFN FTMPP2
	LSH UCHN,9
	ADD TAC1,UCHN		;NEXT ADDRESS TO ASSIGN
	MOVE UCHN,JBTSTS(J)
	TLNE UCHN,SWP		;IS THIS CALL FROM THE SWAPPER
	JRST CORGT0		;YES, PUT IN WRITE PROTECT BIT LATER
	MOVSI UCHN,JWP
	TDNE UCHN,JBTSTS(J)
	SKIPA UCHN,[PREAD,,]
CORGT0:	MOVSI UCHN,PWRT

;TAC1 HAS THE JBTMAP ADDRESS TO ASSIGN NEXT, AC1 IS THE NUMBER OF REMAINING
;PAGES TO ASSIGN, UCHN CONTAINS THE PAGE MAP ENTRY TO STORE (LH)

	PUSH P,DSER		;SAVE LAST POSSIBLE PAGE TO ASSIGN
	MOVEI DSER,GOODPG-1	;START SCAN AT END OF USER CORE
CORGT1:	LDB TAC,COREP		;GET CORTAB ENTRY FOR THIS PAGE
	JUMPE TAC,CORGT3	;JUMP IF THIS PAGE IS AVAILABLE
CORGT2:	CAMLE DSER,(P)		;WAS THAT THE LAST POSSIBLE PAGE?
	SOJA DSER,CORGT1	;NO, LOOK SOME MORE
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /LOFREE AND HIFREE INCONSISTENT AT CORGET.  GET A WIZARD.
/
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCALL
	JRST AUTOLOAD

CORGT3:	DPB J,COREP		;ASSIGN IT IN CORTAB
	CAMGE DSER,FSLIMIT
	SOSA LOFREE
	SOSA HIFREE
	JRST CORGT4
	AOS HIUSED
	AOS JBTPAG(J)		;ONE MORE HIGH PAGE IN THIS JOB
CORGT4:	MOVEM UCHN,(TAC1)	;STORE ACCESS BITS
	HRRM DSER,(TAC1)	;STORE PHYSICAL PAGE NUMBER IN MAP
	SUBI TAC1,1		;Decrement page table address
	SOJG AC1,CORGT2		;ANY MORE PAGES TO ASSIGN?
	POP P,(P)		;FLUSH SCAN LOW LIMIT CELL
	JRST DIDLEA

CORGTA:	MOVE UCHN,JBTSTS(J)
	TLNE UCHN,SWP		;SKIP UNLESS CALLED FROM SWAPPER
	JRST DIDLE4		;SWAPPER GETS FAILURE (NO SKIP) RETURN
	PUSHJ P,XPAND		;MARK THIS JOB AS EXPANDING.  WILL BE SWAPPED OUT
	JRST DIDLEA

IFN FTDMDP,<
↑GETPAG:PUSH P,AC2
	MOVEI AC2,1		;GET ONE PAGE
	PUSHJ P,GETNPG
	 CAI			;INSTRUCTION FOR GETNPG TO EXECUTE
	 CAIA			;NO CORE RETURN
	AOS -1(P)		;WIN RETURN
	POP P,AC2
	POPJ P,

↑GETNPG:MOVE DSER,HIFREE
	ADD DSER,LOFREE
	CAMLE AC2,DSER
	JRST CPOPJ1		;GIVE NO CORE RETURN (SKIP ARG)
	MOVEI DSER,GOODPG-1	;START SCAN AT END OF USER CORE
GETPG1:	LDB TAC,COREP		;GET CORTAB ENTRY FOR THIS PAGE
	JUMPE TAC,GETPG2	;JUMP IF THIS PAGE IS AVAILABLE
	CAMLE DSER,FSPAG	;WAS THAT THE LAST POSSIBLE PAGE?
GETPG3:	SOJA DSER,GETPG1	;NO, LOOK SOME MORE
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /HIFREE-LOFREE AND CORTAB INCONSISTENT AT GETPAG.  GET A WIZARD.
/
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCAL
	JRST AUTOLOAD

GETPG2:	MOVE TAC,[CSTDEF]	;get CST entry default
	MOVEM TAC,CST(DSER)	;INITIALIZE CST ENTRY (CLEAR MODIFICATION BIT)
	DPB J,COREP		;MARK PAGE AS BELONGING TO THIS USER
	CAMGE DSER,FSLIMIT
	SOSA LOFREE
	SOSA HIFREE
	JRST GETPG4
	AOS HIUSED
	AOS JBTPAG(J)
GETPG4:	XCT @(P)		;EXECUTE ARGUMENT
	SOJG AC2,GETPG3		;LOOP AND GET MORE
	JRST CPOPJ2
>;IFN FTDMDP
;DIDLEA DIDLE2 CSTAT1 CSTAT2 DIDL4A DIDL4B DIDL4C DIDLE4 DIDLEX

SUBTTL	DIDDLE

COMMENT $
Call DIDLEA after making core assignment.  DIDLEA skip returns.
[For segments when we get to DIDLEA, either
CORE2 is going to call AUPMAP or FININ will call AUPMAP from FINMST]

Call DIDLE2 to release all core.  Skips.

Call DIDLE4 for failure return and to check CORTAB consistency.
DIDLE4 does not skip.

$

DIDLEA:	MOVE TAC,JBTSTS(J)
	TLNN TAC,JSEG		;SKIP IF THIS IS A SEGMENT
	PUSHJ P,DIDLEX		;ADJUST JOBREL IN USER'S AREA
DIDLE2:	MOVE TAC,JBTSTS(J)	;ENTER HERE TO RELEASE ALL CORE
	TLNN TAC,JSEG
	CAME J,JOB		;IS THIS CURRENT JOB?
	CAIA			;NO, DO NOT ALTER STATE OF MONITOR
NOKL10,<CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON	;CLEAR ARS
>;IFKL10
	AOS (P)			;SET SKIP RETURN.
IFN FTSTAT,<
;PROG=OLD CORE, JBTPAG(J)=NEW CORE
	MOVE TAC,PROG
	XOR TAC,JBTPAG(J)
	TLNN TAC,-1		;CHANGE IN SIZE?
	JRST CSTAT1		;NO CHANGE IN SIZE.
	HLRZ TAC,JBTPAG(J)	;TAC←NEW SIZE
	LSH TAC,6
	IORI TAC,CSZSTA
	PUSHJ P,STAPUT		;SEND SIZE
CSTAT1:	SKIPN TAC,JBTPAG(J)	;REPORT ONLY PROT IF CORE 0
	JRST CSTAT2
	XOR TAC,PROG		;HI PAGE COUNT CHANGE?
	TRNN TAC,-1
	JRST CSTAT2
	MOVEI TAC,HPGSTA	;REPORT HI PAGE CHANGE
	PUSHJ P,STAPUT
	HRRZ TAC,JBTPAG(J)
	PUSHJ P,STAPTT		;REPORT NEW POSITION.
CSTAT2:
>;IFN FTSTAT
IFKL10,<
	MOVSI TAC,CSHON		;LEAVE ONLY THE REASON BITS.  ALLOW CSHSET
	ANDCAM TAC,JBTCSH(J)	;TO TURN THE CACHE ON IF IT'S SUPPOSED TO.
	PUSHJ P,CSHSET
>;IFKL10
	HLRZ TAC,JBTPAG(J)
	HRRZ DSER,JBTPAG(J)
	CAIL TAC,(DSER)		;TOTAL PAGES MUST ALWAYS BE BIGGER THAN HI PAGES
	JRST DIDLE4
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / JBTPAG RH BIGGER THAN LH AT DIDLE4
JBTPAG = /
	MOVE TAC,JBTPAG(J)
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
IFE FTMPP2,<
	MOVE TAC,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	PUSHJ P,JOBMAP
	 JFCL
	MOVEI TAC,(AC1)
>;IFN FTMPP2
	LSH TAC,9
	HRLI TAC,-1000
	MOVEI TAC1,0
	MOVEI AC1,0
DIDL4A:	MOVE AC2,(TAC)
	TLNN AC2,160000		;ANY ACCESS?
DIDL4B:	AOBJN TAC,DIDL4A
	JUMPGE TAC,DIDL4C
	HRRZ AC2,AC2
	CAML AC2,FSLIMIT
	ADDI AC1,1		;COUNT ANOTHER HIGH PAGE
	AOJA TAC1,DIDL4B	;COUNT ANOTHER PAGE

DIDL4C:	HRL AC1,TAC1		;NEW JBTPAG
	MOVEM AC1,JBTPAG(J)
	POPACS

DIDLE4:
IFN FTCORBUG,<	PUSHJ P,CORTCK > ;CHECK FOR CORTAB - PAGE MAP CONSISTENCY
	POPJ P,

DIDLEX:	PUSHJ P,MAPSET
	HLRZ TAC,JBTPAG(J)	;STORE JOBREL OF NEW CORE ASSIGNMENT
	LSH TAC,9
	SUBI TAC,1
	XCTR XW,[HRRZM TAC,JOBREL] ;ALWAYS SET JOB DATA AREA W/PROTECTION
	POPJ P,			;RETURN FROM DIDLEX (THROUGH MAPSET)
;CORCHK CORCH0 CRCH1A CORCH8 CORC8A CRCH8B CORC8C CORCH2 CRCH2E CORCH3 CORTCK CORCKL CORCK1 CORCKN CORCK0 CRCK0A CORCK2 CORCKZ CORCKC CORCKD CORCKE CORCKX

;CORCHK AND CORTCK  -- CHECK CORTAL AGAINST CORTAB AND CHECK CORTAB AGAINST WORLD
IFN FTCORBUG,<

PRINTX HOW ABOUT TURNING OFF THE FTCORBUG CONDITIONAL

CORCHK:	PUSH P,TAC		;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	PUSH P,AC2
	PUSH P,AC1
	PUSH P,TAC1
	PUSH P,DSER
	SETZB AC1,AC2		;COUNT FREE PAGES IN USER CORE
	MOVE DSER,FSPAG
CORCH0:	CAIL DSER,PHYMEM*2
	JRST CRCH1A
	LDB TAC,COREP
	SKIPE TAC
	AOJA DSER,CORCH0	;BLOCK IS IN USE
	CAMGE DSER,FSLIMIT
	AOSA AC1
	AOS AC2
	AOJA DSER,CORCH0

CRCH1A:	CAMN AC1,LOFREE
	CAME AC2,HIFREE
	CAIA
	JRST CORCH8
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /LOFREE = /
	MOVE TAC,LOFREE
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /SHOULD BE = /
	MOVE TAC,AC1-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /HIFREE = /
	MOVE TAC,HIFREE
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /SHOULD BE = /
	MOVE TAC,AC2-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	POPACS
	MOVEM AC1,LOFREE
	MOVEM AC2,HIFREE
CORCH8:

IFN FTHPSG,<
	MOVE DSER,FHUPAG
	MOVEI AC2,0		;COUNT FREE PAGES IN HIGH CORE.
CORC8A:	CAML DSER,LHUPAG
	JRST CRCH8B
	LDB TAC,COREP
	ADDI DSER,1
	JUMPN TAC,CORC8A
	AOJA AC2,CORC8A		;COUNT A FREE PAGE

CRCH8B:	CAMN AC2,CORHTL
	JRST CORC8C		;RIGHT ANSWER
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CORHTL = /
	MOVE TAC,CORHTL
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /,SHOULD BE = /
	MOVE TAC,AC2-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /;     CALLER'S ADDRESS = /
	HRRZ TAC,-26(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCALL
	POPACS
	MOVEM AC2,CORHTL

CORC8C:
>;FTHPSG

	MOVSI AC1,-JOBN
	MOVEI AC2,0		;COUNT HI PAGES IN USE
CORCH2:	HRRZ TAC,JBTPAG(AC1)
	ADDI AC2,(TAC)
	HLRZ TAC1,JBTPAG(AC1)
	CAILE TAC,(TAC1)
	PUSHJ P,CRCH2E		;MORE HI PAGES THAN TOTAL PAGES
	AOBJN AC1,CORCH2	;LOOK THROUGH ALL JOBS
	CAMN AC2,HIUSED
	JRST CORCH3
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /HIUSED DISAGREES WITH JBTPAGS AT CORCHK
/
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	JRST CORCH3

USRH2E:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JOB HAS MORE HI PAGES THAN TOTAL PAGES AT CORCHK
/
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	POPACS
	POPJ P,

CORCH3:	POP P,DSER
	POP P,TAC1
	POP P,AC1
	POP P,AC2
	POP P,TAC
	POPJ P,

CORTCK:	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,DSER
	PUSH P,J
	PUSH P,TAC
	PUSH P,TAC1

	MOVE J,JOBNM1
CORCKL:	MOVE AC2,JBTSTS(J)
	TLNE AC2,JNA		;IS THERE A JOB HERE?
IFE FTMPP2,<	SKIPN AC2,JBTMAP(J)	> ;YES.  IS IT INCORE?
IFN FTMPP2,<	PUSHJ P,JOBMAP		> ; (I DON'T SEE AC1 USED ANYWHERE!)
	JRST CORCKN		;NO JOB OR NO CORE
IFN FTMPP2,<	MOVEI AC2,(AC1)		> ;SHOULD REALLY RENAME ACS INSTEAD
	LSH AC2,9
	HLRZ TAC1,JBTPAG(J)	;PAGE COUNT
	JUMPE TAC1,CORCKN
	MOVN TAC1,TAC1
	HRL AC2,TAC1		;AOBJN POINTER TO PAGE TABLE
CORCK1:	HRRZ DSER,(AC2)		;PHYSICAL PAGE NUMBER
	LDB AC3,COREP
	CAIE AC3,(J)
	JRST CORCKC		;CORTAB ISN'T MARKED ACCORING TO THIS JBTPAG
	AOBJN AC2,CORCK1	;DECREMENT COUNT OF JOB'S PAGES
CORCKN:	SOJG J,CORCKL		;LOOK THRU ALL JOBS
	MOVE DSER,FSPAG
CORCK0:	CAIL DSER,PHYMEM*2
	JRST CORCKZ		;END. TEST OK.
	LDB J,COREP		;LOOK AT ALL USER STG CORTAB ENTRIES
	JUMPE J,CORCK2		;HOLE. ADVANCE TO NEXT PAGE
	CAMLE J,JOBNM1
	JRST CORCKD		;ILLEGAL BYTE IN CORTAB
IFE FTMPP2,<	SKIPN AC3,JBTMAP(J)	>
IFN FTMPP2,<	PUSHJ P,JOBMAP		>
	JRST CORCKE
IFN FTMPP2,<	MOVEI AC3,(AC1)		>
	LSH AC3,9
	HLRZ TAC1,JBTPAG(J)
	MOVN TAC1,TAC1
	HRLI AC3,(TAC1)
CRCK0A:	HRRZ TAC1,(AC3)
	CAIE TAC1,(DSER)
	AOBJN AC3,CRCK0A
	JUMPGE AC3,CORCKE	;DIDN'T FIND PHYSICAL PAGE IN THIS JOB'S MAP
CORCK2:	AOJA DSER,CORCK0	;LOOK FOR OTHER THINGS.

CORCKZ:	POP P,TAC1
	POP P,TAC
	POP P,J
	POP P,DSER
	POP P,AC3
	POP P,AC2
	POP P,AC1
	JRST CORCHK		;NOW CHECK CORTAL

CORCKC:	JSP TAC1,CORCKX		;BLOCK CLAIMED IN PAGE MAP BUT NOT IN CORTAB
CORCKD:	JSP TAC1,CORCKX		;ILLEGAL VALUE OF CORTAB BYTE
CORCKE:	JSP TAC1,CORCKX		;BLOCK CLAIMED IN CORTAB BUT NOT IN JOB'S MAP

CORCKX:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /LOSSAGE AT CORCHK -- GET A WIZARD.  THE WINNING ENTRY IS /
	HRRZ TAC,TAC1-17(P)
	SUBI TAC,CORCKC+1
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	POPACS
	JRST CORCKZ
>;IFN FTCORBUG
;⊗ CORGBP CORGB1 COREP COREPA CORSGT CORSG1 LOW128

SUBTTL	CORSTG - SET AND CLEAR CORE USE TABLE

LOSYS

;CALL WITH DSER=PAGE NUMBER.  RETURNS TAC=BYTE POINTER FOR LDB/DPB.
↑CORGBP:MOVEI TAC,(DSER)
CORGB1:	ADD TAC,COREPA		;add in byte pointer fields (see below)
	POPJ P,

;COREP is byte pointer to page usage field in CORTAB.
;COREPA is same but used for generating absolute byte ptr without indexing.
↑COREP:	POINT 12,CORTAB(DSER),32 ;CORTAB IS REALLY THE CST
COREPA:	POINT 12,CORTAB,32	 ;used only by CORGB1 above

;CORSGT - COMPUTE SIZE (IN WORDS) OF GIVEN JOB.
;CALL:	MOVE TAC1,<JOB NUMBER>
;	PUSHJ P,CORSGT		;CHANGES ONLY TAC1
;	<RETURNS TAC1=CORE SIZE OF JOB>

↑CORSGT:PUSH P,TAC		;SAVE TAC
	MOVE TAC,JBTSTS(TAC1)	;GET JOB STATUS
	TLNN TAC,SWP		;SKIP IF ON DISK,
	JRST CORSG1		;HE'S IN CORE.
	PUSH P,J
	MOVEI J,(TAC1)
	LDB TAC1,IMGIN
	POP P,J
	LSH TAC1,9		;SHIFT TO MAKE WORDS.
	JRST TPOPJ		;RESTORE TAC AND RETURN.

CORSG1:	HLRZ TAC1,JBTPAG(TAC1)
	LSH TAC1,9
	JRST TPOPJ

;LOW128 - SKIP RETURN IF JOB WHOSE NUMBER IS IN J IS NOT BIGGER THAN 128K
↑LOW128:PUSH P,TAC1
	MOVE TAC1,J		;GET LOWER'S JOB NUMBER
	PUSHJ P,CORSGT		;SET SIZE OF LOWER IN TAC1
	CAIG TAC1,400000
	AOS -1(P)
	POP P,TAC1
	POPJ P,

HISYS
;GETPR GETPR5 GETPR3 GETPR2 GETPR1 GETPR4 GETPR6

SUBTTL	GETPR	GET A JOB'S PROTECTION-RELOCATION

IFE FTP2PAG,<

LOSYS

;GET HERE ONLY FROM APRMAP FOR P2 IN NON-PAGING SYSTEM
↑GETPR:	PUSH P,DAT		;SAVE SOME ACCUMULATORS
	PUSH P,TAC1
	SKIPN TAC,J		;FOR JOB 0,
	JRST GETPR1		;WE SUPPLY A ZERO FOR LASTPR AND FOR DATAO APR,
	MOVE TAC,JBTPAG(J)	;START WITH THE MAIN PART
	LSH TAC,9		;SHIFT TO FORM RELOCATION OF LOWER
	SUB TAC,[1,,0]		;CORRECT THE PROTECTION
PRINTX HERE'S A PLACE THAT KNOWS ABOUT K BOUNDARIES
	ANDCM TAC,[1777,,1777]
	LDB DAT,PSEGN
	JUMPE DAT,GETPR4	;IF NO UPPER SEGMENT, WE ARE DONE
	MOVE TAC1,JBTSTS(DAT)	;HE HAS AN UPPER, IS IT WRITE-PROTECTED?
	TLNE TAC1,JWP
	TLO TAC,1		;YES, SET WRITE-PROTECT BIT
	SKIPN TAC1,JBTPAG(DAT)	;PROT,,RELOC OF UPPER
	JRST GETPR1		;UPPER NOT IN CORE
	LSH TAC1,9
	SUB TAC1,[1,,0]
GETPR5:	HLRZ DAT,JBTPAG(J)	;PROT OF LOWER
	LSH DAT,9
	SUBI DAT,1
	CAIGE DAT,400000	;SKIP IF LOWER IS BIGGER THAN 128K
	JRST GETPR3		;LOWER LE 128K, UPPER STARTS AT 400000
	SUBI TAC1,(DAT)		;FUDGE RELOCATION BY RIGHT AMOUNT
	HRLZ DAT,DAT		;PROT OF LOWER + SIZE OF UPPER GIVES
	ADD TAC1,DAT		;PROT OF UPPER
	JRST GETPR2

GETPR3:	TRC TAC1,400000		;REL OF UPPER (FROM JBTPAG) CORRESP TO 400000
GETPR2:	TLO TAC1,400000
	LSH TAC1,-9
PRINTX HERE'S A PLACE THAT KNOWS ABOUT K BOUNDARIES
	AND TAC1,[776,,776]
	IOR TAC,TAC1		;MERGE TWO RELOCATIONS
GETPR1:	POP P,TAC1
	POP P,DAT
	POPJ P,

GETPR4:	SKIPN TAC1,JBTPR2(J)	;IS DOING PEEK-POKE STUFF?
	JRST GETPR1		;NO
	TRNE TAC1,4		;IS IT GETHI HACK
	JRST GETPR1		;YES.  WE ARE DONE (GETHI USES MAP, NOT PROT-REL)
	TLNE TAC1,1		;IS IT TO BE WRITE PROTECTED?
	TLO TAC,1		;YES
	TRZN TAC1,1		;IS IT TO BE RELATIVE TO HIS CORE IMAGE?
	JRST GETPR5		;NO. 
	PUSH P,TAC		;YES, CHECK TOP OF HIS CORE IMAGE
	HLRZ TAC,TAC1		;PROTECTION HE IS REQUESTING
	IORI TAC,1777		;MAKE IT HONEST
	HLRZ DAT,JBTPAG(J)	;HIS JOB'S PROTECTION
	LSH DAT,9
	SUBI DAT,1(TAC1)	;HOW FAR FROM NEW RELOCATION TO TOP OF CORE IMAGE.
	JUMPL DAT,GETPR6	;NOT IN HIS CORE, HE DOESN'T GET TO HAVE AN UPPER
	CAMLE DAT,TAC		;IS HE REQUESTING TO MUCH?
	MOVE DAT,TAC		;NO, USE WHAT HE GAVE US
	POP P,TAC		;GET BACK LOWERS PROT. RELOC.
	HRL TAC1,DAT		;SET NEW PROT. FOR PR2
	ADDI TAC1,(TAC)		;AND RELOCATE IT
	JRST GETPR5		;AND NOW IT LOOKS LIKE AN UPPER

GETPR6:	POP P,TAC
	TLZ TAC,1
	JRST GETPR1

HISYS

>;IFE FTP2PAG
;RELOCA RELOC1 RELOC4 RELOC2 RELC2A RELOC3 RELOCB RELOC5 RELOCC RELOCD

SUBTTL	RELOCA

;THIS HERE IS A ROUTINE TO ADDRESS CHECK
;A USER ADDRESS. IT MAKES USE OF UPPER SEGMENTS AND
;THE PEEK-POKE FEATURE (JBTPR2).
;CALLING:
;	MOVE J,<NUMBER OF JOB IN QUESTION>
;	MOVE TAC1,<ADDRESS TO CHECK>
;	PUSHJ P,RELOCA
;	<ILLEGAL ADDRESS>
;	<LEGAL ADDRESS>
;THE SIGN BIT OF TAC1 IS SET IF THIS ADDRESS IS WRITE PROTECTED
;FROM THE USER (THIS INCLUDES THE PROTECTED PART FROM 0-JOBPFI).
;AC1 IS NOW SET-UP FOR A CALL ON RELOCB.


↑↑RELOCA:
	HRRZ TAC1,TAC1		;CLEAR CONFUSING BITS!
	PUSH P,TAC		;SAVE AN AC
	MOVEI TAC,JOBPFI	;USER'S LOWEST LEGAL IO ADDRESS.
	HLL TAC,UUOPC(J)	;USER OR EXEC OPERATION?
	TLNN TAC,USRMOD		;SKIP IF USER OP
	HRRI TAC,JOBSAV		;MONITOR GETS TO DO IO AT LOWER ADDRESSES.
	CAIGE TAC1,(TAC)	;IS THIS ADDRESS BELOW PROTECTED PART?
	TLO TAC1,400000		;SET WRITE PROTECTED ACCESS
	HLRZ TAC,JBTPAG(J)	;GET SIZE OF LOWER
	LSH TAC,9
	CAIG TAC,(TAC1)		;IS IT OUTSIDE LOWER?
	JRST RELOC1		;YES, THIS IS HARDER
	MOVEI AC1,JBTPAG(J)	;POINT TO THE RELOCATION WORD WE USED.
	JRST TPOPJ1		;PUT BACK TAC AND SKIP

RELOC1:	LDB AC1,PSEGN		;CHECK FOR UPPER SEGMENT
	PUSH P,DAT		;SAVE ANOTHER AC.
	JUMPE AC1,RELOC2	;NONE, CHECK PEEK-POKE
	MOVSI TAC,JWP		;CHECK WRITE PROTECT
	TDNE TAC,JBTSTS(AC1)
	TLO TAC1,400000		;WRITE PROTECTED
	HLRZ DAT,JBTPAG(AC1)	;NUMBER OF PAGES IN UPPER.
	LSH DAT,9		;NUMBER OF WORDS IN UPPER.
	HLRZ TAC,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	CAIGE TAC,400		;SKIP IF LOWER IS 256 PAGES OR LARGER
	MOVEI TAC,400		;UPPER STARTS AT PAGE 400
	LSH TAC,9		;UPPER'S STARTING WORD ADDRESS.
	SUB TAC1,TAC		;ADJUST REFERENCE - RELATIVE ADDRESS IN THE UPPER.
	TLNE TAC1,377777	;UNDERFLOW? (DON'T TEST SIGN OF TAC1-MEANS WR PROT)
	JRST RELOC4		;YES, BETWEEN UPPER AND LOWER!
	CAIG DAT,(TAC1)		;TOO BIG?
	JRST RELOC4		;TOO BIG.  AVOID SKIP RETURN
	MOVEI AC1,JBTPAG(AC1)	;POINT TO THE RELOCATION WORD WE USED.
	AOS -2(P)		;NEED TO RESTORE DAT, TAC, AND SKIP.
RELOC4:	POP P,DAT
	JRST TPOPJ		;LOSE

RELOH4:	TRNE AC1,10		;KLUDGY 2-PIECE FORMAT?
	JRST RELOC4		;TOO BAD FOR YOU
	TRNN AC1,20		;WRITE PROTECTED?
	TLO TAC1,400000		;YES
	SUBI TAC1,400000	;ADDRESS WITHIN UPPER
	HLRZ DAT,AC1		;NUMBER OF PAGES IN HISEG
	LSH DAT,9		;UPPER LIMIT OF HISEG
	CAIG DAT,(TAC1)		;WITHIN BOUNDS?
	JRST RELOC4		;NOPE
	MOVEI AC1,JBTPR2(J)
	JRST RELOH3		;WIN

RELOC2:	SKIPN AC1,JBTPR2(J)	;IS HE DOING PEEK-POKE
	JRST RELOC4		;NO. LOSE.  RESTORE DAT, TAC AND RETURN
	TRNE AC1,4		;IS IT GETHI HACK
	JRST RELOH4		;YES, LOSE.
	TLOE AC1,1		;IS HE WRITE PROTECTED (SET BIT FOR COMPARE)
	TLO TAC1,400000		;YES
	TRZN AC1,1		;IS THIS A RELATIVE MAPPING?
	JRST RELC2A		;NOT A RELATIVE UPPER
	HLRZ TAC,JBTPAG(J)	;SIZE OF LOWER
	LSH TAC,9		;SIZE OF LOWER IN WORDS
	SUBI TAC,(AC1)		;-RELATIVE RELOCATION = MAX. REL. WC OF UPPER
	SOJL TAC,RELOC4		;ERROR IF REL. PROT. OF UPPER IS TOO SMALL
	HRL AC1,TAC		;AC1←PROT OF UPPER IN LEFT
RELC2A:	MOVEI DAT,JBTPR2(J)	;POINT TO THE PROT-REL WORD BEING USED.
RELOC3:	HLRZ TAC,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	CAIGE TAC,400		;SKIP IF LOWER IS 256 PAGES OR LARGER
	MOVEI TAC,400		;UPPER STARTS AT PAGE 400
	LSH TAC,9		;UPPER'S STARTING WORD ADDRESS.
	SUB TAC1,TAC		;ADJUST REFERENCE - RELATIVE ADDRESS IN THE UPPER.
	TLNE TAC1,377777	;UNDERFLOW?
	JRST RELOC4		;YES, BETWEEN UPPER AND LOWER!
	HLRZ TAC,AC1		;GET PROT.
	CAIGE TAC,(TAC1)	;TOO BIG?
	JRST RELOC4		;TOO BIG.  AVOID SKIP RETURN
	MOVE AC1,DAT		;RETURN IN AC1 THE ADDRESS OF THE PROT-REL WORD
RELOH3:	AOS -2(P)		;NEED TO RESTORE DAT, TAC, AND SKIP.
	POP P,DAT
	JRST TPOPJ		;LOSE

;USE THIS ROUTINE AFTER CALLING RELOCA ONCE TO ASSURE
;THAT THE ADDRESS YOU ARE CHECKING IS IN THE SAME
;SEGMENT AS THE LAST ONE YOU CHECKED. DON'T CLOBBER
;AC1 BETWEEN CALLS ON RELOCA AND RELOCB
;CALLING:
;	MOVE J,<NUMBER OF JOB IN QUESTION>
;	MOVE TAC1,<ADDRESS YOU WISH CHECKED>
;	PUSHJ P,RELOCB
;	<ILLEGAL ADDRESS OR NOT IN SAME SEGMENT AS AC1>
;	<LEGAL ADDRESS AND IN RIGHT SEGMENT>

↑↑RELOCB:
	PUSH P,AC1		;SAVE PROT RELOC WE USED LAST!
	PUSHJ P,RELOCA		;DO THE RELOC THING
	JRST RELOC5
	CAMN AC1,(P)		;DID RELOCA USE PROT RELOC WE WANTED?
	AOS -1(P)		;YES, SUCCESS
RELOC5:	POP P,AC1
	POPJ P,			;LOSE

↑↑RELOCC←←RELOCA		;WITH MPX OR C1 WE CAN SWAP OUT FROM ANY MOBY
↑↑RELOCD←←RELOCB
;UNLOKC UNLOCK LOCK0 LOCK0A LOCK0B LOCK LOCK2 LOCK1 LOCKCK LOCKC1

↑UNLOKC:MOVEI J,(DAT)		;CALLED FROM CLOCK RQ AT ESTOP4
↑UNLOCK:
IFN FTP2,<
IFG XGPNUM,<
	CAME J,XFCJN1		;OUR VERSION OF THE FONT COMPILER JOB NUMBER
	CAMN J,XFCJN		;FONT COMPILER?
	POPJ P,			;YES, CAN'T UNLOCK
>;IFG XGPNUM
>;IFN FTP2
	PUSH P,TAC
	MOVSI TAC,LOKSWP
	ANDCAB TAC,JBTSTS(J)
	TRZN TAC,JLOCK
	JRST TPOPJ
	MOVEM TAC,JBTSTS(J)	;UNLOCK HIM.
IFN FTSTAT,<
	MOVEI TAC,LOKSTA	;UNLOCKING
	PUSHJ P,STAPUT
>;FTSTAT
	HLRZ TAC,JBTPAG(J)
	MOVN TAC,TAC
	ADDM TAC,LOKTOT		;DECREASE LOKTOT BY JOB SIZE
	JRST TPOPJ

LOCK0:	JSP TAC,UUOMES
	ASCIZ /Can't LOCK with segment
/

LOCK0A:	MOVEI TAC,0		;DELAY UNTIL HIS IO STOPS
	PUSHJ P,SLEEP
	JRST LOCK

LOCK0B:	JSP TAC,UUOMES
	ASCIZ /Job too big to LOCK in core
/

↑LOCK:
IFN FTP2,<
IFG XGPNUM,<
	CAME J,XFCJN1		;OUR VERSION OF THE FONT COMPILER JOB NUMBER
	CAMN J,XFCJN		;FONT COMPILER?
	POPJ P,			;YES, ALREADY LOCKED
>;IFG XGPNUM
>;IFN FTP2
	LDB TAC1,PSEGN
	JUMPN TAC1,LOCK0
	HLRZ TAC1,JBTPAG(J)
	MOVE AC2,HIFREE
	ADD AC2,HIUSED
	CAMLE TAC1,AC2		;CAN HE POSSIBLY FIT IN LOCKED CORE?
	JRST LOCK0B		;NO
	PUSHJ P,ANYACT		;WAIT UNTIL I/O STOPS
	JRST LOCK0A		;MAKE SURE WE GO OUT IF WE GET TO FORCE0
	MOVEI AC2,JLOCK
	TDNE AC2,JBTSTS(J)	;ARE WE LOCKED ALREADY?
	POPJ P,			;ALL DONE
	PUSHJ P,LOCKCK
	JRST LOCK2		;WE HAVE SOME PAGES IN LOW CORE
	HLRZ AC1,JBTPAG(J)	;WE'RE ALREADY IN THE RIGHT PLACE
	ADDM AC1,LOKTOT
	MOVEI AC2,JLOCK
	IORM AC2,JBTSTS(J)
IFN FTSTAT,<
	MOVEI TAC,LOKSTA+100	;LOCKING
	PUSHJ P,STAPUT
>;IFN FTSTAT
	POPJ P,

LOCK2:	MOVSI AC2,LOKSWP
	IORM AC2,JBTSTS(J)	;TELL SWAPPER TO SWAP INTO LOCKED CORE
IFN FTSTAT,<
	MOVEI TAC,LOKSTA+200	;SETTING LOKSWP
	PUSHJ P,STAPUT
>;IFN FTSTAT
LOCK1:	HLRZ TAC,JBTPAG(J)	;ARGUMENT TO XPAND IS CURRENT CORE SIZE
	SKIPN XJOB(J)
	PUSHJ P,XPAND		;CALL XPAND TO SWAP US OUT
	PUSHJ P,WSCHED		;WAIT UNTIL WE GET SWAPPED IN OR CALL CONT
	PUSHJ P,LOCKCK		;SEE IF WE ARE LOCKED IN
	JRST LOCK1		;NOPE, MUST BE CALL CONT
	POPJ P,

LOCKCK:	HLRZ AC1,JBTPAG(J)
	MOVEI DDB,0
	PUSHJ P,SMAPL
	 PUSHJ P,LOCKC1
	JUMPE DDB,CPOPJ1	;JUMP IF ALL OUR PAGES ARE HI PAGES
	POPJ P,			;HAVEN'T WON YET

LOCKC1:	MOVEI TEM,(AC2)		;GET PHYSICAL PAGE NUMBER
	CAMGE TEM,FSLIMIT	;IS IT SOMEPLACE GOOD?
	MOVNI DDB,1		;NO
	POPJ P,			;YES
;LTHUUO LTHMOV LTHM1 LTHM1B LTHM2 LTHM2A LTHM2Z LTHM3 HTLMOV HTLMV1 HTLMV2 HTLFIN HTLFN1 HTLFN2 HTLFN3 HCBUG HCB1 HCB1A HCB1B HCB2

IFN FTHPSG,<

↑LTHUUO:LDB J,PSEGN
	JUMPE J,CPOPJ
	JUMPL TAC,UUOERR
	CAILE TAC,1
	JRST UUOERR
	JUMPG TAC,HTLMOV
	PUSHJ P,MAPSET		;SETUP MAP TO MAKE UPPER LOOK LIKE MAIN JOB

;LOW TO HIGH MOVE.  CALL WITH J=JOB TO MOVE.  ASSUMES MAP IS SETUP FOR J AS JOB.

↑LTHMOV:SKIPN AC3,JBTMAP(J)	;SKIP IF A MAP EXISTS.
	POPJ P,
IFN FTMPP2,<
	MOVE AC3,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH AC3,AC1
>;IFN FTMPP2
	LSH AC3,9
	HRLI AC3,-1000		;AOBJN POINTER TO USER'S MAP.
	MOVEI AC2,0		;COUNT USER'S PAGES THAT GO TO HI CORE
LTHM1:	SKIPN TAC1,(AC3)	;IS THERE A PAGE HERE?
	JRST LTHM1B		;NO.
	HRRZ TAC1,TAC1
	CAIGE TAC1,1000		;SKIP IF PAGE ALREADY LIVES IN HI CORE
	ADDI AC2,1		;COUNT A PAGE THAT WE MUST MOVE
LTHM1B:	AOBJN AC3,LTHM1
	JUMPE AC2,CPOPJ1	;WIN IF ALL HIS PAGES ARE HI, OR NO PAGES.
	CAMLE AC2,CORHTL	;WILL THIS FIT IN HI CORE?
	POPJ P,			;NO.  SORRY CHARLIE.
IFE FTMPP2,<
	MOVE AC3,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE AC3,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH AC3,AC1
>;IFN FTMPP2
	LSH AC3,9
	HRLI AC3,-1000
	MOVE DSER,FHUPAG	;SEARCH FOR FREE PAGES IN HI CORE.
LTHM2:	SKIPN TAC1,(AC3)	;IS THIS OLD PAGE IN LOW CORE?
	JRST LTHM2Z		;NO SUCH PAGE.
	HRRZ TAC1,TAC1
	CAIL TAC1,1000
	JRST LTHM2Z		;THIS PAGE IS IN HI CORE ALREADY
	CAIA
LTHM2A:	ADDI DSER,1
	CAML DSER,LHUPAG	;HAS DSER RUN AMOK?
	JRST 4,.		;YES.  LOSE.
	LDB TAC1,COREP		;GET A CORTAB BYTE
	JUMPN TAC1,LTHM2A	;JUMP IF CLAIMED.
	DPB J,COREP		;CLAIM THIS BLOCK FOR US.
	SOS CORHTL		;COUNT IT AS IN USE.
	MOVEI TAC1,SHFEXP	;CREATE AN EXEC PAGE POINTING TO THE
	MOVEI TAC,(DSER)	;DESTINATION PAGE
	PUSHJ P,ADDEMP		;DESTINATION PAGE IS MAPPED ONTO SHFEXP
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON
>;IFKL10
	HLLZ TAC,AC3
	ADD TAC,[1000,,SHFEXP]	;TAC←USER PAGE NUMBER,,EXEC PAGE NUMBER
	LSH TAC,9		;TAC←USER ADDRESS,,EXEC ADDRESS
	XCTR XBLTR,[BLT TAC,SHFEXP⊗9+777]
	SETZM EXPGT+SHFEXP	;DELETE MAP ENTRY FOR DESTINATION
	HRRZ TAC,(AC3)		;TAC←PAGE NUMBER OF OLD PAGE FOR USER
	PUSHJ P,CORGB1
	MOVEI TAC1,0
	DPB TAC1,TAC		;FREE CORE.
	AOS CORTAL		;AND COUNT THE LOW-CORE FREE COUNT
	HRRM DSER,(AC3)		;STORE NEW MAP ENTRY FOR THIS USER.
	SOJLE AC2,LTHM3		;COUNT A PAGE MOVED.  JUMP IF DONE
LTHM2Z:	AOBJN AC3,LTHM2		;LOOP MOVING PAGES
LTHM3:
IFE FTMPP2,<
	MOVE AC3,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE AC3,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH AC3,AC1
>;IFN FTMPP2
	LSH AC3,9
	HRRZ TAC,(AC3)		;GET PAGE NUMBER OF VIRTUAL PAGE 0
	HRRM TAC,JBTPAG(J)	;STORE AS USER'S FIRST PAGE.
NOKL10,<CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON
>;IFKL10

	PUSHJ P,HCBUG		;GOD BLESS US, EVERY ONE.

	MOVE AC3,JBTSTS(J)
	TLNE AC3,JSEG		;SKIP UNLESS THIS IS A SEGMENT
	PUSHJ P,AUPMAP		;FOR SEGMENT, SPREAD NEW MAP TO ALL LOWERS
	JRST DIDLE9		;RECOMPUTE SWAPPING PARAMS.  SKIP

;HIGH TO LOW MOVE.  CALL AT UUO LEVEL WITH J=JOB NUMBER TO MOVE.

↑HTLMOV:HRRZ TAC,JBTPAG(J)
	CAIGE TAC,1000		;IS THIS JOB IN HIGH CORE?
	POPJ P,			;NO.  THAT WAS EASY
	JRST HTLMV2

HTLMV1:	PUSHJ P,WSCHED		;WAIT FOR IO TO STOP
HTLMV2:	PUSHJ P,ANYACT
	JRST HTLMV1		;IO STILL ACTIVE
	HLRZ TAC,JBTPAG(J)
	DPB TAC,IMGIN
	DPB TAC,IMGOUT
	MOVSI TAC,SWP
	IORM TAC,JBTSTS(J)	;MARK THE JOB AS HAVING BEEN SWAPPED OUT
	JRST WSCHED		;EXIT TO WSCHED VIA MAPSET

;ENTER HERE FROM SWAPPER WHEN THERE'S LOW CORE AVAILABLE.
;J=JOB NUMBER. TAC=DESIRED CORE SIZE (IN PAGES).

↑HTLFIN:PUSHJ P,HOLSRC		;LOOK FOR A HOLE IN LOWCORE
	POPJ P,			;LOSE.  NONE EXISTS.
;DSER=NEW LOCATION.  TAC=NEW SIZE.
	PUSHJ P,APRMAP		;SETUP MAP (SWAPPER PUSHED MAP)
	MOVSI PROG,(TAC)
	HRRI PROG,(DSER)	;SETUP PROG FOR CALL TO DIDDLE
IFE FTMPP2,<
	MOVE AC3,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE AC3,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH AC3,AC1
>;IFN FTMPP2
	LSH AC3,9
	HRLI AC3,-1000
	PUSH P,TAC		;COUNT OF PAGES TO MOVE
HTLFN1:	SKIPN TAC,(AC3)		;IS THERE A HIGH PAGE HERE?
	JRST HTLFN2		;NO PAGE AT ALL
	HRRZ TAC,TAC
	CAIGE TAC,1000
	JRST HTLFN2		;THIS PAGE IS ALREADY LOW.
	PUSHJ P,CORGB1
	LDB TAC1,TAC
	CAIE TAC1,(J)
	HALT .+1
	MOVEI TAC1,0
	DPB TAC1,TAC		;FREE HIGH CORE BYTE
	AOS CORHTL		;FREE HIGH CORE BYTE
	MOVEI TAC,(DSER)
	PUSHJ P,CORGB1
	LDB TAC1,TAC
	JUMPE TAC1,.+2
	HALT .+1
	DPB J,TAC		;CLAIM LOWCORE BYTE
	SOS CORTAL
	MOVEI TAC1,SHFEXP
	MOVEI TAC,(DSER)
	PUSHJ P,ADDEMP
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON
>;IFKL10
	HLLZ TAC,AC3
	ADD TAC,[1000,,SHFEXP]
	LSH TAC,9		;USER'S ADDRESS,,EXEC PAGE ADDRESS
	XCTR XBLTR,[BLT TAC,SHFEXP⊗9+777]
	SETZM EXPGT+SHFEXP
	HRRM DSER,(AC3)		;UPDATE USER'S MAP
	ADDI DSER,1
	SOSG (P)
	JRST HTLFN3		;LEAVE IF COUNT IS EXHAUSTED
HTLFN2:	AOBJN AC3,HTLFN1
HTLFN3:	SUB P,[1,,1]
NOKL10,<CONO PAG,1
	CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON
>;IFKL10

	PUSHJ P,HCBUG

	MOVEI DSER,(PROG)	;SETUP FOR DIDLE
	MOVEI AC1,0
	JRST DIDLE


HCBUG:	PUSH P,J
	PUSH P,DSER
	PUSH P,AC2
	PUSH P,TAC
	MOVEI J,JOBN-1
HCB1:	SKIPN AC2,JBTPAG(J)
	JRST HCB2
	MOVEI DSER,(AC2)
	CAIGE DSER,1000
	JRST HCB2
IFE FTMPP2,<
	MOVE AC2,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE AC2,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH AC2,AC1
>;IFN FTMPP2
	LSH AC2,9
	HRLI AC2,-1000
HCB1A:	SKIPN DSER,(AC2)
	JRST HCB1B
	LDB TAC,COREP
	CAIN TAC,(J)
	JRST HCB1B
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / JBTMAP - CORTAB INCONSISTENT FOR HICORE SEG.  FIX IT OR RELOAD.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,DDTCALL

HCB1B:	AOBJN AC2,HCB1A
HCB2:	SOJG J,HCB1
	POP P,TAC
	POP P,AC2
	POP P,DSER
	POP P,J
	POPJ P,

>;IFN FTHPSG
SUBTTL	FREE STORAGE	;AND OTHER POLITICAL PRISONERS
; "AND WHO DESERVES THE CREDIT?  AND WHO DESERVES THE BLAME?
; NIKCOLI IVANOVITCH LOBACHEVSKY IS HIS NAME."

;	ACCUMULATOR DEFINITIONS

;;SIZE←AC3		;INPUT PARAMETER TO FSGET (now AC3 is used explicitly)
;;BLOCK←AC1		;BLOCK ADDRESS OF FS BLOCK (now AC1 is used explicitly)

PICMSK←←2⊗(7-APRCHN)-1	;MASK TO SELECT CHANNELS 3,4,5,6,7 IN CONO/I PI
PICHON←←2000		;BIT TO TURN ON SELECTED CHANNELS: CONO PI
PICHOF←←1000		;BIT TO TURN OFF SELECTED CHANNELS

;THE FREE STORAGE SYSTEM ASSUMES THAT CHANNELS 1 AND 2 NEVER REQUEST
;FREE STORAGE.

;FSINIT FSINI3 FSINI5 FSHIN0 HFSIN3 HFSINI HFSIN2 HFSIN5 FSACSV NFSACSV FSACRS

;INITIALIZE FREE STORAGE


COMMENT $	


FREE STORAGE LOOKS LIKE:

BLOCK IN USE:			BLOCK THAT IS FREE

	(LOW ADDRESS)

---------------			---------------
| RS1  |  *---|→→→*		|  U   |  *---|→→→*
---------------   ↓		---------------   ↓
|             |   ↓		|             |   ↓
|             |   ↓		|             |   ↓
|             |   ↓		|             |   ↓
| DATA AREA   |   ↓		|             |   ↓
|             |	  ↓		---------------   ↓
|             |	  ↓		|   0  | BLINK|   ↓
---------------   ↓		---------------   ↓
|⊗ SIZE| RS2  |←←←*		| SIZE | FLINK|←←←*
---------------			---------------

	(HIGH ADDRESS)


WHERE SIZE IS THE TOTAL SIZE OF THE BLOCK IN WORDS.
THE DATA AREA HAS SIZE-2 WORDS. ⊗SIZE IS SIZE + 400000.
RS1 = 400000 + location of PUSHJ to FSGET caller.
RS2 = reserved for free storage system future use.  Presently 0
U IS UNDEFINED.
FLINK IS A FORWARD LINK IN A CHAIN OF FREE BLOCKS.
LINKS WILL EVENTUALLY POINT BACK TO THE BASE OF THE CHAIN!
BLINK IS A BACKWARD LINK IN A CHAIN OF FREE BLOCKS.

THERE ARE "NFSB" CHAINS OF FREE BLOCK WITH FORWARD AND
BACKWARD POINTERS IN FSAVB TABLE.


ALL FREE STORAGE BLOCKS ARE SOME MULTIPLE OF THE "TRIVIAL" SIZE.
ALL REQUESTS ARE ROUNDED UP TO SUCH A MULTIPLE.
CHAINS OF FREE BLOCKS OF EACH SIZE ARE KEPT WITH BASE POINTERS IN FSAVB.
THE LAST ENTRY (FSAVB+2*NFSB-2 AND FSAVB+2*NFSB-1) ARE FOR ALL BIGGER BLOCKS
THAN TRIVIAL*NFSB.


EACH LIST IS KEPT IN INCREASING ORDER OF ADDRESSES.
$

↑FSINIT:SETZM FSBEG
	MOVE TAC,[FSBEG,,FSBEG+1]
	BLT TAC,FSEND
	MOVNI TAC,FSNINIT*2	;NUMBER OF PAGES TO CLAIM NOW
	ADDM TAC,LOFREE		;TAKE IT FROM THE USERS
	ASH TAC,9		;MAKE IT NUMBER OF WORDS
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
	MOVE DSER,SYSPAG	;FIRST FS PAGE
	MOVEI UCHN,(DSER)
	ADDI UCHN,FSNINIT*2
	MOVEM UCHN,FSPAG	;FIRST PAGE PAST FS
	LSH UCHN,9
	MOVEM UCHN,FSTOP	;FIRST WORD PAST FS
	MOVEI UCHN,FSNINIT*2
FSINI3:	PUSHJ P,CORGBP	
	MOVEI TAC1,FSCUS	;USAGE CODE FOR FS
	DPB TAC1,TAC		;CLAIM BLOCK FROM CORTAB
	MOVEI TAC1,(DSER)	;ADD THIS PHYSICAL PAGE 
	PUSHJ P,ADDEVP		;TO THE EXEC MAP
	ADDI DSER,1
	SOJG UCHN,FSINI3
	MOVE UCHN,[2000*FSNINIT,,FSAVB+2*NFSB-1] ;SIZE,,FLINK
	MOVE AC2,FSTOP		;FIRST ADDRESS PAST FS
	SUBI AC2,1		;ADDRESS OF HI END OF FIRST BLOCK
	MOVEM UCHN,(AC2)	;SET SIZE,,FLINK IN TOP OF BLOCK
	HRRZM UCHN,-1(AC2)	;SET BLINK
	MOVEM AC2,@SYSTOP	;ADDRESS OF TOP GOES INTO BOTTOM
	SETZ UCHN,
FSINI5:	MOVEI AC3,FSAVB+1(UCHN)	;GET ADDRESS OF SOMEONE
	MOVEM AC3,FSAVB(UCHN)	;SAVE BACK POINTER
	MOVEM AC3,FSAVB+1(UCHN)	;SAVE FORWARD POINTER
	ADDI UCHN,2		;INCREMENT BY 2
	CAIGE UCHN,2*NFSB-2	;ARE WE AT THE END YET?
	JRST FSINI5		;NO KEEP LOOPING
	HRRZM AC2,FSAVB+2*NFSB-2 ;SAVE BACK POINTER TO ONLY BLOCK
	HRRZM AC2,FSAVB+2*NFSB-1 ;SAVE FORWARD POINTER TO ONLY BLOCK
IFN FTHIFS,<
	MOVNI TAC,HFSPAG	;NUMBER OF HIGH PAGES TO CLAIM NOW
	ADDM TAC,HIFREE		;TAKE IT FROM THE USERS
	ASH TAC,9		;MAKE IS NUMBER OF WORDS
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
	SKIPA DSER,FSLIMIT	;FIRST CANDIDATE HIGH FS PAGE
FSHIN0:	ADDI DSER,1
	LDB TAC,COREP		;GET USE CODE
	JUMPN TAC,FSHIN0	;FIND A FREE PAGE
	MOVE UCHN,HIFSEV	;FIRST AVAILABLE EXEV VIRTUAL PAGE NUMBER
	LSH UCHN,9
	MOVEM UCHN,HIFSBG	;REMEMBER STARING ADDRESS, FOR RE-INITING
	PUSH P,UCHN		;SAVE FIRST WORD OF HIGH FS (VIRT ADDR)
	MOVE UCHN,HIFSEV
	ADDI UCHN,HFSPAG
	LSH UCHN,9
	PUSH P,UCHN		;FIRST WORD PAST HIGH FS (VIRT ADDR)
	MOVEI UCHN,HFSPAG
HFSIN3:	MOVEI TAC1,FSCUS	;CORE USAGE CODE FOR FS
	DPB TAC1,COREP		;CLAIM BLOCK FROM CORTAB
	MOVEI TAC,(DSER)	;ADD THIS PHYSICAL PAGE 
	AOS TAC1,HIFSEV		;WITH THIS EXEC VIRTUAL PAGE
	SUBI TAC1,1		;SORT OF
NOKL10,<CAIL TAC1,600
	ADDI TAC1,PSB-EXPGT	;THIS VIRTUAL PAGE IS IN THE PSB
>;NOKL10
	PUSHJ P,ADDEMP		;TO THE EXEC MAP
	ADDI DSER,1
	SOJG UCHN,HFSIN3
	POP P,AC2		;FIRST ADDRESS PAST HIGH FS BLOCK
	POP P,DSER		;FIRST WORD OF FS BLOCK
	PUSHJ P,HFSIN2		;SET UP THE LINKS FOR INITIAL HI FS
>;IFN FTHIFS
	MOVEI AC2,JIFSEC*=60	;NUMBER OF TICKS BETWEEN CHECKER CHECK
	MOVEM AC2,FSCKCT	;SAVE
	MOVEI UCHN,FSLIST	;GET THE START OF OUR Q SPACE
	MOVEM UCHN,FSIPTR	;SAVE AS Q INPUT POINTER
	MOVEM UCHN,FSOPTR	;AND Q OUTPUT POINTER
	JRST SFSINI		;INITIALIZE FREE STORAGE SPARE LIST USERS


IFN FTHIFS,<

repeat 0,<	;Only the old (NCP) IMPSER used this.
;Here to re-initialize high FS.  Assumes no one thinks they have any high FS.
↑HFSINI:CONO PI,IMPOFF		;Don't nobody try to get no hi fs right now
	SETZM FSHCLK		;Don't request more pages from clock level
	MOVE AC2,HIFSEV		;FIRST VIRTUAL PAGE WITH BEYOND HIGH FS
	CAILE AC2,TOPHIP	;DOES HIGH FS REALLY GO THAT FAR?
	MOVEI AC2,TOPHIP	;NO, THIS IS ONE GREATER THAN LAST POSSIBLE V PAGE
	LSH AC2,9		;MAKE WORD ADDRESS BEYOND FS BLOCK
	MOVE DSER,HIFSBG	;WORD ADDRESS WHERE HIGH FS BEGINS
	PUSHJ P,HFSIN2		;Re-init hi fs
	CONO PI,IMPON		;All clear to grab hi fs
	POPJ P,
>;repeat 0

;Routine to initialize links of high FS.  Sets up one big FS block.
;Call with  AC2 containing (virtual) address of word beyond end of high FS,
;	    DSER with (virtual) address of beginning of high FS.
;Assumes exec map is already set up for these virtual addresses.
HFSIN2:	SETZB UCHN,HFSBSY	;NO HI FS IN USE, PREPARE TO MAKE ALL LISTS EMPTY
HFSIN5:	MOVEI AC3,HFSAVB+1(UCHN) ;GET ADDRESS OF A LIST HEADER
	MOVEM AC3,HFSAVB(UCHN)	;SAVE BACK POINTER, MAKING LIST EMPTY
	MOVEM AC3,HFSAVB+1(UCHN) ;SAVE FORWARD POINTER
	ADDI UCHN,2		;NEXT LIST HEADER
	CAIGE UCHN,2*NFSB	;ARE WE AT THE END YET?
	JRST HFSIN5		;NO, DO NEXT HEADER
	MOVE UCHN,AC2		;COPY ADDRESS OF WORD BEYOND END OF BLOCK
	SUB UCHN,DSER		;SIZE OF BLOCK IN UCHN
	JUMPLE UCHN,CPOPJ	;JUMP IF NO BLOCK
	MOVEI AC3,(UCHN)	;COPY SIZE
	LSH AC3,1-TSHF		;SHIFT TO MAKE INDEX
	SUBI AC3,2		;NORMALIZE TO ZERO INDEX
	CAILE AC3,2*NFSB-2	;ARE WE BEYOND END OF THE TABLE?
	MOVEI AC3,2*NFSB-2	;YES. LIMIT TO LAST LIST
	MOVEI AC3,HFSAVB+1(AC3)	;FLINK
	HRLI AC3,(UCHN)		;SIZE,,FFLINK
	SUBI AC2,1		;ADDRESS OF HI END OF FIRST BLOCK
	MOVEM AC2,(DSER)	;ADDRESS OF TOP GOES INTO BOTTOM
	MOVEM AC3,(AC2)		;SET SIZE,,FLINK IN TOP OF BLOCK
	HRRZM AC3,-1(AC2)	;SET BLINK
	HRRZM AC2,-1(AC3)	;SAVE BACK POINTER TO ONLY BLOCK
	HRRZM AC2,(AC3)		;SAVE FORWARD POINTER TO ONLY BLOCK
	POPJ P,
>;IFN FTHIFS

LOSYS

FSACSV:	EXCH DAT,(P)		;PUSHJ P,FSACSV TO SAVE AC'S.
	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,TEM
NFSACSV←←.-FSACSV		;NUMBER OF ACS SAVED
	JRST (DAT)


FSACRS:	POP P,TEM		;JSP DAT,FSACRS TO RESTORE AC'S
	POP P,AC3
	POP P,AC2
	POP P,TAC1
	POP P,TAC
	EXCH DAT,(P)
	POPJ P,
;CALLING FSSBYP FSSBP1 FSGETP HFSGTU HFSGET FSGET FSGETU FSGETV FSGETT FSGT0 FSGT1 FSGCL FSGCLX FSGTBX FSGTB0 FSGTB1 FSGTB2 FSHGB1 FSHGB2 FSHGLZ FSGPAG FSGPG1 FSGPG2 FSGPG3 FSGTC FSGTC1 FSCLP FSCNEW FSCEND FSGTC2 FSGTC5 FSGTC3 FSGTC6 FSGTC4 FSGTCR FSGRT1 FSGTW FSGTWX FSGTW5 FSGFAI FSGLUZ

;FSGET	GET FREE STORAGE AT ANY LEVEL.

COMMENT $

CALLING:
	MOVEI AC3,<BLOCK SIZE>
	PUSHJ P,FSGET
	<NONE AVAILABLE>
	<OK - ADDRESS OF BLOCK IS IN AC1>

	UUO LEVEL ALWAYS GETS SUCCESS EXIT

ALTERNATE CALLS:
	FSGETU			;ENTER HERE AT UUO LEVEL.
				;GIVE ERROR RETURN INSTEAD OF WAITING

	FSGETP			;ENTER HERE GETS 1K BLOCK ALIGNED ON A 1K ADDRESS.
				;INITIAL CONTENTS OF AC3 ARE IGNORED.

FSGTUF (sometimes in AC1) means:
	1		;Get page on a page boundary
	2		;High FS is OK
	400000,,0	;Don't wait for FS
$


FSSBYP:	POINT 17,(AC1),17	;POINTER TO SIZE FIELD OF BLOCK
FSSBP1:	POINT 17,(AC2),17	;POINTER TO SIZE WHEN BLOCK TOP IN AC2

FSGETP:	MOVEI AC1,1		;HERE TO GET PAGE ON A PAGE BOUNDARY.
	JRST FSGETV

IFN FTHIFS,<
↑HFSGTU:SKIPA AC1,[400000,,2]	;HIGH OK AND ALSO DON'T WAIT
↑HFSGET:MOVEI AC1,2		;FLAG HIGH FS OK (NOT FOR KA-10 USE)
	JRST FSGETV
>;IFN FTHIFS

↑FSGET:	TDZA AC1,AC1		;NORMAL CALL.
↑FSGETU:MOVNI AC1,1		;CALL AT UUO LEVEL AND NEVER WAIT.
FSGETV:	CONSZ PI,1B20-1B26⊗(7-APRCHN)	;Are we below APRCHN?
	JRST FSGLUZ		;NO. SOMEONE SHOULD KNOW BETTER.
	CONSO PI,77400		;ANY PI'S IN PROGRESS?
	SKIPE INTACT		;WE'RE AT UUO LEVEL? USER INTERRUPT?
	JRST .+2		;EITHER PI IN PROGRESS OR USER I-LEVEL
	MOVEM AC1,FSGTUF	;NORMAL UUO LEVEL. SET SPECIAL FLAG.
				;NEGATIVE MEANS DON'T WAIT TO GET FS.
	AOS NFSGETS		;COUNT FS GETS
	PUSHJ P,FSACSV		;SAVE  DAT,TEM,AC3,AC2,TAC,TAC1
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB TABLE
>;IFN FTFSAVBUG
	MOVEI AC3,2(AC3)	;GET SIZE OF REQUEST +2
	TRZE AC3,TRIVIAL-1	;IS THIS EXACT MULTIPLE OF TRIVIAL?
	ADDI AC3,TRIVIAL	;NO. ADD TRIVIAL
FSGETT:
IFN FTHIFS,<
	TRNN AC1,2		;SKIP IF FLAGGING HIGH FS OK
>;IFN FTHIFS
	JUMPG AC1,FSGPAG	;JUMP IF SPECIAL CALL TO GET A PAGE
	MOVEI TAC,(AC3)		;GET SIZE INTO TAC
	LSH TAC,1-TSHF		;SHIFT TO MAKE INDEX
	SUBI TAC,2		;NORMALIZE TO ZERO INDEX
	CAILE TAC,2*NFSB-2	;ARE WE AT THE END OF THE TABLE?
	JRST FSGTBX		;YES. LOOK FOR A BIG BLOCK
	LSH TAC,-1
	AOS FSRPQ(TAC)
	LSH TAC,1
FSGT0:	MOVE TAC1,TAC		;INDEX TO FIRST BASE INSPECTED
	MOVE AC1,FSLIM9		;FIND BLOCK WITH LOWER ADDRESS
FSGT1:	MOVE AC2,FSAVB+1(TAC1)	;AVOID TIMING ERRORS
	CAMG AC2,AC1		;ADDRESS LESS THAN OUR BEST?
	CAMG AC2,SYSTOP		;YES, IS NEW ADDRESS IN FS?
	CAIA			;NO TO EITHER
	MOVE AC1,AC2		;YES. REMEMBER BEST ADDRESS
	ADDI TAC1,2		;GO ON TO NEXT LIST BASE
	AOS NFSLP1		;COUNT A LOOP OF TYPE1
	CAIGE TAC1,2*NFSB	;STILL IN TABLE?
	JRST FSGT1		;YES. LOOP
	CAML AC1,FSLIM9		;FOUND ANY?
	JRST FSGTW		;NO WE'LL HAVE TO WAIT...
	PUSHJ P,FSGCL		;CALL ROUTINE TO CLAIM AND DELINK
	JRST FSGT0		;THE CLAIM FAILED. LOOK AGAIN.
	JRST FSGTC		;CLAIM OK

;CLAIM AND DELINK THE FS BLOCK POINTED TO BY (AC1).
;SKIP ON SUCCESS (LEAVES TAC1 AND TAC SETUP AS PARAMETERS FOR FSGTC5)
FSGCL:	CONI PI,AC2		;GET PI CHANNEL STATUS
	ANDI AC2,PICMSK		;ONLY CHANNELS 3,4,5,6,7
	CONO PI,PICHOF(AC2)	;TURN OFF CHANNELS 3-7
	SKIPG TAC1,(AC1)	;FLINK INTO TAC1
	JRST FSGCLX		;BLOCK IS ALREADY CLAIMED!
	MOVS TAC1,TAC1
	CAILE AC3,(TAC1)
	JRST FSGCLX		;BLOCK STILL FREE, BUT SMALLER THAN BEFORE
	MOVS TAC1,TAC1
	HRRZ TAC,-1(AC1)	;BLINK INTO TAC
	HRRM TAC1,(TAC)		;GO BACK AND RESET FLINK
	HRRM TAC,-1(TAC1)	;GO FORWARD AND RESET BLINK
	CONO PI,PICHON(AC2)	;RESTORE CHANNELS THAT WERE ON
	MOVSI AC2,400000
	IORM AC2,(AC1)		;TURN ON THE SIGN BIT TO CLAIM BLOCK
	JRST CPOPJ1		;GIVE THE SKIP RETURN

FSGCLX:	CONO PI,PICHON(AC2)	;RESTORE PI.
	POPJ P,


;HERE TO GET A BIG FS BLOCK
FSGTBX:	AOS FSRPQ+NFSB-1
IFN FTHIFS,<
	TLZ AC1,400000		;TURN OFF UUO-LVL-DON'T-WAIT FLAG
	CAIE AC1,2		;IS HIGH FS OK?
	TDZA AC1,AC1		;DON'T GET CONFUSED BY OTHER FLAGS
	MOVNI AC1,1		;YES, THIS IS A BETTER FLAG
	PUSH P,AC1		;SAVE HIGH-OK FLAG
>;IFN FTHIFS
FSGTB0:	HRRZ AC1,FSAVB+2*NFSB-1	;GET THE FIRST LINK
IFN FTHIFS,<
	SKIPGE (P)		;IS HIGH OK?
	HRRZ AC1,HFSAVB+2*NFSB-1 ;YES, TRY THAT FIRST
>;IFN FTHIFS				;NOTE HFSAVB IS FIRST IN CORE SO CAIG WINS
FSGTB1:	AOS NFSLP2		;COUNT A LOOP OF TYPE 2
	CAIG AC1,FSAVB+2*NFSB-1	;FLINK .GT. ADDRESS OF LIST BASE?
IFE FTHIFS,<
	JRST FSGTW		;NO. WE'LL HAVE TO WAIT.
>;IFE FTHIFS
IFN FTHIFS,<
	JRST FSHGB1		;NO. TRY LOW FS OR WAIT
>;IFN FTHIFS
	SKIPG AC2,(AC1)		;SKIP IF THIS BLOCK IS NOT CLAIMED
	JRST FSGTB0		;HIGHER CHANNEL MUST HAVE GOT THIS ONE!
	HLRZ TAC1,AC2		;GET THE SIZE FIELD
	CAIL TAC1,(AC3)		;SIZE BIG ENOUGH?
	JRST FSGTB2		;YES. TRY TO CLAIM IT
	MOVEI AC1,(AC2)		;LOAD NEXT FLINK
	JRST FSGTB1		;LOOP

FSGTB2:	PUSHJ P,FSGCL		;CLAIM THE BLOCK AND DELINK IT
	JRST FSGTB0		;CLAIM FAILED.
IFN FTHIFS,<
	POP P,(P)		;GET RID OF HIGH-OK FLAG
>;IFN FTHIFS
	JRST FSGTC		;GOT IT

IFN FTHIFS,<
FSHGB1:	AOSN (P)		;SET HIGH NOT OK, SKIP IF IT WAS BEFORE
	JRST FSHGB2		;TRIED HIGH, NOW TRY LOW
	POP P,(P)
	JRST FSGTW		;ALREADY TRIED LOW, HAVE TO WAIT

FSHGB2:	MOVEI TAC1,5		;ASK FOR THIS MANY MORE PAGES OF HIGH FS
	MOVEM TAC1,FSHCLK	;TELL FSCLK TO MAKE MORE HIGH FS
	SETOM FSNCLK		;TELL CH7 TO RUN FSCLK
	SUB P,[1,,1]		;GET RID OF HIGH-OK FLAG
	JRST FSGFAI		;TAKE FAILURE RETURN FROM HFSGET
>;IFN FTHIFS

FSGPAG:	HRRZ AC1,FSAVB+2*NFSB-1	;GET THE FIRST LINK
	MOVEI AC3,1000		;1 PAGE NEEDED
FSGPG1:	AOS NFSLP2		;COUNT A LOOP OF TYPE 2
	CAIG AC1,FSAVB+2*NFSB-1	;FLINK .GT. ADDRESS OF LIST BASE?
	JRST FSGTWX		;NO.  WE'LL HAVE TO WAIT.
	SKIPG AC2,(AC1)		;SKIP IF THIS BLOCK IS NOT CLAIMED
	JRST FSGPAG		;HIGHER CHANNEL MUST HAVE GOT THIS ONE!
	HLRZ TAC1,AC2		;GET THE SIZE FIELD
	CAIL TAC1,(AC3)		;SIZE BIG ENOUGH?
	JRST FSGPG3		;YES. SEE IF IT IS REALLY BIG ENOUGH.
FSGPG2:	MOVEI AC1,(AC2)		;LOAD NEXT FLINK
	JRST FSGPG1		;LOOP

FSGPG3:	SUBM AC1,TAC1
	ADDI TAC1,1000
	TRZ TAC1,777		;TAC1←LOWEST PAGE BOUNDARY ADDRESS IN BLOCK
	MOVEI TAC,(AC1)
	ADDI TAC,1		;ADDRESS OF NEXT HIGHER BLOCK
	TRZ TAC,777		;TAC←HIGHEST PAGE BOUNDARY ADDRESS IN BLOCK
	SUBI TAC,1000		;SEE IF THERE'S ANY SPACE THERE TO TAKE PAGE
	CAMGE TAC,TAC1		;IF HIGH-PAGE IS AT LEAST AS BIG AS LOW
	JRST FSGPG2		;LOSE.  ADVANCE TO NEXT FS BLOCK
	HLRZ AC3,AC2		;MAKE SURE IT STILL IS AT LEAST THIS BIG
	PUSHJ P,FSGCL		;CLAIM THE BLOCK AND DELINK IT
	JRST FSGPAG		;CLAIM FAILED.
;DON'T CLOBBER TAC AND TAC1 - NEEDED BY FSGTC5
	MOVEI AC3,1000		;RESTORE DESIRED SIZE
	LDB AC2,FSSBYP		;SIZE OF FS BLOCK
	SUBM AC1,AC2
	MOVEI TEM,1(AC2)	;FIRST WORD OF BLOCK
	ADDI AC2,1000
	TRZ AC2,777		;FIRST PAGE BOUNDARY IN BLOCK
	CAIG AC2,(TEM)		;IS IT DIFFERENT FROM THE TOP OF THE BLOCK?
	JRST FSGTC		;NO, GIVE CALLER LOW PART OF BLOCK
;RANGE (TEM) TO (AC2)-1 IS DISCARDED.  AC2 (ENDS IN 000) IS IMPORTANT PART.
	PUSH P,AC1		;HI END OF IMPORTANT BLOCK
	HRRZM AC1,(AC2)		;LO END OF IMPORTANT BLOCK
	SUBI AC2,1		;HI END OF DISCARD BLOCK
IFN FTFSAVBUG,<
	CAMGE TEM,SYSTOP
	PUSHJ P,FSVBX2
>;IFN FTFSAVBUG
	HRROM AC2,(TEM)		;STORE IN LO END OF DISCARD BLOCK
	SUBM AC1,AC2		;AC2←SIZE OF IMPORTANT BLOCK
	DPB AC2,FSSBYP		;STORE IT IN THE BLOCK (ALREADY CLAIMED)
	SUBM AC1,AC2		;GET AC2 BACK
	MOVEI AC1,1(TEM)	;POINTER TO DISCARD
	SUBM AC2,TEM		;TEM ← SIZE-1 OF DISCARD
	ADDI TEM,400001		;TEM ← SIZE + 400000
	HRLZM TEM,(AC2)		;FINISH CLAIMING DISCARD PIECE
	PUSHJ P,FSQUIK
	POP P,AC1
				;FALL INTO FSGTC
;FSGTC - TRIM THE BLOCK WE CLAIMED TO THE SIZE WE REQUESTED.  IF THE
;REMAINDER EXCEEDS 170 WORDS THEN WE USE TAC AND TAC1 (AS SETUP BY
;FSGCL) TO HELP RETURN THE REMAINDER NOW.  IF THE REMAINDER IS SMALL,
;IT IS PLACED ON THE RETURN LIST, WHERE IT WILL BE RETURNED NEXT CLOCK
;TICK, OR, IF WE'RE AT CH7 OR UUO LEVEL IT'S RETURNED AS WE EXIT VIA FSGRT1
FSGTC:	LDB AC2,FSSBYP		;GET THE SIZE OF THIS BLOCK
	SETZ TEM,		;INITIALIZE EXCESS SIZE
	CAIGE AC2,TRIVIAL(AC3)	;IS BLOCK TOO BIG?
	JRST FSGTC1		;NO
	MOVE TEM,AC2		;GET THE SIZE
	SUBI TEM,(AC3)		;GET EXCESS SIZE
	SUBI AC1,(TEM)		;BLOCK ASSIGNED IS LOWER IN CORE
IFN FTFSAVBUG,<
	CAMGE AC1,SYSTOP
	PUSHJ P,FSVBX3
>;IFN FTFSAVBUG
	SETOM (AC1)		;CLAIM IT
	MOVEI AC2,(AC3)		;GET THE SIZE TO USE
	DPB AC2,FSSBYP		;SET SIZE
FSGTC1:	HLLZS (AC1)		;CLEAR RIGHT SIDE OF TOP MARK
	SUBM AC1,AC2		;AC2 GETS ADDRESS BELOW LOWEST
IFN FTFSAVBUG,<
	ADDI AC2,1
	CAMGE AC2,SYSTOP
	PUSHJ P,FSVBX4
	SUBI AC2,1
>;IFN FTFSAVBUG
	PUSH P,TEM
	HRRZ TEM,-NFSACSV-1(P)	;GET FSGET CALLER'S ADDRESS
	SUBI TEM,1
IFN FTFSCALL,<
	PUSH P,AC1
	MOVSI AC1,NFSCSZ	;AOBJN POINTER TO TABLES
FSCLP:	SKIPN FSCADR(AC1)	;ANY MORE CALLERS KNOWN?
	JRST FSCNEW
	CAME TEM,FSCADR(AC1)
	AOBJN AC1,FSCLP		;LOOK THROUGH TABLE FOR KNOWN CALLER
	JUMPGE AC1,FSCEND
FSCNEW:	MOVEM TEM,FSCADR(AC1)
	ADDM AC3,FSCCNT(AC1)
FSCEND:	POP P,AC1
>;IFN FTFSCALL
	IORI TEM,400000		;GENERATE THE "IN USE" BIT
	MOVEM AC1,1(AC2)	;SET UP POINTER IN THE LOW ADDRESS
	HRLM TEM,1(AC2)
	POP P,TEM
;;;;;	HRROM AC1,1(AC2)	;SET UP POINTER IN THE LOW ADDRESS
	JUMPE TEM,FSGTCR	;ALL DONE IF NO SPLIT
	MOVEI AC2,(AC1)
	ADDI AC2,(TEM)		;AC2 POINTS TO EXCESS (HI PART)
	HRLZM TEM,(AC2)		;SET SIZE IN SPLIT BLOCK
	HRRZM AC2,1(AC1)	;STORE POINTER IN BOTTOM OF SPLIT
	CAIGE TEM,NFSB*TRIVIAL	;IS BLOCK VERY BIG?
	JRST FSGTC4		;NO. RETURN THE SPLIT BY THE CLOCK
	JRST FSGTC5		;TAC AND TAC1 WERE SETUP BY FSGCL

;HERE WE TRY TO RELINK THE REMAINDER INTO THE FREE LIST,
;IF THIS FAILS, WE RETURN THE REMAINDER VIA THE RETURN-LIST MECHANISM
FSGTC2:	CONO PI,PICHON(TEM)	;TURN CHANNELS ON AGAIN
FSGTC5:	SKIPG (TAC1)		;LOOK AHEAD
	JRST FSGTC6		;LOSE
	MOVE DAT,-1(TAC1)	;GET BLINK AHEAD
	HRRM DAT,-1(AC2)	;SET BLINK HERE
	HRRM TAC1,(AC2)		;SET FLINK HERE
	CONI PI,TEM		;GET PI STATUS
	ANDI TEM,PICMSK
	CONO PI,PICHOF(TEM)	;TURN OFF CHANNELS
	SKIPLE (TAC1)		;GRABBED FROM UNDER US?
	CAME DAT,-1(TAC1)	;BE SURE
	JRST FSGTC2		;TRY AGAIN
	HRRM AC2,-1(TAC1)	;SET BLINK AHEAD
	HRRM AC2,(DAT)		;SET FLINK BEHIND
	CONO PI,PICHON(TEM)	;TURN ON PI'S AGAIN
	JRST FSGTCR		;RETURN FREE STORAGE.

FSGTC3:	CONO PI,PICHON(TEM)
FSGTC6:	SKIPG DAT,(TAC)
	JRST FSGTC4		;LINK'S HAVE MOVED
	HRRM DAT,(AC2)		;SET FLINK HERE
	HRRM TAC,-1(AC2)	;SET BLINK HERE
	CONI PI,TEM
	ANDI TEM,PICMSK
	CONO PI,PICHOF(TEM)
	CAME DAT,(TAC)		;THESE GUYS STILL THE SAME?
	JRST FSGTC3		;LINKS HAVE MOVED. TRY AGAIN
	HRRM AC2,-1(DAT)	;SET BLINK AHEAD
	HRRM AC2,(TAC)		;SET FLINK BEHIND
	CONO PI,PICHON(TEM)
	JRST FSGTCR		;RETURN BLOCK

FSGTC4:	MOVSI TAC,400000
	IORM TAC,(AC2)
	LDB TAC,FSSBP1
	SUBM AC2,TAC
IFN FTFSAVBUG,<
	ADDI TAC,1
	CAMGE TAC,SYSTOP
	PUSHJ P,FSVBX5
	SUBI TAC,1
>;IFN FTFSAVBUG
	HRROM AC2,1(TAC)
	PUSH P,AC1
	MOVEI AC1,2(TAC)
	PUSHJ P,FSQUIK		;ADD BLOCK TO FSRTL.
	POP P,AC1
FSGTCR:	LDB TAC,FSSBYP		;GET THE SIZE
IFN FTHIFS,<
	CAML AC1,FSLIM9
	ADDM TAC,HFSBSY		;FIX CORRECT COUNT
	CAMGE AC1,FSLIM9	;SKIP IF BLOCK IS IN HIGH FS
>;IFN FTHIFS
	ADDM TAC,FSBUSY		;ADD TO CLAIMED AMOUNT.
	SUBI AC1,-2(TAC)	;COMPUTE LOWEST USABLE ADDRESS
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB TABLE
>;IFN FTFSAVBUG
	CONSO PI,77000		;SKIP IF AT HI PI CHANNEL (ABOVE CHANNEL 7)
	SKIPN FSRTL		;LOW CHANNEL. SKIP IF ANY COMING BACK
	JRST FSGRT1		;NOTHING TO DO OR MUST RETURN QUICK
	PUSH P,AC1
	PUSHJ P,FSCKX		;GIVE IT BACK TO THE INDIANS
	POP P,AC1
FSGRT1:	JSP DAT,FSACRS		;RESTORE ACS
	PUSH P,[FSGET]		;IN CASE OF TROUBLE TRY AGAIN
	SETOM FSCFLG
	PUSHJ P,FSECHK		;IN CASE OF ERROR, RETURNS UPLEVEL (to FSGET)
	POP P,(P)		;DON'T NEED TO RETURN TO FSGET AFTER ALL
	JRST CPOPJ1		;GIVE SKIP RETURN FOR SUCCESS

;HERE IF WE COULDN'T FIND ANY FREE STORAGE.
FSGTW:	TDZA AC1,AC1		;NORMAL ENTRY
FSGTWX:	MOVEI AC1,1		;ENTRY FOR NEED PAGE ON A PAGE BOUNDARY
	PUSHJ P,FSGETK		;WE NEED ANOTHER PAGE, GET IT
	JRST FSGTW5		;CAN'T GET ANOTHER PAGE
	PUSH P,J		;SAVE J (CLBBD BY FSWAKE)
	PUSHJ P,FSWAKE		;WAKE SOMEONE WHO WAITS
	POP P,J
	JRST FSGETT		;FSGET RETRY THIS ONE

FSGTW5:	CONSO PI,77400		;ARE WE AT I-LEVEL?
	SKIPGE FSGTUF		;NOT I-LEVEL, WANT TO RETURN QUICK?
	JRST FSGFAI		;GIVE THE NON-SKIP RETURN
	SKIPN JOB		;If called from initialization context,
	JRST FSGFAI		;JOB is zero, and we can't wait for anything.
	SKIPE INTACT		;IF YOU'RE AT USER I-LEVEL YOU'LL
	JRST WSCHED		;BE KICKED OUT BY WSCHED....
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB
>;IFN FTFSAVBUG
	AOS NFSWAITS		;COUNT A WAIT
	PUSH P,J		;SAVE J ON THE STACK
	MOVE J,JOB		;GET THE JOB NUMBER
	HRL J,AC3		;GET THE SIZE OF REQUEST
	MOVEM J,@FSIPTR		;SAVE IN OUR QUEUE OF JOBS
	AOS TAC,FSIPTR		;INCREMENT THE POINTER
	CAIL TAC,FSLIST+JOBN
	MOVEI TAC,FSLIST
	MOVEM TAC,FSIPTR
	AOS FSCNT
;;;	System would become wedged by LOGOUT running at infinite priority
;;;	waiting for FS to be freed, which won't happen if no one else runs.
	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)	;SET QUEUE FOR THIS JOB
	PUSHJ P,REQUE		;REQUEUE THIS JOB
	PUSHJ P,WSCHED		;CALL CH7 TO RESCHEDULE JOB
	SETZM FSGTUF		;ZERO THIS CELL SO IF WE FAIL AGAIN, WE WAIT
;HERE EVENTUALLY AFTER FSWAKE
	PUSHJ P,FSWAKE		;WAKE SOMEONE ELSE
	POP P,J			;RESTORE J, FINALLY.
IFN FTHIFS,<
	MOVEI AC1,0		;IN CASE ANOTHER REQUEST HAPPENED MEANTIME
>;IFN FTHIFS
	JRST FSGETT		;PLAY IT AGAIN, SAM.

FSGFAI:
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB
>;IFN FTFSAVBUG
	JSP DAT,FSACRS		;RESTORE AC'S
	AOS NFSGFA		;COUNT A FAILURE
	POPJ P,			;CRY

FSGLUZ:	HRRZ AC1,(P)		;GET RETURN ADDRESS
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ / FSGET CALLED ILLEGALLY FROM PI CHANNEL 1 OR 2
RETURN ADDRESS = /]
	DISARG ( LOC,<AC1-20(P)> )
	[ASCIZ /
/]
	-1
	POPACS
	POPJ P,
;FSGETK FSGTKZ FSGTKQ FSGTKY FSSWAP FSWP3A FSSWP3 FSWAKE FSWAK1

;SWIPE A PAGE FROM AVAILABLE USER SPACE.  FSGETK
;THIS CAN BE DONE ONLY AT CLOCK OR UUO LEVEL.
;IT SETS THE FOLLOWING GLOBAL VALUES:
; LOFREE		NUMBER OF FREE PAGES BELOW FSLIMIT
; USRMAX		MAXIMUM NUMBER OF WORDS A JOB MAY HAVE (CLIPS AT 776000)
; CORMAX		TOTAL NUMBER OF WORDS ABOVE FS (NOT INCLUDING IO PAGES)
; FSTOP			FIRST PAGE ABOVE FREE STORAGE

FSGETK:	CONSO PI,77000		;SKIP IF PI IN PROGRESS (EXCEPT CLKCHN)
	JRST FSGTKZ		;CH7 OR UUO LEVEL. JUMP IF P1 (TO HISYS)
	POPJ P,			;CAN'T DO THIS ABOVE CH7 OR ON P2

HISYS

FSGTKZ:	MOVE TAC,FSPAG		;GET PAGE NUMBER WE WANT
	CAMN TAC,FSLIMIT
	JRST FSGTKY
FSGTKQ:	PUSHJ P,CORGB1		;MAKE A BYTE POINTER TO CORTAB
	LDB TAC1,TAC		;PICK UP MARK BIT FOR THIS BLOCK
	JUMPN TAC1,FSSWAP	;JUMP IF CLAIMED AND FORCE USER OUT
	MOVEI TAC1,FSCUS	;CLAIM THIS BLOCK!
	DPB TAC1,TAC		;STUFF OUR CLAIM BIT IN
	MOVNI TAC,1000		;UPDATE GLOBAL CELLS
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
	MOVEI TAC,1000
	ADDM TAC,FSTOP		;FIRST WORD ABOVE FREE STORAGE
	AOS TAC1,FSPAG		;FREE STORAGE IS ONE PAGE BIGGER
	SUBI TAC1,1		;TAC1 IS NEW FS PAGE
	CAMGE TAC1,FSLIMIT
	SOSA LOFREE		;ONE FEWER FREE PAGES BELOW FSLIMIT
	SOS HIFREE		;IN CASE WE SCREW UP AND GO PAST FSLIMIT
NOKL10,<CAIL TAC1,600		;is this page in the PSB?
	ADDI TAC1,PSB-EXPGT	;yes, adjust offset to work from EXPGT into PSB
>;NOKL10
	PUSHJ P,ADDEVP		;ADD PHYSICAL PAGE = VIRTUAL PAGE
IFKL10,<
	PUSHJ P,SWEEPA		;MAKE SURE CACHE DOESN'T GET ANY
>;IFKL10

IFN FTCORBUG,< PUSHJ P,CORCHK >	;CHECK VALIDITY OF CORE TABLES.

	PUSH P,DSER
	PUSH P,UCHN
	PUSH P,AC1
	PUSH P,AC3
	PUSHJ P,DIDLE4		;SET UP SWAPPER PARAMTERS
	MOVE AC1,FSTOP
	SUBI AC1,1		;POINTER TO LAST WORD OF PAGE
	MOVSI TAC,401000	;SET UP SIZE AND USE BIT
	MOVEM TAC,(AC1)		;STUFF IN BLOCK HEADER
	HRROM AC1,-777(AC1)
	MOVEI AC1,-776(AC1)
	PUSHJ P,FSGIVX		;GIVE BACK A 1K BLOCK (MERGES)
	POP P,AC3
	POP P,AC1
	POP P,UCHN
	POP P,DSER
	SETZM FSGVKF		;FLUSH WARNING ABOUT BOTTOM K.
	JRST CPOPJ1		;GIVE A SKIP RETURN FROM FSGETK

FSGTKY:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /FSTOP IS ABOUT TO EXCEED FSLIMIT AT FSGETK
/
IFN FTFSCALL,<
	PUSHJ P,DISMES
	ASCIZ/The arrays FSCADR and FSCCNT tell who is using how much FS
/
>;IFN FTFSCALL (FOR WIZARDS WHO FORGET WHAT THE NAMES ARE)
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCALL
	POPJ P,

;ROUTINE TO FORCE THE JOB AT TOP OF CORE OUT.

FSSWAP:	MOVE TAC,FSPAG
	PUSHJ P,CORGB1
	PUSH P,J		;DON'T CLOBBER J
	LDB J,TAC		;GET JOB NUMBER OF THE GUY TO FORCE
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		;IS HE IN MOTION?
	JRST FSWP3A		;CAN'T DO HIM NOW.
	HLRZ TAC,JBTPAG(J) 
	SKIPN XJOB(J)
	PUSHJ P,XPAND		;MAKE HIM GET SHOVED OUT
FSWP3A:	POP P,J			;RESTORE J
FSSWP3:	SETOM FSCLKF		;TELL FSCLK TO THINK ABOUT GOBBLING
	SETOM FSNCLK		;TELL CLKSER TO RUN FSCLK
	POPJ P,			;AND RETURN


; THIS ROUTINE REQUEUES A JOB WHEN CORE IS AVAILABLE FOR HIM.

FSWAKE:	SYSPIFF
	SKIPLE FSCNT		;ANYONE THERE?
	JRST FSWAK1		;YES
	SETZM FSCNT
	SYSPIN
	POPJ P,			;NO WORK FOR NO ONE

FSWAK1:	SOS FSCNT		;DECREASE NUMBER OF WAITERS
	SYSPIN
	HRRZ J,@FSOPTR		;GET JOB NUMBER TO REQUEUE
	AOS TAC,FSOPTR
	CAIL TAC,FSLIST+JOBN
	MOVEI TAC,FSLIST
	MOVEM TAC,FSOPTR
	SKIPL JBTSTS(J)		;IS THIS GUY STILL RUNABLE?
	JRST FSWAKE		;NO. TRY ANOTHER ONE.
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)	;SET QUEUE FOR THIS JOB
	JRST REQUE		;REQUEUE THIS JOB
;FSHGTK FSHGK9 FSHGK0 FSHGK1 FSHEVM FSHSWP FSHP3A FSHWP3

IFN FTHIFS,<

;SWIPE A PAGE FROM AVAILABLE USER SPACE.  FSHGTK
;THIS CAN BE DONE ONLY AT CLOCK OR UUO LEVEL.
;IT SETS THE FOLLOWING GLOBAL VALUES:
; HIFREE		NUMBER OF FREE PAGES ABOVE FSLIMIT
; USRMAX		MAXIMUM NUMBER OF WORDS A JOB MAY HAVE (CLIPS AT 776000)
; CORMAX		TOTAL NUMBER OF WORDS ABOVE FS (NOT INCLUDING IO PAGES)

FSHGTK:	PUSH P,DSER
	MOVE TAC1,HIFSEV	;THIS IS THE VIRTUAL PAGE NUMBER WE'LL USE
	CAIL TAC1,TOPHIP	;WILL ADDEMP LET US HAVE IT?
	JRST FSHEVM		;NO, ERROR
	MOVEI TAC1,0		;THIS WILL KEEP TRACK OF A JOB PAGE TO TRY FOR
	MOVE DSER,FSLIMIT
FSHGK9:	LDB TAC,COREP
	JUMPE TAC,FSHGK1	;JUMP IF FREE
	CAIL TAC,JOBN
	JRST FSHGK0		;JUMP IF IN USE BY SYSTEM OR NXM
	JUMPN TAC1,FSHGK0	;IN USE BY JOB, JUMP IF WE ALREADY HAVE ONE OF THOSE
	MOVE TAC,JBTSTS(TAC)	;IN USE BY JOB, IS IT LOCKED?
	TRNN TAC,JLOCK
	MOVEI TAC1,(DSER)	;NO, SAVE PAGE NUMBER
FSHGK0:	ADDI DSER,1		;TRY ANOTHER PAGE
	CAIGE DSER,GOODPG	;IF ANY
	JRST FSHGK9
	POP P,DSER
	SKIPE TAC,TAC1		;DID WE FIND A USER PAGE, AT LEAST?
	JRST FSHSWP		;YES, FLUSH THE JOB WHICH IS IN THE WAY
	POPJ P,			;SORRY, NONE AVAILABLE

FSHGK1:	SETZM FSHJOB		;NO LONGER SWAPPING OUT A JOB
	MOVEI TAC1,FSCUS	;CLAIM THIS BLOCK!
	DPB TAC1,COREP		;STUFF OUR CLAIM BIT IN
	MOVNI TAC,1000		;UPDATE GLOBAL CELLS
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
	SOS HIFREE		;ONE HIGH PAGE TAKEN
	MOVEI TAC,(DSER)	;PHYSICAL PAGE
	AOS TAC1,HIFSEV		;USE NEXT FREE EXEC VIRTUAL PAGE
	SUBI TAC1,1
NOKL10,<CAIL TAC1,600
	ADDI TAC1,PSB-EXPGT	;THIS VIRTUAL PAGE IS IN THE PSB
>;NOKL10
	PUSHJ P,ADDEMP		;ADD PAGE
IFKL10,<
	PUSHJ P,SWEEPA		;MAKE SURE CACHE DOESN'T GET ANY
>;IFKL10

IFN FTCORBUG,< PUSHJ P,CORCHK >	;CHECK VALIDITY OF CORE TABLES.

	PUSH P,UCHN
	PUSH P,AC1
	PUSH P,AC3
	PUSH P,DSER
	PUSH P,TAC1		;SAVE VIRTUAL PAGE
	PUSHJ P,DIDLE4		;SET UP SWAPPER PARAMTERS
	MOVE AC1,(P)		;GET TARGET PAGE NUMBER
	LSH AC1,9
	ADDI AC1,777		;POINTER TO LAST WORD OF PAGE
	MOVSI TAC,401000	;SET UP SIZE AND USE BIT
	MOVEM TAC,(AC1)		;STUFF IN BLOCK HEADER
	HRROM AC1,-777(AC1)
	MOVEI AC1,-776(AC1)
	PUSHJ P,FSGIVX		;GIVE BACK A 1K BLOCK (MERGES)
	POP P,TAC1
	POP P,DSER
	POP P,AC3
	POP P,AC1
	POP P,UCHN
	POP P,DSER		;ONE MORE POP OF DSER
	SOSLE FSHCLK		;COUNT ONE REQUESTED PAGE GOTTEN
	JRST FSHGTK		;JUMP IF STILL MORE TO GET
	JRST CPOPJ1		;GIVE A SKIP RETURN FROM FSHGTK

FSHEVM:	SETZM FSHCLK		;CAN'T GET ANY MORE HIGH FS, NO MORE EXEC SPACE
	POP P,DSER
	CAIN TAC1,TOPHIP	;IS THIS THE FIRST FAILURE?
	AOS HIFSEV
	POPJ P,

;ROUTINE TO FORCE THE JOB AT TOP OF CORE OUT.

FSHSWP:	SKIPE FSHJOB		;HAVE WE ALREADY ASKED FOR A JOB TO GO OUT?
	JRST FSHWP3		;YES, DON'T BE PIGGY
	PUSHJ P,CORGB1
	PUSH P,J		;DON'T CLOBBER J
	LDB J,TAC		;GET JOB NUMBER OF THE GUY TO FORCE
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		;IS HE IN MOTION?
	JRST FSHP3A		;CAN'T DO HIM NOW.
	MOVEM J,FSHJOB		;RECORD WHICH JOB WE'RE DOING
	HLRZ TAC,JBTPAG(J) 
	SKIPN XJOB(J)
	PUSHJ P,XPAND		;MAKE HIM GET SHOVED OUT
FSHP3A:	POP P,J			;RESTORE J
FSHWP3:	SETOM FSNCLK		;TELL CLKSER TO RUN FSCLK
	POPJ P,			;AND RETURN

>;IFN FTHIFS
;FSCLK FSCKY FSCLK1 FSGVK1 FSGVK3 FSCKZ FSCLK3 FSCLK4 FSCKX

;FSCLK:	CLOCK LEVEL (CHANNEL 7) ROUTINES TO KEEP FREE STORAGE HAPPY!
;CALLED FROM CLKSER, NEAR CALL ON DPYCLK

↑FSCLK:	SETZM FSNCLK		;WE HAVE GOTTEN SERVICE. SHUT OFF FLAG.
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB
>;IFN FTFSAVBUG
	PUSHJ P,FSCKX		;RETURN CONTENTS OF FSRTL.
IFN FTHIFS,<
	SKIPLE FSHCLK		;NEED TO GET SOME HIGH FS?
	PUSHJ P,FSHGTK		;YES, DO IT
	 JFCL			;NOPE
	SKIPLE FSHCLK		;STILL NEED SOME?
	SETOM FSNCLK		;YES, COME BACK NEXT TICK
>;IFN FTHIFS
FSCKY:	SKIPN FSCLKF		;ARE WE WAITING FOR THE SWAPPER?
	JRST FSCLK1		;NO. SKIP THIS MESS
	SETZM FSCLKF
	PUSHJ P,FSGETK		;LOOK FOR THE 1K WE WANTED.
	JRST FSCKZ		;THERE WASN'T ANY THERE FOR US
	PUSHJ P,FSWAKE		;ATTEMPT TO WAKE A WAITER.
	JRST FSCKZ		;AVOID ATTEMP TO GIVE BACK 1K

FSCLK1:	SKIPN FSGVKF		;MAYBE THERE'S A 1K BLOCK TO GIVE BACK?
	JRST FSCKZ		;NOPE.
	MOVE TAC,FSPAG
	SUBI TAC,1
	PUSHJ P,CORGB1		;COMPUTE BYTE POINTER TO FIRST FS BLOCK
	LDB TAC,TAC		;GET THE CORTAB ENTRY
	CAIE TAC,FSCUS		;IS IT A REGULAR FREE BLOCK?
	JRST FSCKZ		;NO, CAN'T RETURN IT TO USERS
	SETZM FSGVKF
	MOVE AC1,FSTOP
	SUBI AC1,1		;POINTER TO TOP OF TOP BLOCK
	LDB AC3,FSSBYP		;GET THE SIZE FIELD
	CAIGE AC3,1000		;SKIP IF BIG ENOUGH
	JRST FSCKZ
	PUSHJ P,FSGCL		;ATTEMPT TO CLAIM THIS BLOCK
	JRST FSCKZ		;LOSE
	LDB AC3,FSSBYP		;GET THE SIZE
	MOVEI TEM,(AC1)		;GET THE BLOCK ADDRESS
	SUBI TEM,-1(AC3)	;GET THE BOTTOM ADDRESS
IFN FTFSAVBUG,<
	CAMGE TEM,SYSTOP
	PUSHJ P,FSVBX6
>;IFN FTFSAVBUG
	HRROM AC1,(TEM)		;CLAIM THE BOTTOM
	MOVE TAC,FSTOP
	SUBI TAC,1
	CAIL AC3,1000		;SKIP IF SMALLER THAN A BREADBOX
	CAME AC1,TAC		;BIG ENOUGH. AT TOP?
	JRST FSGVK3		;NO. GIVE IT ALL BACK.
	SUBI AC3,1000		;FIGURE SIZE OF NEW BLOCK
	JUMPE AC3,FSGVK1	;THERE'S NOTHING TO SPLIT
	MOVEI AC1,-1000(AC1)	;POINT TO PIECE LEFT OVER BELOW THE 1000
IFN FTFSAVBUG,<
	CAMGE AC1,SYSTOP
	PUSHJ P,FSVBX7
>;IFN FTFSAVBUG
	SETOM (AC1)		;MAKE IT LOOK CLAIMED
	HRROM TAC,1(AC1)	;MAKE 1000 WD PIECE LOOK DECENT TOO
	DPB AC3,FSSBYP		;SET SIZE FIELD IN BLOCK
	SUBM AC1,AC3		;GET THE BOTTOM ADDRESS
IFN FTFSAVBUG,<
	ADDI AC3,1
	CAMGE AC3,SYSTOP
	PUSHJ P,FSVBX8
	SUBI AC3,1
>;IFN FTFSAVBUG
	HRROM AC1,1(AC3)	;SET THE BOTTOM MARK
	MOVEI AC1,2(AC3)	;GET THE ADDRESS FOR FSGIVE
	PUSHJ P,FSGIVX		;GIVE BACK THIS PART OF THE AC1
FSGVK1:	MOVNI TAC,1000
	ADDM TAC,FSTOP
	MOVEI TAC,1000		;MORE CORE FOR USERS
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
	SOS DSER,FSPAG
	CAMGE DSER,FSLIMIT
	AOSA LOFREE
	AOS HIFREE		;IN CASE WE SCREWED UP
	MOVEI TAC1,(DSER)
NOKL10,<CAIL TAC1,600
	ADDI TAC1,PSB-EXPGT
>;NOKL10
	PUSHJ P,DELEMP		;DELETE PAGE FROM EXEC MAP
	PUSHJ P,CORGBP
	MOVEI TAC1,0
	DPB TAC1,TAC
	PUSHJ P,DIDLE4
	SETOM FSGVKF		;FLAG FOR NEXT TICK JUST IN CASE 
	JRST FSCKZ

FSGVK3:	MOVEI AC1,1(TEM)	;GET THE BOTTOM DATA WORD ADDRESS
	PUSHJ P,FSGIVX		;GIVE BACK THIS BLOCK!
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB
>;IFN FTFSAVBUG
FSCKZ:
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB
>;IFN FTFSAVBUG
	SKIPLE FSCKCT		;TIME TO DO CHECKERBOARD?
	JRST FSCLK3		;NO.
	MOVE AC1,FSTOP
	SUB AC1,SYSTOP
	SUB AC1,FSBUSY
	CAILE AC1,5000		;SKIP IF LESS THAN 2.5 FREE
	JRST FSCLK4		;TOO MUCH IS FREE.
	MOVEI AC1,=30*JIFSEC	;LOOK AGAIN IN 30 SECONDS.
	MOVEM AC1,FSCKCT
FSCLK3:	POPJ P,

FSCLK4:	MOVEI AC1,=10*JIFSEC
	MOVEM AC1,FSCKCT
	JRST RELEX		;RELEASE SPARES.

LOSYS

FSCKX:	SKIPN FSRTL		;ANY ONE ON THE RETURN LIST?
	POPJ P,			;NO. RETURN
	SYSPIFF		;DON'T INTERRUPT
	HRRZ AC1,FSRTL		;GET THE FORWARD LINK
	MOVE TAC,(AC1)		;GET THE NEXT FLINK
	HRRZM TAC,FSRTL		;SAVE IT HERE
	SYSPIN		;TURN ON THE PI'S
	LDB TAC,FSSBYP		;GET THE SIZE FIELD
	SUBI AC1,-2(TAC)	;GET THE ADDRESS OF LOWEST DATA WORD
	PUSHJ P,FSGIVX		;ALL SET TO GIVE THE BLOCK BACK AGAIN
IFN FTFSAVBUG,<
	PUSHJ P,FSVBCK		;CHECK FSAVB
>;IFN FTFSAVBUG
	JRST FSCKX		;LOOK FOR MORE
;CALLING FSECHK FSCLP1 FSCEN1 FSECK0 FSECK1 FSECK2 FSECK3 FSECK4 FSECK5 FSECK6 FSECKX FSGIVE FSGIH0 FSGIVX FSGIVY FSGV0 FSGV1 FSGV2 FSGV2A FSGV5 FSGV61 FSGV6 FSGV7 FSGV8 FSXPOP FSPOP FSQUIK FSQUK1 FSVBCK FSVBC1 FSVBC2 FSVBC3 FSVBE1 FSVBE2 FSVBE3 FSVBE4 FSVBE0 FSVBX1 FSVBX2 FSVBX3 FSVBX4 FSVBX5 FSVBX6 FSVBX7 FSVBX8 FSVBXT FSVBXY FSVBXZ

;RETURN FREE STORAGE TO SYSTEM.

COMMENT $


CALLING:
	MOVE AC1,<ADDRESS OF BLOCK>
	PUSHJ P,FSGIVE
	<RETURN HERE ALWAYS>

FSGIVX IS ROUTINE FOR FSGIVE THAT DOESN'T SAVE AC'S 
USE THIS ONLY INSIDE OF FS ROUTINES!

$


FSECHK:	PUSH P,AC1		;SAVE AC'S FOR A WHILE.
	PUSH P,AC3		;SAVE.
IFE FTHIFS,<
	CAMGE AC1,FSTOP
	CAMG AC1,SYSTOP
	JRST FSECK0		;OUT OF BOUNDS
>;IFE FTHIFS
IFN FTHIFS,<
	PUSH P,DSER
	LDB DSER,[POINT 9,AC1,26] ;GET BLOCK'S PAGE NUMBER
NOKL10,<
	CAIL DSER,600
	ADDI DSER,PSB-EXPGT	;PAGE IS IN PSB
>;NOKL10
	LDB DSER,[POINT 13,EXPGT(DSER),35];VIRTUAL TO PHYSICAL
	LDB DSER,COREP		;GET USE CODE
	CAIE DSER,FSCUS		;FS PAGE?
	JRST [POP P,DSER ↔ JRST FSECK0] ;NO, OUT OF BOUNDS
	POP P,DSER
>;IFN FTHIFS
	SUBI AC1,1
	TRNE AC1,TRIVIAL-1	;ALL THESE BITS MUST BE OFF!
	JRST FSECK1		;BAD ALLIGNMENT
	MOVE AC3,(AC1)		;GET BOTTOM LINK
;	TLC AC3,-1
;	TLNE AC3,-1
;	JRST FSECK2			;BOTTOM LINK  LEFT HALF NOT -1
	JUMPGE AC3,FSECK2	;BOTTOM LINK LEFT HALF NOT NEGATIVE
	HRRZ AC3,AC3
IFE FTHIFS,<
	CAMGE AC3,FSTOP
	CAMG AC3,SYSTOP
	JRST FSECK3		;BOTTOM LINK POINTS TO GARBAGE
>;IFE FTHIFS
IFN FTHIFS,<
	PUSH P,DSER
	LDB DSER,[POINT 9,AC3,26] ;GET LINK'S PAGE NUMBER
NOKL10,<
	CAIL DSER,600
	ADDI DSER,PSB-EXPGT	;PAGE IS IN PSB
>;NOKL10
	LDB DSER,[POINT 13,EXPGT(DSER),35];VIRTUAL TO PHYSICAL
	LDB DSER,COREP		;GET USE CODE
	CAIE DSER,FSCUS		;FS PAGE?
	JRST [POP P,DSER ↔ JRST FSECK0] ;NO, OUT OF BOUNDS
	POP P,DSER
>;IFN FTHIFS
	CAIG AC3,(AC1)
	JRST FSECK4		;BOTTOM LINK POINTS BELOW BOTTOM WORD.
	TRC AC3,TRIVIAL-1
	TRCE AC3,TRIVIAL-1
	JRST FSECK5		;BAD ALIGNMENT ON TOP BLOCK
IFN FTFSCALL,<
	PUSH P,AC1
	PUSH P,TEM
	AOSN FSCFLG
	JRST FSCEN1		;DON'T DO IT WHEN GETTING BLOCK
	HLRZ TEM,(AC1)		;CALLER
	ANDI TEM,377777
	HRROS (AC1)		;IF WE COME THROUGH AGAIN WE'LL ABORT
	MOVSI AC1,NFSCSZ	;AOBJN POINTER TO TABLES
FSCLP1:	SKIPN FSCADR(AC1)	;ANY MORE CALLERS KNOWN?
	JRST FSCEN1		;NO, FORGET IT
	CAME TEM,FSCADR(AC1)
	AOBJN AC1,FSCLP1	;LOOK THROUGH TABLE FOR KNOWN CALLER
	JUMPGE AC1,FSCEN1
	HLRZ TEM,(AC3)
	ANDI TEM,377777
	EXCH TEM,FSCCNT(AC1)
	SUBM TEM,FSCCNT(AC1)	;GIVE IT BACK
FSCEN1:	POP P,TEM
	POP P,AC1
>;IFN FTFSCALL
	HLRZ AC1,(AC3)		;GET 400000+SIZE OF THIS BLOCK
	SUBI AC3,-400002(AC1)	;MAKE POINTER TO 1 ABOVE THE BOTTOM
	CAME AC3,-1(P)		;MAKE SURE THESE ARE THE SAME.
	JRST FSECK6		;ALLEDGED TOP DOESN'T POINT TO BOTTOM.
	POP P,AC3
	POP P,AC1
	POPJ P,

FSECK0:	JSP AC1,FSECKX		;ERROR 0 - OUT OF BOUNDS
FSECK1:	JSP AC1,FSECKX		;ERROR 1 - BAD ALIGNMENT
FSECK2:	JSP AC1,FSECKX		;ERROR 2 - BOTTOM LINK LEFT HALF NOT -1
FSECK3:	JSP AC1,FSECKX		;ERROR 3 - BOTTOM LINK POINTS OUTSIDE FS
FSECK4:	JSP AC1,FSECKX		;ERROR 4 - BOTTOM LINK POINTS BELOW ITSELF
FSECK5:	JSP AC1,FSECKX		;ERROR 5 - BOTTOM LINK MISALIGNED
FSECK6:	JSP AC1,FSECKX		;ERROR 6 - TOP DOESN'T POINT TO BOTTOM.
FSECKX:	SUBI AC1,FSECK0+1	;NORMALIZE
	HRRZ AC1,AC1
	PUSHACS	
	PUSH P,AC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /RELEASE OF NON-EX FREE STORAGE BLOCK. BLOCK = /
	MOVE TAC,-22(P)		;REACH BACK AND PULL UP STINKING MESS.
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
CALLER'S ADDRESS = /
	MOVE TAC,-24(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /;  ERROR CODE = /
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH	;MAKE SURE WE CAN SEE MESSAGE.
	POPACS
	PUSHJ P,WDDTCAL
	POP P,AC3		;Restore ACs pushed by FSECHK
	POP P,AC1
	POP P,(P)		;THROW OUT RETURN FROM FSCHEK
	POPJ P,			;RETURN TO BASTARD WHO CALLED ME.

↑FSGIVE:ANDI AC1,-1		;FLUSH LEFT HALF
	PUSHJ P,FSECHK		;CHECK FOR WINNING ADDRESSES
IFKL10,<CAME AC1,TO11QH		;Bugtrap for KLSER, catch FS return of queued block
	CAMN AC1,TO11QT		;just check against head and tail of to-11 queue
	JRST FSGV11		;jump into KLSER for bugtrap
>;IFKL10
	AOS NFSGIVES		;INCREMENT COUNT OF GIVES
IFN FTHIFS,<
	CAMGE AC1,FSLIM9	;LOW FS BLOCK?
	PUSH P,[FSBUSY]		;YES, SAVE CELL TO FIX UP
	CAML AC1,FSLIM9
	PUSH P,[HFSBSY]		;DON'T DIDDLE FSBUSY FOR HIGH FS
>;IFN FTHIFS
	PUSH P,AC1		;SAVE THIS FOR A WHILE.
	HRRZ AC1,-1(AC1)	;GET THE TOP ADDRESS
	LDB AC1,FSSBYP		;GET THE SIZE
	MOVN AC1,AC1		;GET -SIZE
IFE FTHIFS,<
	ADDM AC1,FSBUSY		;DECREASE BUSY COUNT
>;IFE FTHIFS
IFN FTHIFS,<
	ADDM AC1,@-1(P)		;ADD TO FSBUSY OR HFSBSY
>;IFN FTHIFS
	POP P,AC1		;RESTORE AC1
IFN FTHIFS,<
	POP P,(P)		;FLUSH COUNT CELL POINTER FROM PDL
>;IFN FTHIFS
FSGIH0:	CONSZ PI,77000		;SKIP IF WE'RE NOT IN CHANNELS 1-6
	JRST FSQUK1		;DO THE QUICK STUFF!
	PUSHJ P,FSACSV		;SAVE AC'S
	PUSHJ P,FSGIVY		;NOW GO GIVE BACK FREE STORAGE
	JSP DAT,FSACRS		;RESTORE AC'S
	POPJ P,			;RETURN

FSGIVX:	PUSHJ P,FSECHK		;CHECK FOR ERROR.
	CONSZ PI,77000		;SKIP IF AT LOW LEVEL
	JRST FSQUK1		;AT HI CHANNEL GIVE BACK QUICK
FSGIVY:	PUSH P,AC1		;SAVE AC1
	MOVEI AC2,-2(AC1)	;AC2 ← HIGH ADDRESS OF LOWER BLOCK
	HRRZ AC1,-1(AC1)	;BLOCK SET TO TOP WORD OF THIS BLOCK
	LDB TAC,[POINT 9,AC2,26]
	PUSHJ P,CORGB1		;BYTE POINTER TO CORTAB
	LDB TAC,TAC
IFN FTHIFS,<
	MOVEI TEM,1(AC2)	;BOTTOM OF THE BLOCK WE'RE RETURNING
	CAME TEM,FSLIM9		;DON'T JOIN HIGH AND LOW BLOCKS!
>;IFN FTHIFS
	CAIE TAC,FSCUS		;SKIP IF BLOCK IS ABOVE AN FS AREA.
	JRST FSGV1		;NO.  EITHER AT BOTTOM OF FS OR ABOVE PMAP
	PUSH P,AC1		;SAVE BLOCK TOP!
	MOVE AC1,AC2		;GET THE ADDRESS OF LOWER
	LDB AC3,FSSBYP		;GET SIZE OF LOWER BLOCK
	PUSHJ P,FSGCL		;ATTEMPT TO CLAIM LOWER
	 JRST FSGV0		;POP AC1 AND FORGET ABOUT LOW MERGE
	LDB TEM,FSSBYP		;GET THE SIZE
	MOVEI DAT,(AC1)
	SUBI DAT,(TEM)		;GET THE BOTTOM ADDRESS - 1
	POP P,AC1		;GET ADDRESS OF TOP OF BIG BLOCK
	LDB TAC1,FSSBYP		;GET SIZE OF ORIGINAL
	ADD TEM,TAC1		;SUM THEM
	DPB TEM,FSSBYP		;STUFF THEM IN THE ORIGINAL
	HRROM AC1,1(DAT)	;SAVE A BOUNDARY MARKER.
	JRST FSGV1

FSGV0:	POP P,AC1		;GET THE TOP OF THIS BLOCK BACK.
FSGV1:	MOVEI TAC,(AC1)		;GET ADDRESS OF GUY ABOVE
	ADDI TAC,1		;(SINCE MOVEI TAC,1(AC1) MIGHT OVERFLOW)
IFN FTHIFS,<
	CAMN TAC,FSLIM9
	JRST FSGV2A		;DON'T MERGE HI AND LO BLOCKS
>;IFN FTHIFS
	LSH TAC,-9
IFN FTHIFS,<
	CAIL TAC,GOODPG		;IF WE HAVE HIGH FS,
	JRST FSGV2A		;THIS MIGHT BE THE TIPPY TOP OF CORE
>;IFN FTHIFS
	PUSHJ P,CORGB1		;GET A BYTE POINTER INTO TAC
	LDB TAC,TAC		;GET CORTAB BYTE
	CAIE TAC,FSCUS		;SKIP IF NEXT HIGHER ADDRESS IS IN FS.
	JRST FSGV2A		;ABOVE THIS BLOCK IS NOT MORE FS.
	CONI PI,DAT
	ANDI DAT,PICMSK
	CONO PI,PICHOF(DAT)	;STOP CHANNELS 3-7
	HRRZ AC2,1(AC1)		;GET THE BOTTOM POINTER
	SKIPG TAC,(AC2)		;GET THE FLINK
	JRST FSGV2		;ALL A BAD IDEA.
	MOVE TAC1,-1(AC2)	;GET THE BLINK
	HRRM TAC1,-1(TAC)	;GO FORWARD AND STUFF BLINK
	HRRM TAC,(TAC1)		;GO BACK AND SET FLINK
	CONO PI,PICHON(DAT)	;ALLOW INTERRUPTS AGAIN
	MOVSI DAT,400000
	IORM DAT,(AC2)		;CLAIM THIS BLOCK.
	LDB TAC,FSSBP1		;GET THE SIZE OF THIS GUY
	LDB AC3,FSSBYP
	ADD AC3,TAC
	MOVE DAT,AC2
	SUB DAT,AC3		;COMPUTE THE BOTTOM ADDRESS
	DPB AC3,FSSBP1
	HRROM AC2,1(DAT)
	SKIPA AC1,AC2
FSGV2:	CONO PI,PICHON(DAT)
FSGV2A:	LDB AC3,FSSBYP
	LSH AC3,1-TSHF		;SHIFT SIZE TO MAKE INDEX.
	SUBI AC3,2		;FIX INDEX.
	CAIL AC3,NFSB*2		;REASONABLE INDEX?
	MOVEI AC3,NFSB*2-2	;NO. FIX INDEX.
	JRST FSGV61

FSGV5:	CONO PI,PICHON(TAC1)	;MAKE SURE PI'S GET RESTORED
FSGV61:
IFN FTHIFS,<
	JUMPL AC3,FSGV6		;JUMP IF 2ND TIME THROUGH AND SIZE ALREADY OFFSET
	CAML AC1,FSLIM9		;HIGH OR LOW BLOCK?
	SUBI AC3,FSHOFS		;HIGH, OFFSET POINTER INTO HIGH LIST TABLE
>;IFN FTHIFS
FSGV6:	MOVEI TAC,FSAVB+1(AC3)	;GET THE LIST BASE
FSGV7:	SKIPG DAT,(TAC)		;DOES THIS POINT FREE?
	JRST FSGV6		;NO TRY THIS LIST ALL OVER AGAIN
	HRRZ TEM,(TAC)		;GET THE FLINK
	CAIE TEM,FSAVB+1(AC3)	;IS THIS THE END OF THE LIST?
	CAILE TEM,(AC1)		;HAVE WE FOUND THE RIGHT PLACE?
	JRST FSGV8		;YES. PREPARE TO LINK IT IN
	CAME DAT,(TAC)		;IS THIS STILL THE SAME?
	JRST FSGV6		;NO. TRY ALL OVER
	MOVEI TAC,(TEM)		;GET THE NEXT FLINK
	JRST FSGV7		;CHASE DOWN THIS LIST

FSGV8:	HRRZM TAC,-1(AC1)	;SET THE BLINK
	HRRM TEM,(AC1)		;SET THE FLINK
	LDB AC2,FSSBYP		;GET THE SIZE OF BLOCK
	SUBM AC1,AC2		;GET POINTER TO BOTTOM
	MOVSI TAC1,400000
	ANDCAM TAC1,(AC1)	;TURN OFF CLAIM BIT
	CONI PI,TAC1
	ANDI TAC1,PICMSK
	CONO PI,PICHOF(TAC1)	;HOLD CHANNELS 3-7
	CAME DAT,(TAC)		;STILL HERE?
	JRST FSGV5		;WHAT A LOSS.
	HRRM AC1,(TAC)		;STUFF IN NEW FLINK
	HRRM AC1,-1(TEM)	;STUFF IN NEW BLINK
	HRRZM AC1,1(AC2)	;AND TURN OFF BOTTOM MARK
	CONO PI,PICHON(TAC1)	;ALLOW INTERRUPTS
	MOVE AC1,FSTOP
	SUBI AC1,1		;POINTER TO TOP-MOST FS BLOCK
	LDB AC3,FSSBYP		;GET THE SIZE OF LOW BLOCK
	SKIPL (AC1)		;SKIP IF BLOCK IS CLAIMED ALREADY
	CAIGE AC3,2000		;UNCLAIMED. SKIP IF BIGGER THAN 1K
	JRST FSXPOP		;CLAIMED OR NOT BIG ENOUGH
	SKIPN FSCNT		;SKIP IF ANYONE'S WAITING
	SETOM FSGVKF		;SET FLAG TO LET CLOCK THINK ABOUT IT
	SETOM FSNCLK		;MAKE CLKSER CALL FSCLK
FSXPOP:	PUSH P,J		;SAVE J, CLOBBERED BY FSWAKE
	PUSHJ P,FSWAKE		;WAKE SOMEONE WHO WAITS.
	POP P,J			;RESTORE J
FSPOP:	POP P,AC1
	POPJ P,


FSQUIK:	PUSHJ P,FSECHK		;CHECK ADDRESSES
FSQUK1:	PUSH P,AC1
	PUSH P,TEM
	HRRZ AC1,-1(AC1)	;LOAD TOP ADDRESS FROM BOTTOM
	SYSPIFF		;ADD THIS BLOCK TO THE FREE LIST
	HRRZ TEM,FSRTL		;GET THE FLINK
	HRRM TEM,(AC1)		;SAVE HERE
	HRRZM AC1,FSRTL		;RESET LIST BASE
	SYSPIN		;DONE
	SETOM FSNCLK
	POP P,TEM
	JRST FSPOP

IFN FTFSAVBUG,<
FSVBCK:	PUSH P,TAC
	PUSH P,TAC1
	MOVEI TAC,FSAVB+2*NFSB-1 ;START AT LAST FORWARD POINTER
FSVBC1:	MOVE TAC1,(TAC)		;GET THE FORWARD POINTER
	TLNE TAC1,-1		;MUST HAVE ZERO LEFT HALF
	JRST FSVBE1
	CAIN TAC1,(TAC)		;CAN POINT TO ITSELF
	JRST FSVBC2
	CAML TAC1,SYSTOP
	CAML TAC1,FSTOP
	JRST FSVBE2		;OR TO FREE STORAGE
FSVBC2:	SUBI TAC,1		;DECREMENT TO BACK POINTER
	MOVE TAC1,(TAC)		;GET THE BACKWARD POINTER
	TLNE TAC1,-1		;MUST HAVE ZERO LEFT HALF
	JRST FSVBE3
	CAIN TAC1,1(TAC)	;CAN POINT TO FORWARD POINTER
	JRST FSVBC3
	CAML TAC1,SYSTOP
	CAML TAC1,FSTOP
	JRST FSVBE4		;OR TO FREE STORAGE
FSVBC3:	CAIE TAC,FSAVB		;DONE?
	SOJA TAC,FSVBC1		;NO
	POP P,TAC1
	JRST TPOPJ

FSVBE1:	JSP TAC1,FSVBE0		;0 - FORWARD POINTER LH NOT ZERO
FSVBE2:	JSP TAC1,FSVBE0		;1 - FORWARD POINTER OUTSIDE VALID RANGE
FSVBE3:	JSP TAC1,FSVBE0		;2 - BACKWARD POINTER LH NOT ZERO
FSVBE4:	JSP TAC1,FSVBE0		;3 - BACKWARD POINTER OUTSIDE VALID RANGE

FSVBE0:	SYSPIFF
	PUSHACS
	SUBI TAC1,FSVBE1+1	;ERROR CODE
	PUSH P,TAC1
	PUSH P,TAC
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /FSAVB+/
	POP P,TAC
	SUBI TAC,FSAVB
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / CLOBBERED, ERROR CODE = /
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / CALLER = /
	HRRZ TAC,-22(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
;	POPACS
;	POP P,TAC1
;	POP P,TAC
	JRST AUTOLOAD
;	SYSPIN
;	POPJ P,

FSVBX1:	JSA DSER,FSVBXX
FSVBX2:	JSA DSER,FSVBXX
FSVBX3:	JSA DSER,FSVBXX
FSVBX4:	JSA DSER,FSVBXX
FSVBX5:	JSA DSER,FSVBXX
FSVBX6:	JSA DSER,FSVBXX
FSVBX7:	JSA DSER,FSVBXX
FSVBX8:	JSA DSER,FSVBXX

FSVBXT:	MOVEI DSER,(AC2)
	MOVEI DSER,(TEM)
	MOVEI DSER,(AC1)
	MOVEI DSER,(AC2)
	MOVEI DSER,(TAC)
	MOVEI DSER,(TEM)
	MOVEI DSER,(AC1)
	MOVEI DSER,(AC3)

;FSVBXX:0			;IN ALLDAT
;	SYSPIFF		;IN ALLDAT
;	JRST FSVBXY		;IN ALLDAT
↑FSVBXY:MOVE DSER,FSVBXT-FSVBX1-1(DSER)
	EXCH DSER,FSVBXX	;RESTORE DSER, STORE INSTRUCTION
	PUSHACS
	XCT FSVBXX		;GET ADDRESS WE ARE ABOUT TO STEP ON
	PUSH P,DSER
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /ABOUT TO CLOBBER /
	POP P,TAC
	CAIL TAC,FSAVB
	CAILE TAC,FSAVB+2*NFSB-1
	JRST FSVBXZ
	SUBI TAC,FSAVB
	PUSH P,TAC
	PUSHJ P,DISMES
	ASCIZ /FSAVB+/
	POP P,TAC
FSVBXZ:	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / CALLER = /
	HRRZ TAC,-20(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
;	POPACS
	JRST AUTOLOAD
;	SYSPIN
;	POPJ P,

>;IFN FTFSAVBUG
;UFSGET UFSGT1

;GET FREE STORAGE AT UUO LEVEL.

HISYS

↑UFSGET:PUSHJ P,FSGET		;GET FREE STORAGE AT UUO LEVEL
	 JRST .+2		;FAILURE CANNOT HAPPEN (IT SAYS HERE)
	POPJ P,			;EXPECTED RETURN
UFSGT9:	PUSHACS			;STUFF EVERYTHING AWAY
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /NO FS AT UFSGET. /
	CONSO PI,77400		;ARE THERE ANY CHANNELS ACTIVE?
	JRST UFSGT1		;NO.
	PUSHJ P,DISMES
	ASCIZ /NOT AT UUO LEVEL!  RETURN PC = /
	MOVE TAC,P-17(P)
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ / PI = /
	CONI PI,TAC
	PUSHJ P,DISLOC
UFSGT1:	PUSHJ P,DISCRLF
	POPACS
	JSP DAT,UERROR		;GIVE A UUO ERROR.

IFN FTHIFS,<
↑UHFSGT:PUSHJ P,HFSGET		;GET HIGH FS
	 JRST UFSGT9
	POPJ P,
>;IFN FTHIFS
;RELPDL

;RELPDL - RELEASE THE JBTPDL
;CALL:	MOVE J,<JOB NUMBER>
;	PUSHJ P,RELPDL

COMMENT $

The free storage block that this PDL uses will be placed on the free
storage return list.  The block will actually be returned the next
time that channel 7 is activated by the clock.  The caller of RELPDL
must finish using the PDL at UUO level or clock level, whichever
level RELPDL is called from.

$


↑RELPDL:HRRZ AC1,JBTPDL(J)	;GET THE ADDRESS OF THE PDL
	JUMPE AC1,CPOPJ		;NO PDL, CAN'T RELEASE
	HRRZ TAC,JBTPDL(J)	;GET THE PDL ADDRESS
	ADDI TAC,JBTPLN+JOBPRT-JOBPFI ;ADDRESS OF THE TOP IN TAC
	SKIPN (TAC)		;LOOK FOR A NON-ZERO CELL
	SOJGE TAC,.-1		;LOOP.
	SUB TAC,AC1		;SUBTRACT THE BASE ADDRESS.
	CAMLE TAC,NPUSHD	;BIGGER THAN OUR BIGGEST
	MOVEM TAC,NPUSHD	;YES. SAVE THIS NUMBER
	SETZM JBTPDL(J)		;CLEAR PDL CELL FOR NEXT JOB
	AOS NFSGIVES		;COUNT THIS CELL HERE, SINCE FAKING IT
	MOVNI TAC,JBTPLN+2	;GET THE SIZE OF THIS BLOCK
	ADDM TAC,FSBUSY		;DECREASE BUSY COUNT TOO.
	AOJA AC1,FSQUIK		;CHECK BLOCK, STUFF ON FSRTL, RETURN
;SFSINI SFSIOL SFSIIL SFSI3 SFSI2 SFSCLK SFSCL1 SFSCLL SFSCL2

;SPARE LIST HANDLER FOR DPYSER & TTYSER

;HERE WE SET UP THE INITIAL QUOTAS (QUOTAE?)
SFSINI:	HRRZ DDB,SFHEAD		;THE SPARE LIST LIST
SFSIOL:	LDB DAT,[331000,,SFSIZE(DDB)] ;HOW MANY DOES THIS ONE WANT?
	JUMPE DAT,SFSI2		;NONE?
	HRRZ AC3,SFSIZE(DDB)
	MOVEI AC2,(DDB)		;INIT PNTR FOR LINKING
SFSIIL:	PUSHJ P,FSGETU
	 JRST SFSI3		;LOSE - SET TO TRY LATER (SHOULDN'T HAPPEN)
	MOVEM AC1,(AC2)		;LINK IT IN
	MOVEI AC2,(AC1)
	SOJG DAT,SFSIIL
SFSI3:	SETZM (AC2)		;TERMINATE LIST
	MOVEM DAT,SPFSN(DDB)	;SET FROM DAT IN CASE WE LOST
	SKIPL SFSIZE(DDB)
	ADDM DAT,SPFSNT
SFSI2:	HRRZ DDB,SFLINK(DDB)
	JUMPN DDB,SFSIOL
	POPJ P,

;WE GET HERE AT CLOCK LEVEL WHEN SPFSNT GT 0 TO REPLENISH OUR SPARES
↑SFSCLK:HRRZ DDB,SFHEAD
SFSCL1:	SKIPLE SPFSN(DDB)	;IF THIS LIST DOESN'T NEED ANY
	SKIPGE SFSIZE(DDB)	;OR THIS ISN'T THE CLOCK-FILLED KIND
	JRST SFSCL2		;TRY NEXT LIST
SFSCLL:	HRRZ AC3,SFSIZE(DDB)
	PUSHJ P,FSGET		;TRY TO GET ONE
	JRST SFSCL2		;LOSE - DON'T BOTHER WITH THIS LIST ANY MORE
	SYSPIFF
	EXCH AC1,(DDB)		;PUT IT IN THE LIST
	MOVEM AC1,@(DDB)
	SYSPIN
	SOS AC1,SPFSNT		;DECREMENT TOTAL
	SOSLE SPFSN(DDB)	;& # THIS LIST
	JRST SFSCLL		;STILL NEED MORE
	JUMPLE AC1,CPOPJ	;THIS LIST ALL SET, ANY OTHERS TO DO?
SFSCL2:	HRRZ DDB,SFLINK(DDB)	;YES, TRY NEXT LIST
	JUMPN DDB,SFSCL1	;IF THERE IS ONE
	POPJ P,
;SFSGET SFGFS SFSCLP SFSCNE SFSCEN SFSXIT SFSWIN SFSGTS SFSGOK SFGSF SFGTS SFSLUZ SFULUZ

;VERSION OF FSGET TO USE SPARE LIST -- SFSGET
;LIKE FSGET EXCEPT AC3 HAS SPARE LIST HEADER POINTER INSTEAD OF SIZE
;SIGN BIT (AC3) MEANS NO SKIP (OR FAILURE) RETURN
;SFNWT BIT FORCES FAILURE RETURN EVEN AT UUO LEVEL
↑SFSGET:PUSH P,AC3
	SKIPGE SFSIZE(AC3)
	JRST SFGSF		;WANTS TO TRY SPARES FIRST
SFGFS:
IFN FTHIFS,<
	TLNE AC3,SFHI		;HIGH OK?
	JRST SFGFSH		;YES
>;IFN FTHIFS
	HRRZ AC3,SFSIZE(AC3)
	PUSHJ P,FSGETU
	 JRST SFSGTS		;NO FS, TRY SPARE
SFGFS1:
IFN FTFSCALL,<
REPEAT 0,<			;THIS DOESN'T WORK
	MOVE AC3,(P)		;GET FS LIST HEADER
	HRLI AC3,400000		;FLAG THAT THIS IS A HEADER, NOT A CALLER
	PUSH P,AC1
	PUSH P,AC2
	HRRZ AC2,SFSIZE(AC3)	;SIZE OF BLOCK WE JUST ASKED FOR
	MOVSI AC1,NFSCSZ	;AOBJN POINTER TO TABLES
SFSCLP:	SKIPN FSCADR(AC1)	;ANY MORE CALLERS KNOWN?
	JRST SFSCNE
	CAME AC3,FSCADR(AC1)
	AOBJN AC1,SFSCLP	;LOOK THROUGH TABLE FOR KNOWN CALLER
	JUMPGE AC1,SFSCEN
SFSCNE:	MOVEM AC3,FSCADR(AC1)
	ADDM AC2,FSCCNT(AC1)
SFSCEN:	POP P,AC2
	POP P,AC1
>;REPEAT 0
>;IFN FTFSCALL
SFSXIT:	POP P,AC3
SFSWIN:	JUMPGE AC3,CPOPJ1	;HERE WE HAVE WON, AND GIVE THE REQUESTED SUCCESS RETURN
	POPJ P,

SFSGTS:	PUSHJ P,SFGTS		;TRY TO GET A SPARE
	JRST SFSLUZ		;OOPS - NO SPARE, EITHER
SFSGOK:	POP P,AC3
	AOS SPFSN(AC3)		;NOW WE NEED ANOTHER
	SKIPL SFSIZE(AC3)	;AND UNLESS WE'RE KEEPING SFSCLK OUT
	AOS SPFSNT		;WE SHOULD REQUEST SERVICE FROM IT
	JRST SFSWIN

SFGSF:	PUSHJ P,SFGTS		;HERE WE TRY THE SPARES FIRST
	SKIPA AC3,(P)		;LOSE - GET THE PNTR SO WE CAN GET THE SIZE FOR FSGET
	JRST SFSGOK		;WIN - UPDATE THINGS & EXIT
	JRST SFGFS		;NOW TRY FSGET

SFGTS:	MOVEI AC3,		;PREPARE TO FLUSH LINK
	SYSPIFF		;GET SPARE FROM LIST AT @(P)
	SKIPN AC1,@-1(P)
	JRST PIONJ		;NONE
	EXCH AC3,(AC1)		;THIS ZEROES LINK TO TELL RELEX SOMETHING CHANGED
	MOVEM AC3,@-1(P)	;DELINK IT FROM THE LIST
	SYSPIN
	JRST CPOPJ1

SFSLUZ:	POP P,AC3
	AOS SFLOSS(AC3)		;COUNT OUR TOTAL LOSSES
	CONSO PI,77400
	JRST SFULUZ		;UUO LEVEL - NOT TOO BAD
	JUMPL AC3,SFILUZ	;IF WE CAN'T GIVE A FAILURE RETURN WE ARE IN DEEP TROUBLE
	POPJ P,			;WHEW!

SFULUZ:	TLNE AC3,SFNWT		;IF THE CALLER DOESN'T WANT TO WAIT
	JUMPGE AC3,CPOPJ	;AND HE ALLOWS FAILURE, JUST RETURN
	PUSH P,AC3
IFN FTHIFS,<
	TLNE AC3,SFHI
	JRST SFHLUZ
>;IFN FTHIFS
	HRRZ AC3,SFSIZE(AC3)
	PUSHJ P,UFSGET		;OTHERWISE OFF TO FSGET TO WAIT FOR IT
	JRST SFSXIT

IFN FTHIFS,<
SFGFSH:	HRRZ AC3,SFSIZE(AC3)	;HERE IF HIGH FS IS ACCEPTABLE
	PUSHJ P,HFSGTU		;ASK FOR HIGH FS
	 JRST SFSGTS		;NO FS, TRY SPARE
	JRST SFGFS1		;REJOIN MAIN CODE

SFHLUZ:	HRRZ AC3,SFSIZE(AC3)	;HERE IF HIGH FS IS ACCEPTABLE
	PUSHJ P,UHFSGT		;ASK FOR HIGH FS
	JRST SFSXIT		;REJOIN MAIN CODE
>;IFN FTHIFS
;SFILUZ

;ARRRGH! PI LEVEL AND NO FAILURE POSSIBLE! HERE WE CURL UP AND DIE
SFILUZ:	HLRZ AC2,SFLOSS(AC3)	;MAYBE THE CONDEMNED HAS A FEW LAST WORDS
	SKIPN AC2
	MOVEI AC2,[ASCIZ /SOMETHING/] ;NOPE
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /πππππππNO CORE FOR /]
	@AC2-20(P)
	[ASCIZ / AT SFSGET.

/]
	-1
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCALL		;MAYBE SOMEONE WANTS TO KNOW WHY
	JRST AUTOLOAD		;AS THE SYSTEM SINKS SLOWLY INTO THE WEST
;SFSGIV SFSREL SFSRLL

;VERSION OF FSGIVE TO THINK ABOUT PUTTING RETURNED BLOCK INTO SPARE LIST -- SFSGIV SFSREL
;LIKE FSGIVE BUT CALL IS FOLLOWED BY LIST HEADER ADDRESS
↑SFSGIV:PUSH P,AC3
	AOS AC3,-1(P)		;SKIP OVER ARG
	MOVEI AC3,@-1(AC3)	;& GET IT
	SKIPGE SFSIZE(AC3)	;ONLY RETURN INTO LIST IF THIS BIT IS ON
	SKIPG SPFSN(AC3)	;AND WE NEED SOME
	JRST SFSGV1		;OTHERWISE GIVE IT BACK TO FS
	PUSH P,AC1
	ANDI AC1,-1
	SYSPIFF
	EXCH AC1,(AC3)		;LINK IT IN
	MOVEM AC1,@(AC3)
	SYSPIN
	POP P,AC1
	SOS SPFSN(AC3)		;ONE FEWER NEEDED
	POP P,AC3
	POPJ P,

IFN FTFSCALL,<
SFSRE1:	PUSH P,AC3
>;IFN FTFSCALL
SFSGV1:
IFN FTFSCALL,<
	PUSH P,AC1
	PUSH P,TEM
	HRLI AC3,400000		;SFS LIST HEADER FLAG
	MOVSI AC1,NFSCSZ	;AOBJN POINTER TO TABLES
SFSCP1:	SKIPN FSCADR(AC1)	;ANY MORE CALLERS KNOWN?
	JRST SFSCE1		;NO, FORGET IT
	CAME AC3,FSCADR(AC1)
	AOBJN AC1,SFSCP1	;LOOK THROUGH TABLE FOR KNOWN CALLER
	JUMPGE AC1,SFSCE1
	HRRZ TEM,SFSIZE(AC3)	;SIZE OF BLOCK
	EXCH TEM,FSCCNT(AC1)
	SUBM TEM,FSCCNT(AC1)	;GIVE IT BACK
SFSCE1:	POP P,TEM
	POP P,AC1
>;IFN FTFSCALL
	POP P,AC3
	JRST FSGIVE		;GIVE IT BACK TO FS

;ROUTINE TO DYNAMICALLY SHRINK SIZE OF SPARE LIST
;CALL WITH -# TO DECREASE IN AC2, HEADER POINTER IN AC3 (CLOBBERS AC1 & AC2)
↑SFSREL:SKIPL SFSIZE(AC3)	;AS USUAL, THIS TYPE LEAVES SPFSNT ALONE
	ADDM AC2,SPFSNT
	ADDB AC2,SPFSN(AC3)
	JUMPGE AC2,CPOPJ	;LEAVE IF WE DON'T HAVE TO GIVE ANY AWAY
SFSRLL:	SYSPIFF
	SKIPN AC1,(AC3)		;GET ONE
	JRST PIONJ		;NONE
	HRRZ AC2,(AC1)
	MOVEM AC2,(AC3)		;LINK IT OUT
	SYSPIN
IFE FTFSCALL,<
	PUSHJ P,FSGIVE		;AND GIVE IT BACK TO THE WORLD
>;IFE FTFSCALL
IFN FTFSCALL,<
	PUSHJ P,SFSRE1		;MARK IT DOWN AND GIVE IT BACK
>;IFN FTFSCALL
	SKIPL SFSIZE(AC3)	;THE UBIQUITOUS TEST (SIGH)
	AOS SPFSNT
	AOSGE SPFSN(AC3)	;ONE MORE "NEEDED" (SHOULD BE GOING UP TO 0)
	JRST SFSRLL		;AND WE'LL KEEP AT IT UNTIL IT DOES
	POPJ P,
;RELEX RELX1 RELX2 RELXI RELXL RELXO

;YES FANS, IT'S THE INFAMOUS RELEX, FORMERLY SCATTERED THROUGH TTYSER & DPYSER
;THIS ONE TRIES TO SHUFFLE UP ALL THE SPARES IN THE BOTTOM 1K
;BY REPLACING THEM WITH NEW ONES FROM FREE STORAGE
;IT GIVES UP QUICKLY IF THE NEW ONES AREN'T ABOVE THE BOTTOM 1K


RELEX:	MOVE AC2,FSTOP
	SUBI AC2,2000
	CAMG AC2,SYSTOP
	POPJ P,
	HLRZ DDB,SFHEAD		;THERE WAS ONCE A REASON FOR GOING THROUGH BACKWARDS
RELX1:	MOVEI TAC,(DDB)		;START THE "PREVIOUS" POINTER HERE
RELX2:	HRRZ TEM,(TAC)		;CONSIDER A BLOCK
	JUMPE TEM,RELXO		;GEE, WASN'T THAT EASY
	CAIGE TEM,(AC2)
	JRST RELXI		;HE'S NOT IN THE BOTTOM 1K, SO WE WON'T WORRY ABOUT HIM NOW
	MOVE TAC1,(TEM)		;PICK UP HIS LINK
	HRRZ AC3,SFSIZE(DDB)	;HE MUST BE THIS BIG
	PUSHJ P,FSGET		;GET A SHINY NEW PIECE
	JRST RELXO		;OH WELL, SO MUCH FOR THIS LIST
	CAIL AC1,(AC2)
	JRST RELXL		;TIME TO SEE THE COMPLAINT DEPARTMENT
	MOVEM TAC1,(AC1)	;COPY THE LINK
	SYSPIFF		;NOW CLOSE OUR EYES
	CAMN TAC1,(TEM)		;AND IF THESE 2 POINTERS
	CAME TEM,(TAC)		;STILL AGREE
	JRST [SYSPIN↔JRST RELXL] ;CURSES! FOILED AGAIN! GIVE BACK NEW BLOCK.
	MOVEM AC1,(TAC)		;QUICK! PULL THE SWITCH!
	SYSPIN		;DIDN'T SEE A THING
	EXCH AC1,TEM		;DON'T FORGET TO TELL FSGIVE ABOUT THE SWITCH
	PUSHJ P,FSGIVE		;NOW GET RID OF THE LOSER
RELXI:	MOVE TAC,TEM		;THIS IS NOW THE PREVIOUS BLOCK
	JRST RELX2

RELXL:	PUSHJ P,FSGIVE		;GIVE BACK THE NEW ONE
RELXO:	HLRZ DDB,SFLINK(DDB)	;AND TRY A NEW LIST
	JUMPN DDB,RELX1		;IF THERE'S ONE TO BE FOUND
	POPJ P,
;GETMAP GIVMAP JOBMAP JOBEVP GETMAP GIVMAP GETMP3 HIDVBG DEVBEG

;MANIPULATE 512-WORD PAGES OF FREE STORAGE.

IFN FTMAPP,<

;; Note: Callers of GETMAP must not themselves call JOBMAP!

↑GETMAP:MOVE AC1,JBTMA2(J)	;PAGE NUMBER OF MAP PAGE FOR THIS JOB
IFN FTMPP2,<
	PUSH P,JBTMAP(J)	;PROBABLY UNNECESSARY SINCE CALLER WILL SET IT
	MOVEM AC1,JBTMAP(J)
	PUSHJ P,JOBMAP		;Map job's map page into exec, return VMA in AC1
	 PUSHJ P,POPTRP		;Better not happen--call DDT and don't return here
	POP P,JBTMAP(J)		;RESTORE JBTMAP
>;IFN FTMPP2
	LSH AC1,9
	SETZM (AC1)
	PUSH P,AC3
	MOVS AC3,AC1
	HRRI AC3,1(AC1)
	BLT AC3,777(AC1)	;CLEAR OUT PAGE MAP
	POP P,AC3
IFE FTMPP2,<	LSH AC1,-9		>
IFN FTMPP2,<	MOVE AC1,JBTMA2(J)	>
	JRST CPOPJ1

↑GIVMAP:POPJ P,

IFN FTMPP2,<

; NOTE THAT GIVMAP HAD BETTER NOT DO ANYTHING OR ITS CALLERS MUST BE FIXED

; JOBMAP TAKES JOB NUMBER IN J, PUTS ITS UPMP IN THE RIGHT EVM PAGE FOR
; WHATEVER PI LEVEL WE'RE IN, THEN RETURNS THAT EXEC VIRTUAL PAGE NUMBER
; IN AC1.  CLOBBERS NO ACS EXCEPT AC1.
; NOTES: (1) ASSUMES NOBODY IN A HIGHER PI LEVEL WILL FLUSH JBTMAP OUT
; FROM UNDER US.  (2) ASSUMES IT IS OK TO CLOBBER THE UPMEXP ENTRY FOR
; THIS PI LEVEL, SO YOU HAVE TO FINISH USING THE PAGE BEFORE YOU LET
; ANYONE ELSE CALL JOBMAP FROM THE SAME LEVEL.

; ENTER AT JOBEVP WITH JOB NUMBER IN J, EXEC VIRTUAL PAGE NUMBER IN AC1
; TO GET A SPECIAL EXEC VIRTUAL PAGE (NOT DEPENDENT ON PI LEVEL) SET TO
; POINT TO THE JOB'S UPMP.

↑JOBMAP:SKIPN JBTMAP(J)		;IS THERE A UPMP?
	POPJ P,			;NOPE
	CONI PI,AC1		;GET PI LEVEL
	ANDI AC1,77400		;WITHOUT JUNK
	LSH AC1,=21-1		;GET CH1 TO BIT 1
	PUSH P,AC1+1		;(UUO LEVEL WILL BE "CHANNEL 0")
	JFFO AC1,.+1		;GET BIT NUMBER (= CHANNEL NUMBER)
	MOVEI AC1,UPMEXP(AC1+1)	;GET EXEC VIRTUAL PAGE NUMBER
	POP P,AC1+1
↑JOBEVP:PUSH P,TAC		;ENTER HERE WITH EXEC VIRTUAL PAGE # IN AC1
	PUSH P,TAC1
	MOVEI TAC1,(AC1)
	SKIPE EXPGT(TAC1)	;ALREADY IN USE?
	PUSHJ P,DELEMP		;YES, FLUSH IT
	HRRZ TAC,JBTMAP(J)	;PHYSICAL PAGE NUMBER
	MOVEI TAC1,(AC1)	;EXEC VIRTUAL PAGE NUMBER
	PUSHJ P,ADDEMP		;ADD TO MAP
	POP P,TAC1
	POP P,TAC
	JRST CPOPJ1
>;IFN FTMPP2

>;IFN FTMAPP

IFE FTMAPP,<
;RETURNS IN AC1 THE ADDRESS OF A 512-WORD PAGE MAP, CONTAINING ALL ZEROS.
;SKIPS ON SUCCESS.  CALL AT UUO-LEVEL OR FROM CHANNEL-7 ONLY!

↑GETMAP:PUSHJ P,FSACSV		;SAVE SOME ACS
	PUSHJ P,FSGETP		;SPECIAL FS CALL. RETURNS A PAGE
	JRST GETMP3		;LOSE.  RESTORE ACS AND DIRECT-RETURN
	MOVEI TAC,(AC1)		;MAKE INTO NEW FORMAT FS BLOCK.
	LSH TAC,-9
	PUSHJ P,CORGB1		;MAKE CORTAB BYTE POINTER.
	MOVEI AC2,PGTCUS	;CODE - MAP PAGE - BUSY
	DPB AC2,TAC		;CHANGE CORTAB ENTRY.
	SUBI AC1,1		;POINTS TO THE PAGE
	MOVSI AC2,(AC1)
	HRRI AC2,1(AC1)
	SETZM (AC1)
	BLT AC2,777(AC1)
	JSP DAT,FSACRS		;SKIP RETURN, RESTORING ACS
	LSH AC1,-9		;RETURN PAGE NUMBER OF THIS PAGE.
	JRST CPOPJ1

;RETURN A 512-WORD PAGE TO FREE STORAGE.  CALL WITH ADDRESS IN AC1.
↑GIVMAP:PUSHJ P,FSACSV		;SAVE SOME ACS
	LSH AC1,9		;CONVERT TO A WORD ADDRESS
	MOVEI TAC1,777(AC1)	;HIGH ADDRESS.
	MOVSI AC2,401000	;SIZE FIELD FOR FS BLOCK.
	MOVEM AC2,(TAC1)	;STUFF IN HIGH WORD
	HRROM TAC1,(AC1)	;STUFF UP POINTER IN LOW WORD
	LDB TAC,[POINT 9,AC1,26]
	PUSHJ P,CORGB1
	MOVEI TAC1,FSCUS	;SET CORTAB CODE TO FREE STORAGE.
	DPB TAC1,TAC
	ADDI AC1,1		;MAKE AC1 POINT TO NORMAL STYLE FS BLOCK
	PUSHJ P,FSGIVE		;GIVE IT AWAY
GETMP3:	JSP DAT,FSACRS
	POPJ P,
>;IFE FTMAPP

BEND CORE

↑HIDVBG←←0
IFN FTHSYS,<↑HIDVBG←←.>		;FTHSYS
LOSYS
↑DEVBEG←←.			;START OF THE DEV SERVICES IN ENTIRE SYSTEM
HISYS
