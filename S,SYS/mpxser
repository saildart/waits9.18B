COMMENT ⊗   VALID 00003 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	MPXINI MPXINT MPXEXT MPXIND MPXERR MPXNT0 MPXNT1 MPXNT2 MPXNT6 MINTLP MINTL1 MINTL2 MINTL3 MINTL4 MPXRS0 MPXRSL MPXRS1 MPXRS2 MDEVPT MDVPTB GKW
C00009 00003	DKMPXS DKMPXX DKMPSX DDMPXS DDMPXX MPXDVS MPXDSX MPXDV1 MPXDV2 MPXDV3 MPXDV4 MPXDVX MPXDX1 MPXDX2 MPXDVL MPXDVR MPXDVT MPXDVY
C00016 ENDMK
C⊗;
;MPXINI MPXINT MPXEXT MPXIND MPXERR MPXNT0 MPXNT1 MPXNT2 MPXNT6 MINTLP MINTL1 MINTL2 MINTL3 MINTL4 MPXRS0 MPXRSL MPXRS1 MPXRS2 MDEVPT MDVPTB GKW

IFN FTMPX,<

BEGIN MPXSER ↔ SUBTTL MAPPIPLEXOR SERVICE

↑MPXINI:CONO MPX,MRESET
	SETZM MPXZER
	MOVE TAC,[MPXZER,,MPXZER+1]
	BLT TAC,MPXZND
	CONSZ MPX,MBUSY			;WAIT UNTIL FINISH CLEARING RAMS
	JRST .-1
	CONO MPX,MENBPI!MPXCHN
	POPJ P,

↑MPXINT:MOVEM TAC,MPXTAC
	CONI MPX,TAC
	TDNE TAC,[20000000⊗<-2*DDDMPX>]
	JRST MPXIND			;IT'S A DATA DISK ACCESS VIOLATION
	MOVE TAC,MPXTAC
	EXCH P,APRPDL			;GET SOME SPACE
	PUSHJ P,MPXERR
	EXCH P,APRPDL
	SKIPE MPXDTI			;WERE THERE DEVICE PARITY ERRORS?
	JRST PARIN0			;YES, GO TO PARSER
MPXEXT:
	MTRCOF (CH3,P2NOCK)

IFN FTXADR,<
	XJEN MPXCHL
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@MPXCHL
>;IFE FTXADR

MPXIND:	CONO MPX,MCLRAV+DDDMPX⊗MPXSHF	;CLEAR ACCESS VIOLATION FOR DD
	MOVE TAC,MPXTAC			;MPX IS STILL HUNG FOR DD SO DD SHOULD
	SETOM MPXDDR			;GET A NXM.  THIS FLAG WILL TELL DPYSER
	JRST MPXEXT			;THAT IT WAS EXPECTED

↑MPXERR:SYSPIFF
	PUSHACS
	SETZM MPXSTP
	SETZM MPXRST
	MOVE TAC,[MPXRST,,MPXRST+1]
	BLT TAC,MPXRST+7
	CONI MPX,MPXCNI
	DATAI MPX,MPXDTI
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /MPX/
	PUSHJ P,DISERR
	[ASCIZ /MPX INTERRUPT.  CONI = /]
	DISARG OCT,MPXCNI
	[ASCIZ /   DATAI = /]
	DISARG OCT,MPXDTI
	[ASCIZ /
/]
	-1
	MOVE AC1,MPXCNI
	TRNN AC1,MNXM!MPARER		;NXM OR PARITY ERROR IN MPX ITSELF?
	JRST MPXNT2
	SETOM MPXSTP			;YES, GO TO DDT
	MOVE AC1,MPXCNI
	TRNN AC1,MNXM
	JRST MPXNT0
	PUSHJ P,DISMES
	ASCIZ /MPX NXM   /
MPXNT0:	MOVE AC1,MPXCNI
	TRNN AC1,MPARER
	JRST MPXNT1
	PUSHJ P,DISMES
	ASCIZ /MPX PARITY ERROR/
MPXNT1:	PUSHJ P,DISCRLF
MPXNT2:	SKIPN MPXDTI
	JRST MPXNT6
	PUSHJ P,DISMES
	ASCIZ /DEVICE PARITY ERRORS
/
	SETOM MPXSTP
MPXNT6:	MOVEI DDB,MPXMAX
MINTLP:	MOVN UUO,DDB
	ASH UUO,1			;SHIFT VALUE FOR THIS DEVICE
	MOVSI TAC1,20			;BIT 13
	LSH TAC1,(UUO)			;ACCESS VIOLATION BIT
	TDNN TAC1,MPXCNI
	JRST MINTL1
	PUSHJ P,DISMES
	ASCIZ /ACCESS VIOLATION FOR /
	PUSHJ P,MDEVPT			;PRINT DEVICE NAME
MINTL1:	MOVSI TAC1,10			;BIT 14
	LSH TAC1,(UUO)			;WRITE VIOLATION BIT
	TDNN TAC1,MPXCNI
	JRST MINTL2
	PUSHJ P,DISMES
	ASCIZ /WRITE VIOLATION FOR /
	PUSHJ P,MDEVPT
MINTL2:	MOVSI TAC1,30			;BITS 13 AND 14
	LSH TAC1,(UUO)
	TDNN TAC1,MPXCNI
	JRST MINTL3
	PUSHJ P,DISMES
	ASCIZ /LAST DATAO = /
	MOVE TAC,MPXDTO(DDB)
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /   JOB = /
	MOVE TAC,MPXJOB(DDB)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
JBTMAP(J) = /
	MOVE TAC,MPXJOB(DDB)
	MOVE TAC,JBTMAP(TAC)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	SETOM MPXSTP			;FLAG TO GO TO DDT
	SETOM MPXRST(DDB)
MINTL3:	SOJGE DDB,MINTLP
	SKIPN MPXSTP
	JRST MPXRS2
REPEAT 0,<
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
>;REPEAT 0
	MOVE TAC,MPXCNI
	TRNN TAC,MNXM!MPARER		;PARITY OR NXM IN MPX ITSELF?
	JRST MPXRS0			;NO
	SETOM MPXRST			;YES, RESET ALL DEVICES
	MOVE TAC,[MPXRST,,MPXRST+1]
	BLT TAC,MPXRST+7
	MOVEI TAC,3000
MINTL4:	CONO MPX,MRESET			;RESET THE ENTIRE MPX
	CONSZ MPX,MBUSY
	SOJG TAC,.-1
	JUMPE TAC,MINTL4
MPXRS0:	MOVSI TAC,-8
MPXRSL:	HRRZ TAC1,TAC			;DEVICE CODE
	LSH TAC1,MPXSHF
	CONO MPX,MCPTPE!MCWPE!MCRPE(TAC1)	;CLEAR PARITY ERROR FLAGS
	SKIPN MPXRST(TAC)
	JRST MPXRS1
	CONO MPX,MDVRST(TAC1)		;RESET THAT DEVICE
	CONSZ MPX,MBUSY
	JRST .-1
	SKIPE MPXDTO(TAC)
	DATAO MPX,MPXDTO(TAC)		;REISSUE LAST DATAO
	CONSZ MPX,MBUSY
	JRST .-1
	SKIPE MPXENB(TAC)
	CONO MPX,MENBMP(TAC1)		;REENABLE MAPPING
	CONSZ MPX,MBUSY
	JRST .-1
MPXRS1:	AOBJN TAC,MPXRSL
MPXRS2:	CONO MPX,MENBPI!MPXCHN
	POPACS
	SYSPIN
	POPJ P,

MDEVPT:	PUSHJ P,DISERR
	DISARG STR,@MDVPTB(DDB)
	-1
	POPJ P,

MDVPTB:	[ASCIZ /DISK DEVICE
/]
	[ASCIZ /DATA DISK DEVICE
/]
	[ASCIZ /III DEVICE
/]
	GKW
	GKW
	GKW
	GKW
	GKW

GKW:	ASCIZ /GOD KNOWS WHAT
/
;DKMPXS DKMPXX DKMPSX DDMPXS DDMPXX MPXDVS MPXDSX MPXDV1 MPXDV2 MPXDV3 MPXDV4 MPXDVX MPXDX1 MPXDX2 MPXDVL MPXDVR MPXDVT MPXDVY

IFN FTSWPM!FTDSKM,<

;ROUTINE TO SET UP MPX DISK DEVICE FOR MAPPING CURRENT TRANSFER
;CALL WITH JOB NUMBER IN J, CALL ONLY FROM A DISK I LEVEL SUBR

↑DKMPXS:PUSH P,AC3
	MOVEI AC3,DSKMPX	;MPX DISK DEVICE CODE
	PUSHJ P,MPXDVS
	POP P,AC3
	POPJ P,

↑DKMPXX:PUSH P,AC3
	MOVEI AC3,DSKMPX	;MPX DISK DEVICE CODE
	PUSHJ P,MPXDVX
	POP P,AC3
	POPJ P,

IFN FTSIX,<
↑DKMPSX:PUSH P,AC3		;SET UP MPX TO TRANSFER INTO P3 MEMORY
	MOVEI AC3,DSKMPX
	MOVEI TAC,SIXPGT⊗-9	;USE SIXPGT AS PAGE TABLE FOR XFER
	PUSHJ P,MPXDSX
	POP P,AC3
	POPJ P,
>;IFN FTSIX
>;IFN FTSWPM!FTDSKM

IFN FTDDDM,<

;ROUTINE TO SET UP DATA DISK DEVICE FOR MAPPING CURRENT TRANSFER
;CALL WITH JOB NUMBER IN J.

↑DDMPXS:PUSH P,TAC
	PUSH P,AC3
	MOVEI AC3,DDDMPX	;MPX DATA DISK DEVICE CODE
	PUSHJ P,MPXDVS
	POP P,AC3
	SETZM MPXDDR		;CLEAR DDD ACCESS VIOLATION FLAG
	JRST TPOPJ

↑DDMPXX:PUSH P,AC3
	MOVEI AC3,DDDMPX	;MPX DATA DISK DEVICE CODE
	PUSHJ P,MPXDVX
	POP P,AC3
	POPJ P,

>;IFN FTDDDM

IFN FTSWPM!FTDSKM!FTDDDM,<

;ROUTINE TO SET UP MPX DEVICE FOR MAPPING CURRENT TRANSFER.  DEVICE CODE IN AC3.
;CALL WITH JOB NUMBER IN J, CLOBBERS TAC, STARTS CACHE SWEEP OF PAGE
;TABLE.
↑MPXDVS:CAILE AC3,MPXMAX	;IS DEVICE CODE WITHIN REASON?
	JRST MPXDVR
	HRRZ TAC,JBTMAP(J)	;PAGE MAP PAGE NUMBER
	JUMPE TAC,MPXDVL	;NO PAGE TABLE NO XFER
;;	CONSZ CCA,(TAC)		;SWEEP PAGE MAP INTO CORE (LEAVE IN CACHE TOO)
			;RIGHT NOW PAGE MAP IS UNCACHED
MPXDSX:	PUSH P,AC1
	MOVEI AC1,(AC3)
	LSH AC1,MPXSHF		;SHIFT DEVICE CODE TO MPXDEV POSITION
	PUSH P,TAC1
	MOVEI TAC1,1000
MPXDV1:	CONSZ MPX,MINT
	PUSHJ P,MPXERR
	CONSZ MPX,MBUSY
	SOJG TAC1,MPXDV1	;IN CASE OF INTERRUPT,WAIT FOR OP IN PROGRESS TO END
	JUMPE TAC1,MPXDVT	;WAITED TOO LONG
	CONO MPX,MDVRST(AC1)	;RESET DEVICE
	HRLI TAC,(AC3)		;DEVICE NUMBER
	MOVEM TAC,MPXDTO(AC3)	;SAVE LAST MPX DATAO FOR TYPEOUT
	MOVEM J,MPXJOB(AC3)	;SAVE JOB NUMBER THAT GOES WITH PAGE TABLE
	MOVEI TAC1,1000
MPXDV2:	CONSZ MPX,MINT
	PUSHJ P,MPXERR
	CONSZ MPX,MBUSY
	SOJG TAC1,MPXDV2	;WAIT FOR RESET TO FINISH
	JUMPE TAC1,MPXDVT
	DATAO MPX,TAC		;LOAD PAGE TABLE POINTER
	MOVEM TAC,LMPXDTO	;SAVE AS LAST MPX DATAO ANYWHERE
	MOVEI TAC1,1000
MPXDV3:	CONSZ MPX,MINT
	PUSHJ P,MPXERR
	CONSZ MPX,MBUSY
	SOJG TAC1,MPXDV3	;WAIT FOR PAGE TABLE POINTER LOAD TO FINISH
	JUMPE TAC1,MPXDVT
	CONO MPX,MENBMP(AC1)	;ENABLE MAPPING FOR THE DEVICE
	SETOM MPXENB(AC3)	;MARK MAPPING ENABLED
	MOVEI TAC1,1000
MPXDV4:	CONSZ MPX,MINT
	PUSHJ P,MPXERR
	CONSZ MPX,MBUSY
	SOJG TAC1,MPXDV4
	JUMPE TAC1,MPXDVT
	POP P,TAC1
	POP P,AC1
	POPJ P,

↑MPXDVX:CAILE AC3,MPXMAX	;IS DEVICE CODE WITHIN REASON?
	JRST MPXDVR
	PUSH P,AC1
	PUSH P,TAC1
	MOVEI AC1,(AC3)
	LSH AC1,MPXSHF		;SHIFT DEVICE CODE TO MPXDEV POSITION
	MOVEI TAC1,1000
MPXDX1:	CONSZ MPX,MINT
	PUSHJ P,MPXERR
	CONSZ MPX,MBUSY
	SOJG TAC1,MPXDX1	;IN CASE OF INTERRUPT,WAIT FOR OP IN PROGRESS TO END
	JUMPE TAC1,MPXDVY
	CONO MPX,MDISMP(AC1)	;DISABLE MAPPING FOR DEVICE
	SETZM MPXENB(AC3)
	MOVEI TAC1,1000
MPXDX2:	CONSZ MPX,MINT
	PUSHJ P,MPXERR
	CONSZ MPX,MBUSY
	SOJG TAC1,MPXDX2
	JUMPE TAC1,MPXDVY
	POP P,TAC1
	POP P,AC1
	POPJ P,

MPXDVL:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JBTMAP ZERO AT MPXDVS
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	JRST AUTOLOAD

MPXDVR:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /ILLEGAL MPX DEVICE CODE AT MPXDVS OR MPXDVX
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	JRST AUTOLOAD

MPXDVT:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /MPX BUSY STUCK ON AT MPXDVS
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	POP P,TAC1
	POP P,AC1
	JRST MPXDVS

MPXDVY:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /MPX BUSY STUCK ON AT MPXDVX
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	POP P,TAC1
	POP P,AC1
	JRST MPXDVX

>;IFN FTDSKM!FTSWPM!FTDDDM

BEND MPXSER

>;IFN FTMPX
