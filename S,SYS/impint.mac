COMMENT ⊗   VALID 00015 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	TITLE IMPINT	HARDWARE/SOFTWARE INTERFACE	V 1515/515
C00005 00003	LOCAL REVISION HISTORY
C00007 00004	 IMPINT MPI MPE MPP
C00008 00005	DOCUMENTATION
C00010 00006		EXTERNAL ROUTINES:
C00012 00007	PARAMETERS  IMP POWER DOWN10 SICK DEAD ENDIN ENDIN EMPTY FULL CSICK DOWN10 OUTSTP OUTEND GOTEND MPEENB MPPENB MPIENB MPEPIA MPPPIA MPIPIA IMP TYHB RFNHB TEST IMPERR IDONE IEND ODONE NREADY IEPIA IDPIA ODPIA TEST STRIN I32 O32 CLRST CLRWT STROUT FINO IEPIEN IDPIEN ODPIEN PIA ISTART IFLUSH SICK DEAD FULL ENDIN EMPTY MPIPIA MPEPIA MPPPIA CSICK OUTEND MPIENB MPPENB MPIENB MPPENB MPEENB ALLENB MPISET MPESET MPPSET
C00019 00008		SUBTTL INTERRUPT CODE  MPIINT MPIIN1 ONEWRD MPIIN2 IGNORE
C00024 00009	MPE INTERRUPT SERVICE  --  END-OF-MESSAGE  MPEINT END2 END3 MPEINT END1 END2
C00027 00010	MPP INTERRUPT SERVICE -- OUTPUT TO IMP  MPPINT DONE NONE
C00031 00011	SUBROUTINES  IMPOUT IMPOU0 IMPOU1 IMPOU2
C00034 00012	CODE TO CHECK HARDWARE HEALTH  IMPCHK
C00036 00013	INITIALIZE DEVICES  IMPDWN IMPIOF IMPION
C00038 00014	IFWAITS<  SAVE1 SAVE2 SAVE3 SAVE4 RES4 RES3 RES2 P1POPJ RES1 SAVT T4POPJ TPOPJ1 TPOPJ T2POJ1 T2POPJ FPOPJ1 FPOPJ
C00043 00015	 BLKIPT INPON DUMMY BLKOPT OUTACT
C00044 ENDMK
C⊗;
TITLE IMPINT	HARDWARE/SOFTWARE INTERFACE	V 1515/515
SUBTTL SUNDBERG/RLS/EAT --	22-APR-73
	SEARCH	F,S		;MACRO V50
	$RELOC
NOWAITS<
	$LOW
>;NOWAITS
IFWAITS<
	$HIGH
>;IFWAITS
	XP VIMPNT,516	;5.06 VERSION = 1000+5.04 VERSION

IFN FTAIP,<	;Most of file (except AC save code on page 14)

;LOCAL REVISION HISTORY

;[96bit]	7-Jul-80, Jim McCool
;	Modules effected: S, COMDEV, I, IMPINT, IMPSER, NETCON
;	Edit type: Enhancement
;	Add the CMU modifications to the ARPAnet code to support
;	96 bit leaders in the HOST-IMP protocol


;END OF LOCAL REVISION HISTORY

;JJW/ME revised April '83 for WAITS IP/TCP.

;Code marked NOWAITS is TOPS-10 code not used in WAITS.  Code marked IFWAITS or
;IFE FTF2 is new WAITS code.  Code marked IFN FTF2 but not IFWAITS is used in
;both TOPS-10 and F2 WAITS.

;As of late 1985 we always use 32-bit mode to communicate with the IMP, so
;that all higher-level code can deal with four 8-bit bytes per word.  The
;SAIL interface can handle this, but the F2 interface must simulate it.
;The F2 code has not yet been written since only LLL needs it, and we're no
;longer updating their WAITS system.

;⊗ IMPINT MPI MPE MPP

NOWAITS<
	ENTRY IMPINT
IMPINT::
>;NOWAITS


;     BECAUSE OF ASSEBLY-TIME ERROR IN COMMON (MACRO BUG), ALL MPO...
;     VALUES AND LABELS HAVE BEEN CHANGED TO MPP...		DK/FEB 75


COMMENT \
	INPUT INTERRUPT CHANNEL MUST BE HIGHER PRIORITY THAN
END-OF-MESSAGE CHANNEL
\

IFWAITS<
;JJW - The above warning is not heeded: in COMMON.MAC all IMP interrupts are
;assigned to the same channel.  We'll do the same in WAITS, with the channel
;number defined in CACDAT.

MPI==IMPCHN##
MPE==IMPCHN##
MPP==IMPCHN##
>;IFWAITS
SUBTTL DOCUMENTATION

COMMENT \

	INTERNAL ROUTINES:

IMPDWN--	TURNS THE HARDWARE OFF AND SETS PDP10 DOWN BIT

IMPIOF--	TURNS OFF INPUT

IMPION--	TURNS ON INPUT

IMPCHK--	CHECKS THE STATUS OF THE HARDWARE.  THE RETURN ADDRESS
		DEPENDS ON THE STATUS.  NO SKIP MEANS THAT THE IMP
		IS DEAD.  ONE SKIP MEANS THAT IT WAS DEAD BUT IS
		APPARENTLY OK NOW.  A DOUBLE SKIP MEANS THAT THE
		PDP-10 IS QUESTIONABLE.  A TRIPLE SKIP MEANS THAT ALL
		IS OK.

IMPOUT--	ROUTINE TO START UP THE OUTPUT SECTION.  T1 MUST
		CONTAIN AN IOWD POINTER TO AN OUTPUT MESSAGE.  RETURNS
		IMMEDIATELY IF THE HARDWARE IS BUSY AND THE MESSAGE
		CANNOT BE TRANSMITTED.  THE SKIP RETURN IS TAKEN
		IF THE MESSAGE IS BEING TRANSMITTED.
	EXTERNAL ROUTINES:

IMPEOM--	CALLED WHEN END-OF-MESSAGE HAS BEEN TRANSMITTED.
		IF THERE IS NO MORE OUTPUT, RETURN WITH A POPJ P,.
		IF ANOTHER MESSAGE IS TO BE TRANSMITTED, PLACE THE IOWD
		POINTER IN T1 AND TAKE THE SKIP RETURN.

IMPOND--	CALLED UPON A RUNOUT OF THE BLKO POINTER.  TO APPEND
		MORE OUTPUT, RETURN A NEW IOWD POINTER IN T1.  OTHER-
		WISE, DO NOT ALTER T1.

IMPIN--		CALLED ON THE FIRST WORD OF AN INCOMING MULTIWORD
		MESSAGE.  T1 CONTAINS THE FIRST WORD.  RETURN WITH
		A POPJ P, AND T1 LOADED AS FOLLOWS:
		IF THE ENTIRE MESSAGE IS TO BE INPUT, T1 SHOULD
			CONTAIN A LEGAL IOWD POINTER.
		IF THE MESSAGE IS TO BE IGNORED, T1 SHOULD CONTAIN
			ANY POSITIVE NUMBER.
		IF IT IS DESIRED THAT IMPIN(OR IMPONE, BELOW) BE
			CALLED ON THE NEXT INPUT WORD, T1 SHOULD
			BE ZEROED.

IMPEIM--	CALLED WHEN AN END-OF-MESSAGE HAS BEEN RECEIVED.  T1
		CONTAINS THE CURRENT BLKI POINTER.
		RETURNS NON-SKIP ALWAYS.

IMPIND--	CALLED WHEN A SUPPLIED INPUT IOWD POINTER RUNS OUT.
		THE OLD POINTER(EXPIRED) IS IN T1 (SEE IMPEIM).  RETURN WITH
		A POPJ P, WITH T1 LOADED AS IN IMPIN, ABOVE.
\
SUBTTL PARAMETERS ;⊗ IMP POWER DOWN10 SICK DEAD ENDIN ENDIN EMPTY FULL CSICK DOWN10 OUTSTP OUTEND GOTEND MPEENB MPPENB MPIENB MPEPIA MPPPIA MPIPIA IMP TYHB RFNHB TEST IMPERR IDONE IEND ODONE NREADY IEPIA IDPIA ODPIA TEST STRIN I32 O32 CLRST CLRWT STROUT FINO IEPIEN IDPIEN ODPIEN PIA ISTART IFLUSH SICK DEAD FULL ENDIN EMPTY MPIPIA MPEPIA MPPPIA CSICK OUTEND MPIENB MPPENB MPIENB MPPENB MPEENB ALLENB MPISET MPESET MPPSET

;HARDWARE DEFINITIONS

IFN FTF2,<
;The F2 IMP interface looks much the same as the DEC standard.
.FATAL 32-bit IMP code for F2 not written yet

IMP==	   550	;IMP DEVICE NUMBER

;CONI BITS
POWER==	200000	;IMP INTERFACE TURNED ON
DOWN10==100000	;PDP-10 WAS DOWN
SICK==   40000	;IMP WAS DOWN
DEAD==   20000	;IMP CURRENTLY DOWN
NOWAITS<
ENDIN==:  4000	;EOM RECEIVED
>;NOWAITS
IFWAITS<
ENDIN==: 14000	;EOM RECEIVED (I don't know why it's two bits at LLL either)
>;IFWAITS
EMPTY==:   200	;OUTPUT BUFFER EMPTY
FULL==:	    10	;INPUT BUFFER FULL

;CONO BITS
CSICK== 200000	;CLEAR SICK FLAG
DOWN10==100000	;PDP-10 IS UNHEALTHY
OUTSTP== 40000	;CLEAR EMPTY FLAG
OUTEND== 20000	;SEND EOM
GOTEND== 10000	;ACKNOWLEDGE INPUT EOM
MPEENB==  4000	;ENABLE PI FIELD FOR ENDIN INTERRUPT
MPPENB==   200	;ENABLE PI FIELD FOR OUTPUT INTERRUPT
MPIENB==    10	;ENABLE PI FIELD FOR INPUT INTERRUPT

MPEPIA==: 3400	;Endin PI channel bits
MPPPIA==:  160	;Output PI channel bits
MPIPIA==:    7	;Input PI channel bits
>;IFN FTF2

IFE FTF2,<
;For the SAIL interface, we first define names used by the old NCP code,
;and then define the equivalent TOPS-10 names.

IMP==	400			;Device number

; CONI bits

TYHB==	400000	; There's Your Host Bit
RFNHB==	200000	; Ready For Next Host Bit
TEST==	100000	; Interface is in test mode
IMPERR==040000	; IMP error (the READY line has gone down)
IDONE== 020000	; Input done
IEND==	010000	; Input end (end of message)
ODONE== 004000	; Output done
NREADY==002000	; IMP not ready if ¬TEST (actually ¬TEST∧¬READY)
IEPIA==	000700	; input end PI channel
IDPIA==	000070	; input done PI channel
ODPIA==	000007	; output done PI channel

; CONO bits

TEST==	100000	; Enter test mode.  In test mode the output side is
		; tied to the input side of the interface, and READY
		; is brought down
STRIN==	040000	; Start input, sets stop, clears IEND.
		; Stop means enable wait.  Wait happens after the
		; last bit has come in (if enabled by "stop") to
		; allow the programmer to change data modes before
		; the first bit of the next word comes in
repeat 0,<	;Combined with enable bits, see below
I32==	020000	; Set 32. bit input mode if IDPIEN set
O32==	010000	; Set 32. bit output mode if ODPIEN set
>;repeat 0
CLRST==	004000	; Clear stop
CLRWT==	002000	; Clear wait
STROUT==000200	; Start output
FINO==	000100	; Finish output (last bit has been sent)
IEPIEN==000040	; Enable change of IEPIA
repeat 0,<	;These are the actual enable bits
IDPIEN==000020	; Enable change of input byte size and IDPIA, clear IMPERR
ODPIEN==000010	; Enable change of output byte size and ODPIA
>;repeat 0
repeat 1,<	;This way we always set 32-bit mode when we enable
IDPIEN==020020	; Enable change of input byte size and IDPIA, clear IMPERR
ODPIEN==010010	; Enable change of output byte size and ODPIA
>;repeat 1
PIA==	000007	; PI channel (see IEPIEN, IDPIEN, ODPIEN)

;Useful combinations copied from old NCP IMPSER:
ISTART==STRIN!CLRWT!IEPIEN!IDPIEN!IMPCHN
IFLUSH==TEST!IEPIEN!IDPIEN!ODPIEN	;stop the IMP, turn off PIAs

SICK==	 IMPERR				;Equivalents
DEAD==   NREADY
FULL==:	 IDONE
ENDIN==: IEND
EMPTY==: ODONE
MPIPIA==:IDPIA
MPEPIA==:IEPIA
MPPPIA==:ODPIA
CSICK==	 IFLUSH
OUTEND== FINO
GOTEND== ISTART

MPIENB==IDPIEN
MPPENB==ODPIEN

MPEENB==IEPIEN
>;IFE FTF2

ALLENB==MPIENB+MPPENB+MPEENB

NOWAITS<
MPISET==MPIENB+MPIPI##		;SETS THE INPUT CHANNEL
MPESET==MPEENB+MPEPI##		;SETS E-O-M CHANNEL
MPPSET==MPPENB+MPPPI##		;OUTPUT CHANNEL
>;NOWAITS

;MACRO TO DISMISS INTERRUPTS IN VARIOUS WAYS

IFN FTXADR,<
DEFINE JMPENB(CH) <
	XJEN CH'CHL##
>
>;IFN FTXADR

IFE FTXADR,<
DEFINE JMPENB(CH) <
	  JEN	@CH'CHL##
>
>;IFE FTXADR
	SUBTTL INTERRUPT CODE ;⊗ MPIINT MPIIN1 ONEWRD MPIIN2 IGNORE

;MPI INTERRUPT SERVICE --  INPUT FROM IMP


NOWAITS<
MPIINT::CONSO	IMP,FULL	;IMP INPUT?
	JRST	.-1
MPIIN1:	SKIPL	BLKIPT		;GOOD BLKI?
	JRST	ONEWRD		;NO
	BLKI	IMP,BLKIPT	;READ
	SKIPA
	JMPENB	(MPI)		;DISMISS
	JSR	MPISAV##	;COUNTED OUT
	MOVE	T1,BLKIPT
	CONSZ	IMP,ENDIN	;WAS IT THE LAST ANYWAY?
	JRST	END2		;YES
	PUSHJ	P,IMPIND##	;NO.  TELL OF RUNOUT
	JRST	MPIIN2		;STORE NEW POINTER AND RESUME INPUT
>;NOWAITS

IFWAITS<
;Here from CONSZ chain in CACDAT with CONI bits in J.
MPIINT::TRNN J,MPIPIA		;Any input PIA?
	JRST IMPETS##		;No, return to CONSZ chain
	SKIPL BLKIPT		;Good BLKI?
	JRST ONEWRD		;No
IFE FTF2,<
;Compensate for KL-10 Model B microcode bug, where a BLKI may cause
;an extra DATAI unless we do this.
	EXCH T1,BLKIPT		;Save T1, get BLKIPT
	SETMM 1(T1)		;Reference the word being input
	EXCH T1,BLKIPT		;Restore T1 and BLKIPT
>;IFE FTF2
	BLKI IMP,BLKIPT		;Read a word
	JRST MPIIN4		;Counted out
	TRNE J,ENDIN		;Are we at the end of the message?
	JRST MPIIN3		;Yes
	MOVE J,IMPJ		;No, just restore saved AC
	JMPENB (MPI)		;and dismiss

MPIIN3:	MOVE J,IMPJ		;Restore saved AC
	JRST END1		;Tell IMP service about end of message

MPIIN4:	EXCH J,IMPJ		;Save CONI bits and restore saved AC
	JSR MPISAV##		;Get interrupt level ACs
	MOVE J,IMPJ		;Get back CONI bits from before the BLKI
;This is necessary with the SAIL interface because ENDIN would now be set
;if the next word to be read was the last word in the message.
	TRNE J,ENDIN		;Was it the end?
	JRST END2		;Yes, process end of message
;Note that we haven't set up T1 here as the TOPS-10 code does.  It isn't
;needed by IMPIND.
	PUSHJ P,IMPIND##	;No. Tell of runout
	JRST MPIIN2		;Store new pointer and resume input
>;IFWAITS

;EITHER FIRST INPUT OR THROWING AWAY DATA
ONEWRD:
NOWAITS<
	conso	imp,endin	;[96bit] EOM already on? (1 word long)
>;NOWAITS
IFWAITS<
	TRNN J,ENDIN		;EOM already on?
>;IFWAITS
	SKIPE	BLKIPT		;FIRST?
	JRST	IGNORE		;NO
;[96bit] no one word messages.
;[96bit]CONSZ	IMP,ENDIN	;EOM SEEN?  (MUST TEST BEFORE DATAI)
;[96bit]JRST	ONEIN		;YES
IFWAITS<
	MOVE J,IMPJ		;Restore saved AC
>;IFWAITS
	JSR	MPISAV##
	DATAI	IMP,T1		;GET LEADER
IFE FTF2,<
;When we acknowledged the end of the previous message with the STRIN bit, STOP
;was set, so on this input WAIT got set.  Here we clear WAIT, and clear STOP so
;remaining words of this message don't cause WAIT.
	CONO IMP,CLRWT!CLRST
>;IFE FTF2
	PUSHJ	P,IMPIN##	;EXCHANGE FOR BLKI POINTER
MPIIN2:	MOVEM	T1,BLKIPT
;[96bit] nobody ever uses this information.
;[96bit]SETZM	OVERFL		;CLEAR OVERFLOW COUNTER
;[96bit]SKIPLE	T1		;DISCARDING NEXT INPUT?
;[96bit]AOS	OVERFL		;YES, START COUNT
	POPJ	P,

IGNORE:	DATAI	IMP,DUMMY	;THROW AWAY OVERFLOW DATA
IFE FTF2,<
	TRNE J,ENDIN		;have we seen end of message yet?
	SETZM BLKIPT		;yes, we can quit ignoring garbage now
	CONO IMP,ISTART		;clear all of EOM, IMPERR and WAIT
>;IFE FTF2
IFWAITS<
	MOVE J,IMPJ		;Restore saved AC
>;IFWAITS
	JMPENB	(MPI)		;DISMISS
;MPE INTERRUPT SERVICE  --  END-OF-MESSAGE ;⊗ MPEINT END2 END3 MPEINT END1 END2

NOWAITS<
MPEINT::CONSO	IMP,ENDIN	;IMP END OF INPUT?
	JRST	.-1
	CONSZ	IMP,FULL	;YES, DID INPUT FLAG COME UP JUST NOW?
	JRST	MPIIN1		;YES, HANDLE IT FIRST
	JSR	MPESAV##
;[96bit]SKIPL	T1,BLKIPT	;UNDERFLOW?
;[96bit]HRL	T1,OVERFL	;NO.  PERHAPS OVERFLOW
	skipge	t1,blkipt	;[96bit] load t1, skip if ingoring input
END2:	PUSHJ	P,IMPEIM##	;TELL IMP SERVICE
	SETZM	BLKIPT		;READY FOR NEXT INPUT MESSAGE
;[96bit]SETZM	OVERFL
END3:	CONO	IMP,GOTEND	;RESUME INPUT
	POPJ	P,

;[96bit] imp-host messages no longer fit in one word: handle
;	 like buffered input.
;ONEIN:	DATAI	IMP,T1		;GET LEADER
;[96bit]PUSHJ	P,IMPONE##	;SEND MESSAGE TO IMPSER
;[96bit]JRST	END3
>;NOWAITS

IFWAITS<
;Code reorganized to do the CONO before calling IMPEIM, so that hardware
;can start getting the next word from the IMP while we ponder this packet.

;Here (with CONI bits in J) on end of input message without end-of-word
;having happened simultaneously.
MPEINT::TRNN J,MPEPIA		;Any input-end PIA?
	JRST IMPOTS##		;No, return to CONSZ chain
	MOVE J,IMPJ		;Restore saved AC
	SKIPGE BLKIPT		;Skip if ignoring input
	JRST END1
	CONO IMP,GOTEND		;Acknowledge end of message
	SETZM BLKIPT		;Ready for next input message
	JMPENB (MPE)		;Dismiss

END1:	JSR MPESAV##		;Get interrupt level ACs
;Here with interrupt-level ACs already set up on end of message after
;having read last input word.
END2:	CONO IMP,GOTEND		;Acknowledge end of message
	MOVE T1,BLKIPT		;Get BLKI ptr for MES00 in IMPMAC.MAC
	SETZM BLKIPT		;Ready for next input message
	JRST IMPEIM##		;Process this message
>;IFWAITS
;MPP INTERRUPT SERVICE -- OUTPUT TO IMP ;⊗ MPPINT DONE NONE

MPPINT::
NOWAITS<
	CONSO	IMP,EMPTY	;IMP OUTPUT?
	JRST	.-1
>;NOWAITS
IFWAITS<			;Here with CONI bits in J
	TRNN J,MPPPIA		;Any output PIA?
	JRST IMPCTS##		;No, return to CONSZ chain
	MOVE J,IMPJ		;Restore saved AC
>;IFWAITS
	SKIPL	BLKOPT		;LEGIT IOWD?
	JRST	DONE		;NO
IFE FTF2,<
	AOSN OUTBGN		;Is this the first word in a message?
	CONO IMP,STROUT!MPPENB!MPPPI##	;Yes
repeat 0,<			;*** Debugging code
	SKIPE OUTBGN		;*** Check again for beginning of msg
	JRST MPPINX		;*** No, go do normal stuff
	JSR MPPSAV##		;*** Set up ACs so we can call XOUTMS
	HRRZ J,BLKOPT		;***
	ADDI J,1		;*** Addr of 1st output word
	PUSHJ P,XOUTMS##	;*** Say we are sending a msg
	BLKO IMP,BLKOPT		;*** Now do the output
	 PUSHJ P,IMPBUG##	;*** This can't happen now!!!
	POPJ P,			;*** This will dismiss
MPPINX:				;***
>;repeat 0
>;IFE FTF2
	BLKO	IMP,BLKOPT	;YES
	JRST	.+2		;BLKO RUNOUT
	JMPENB	(MPP)		;DISMISS
	JSR	MPPSAV##
	MOVE	T1,BLKOPT
	PUSHJ	P,IMPOND##	;RETURN ANOTHER BLKO POINTER
	MOVEM	T1,BLKOPT
	POPJ	P,		;DISMISS INTERRUPT

DONE:	SKIPG	BLKOPT		;CLEARED?
	JRST	NONE		;YES
	JSR	MPPSAV##	;NO
	CONO	IMP,OUTEND	;SEND EOM
IFE FTF2,<
	SETOM OUTBGN		;Next word will start a message
>;IFE FTF2
	PUSHJ	P,IMPEOM##	;TELL IMP SERVICE
	  SETZ	T1,		;QUEUES ARE EMPTY
	MOVEM	T1,BLKOPT
	POPJ	P,		;DISMISS

NONE:	SETZM	OUTACT		;SET INACTIVE
IFN FTF2,<
	CONO	IMP,OUTSTP	;STOP HARDWARE
>;IFN FTF2
IFE FTF2,<
	CONO IMP,MPPENB		;Disable output interrupts
>;IFE FTF2
	JMPENB	(MPP)		;DISMISS


;LEGAL FLAG STATES:

;BLKOPT:	 -,	 +,	 0,	 0
;OUTACT:	-1,	-1,	-1,	 0
;STATE NUMBER:	 1,	 2,	 3,	 4 

;	1.	NORMAL TRANSMISSION IN PROGRESS.  OUTPUT REQUESTS
;		MUST BE QUEUED.
;	2.	OUTPUT BLOCK DONE.  EOM ON NEXT INTERRUPT.  OUTPUT
;		REQUESTS MUST BE QUEUED.
;	3.	STOPPING.  QUEUES WERE EMPTY.  OUTPUT REQUEST MAY
;		BE DEPOSITED DIRECTLY IN BLKOPT.
;	4.	INACTIVE.  HARDWARE MUST BE RESTARTED ON OUTPUT
;		REQUESTS.
SUBTTL SUBROUTINES ;⊗ IMPOUT IMPOU0 IMPOU1 IMPOU2

;HERE TO OUTPUT A BLOCK TO THE IMP
;INTERRUPTS MUST BE DISABLED
;CALL:
;	MOVE T1,[IOWD LENGTH,ADDRESS]
;	PUSHJ P,IMPOUT
;	RETURN HERE IF MUST QUEUE
;	HERE IF OUTPUT STARTED

IMPOUT::
NOWAITS<
	consz	pi,impbts##	;(debug) are the IMPs enabled?
	 stopcd	.+1,DEBUG,IDE	;(debug) imps dangerously enabled.
>;NOWAITS
IFWAITS<
repeat 0,<		;Only do this if we're paranoid.
	;We want to allow getting here at IMP interrupt level without
	;turning off interrupts.
	CONSO PI,77000		;At interrupt level?
	CONSO PI,IMPBTS##	;No, IMP interrupts off?
	JRST IMPOU0		;Yes, ints off or at int level
	STOPCD .+1,DEBUG,IDE	;IMPS dangerously enabled
IMPOU0:
>;repeat 0
>;IFWAITS
	SKIPE	BLKOPT		; ALREADY OUTPUTTING?
	POPJ	P,		;YES.
	JUMPGE	T1,CPOPJ1##	;PRETEND OK IF NOTHING THERE
	SKIPE	OUTACT		;ACTIVE?
	JRST	IMPOU2		;YES, JUST STORE NEW BLKOPT
	SETOM	OUTACT		;FLAG ACTIVE
IFE FTF2,<
	CONO IMP,STROUT!MPPENB!MPPPI##	;Start output going
	SETZM OUTBGN			;Next word doesn't start a message
>;IFE FTF2
	blko	imp,t1		;[96bit] output the first word
	  jrst	cpopj1		;[96bit] should never be here, ever.
NOWAITS<
IMPOU1:	CONO	IMP,MPPSET	;ENABLE OUTPUT HARDWARE
>;NOWAITS
repeat 0,<
IFWAITS<
	PUSH P,J		;*** Being safe
	MOVE J,T1		;***
	PUSHJ P,XOUTMS##	;*** Say that we're sending a message
	POP P,J			;***
>;IFWAITS
>;repeat 0
IFN FTF2,<
	CONO	IMP,MPPENB!MPPPI##	;ENABLE OUTPUT HARDWARE
>;IFN FTF2
IMPOU2:	MOVEM	T1,BLKOPT	;STORE NEW IOWD
	JRST	CPOPJ1		;SKIP RETURN
;CODE TO CHECK HARDWARE HEALTH ;⊗ IMPCHK

;CALL:
;	PUSHJ	P,IMPCHK
;	  ERROR RETURN	...  IMP OR INTERFACE DOWN
;	  ERROR RETURN	...  IMP OR INTERFACE WAS DOWN
;	OK RETURN

IMPCHK::
NOWAITS<
	MOVEI	T4,EMPTY	;ENABLE OUTPUT FLAG TEST
	HRRM	T4,MPPINT
	CONO	IMP,MPPSET	;MAKE SURE OUTPUT ON
>;NOWAITS
IFWAITS<
	CONO	IMP,MPPENB!MPPPI##;MAKE SURE OUTPUT ON
>;IFWAITS
	SKIPE	INPON		;WANT INPUT OPEN?
	PUSHJ	P,IMPION	;YES, MAKE SURE TURNED ON
IFN FTF2,<
	CONSO	IMP,POWER	;POWER DOWN?
	POPJ	P,		;YES
>;IFN FTF2
	CONSO	IMP,SICK	;INTERFACE ERROR?
	JRST	CPOPJ2##	;NO, DOUBLE SKIP
	CONSZ	IMP,DEAD	;IS IT STILL DOWN?
	POPJ	P,		;YES
	CONO	IMP,CSICK	;CLEAR FAULT
	JRST	CPOPJ1		;AND TAKE SINGLE SKIP
;INITIALIZE DEVICES ;⊗ IMPDWN IMPIOF IMPION

;SUBROUTINE TO TURN THE HARDWARE OFF
IMPDWN::
IFN FTF2,<
	CONO	IMP,DOWN10+ALLENB;TURN OFF HARDWARE
>;IFN FTF2
IFE FTF2,<
	CONO IMP,IFLUSH		;Stop the IMP, turn off PIAs
>;IFE FTF2
NOWAITS<
	HLLZS	MPPINT		;DISABLE OUTPUT FLAG TEST IN SKIP CHAIN
>;NOWAITS
	SETZM	OUTACT
	SETZM	BLKIPT
	SETZM	BLKOPT

;HERE TO TURN OFF INPUT
IMPIOF::SETZM	INPON		;TURN OFF INPUT ACTIVE FLAG
	CONO	IMP,MPIENB!MPEENB	;TURN OFF INPUT
NOWAITS<
	HLLZS	MPIINT		;DISABLE INPUT FLAG TESTS
	HLLZS	MPEINT
>;NOWAITS
	POPJ	P,

;HERE TO TURN INPUT ON
IMPION::SETOM	INPON		;TURN ON FLAG FOR CLOCK
NOWAITS<
	push	p,t1		; save a scratch
	MOVEI	t1,FULL		;ENABLE INTERRUPT FLAG TESTS
	HRRM	t1,MPIINT
	MOVEI	t1,ENDIN
	HRRM	t1,MPEINT
	pop	p,t1		; restore scratch reg.
	CONO	IMP,MPISET	;TURN ON INPUT
	CONO	IMP,MPESET
>;NOWAITS
IFWAITS<
	;Turn on input with a single CONO, since we run all the types
	;of IMP interrupts in the same channel.
	CONO IMP,MPIENB!MPEENB!MPIPI##!MPEPI##
>;IFWAITS
	POPJ	P,

>;IFN FTAIP
IFWAITS< ;⊗ SAVE1 SAVE2 SAVE3 SAVE4 RES4 RES3 RES2 P1POPJ RES1 SAVT T4POPJ TPOPJ1 TPOPJ T2POJ1 T2POPJ FPOPJ1 FPOPJ

;Note: these MUST be defined outside the FAIL assembly of WAITS, and made
;external, because TPOPJ here is different from TPOPJ in the rest of WAITS.
;The TPOPJ in the FAIL code is not external, and it all works.

;These definitions cannot be included in any MACRO files that reference them,
;because MACRO complains when they are referenced as external and defined in
;the same file.

;SUBROUTINES TO SAVE AND RESTORE PRESERVED ACS
;SAVEN IS CALLED AT THE BEGINNING OF A SUBROUTINE
;FOR CONVENIENCE NO MATCHING SUB IS NEEDED TO BE CALLED
;TO RESTORE THIS ACS.
;INSTEAD AN EXTRA RETURN IS PUT ON STACK
;5 CHAR NAME INDICATES IT VIOLATES
;SUBROUTINE CALLING CONVENTIONS
;CALL:	PUSHJ	P,SAVEN
;	RETURN	HERE IMMEDIATELY WITH EXTRA RETURN ON STACK
;	RESPECTS ALL ACS

;NOTE:	THIS CODE USES 1 LOC BEYOND END OF STACK BUT THEN PUSHES ON TOP OF IT
;SO GET OVERFLOW INTERUPT IF TOO FULL.  OK TO DO 1(P) SINCE THIS WORD WRITTEN ON OVERFLOW

SAVE1::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,(P)		;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES1
	AOS	-1(P)
	JRST	RES1

SAVE2::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-1(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES2
	AOS	-2(P)
	JRST	RES2

SAVE3::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-2(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES3
	AOS	-3(P)
	JRST	RES3

SAVE4::	EXCH	P1,(P)		;SAVE P1, GET CALLER PC
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	MOVEM	P1,1(P)		;SAVE CALLER PC ONE BEYOND END
	MOVE	P1,-3(P)	;RESTORE P1
	PUSHJ	P,@1(P)		;GO BACK TO CALLER, OVERWRITE CALLER PC WITH .+1
	  JRST	RES4
	AOS	-4(P)
RES4:	POP	P,P4
RES3:	POP	P,P3
RES2:	POP	P,P2
P1POPJ::
RES1:	POP	P,P1
	POPJ	P,
;SUBROUTINE TO SAVE AND RESTORE TEMP ACS
;CALLED BY PUSHJ P,SAVT   RETURN EITHER CPOPJ OR CPOPJ1 WHEN THROUGH
SAVT::	EXCH	T4,(P)		;SAVE T4, GET RETURN ADR.
	PUSH	P,T3		;SAVE T3
	PUSH	P,T2		;AND T2
	PUSH	P,T1		;AND T1
	MOVEM	T4,1(P)		;STORE PC
	MOVE	T4,-3(P)	;RESTORE T4
	PUSHJ	P,@1(P)		;RETURN TO CALLER
	  SKIPA			;POPJ RETURN
	AOS	-4(P)		;CPOPJ1 - SET SKIP RETURN
	POP	P,T1		;RESTORE T1
	POP	P,T2		;RESTORE T3 ACS
	POP	P,T3
T4POPJ::POP	P,T4
	POPJ	P,		;AND RETURN

;COMMON SUBROUTINE RETURNS

TPOPJ1::AOS	-1(P)
TPOPJ::	POP	P,T1		;RESTORE T1
	POPJ	P,		;AND RETURN

T2POJ1::AOS	-1(P)
T2POPJ::POP	P,T2		;RESTORE T2
	POPJ	P,

FPOPJ1::AOS	-1(P)
FPOPJ::	POP	P,F		;RESTORE F
	POPJ	P,		;RETURN

>;IFWAITS
;⊗ BLKIPT INPON DUMMY BLKOPT OUTACT

IFN FTAIP,<

	$LIT
NOWAITS<
	$LOW

;STORAGE

BLKIPT:	0		;BLKI POINTER
INPON:	0		;-1 IF INPUT SHOULD BE ACTIVE
DUMMY:	0		;PLACE TO PUT DISCARDED INPUT DATA

BLKOPT:	0		;BLKO POINTER
OUTACT:	0		;-1 IF OUTPUT IS ACTIVE
>;NOWAITS

IFWAITS<
	EXTERN	BLKIPT,INPON,DUMMY,BLKOPT,OUTACT,IMPJ
IFE FTF2,<
	EXTERN	OUTBGN
>;IFE FTF2
>;IFWAITS

>;IFN FTAIP

	END
