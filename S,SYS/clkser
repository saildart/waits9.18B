COMMENT ⊗   VALID 00074 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00013 00002	APRINT APRNIL
C00015 00003	BRKTST BRKHIT BRKXIT BRKERR BRKER1
C00018 00004	KLTINT KLTIN1
C00020 00005	BREAKX APR.I1 PITINC PITINU NOPIT BREAK3 APRI1
C00024 00006	 APRI1A APR1A1 APR1A3 APR1A7 APR1A6 APR1A4 APR1A8 APR1A9 APRI1B CARDON APRADD MTRTM0 MTRTM1 MTRTM2 NOMTR
C00033 00007	APRCI2 APRCI4 APRCI5 APRCI9 APRCI3 APRDEL APRDL1 APRDRL
C00037 00008	APRI2 APRI2K APRI2L APRI2M APRI2N APRI2O APRI2W APRI2X P1RET APRI2P
C00041 00009	APRER APRNSC APRNS1 APRER1 APRER6 APRE6A APRE6B APRER2 APRER3 APRERB APRER4 APRERC APRSCR
C00049 00010	APRERU APREU1 APREU2 APREU3 APREU4 APRERV APREV2 APRFL2 APRFLT APRMPV
C00057 00011
C00059 00012	 KCLKIN CLKIN0 CLKINT INTXTS NOTCH7 MTDINE
C00066 00013	CLKIN1 CLKERR CLKER1 FOO01 CIP2 MIDCHK MIDCHL PDTCHK PDTST1 PDTST2 PDTSTD
C00074 00014	P1 CLOCK LEVEL  CIP2A CIP2B CIP2DA CIP2SP CIP2D DATEOK FUNTIM TIMEOK CRKT1 CRKT1A CRKT2 HNGP2D TDSET
C00094 00015	CRKT4 CIP4 CIP5AA CIP5A CIP5 CNTCPT CNTCP1 NCLKRQ NCLKRQ CLKRQS LCLKRQ CLKUGH CQUERR CQUEUE
C00104 00016	SPWCHK CIP11A CIP11 CIP11B CIPNEG COMTIM CIP11E CIP11C CIP11D CIPFOO CLKSRJ CLKSRX COMLST COMLSL COMLS2
C00112 00017	S2U S2U1 U2S CIP6A CIP6B NULJOB CIP7XX
C00117 00018	CIP8X CIP8 CIP8AA CIP8A7 CIP8A8 CIP8C CIP8B
C00122 00019	NULJB NULPAG NULJP1 NULP1X NULJP2 NULP2X
C00124 00020	CHECK CHECK1 CHKNOW
C00127 00021	SYSFIX SYSFX1 NOTOK TTPPJ1
C00129 00022	INTRUN INTSC1 INTR2 INTR1 INTR11 INTSCR
C00133 00023	GETINT INTR8 GTINT1
C00135 00024	INTR9 INTR13 INTR14 INT14B INT14A INTR10 INTR5 INTR15 JWKCHK JWKCH0
C00143 00025	INTR4 INTR4A INTNKL
C00146 00026	INTADC INTXIT
C00148 00027	INTSWAPIN INTSWS INTSWT
C00150 00028	 INTCH7 INTERQ INTHL1 INTRU0 INTERU INTER1 INTERP INTAPR INTERR INTDSM INTDB1 INTDEB
C00155 00029	INTKILL
C00156 00030	INIJB0 INIJB1 INIJB2 INIJOB INIJBA INIJBC INIJXC INIJXA RELJOB RELJB1 MAKPDL INIJXX
C00163 00031
C00167 00032	NOCORE NOJOBN NOLOGIN NOACT INCORE NORUN SHRINK NOSKPB NOPRIV SETMAP NOINCK NOCRLF NOPER TTYRNU TTYRNC NOMESS DOLOG TYPEGO ERRFLG RPGBIT
C00170 00033	COMMAND.NAMES 
C00187 00034	XYZZY XYZZY COMTAB DISPL CTBL CCLOG DISP DSPLUZ NAM FCMTAB
C00190 00035	COMMAND COM0 SCREWU NOSCRU CMDMSK
C00195 00036	COMFND FRCCO1 COMNOL CHKNOX CHKNO CHKRUN CNCME2 CNCME4 CNCMES CNCMSG CNCME3 CNCMS2 JBCPEX FRCCOM
C00200 00037	CHKACT CHKCO2 CHKCO1 SQUASH
C00202 00038	COMER COMGO COMDIS COMDIP COMRET COMRNF COMRIP COMRE1 COMRT1 PCRLF PCRLF1 COMR2A SKPBRK SKPBR2 SKPBR1 SKPBR3 COMRT2 COMR2B COMR2F
C00211 00039	 CEDDT KLDLOD P2LOAD KLDLO2 KLDLO3 P2LOA2 KLDLDN P2LODN NBDCOM BRDCOM BRDOK BPCOM BPCMOK BPCOML BPCOM2 DQACOM DCACOM DCOCOM DCOCLP DCOULP DCOUL2 DCOUL3 DCOUL4 DCOUL5 DCODLP DCODL2 DCOTAB ECCCOM ECCCO2 ECCCOL ECCDUN ECCLUZ ECCOUT ECCOUL ECCOU2 SLEVEL TYPSL ELFQFI ELFQFL ELFQOK ELFQO2 ELFQLZ MTAFIX MTAFXL MTAFOK MTAOK MTAFLZ SETCTY SETCT2 SETCT3
C00231 00040	NOTLOG PTTY PTTY1 PTTYDT CLSCOM
C00238 00041	 PJOBDV PJOB DECLF PJOBX FNDDEV FNDD1A FNDDV1 FNDDV2 FNDDV3 PJPTY PJOBDL PJOBD2 PJBICK PJBGEN PJBGNL PJBGND PJBGN2 PJBGN6 PJBGN5 PJBG12 PJBG14 PJBG15 PJBG13 STTTAB STTLEN PJBGN4 PJBGN9 PJBGN3 PJBGN7 PJBIM2 PJBIMP PJBGN8 PJBG10 INLSPA SPAOUT SIXCNT SIXCN2 PJBUDP PJDVLZ PJGNLZ DEVFR2 DEVFR3 DEVFR1 DEVFR5 DEVFRE DEVFT2 PJBMSG PJPRNM
C00262 00042	PPPN PPPN5 PPPN6 PPPN65 PPPN7 PPPN8 PPPN9
C00264 00043	SDSKPPN SDKPP1 SDKPP2 CNGPRJ CDSKPPN ALDFL1 ALDFL2 GETWRB NOJUST GTWRB1
C00267 00044	 KJOB0 KJOB NOTLGI LOGPLS KJOB0A LOGPLM ADSRST ADSRSL ADSRS2 ADSRS3 KJOB1A KJOB1 JOBKL0 KJOB2 JOBKL JOBKL1 JOBKL2
C00277 00045	RESCOM RESCO3 RESCO2 KILUUO KILUU2 SOMCOR FKILLC KILCOM KILOK0 KILOK KILCM3 KILCM4 KILCM6 KILCM5 ILLKIL KILCMF KILCM1 RESCM1 FINCM1
C00288 00046	CORE CNOT0 COR3 CORFX CORFX1 COR0 JOB1 JOB1A
C00295 00047	CSHIFT COR4 COR4A COR2.1
C00297 00048	START STARTC STARTB STARTA STARTE REENTE REENTN REENTM STRTCK
C00300 00049	DDTGO DDTG2 DDTG3 DDTPUR DDTGOE
C00304 00050	STOP STOPB STOPB1 MAKCNC MAKCN2 CONTC CONT NOCONT
C00308 00051	SETWPS CLRWPS NOSPRO NOSPR1 SETRLC WPGTUP WPSEG NXSEG ILLPRO
C00312 00052	DISABL ENABLE NXPRV ILLPRV LFTTAB LFTLEN RHTTAB RHTLEN PRVSET FNDLFT FNDRHT ISALL ISLFT ISRHT
C00316 00053	PRJOB PRCNFG HELLO ALOGIN ALOGN1 SETTPV CLRTP0 CLRTPV  PRJOB PRCNFG HELLO ALOGIN ALOGN1 SETTPV CLRTP0 CLRTPV
C00319 00054	LOGDET LOGREF CLOGNF CLOGIN CXLOGI FLOGI2
C00323 00055	 HELP1 HLPRUN HELPX WHOCOM ERPGCM RPGCOM ACCCOM ETCOM PUMCOM DSCCOM CPYCOM ORACOM WHECOM TSTCOM MAICOM TSTCO2 FNDCOM DRDCOM SPLCOM NICCOM PRSRUN ATCOM TNCOM SDCOM LSPCOM TLKPGM UNPCOM UNDCOM UDPCOM UNPCO1 NSCOM3 FNGCOM CKMCOM CKMCO2 DSKCOM NSCOM2 NSCOM NSCOM1 HOTCOM HOTCOM MRDCOM MCOCOM MCOCO2
C00330 00056	CMDRUN ARCOM AXCOM ARCOM1 AXXCOM ARPCOM RCOM RUNCOM RUNCO2 RUNCO4 RUNCM RUNCO1 NOTPR0 NOTPRC GET SSAVE SAVE
C00338 00057	 ASSIGN ASSPP9 ASSPP1 ASSPP2 ASSPP3 ASSPP0 PUBBIT PRIBIT OLDBIT ASATTT NASATT ASATTB ASATBB ASSPP2 ASSPPX ASSG3 ASSG0 ASSG4 ASSUDP ASSUD1 ASSUD1 ASSUD2 AUDPPV ASSUD4 ASSUD5 ASSUD3 AUDPPB AUDPNU AUDCCN AUDFOO AUDPOL AUDOK ASSCKS ASCKS1 ASCKS2 ASCKS9 ASSG1 ASSG2
C00352 00058	ASSR1A ASSER1 ASSMS2 ASSFIN ASLNOK DEFLOS ASSF1 ASSF2 NOLOGP LOGERR DEFASS
C00356 00059	DEASSI DEAER4 DEAER3 DEADON DEADN1 NOTDEV DEAER1 PNOTDV DEAER2 DEALL
C00359 00060	REASSI REASS REASS1 REASS4 REASS2 REASS8 REAST2 REAST3 REAST1 REASS3 REASE1 REASE4 REASE3 REASE2 REASE5 REASE6 REASE7 REASSX
C00366 00061	ATTDLY ATTJBU FATTCH FATT2 ATTACH FATT1 THEHUN THEHU2 ATTFF1 ATTFF2 ATTNUM ATTNU0 ATTNU1 ATTNU3 ATTNER ATTCHK ATTCH2 ATTLOG ATTFOO ATTPTY ATTILA
C00380 00062	DEVATT ATTCTY CTYAT1 DADD02 DADD0X CTYATT ATTUDP DADD00 DADD01 DADD03 DADD04 ATT2 ATT8 ATT3 ATT5A ATT5 ATT7 ATT6
C00389 00063	FLUSH FLUSH0 FLUSH1 NOTTTY INUSE
C00391 00064	MFORK CFORK FORK FORK1 FORKC LOSEJB DETCHA DETCHB DETCHD DETCHE DETCHC DETCH1 CDETACH PDETCH DETCH0 DETNBR DETACH DETCTY DDDD03 DETSHR DDDUDP LOGER1 DDDDDD DDDD01 TEMP1 INUSE1 NODTTY NOATTY NOADD
C00408 00065	"DAYTIME" COMMAND  DAYTIM PRDATM SETTIM SETTI0 SETTI2 SETTI3 DAYT2 PDDATE DAYTAB MONTHB KL11TM KL11T2 DAYCNT MONTHX DCTOSD DCTOS1 DCTOS2 DCTOS3 DCTOS4 DCTOS5
C00422 00066	RUNTIM CRUN3 CRUN4 CRUN4D CRUN4C CRUN1 CRUN2 CRUN2X CRUN4B PITIME PITIM2 PITIML PITNAM PERCN0 PERCNT PERCN1 PR2SP TYOPOP PRCOMA PRCOLN PRTIME PRTIM1 PDTIMX PRTIM2 PRTIM3 PDTIM0 PDTIME PDTIM1
C00434 00067	TALK TALK0 TALK00 TALK9 TALK0L TALK1 TALK3 TALK4 TALK5 TALK5B TALK5A TALK7 TALK6 TALK62 TALK61 TALK8 TALKE4 TALKE5 TALKE6 TALKE7 TALKE8 TALKE9 NETALK
C00442 00068	EXAMINE/DEPOSIT commands  ECOM ECOM1 ECOM2 DCOM DCOMIX DEAT TESTIN ECOMP ECOMA PRVCHK PRVCH2 TTPOPJ
C00451 00069	CBLANK NOCOM
C00452 00070	FINIS FINPHA FIN00 FIN0 FIN3 FIN1 FIN2 FINRDV FINRD1 FINRD2 FINXIT FINREL FINRL2 FINRL1 FINSTK FINST1 FINST2 FINALL FINAL1 FINAL3 FINST4 FINST5 FINST3
C00460 00071	FREDEV FRUDP1 FRUDP2 FRUDP3 FRUDP4 FRUDP5 LOP01 LOP04 RESRES RESRE1 RESRE2 LP1RET SIXDKL RESOOP RESWAT RESCON RESCOL SATTAC
C00469 00072	ACTCHK ACTCH1 DLYCR2 DLYCR1 DLYCOR DLYCM DLYCM1 DLYCM3 DLYCM2 FRCUSR
C00473 00073	STOPCK STOPC1 STOPC2 STOPD STOPC
C00475 00074	"FILES <filename or job number>" -- print status of open files.  FILCOM FIL0 FIL6D FIL6 FIL6A FIL6E FIL6B FIL4 FIL3 FIL99 FIL88 FIL5 FIL5Q FIL5C FIL5D FIL5A FIL5G FIL5B FIL5F FIL2JB FIL2JL FIL2LZ FIL2JX FIL2 FIL2A PTFILE PTFIL0 PTFIL2 PR3SIX PR6SIX PRSIXA PRRECD PRRECL PRREC3 PRREC2 NXTDSK
C00489 ENDMK
C⊗;
;APRINT APRNIL
SUBTTL APRINT	8 SEPT 67

;THIS SERVICE ROUTINE RUNS ON A HIGH PRIORITY CHANNEL AND REQUESTS
;INTERRUPTS ON LOWER CLK CHANNEL FOR SCHEDULING JOBS AND ERROR
;HANDLING THAT THE USER IS NOT ENABLED TO HANDLE HIMSELF

;P1 ENTERS AT APRINT
;APR IS ALWAYS ENABLED FOR CLOCK,ILM,NXM,PDLOV, ALSO AROV IF THE USER REQUESTS

NOKL10,<			;Whole page
↑APRINT:EXCH PID,APRID+P1PID
	CAIE PID,P1PID
	HALT .+1
	MOVEI PID,P1PID

	AOSN PAGFLG		;SKIP UNLESS WE GOT HERE FROM PAGINT
	JRST APRFLT		;ILL MEM REF VIA PAGER
IFE FTF2,<
	CONSO APR,ILM		;SHOULDN'T HAPPEN ON P1 ANYMORE.
	JRST APRNIL		;OK.
	EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /ILL MEM REF BUT NO PAGE FAULT,  PC = /
	MOVE TAC,APRCHL
	PUSHJ P,DISOCT		;PRINT THE FLAGS TOO
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCA
	POPACS
	EXCH P,APRPDL
	CONO APR,ILM!APRCHN	;CLEAR SPURIOUS ILM
	JRST P1RET		;DISMISS INT.

>;IFE FTF2
APRNIL:
>;NOKL10
;FALL OFF THE PAGE
;BRKTST BRKHIT BRKXIT BRKERR BRKER1
;P1 APR INTERRUPT PROCESSING CONTINUES HERE.
;	FALLS THROUGH FROM ABOVE.

;ADDRESS BREAK SYSTEM.
;PUT THE EXCEPTED PCS (THE ONES YOU WANT TO IGNORE BREAKS FROM) IN BRKTAB,
; AND THE NUMBER OF EXCEPTED PCS IN BRKNUM.
;WHEN A BREAK OCCURS FROM SOME UNEXCEPTED PC, IT EXECUTES THE CODE AT
;BRKHIT, WHICH MAY BE PATCHED TO WHATEVER YOU WANT.
;NOTE THAT IF BRKNUM≤0 ALL BREAKS ARE EXCEPTED AND AN ERROR MESSAGE RESULTS

NOKL10,<			;Whole page
IFN PRCONF-1,<			;ASSEMBLE IF THIS SYSTEM HAS A KA10
IFE PRCONF-2,<LOSYS>
BRKTST:	CONSO APR,ADRBRK	;ADDRESS BREAK?
	JRST BREAKX		;NO.
	MOVEM TAC,BRKTAC	;SAVE A COUPLE OF ACCUMULATORS
	MOVEM AC1,BRKAC1
	HRRZ TAC,APRCHL		;PICK UP BREAK PC+1
	SUBI TAC,1		;MAKE IT HONEST
	SKIPLE AC1,BRKNUM	;ARE WE READY FOR A BREAK?
	CAILE AC1,BRKMAX	;YES.  REASONABLE NUMBER OF EXCEPTED PCS?
	JRST BRKERR		;NO. NOT READY
	CAMN TAC,BRKTAB-1(AC1)	;IS THIS PC EXCEPTED?
	JRST BRKXIT		;JUMP IF WE MATCHED SOME EXCEPTED PC.
	SOJG AC1,.-2		;NO. TRY NEXT ONE
BRKHIT:	REPEAT 10,<JFCL>	;PATCH HERE FOR UN-EXCEPTED BREAKS.
BRKXIT:	MOVE TAC,BRKTAC		;RESTORE ACCUMULATORS
	MOVE AC1,BRKAC1
	CONO APR,ADRBRK!APRCHN	;CLEAR BREAK BIT. SET PIA.  DISMISS
	JRST P1RET


BRKERR:	EXCH P,APRPDL
	PUSHACS
	CAIG AC1,BRKMAX		;SKIP IF ILLEGAL VALUE OF BRKNUM
	JUMPGE AC1,BRKER1	;JUMPE IF LEGAL VALUE OF BRKNUM
	PUSHJ P,DISMES
	ASCIZ /BRKNUM VAL ILLEGAL = / ;VALUE ILLEGAL
	HRRZ TAC,BRKNUM
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	SETZM BRKNUM
BRKER1:	PUSHJ P,DISMES
	ASCIZ /ADDR BRK, PC=/
	MOVE TAC,APRCHL
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	POPACS
	EXCH P,APRPDL
	JRST BRKXIT

IFE PRCONF-2,<HISYS>
>;IFN PRCONF-1			;ASSEMBLE FOR ANY SYSTEM THAT HAS A KA10
>;NOKL10
;KLTINT KLTIN1

IFKL10,<			;Whole page
;KLTINT - VECTOR INTERRUPT FROM INTERVAL TIMER COMES HERE IN APRCHN.

↑KLTINT:EXCH TAC,KLTINX		;SAVE TAC.  GET INTERUPT PC
	MOVEM TAC,APRCHL
	EXCH TAC,KLTINX
IFN FTXADR,<
	EXCH TAC,KLTINX+1	;SAVE TAC.  GET INTERUPT PC
	MOVEM TAC,APRCHL+1
	EXCH TAC,KLTINX+1
>;IFN FTXADR
	CHKPIS (0,\APRCHN)

	MTRCON (CH3,P2NOCK)

	SKIPLE KLITCN
	SETCMM KLITCN		;1 BECOMES -2
	AOSGE KLITCN		;0→1→-1→0...
	JRST KLTIN1
	CONO TIM,TIINON!TIINCL!=1667 ;CLEAR INTERRUPT. METER ON. TWO LONG TICKS
	JRST .+2
KLTIN1:	CONO TIM,TIINON!TIINCL!=1666 ;AND ONE SHORT TICK
	SKIPN IIIOFF
	CONSZ DPY,7		;IF III IS SHUT DOWN
	CAIA
	CONO PI,4000!<1⊗<7-APRCHN>> ;INITIATE INTERRUPT FOR III
				;(RESTART III WHEN IT IS IDLE)
	SETOM DSFLAG		;TELL DPYINT THAT CLOCK HAS TICKED.
	SETOM KLCLKF		;FLAG A CLOCK INTERRUPT
	EXCH PID,APRID		;KL10 CLOCK INTERRUPT.
	CAIE PID,P1PID
	HALT .+1
	MOVEI PID,P1PID
	JRST APR.I1
>;IFKL10
;BREAKX APR.I1 PITINC PITINU NOPIT BREAK3 APRI1

NOKL10,<
BREAKX:	CONSO APR,1B26		;IS IT A CLOCK TICK?
	JRST APRER		;NO, GO CHECK ERROR FLAGS
	CONO APR,1B26+APRCHN	;CLEAR THE CLOCK FLAG
>;NOKL10
;PROCESS CLOCK INTERRUPTS
;HERE FOR CLOCK TICK ON BOTH PROCESSORS (ENTER FROM KLTINT ON P1)
APR.I1:	MOVEM TAC,APRTAC	;GET AN ACCUMULATOR
	AOS TIME		;YES, INCREMENT TIME OF DAY
	AOS PSTIME
	SETOM TIMEFF		;FLAG THAT APR CLOCK HAS TICKED
	HLLOS CLKFLG		;SET FLAG FOR CLK FORCED INTERRUPT
	SKIPN PITFLG		;skip if want to compute time in lower PI chans
	JRST NOPIT		;don't waste time
	MOVE TAC,APRCHL		;get interrupt PC flags
	TLNE TAC,USRMOD		;skip if exec mode
	JRST PITINU		;count user mode upon int
IFG APRCHN-SCNCHN,<		;use this version if Scanner in high-priority chan
	CONSO PI,1⊗(7-SCNCHN)	;is scanner channel on?
	AOS SFTIME		;no, count its off time
>;IFG SCNCHN-APRCHN
	MOVEI TAC,UUTIME	;assume UUO level upon clk int
FOR @' I←APRCHN+1,7<
	CONSZ PI,<1B27>⊗(7-I)	;in progress in channel I?
	JRST TIME'I		;yes, increment count for channel I
IFE I-SCNCHN,<			;we're below scanner chan
	CONSO PI,1⊗(7-SCNCHN)	;is scanner channel on?
	AOS SFTIME		;no, count its off time
>;IFE I-SCHCHN
>;FOR
	JRST PITINC		;increment UUO level count

FOR @' I←APRCHN+1,7<
TIME'I:	AOJ TAC,		;back up to previous count cell (previous PI chan)
>;FOR
PITINC:	AOSA (TAC)		;count int from uuo level or PI chan
PITINU:	AOS USTIME		;count int from user level
NOPIT:	CONSZ PI,1B27*(1⊗(7-APRCHN)-1) ;Skip if not in prog on chn APRCHN+1 thru 7
	JRST BREAK3		;in progress on low PI chan
	MOVE TAC,JOB		;INCREMENT JOB'S RUNNING TIME
	AOS TTIME(TAC)		;TIME ACCOUNTING
	JUMPE TAC,APRI1		;DON'T COUNT KCJ FOR NULL JOB.
	MOVEM AC1,APRAC1	;GET AN AC
	HLRZ AC1,JBTPAG(TAC)	;GET CURRENT JOB'S PAGE COUNT
	ADDM AC1,JBTKCJ(TAC)	;PAGE-JIFFIES
	MOVE AC1,APRAC1		;GET BACK OUR AC
	AOSA JBTRNB(TAC)	;INCREMENT JOB LOADING.  SKIP
BREAK3:	AOS INTIME		;INCREMENT INTERRUPT LEVEL TIME
APRI1:	AOS TAC,UPTIME		;INCREMENT SYSTEM UPTIME.
	JRST APRI1A		;(TO HISYS) TAC HAS UPTIME.
;⊗ APRI1A APR1A1 APR1A3 APR1A7 APR1A6 APR1A4 APR1A8 APR1A9 APRI1B CARDON APRADD MTRTM0 MTRTM1 MTRTM2 NOMTR

;APRI1A, APRADD, KL10 METER SERVICE, - P1 CLOCK ONLY

HISYS

;DATA DISK AND CART CLOCKS LIVE HERE.

;ENTER HERE FOR P1 CLOCK TICKS AFTER TIME ACCOUNTING
;TAC CONTAINS UPTIME IN TICKS
APRI1A:	TRNE TAC,7777		;SKIP APPROXIMATELY ONCE A MINUTE
	JRST APRI1B		;NO, DON'T DO PER-MINUTE ROUTINE
;Now we see if any DCA ports have been interrupting too much lately.
	EXCH P,APRPDL		;GET A PDL
	PUSH P,TAC1		;GET AN AC
	MOVSI TAC,-DCANUM	;Nbr of DCA ports checked for excessive interrupts
APR1A1:	MOVE TAC1,DCAPIN(TAC)	;Get current total ints per port
	EXCH TAC1,DCACIN(TAC)	;Store and get old total
	SUB TAC1,DCACIN(TAC)	;Negative nbr of new ints
	MOVNM TAC1,DCAREC(TAC)	;Store recent interrupt count
	MOVEI TAC1,0
	EXCH TAC1,DCAINN(TAC)	;GET AND CLEAR A COUNT
IFE FTLLL,<
	CAIGE TAC1,=6825	;ABOUT 1000 BAUD IN CHARS/PSEUDO-MINUTE
>;IFE FTLLL
IFN FTLLL,<
	CAIGE TAC1,-1		;LET 'ER RIP
>;IFN FTLLL
APR1A3:	AOBJN TAC,APR1A1	;OK, TRY ANOTHER
	JUMPGE TAC,APR1A9	;JUMP IF ALL OK
	CAIL TAC1,=13650	;SKIP IF UNDER 2000 BAUD
	JRST APR1A7		;SHUT PORT OFF (UNLESS DIALNET)
	MOVE TAC1,DCATAB(TAC)	;BETWEEN 1000 AND 2000, SHUT OFF IF DD/III KBD
	TRNN TAC1,DCADPB	;WHICH IS INDICATED BY DPY BIT
	JRST APR1A3		;NOT MICROSWITCH KBD, LEAVE ALONE
APR1A7:	PUSHACS
	MOVE DDB,DCATAB(TAC)	;GET DCATAB
	TRNE DDB,DCADLB		;DIALNET PORT?
	JRST APR1A8		;*** FOR NOW, NEVER DO ANYTHING ABOUT DLN PORTS
	TRNN DDB,DCAPRM		;skip if this is not a phone line
	TLNN DDB,DCACAR		;skip if carrier detect on
	JRST APR1A6		;not phone, or no carrier, can't hang up
	IORI TAC,400000		;make port number with high RH bit on
	PUSHJ P,DCAHNG		;hang up that port
	 JFCL			;failed (shouldn't happen), not a phone
	PUSHJ P,DISUSR		;print time for new message on cty
	 SIXBIT /DEVICE/
	PUSHJ P,DISERR
	 [ASCIZ/Hanging up phone for runaway DCA port /]
	 DISARG LOC,<TAC-20(P)>
	 [ASCIZ/
/]
	-1
	JRST APR1A8		;restore all ACs and re-loop

APR1A6:	TRNN DDB,DCADWN		;Skip if port is already down
	JRST APR1A4		;No, turn it off and notify CTY
IFN FTP2,<
	SETOM KABELL		;WAKE SOMEONE UP
>;IFN FTP2
IFN FTDCHK,<
	HRRZM TAC,CHKDCA	;Request standard DCA status for CTY
>;IFN FTDCHK
	PUSHJ P,DISGST		;Print time of message on CTY
	PUSHJ P,DISERR
	 [ASCIZ /HELP!  DCA port  /]
	 DISARG LOC,<TAC-20(P)>
	 [ASCIZ /  is still interrupting continuously although turned off.
Please unplug this port's cable from the back of the DCA scanner.
(If you need help, call a wizard.)  After unplugging, type "$P".  /]
	 -1
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCAL
	JRST APR1A8

APR1A4:	HRLI TAC,DCARUN		;CH7 ROUTINE TO NOTIFY OPERATOR, also det's job
	SYSPIFF
	IDPB TAC,CLKQ
	SYSPIN
	MOVEI TAC,400000(TAC)	;PORT NUMBER IN TTYSER FORMAT
printx DCADET is called from Ch3 but scanner isn't interlocked with Ch3.
	PUSHJ P,DCADET		;TURN THE PORT OFF IN HARDWARE
APR1A8:	POPACS
	AOBJN TAC,APR1A1	;FINISHED WITH BUG TRAP, BACK TO LOOP
APR1A9:	POP P,TAC1
	EXCH P,APRPDL
	MOVE TAC,UPTIME		;Get back current time count
APRI1B:
IFN CARNUM,<
	CAML TAC,CARALR		;TIME TO RUN HI-PRIORITY CART CLOCK?
	JRST CARNXT		;YES. CLOBBERS TAC.
↑CARDON:
>;IFN CARNUM

IFN FTDD,<
	SOSGE DDCNT		;HAS DATA DISK TIMED OUT??
	JRST DDCLK		;YES, GO FLUSH IT  (RETURN TO APRADD)
	SKIPE DDSTART		;DO WE NEED TO START IT UP?
	JRST DDSTRT		;YES, DO SO.  (RETURN TO APRADD)
↑APRADD:			;RETURN HERE FROM DPYSER
>;IFN FTDD
IFN FTGRIN,<
	SOSGE DDCNT		;HAS DISPLAY TIMED OUT??
	CONO PI,GRNGEN		;YES, GENERATE INTERRUPT ON APPROPRIATE CHANNEL
>;IFN FTGRIN
IFKL10,<
	SKIPG MTRBKG		;SKIP IF METER IS IN BACKGROUND MODE
	JRST NOMTR		;NOPE, DON'T INTERFERE
	MOVE TAC,UPTIME
	TRNE TAC,3		;ONLY SAMPLE METER EVERY FOURTH TICK
	JRST NOMTR
	EXCH P,APRPDL
	PUSH P,AC1
	PUSH P,AC2
	SKIPN TAC,MTRPTR	;GET CURRENT METER POINTER
	JRST MTRTM1		;IF NONE, START OVER
	BLKI TIM,AC1		;READ DOUBLE WORD METER
	DMOVEM AC1,MTRVAL(TAC)	;STORE CURRENT VALUE
	DADD AC1,MTRTOT(TAC)	;ADD TO MAKE CUMULATIVE TOTAL
	DMOVEM AC1,MTRTOT(TAC)	;STUFF RESULT BACK
	DMOVE AC1,MTRVAL(TAC)	;GET THE CURRENT VALUE AGAIN
	DADD AC1,MTRTMP(TAC)
	DMOVEM AC1,MTRTMP(TAC)	;INCREMENT TABLE OF 16 RECENT VALUES
	MOVE AC1,MTRNUL(TAC)	;NUMBER OF TIMES METER POINT REACHED THIS TIME
	ADDM AC1,MTRNUT(TAC)	;UPDATE TOTAL FOR THIS ONE
	ADDM AC1,MTRNUP(TAC)	;ALSO UPDATE TEMP FOR 16 ITEM TOTAL
	AOS AC1,MTRCNT(TAC)	;COUNT A VALUE READ
	TRNE AC1,17		;16 ITEMS COMPLETE?
	JRST MTRTM0		;NOT YET
	DMOVE AC1,MTRTMP(TAC)
	DMOVEM AC1,MTRREC(TAC)	;SAVE TOTAL OF 16 RECENT VALUES
	SETZM MTRTMP(TAC)	;AND CLEAR TEMP ACCUMULATOR FOR NEXT TIME
	SETZM MTRTMP+1(TAC)
	MOVE AC1,MTRNUP(TAC)
	MOVEM AC1,MTRNUR(TAC)	;SAVE RECENT 16 COUNT
	SETZM MTRNUP(TAC)	;AND RESET TEMP COUNT
MTRTM0:	HRRZ TAC,MTRLNK(TAC)	;GET LINK TO NEXT METER BLOCK
	SKIPN TAC		;SKIP UNLESS END OF LIST.
MTRTM1:	MOVEI TAC,MTRLST	;START AT FRONT OF METER LIST
	MOVEM TAC,MTRPTR	;SAVE POINTER FOR NEXT TIME
	BLKO TIM,[40]		;STOP COUNTING, CLEAR METER
	SETZM KLEPT+EPTPRF	;CLEAR EPT LOCATIONS FOR METER
	SETZM KLEPT+EPTPRF+1
	SETZM MTRNUL(TAC)
IFE FTKLB,<
	CLRUS1			;CLEAR MICROCODE STATE 1
	HLRZ AC2,MTRLNK(TAC)
	MOVEM AC2,MTRCNM	;SAVE METER TYPE NUMBER (SEE MTRON MACRO)
	CAME AC2,MTRCNW		;ARE WE ABOUT TO METER AN EVENT IN PROGRESS?
	JRST MTRTM2
	SETUS1			;YES.  SET MICROCODE STATE 1
	AOS MTRNUL(TAC)
>;IFE FTKLB
MTRTM2:	BLKO TIM,MTRDAT(TAC)	;SET METER CONDITION. START COUNTING
	POP P,AC2
	POP P,AC1
	EXCH P,APRPDL
NOMTR:
>;IFKL10

;FALL OFF THE PAGE
;APRCI2 APRCI4 APRCI5 APRCI9 APRCI3 APRDEL APRDL1 APRDRL
;APRDEL, APRDRL - P1 CLOCK ONLY.

;FALLS THROUGH

;GENERATE ANY USER CLOCK-INTERRUPTS NEEDED.
;APRLST POINTS TO A LIST, 2-WORDS PER ENTRY
;LH OF FIRST WORD IS TIME BETWEEN INTERRUPTS
;RH OF FIRST WORD IS JOB NUMBER
;SECOND WORD IS NEGATIVE COUNT OF TIME BETWEEN INTERRUPTS

	SKIPN TAC,APRLST	;ANY INTERRUPTS TO GIVE?
	JRST APRI2		;NO, EXIT NOW
	MOVEM J,APRJ
	MOVEM AC1,APRAC1	;SAVE SOME AC'S AND PICK UP A PDL
	MOVEM AC2,APRAC2
	EXCH P,APRPDL
APRCI2:	SKIPN J,(TAC)		;END OF LIST?
	JRST APRCI9		;YES, RESTORE ACS AND LEAVE
	AOSGE 1(TAC)		;TIME EXPIRED YET?
	JRST APRCI4		;NO, LOOP AROUND
	MOVSI AC2,INTCLK	;MAKE SURE HE IS STILL ENABLED
	TDNN AC2,JBTIEN(J)
	JRST APRCI5		;NOT ENABLED, ALLOWABLE TIMING ERROR, JUST DELETE
	HLRZ AC1,J		;RESET TIME
	MOVNM AC1,1(TAC)
	IORM AC2,JBTIRQ(J)
	TDNE AC2,JBTMSK(J)	;BIT MASKED ON?
	SETOM INTREQ		;YES, REQUEST INTERRUPT CHECK
APRCI4:	ADDI TAC,2		;LOOP AROUND FOR NEXT ENTRY
	JRST APRCI2

APRCI5:	PUSHJ P,APRDEL		;DELETE THE ENTRY, SKIP IF THAT WAS THE LAST ONE
	JRST APRCI2
	JRST APRCI3		;LIST EXHAUSTED

APRCI9:	CAMN TAC,APRLST		;IS LIST EMPTY?
	PUSHJ P,APRDRL
APRCI3:	EXCH P,APRPDL		;RESTORE THE ACS WE SAVED
	MOVE AC1,APRAC1
	MOVE AC2,APRAC2
	MOVE J,APRJ
	JRST APRI2		;(LOSYS)


;APRDEL, APRDRL ROUTINES

;APRDEL DELETE CLOCK INT ENTRY POINTED TO BY TAC
;DELETES FS BLOCK AND SKIP RETURNS IF LAST ENTRY IS DELETED
;CALL ONLY ON P1 AFTER DOING CONO PI,APROFF

↑APRDEL:MOVEI AC1,(TAC)		;START AT CURRENT ENTRY
APRDL1:	ADDI AC1,2		;ADVANCE TOWARD END OF THE LIST.
	SKIPE (AC1)		;AT THE END YET?
	JRST APRDL1		;NO.  KEEP LOOKING.
	MOVE AC2,-2(AC1)	;PICK UP LAST ENTRY.
	MOVEM AC2,(TAC)		;AND STORE IT OVER THEN ENTRY BEING DELETED.
	MOVE AC2,-1(AC1)
	MOVEM AC2,1(TAC)
	SETZM -2(AC1)		;CLEAR THE FORMER LAST ENTRY.
	MOVEI AC1,-2(AC1)	;AC1←ADDRESS OF END OF THE LIST.
	CAME AC1,APRLST		;SAME AS FIRST OF THE LIST?
	POPJ P,			;NO.  THE LIST IS NON-EMPTY
	AOS (P)			;SET SKIP RETURN
APRDRL:	MOVEI AC1,0		;RETURN EMPTY APRLST TO FS.
	EXCH AC1,APRLST
	JRST FSGIVE
;APRI2 APRI2K APRI2L APRI2M APRI2N APRI2O APRI2W APRI2X P1RET APRI2P
;REQUEST CH7 INTERRUPT AND DISMISS.  BOTH PROCESSORS. CLOCK INT ONLY.

LOSYS

APRI2:	CONO PI,4000+1⊗<7-CLKCHN> ;REQUEST INTERRUPT ON CLOCK CHANNEL.
	MOVE TAC,APRIN1		;GET USER'S ENABLINGS
	TRNN TAC,1B26		;IS USER ENABLED FOR OLD-STYLE CLOCK INT?
	JRST APRI2X		;NO. EXIT NOW
	MOVEI TAC,46		;YES. FIND REAL USER PC.  ASSUME CH3
	CONSZ PI,0400		;CH7 IN PROGRESS?
	JRST APRI2K		;YES.  LOOK @156
	CONSZ PI,1000		;CH6 IN PROGRESS?
	JRST APRI2L		;YES.  LOOK @154
	CONSZ PI,2000		;CH5 IN PROGRESS?
	JRST APRI2M		;YES.  LOOK @152
	CONSZ PI,4000		;CH4 IN PROGRESS?
	JRST APRI2N		;YES.  LOOK @150 (IFN FTAPR4 will always exit here)
	JRST APRI2O		;NO. IT WAS CH3 - LOOK @146

APRI2K:	ADDI TAC,2		;CHANNEL 7
APRI2L:	ADDI TAC,2		;CHANNEL 6
APRI2M:	ADDI TAC,2		;CHANNEL 5
APRI2N:	ADDI TAC,2		;CHANNEL 4
APRI2O:
NOKL10,<
IFE FTMAOFF,<
	IORI TAC,MATOFF		;INCLUDE OFFSET OF 0 OR 100
>;IFE FTMAOFF
IFN FTMAOFF,<
	CONSZ APR,MAOFF
	IORI TAC,100
>;IFN FTMAOFF
>;NOKL10
IFKL10,<IORI TAC,KLEPT		;KL10 PI LOCATIONS ARE IN THE EPT
>;IFKL10
	MOVEM AC1,APRAC1	;SAVE AC1 FOR A WHILE.
	MOVE AC1,@(TAC)		;FETCH USER'S PC.
	TLNN AC1,USRMOD		;IN USER MODE?
	JRST APRI2W		;SORRY. CAN'T INTERRUPT UUO CODE FOR THIS.
	EXCH P,APRPDL		;GET A STACK.
	PUSHACS			;SAVE EVERYTHING
	MOVE J,JOB		;SETUP MAP FOR THIS USER.
	PUSHJ P,APRI2P		;HAVE TO PUSHJ FOR MAPSET TO WORK!
	POPACS
	EXCH P,APRPDL
APRI2W:	MOVE AC1,APRAC1
APRI2X:	MOVE TAC,APRTAC		;RESTORE TAC
P1RET:	EXCH PID,APRID

	MTRCOF (CH3,P2NOCK)

IFN FTXADR,<
	XJEN APRCHL		;DISMISS INTERRUPT
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@APRCHL		;DISMISS INTERRUPT
>;IFE FTXADR

APRI2P:	PUSHJ P,MAPSET
	MOVE AC1,@(TAC)			;GET PC AGAIN
	XCTR XW,[MOVEM AC1,JOBTPC]	;STORE INTERRUPT PC IN JOB DATA AREA
	MOVEI AC1,1B26
	XCTR XRW,[IORM AC1,JOBCNI]	;STORE INTERRUPT CONDITION IN JOBCNI
	ANDCAM AC1,APRIN1		;SHUT OFF FUTURE CLOCK TRAPS.
	XCTR XRW,[ANDCAM AC1,JOBENB]	;IN USER'S ENABLES TOO.
	AOS NINTS+=26			;Count this interrupt for bit 26
	XCTR XR,[HLLZ AC1,JOBTPC]	;SET USER PC TO HIS TRAP ADDRESS
	TLZ AC1,BISFLG			;CLEAR THE BIS FLAG FOR INT ROUTINE
	XCTR XR,[HRR AC1,JOBAPR]
	MOVEM AC1,@(TAC)
	POPJ P,				;RETURN THRU MAPSET (RESTORE MAP) TO CALLER
;APRER APRNSC APRNS1 APRER1 APRER6 APRE6A APRE6B APRER2 APRER3 APRERB APRER4 APRERC APRSCR
;APR INTERRUPTS OTHER THAN CLOCK.
;WE ALREADY LOOKED AT CLOCK FLAG.  DO NOT TEST IT OR CLEAR IT!

NOKL10,<	;Whole page
APRER:	EXCH TAC,APRCHL		;SAVE TAC, GET PC WORD
	XORI TAC,PAGINT+1
	TDNN TAC,[USRMOD,,-1]
	JRST APRSCR		;GOT SCREWED BY PDLOV/MEM PROT?
APRNSC:	XORI TAC,PAGINT+1

APRNS1:
IFN FTF2,<
	SKIPE F2ILM		;SKIP UNLESS SIMULATED MPV FOR PAGE FAULT
	JRST APRMPV		;CLEAN UP AFTER CPU ON MPV
>;IFN FTF2
IFE FTF2,<
	CONSZ APR,ILM
	JRST APRMPV		;CLEAN UP AFTER CPU ON MPV
>;IFE FTF2
	TLNN TAC,USRMOD		;IS IT IN USER MODE?
	JRST APRER2		;EXEC MODE.
APRER1:	CONSZ PI,1B27*(1⊗(7-APRCHN)-1)	;USER MODE.  NO CHECK PIS
	JRST APRER2		;USER IN PROGRESS IN PI 4,5,6,7?
	SKIPN SPWUUF		;SPACEWAR?
	JRST APRER6		;NO.
	EXCH TAC,APRCHL		;ERROR FROM SPACEWAR.
	EXCH PID,APRID
	JRST SPWINT

;Error came from user mode; maybe should give user interrupt.
APRER6:	SKIPE INTACT		;KILL IF ALREADY AT USER INT. LEVEL.
	JRST APRER2		;RECURSIVE INT, STOP JOB
IFN FTF2,<
	SKIPN F2ILM		;If have ILM, it isn't in CONI APR,
	JRST APRE6B		;No ILM (no page fault, that is)
	MOVEM TAC,APRTAC	;Get an AC, save PC
	MOVEI TAC,@APRIN1	;Special check (can't use CONSZ) to see if
	TRNN TAC,ILM		;  user is enabled for this ILM
	JRST APRE6A		;Not enabled, look for other enablings
	MOVE TAC,APRTAC		;Restore PC
	JRST APRERU		;Enabled, give user interrupt

APRE6A:	MOVE TAC,APRTAC		;Restore PC
APRE6B:
>;IFN FTF2
	CONSZ APR,@APRIN1	;IS USER ENABLED FOR THIS INTERRUPT?
	JRST APRERU		;Yes, give interrupt
;APR INT FROM EXEC MODE OR, USER NOT ENABLED FOR INT -- STOP JOB.
APRER2:
IFN FTF2,<
	SKIPN F2ILM		;ILM (page fault) on F2?
>;IFN FTF2
	CONSZ APR,630000	;DOES EXEC CARE? CONS,PDLOV,NXM,MPV
	JRST APRERB		;YES!
	CONSO APR,110		;AROV OR FOV (PC CHNG ON P2 WAS CLEARED)
	JRST APRER3		;NO.
	MOVEM TAC,APRTAC
	MOVE TAC,APRIN1
	TRNN TAC,10		;USER ENABLED FOR AROV?
	CONO APR,40!APRCHN
	TRNN TAC,100		;OR FOV (PC CHANGE ON 6)
	CONO APR,400!APRCHN
	MOVE TAC,APRTAC
APRER3:	TLZ TAC,440000		;CLEAR FOV AND AROV PC FLAGS SO INT MAY
	EXCH TAC,APRCHL		;  BE DISMISSED. RESTORE TAC & APRCHL
IFN FTF2,<
	SETZM F2ILM		;Clear software ILM flag for F2, no hardware flag
>;IFN FTF2
	CONO APR,530110+APRCHN	;CLEAR PDLOV,CONS,MPV,NXM,FOV,AROV
	JRST P1RET

;NON-TRIVIAL ERROR DETECTED.  MAY BE FROM EXEC.

APRERB:	MOVEM TAC,APRPC		;STORE ERROR PC FOR CLK CHANNEL
	CONI APR,APRERR		;STORE ERROR FLAGS - SEE CH7 CODE
IFN FTF2,<
	MOVEI TAC,ILM		;Simulate ILM flag being on if page fault on F2
	SKIPE F2ILM
	IORM TAC,APRERR		;Make it look like bit came from hardware
	MOVE TAC,APRPC		;Still need PC in TAC
>;IFN FTF2
	HLLOS CLKFLG		;SET FLAG FOR CLK INTERRUPT
	SETOM SCHEDF		;FLAG THAT RESCHEDULING IS NEEDED
				;(EVEN THOUGH PC MAY BE IN EXEC MODE)
	CONO PI,1B24+1⊗(7-CLKCHN) ;REQUEST INTERRUPT ON CLOCK CHANNEL.
IFN FTF2,<
	SKIPN F2ILM		;ILL MEM REF?
	JRST APRERC		;NO.
>;IFN FTF2
IFE FTF2,<
	CONSO APR,ILM		;ILL MEM REF?
	JRST APRERC		;NO.
>;IFE FTF2
	MOVEM TAC,USAVPC	;SAVE ERROR PC FOR CLKINT
	HRRI TAC,0		;YES. SET ADDRESS SO PDP-10 DOESN'T HANG
APRER4:
IFE FTF2,<
	CONSO APR,NXM		;NON-EXISTANT MEMORY?
	JRST APRER3		;NO. RESTORE ACS AND DISMISS
REPEAT 0,<
	MOVEI TAC,(TAC)		;YES. IS IT PC?
	CAML TAC,RMEMSIZ	
	MOVEI TAC,[CONO PI,1B24!1⊗(7-CLKCHN)] ;YES. DISMISS TO CLKINT
>;REPEAT 0
	HLL TAC,APRPC
>;IFE FTF2
	JRST APRER3		;RESTORE ACS AND DISMISS

APRERC:	TLNN TAC,USRMOD		;ERROR FROM USER?
	CONSO PI,177B27≠(1B27⊗(7-APRCHN)) ;NO. PI IN PROGRESS?
	JRST APRER4		;USER MODE OR UUO LEVEL.
	EXCH P,APRPDL		;SYSTEM ERROR!
	PUSHACS
	PUSH P,TAC
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CH3 ERROR IN EXEC.  PC = /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /
APR CONI = /
	MOVE TAC,APRERR
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	PUSHJ P,SYSFIX
	JFCL			;NOT IN MONITOR
	JFCL			;ERROR, BUT COULDN'T FIX
	PUSHJ P,DISFLU		;SEND MESSAGES TO CTY.
	POPACS
	PUSHJ P,WDDTCALL	;MAY REQUIRE INTERVENTION.
	EXCH P,APRPDL
	JRST APRER4

;GET HERE IF ADDRESS IN CH3 IS EXEC PAGINT+1
APRSCR:	CONSZ APR,200000	;SKIP IF PDLOV
	CONSZ PI,1B27*(1⊗(7-APRCHN)-1)	;Skip if not in progress on APRCHN thru 7
	JRST APRNSC		;NOT PDLOV OR PDLOV FROM PI CH 4-7
	EXCH TAC,PAGINT		;GET PC OF PUSH/PUSHJ THAT SCREWED UP
	TLNE TAC,USRMOD
	JRST APRNS1		;MAKE IT LOOK LIKE USER MODE PDLOV
	EXCH TAC,PAGINT		;WAS FROM EXEC MODE - UUO LEVEL
	JRST APRNSC
>;NOKL10
;APRERU APREU1 APREU2 APREU3 APREU4 APRERV APREV2 APRFL2 APRFLT APRMPV
;GIVE USER AN APR INTERRUPT.  APRFLT, APRMPV  P1 ONLY.

;ENTER AT APRERU WHEN INTERRUPT PC IS IN USER MODE, NOT DOING EITHER
;SPACEWAR OR (NEW) USER INTERRUPTS.  WE ARE ASSURED THAT THIS
;INTERRUPT WAS REALLY GENERATED BY THIS USER.  BY VIRTUE OF THE PC
;BEING IN USER MODE, AND NOT RUNNING USERS WITHOUT THE MAP BEING
;SETUP, WE KNOW THE CURRENT MAP IS THE CORRECT ONE.

;OLD STYLE CLOCK INTERRUPTS ARE HANDLED AT APRI2, SINCE CLOCK MAY TICK
;WHILE PI IN PROGRESS IN SOME INTERMEDIATE CHANNELS.  OLD-STYLE CLOCK
;INTS HAVE BEEN CHANGED TO DISABLE SUBSEQUENT INTS AFTER ONE IS GIVEN.
;NOTE THAT THERE ARE STILL PROBLEMS WITH ENABLING FOR CLOCK INTS AND
;ANYTHING ELSE, SINCE, SAY, PDLOV CAN HAPPEN, AND APRERU ENTERED AND THEN
;THE CLOCK FLAG COMES ON.  USER WILL GET THE TRAP FOR PDLOV AND THEN
;THE TRAP FOR CLOCK WILL CLOBBER JOBTPC.  SIGH.

NOKL10,<	;Whole page

;TAC HAS INTERRUPT (USER) PC

APRERU:

IFN FTF2,<
	SKIPN F2ILM		;Sigh, must check software simulation of F2 ILM
	JRST APREU3		;No ILM to think about
	MOVEM TAC,APRTAC	;Save PC for a moment
	MOVEI TAC,@APRIN2	;Get user new-style enablings
	TRNN TAC,ILM		;Enabled for this ILM?
	JRST APREU2		;No, maybe enabled for some other current error
	MOVE TAC,APRTAC		;Yes, restore PC
	JRST APREU4		;Pretend CONSO skips

APREU2:	MOVE TAC,APRTAC		;Restore PC
APREU3:
>;IFN FTF2
	CONSO APR,@APRIN2	;ENABLED VIA NEW USER INTERRUPT SYSTEM?
	JRST APRERV		;NO. OLD STYLE.
APREU4:	MOVEM TAC,APRIN3	;SAVE PC FOR CLKINT
	EXCH J,JOB
	CONI APR,TAC		;GET APR BITS
IFN FTF2,<
	SKIPE F2ILM		;This flag is not held by hardware any more
	IORI TAC,ILM		;But make it look like it is, since it's on
>;IFN FTF2
	AND TAC,APRIN2		;SELECT ONLY THE ONES THE USER WANTS
	ANDI TAC,CPUMSK		;ONLY REAL APR BITS!
	IORM TAC,JBTIRQ(J)	;INCLUDE APR BITS IN THE INT REQUESTS
	TDNE TAC,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, NOW REQUEST AN INTERRUPT
	EXCH J,JOB
	MOVE TAC,[JRST JOBTM5]
	XCTR XW,[MOVEM TAC,JOBTM5] ;MAKE USER LOOP UNTIL CH7 GETS HIM.
	MOVE TAC,[USRMOD,,JOBTM5] ;SETUP NEW PC TO DISMISS TO.
	HLLOS CLKFLG		;FLAG CHANNEL 7 - WE NEED USER INT.
	CONO PI,1B24+1⊗(7-CLKCHN) ;REQUEST INTERRUPT ON CH7
	JRST APRER3		;GO DISMISS INT.

;ENABLED VIA OLD-STYLE INTERRUPTS.
APRERV:	XCTR XW,[MOVEM TAC,JOBTPC] ;STORE INTERRUPT PC IN JOB DATA AREA
	CONI APR,TAC		;GET APR BITS
IFN FTF2,<
	SKIPE F2ILM		;This flag is not held by hardware any more
	IORI TAC,ILM		;But make it look like it is, since it's on
>;IFN FTF2
	XCTR XW,[MOVEM TAC,JOBCNI] ;STORE INTERRUPT CONDITIONS FOR USER.
	MOVEM TAC1,APRTC1	;SAVE ANOTHER AC
	TRZ TAC,6043		;TURN OFF SOME NON-INTERRUPT BITS
	JFFO TAC,.+2		;Find interrupt's bit number 
	AOSA NINTS1		;Count a time with no bit!
	AOS NINTS(TAC1)		;Count an interrupt for first int bit found
	MOVE TAC1,APRTC1	;Restore AC
	MOVEI TAC,1B26		;FOR SANITY, PREVENT A CLOCK INT NOW.
	ANDCAM TAC,APRIN1	;IN THE APR ENABLE
	XCTR XRW,[ANDCAM TAC,JOBENB] ;AND IN USER'S ENABLE.
	XCTR XR,[HRRZ TAC,JOBAPR] ;GET TRAP ROUTINE ADDRESS
	CAIGE TAC,JOBPFI	;LEGAL TRAP ADDRESS? (NO TRAPS TO ACS)
	JRST APREV2		;NO.
	MOVEM TAC,APRTAC	;SAVE TRAP ADDRESS.
	XCTR XR,[HRRZ TAC,JOBTPC] ;GET INTERRUPT PC.
	CAMN TAC,APRTAC
	JRST APREV2		;INTERRUPT PC=TRAP PC.  LOSE.
	ADDI TAC,1
	CAMN TAC,APRTAC
	JRST APREV2		;INTERRUPT PC=TRAP PC+1.  LOSE.
	XCTR XR,[HLLZ TAC,JOBTPC] ;NOW PUT THE ENTIRE PC TOGETHER AGAIN
	TLO TAC,USRMOD		;MPV MAY BE FROM EXEC. RUN THIS IN USER MODE
	TLZ TAC,BISFLG		;CLEAR THE BIS FLAG FOR INT ROUTINE
	XCTR XR,[HRR TAC,JOBAPR]
	JRST APRER3

;LOSER HAS INVALID TRAP ADDRESS.  CLEAR APRIN1 TO PREVENT FURTHER LOSSAGE.
APREV2:	XCTR XR,[MOVE TAC,JOBTPC] ;RESTORE PC AND FLAGS
	SETZM APRIN1
	XCTR XW,[SETZM JOBENB]	;CLEAR HIS ENABLES.
	JRST APRER2		;PRETEND HE WAS NOT ENABLED FOR INT.


;Page fault on write, adjust PC to actual instruction that faulted.
APRFL2:
IFN FTF2,<
	PRINTX	Compensate for F2 setting both Read and Write failure on RMW
	TLNE TAC,10		;Read access?
	  JRST APRFL1		;  Sigh.  Kludge around F2 lossage.
>;IFN FTF2
	MOVE TAC,PAGINT
	TLNN TAC,BISFLG		;SKIP IF BIS flag set (i.e., if was IDPB)
	HRRI TAC,-1(TAC)	;IT WAS A WRITE, SO SOS THE PC (no BIS flag)
	JRST APRMPV

;Here to handle page fault.
APRFLT:	MOVEM TAC,APRCHL	;SAVE TAC AWAY
	MOVE TAC,PSB+TSW	;GET TRAP STATUS WORD
	TLNE TAC,4		;SKIP IF WASN'T A WRITE REQUEST
	JRST APRFL2		;IT WAS A WRITE REQUEST
APRFL1:	MOVE TAC,PAGINT		;SET UP TAC TO PC OF LOSSAGE
APRMPV:	CONO APR,400000!APRCHN	;DON'T MENTION PDLOV YET IF BOMBED ON MPV
	TLNE TAC,USRMOD		;MAY HAVE TO WORRY IF EXEC LOST
	JRST APRER1		;NO. USER MODE.
	CONSZ PI,1B27*(177-1⊗(7-APRCHN))	;PI IN PROGRESS? (EXCEPT APRCHN)
	JRST APRER6		;YES. MPV FROM EXEC PI IN PROGRESS.
	HRRI TAC,UADERR		;SEND HIM TO ADDRESS CHECK
	JRST APRER3

>;NOKL10
;

SUBTTL CLOCK 24 JULY 67

;THIS ROUTINE RUNS ON THE LOWEST PRIORITY PI CHANNEL AND AT UUO LEVEL
;TO CAUSE AN INTERRUPT ON CLK CHANNEL:
;	SETOM CLKFLG	;FLAG THAT INTERRUPT HAS BEEN REQUESTED
;	CONO PI,CLKREQ	;REQUEST PI INTERUPT ON LOWEST PI CHANNEL
;THE FOLLOWING OTHER FLAGS MUST ALSO BE SET
;APRERR-APR DETECTED ERROR IN CURRENT JOB
;SCHEDF-RESCHEDULING MUST TAKE PLACE(EVEN THOUGH PC IN EXEC MODE)
;TIMEF-APR CLOCK HAS TICKED ON HIGH PRIORITY CHANNEL
;SEE APRSER AND RUNCSS TO SEE HOW THIS ROUTINE IS CALLED

;CLK SERVICE PERFORMS THE FOLLOWING ON A REGULAR BASIS:
;PROCESSES CLOCK QUEUE REQUESTS
;CALLS CONSOLE MONITOR COMMAND DECODER
;CALLS CORE SHUFFLER
;THEN CALLS SCHEDULER
;IF THE CURRENT JOB IS IN EXEC MODE THE ABOVE 4 TASKS ARE
;DELAYED UNTIL THE CURRENT JOB ENTERS A STOPPABLE STATE: I.E., UNTIL
;	1. JOB STARTS TO WAIT FOR A BUSY SHARABLE DEVICE
;	2. JOB STARTS TO WAIT FOR IO TO COMPLETE
;	3. CONTROL ABOUT TO RETURN TO USER MODE
;THEN CLK SERVICE IS ENTERED AT THE UUO LEVEL

;⊗ KCLKIN CLKIN0 CLKINT INTXTS NOTCH7 MTDINE

;HERE AT CLK INTERRUPT LEVEL  -  CLKINT

IFKL10,<
↑KCLKIN:EXCH 17,KLTPC		;Here from CH7 chain in CACDAT when KLTPCF has
	MOVEM 17,CLKCHL		; been set by KLEINT.
	EXCH 17,KLTPC
IFN FTXADR,<
	EXCH 17,KLTPC+1
	MOVEM 17,CLKCHL+1
	EXCH 17,KLTPC+1
>;IFN FTXADR
	JRST CLKINT
>;IFKL10

↑CLKIN0:EXCH 17,UUO0		;GET HERE WHEN CLKFLG IS NEGATIVE
IFN FTXADR,<
	MOVEM 17,CLKCHL+1	;SIMULATE INT FROM USER
>;IFN FTXADR
IFE FTXADR,<
	MOVEM 17,CLKCHL		;SIMULATE INT FROM USER
>;IFE FTXADR
	EXCH 17,UUO0
↑CLKINT:SETZM CLKFLG
	MOVEM 17,CLKS17		;SAVE AC 17
IFKL10,<
	JSP 17,.+1
	TLO 17,PCU		;SET PCU SO XCTRS WILL WORK
	HRRI 17,.+2
	JRST 2,@17
>;IFKL10
	SKIPE SPWUUF		;SPACEWAR IN PROGRESS?
	JRST SPCLK1		;YES, RUN SPACEWAR CLOCK P1

IFN FTHG,<
	MOVEI 17,7
	MOVEM 17,HGCODE
>;FTHG

	MOVEI 17,P1PID
	SKIPLE INTDISP(17)	;IS SOMEONE SNEAKING INTO CH7 FOR USER-INT SERVICE?
	JRST @INTDISP(17)	;SERVICE HIM (INTCH7, INTDSM, INTDEB, OR INTHL1)

IFN FTHG,<	SETZM HGCODE	>

	SKIPN 17,USAVPC
	MOVE 17,CLKCHL		;IS CURRENT JOB IN USER MODE?
	TLNN 17,USRMOD
	SKIPE SCHEDF		;EXEC MODE - IS THIS A FORCED RESCHEDULING?
	JRST CLKIN1		;USER MODE OR FORCED RESCHEDULING.
INTXTS:	MOVE 17,[CONO PI,PIOFF]
	MOVEM 17,UUOXIT		;DIVERT TO CLKIN0 ON WAY BACK TO USER
	MOVE 17,CLKS17		;LEAVE TIMEF SET AND DISMISS INT.

	MTRCOF (CH7,P2NOCK)

IFN FTXADR,<
	XJEN CLKCHL
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CLKCHL
>;IFE FTXADR

;Bugtrap code, here if hit CH7 consz chain but not in ch 7.
↑NOTCH7:SYSPIFF			;turn off PIs to stop everything
	EXCH P,ERRPDL		;get a stack
	PUSHACS			;save ACs
	CONI PI,DDB		;read PI state for printing
	PUSHJ P,DISGST		;print time for new message on CTY
	PUSHJ P,DISERR		;tell someone
	 [ASCIZ/In CH7 CONSZ chain but not in Ch 7.  PI CONI = /]
	 DISARG OCH,DDB		;print PI CONI
	 [ASCIZ/
CH7 = /]
	 DISARG OCH,CH7		;print ch7 return address
	 [ASCIZ/  CH6 = /]
	 DISARG OCH,CH6		;print ch6 return address
	 [ASCIZ/  CH5 = /]
	 DISARG OCH,CH5		;print ch5 return address
	 [ASCIZ/  CH4 = /]
	 DISARG OCH,CH4		;print ch4 return address
	 [ASCIZ/
CH3 = /]
	 DISARG OCH,CH3		;print ch3 return address
	 [ASCIZ/  CH2 = /]
	 DISARG OCH,CH2		;print ch2 return address
	 [ASCIZ/  CH1 = /]
	 DISARG OCH,CH1		;print ch1 return address
	 [ASCIZ/  MTDINT = /]
	 DISARG OCH,MTDINT	;print DC 136 interrupt return address
	 [ASCIZ/  MTIDSP = /]
	 DISARG OCH,MTIDSP	;print MT coroutine address
	 [ASCIZ/  You need a wizard.
/]
	 -1
	PUSHJ P,DISFLU
	POPACS			;restore ACs
	PUSHJ P,WDDTCAL		;stop
	EXCH P,ERRPDL		;restore AC
	SYSPIN			;restore PIs
	CONSZ PI,77400		;hopefully, we're not in any PI channel
	JRST 4,.		;but we are!  (and it's not ch7)
	SKIPN J,JOB             ;skip unless null job running
	JRST NULJB              ;attempt to fix the world, restart null job
	SKIPN P,JBTPDL(J)       ;get a stack for this job
	HALT .                  ;none!
	JRST UUOERR             ;and give this job an error
IFN FTXADR,<
;;	XJEN CLKCHL
>;IFN FTXADR
IFE FTXADR,<
;;	JRST 12,@CLKCHL
>;IFE FTXADR

;Bugtrap, here from MTDINT if someone interrupted in DC's channel, but it wasn't DC.
↑MTDINE:SYSPIFF			;turn off PIs to stop everything
	EXCH P,ERRPDL		;get a stack
	PUSHACS			;save ACs
	CONI PI,DDB		;read PI state for printing
	CONI DC,DSER		;read DC state for printing
	PUSHJ P,DISGST		;print time for new message on CTY
	PUSHJ P,DISERR		;tell someone
	 [ASCIZ/Ch 1 interrupt other than DC 136, or not expecting DC.  PI CONI = /]
	 DISARG OCH,DDB		;print PI CONI
	 [ASCIZ/
DCWRD = /]			;current BLKI/O ptr
	 DISARG OCH,DCWRD
	 [ASCIZ/  DC CONI = /]
	 DISARG OCH,DSER
	 -1
	PUSHJ P,DISCRL
	JSR DCHECK		;check all the devices
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCAL		;stop for inspection
	SKIPL DCWRD		;skip if plausible for DC to be interrupting
	CONO DC,0		;turn off DC, if that's the problem
	EXCH P,ERRPDL		;restore AC
	SYSPIN			;restore PIs
	JRST 12,@MTDINT		;dismiss, hope strange device has quit interrupting
;CLKIN1 CLKERR CLKER1 FOO01 CIP2 MIDCHK MIDCHL PDTCHK PDTST1 PDTST2 PDTSTD
;CLKERR - NOW OFFICIALLY IN CHANNEL 7.   CLKIN1, MIDCHK, PDTCHK

CLKIN1:	MOVEM 17,USRPC		;P1 - NOW OFFICIALLY IN CHANNEL 7
	MOVEI 17,P1PID
CLKERR:	JSR @CLKSV(17)		;SAVE ACS
	SETZM USAVPC		;(BOTH PROCESSORS HERE)
	HRLI P,-CLKPLN
	HRRI P,CLKPDL-1
	MOVE TAC,UUOXI
	MOVEM TAC,UUOXIT	;RESTORE EXIT, NOW THAT WE MADE IT
	SKIPE TAC,APRERR	;IS THIS AN ERROR INTERRUPT?
	PUSHJ P,APRILM		;YES, GO PROCESS ERROR 
	HGMAC (7)
	SKIPE INTREQ		;ANY INTERRUPTS PENDING?
	PUSHJ P,INTRUN
	HGMAC (0)
CLKER1:	SKIPN TIMEFF		;CLOCK FLAG?
	JRST CIP11A		;NO, JUST RESCHEDULE
	SETZM TIMEFF		;CLEAR CLOCK FLAG
	SETOM TIMEF		;SET TIME FLAG.  CLOCK HAS TICKED.
;Now update load avg
	SETZ AC1,		;CLEAR COUNTER
	MOVNI TAC,RUNQ		;GET RUNQ OFFSET
	HRRE TAC,JBTQ(TAC)	;TRACE LINK
	SKIPLE TAC		;BACK TO HEADER?
	AOJA AC1,.-2		;GO GET SOME MORE
	MOVNI TAC,TQ		;THE HPQ
	HRRE TAC,JBTQ(TAC)	;TRACE
	SKIPLE TAC		;MORE?
	AOJA AC1,.-2		;WORK IS NEVER DONE
	MOVE AC2,LDAVG		;GET OLD LDAVG
	LSH AC2,-LDPWR		;GET ONE TICK'S WORTH TO SUBTRACT OUT
	LSH AC1,LDSHF		;NORMALIZE NEW TICK'S WORTH
	SUB AC1,AC2		;NEW TICK MINUS AVG OLD TICK
	ADDM AC1,LDAVG		;DIDDLE AVG BY PROPER AMOUNT
;Now update the disk queue avg
	MOVE AC2,DQAVG		;GET OLD DQAVG
	LSH AC2,-LDPWR		;GET ONE TICK'S WORTH TO SUBTRACT OUT
	MOVE AC1,DQCNT		;Get current disk queue size
	ADDM AC1,DQTOT		;Include for long-term average
	AOS NDQTOT		;Count samples in long-term total
	LSH AC1,LDSHF		;NORMALIZE NEW TICK'S WORTH
	SUB AC1,AC2		;NEW TICK MINUS AVG OLD TICK
	ADDM AC1,DQAVG		;DIDDLE AVG BY PROPER AMOUNT
;Now update the DCA interrupt avg
	MOVE AC2,DCAAVG		;GET OLD DCAAVG (DCA interrupt/tick avg)
	LSH AC2,-LDPWR		;GET ONE TICK'S WORTH TO SUBTRACT OUT
	MOVE AC1,NDCAIN		;Get current total ints
	SUB AC1,CDCAIN		;Subtrack previous total to get recent number
	ADDM AC1,CDCAIN		;Update saved current total ints
	LSH AC1,LDSHF		;NORMALIZE NEW TICK'S WORTH
	SUB AC1,AC2		;NEW TICK MINUS AVG OLD TICK
	ADDM AC1,DCAAVG		;DIDDLE AVG BY PROPER AMOUNT

	MOVEI AC1,TIME
	MOVEI AC2,THSDAT
	PUSHJ P,MIDCHK		;CHECK FOR MIDNIGHT (LOCAL TIME)
	MOVEI AC1,PSTIME
	MOVEI AC2,PSDATE
	PUSHJ P,MIDCHK		;CHECK FOR MIDNIGHT (PST)
IFN FTP2,<
	MOVE AC1,TIME
	MOVEM AC1,P2TIME	;TELL P2 WHAT TIME IT IS
	MOVE AC1,THSDAT
	MOVEM AC1,P2DATE	;TELL P2 WHAT DAY IT IS
>;IFN FTP2
CIP2:	SOSGE CHKYET		;COUNTDOWN TO NEXT CHECKSUM TIME.
	PUSHJ P,CHKNOW		;GO CHECK THE CHECKSUM
	HGMAC(0)
	JRST CIP2A		;(HISYS)

;CALL WITH POINTER TO TIME IN TICS IN AC1 AND DATE IN SYSTEM DATE FORMAT IN AC2
;IT FIXES THE TIME IF IT IS AFTER MIDNIGHT AND BUMPS THE DATE BY ONE.
↑MIDCHK:MOVE TAC,MIDNIT		;TAC←NUMBER OF TICKS/DAY
	CAMLE TAC,(AC1)		;IS TIME OF DAY PAST MIDNIGHT?
	POPJ P,			;NO.
IFN FT11CLK,<
	CAIN AC2,THSDAT		;changing real system date?
	SKIPL BIGTIM		;yes, skip if suppressing bad-time msg
	CAIA			;no, don't re-type msg yet
	SETZM BIGTIM		;repeat "console-11 clock bad" msg daily
>;IFN FT11CLK
	MOVN TAC,TAC
	ADDM TAC,(AC1)		;DECREMENT TIME BY NUMBER OF TICKS/DAY
MIDCHL:	MOVEI IOS,0		;IOS←0 (FOR DIVI BELOW)
	AOS TAC,(AC2)		;INCREMENT DAY
	IDIVI TAC,=31		;TAC1←DAY OF MONTH -1
IFN TAC-IOS-1,<.FATAL ACs IOS and TAC are not contiguous as required here.>
	DIVI IOS,=12		;IOS←YEAR-1964, TAC←MONTH-1 (0=JAN)
	LDB TAC,PMONTB		;TAC←(NUMBER OF DAYS IN MONTH)-1
	CAIL TAC,(TAC1)		;SKIP IF PAST THE END OF THE MONTH.
	POPJ P,			;(STILL INSIDE OF THIS MONTH)
	CAIN TAC,=27		;SKIP IF THIS IS NOT FEB.
	TRNE IOS,3		;FEB. SKIP IF LEAP YEAR
	JRST MIDCHL		;ADVANCE DATE TO FIRST OF NEXT MONTH
	CAIE TAC1,=28		;ALLOW FEB 29 TO EXIST
	JRST MIDCHL		;ADVANCE TO MARCH 1.
	POPJ P,

↑PDTCHK:MOVE TAC,OCTSUN
	MOVE TAC1,APRSUN
	MOVE DDB,PSTIME
	CAMG TAC1,PSDATE	;SKIP IF BEFORE APRIL'S first SUNDAY
	CAMGE TAC,PSDATE	;IT'S NOT BEFORE, IS IT BEFORE OCT'S last Sunday?
	JRST PDTSTD		;BEFORE APRIL'S OR AFTER OCT'S
	CAME TAC1,PSDATE
	JRST PDTST1		;STRICTLY AFTER APRSUN
	CAMGE DDB,[2*=60*=60*JIFSEC] ;SKIP IF NOT BEFORE 2AM PST APRSUN
	JRST PDTSTD
	JRST PDTST2		;SET PDT

PDTST1:	CAME TAC,PSDATE
	JRST PDTST2		;STRICTLY BETWEEN FENCEPOSTS
	CAML DDB,[1*=60*=60*JIFSEC] ;SKIP IF BEFORE 1AM
	JRST PDTSTD
PDTST2:	SKIPE DAYLIT
	POPJ P,			;DAYLIT ALREADY SET
	SETOM DAYLIT
	MOVE TAC,[=60*=60*JIFSEC]
	ADDM TAC,TIME
	MOVEI AC1,TIME
	MOVEI AC2,THSDAT
	JRST MIDCHK

PDTSTD:	SKIPN DAYLIT
	POPJ P,			;DAYLIT ALREADY CLEAR
	SETZM DAYLIT		;SWITCH FROM PDT TO PST
	MOVE TAC,PSTIME
	MOVEM TAC,TIME
	MOVE TAC,PSDATE
	MOVEM TAC,THSDAT
	POPJ P,
;P1 CLOCK LEVEL ;⊗ CIP2A CIP2B CIP2DA CIP2SP CIP2D DATEOK FUNTIM TIMEOK CRKT1 CRKT1A CRKT2 HNGP2D TDSET

;THIS PAGE IS P1 ONLY

HISYS

CIP2A:
IFN FTDCHK,<
	SKIPL CHKDCA		;DOES WIZARD WANT A DCA STATUS REPORT?
	PUSHJ P,DCACHK		;YES, DO IT
>;IFN FTDCHK
	SOSLE T15CNT		;TIME TO CHECK FOR AUDIO SWITCH?
	JRST CIP2B		;NO.
	MOVEI TAC1,JIFSEC/4	;REPEAT THIS 4 TIMES PER SECOND.
	MOVEM TAC1,T15CNT
IFN FTSUAI,<
	CONO CAR,ONGRN		;Keep the green light on, system is running
>;IFN FTSUAI
IFN FTAS,<
	PUSHJ P,ASSCN		;SEE IF ANY AUDIO SWITCH WORK TO BE DONE(TTYSER)
>;IFN FTAS
IFN FTADRB,<
	SKIPL ADRBRA		;Want to enable new addr break?
	PUSHJ P,ADRBCK		;Yes, do it
	SKIPE ADRBRC		;Want to read addr break enablings?
	DATAI APR,ADRBRO	;Yes, read them to standard place
	SETZM ADRBRC
>;IFN FTADRB
IFE FTF2,<
	DATAI HOT,TAC		;GET A THERMOMETER READING
	LDB AC2,[POINT 1,TAC,23] ;GET INSIDE/OUTSIDE BIT
	MOVEI AC1,0
	IDIVI TAC,20
	ADDI AC1,(TAC1)
	IDIVI TAC,20
	IMULI TAC1,=10
	ADDI AC1,(TAC1)
	TRNE TAC,2
	ADDI AC1,=100
	TRNE TAC,1
	MOVN AC1,AC1
	MOVEM AC1,ITHERM(AC2)	;STORE IT
>;IFE FTF2
IFKL10,<
	SKIPE TAC,BADADR
	PUSHJ P,WRBADP		;WRITE BAD PARITY DATA WHERE REQUESTED
	SETZM BADADR
>;IFKL10
IFN FTP2,<
	AOSN HNGP2F		;HAS P2 JUST DIED?
	PUSHJ P,HNGP2D		;YES, HUNG TIMEOUT ITS DEVICES
>;IFN FTP2
CIP2B:	SOSLE HNGTIM		;TIME TO RUN THE 1 SECOND CLOCK?
	JRST CIP2D		;NO
	MOVEI TAC,JIFSEC	;RESET COUNT TO CHECK EVERY SECOND.
	MOVEM TAC,HNGTIM
IFN FTIP,<
	HGMAC(26)
	PUSHJ P,IMPSEC↑		;Do IMP once-a-second stuff
>;IFN FTIP
IFN FTDOM,<
	HGMAC(45)
	PUSHJ P,DOMCLK		;Time out domain records
>;IFN FTDOM
	HGMAC(24)
	PUSHJ P,DEVCHK		;GO CHECK FOR HUNG IO DEVICES
IFKL10,<
	PUSHJ P,QMPCLK		;check for stuck 10/11 transfers, etc.
IFN FTNDTE,<
	PUSHJ P,DTECLK		;Check for hung 11 cmds
>;IFN FTNDTE
>;IFKL10
IFE FTDLS,<
	HGMAC(25)
	PUSHJ P,KBDCHK		;See if Microswitch kbds need re-enabling
IFE FTF2,<
	PUSHJ P,KBDCHK		;Do two kbds/second, each kbd once/32 secs
>;IFE FTF2
>;IFE FTDLS
	HGMAC(0)
	PUSHJ P,TDSET		;Update TIMDAT and PSTDAT

IFN FTDDSTAT,<
	SOSLE NDSTAT		;TIME FOR DD STATISTICS?
	JRST CIP2DA		;NO.
	MOVEI TAC,5		;HERE EVERY 5 SECONDS
	MOVEM TAC,NDSTAT
	MOVE TAC,NDDXCT		;GET NEW COUNT
	EXCH TAC,NDDXOL		;STORE AS OLD COUNT
	SUB TAC,NDDXOL		;OLD COUNT - NEW COUNT. RESULT NEGATIVE
	MOVN TAC,TAC
	CAMLE TAC,NDDXMX	;BIGGER THAN OLD MAX?
	MOVEM TAC,NDDXMX	;YES. STORE NEW MAX.
	MOVE TAC,NDDLCT		;GET NEW COUNT
	EXCH TAC,NDDLOL		;STORE AS OLD COUNT
	SUB TAC,NDDLOL		;OLD-NEW. RESULT IS POSITIVE.
	CAMLE TAC,NDDLMX	;BIGGER THAN OLD MAXIMUM?
	MOVEM TAC,NDDLMX	;YES. STORE NEW MAX.
CIP2DA:
>;END FTDDSTAT

	SOSLE PDTCNT		;Time to run once-a-minute code?
	JRST CIP2D		;No
IFN PUPNUM,<
	MOVNI TAC,NPPMSS	;SET NUMBER OF PUP MESSAGES/MINUTE ALLOWED
	MOVEM TAC,PPERCN
>;IFN PUPNUM
	MOVEI TAC,=60
	MOVEM TAC,PDTCNT	;CHECK EVERY MINUTE
	MOVEI TAC,NDBCNT
	MOVEM TAC,DEBCNT	;Reset debug-mode error count down
	PUSHJ P,PDTCHK		;CHECK ON CHANGING TO PST/PDT
IFG DILNUM,<
IFE FTVDIL,<
	PUSHJ P,DILIN		;Re-init max interrupt count once per minute
>;IFE FTVDIL
>;IFG DILNUM
REPEAT <SCNNUM+=11>/=12,<
	PUSHJ P,CKFONE		;Maybe hang up some phone line not in use
>;REPEAT.  Here once a minute, so this makes each TTY checked once per 12 mins.
IFN FTIRMA,<
	MOVEI TEM,IRMANO
	MOVEM TEM,IRMCNT	;INITIALIZE IRMA COUNT
	MOVE TEM,[IRMCNT,,IRMCNT+1]
	BLT TEM,IRMCNT+TTPLEN-1	;  FOR ALL TTYS
>;IFN FTIRMA
IFN FTP2,<
	SKIPN DETFLG		;P2 GOING?
	JRST CIP2D		;NO, DON'T BOTHER CHECKING
	MOVEI TAC,P2CKTB	;YES, GET TABLE OF LOCATIONS TO CHECK

DEFINE P2C(AD)<
	MOVE TEM,(TAC)
	CAIE TEM,AD-P2VORG
	JRST CIP2SP		;JUMP IF A CHECK LOC DOESN'T AGREE
	ADDI TAC,1		;POINT TO NEXT CHECK LOC
>;P2C

	P2CHKS			;CHECK EACH LOC IN TABLE
	SETZM DIDLOD		;IT'S OK, ALLOWED TO TRY TO RELOAD IF IT GOES BAD
	JRST CIP2D		;MADE IT, P2COMM AGREES WITH OUR SYSTEM

CIP2SP:	SETZM P2NUM		;LOSING, TRY TO TURN OFF P2
	SETZM DETFLG		;IN ANY CASE, DON'T TRY TO USE IT ANYMORE
	PUSHJ P,HNGP2D		;GIVE HUNG TIMEOUTS TO ITS DEVICES
	SKIPE DIDLOD		;HAVE I ALREADY RELOADED?
	JRST CIP2D		;YES, DON'T KEEP TRYING
	SETOM DIDLOD		;FLAG THAT IT'S BEEN DONE
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES		;TELL SOMEONE
	ASCIZ /P1 and P2 P2COMM addresses incompatible, I'll try to reload P2.
/
	MOVEI TAC,['P2LOAD'↔'  1  2'↔<REAPRV!ACWPRV,,0>↔0]
	PUSHJ P,FIREUP
	 JFCL			;TOUGH
>;IFN FTP2
CIP2D:	HGMAC (21)
	SOSLE FSCKCT
	SKIPE FSNCLK
	PUSHJ P,FSCLK		;THINK ABOUT FREE STORAGE.
	SKIPLE SPFSNT
	PUSHJ P,SFSCLK		;REPLENISH SPARE LISTS IF NECESSARY
;;;DPYCLK uses HGMAC for 35,36,37
	PUSHJ P,DPYCLK		;MAINTAIN DISPLAYS.  DPYSER CLOCK QUEUE

IFKL10,<HGMAC (44)
IFE PUPNUM,<
	PUSHJ	P,ENICLK
>;IFE PUPNUM
IFN PUPNUM,<
	PUSHJ P,PUPCLK
>;IFN PUPNUM
>;IFKL10

IFN FTIP,<
	HGMAC (23)
	PUSHJ P,IMPCLK
>;IFN FTIP
IFN FTSIX,<
	HGMAC (11)
	SKIPE SIXINL		;ANYTHING IN INPUT LIST?
	PUSHJ P,SIXCLK		;YES, GO SCAN IT.
	SKIPE SIXNWW		;WAITING FOR F.S.?
	PUSHJ P,SIXFSW		;YES, GO SEE IF IT IS COME YET
>;IFN FTSIX
IFN FTSAM,<
	PUSHJ P,SAMCLK		;Call SAMbox clock level code
>;IFN FTSAM
	MOVEI PID,P1PID		;MAKE SURE PID STAYS HONEST.
	HGMAC (16)
	PUSHJ P,JLCAL		;MAYBE RECOMPUTE A JOB'S PRIORITY, OR ORDER ALL JOBS
;;next two instructions not needed since P2 never executes JLCAL any more.
;;	SKIPE ORDYET
;;	PUSHJ P,ORDER		;SORT RUNQ BY PRIORITY ORDER.
	HGMAC (0)
	SOSG BATYET		;TIME TO SEE ABOUT PHANTOMS?
	PUSHJ P,BATCLK		;YES.
IFE FTF2,<
	CONI TV,SPWBUT		;READ THE SPACEWAR BUTTONS
>;IFE FTF2
	HGMAC(27)
	SKIPE SPWGO		;ONLY RUN SPACEWAR IF SOMEONE WANTS IT
	PUSHJ P,SPWP1		;SEE IF SOMEONE WANTS P1 SPACEWAR.
	HGMAC (31)
	PUSHJ P,WHOSER		;REFRESH some WHO LINE.
	HGMAC (0)
IFN FT11CLK,<
	SKIPE KLEPT+DTTIME	;SKIP UNLESS PDP11 HAS NEW TIME FOR US
	PUSHJ P,G11TIM		;TRY TO DECODE PDP11 TIME (SETOMS CONALV)
	 JRST CRKT1		;NO NEW TIME, OR TIME NO GOOD (maybe went backwards)
;;Begin checking any jump in real-time clock's time for being reasonable.
	MOVEI TAC,0		;collect amt of change of time here, in ticks
	CAMN DSER,PSDATE	;date change?
	JRST DATEOK		;no
	PUSH P,DAT		;save new date (local time)
	MOVE TAC,PSDATE		;get old date (standard time)
	PUSHJ P,DAYCNT		;see what day of forever it is
	PUSH P,TAC		;save answer
	MOVE TAC,DSER		;get new date (standard time)
	PUSHJ P,DAYCNT		;see what day it is (new day in TAC)
	POP P,TAC1		;old day
	POP P,DAT		;restore G11TIM result back to DAT
	SUB TAC,TAC1		;number of days that elapsed
	JUMPL TAC,CRKT1		;can't go backwards in date! (shouldn't happen)
	IMUL TAC,[=24*=60*=60*JIFSEC] ;times ticks in a day is ticks gone
DATEOK:	ADD TAC,DDB		;add in new time in ticks
	SUB TAC,PSTIME		;minus old time is total ticks of time skipped
	JUMPL TAC,CRKT1		;can't go backwards (shouldn't happen)
	CAIGE TAC,=60*=60*JIFSEC ;better be less than an hour
	JRST TIMEOK		;jump if reasonable change
;;;
;;; The time has just advanced by a large amount.  Maybe the clock is screwed up.
;;; So here we check to see if a wizard has been expecting this.  If not, we
;;; won't believe the clock.
;;;
;;; To permit updating the time of day after a big gap, e.g., a long time
;;; in DDT, set BIGTIM to:  FUNTIM,,<mins OK>  where <mins OK> is the max
;;; amount of jump in the time of day in MINUTES you want to allow (e.g., a
;;; little more than the number of minutes spent in DDT).  BIGTIM is normally
;;; zero, but is -1 if we found the clock jumped forward a lot without the
;;; system being enabled to accept such a time jump (via BIGTIM).
;;;
	IDIVI TAC,=60*JIFSEC	;convert to number of minutes of time jump
	SKIPGE TAC1,BIGTIM	;see if someone has enabled a big time change
	JRST CRKT1		;already warned that clock is whacko
FUNTIM←←132546	;random unlikely halfword code (must be positive as LH value).
	TLC TAC1,FUNTIM		;BIGTIM has to have this special value in LH
	TLNN TAC1,-1		;should be 0 in LH now, leaving <mins OK> in RH
	CAILE TAC,(TAC1)	;is amount of time jump within amt permitted (mins)
	CAIA			;nope, maybe we have a sick clock
	JRST TIMEOK		;yes, clear BIGTIM flag and accept the new time
	PUSHJ P,DISUSR		;print time (!) on CTY
	 SIXBIT /11TIME/	;this is the name of the cmd to type 11's last time!
	PUSHJ P,DISMES
	 ASCIZ/Console-11 real-time clock seems out of whack!  I'm not going to believe
whacko time till BIGTIM is set appropriately (see DATEOK; 11TIME cmd).
/
	MOVEI DDB,SCNDDB	;force a command on CTY
	MOVEI TAC,F.11TM	;forced-cmd code
	PUSHJ P,FORCEC		;force 11TIME command, don't care if fails
	SETOM BIGTIM		;flag that we've typed out this message now
	JRST CRKT1		;ignore console-11 time

;Here we accept the time given us by the console-11's realtime clock.
TIMEOK:	SETZM BIGTIM		;you have to re-enable each time you want big jump.
	CAMLE TAC,BIGJMP	;just for fun, we remember biggest time jump
	MOVEM TAC,BIGJMP	;remember biggest time jump we've seen (for info)
;;End of code checking the jump in real-time clock's time for being reasonable.
	EXCH J,TIME		;STORE TICKS SINCE MIDNIGHT
	EXCH DAT,THSDAT		;STORE DATE
	MOVEM DDB,PSTIME	;STORE TICKS IN PST
	MOVEM DSER,PSDATE	;STORE DATE IN PST
	PUSHJ P,TDSET		;Update TIMDAT and PSTDAT
;;Begin code to correct last disaster time to time of system resumption, in
;;order to make autologout lenient after a system pause.
	SUB J,TIME		;Get negative of increment in time
	SUB DAT,THSDAT		;And negative of increment in date
	JUMPG DAT,CRKT1		;If date went backwards, don't mess around
	MOVN TAC,J		;Make it positive time increment
	IDIVI TAC,JIFSEC	;Figure time increment in seconds
	JUMPE DAT,.+2		;Jump if date didn't change (otherwise assume 1 day)
	ADDI TAC,=24*=60*=60	;Adjust time change to include changing date
	CAIGE TAC,=30		;Is time change more than this many seconds?
	JRST CRKT1		;Small change
	MOVE DAT,TIMDAT		;Current date/time
	EXCH DAT,LASTDISASTER	;If no disaster was noticed, then say that
	JUMPE DAT,CRKT1		;  we have just had one right now!
	HRRZ J,DAT		;Get current idea of last disaster time (secs)
	ADDI J,(TAC)		;Increment disaster time, to system resumption time
	IMULI J,JIFSEC		;Need time in ticks for midchk
	HLRZ DAT,DAT		;Get date of last disaster
	MOVEI AC1,J		;Pointer to time word
	MOVEI AC2,DAT		;Pointer to date word
	PUSHJ P,MIDCHK		;Check for having passed midnight
	HRLM DAT,LASTDISASTER	;Store corrected date
	MOVE TAC,J		;Get corrected time
	IDIVI TAC,JIFSEC	;Convert back to secs
	HRRM TAC,LASTDISASTER	;Store corrected time of resumption in secs
	MOVE TAC,TIMDAT		;Let's not forecast a disaster
	CAMGE TAC,LASTDISASTER	;Disaster time in future?
	MOVEM TAC,LASTDISASTER	;Yes, back up disaster time to now!
;;End of disaster time update to resumption time.
CRKT1:	SOSLE CONYET
	JRST CRKT1A
	MOVEI TAC,5*=60*JIFSEC	;CHECK AGAIN IN 5 MINUTES
	MOVEM TAC,CONYET
	AOSE CONALV
	PUSHJ P,S11CLK		;NO TIME IN LAST 5 MINUTES, TELL 11 TO REPORT TIME
CRKT1A:
>;IFN FT11CLK
IFN FTP2,<
	SKIPN DETFLG
	JRST CRKT2		;NO CLOCK ROUTINES FOR P2 IF NO P2
IFN PTRNUM,<
	SKIPE PTRDAT+PTPSHT	;P2 WANT US TO RESET HUNG TIME?
	PUSHJ P,PTRP1H		;YES
	SKIPE PTRADV		;RUN CLOCKS FOR PTR,PTP,AD AND XGP
	PUSHJ P,PTRP1		;SERVE PTR
>;IFN PTRNUM
	SKIPE PTPDAT+PTPSHT	;P2 WANT US TO RESET HUNG TIME?
	PUSHJ P,PTPP1H		;YES
IFE PLTNUM,<
	SKIPE PTPFG1
	PUSHJ P,PTPP1		;SERVE PTP
>

IFG PLTNUM,<
	SKIPE PLTDAT+PTPSHT	;P2 WANT US TO RESET HUNG TIME?
	PUSHJ P,PLTP1H		;YES
	PUSHJ P,PTPP1		;PTP/PLT P1 CLOCK.
>
	SKIPE XGPP1F
	PUSHJ P,XGPP1		;SERVE XGP (OR VRN)
>;IFN FTP2
CRKT2:	HGMAC (0)
	MOVE TAC,DISPTR		;FLUSH DISASTER BUFFER IF NEEDED.
	CAME TAC,DISOPT		;ANYTHING IN THE DISASTER BUFFER?
	PUSHJ P,DISOUT		;YES, GO EMPTY IT
	JRST CRKT4		;JUMP  (TO LOSYS)

IFN FTP2,<
HNGP2D:	MOVSI TAC,DEVP2H	;BIT TO FLAG WE WANT HUNG TIMEOUT
	MOVEI TAC1,ASSPRG	;BIT IF DEVICE IS INITED
IFN PTRNUM,<
	TDNE TAC1,PTRDDB+DEVMOD
	IORM TAC,PTRDDB+DEVCMR
>;IFN PTRNUM
	TDNE TAC1,PTPDDB+DEVMOD
	IORM TAC,PTPDDB+DEVCMR
IFG PLTNUM,<
	TDNE TAC1,PLTDDB+DEVMOD
	IORM TAC,PLTDDB+DEVCMR
>;IFG PLTNUM
IFN FTVRN,<
	TDNE TAC1,VRNDDB+DEVMOD
	IORM TAC,VRNDDB+DEVCMR
>;IFN FTVRN
IFG XGPNUM,<
	TDNE TAC1,XGPDDB+DEVMOD
	IORM TAC,XGPDDB+DEVCMR
>;IFG XGPNUM
	POPJ P,
>;IFN FTP2

TDSET:	MOVE TAC,TIME		;GET CURRENT TIME
	IDIVI TAC,JIFSEC	;AND CONVERT IT TO SECONDS
	HRL TAC,THSDAT		;PUT DATE IN LEFT HALF
	MOVEM TAC,TIMDAT	;SAVE <DATE>,,<TIME IN SECS>
	MOVE TAC,PSTIME
	IDIVI TAC,JIFSEC
	HRL TAC,PSDATE
	MOVEM TAC,PSTDAT
	POPJ P,
;CRKT4 CIP4 CIP5AA CIP5A CIP5 CNTCPT CNTCP1 NCLKRQ NCLKRQ CLKRQS LCLKRQ CLKUGH CQUERR CQUEUE
;CLOCK QUEUE

	LOSYS			;BOTH PROCESSORS HERE

;PROCESS CLOCK QUEUE  - BOTH PROCESSORS.
CRKT4:	HGMAC (17)
	HRRZ DAT,CLOCKP		;GET END OF LIST
CIP4:	CAIG DAT,CIPWT-1	;END YET?
	JRST CIP5		;YES
	SOS TAC1,(DAT)		;DECREMENT TIMING REQUEST
	TRNE TAC1,7777		;TIME EXPIRED YET?
	SOJA DAT,CIP4		;NO, CONTINUE SCAN
	SYSPIFF			;YES, MOVE LAST ITEM IN LIST TO THIS
	MOVE TAC,@CLOCKP
	SOS CLOCKP
	MOVEM TAC,(DAT)
	SYSPIN
	LDB TAC,[POINT 15,TAC1,23] ;GET 15 BIT DATA ITEM
	LDB TAC1,[POINT 9,TAC1,8] ;GET DISPATCH INDEX
	CAILE TAC1,NCLKRQ-1	;Valid index?
	MOVEI TAC1,0		;No, make into dispatch to error routine
	MOVE TAC1,CLKRQS(TAC1)	;Get dispatch address
CIP5AA:	PUSH P,DAT		;SAVE ONLY VALUABLE AC
IFN FTHG,<
	PUSH P,HGCODE 
	HGMAC (22)
>;IFN FTHG
	PUSHJ P,(TAC1)		;AND DISPATCH TO TIMING REQUEST ROUTINE
IFN FTHG,<
	POP P,HGCODE
>;IFN FTHG
	POP P,DAT
CIP5A:	SOJA DAT,CIP4		;GO BACK FOR MORE REQUESTS
CIP5:	MOVE TAC,TIME
	TRNE TAC,3		;SKIP IF THIS IS THE FOURTH TICK
	JRST CIP11
	MOVEI J,JOBN-1		;DECREMENT PROTECT TIME
CNTCPT:	SOSG JBTICP(J)
	JRST CNTCP1
	MOVM TAC,JOBQUE(J)
	CAIE TAC,TQ
	CAIN TAC,RUNQ
	JRST CNTCP1
	CAIE TAC,DIOWQ
	SOS JBTICP(J)		;COUNT 2 TICKS PER TICK FOR NOT RUNNING
CNTCP1:	SOJG J,CNTCPT

	JRST CIP11		;TO HISYS

;Here is the table of possible clock requests
;First a macro to define the index for a particular dispatch address
;and at the same time deposit the address in the dispatch table.
DEFINE XX'(ADR)<
IFDIF <ADR><CLKUGH>,<
 IFDEF $'ADR,<.FATAL Clock request index symbol $'ADR multiply defined.>>
↑↑$'ADR←←NCLKRQ⊗9
NCLKRQ←←NCLKRQ+1
	ADR	>;DEFINE
NCLKRQ←←0	;Initialize the index, macro will count it up
;The $XXXXX symbols are left half values to be ORed or ADDed in to clock request.
;Note that the first FIVE chars in a dispatch address must be unique, since
;a dollar sign is prepended to format the symbol for the clock request index.

CLKRQS:	XX(CLKUGH)	;Make zero always an error, to catch accidents
	XX(BATRS)	;phantom delay request (1 tick)
	XX(BATTT)	;phantom delay request (1 tick)
	XX(WAKE)	;sleep request (1:7777)
	XX(SDEAD)	;core deadlock request (15 or 30 secs)
	XX(HALFD)	;core deadlock request (15 or 30 secs)
	XX(DPYKIL)	;delayed dpykill (1 tick to 15 secs)
	XX(HNGCM1)	;pick up hung phone request (5 secs)
	XX(TTYKC0)	;delayed ttykill (15 secs)
	XX(ASTD11)	;delayed CD down action (1/2 sec)
IFE FTDLS,<
IFN FTDSYI,<
	XX(DCA2MN)	;DCA system initial hangups (1,2,3 mins)
	XX(DCA1MN)	;DCA system initial hangups (1,2,3 mins)
	XX(DCANOW)	;DCA system initial hangups (1,2,3 mins)
>;IFN FTDSYI
>;IFE FTDLS
IFN FTREPT,<
	XX(CLKRPT)	;line editor repeating request (6 ticks)
>;IFN FTREPT
IFN FTVBEEP,<
	XX(WHORPT)	;Flashing who lines
>;IFN FTVBEEP
IFN DLNNUM,<
	XX(DLNCLK)	;Dialnet...
	XX(DLNRLA)	;
	XX(DLNLC)	;
	XX(DCWAKE)	;
	XX(DLPCLK)	;
	XX(DLPTST)	;
>;IFN DLNNUM
IFN MTCNUM,<
	XX(MTCLOK)	;rewind tape check (1/2 sec)
>;IFN MTCNUM
IFN MTUNUM,<
	XX(MTUCLK)	;rewind tape check (1/2 sec) for TU-78
>;IFN MTUNUM
IFN FTP2,<
IFG XGPNUM,<
	XX(GETBT0)	;font compiler creation (1 tick)
	XX(FCRQCK)	;wait for font compiler done (60 secs)
>;IFG XGPNUM
>;IFN FTP2
IFG DILNUM,<
IFN FTVDIL,<
	XX(DLRTO)	;dialer timeout (60 secs)
>;IFN FTVDIL
>;IFG DILNUM
	XX(TGREE)	;greet newly dialed up TTY (1/2 sec)
;Add new clock dispatch addresses ABOVE here.
LCLKRQ←←.-CLKRQS	;Index after last valid clock request, for CQUEUE
;CLKUGH must be the last entries in clock request table, for patches to be reserved.
	XX(CLKUGH)	;Allow two dispatch addresses to be patched in, but if
	XX(CLKUGH)	;  you patch, must increase index limit tested in CQUEUE.

;Here at clock dispatch time, with bad clock request.
↑CLKUGH:PUSHJ P,DISGST		;Print time of error on CTY (no acs saved here)
	PUSHJ P,DISERR
	 [ASCIZ/CLKSER clock request index is Zero or Too Big, or request has Data Too Big.
Clock req = /]
	 DISARG OCH,<@-2(P)>	;Get clk req via DAT saved on stack in main loop
	 -1
	PUSHJ P,DISCRL
	DEBCHECK(NOPOPACS)
	POPJ P,			;Return to main clock queue dispatch loop

;Here at clock request enqueueing time, with bad clock request.
↑CQUERR:PUSHACS
	PUSHJ P,DISGST		;Print time of error on CTY (no acs saved here)
	PUSHJ P,DISERR
	 [ASCIZ/CLKSER clock request index is Zero or Too Big, or request has Data Too Big.
Clock req = /]
	 DISARG OCH,<-21(P)>	;Print clk req that was saved on the stackby CQUEUE
	 [ASCIZ/     Callers = /]
	 DISARG LOC,<-23(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-24(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-25(P)>
	 -1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	ADJSP P,-1		;Flush clk req from stack
	POP P,TAC		;Restore saved TAC
	PUSHJ P,WDDTCA		;Get help; skip return after fixing clk req to retry!
	 JRST CPOPJ1		;Return without planting clock request, skip over JFCL ADR
;Routine to plant CLKSER clock request from any location.  Call with:
;	MOVE ADR,<clk req>
;	PUSHJ P,CQUEUE
;	 JFCL ADR		;This word is indirected through to find the clk req
;Preserves all ACs.  Clock request doesn't have to be in an AC.
↑CQUEUE:PUSH P,@(P)		;Push the JFCL ADR word on the stack
	PUSH P,@(P)		;Push the actual clock request on top of stack
	MOVEM TAC,-1(P)		;Save TAC
	LDB TAC,[POINT 9,(P),8] ;GET DISPATCH INDEX
	CAILE TAC,LCLKRQ-1	;Valid index?
	JRST CQUERR		;No!
	JUMPE TAC,CQUERR	;Jump if zero index, illegal
;;	LDB TAC,[POINT 15,(P),23] ;GET 15 BIT DATA ITEM
	POP P,TAC		;Get the clock request
	SYSPIFF			;Don't interrupt in middle of IDPB
	IDPB TAC,CLOCKP		;Plant clock request
	SYSPIN
	JRST TPOPJ1		;Skip over JFCL ADR word, and restore saved TAC
;SPWCHK CIP11A CIP11 CIP11B CIPNEG COMTIM CIP11E CIP11C CIP11D CIPFOO CLKSRJ CLKSRX COMLST COMLSL COMLS2

HISYS

SPWCHK:	MOVE TAC1,[,SPWGO(J)]
	SETZ J,
	MOVSI TAC,SPWERB	;LOOK FOR ANY SPACEWAR MODE ERRORS
	LDB J,[POINT JOBNSZ,@TAC1,JOBNSZ-1] ;GET NEXT JOB IN SPW LIST
	TDNN TAC,JBTST2(J)	;See if any errors
	JUMPN J,.-2
	JUMPE J,CPOPJ
	JRST SPWMES		;Go print spw error

CIP11A:	AOSE COMFLG		;HERE IF IT IS NOT A TIME INTERRUPT
	JRST CIP11D		;NOT TRYING TO FORCE CALL TO COMMAND
	JRST CIP11B		;TRY RUNNING COMMANDS

CIP11:	SKIPE SPWGO
	PUSHJ P,SPWCHK
	HGMAC (1)
CIP11B:	SKIPN COMCNT		;ANY COMMANDS TO PROCESS?
	JRST CIP11C		;NO
IFN FTCMDBUG,<
	SKIPG COMCNT		;COUNT IS NEVER SUPPOSED TO GO NEGATIVE
	JRST CIPNEG		;BUT IT MIGHT IF THE COMAGN BUG TRAP OVER CORRECTED
	SOSG COMAGN
	JRST CIP11E		;COMMAND CALLED TOO MANY CONSECUTIVE TIMES!!
>;FTCMDBUG
	PUSHJ P,PSHMAP		;SAVE STATE OF MAP
	PUSHJ P,COMMAND		;CALL COMMAND DECODER.
	PUSHJ P,POPMAP		;RESTORE THE MAP
	JRST CIP11D

IFN FTCMDBUG,<
CIPNEG:	PUSHACS
	MOVE AC2,COMCNT
	SETZM COMCNT		;Fix count
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /COMCNT/
	PUSHJ P,DISERR
	[ASCIZ/COMCNT negative at CIP11B.  COMCNT = /]
	DISARG DCP,AC2
	-1
	PUSHJ P,DISCRL
	DEBCHECK(POPACS)	;CALL DDT IF DEBUGGING
	JRST CIP11C		;DON'T DO ANY COMMANDS THIS TIME

↑COMTIM←←JIFSEC*=60		;CONSECUTIVE CALLS TO COMMAND BEFORE COMPLAINING
CIP11E:	PUSHACS
	MOVE AC2,COMCNT
;;;Don't fix count, probably ought to be positive, maybe swapper hung.
;;;	SETZM COMCNT		;Fix count
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /COMCNT/
	PUSHJ P,DISERR
	[ASCIZ/COMCNT non-zero for 3600. ticks solid; COMCNT now = /]
	DISARG DCP,AC2
	[ASCIZ/
/]
	 -1
;;	PUSHJ P,COMLST		;LIST RECENT COMMANDS
	DEBCHECK(POPACS)	;CALL DDT IF DEBUGGING
	SKIPA TAC,[=10*COMTIM]	;Don't say anything again for 10 mins
>;IFN FTCMDBUG
CIP11C:
IFN FTCMDBUG,<
	MOVEI TAC,COMTIM	;NUMBER OF CONSECUTIVE CALLS BEFORE WE COMPLAIN
	MOVEM TAC,COMAGN	;NOTE THAT WE DIDN'T CALL COMMAND THIS TIME
>;FTCMDBUG
CIP11D:	HGMAC (6)		;GET HERE IF NOT A CLOCK TIC
	MTRON (MTRNXT)
IFN FTACBUG,<
	MOVE J,JOB
	PUSHJ P,WSYJCM		;CHECK J MAYBE
>;IFN FTACBUG
	PUSHJ P,NXTJOB		;CALL SCHEDULER
	MTROFF (MTRNXT)
	HGMAC (15)

IFN FTSTAT,<
	MOVEI TAC,JOBSTA	;TRANSMIT NEXT JOB NUMBER TO RUN
	CAME J,JOB		;DON'T RETRANSMIT SAME JOB NUMBER AGAIN
	PUSHJ P,STAPUT
>;IFN FTSTAT

	JUMPN J,CLKSRJ		;IF NULL JOB RUNS NEXT, DO FOLLOWING TEST.
	MOVE AC1,[-RUNQ,,-RUNQ]
	MOVE AC2,[-TQ,,-TQ]
	CAMN AC1,JBTQ-RUNQ
	CAME AC2,JBTQ-TQ
	AOSA NJRNULLS		;COUNT WASTED TIME.  OTHER JOBS WANT TO RUN
	JRST CLKSRJ		;NOT WASTED
	MTRON (MTRWST)		;COUNT WASTED TIME
	JRST CLKSRX

CLKSRJ:	MTROFF (MTRWST)		;THIS ISN'T A WASTED TICK
CLKSRX:
;Record bit for job about to run, for system wholine stats
	MOVEI AC1,(J)		;Figure out which word bit for this job is in
	IDIVI AC1,44		;Word index in AC1, shift amount in AC2
	MOVEI TAC,1		;Mask bit
	LSH TAC,(AC2)		;Shift to proper position
	IORM TAC,JBSRUN(AC1)	;Turn on bit for this job
	JRST CIP6B		;(LOSYS)

REPEAT 0,< ;Don't delete this code.  It is handy from time to time for bugtraps.
;Routine to type out the last NLCOMS commands.
;This routine does NEITHER a PUSHACS nor a DISFLUSH.  That's up to the caller.
↑COMLST:PUSHACS
	PUSHJ P,DISMES
	ASCIZ/
Most recently executed command dispatches:
   Command            DDB           TTYTAB          IMLHAC      TTY#  Ticks ago
/
;AC1, AC2, AC3 are preserved by DISTYO and friends.
;However, AC1 is clobbered by DISFLUSH and DISERR.
	MOVE AC1,NCOMS
	ANDI AC1,NLCOMS-1	;MAKE POINTER TO MOST RECENT CMD
	MOVEI AC3,NLCOMS	;NUMBER OF COMMANDS REMEMBERED--TYPE THEM OUT
COMLSL:	MOVE TAC,LCOMS(AC1)	;GET COMMAND BITS AND DISPATCH ADDRESS
	PUSHJ P,DISOCH		;PRINT HALFWORDS
	PUSHJ P,DISTAB		;PRINT A TAB
	MOVE TAC,LDDBS(AC1)	;GET TTY DDB
	PUSHJ P,DISOCH		;PRINT HALFWORDS
	PUSHJ P,DISTAB		;PRINT A TAB
	HRRZ DDB,LDDBS(AC1)	;TTY DDB AGAIN
	MOVEI TAC1,@PUNIT	;CALCULATE ADDRESS WHERE WE WANT TO LOOK
	CAIL TAC1,TTYLST-DDBSKW	;TTY DDB SHOULDN'T BE BEFORE MODEL
	CAML TAC1,FSTOP		;IS THIS A VALID ADDRESS FOR US TO EXAMINE
	JRST [	PUSHJ P,DISMES
		ASCIZ/DDB out of bounds			/
		JRST COMLS2 ]
	LDB AC2,PUNIT		;YES, GET TTY NUMBER FROM DDB
	MOVE TAC,TTYTAB(AC2)	;GET TTYTAB
	PUSHJ P,DISOCH		;PRINT HALFWORDS
	PUSHJ P,DISTAB		;AND A TAB
	HRRZ DDB,LDDBS(AC1)	;GET DDB AGAIN
	MOVE TAC,IMLHAC(DDB)	;GET IMLHAC
	PUSHJ P,DISOCH		;PRINT HALFWORDS
	PUSHJ P,DISTAB		;AND A TAB
	MOVE TAC,AC2		;GET TTY NUMBER AGAIN
	PUSHJ P,DISLOC		;PRINT RH SUPPRESSING LEADING ZEROES
	PUSHJ P,DISTAB
COMLS2:	MOVN TAC,LTIMS(AC1)	;SUBTRACT UPTIME AT TIME OF THIS COMMAND
	ADD TAC,UPTIME		;FROM CURRENT UPTIME
	PUSHJ P,DISDCP		;PRINT IN DECIMAL
	PUSHJ P,DISCRLF		;PRINT A CRLF
	SOJGE AC1,.+2
	MOVEI AC1,NLCOMS-1	;WRAP AROUND
	SOJG AC3,COMLSL		;UNTIL WE'VE LISTED ALL THE SAVED COMMANDS
	PUSHJ P,DISFLU		;so we can be called from DDT, force output
	POPACS
	POPJ P,
>;REPEAT 0
;S2U S2U1 U2S CIP6A CIP6B NULJOB CIP7XX
;CONTEXT SWITCHING

LOSYS

;S2U AND U2S -- MOVE DATA BETWEEN PROTECTED USER CORE AND USRPRT.
;(S2U ALSO CALLED FROM ANYACT)

↑S2U:	MOVSI TAC,USRPRT	;FROM SYSTEM COPY OF JOBDAT
	HRRI TAC,JOBPRT		;TO USER'S JOBDAT WHILE NOT RUNNING.
	SKIPGE USRHCU		;SAVGET IO HAPPENING?
	JRST S2U1
	XCTR XBLTW,[BLT TAC,JOBJDA+17] ;MOVE SYSTEM TO USER.
	POPJ P,

S2U1:	XCTR XBLTW,[BLT TAC,JOBPC] ;STORE ONLY JOBHCU AND JOBPC.
	POPJ P,

↑U2S:	MOVSI TAC,JOBPRT	;FROM USER'S JOBDAT
	HRRI TAC,USRPRT		;TO SYSTEM'S PROTECTED COPY
	XCTR XBLTR,[BLT TAC,USRJDA+17] ;MOVE USER TO SYSTEM
	POPJ P,


;PREPARE TO RETURN TO USER JOB. (POSSIBLY SWITCHING JOBS)

CIP6A:	MOVEI J,0		;HERE ON P2.  RUN THE NULL JOB.
CIP6B:	SETZM SCHEDF		;CLEAR FORCED SCHEDULING FLAG
	SETZM TIMEF		;CLEAR "CLOCK FIRED" FLAG
	MOVEI TAC,AVLNUM
	CAME J,CALLTB(TAC)
	SOJGE TAC,.-1
	CAIGE TAC,MINQ
	CAIA
	SETZM CALLTB(TAC)	;CLEAR CALLTB ENTRY WHEN JOB GETS TO RUN
	CAMN J,JOB		;IS NEXT JOB SAME AS LAST ONE?
	JRST CIP8AA		;YES, JUST RESTORE ACS AND DISMISS
	SKIPE J			;ARE WE SWITCHING TO THE NULL JOB?
	AOS NJSWITCHES		;NO, MARK ANOTHER SWITCHING
	MOVE TAC1,JOB		;SAVE SOFTWARE STATE.  GET OLD JOB
	MOVE TAC,TIMDAT		;GET <DATE>,,<TIME IN SECS>
	MOVEM TAC,FTIME(TAC1)	;AND SAVE FOR JOB THAT JUST RAN
	SKIPLE TAC,JOB		;SKIP IF THERE WAS NO OLD JOB
	SKIPN JBTPAG(TAC)	;OLD JOB EXISTED.  SKIP IF IT STILL HAS CORE
	JRST NULJOB		;IF NO OLD JOB OR NO CORE, THEN DON'T
	PUSHJ P,S2U		;PUT CHANNEL ASSIGNMENTS BACK IN USER CORE
↑NULJOB:			;HERE FROM SYSINI WITH J←0
	MOVEM J,JOB		;STORE NEW CURRENT JOB NUMBER
	SKPKL
	CONO APR,550+APRCHN	;CLEAR APR ENABLED FLAGS
	HLLZS APRIN1		;DISABLE USER APR INTERRUPTS
	SETZM APRIN3
	JUMPE J,CIP8X		;JUMP IF SWITCHING TO NULJOB (P2 JUMPS)
	HGMAC (12)
	AOS AMC3		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;P1. NOT THE NULL JOB. SETUP THE MAP
	HGMAC (15)
	HLRZ TAC,JBTPAG(J)
	LSH TAC,9
	SUBI TAC,1
	XCTR XW,[HRRZM TAC,JOBREL] ;LET USER SEE HIS PROTECTION IN JOBREL
	PUSHJ P,U2S		;MOVE USER TABLE INTO SYSTEM
	HGMAC(13)
IFKL10,<
	PUSHJ P,CSHSET		;TURN ON CACHE FOR THIS JOB
>;IFKL10
	HGMAC(15)
IFN FTACBUG,<
	PUSHJ P,WSYJCM		;CHECK NEW JOB'S J
>;IFN FTACBUG
	JRST CIP8A7		;MAP ALREADY SETUP.

CIP7XX:	PUSHACS			;A BUG TRAP.
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /RUNNING JOB WITH NO CORE. /
	MOVSI TAC,RUN
	ANDCAM TAC,JBTSTS(J)
	PUSHJ P,DISJOB
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCAL
	SETZB J,JOB		;FALL INTO NULL JOB.
	SETOM NULBAD
	JRST CIP8
;CIP8X CIP8 CIP8AA CIP8A7 CIP8A8 CIP8C CIP8B
;RESTORE HARDWARE STATE OF NEW JOB - CIP8

CIP8X:	SETOM NULBAD		;SWITCH TO (RESTART) NULL JOB.
;CIP8 - ON P1 TO CONTINUE A JOB, OR TO INITIATE THE NULL JOB
CIP8:	HGMAC (12)
	AOS AMC4		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP MAP
	HGMAC (15)
CIP8AA:	JUMPE J,CIP8A8		;FOR NULL JOB, AVOID SETTING UP INTERRUPTS
CIP8A7:	MOVE TAC,JBTIEN(J)	;PICK UP USER INTERRUPT ENABLINGS
	ANDI TAC,CPUMSK		;CONS,PDLOV,NXM,MPV,FOV,OV.  NOT CLOCK!
	MOVEM TAC,APRIN2	;SET SO CH3 CAN TEST FOR THEM
	XCTR XR,[IOR TAC,JOBENB] ;NOW INCLUDE OLD-STYLE INTS
	ANDI TAC,CPUMSK!1000	;SYSTEM ENABLED FOR PDL OV, ILM, NXM, CLK
	PUSHJ P,APREN2		;(IN APRENB UUO. SETUP APR, TRAP LOCS)
CIP8A8:	SETOM STIME(J)		;MARK CORE IMAGE HAS BEEN RUN (AND MODIFIED)
IFN FTSCNBUG <
	JSR CH7CHK		;BUG TRAP FOR STATE OF SCANNER CHANNEL
>;FTSCNBUG
	LDB TAC,PSEGN		;AND MARK HIGH SEGMENT TOO
	MOVE TAC1,JBTSTS(TAC)	;IF IT IS NOT WRITE-PROTECTED
	TLNN TAC1,JWP
	SETOM STIME(TAC)	;IF WRITE-ENABLED, MARK AS MODIFIED.
IFKL10,<
IFE FTMTRACT,<
	PUSHJ P,MTRJST		;SET UP METERING FOR JOB IF APPROPRIATE
>;IFE FTMTRACT
>;IFKL10
	SKIPE JBTPAG(J)		;SKIP IF THERE IS NO JOB DATA AREA
	JRST CIP8B		;NOT THE NULL JOB.  RUN JOB.
	SKIPE NULBAD		;NO. IT'S THE NULL JOB.  IS IT SICK?
	JRST NULJB		;YES, GO START IT UP AGAIN
	MOVEI TAC,NULDAT	;HERE TO CONTINUE RUNNING THE NULL JOB
	MOVE TAC,JOBD17(TAC)
	MOVEM TAC,CLKS17
	JRST CIP8C

HISYS

CIP8C:				;HERE TO CONTINUE NULL JOB ON P1.
NOKL10,<SKIPN LITOFF
	DATAO PI,[400000,,0]	;Display a bit for null job in lights
>;NOKL10
IFKL10,<DATAO KLPAG,[401000,,0]	;AC BLOCK 1. PREV IRRELEVANT
>;IFKL10
	MOVSI 17,JOBDAC+NULDAT	;RESTORE DUMP ACS
	BLT 17,16
	MOVEI 17,P1PID
	SKIPE APRERR(17)	;ERROR IN THE EXEC?
	JRST CLKERR		;YES. GO PROCESS.
	MOVE 17,CLKS17(17)

	MTRCOF (CH7,P2NOCK)

	JRST 12,@USRPC		;RETURN TO USER


CIP8B:	XCTR XR,[MOVE TAC,JOBD17] ;RUN A JOB (NOT JOB 0) ON P1.
	MOVEM TAC,CLKS17
NOKL10,<MOVN J,J		;READY TO RUN THAT JOB.
	MOVSI TAC,400000	;UNARY BUT AMBIGUOUS DISPLAY OF JOB NUMBERS
	ROT TAC,(J)
	SKIPN LITOFF
	DATAO PI,TAC		;DISPLAY JOB NUMBER.
>;NOKL10
IFKL10,<MOVE TAC,USRPC		;GET PC WE'RE ABOUT TO RETURN TO
	TLNN TAC,USRMOD
	DATAO KLPAG,[400100,,0]	;BACK TO EXEC MODE
	TLNE TAC,USRMOD
	DATAO KLPAG,[401000,,0]	;BACK TO USER MODE, PREV IRRELEVANT
>;IFKL10
	MOVSI 17,JOBDAC		;RESTORE DUMP ACS
	XCTR XBLTR,[BLT 17,16]	;MOVE DUMP ACS TO PHYSICAL ACS.
	MOVEI 17,P1PID
	SKIPE APRERR(17)	;ERROR IN THE EXEC?
	JRST CLKERR		;YES. GO PROCESS.
	MOVE 17,CLKS17(17)	;RESTORE LAST AC.

	MTRCOF (CH7,P2NOCK)

	JRST 12,@USRPC		;RETURN TO USER.
;NULJB NULPAG NULJP1 NULP1X NULJP2 NULP2X

;THE NULL JOB
;RUNS IN ACS IN USER MODE.

LOSYS

NULJB:	SETZM NULBAD
NOKL10,<
NULPAG:	SKIPN LITOFF
	DATAO PI,[400000,,0]	;DISPLAY US IN LITES
>;NOKL10
IFKL10,<DATAO KLPAG,[401000,,0]	;SET CURRENT AC BLK = 1, PREV IRRELEVANT
>;IFKL10
	MOVSI 17,NULJP1		;SET UP BLT TO ACCUMULATORS
	BLT 17,NULP1X		;BLT IN ZINGHEIM'S NULL JOB

	MTRCOF (CH7,P2NOCK)

	JRST 12,@[USRMOD,,1]	;DISMISS IF INTERRUPT IN PROGRESS

IFE FTF2,<
NULJP1:	0
	ROT 0,-1		;RING AROUND THE ACCUMULATOR
	TLNN 0,200000
	TLC 0,400000
	MOVEI 10,70000
	SOJGE 10,5
	JRST 1
NULP1X←←.-NULJP1
>;IFE FTF2
IFN FTF2,<
NULJP1:	201400,,0		; CAREFUL NOT TO GET OVER/UNDER FLOWS
	FMPRI 0,201400		; LOT OF TIME, BUT NOT MEMORY CYCLES
	JRST 1
NULP1X←←.-NULJP1
>;IFN FTF2

REPEAT 0,<
NULJP2:	0
	ROT 0,1			;RING AROUND THE ACCUMULATOR
	TRNN 0,2
	TRC 0,1
IFL PRCONF-2,<	MOVEI 10,34000	>;SHORT COUNT FOR PDP-6
IFE PRCONF-2,<	MOVEI 10,70000	>;LONG COUNT FOR KA10
	SOJGE 10,5
	XCT SIXRUN		;TRAP IF CORE GETS CLEARED
	JRST 1
NULP2X←←.-NULJP2
>;REPEAT 0
;CHECK CHECK1 CHKNOW

;THE LINE DIRECTLY BELOW THIS ONE IS FALSE NOW.
;18-BIT FOLDED CHECKSUM ROUTINE, DEDICATED TO THE MEMORY OF BERTRAND RUSSELL.
;CALL WITH AOBJN POINTER IN TAC.   RETURNS CHECKSUM IN TAC1.

↑CHECK:	MOVEI TAC1,0		;INITIALIZE SUM
;;;	JCRY0 .+1		;CLEAR CARRY 0 FLAG
CHECK1:
IFE FTCINS∧FTF2,<
	ADD TAC1,(TAC)		;FORM THE SUM.
;;;	JCRY0 [AOJA TAC1,.+1]	;IN CASE OF CARRY 0, INCREMENT SUM
	AOBJN TAC,CHECK1
>;IFE FTCINS∧FTF2
IFN FTSUAI,< printx Consider using CHKINS at CHECK1 >;IFN FTSUAI
IFN FTCINS∧FTF2,<
IFN FTF2,<
	JUMPE TAC,CPOPJ		;EDDT calls CHECK with zero WCMA if MONPTR has
				;  not been set up yet.
	TLCN TAC,400000		;Larger than 128K?
	  CHKINS TAC,		;  Yes, checksum half of address space
	TLC TAC,400000		;Undo fudge
>;IFN FTF2
	CHKINS TAC,		;Now, do the rest
>;IFN FTCINS∧FTF2
REPEAT 0,<
	HLRZ TAC,TAC1		;TAC←LH OF SUM
	HRRZ TAC1,TAC1		;TAC1←RH OF SUM
	ADD TAC1,TAC		;TAC1←FOLDED SUM
	TLZE TAC1,1		;INCASE OF HIGH ORDER CARRY, 
	ADDI TAC1,1		;INCREMENT.
>;REPEAT 0
	POPJ P,

↑CHKNOW:MOVEI TAC1,=300*JIFSEC	;CHECKSUM EVERY 5 MINUTES
	MOVEM TAC1,CHKYET
	PUSHJ P,SYSFIX		;CHECK FOR ERROR AND FIX
	 POPJ P,		;NO ERRORS
	 JFCL			;ERROR, BUT CAN'T FIX, FIX CHECKSUM.
	MOVE TAC,MONPTR		;RECOMPUTE CHECKSUM
	PUSHJ P,CHECK
	MOVEM TAC1,MONSUM

IFN FTHSYS,<
	MOVE TAC,HMNPTR
	PUSHJ P,CHECK
	MOVEM TAC1,HMNSUM
>;IFN FTHSYS

	POPJ P,
;SYSFIX SYSFX1 NOTOK TTPPJ1

	BEGIN SYSFIX		;VERIFY SYSTEM CHECKSUM AND FIX IT IF WRONG.
; CALLED BY:
;	PUSHJ P,SYSFIX
;	<NO ERRORS>
;	<ERROR, BUT COULDN'T FIX>
;	<ERRORS FIXED>


↑↑SYSFIX:
	PUSH P,TAC
	PUSH P,TAC1
	MOVE TAC,MONPTR
	PUSHJ P,CHECK		;CHECKSUM MONITOR
	CAME TAC1,MONSUM	;IS IT OK?
	JRST NOTOK
IFN FTHSYS,<
	MOVE TAC,HMNPTR
	PUSHJ P,CHECK
	CAME TAC1,HMNSUM
	JRST NOTOK
>;IFN FTHSYS
SYSFX1:	POP P,TAC1
	POP P,TAC
	POPJ P,			;ALL IS WELL

NOTOK:	PUSHACS
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /πππMONITOR CHECKSUM FAILURE, XOR = /
	POP P,TAC
	XOR TAC,MONSUM
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	POPACS			;IF DISK IS OFF-LINE, NOTHING WE CAN DO.
↑↑TTPPJ1:POP P,TAC1
	POP P,TAC
	JRST CPOPJ1		;TELL THEM NOTHING FIXED!

BEND SYSFIX
;INTRUN INTSC1 INTR2 INTR1 INTR11 INTSCR
;INTRUN - THE (MOORER) USER INTERRUPT HANDLER

HISYS

↑INTRUN:SETZB AC1,INTREQ	
	EXCH AC1,APRIN3		;GET CORRECT PC, IF APR TRAP (SEE APRERV)
	SKIPE AC1		;SKIP IF NOT AN APR TRAP
	MOVEM AC1,USRPC		;STORE INTERRUPT PC (NOT JOBTM5)
	PUSHJ P,PSHMAP		;SAVE STATE OF MAP
	PUSH P,USRSAV		;MAY HAVE INTERRUPTED UUOCON BEFORE IT'S REENTRANT
	PUSH P,UUO0		;THE UUO LOCATION
	PUSH P,@UUOLOC		;THE UUO ITSELF
	MOVE AC1,JOB		;JOB NUMBER THAT WAS INTERRUPTED TO RUN THIS INT.
	MOVEM AC1,SJOB		;SAVEIT FOR LATER.
	PUSH P,@CLKCH		;SAVE CLKINT DATA BECAUSE IT IS NOT REENTRANT
	PUSH P,CLKS17		;
	PUSH P,SCHEDF
	PUSH P,APRPC		;SAVE ANY APR ERRORS - I-PROCESS MAY MAKE NEW ONES
	PUSH P,APRERR
	PUSH P,APRIN1
	MOVSI AC1,USRPRT	;SAVE USER CHANNEL TABLE.  (SOURCE)
	HRRI AC1,1(P)		;(DESTINATION)
	MOVEI AC2,USRJDA+20-USRPRT(P) ;(ENDING ADDRESS OF BLT)
	BLT AC1,(AC2)
	ADD P,[USRJDA+20-USRPRT,,USRJDA+20-USRPRT]
	SETOM INTACT		;WE ARE NOW AT INTERRUPT LEVEL
INTSC1:	MOVEI J,JOBN-1		;SCAN JOBS LOOKING FOR ONE WITH AN INTERRUPT.
INTR2:	SKIPN AC1,JBTIRQ(J)	;INTERRUPT WAITING HERE?
INTR1:	SOJG J,.-1		;NO
	JUMPE J,INTXIT		;IF NONE AT ALL, GO AWAY
	JUMPL J,INTSCR		;(BUG TRAP)
	PUSHJ P,GETINT		;GET THE BIT CORRESPONDING TO THE INTERRUPT
	 JRST INTR1		;ALL MASKED OUT, LOOP BACK FOR NEXT GUY
	MOVE AC2,JBTSTS(J)
	TLNN AC1,INTSWW		;IF THIS IS A SWAP INTERRUPT,
	TLNN AC2,SWP		;  THE JOB IS REALLY THERE!
	SKIPN JBTPAG(J)		;IS THIS JOB INCORE?
	JRST INTSWAPIN		;GET HIM SWAPPED IN IF NEEDED.
	LDB AC3,PSEGN		;DOES HE HAVE AN UPPER?
	JUMPE AC3,INTR11
	MOVE AC2,JBTSTS(AC3)	;SEE IF UPPER IS IN CORE
	TLNN AC1,INTSWW
	TLNN AC2,SWP
	SKIPN JBTPAG(AC3)	;SKIP IF SEGMENT IS INCORE
	JRST INTSWS		;GET SEGMENT IN
INTR11:	SKIPN JBTIIP(J)		;IS THIS JOB ALREADY AT I-LEVEL?
	JRST INTR9		;NO. - RUN THIS INTERUPT.
	SETOM INTREQ		;WE'LL HAVE TO RUN THIS INT LATER.
	JRST INTR1		;CONTINUE SCAN.

INTSCR:	ADD P,[5,,5]		;SO WE CAN LOOK AT PREV RETURN ADDRESSES
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /J NEGATIVE AT INTR2
/
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCAL
	POPACS
	SUB P,[5,,5]
	JRST INTSC1		;OVER FROM THE TOP.
;GETINT INTR8 GTINT1
;GETINT - GET FIRST SERVICABLE INTERRUPT BIT FROM WORD OF BITS.
; ENTER WITH COPY OF JBTIRQ IN AC1
; WILL RETURN SINGLE SERVICABLE BIT IN AC1

GETINT:	MOVSI AC2,INTWAIT
	TDNE AC2,JBTIEN(J)
	JRST GTINT1		;HERE IF TRYING TO FINISH UUO (VIA UWAIT)
	MOVEI AC3,0
INTR8:	JFFO AC1,.+1		;GET FIRST BIT. SERVE INTERRUPTS ONLY ONE AT A TIME.
	MOVN AC2,AC2
	MOVSI AC1,(1B0)
	LSH AC1,(AC2)		;AC1←LEFTMOST BIT IN JBTIRQ(J)
	TDNE AC1,JBTMSK(J)	;IS THIS PROCESSOR ENABLED FOR THIS INTERRUPT?
	JRST CPOPJ1		;YES.
	IORB AC1,AC3		;AC3 ACCUMLATES INTS MASKED OFF ON THIS PROC
	ANDCA AC1,JBTIRQ(J)	;AC1←ANY INTS PENDING (THAT AREN'T ALREADY MASKED)
	JUMPN AC1,INTR8		;JUMP IF SOME INTS ARE STILL PENDING.
	POPJ P,			;NONE PENDING (EXCEPT THOSE MASKED OFF)

GTINT1:	TDNN AC2,AC1		;SKIP IF INTWAIT ENABLED AND REQUESTED
	POPJ P,			;ENABLED BUT NOT REQUESTED YET
	MOVE AC1,AC2
	JRST CPOPJ1		;DO INTWAIT INT FIRST
;INTR9 INTR13 INTR14 INT14B INT14A INTR10 INTR5 INTR15 JWKCHK JWKCH0

;CLEAR THE INTERRUPT BIT IN JBTIRQ AND START THE I-PROCESS
INTR9:	MOVE AC1,JBTIRQ(J)	;GET INTERRUPT BITS AGAIN
	PUSHJ P,GETINT		;GET BIT CORRESPONDING TO INTERRUPT
	 JRST INTR1		;ALL MASKED OUT.  SCAN OTHERS.
	TDNN AC1,JBTIRQ(J)	;MAKE SURE INT IS THERE.
	JRST INTR9		;HUH?  IT DISAPPEARED.
	ANDCAM AC1,JBTIRQ(J)	;NOW WE HAVE SERVICED THIS INTERRUPT.
	TDNN AC1,JBTIEN(J)	;IS THIS GUY ENABLED FOR THIS INTERRUPT?
	JRST INTR2		;NO, FORGET IT.
;new code to avoid running user interrupt level code if possible, 8 Dec 81.
	TDNN AC1,JBTIRU(J)	;user want his i-level code run for this int?
	TLNE AC1,INTWAIT	;always run i-level for this special int bit
	JRST INTR13		;yup
;nope, just wake up user's main job if appropriate
	PUSHJ P,JWKCH0		;wake up job if appropriate for AC1's int bits
	JRST INTR2		;look for other interrupts to run

INTR13:

;THE FOLLOWING UP TO THE LABEL INTR14 IS PROBABLY UNNECESSARY.
	SKIPN JBTIIP(J)
	JRST INTR14
	IORM AC1,JBTIRQ(J)
	SETOM INTREQ
	JRST INTR2		;TRY TO GET BACK NEXT TICK

;INITIALIZE SYSTEM VARIABLES IN TO RUN THE USER I-PROCESS

INTR14:	IORM AC1,JBTIIP(J)	;HE NOW HAS THIS INTERRUPT IN PROGRESS
	AOS AMC5		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP APR MAP
;If job is in INTW and enabled for tty ints, then clear XTIME so that we
;can beep user when long process finishes, not when user finally types something
;that makes his job wait only for tty.
	MOVSI TAC,INTTTY	;see if enabled for tty interrupt
	TDNN TAC,JBTIEN(J)	;skip if enabled
	JRST INT14B		;avoid work most of time
	MOVM TAC,JOBQUE(J)	;see if in INTW
	CAIN TAC,INTWQ		;no work if not INTW queue
	PUSHJ P,STXTM2		;clear interaction run time (wholine X time)
INT14B:	HLRZ TAC,JBTPAG(J)
	LSH TAC,9		;NUMBER OF WORDS IN LOWER.
	XCTR XR,[SKIPN AC3,JOBINT] ;DOES HE WANT INTS SOMEWHERE ELSE?
	JRST INT14A		;NO
	ADDI AC3,2		;THIS MUST BE LEGAL, TOO
	CAIL AC3,JOBPFI+2
	CAIL AC3,(TAC)
	JRST INTADC		;ILLEGAL ADDRESS. (MUST BE IN LOWER)
	SKIPA AC2,AC3		;ADDRESS FOR THE BITS -2
INT14A:	MOVEI AC2,JOBCNI+2	;OR HERE
	XCTR XW,[MOVEM AC1,-2(AC2)] ;STORE INTERRUPT BITS IN USER CORE.
	JFFO AC1,.+2		;Get bit number of first interrupt bit
	AOSA NINTS1		;Count a time with no bit!
	AOS NINTS(AC1+1)	;Remember interrupts per bit
	SKIPN AC2,AC3
	MOVEI AC2,JOBAPR
	XCTR XR,[HRRZ AC2,(AC2)] ;AC2←TRAP ROUTINE ADDRESS
	CAIL AC2,JOBPFI
	CAIL AC2,(TAC)
	CAIA
	JRST INTR10		;TRAP ADDRESS IS LEGAL
	LDB AC1,PSEGN		;SEE IF ADDRESS IS IN UPPER
	JUMPE AC1,INTADC	;NO UPPER, ERROR
	HLRZ AC1,JBTPAG(AC1)
	LSH AC1,9		;UPPER'S WORD COUNT.
	CAIGE TAC,400000	;IF LOWER'S IS SMALLER THAN 400000
	MOVEI TAC,400000	;  THEN UPPER STARTS AT 400000
	ADD AC1,TAC		;AC1←FIRST NXM WORD ABOVE UPPER
	CAIL AC2,400000		;SKIP IF BELOW TOP OF UPPER.
	CAML AC2,AC1		;note that AC1 may be 1,,0
	JRST INTADC		;NOT WITHIN UPPER, ADDRESS CHECK
INTR10:	PUSH P,UUOPC(J)		;SAVE HIS UUO LEVEL PC TOO
	MOVEM J,JOB		;THIS IS OUR TEMPORARY JOB NUMBER
	CAME J,SJOB		;MIGHT ALREADY BE THERE
	PUSHJ P,U2S		;MOVE JOBJDA INTO THE SYSTEM
	SETZM APRERR		;PREVIOUS JOB MAY HAVE HAD AN ERROR
	SETZM APRPC
	SETZM APRIN1
	SETZM SCHEDF
	SETOM STIME(J)		;MARK CORE IMAGE AS ALTERED NOW.
	LDB AC1,PSEGN		;SEE IF WE MUST MARK UPPER
	JUMPE AC1,INTR5		;NONE THERE.
	MOVE AC2,JBTSTS(AC1)	;SEE IF WRITE PROTECTED
	TLNN AC2,JWP
	SETOM STIME(AC1)
INTR5:	MOVNI AC1,10
	MOVEM AC1,INTQUANT	;8 TICKS BEFORE TIMEOUT
	MOVEI AC1,INTCH7
	MOVEM AC1,INTDISP	;CLOCK INTS DISPATCH TO TIMER COUNTDOWN
	PUSHJ P,JWKCHK		;see if we should wake up this job
IFKL10,<
IFE FTMTRACT,<
	PUSHJ P,MTRJST		;SET UP USER ACCOUNT METERS
>;IFE FTMTRACT
>;IFKL10
	MOVEM P,INTSP		;SAVE THE STACK POINTERS.
				;CLKINT DOESN'T DEPEND ON ACCUMULATORS.
	MOVE AC2,JBTIIP(J)
	TLNN AC2,INTWAIT	;UWAIT? - GIVE THE UUO LEVEL ACS.
	JRST INTR4		;NOT UWAIT.
	ANDCAM AC2,JBTIEN(J)	;NO LONGER ENABLED FOR INTERRUPT-WAIT
	SKIPN AC2,AC3		;(AC3=ADDRESS TO STORE CRUD)
	MOVEI AC2,JOBTPC+1
	MOVE AC1,USRPC		;GIVE HIM HIS MOST ACCURATE PC
	XCTR XW,[MOVEM AC1,-1(AC2)]
	MOVE AC1,JBTUPC(J)	;RESTART HIM JUST AFTER THE UWAIT UUO
	TLO AC1,USRMOD		;MAKE SURE HE GETS INTO USER MODE
	MOVEM AC1,UUO0
INTR15:
IFKL10,<DATAO KLPAG,[401000,,0]	;USER GETS AC BLOCK 1
>;IFKL10
	MOVSI 17,JOBDAC
	XCTR XBLTR,[BLT 17,17]	;MOVE DUMP ACS TO PHYSICAL ACS

	MTRCOF (CH7,P2NOCK)

	JRST 12,@UUO0

JWKCHK:	MOVE AC1,JBTIIP(J)	;DO WE WAKE HIM UP?
JWKCH0:	TDNN AC1,JBTWKM(J)
	POPJ P,			;NO
	MOVM AC1,JOBQUE(J)	;SEE IF HE IS WAITING FOR AN INTERRUPT
	CAIE AC1,INTWQ
	POPJ P,			;no
	MOVNI AC1,TQ		;YES, WAKE HIM UP WITH HIGH PRIORITY
	MOVEM AC1,JOBQUE(J)
	JRST REQUE
;INTR4 INTR4A INTNKL
;INTR4 - REGULAR I-PROCESS STARTUP (NOT AFTER UWAIT)

INTR4:	MOVSI AC1,JOBAC		;SAVE UUO-LEVEL ACS
	HRRI AC1,INTACS		;SINCE HE WILL DO UUO'S
	XCTR XBLTR,[BLT AC1,INTACS+17]
	MOVE AC1,USRPC		;SHOULD BE HERE BY NOW
	TLNE AC1,USRMOD
	JRST INTR4A		;PC IS IN USER MODE.
	MOVE AC1,UUOPC(J)	;USE LAST UUO-LEVEL PC.
	CAIN AC1,USRXT5		;WAS UUOCON INTERRUPTED EARLY?
	MOVE AC1,UUO0		;YES. HERE'S HIS USER LEVEL PC
	TLZN AC1,USRMOD		;FLAG IT AS COMING FROM EXEC
	TDZA AC1,AC1		;MAKE ZERO IF WE DON'T KNOW IT
	SUBI AC1,1		;ADJUST IT TO POINT AT HIS UUO
INTR4A:	SKIPE AC2,AC3		;AC3 IS NON-ZERO FOR DUAL INT. SYSTEM
	JRST .+3
	MOVEI AC2,JOBTPC+1	;PLACE TO STORE INTERRUPT PC, +1
	MOVEI AC3,JOBAPR	;PLACE TO FETCH TRAP PC.
	XCTR XR,[MOVE AC3,(AC3)] ;AC3←TRAP ADDRESS
	XCTR XW,[MOVEM AC1,-1(AC2)] ;STORE INTERRUPT PC.
	MOVE AC2,JB2PRV(J)	;GET PASSIVE PRIVS
	TLNN AC2,LUPPRV
	TLZ AC3,4000		;DON'T SET IOT USER UNLESS LOCAL
	TLO AC3,USRMOD		;AND MAKE SURE WE DO GET TO USERMODE
	TLZ AC3,37		;AVOID @ LOOPS
	MOVE 17,AC3		;get starting PC and flags into 17
	MOVE 16,J		;SET UP HIS ACS
	HLLZ 2,JBTPAG(16)
	LSH 2,9
	SUB 2,[1,,0]
	MOVE 1,SPWBUT
	SETZM 3
	MOVE 15,JBTIIP(16)
	TLNE 15,INTSWW
	SETOM 3			;SWAP/SHUFFLE WARNING
	MOVEI 4,1		;PROCESSOR NUMBER IN 4 (ALWAYS P1 NOW)
	SETZM 5			;5 TELLS IF THE OTHER PROCESSOR IS ALIVE
	MOVE 6,JBTSTS(16)	;HE WANTS HIS STATUS WORD IN 6 TOO
	LDB 7,[POINT JOBNSZ,JBTSTS(16),35] ;7←SEGMENT NUMBER
	HLRZ 7,JBTPAG(7)
	LSH 7,9
	SUBI 7,1		;7←PROTECTION OF SEGMENT
	MOVE 10,INTDTM(16)
	MOVM 14,JOBQUE(16)	;TELL HIM HIS CURRENT Q
	SETOM 5
IFKL10,<SKPKL
	JRST INTNKL
	XCTR XW,[MOVEM 17,17]	;STORE EXEC 17 IN USER'S 17
	MOVEI 17,0
	XCTR XBLTW,[BLT 17,16]	;STORE EXEC 0-16 IN USER'S 0-16
	DATAO KLPAG,[401000,,0]	;USER RUNS WITH AC BLOCK 1
INTNKL:
>;IFKL10
	MTRCOF (CH7)		;BOTH PROCESSORS HERE

	JRST 12,@17		;DISMISS TO TRAP ADDRESS.
;INTADC INTXIT

;TYPE ERROR MESSAGE FOR ILL. STARTING ADDRESS

INTADC:	SETZM JBTIIP(J)		;ADDRESS CHECK.  GET OUT OF I-LEVEL
	PUSHJ P,TTYERP		;NOW GIVE HIM A NASTY MESSAGE
	PUSHJ P,INLMES
	ASCIZ /Interrupt address out of bounds
/
	PUSHJ P,HOLD		;PRINT ↑C CRLF . CRLF.  CALL TTYSTC AND ESTOP
	JRST INTR1		;RESCAN FOR OTHER INTERRUPTS.

INTXIT:
IFKL10,<JRST 2,@[PCU,,.+1]	;KEEP PCU SET
>;IFKL10
	SETZM INTACT	;DONE. RESTORE ALL THE STUFF WE SAVED UP FRONT.
	SETZM INTDISP
	HRLI AC1,-USRJDA-20+USRPRT+1(P)
	HRRI AC1,USRPRT
	BLT AC1,USRJDA+17
	SUB P,[USRJDA+20-USRPRT,,USRJDA+20-USRPRT]
	POP P,APRIN1
	POP P,APRERR
	POP P,APRPC
	POP P,SCHEDF
	POP P,CLKS17
	POP P,@CLKCH
	POP P,@UUOLOC
	POP P,UUO0
	POP P,USRSAV
	PUSHJ P,POPMAP
	MOVE J,SJOB
	MOVEM J,JOB
	POPJ P,
;INTSWAPIN INTSWS INTSWT
; ROUTINE TO SWAP A GUY IN SO HE MAY BE INTERRUPTED  - INTSWAPIN, INTSWS

INTSWAPIN:
	MOVE AC3,J		; AC3 IS JOB TO TEST FOR BEING IN
	PUSHJ P,INTSWT		; SWAPIN TEST SUBR
	JRST INTR1		; NO CAN DO
	LDB AC3,PSEGN		; GET SEGMENT #
	JUMPE AC3,INTR1
	MOVE TAC,JBTSTS(AC3)
	TLNE TAC,SWP		; IF SWAPPED OUT,
	JRST INTR1		; NORMAL THING WILL HAPPEN
	MOVSI TAC,JHLDIN	; ELSE HOLD IT IN
	IORM TAC,JBTSTS(AC3)	; FOR LOWER
	JRST INTR1

INTSWS:	PUSHJ P,INTSWT		; AC3 JOB TO BRING IN, J LOWER
	JRST INTR1
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		; IF LOWER IS SWAPPED OUT,
	JRST INTR1		; LET NORMAL THING HAPPEN
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	; ELSE HOLD HIM IN FOR UPPER
	JRST INTR1

INTSWT:				; SEE IF HE IS MASKED OUT
	TDNN AC1,JBTMSK(J)	; ARE ANY OF THOSE BITS ON?
	POPJ P,			; APPARANTLY NOT, DON'T BOTHER TO CALL HIM IN
	SETOM INTREQ		; COME BACK NEXT TIME AROUND TOO
	MOVE AC2,JBTSTS(AC3)
	TLNN AC2,SWP		; NEED TO GET HIM IN CORE?
	POPJ P,			; NO, MUST BE SHUFFLE, JUST WAIT
	EXCH AC3,J		; GET US IN J
	MOVSI TAC,INTSNB
	PUSHJ P,SETSIN		; PUT INTO SWAP IN LIST
	EXCH AC3,J
	JRST CPOPJ1
;⊗ INTCH7 INTERQ INTHL1 INTRU0 INTERU INTER1 INTERP INTAPR INTERR INTDSM INTDB1 INTDEB

;THIS IS THE PLACE WE COME UPON CH7 BREAKS WHILE AN I-LEVEL PROCESS
;IS RUNNING.  CHECK FOR ERRORS, FOR TIMEOUT, DISMISS CH7 IF ALL IS OK.

INTCH7:	SKIPN APRERR		;CH3 ERROR?
	SKIPE SCHEDF		;OR ATTEMPT TO RESCHEDULE?
	JRST INTERU		;YES - I LEVEL ERROR
	AOSL INTQUANT		;HAS HIS QUANTUM EXPIRED?
	JRST INTERQ		;YES - ERROR
	MOVE 17,CLKS17

	MTRCOF (CH7,P2NOCK)

IFN FTXADR,<
	XJEN CLKCHL
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CLKCHL
>;IFE FTXADR

;User interrupt-level quantum expired.
INTERQ:	MOVE 17,CLKCHL		;Is current job in user mode?
	TLNE 17,USRMOD
	JRST INTERU		;Yes, print message and stop job
	MOVEI 17,INTHL1		;No, finish UUO and then come back
	MOVEM 17,INTDISP	;(unless UUO dismisses I-level)
	JRST INTXTS

;Here on next CH7 interrupt after I-level timeout during UUO.
INTHL1:	SKIPN SCHEDF		;See if UUO finished
	JRST INTXTS		;Another tick happened before UUOXIT
	MOVE 17,UUOXI
	MOVEM 17,UUOXIT		;Restore exit, now that we made it
	SETZM SCHEDF		;Now give timeout error
;Here we have a problem.  Print error message and stop job.
INTERU:	JSR @CLKESV		;SAVE THE ACS.  SETUP J, PID,
	SKIPE ESTINT		;ARE WE HERE FROM ESTOP?
	JRST INTDSM		;YES - ACT LIKE DISMISS (PHANTOM WITH ERROR)
	JSP TAC,ERRPTU		;"? ERROR IN JOB N USER I-LEVEL ...."
	ASCIZ /User Interrupt-Level /
	SKIPE APRERR
	JRST INTAPR
	SKIPE SCHEDF
	JRST INTERP		;MAY HAVE COME FROM ESTOP - CHECK JERR.
	PUSHJ P,INLMES		;MUST HAVE BEEN A TIMEOUT.
	ASCIZ /timeout/
	MOVE TAC1,@CLKCH	;GET A PC TO TYPE.
	JRST INTERR

INTERP:	PUSHJ P,INLMES
	ASCIZ /attempt to schedule, UUO/
	MOVE TAC1,UUOPC(J)
	SOJA TAC1,INTERR

INTAPR:	MOVEI TAC,[ASCIZ /CH3 error/]
	MOVE AC1,APRERR
	TRNE AC1,ILM
	MOVEI TAC,[ASCIZ /ill mem ref/]
IFE FTF2,<
	TRNE AC1,NXM
	MOVEI TAC,[ASCIZ /NXM/]
>;IFE FTF2
	TRNE AC1,POV
	MOVEI TAC,[ASCIZ /pdl ov/]
	PUSHJ P,CONMES
	MOVE TAC1,APRPC
INTERR:	PUSHJ P,PCP
	PUSHJ P,HOLD
INTDSM:	SETZM ESTINT		;ENTER HERE FOR THE DISMISS UUO
	MOVE P,INTSP		;HERE WE ARE AT THE DISMIS UUO
	MOVE J,JOB		;PICK UP ALL THE ACCUMULATORS
	MOVSI AC1,INTACS	;PUT BACK EVERYTHING. (SOURCE)
	HRRI AC1,JOBAC
	XCTR XBLTW,[BLT AC1,JOBAC+17] ;STORE INT ACS INTO USER RELATIVE 0-17
INTDB1:	CAME J,SJOB		;DON'T BOTHER IF ALREADY OK
	PUSHJ P,S2U		;MOVE JOBJDA BACK
	POP P,UUOPC(J)
	SETZM JBTIIP(J)		;GET HIM OUT OF INTERRUPT LEVEL
	JRST INTR2

INTDEB:	MOVE P,INTSP		;HERE FOR DEBREAK UUO.
	MOVE J,JOB
	MOVE AC1,UUOPC(J)	;WHERE WE WANT TO BE WHEN AT MAIN LEVEL
	MOVEM AC1,USRPC
	CAMN J,SJOB
	MOVEM AC1,-USRJDA-20+USRPC(P) ;THIS IS WHAT WILL BE PUT INTO USRPC!!
	MOVE AC1,[JOBAC,,JOBDAC]
	XCTR XBLTRW,[BLT AC1,JOBDAC+17] ;REAL ACS WILL BE UUO ACS AT TIME OF DEBREAK
	MOVM AC1,JOBQUE(J)
	CAIE AC1,IOWQ
	JRST INTDB1
	MOVNI AC2,RUNQ		;IN CASE UUO WAS IN IOWQ
	MOVEM AC2,JOBQUE(J)
	PUSHJ P,REQUE	
	JRST INTDB1
;INTKILL
;INTKILL  ROUTINE TO CLEAR A JOB'S INTERRUPT ENABLINGS AND RESET HIS MASKS

↑INTKILL:
	PUSH P,AC1
	PUSH P,AC2
	SETZM JBTIEN(J)		;CLEAR THE ENABLE BITS FIRST
	SETZM JBTIRQ(J)		;NOW CLEAR ANY PENDING INTERRUPTS
	SETZM JBTIIP(J)
	SETOM JBTWKM(J)		;INITIALIZE THE WAKE UP MASK
	SETOM JBTIRU(J)		;INITIALIZE THE I-LEVEL RUN MASK
	SETOM JBTMSK(J)		;NOW CLEAR THE PROCESSOR MASK
	PUSHJ P,APRDKL		;FLUSH CLOCK REQUESTS
	POP P,AC2
	POP P,AC1
	SETZM UUOPTR(J)		;ALSO DISABLE UUO INTERPRETER
	POPJ P,
;INIJB0 INIJB1 INIJB2 INIJOB INIJBA INIJBC INIJXC INIJXA RELJOB RELJB1 MAKPDL INIJXX
;INIJOB		ROUTINE TO INITIALIZE A JOB SLOT
;CALL AT CLOCK LEVEL OR UUO LEVEL
;	PUSHJ P,INIJOB
;	<JOB CAPACITY EXCEEDED>
;	<CANNOT GET FREE STORAGE - TRY AGAIN LATER>
;	<SUCCESS. J IS SET UP>
;	IF YOU WANT TO MAKE THIS A REAL JOB, YOU MUST CLAIM JOB
;	SLOT BY MARKING JNA OR CMWB IN JBTSTS.

;CLOBBERS TAC
;SETS UP: JBTADR,JBTPRV,JBTBTM,JBTSTS,TTIME,RTIME,JBTUFD,DSKPPN,JBTRNB,JBTPR2,
;	  JBTKCJ,J,JBTMAP

INIJB0:	MOVSI TAC,JNA!CMWB
INIJB1:	MOVEI J,1		;SEEK JOB SLOT
INIJB2:	TDNN TAC,JBTSTS(J)
	JRST CPOPJ1		;THIS ONE IS FREE.
	CAMGE J,JOBNM1		;HAVE WE REACHED MAXIMUM SLOT NUMBER?
	AOJA J,INIJB2		;NOT YET.
	MOVEI J,0		;RETURN A ZERO
	POPJ P,			;AND LOSE.

↑INIJOB:PUSHJ P,INIJB0		;SEEK A JOB SLOT
	 POPJ P,		;NONE AVAILABLE
	SKIPE JBTPAG(J)		;BUG TRAP
	PUSHJ P,INIJXX		;COMPLAIN
	PUSH P,AC3
	PUSH P,AC1
	PUSHJ P,MAKPDL		;MAKE A JOB PDL - RETURNS PDL IN AC1
	JRST INIJXA		;LOSE.  - GIVE THE NO FS. RETURN.
	MOVSI TAC,JNA!CMWB	;JOB SLOT STILL AVAILABLE?
	TDNN TAC,JBTSTS(J)
	JRST INIJBA		;YES. WE'RE WINNING.
	PUSHJ P,INIJB1		;GET A NEW JOB SLOT
	JRST INIJXC		;THERE ARE NO JOB SLOTS.
INIJBA:	EXCH AC1,JBTPDL(J)	;STORE PDL POINTER
	JUMPE AC1,INIJBC
	MOVEI AC1,1(AC1)	;MAKE A BLOCK ADDRESS
	PUSHJ P,FSGIVE		;RETURN OLD PDL
INIJBC:
IFN FTDMDP,<
	MOVE TAC,J
	IMULI TAC,DDBSIZ
	ADDI TAC,SWPDDB		;JOB'S SWAPPING DDB
	MOVE AC1,TAC
	SETZM (TAC)
	HRL TAC,TAC
	ADDI TAC,1
	BLT TAC,DDBSIZ-1(AC1)
	MOVSI TAC,DVDSK
	MOVEM TAC,DEVMOD+DDBSKW(AC1)
	DPB J,[POINT JOBNSZ,DEVJBN+DDBSKW(AC1),JOBNPS] ;PJOBN via AC1
>;IFN FTDMDP
	POP P,AC1
	POP P,AC3
	SETZM JBTPAG(J)		;JOB HAS NO CORE ASSIGNED ...
	SETZM JBTSWP(J)		;... OR ON THE DISK
	SETZM JB2SWP(J)
	SETZM TTIME(J)
	SETZB RTIME(J)
	SETZM DSKOPS(J)		;NO DISK USAGE YET
	SETZM JBTWAT(J)		;HAVEN'T WAITED FOR SYSTEM YET
	SETZM JB2WAT(J)		;DITTO
	SETZM XTIME(J)		;MAKE SURE NO-UPDATE BIT IS CLEAR IN XTIME
	SETZM NSCHOF(J)		;HASN'T BEEN SCHEDULED OFF YET
	SETZM JBTMSC(J)		;NO RANDOM BITS
	SETZM JBTDDB(J)		;NO DDB FOR WHOLINE
	MOVSI TAC,JERR
	MOVEM TAC,JBTSTS(J)	;A NICE WAY TO START: JERR.
	SETZM JBTPRV(J)		;NO ACTIVE PRIVILEGES
	SETZM JB2PRV(J)		;OR PASSIVE ONES
	SETZM JBTRNB(J)
	LSH J,1
	SETZM MTRETIME(J)
	SETZM MTRETIME+1(J)
IFN FTMTRACT,<
	SETZM MTRMTIME(J)
	SETZM MTRMTIME+1(J)
	SETZM MTRTTIME(J)	;CLEAR EBOX COUNTERS
	SETZM MTRTTIME+1(J)
	SETZM MTRXTIME(J)
	SETZM MTRXTIME+1(J)
>;IFN FTMTRACT
IFN FTMTRTIME,<
	SETZM MTRRTIME(J)
	SETZM MTRRTIME+1(J)
>;IFN FTMTRTIME
	LSH J,-1
IFN FTMTRACT,<
	SETZM MTRRNB(J)
>;IFN FTMTRACT
	SETZM JBTPR2(J)		;NO PEEK-POKE
	SETZM JBTUFD(J)		;NO UFD ADDRESS
	SETZM DSKPPN(J)		;NO DSKPPN
	SETZM JBTKCJ(J)		;NO KILO-CORE JIFFIES
	MOVE TAC,TIMDAT		;GET <DATE>,,<TIME IN SECS>
	MOVEM TAC,JBTBTM(J)	;SAVE JOB BEGINING TIME.
	MOVEM TAC,FTIME(J)	;SET TIME LAST RUN.
IFKL10,<
	SETZM JBTCSH(J)		;NO REASON WE CAN'T CACHE THIS.  NOT CACHED
>;IFKL10
	JRST CPOPJ2		;GIVES THE (DOUBLE) SKIP RETURN.

INIJXC:	SOS (P)			;NO JOBS.  RETURN +0 (CPOPJ1 BELOW)
	MOVEI AC1,1(AC1)
	PUSHJ P,FSGIVE
INIJXA:	POP P,AC1		;NO FREE STORAGE FOR JBTPDL
	POP P,AC3
	JRST CPOPJ1		;NO F.S.  RETURN +1

;HERE TO RELEASE AN ILL-GOTTEN JOB.
RELJOB:	MOVEI AC1,0
	EXCH AC1,JBTPDL(J)
	JUMPE AC1,RELJB1
	MOVEI AC1,1(AC1)
	PUSHJ P,FSGIVE
RELJB1:	SKIPE AC1,JBTMAP(J)
	PUSHJ P,GIVMAP
	SETZM JBTMAP(J)
	MOVSI TAC,JNA	
	ANDCAM TAC,JBTSTS(J)
	POPJ P,


MAKPDL:	MOVEI AC3,JBTPLN	;GET A PDL FOR THIS JOB.
	PUSHJ P,FSGET		;FROM FREE STORAGE.
	POPJ P,			;NO FREE STORAGE.
PRINTX	Here's another place LOGOUT can wedge the system waiting for FS.
;;;	System became wedged here by LOGOUT running at high priority
;;;	waiting for FS to be freed, which won't happen if no one else runs.
	HRLI AC1,1-<JBTPLN+JOBPRT-JOBPFI> ;SET LEFT SIDE TO COUNT.
	SETZM (AC1)		;ZERO FIRST LOCATION OF PDL
	MOVSI AC3,(AC1)		;SOURCE OF BLT
	HRRI AC3,1(AC1)		;DESTINATION
	BLT AC3,JBTPLN-1(AC1)	;ZERO THE ENTIRE PDL.
	SOJA AC1,CPOPJ1		;AC1 SET AS PDL POINTER. SKIP RETURN.

INIJXX:	PUSHACS			;CALLED FROM INIJOB OR ESTSG2
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JBTPAG NOT 0 AT INIJXX /
	PUSHJ P,DISJOB
	PUSHJ P,DISTAB
	MOVE TAC,JBTPAG(J)
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	DEBCHECK(POPACS)
	POPJ P,
;

SUBTTL COMCON THE COMMAND DECODER 8/4/67

COMMENT $

COMMAND is called from the clock routine when COMCNT, set by TTYSER,
is greater than 0.  All ACs are available to the command decoder. 
COMMAND calls TTYCOM to scan for a TTY which has typed a command.
Then the command is looked-up and the dispatch address and control
bits are found.  After checking that the initial conditions specified
by the control bits are satisfied, we dispatch via PUSHJ to the
command setup routine.  The initial ACs and stack are set up as
follows.

DDB/	TTY DDB address
TAC/	Byte pointer to the command string (the space or CR after the command name)
DAT/	Byte pointer to the last output character
J/	Job number of TTY typing this command or 0.
TAC1/	COMMAND BITS,,DISPATCH ADDRESS
UUO/	The full name of this command in SIXBIT
IOS/	0 (is used for subsequent dispatches)

The TTY DDB and control bits are pushed on the stack prior to
dispatching.  Thus, by referencing down the stack the command setup
routine can get at it's TTY DDB (in case it uses multiple DDBs) and
also it can affect the typeout generated by the command decoder after
returning from command setup (by changing the control bits). 

	PUSH P,DDB
	PUSH P,TAC1
	PUSHJ P,(TAC1)

On return from the command setup routine, usually a CRLF is appended
to the message (generated by the command setup routine) and the TTY
(specifed by the DDB on the stack) is started.  Several flags are
checked on return from the command setup routine (unless an error has
occurred) for standard command response.  If an error occurs, the job
number (J) should be set to 0 on return to prevent the job from being
initialized if this is the first command.  ERRMES routine will set J
to 0. 

Since the command decoder is called from the clock routine each
command setup routine must run to completion quickly, without waiting
for core assignments or I/O of any kind.  If a command function
cannot complete without waiting, it must either

	1.  delay itself (DLYCOR, DLYCM1) until conditions obtain such
	that it can complete.  In this case the command will be called
	repeatedly until it completes.

	2.  schedule a monitor job to run at UUO level and complete the
	function.

	3.  perform whatever work it can, remember it's state, and
	on subsequent calls, perform more work when possible.

$
;NOCORE NOJOBN NOLOGIN NOACT INCORE NORUN SHRINK NOSKPB NOPRIV SETMAP NOINCK NOCRLF NOPER TTYRNU TTYRNC NOMESS DOLOG TYPEGO ERRFLG RPGBIT

;TABLE OF CONSOLE COMMANDS


;"*" MARKS THOSE BITS THAT ARE CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE
;"+" MARKS THOSE BITS THAT ARE CHECKED AFTER RETURNING FROM COMMAND SETUP
;NOTE THAT SOME BITS HAVE TWO MEANINGS, BEWARE!

NOCORE←←400000		;*NO CORE NEEDED FOR COMMAND
NOJOBN←←200000		;*NO JOB NUMBER NEEDED FOR COMMAND
NOLOGIN←←100000		;*JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT←←40000		;*COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
INCORE←←20000		;*COMMAND MUST BE DELAYED IF JOB IS CURRENTLY SWAPPED OUT.
NORUN←←10000		;*↑C MUST BE TYPED BEFORE COMMAND CAN BE EXECUTED.
SHRINK←←4000		;*IF JOB IS SWAPPED OUT, SHRINK BEFORE BRINGING HIM IN!
NOSKPB←←4000		;+DON'T CALL SKPBRK
NOPRIV←←2000		;*CLEAR TEMPORARY PRIVILEGE BITS
SETMAP←←1000		;*SET APR MAP TO REFERENCE JOB TO WHICH THIS COMMAND 
				;PERTAINS, RESTORE MAP TO CURRENT JOB WHEN DONE
NOINCK←←400		;+NO CHECK FOR JOB INITIALIZATION (JNA=0)
NOCRLF←←200		;+NO PRINTING OF CRLF
NOPER←←100		;+NO PRINTING OF PERIOD
TTYRNU←←40		;+SET TTY TO USER MODE AND START JOB AFTER COMMAND
				;RESPONSE STOPS TYPING
TTYRNC←←20		;+KEEP TTY IN COMMAND MODE AND START JOB AFTER COMMAND
				;RESPONSE STOPS TYPING
NOMESS←←10		;+NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR
DOLOG←←4		;*ALLOW LOGIN FIRST
TYPEGO←←2		;+CALL TTYSTF TO START TYPEOUT BUT NOT CHANGE TPMON.
				;USED BY FORCED COMMANDS, WITH NOMESS SET ALSO.
ERRFLG←←1		;COMMAND ERROR

RPGBIT←←NOCORE!NOPER!NOCRLF!INCORE!NORUN!NOACT!TTYRNU!SHRINK!DOLOG!NOPRIV
			;BITS FOR THE RPG COMMANDS
;COMMAND.NAMES ;⊗

; THIS TABLE MUST BE IN ALPHABETICAL ORDER!!

DEFINE NAMES
<
	C @,ATCOM,RPGBIT			;A CROCK IF EVER THERE WAS ONE
	C A,ASSIGN,NOCORE!DOLOG!NOPRIV
	C ACCESS,ACCCOM,RPGBIT			;OWNER ACCESS TO ALIAS PPN
	C ADVANC,DSCCOM,RPGBIT
	C ALIAS,SDSKPPN,NOCORE!NOPRIV
	C ASSIGN,ASSIGN,NOCORE!DOLOG!NOPRIV
	C ATTACH,ATTACH,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C BACKSP,DSCCOM,RPGBIT
	C BATCH,MAICOM,RPGBIT
	C BEEP,BPCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
IFE FTF2,<
	C BOISE,SPLCOM,RPGBIT
>;IFE FTF2
	C BOOK,ETCOM,RPGBIT
IFN FTKLB,<
	C BOOT,MRDCOM,RPGBIT	;LOAD CORE WITH SPECIAL PROGRAM from monitor
>;IFN FTKLB
IFN PUPNUM,<
	C BROADCAST,BRDCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
>;IFN PUPNUM
	C C,CORE,NOCORE!NOACT!NOLOGIN!NORUN!NOJOBN!NOINCK
	C CANCEL,CMDRUN,RPGBIT			;DELETE REMINDERS
	C CCONTINUE,CONTC,TTYRNC!INCORE!NORUN
	C CD,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;CDETACH REQUIRE "CDE"
	C CDETACH,CDETACH,NOCORE!NOINCK
	C CETV,ETCOM,RPGBIT
	C CFORK,CFORK,NOINCK!NOMESS!NOPER!NOCRLF!NOCORE
	C CKMAIL,CKMCOM,RPGBIT!NOLOGIN		;MAIL CHECKER
	C CLOSE,CLSCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK ;now use QUIT to close conn
	C CLRUW,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;CLRUWP must be typed entirely
	C CLRUWP,CLRWPS,NOACT!INCORE!NOPRIV!SETMAP
	C COMPILE,RPGCOM,RPGBIT			;RPG COMMANDS
	C CONTINUE,CONT,NOPER!TTYRNU!INCORE!NORUN
	C COPY,CPYCOM,RPGBIT
	C CORE,CORE,NOCORE!NOACT!NOLOGIN!NORUN!NOINCK!NOJOBN
	C CREATE,ERPGCM,RPGBIT
	C CREF,RPGCOM,RPGBIT
	C CSTART,STARTC,TTYRNC!INCORE!NORUN!SETMAP
IFN FTSCTY,<
	C CTYSET,SETCTY,NOCORE!NOJOBN!NOLOGIN!NOINCK
>;IFN FTSCTY
	C D,DEASSIGN,NOCORE
	C DAYTIME,DAYTIM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C DCAAVG,DCACOM,NOCORE!NOLOGIN!NOINCK!NOJOBN
IFN FTRH,<
	C DCOUNT,DCOCOM,NOCORE!NOLOGIN!NOINCK!NOJOBN	;show RH disk error counts
>;IFN FTRH
	C DDT,DDTGO,NOPER!TTYRNU!INCORE!NORUN!SETMAP
	C DE,DCOM,INCORE!NOPRIV!SETMAP
	C DEASSI,DEASSIGN,NOCORE
	C DEBUG,RPGCOM,RPGBIT
IFE FTCCRMA,<	;there's no oracle at CCRMA
	C DECIDE,ORACOM,RPGBIT!NOLOGIN
>;IFE FTCCRMA
	C DELETE,CPYCOM,RPGBIT
	C DETACH,DETACH,NOCORE!NOINCK!NOPER!NOCRLF!NOMESS!NOJOBN!NOLOGIN
	C DFIND,FNDCOM,RPGBIT!NOLOGIN
	C DI,CPYCOM,RPGBIT!NOLOGIN
	C DIAL,CMDRUN,RPGBIT
	C DIRECTORY,CPYCOM,RPGBIT!NOLOGIN
	C DISABLE,DISABLE,NOCORE
	C DO,CMDRUN,RPGBIT
IFN PUPNUM,<
	C DOVER,SPLCOM,RPGBIT
>;IFN PUPNUM
	C DOWNLOAD,CMDRUN,RPGBIT		;Download string to terminal
	C DQAVG,DQACOM,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C DRD,DRDCOM,RPGBIT
	C DSKSIZ,DSKCOM,RPGBIT			;USER DISK UTILIZATION
IFN FTIP!PUPNUM,<
	C DT,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;DTN REQUIRE "DTN"
	C DTN,CMDRUN,RPGBIT			;DATAMEDIA SIMULATOR TELNET
>;IFN FTIP!PUPNUM
	C DUMP,DSCCOM,RPGBIT
	C E,ECOM,NOCRLF!INCORE!SETMAP
	C ECC,ECCCOM,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C ED,ERPGCM,RPGBIT
	C EDDT,CEDDT,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C EDIT,ERPGCM,RPGBIT			;EDIT STYLE RPG COMMANDS
	C EFIND,HLPRUN,RPGBIT!NOLOGIN
IFN PUPNUM,<
	C EFTP,HLPRUN,RPGBIT
>;IFN PUPNUM
IFN ELFNUM,<
	C ELFQFIX,ELFQFI,NOCORE!NOJOBN!NOLOGIN!NOINCK
>;IFN ELFNUM
	C ENABLE,ENABLE,NOCORE
	C EOT,DSCCOM,RPGBIT
	C EREAD,ETCOM,RPGBIT			;COMMANDS TO E
	C ESPOOL,SPLCOM,RPGBIT		;Imagen 300 dpi spooler (now called Maple)
	C ETV,ETCOM,RPGBIT
	C EVENT,MAICOM,RPGBIT
	C EXECUTE,RPGCOM,RPGBIT
	C FDIRECTORY,CPYCOM,RPGBIT!NOLOGIN
	C FI,FILCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C FILES,FILCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C FIND,HLPRUN,RPGBIT!NOLOGIN
	C FINGER,FNGCOM,RPGBIT!NOLOGIN
	C FINISH,FINIS,NOPER!NOACT!INCORE!NORUN!NOPRIV!SETMAP
IFE FTF2,<	;CCRMA doesn't have Imlacs
	C FIXIML,HLPRUN,RPGBIT!NOLOGIN
>;IFE FTF2
	C FLUSH,FLUSH,NOINCK!NOLOGIN!NOJOBN!NOCORE
	C FORK,FORK,NOINCK!NOMESS!NOPER!NOCRLF!NOCORE
	C FRAID,CMDRUN,RPGBIT
IFN FTIP,<
	C FTP,CMDRUN,RPGBIT
>;IFN FTIP
	C G,GET,NOCRLF!NOPER!TTYRNU!INCORE!NOCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C GET,GET,NOCRLF!NOPER!TTYRNU!INCORE!NOCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C GRIPE,MAICOM,RPGBIT!NOLOGIN
	C HALT,STOP,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C HELLO,HELLO,NOCORE!NOLOGIN!NOJOBN!NOINCK
	C HELP,HLPRUN,RPGBIT!NOLOGIN
	C HOST,HLPRUN,RPGBIT!NOLOGIN	;Keep HOST on Non-ARPA machines (TVR)
IFE FTF2,<	;Instead of FTNEWS so if turned off at SAIL, gets special msg
	C HOT,HOTCOM,RPGBIT			;NEWS HOT LINE
>;IFE FTF2
IFN FTF2,<
	C HOT,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;Keep abrev. the same
>;IFN FTF2
;;	C IMPRINT,SPLCOM,RPGBIT			;Imprint Canon SPOOLER
	C K,KJOB0,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KATTACH,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KILL,KILCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C KJOB,KJOB0,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KLOG,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C L,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C LATER,MAICOM,RPGBIT
IFN FTSUAI,<
	C LATHROP,SPLCOM,RPGBIT		;Lathrop spooler
>;IFN FTSUAI
	C LISP,LSPCOM,RPGBIT
IFN LPTNUM,<
	C LIST,CPYCOM,RPGBIT			;COPY COMMANDS
>;IFN LPTNUM
	C LOAD,RPGCOM,RPGBIT
	C LOCATE,DSCCOM,RPGBIT!NOLOGIN
	C LOG,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C LOGIN,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C LOGOUT,KJOB0,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C MAIL,MAICOM,RPGBIT!NOLOGIN
	C MAKE,ERPGCM,RPGBIT
	C MAPLE,SPLCOM,RPGBIT		;Maple/Imagen spooler
	C MCOPY,MCOCOM,RPGBIT		;Dart master tape copy
IFN FTF2,<
	C MREAD,MRDCOM,RPGBIT	;LOAD CORE WITH SPECIAL PROGRAM TO READ F2 MAGTAPE
>;IFN FTF2
IFN MTCNUM,<
	C MTAFIX,MTAFIX,NOCORE!NOJOBN!NOLOGIN!NOINCK
>;IFN MTCNUM
	C NAME,MAICOM,RPGBIT!NOLOGIN
	C NEO,TTYNOE,NOLOGIN!NOCORE!NOJOBN!NOINCK ;DPY HAS NO EDIT KEY (par bit on)
	C NICNAME,NICCOM,RPGBIT!NOLOGIN
IFN PUPNUM,<
	C NOBROADCAST,NBDCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
>;IFN PUPNUM
	C NODE,TTYNOE,NOLOGIN!NOCORE!NOJOBN!NOINCK ;DPY HAS NO EDIT KEY (odd parity)
	C NOE,TTYNOE,NOLOGIN!NOCORE!NOJOBN!NOINCK ;DPY HAS NO EDIT KEY (even par)
	C NOEDIT,TTYNOE,NOLOGIN!NOCORE!NOJOBN!NOINCK ;DPY HAS NO EDIT KEY (normal)
	C NOEIT,TTYNOE,NOLOGIN!NOCORE!NOJOBN!NOINCK ;DPY HAS NO EDIT KEY (even par)
IFE FTF2,<	;Instead of FTNEWS so if turned off at SAIL, gets special msg
	C NS,NSCOM,RPGBIT			;NEWS SERVICE
>;IFE FTF2
IFN FTF2,<
	C NS,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;Keep abrev. the same
>;IFN FTF2
	C OFIND,FNDCOM,RPGBIT!NOLOGIN
IFKL10,<
	C P2LOAD,P2LOAD,NOCORE!NOJOBN!NOLOGIN!NOINCK ;DOESN'T RUN JOB NOW
>;IFKL10
IFN FTIP,<
	C PANCAKE,SPLCOM,RPGBIT		;Pancake spooler
>;IFN FTIP
	C PDETACH,PDETCH,NOCORE!NOINCK!NOPER!NOCRLF!NOMESS!NOJOBN!NOLOGIN
	C PITIME,PITIME,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C PJOB,PJOBDV,NOCORE!NOLOGIN!NOJOBN!NOINCK
	C PLAN,MAICOM,RPGBIT
	C PLIST,DSCCOM,RPGBIT!NOLOGIN
IFN PUPNUM,<
;;	C PLOVER,SPLCOM,RPGBIT		;Plover spooler
>;IFN PUPNUM
	C POX,RPGCOM,RPGBIT
	C PPPN,PPPN,NOLOGIN!NOCORE!NOJOBN!NOINCK
	C PREPARE,RPGCOM,RPGBIT
IFN LPTNUM,<
	C PRINT,CPYCOM,RPGBIT
>;IFN LPTNUM
	C PRO,RPGCOM,RPGBIT
	C PROCES,RPGCOM,RPGBIT
IFE FTF2,<	;We don't need this at CCRMA
	C PROVE,CMDRUN,RPGBIT
>;IFE FTF2
	C PTTY,PTTY,NOCORE!NOJOBN!NOINCK!NOLOGIN
	C PUB,RPGCOM,RPGBIT
	C PUMPKI,PUMCOM,RPGBIT			;QUEUE PUMPKIN REQUEST
	C Q,SPLCOM,RPGBIT!NOLOGIN
	C QSPOOL,SPLCOM,RPGBIT!NOLOGIN
	C QUIT,QUITCM,NOCORE!NOJOBN!NOLOGIN!NOINCK ;close network connection
	C R,RCOM,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C RCV,HLPRUN,RPGBIT!NOLOGIN
	C READ,ETCOM,RPGBIT
	C REAP,DSCCOM,RPGBIT			;DART
	C REASSI,REASS,NOCORE!NOACT!INCORE!NORUN
	C REENTER,REENTER,TTYRNU!NOPER!INCORE!NORUN!SETMAP
	C REMIND,MAICOM,RPGBIT
	C RENAME,CPYCOM,RPGBIT
	C RER,RPGCOM,RPGBIT			;RERUN SYSTEM PROGRAM
	C RERUN,RPGCOM,RPGBIT			;RERUN USER PROGRAM
	C RESET,RESCOM,NOCORE
	C RESOURCES,FREDEV,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C RESTOR,DSCCOM,RPGBIT
	C RETRY,MAICOM,RPGBIT
	C REWIND,DSCCOM,RPGBIT			;DART
IFN PUPNUM,<
	C ROVER,SPLCOM,RPGBIT
>;IFN PUPNUM
	C RSL,CMDRUN,RPGBIT
	C RUN,RUNCOM,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C S,START,NOPER!TTYRNU!INCORE!NOACT!NORUN!SETMAP
	C SAVE,SAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NOPRIV!SETMAP
IFN FTIP,<
	C SD,SDCOM,RPGBIT
>;IFN FTIP
	C SELF,SPLCOM,RPGBIT			;Imagen spooler on own TTY
	C SEND,MAICOM,RPGBIT!NOLOGIN		;MAIL AND REMINDERS
	C SETTI,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;SETTIME must be typed entirely
	C SETTIME,SETTIM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C SETUW,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;SETUWP must be typed entirely
	C SETUWP,SETWPS,NOACT!INCORE!NOPRIV!SETMAP
IFN FTPRIQ,<
	C SLEVEL,SLEVEL,NOCORE
>;IFN FTPRIQ
	C SPOOL,SPLCOM,RPGBIT			;SPOOLER
	C SSAVE,SSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NOPRIV!SETMAP
	C START,START,NOPER!TTYRNU!INCORE!NOACT!NORUN!SETMAP
IFN FTIP,<
	C STRUDEL,SPLCOM,RPGBIT			;Apple Strudel spooler
;	C STRUDEL,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;disable Strudel 
>;IFN FTIP
IFN FTIP,<
	C SUPDUP,SDCOM,RPGBIT
>;IFN FTIP
	C SYSTAT,WHOCOM,RPGBIT!NOLOGIN
IFN FTIP,<
	C SZEGO,SPLCOM,RPGBIT		;spool to Szego (LPS 40 via Polya)
>;IFN FTIP
	C TALK,TALK,NOCORE!NOJOBN!NOLOGIN!NOMESS!NOINCK!NOCRLF!NOPER
	C TECO,ERPGCM,RPGBIT
IFN FTIP!PUPNUM,<
	C TELNET,TNCOM,RPGBIT
>;IFN FTIP!PUPNUM
	C TEST,CMDRUN,RPGBIT			;for most test programs
;	C TEST,TSTCOM,RPGBIT!NOLOGIN		;for testing mail
	C TEX,RPGCOM,RPGBIT
	C TIME,RUNTIM,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C TLIST,DSCCOM,RPGBIT
IFN FTIP!PUPNUM,<
	C TN,TNCOM,RPGBIT
>;IFN FTIP!PUPNUM
	C TRANSFER,CPYCOM,RPGBIT
	C TRY,RPGCOM,RPGBIT
	C TTY,TTYSUB,NOLOGIN!NOCORE!NOJOBN!NOINCK
	C TURKEY,DSCCOM,RPGBIT!NOLOGIN
	C TYPE,CPYCOM,RPGBIT!NOLOGIN
	C UDPUFD,UDPCOM,RPGBIT			;UDP UFD MAKER
	C UFD,UDPCOM,RPGBIT			;NEW UFD MAKER
	C UNDELE,UNDCOM,RPGBIT			;USER MODE UNDELETE
	C UNLOAD,DSCCOM,RPGBIT			;DART
	C UNPROT,UNPCOM,RPGBIT			;LAST RESORT FILE UNPROTECT
	C UNPUMP,PUMCOM,RPGBIT			;DEQUEUE PUMPKIN REQUEST
	C UNREAP,DSCCOM,RPGBIT			;DART
	C UNSPOOL,SPLCOM,RPGBIT
IFE FTF2,<;	CCRMA's David C. Luckham Memorial Conditional
	C VE,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;MAKE VERIFY REQUIRE "VER"
	C VERIFY,CMDRUN,RPGBIT
>;IFE FTF2
IFN FTF2,<
	C VERSION,HELLO,NOCORE!NOLOGIN!NOJOBN!NOINCK	;MRC always wanted this
>;IFN FTF2
	C W,WHOCOM,RPGBIT!NOLOGIN
	C WHE,WHECOM,RPGBIT!NOLOGIN
	C WHEN,HLPRUN,RPGBIT!NOLOGIN
	C WHERE,HLPRUN,RPGBIT!NOLOGIN
	C WHO,WHOCOM,RPGBIT!NOLOGIN
	C WHOIS,HLPRUN,RPGBIT!NOLOGIN
IFG XGPNUM,<
	C XGPLIST,CPYCOM,RPGBIT
>;IFG XGPNUM
	C XPART,CMDRUN,RPGBIT
IFN FTCCRMA,<
	C XSPOOL,SPLCOM,RPGBIT
>;IFN FTCCRMA
	C ZERO,CMDRUN,RPGBIT
IFKL10,<
	C 11L,COMERR,NOCORE!NOJOBN!NOINCK!NOLOGIN ;MAKE 11LOAD REQUIRE "11LO"
	C 11LOAD,KLDLOD,NOCORE!NOJOBN!NOLOGIN!NOINCK ;RELOAD KLDCP W/11LOAD
>;IFKL10
IFN FT11CLK,<
	C 11TIME,KL11TM,NOCORE!NOJOBN!NOLOGIN!NOINCK ;type real-time clock's time
>;IFN FT11CLK
>;NAMES
;XYZZY XYZZY COMTAB DISPL CTBL CCLOG DISP DSPLUZ NAM FCMTAB
BEGIN COMTBL

XYZZY←←<SIXBIT/@/>	;DON'T .FATAL THE FIRST TIME

DEFINE C(A,B,D)
<IFL <<SIXBIT/A/>-XYZZY>,<.FATAL COMMAND NAME OUT OF ORDER: A>
	<SIXBIT /A/>	;ONLY FIRST SIX CHARACTERS.
XYZZY←←<SIXBIT/A/>
>

LOSYS

↑↑COMTAB:
	XLIST
	NAMES
	LIST
↑↑DISPL←←.-COMTAB	;LENGTH OF TABLE
	REPEAT <<1⊗<=36-∃DISPL>>-DISPL>,<377777,,-1>
↑↑CTBL←←.-COMTAB	;LENGTH OF EXTENDED TABLE
↑↑CCLOG←←<=35-∃CTBL>	;LOGARITHM OF CTBL

HISYS

;GENERATE THE DISPATCH TABLE AND SPECIAL BITS

DEFINE C(A,B,D)
<	XWD D,B>

;SPECIAL HACK TO FORCE LOGIN FROM "ANY" COMMAND.
	XWD NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN,CXLOGI
↑DISP:
	XLIST
	NAMES
	LIST

↑↑DSPLUZ←←.-DISP	; INDEX OF BAD COMMAND DISPATCH
	XWD NOCORE+NOJOBN+NOLOGIN+NOINCK,NOCOM	;CATCH ANYTHING THAT'S NOT A COMMAND

DEFINE FCM(NAM,LH,RH)<
↑↑NAM←←.-FCMTAB
	LH,,RH>

↑FCMTAB:0		;TABLE OF FORCED MONITOR COMMANDS
FCM(F.WHO,NOLOGIN!NOCORE!NOJOBN!NOINCK!NOMESS!TYPEGO,FTTYW)		;(1) TTY WHO
FCM(F.TALK,RPGBIT,TLKPGM)						;(2) R TALK
FCM(F.FILE,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOMESS!TYPEGO,FILCOM)		;(3) FILES
FCM(F.DET,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOPER!NOCRLF!NOMESS,DETCH0)	;(4) DETACH
FCM(F.KILL,NOPER!NOCORE!NOLOGIN!NOJOBN!NOINCK!NOMESS!TYPEGO,FKILLC)	;(5) KILL
FCM(F.ATT,NOCORE!NOJOBN!NOLOGIN!NOINCK,FATTCH)				;(6) ATTACH
FCM(F.LOG,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN,CLOGNF)	;(7) LOGIN
FCM(F.PDET,NOCORE!NOINCK!NOPER!NOCRLF!NOMESS,PDETCH)			;(10) PDETACH
IFE FTF2,<
FCM(F.P2LO,RPGBIT!NOLOGIN,P2LODN)					;(11) P2LOAD
FCM(F.KLDC,RPGBIT!NOLOGIN,KLDLDN)					;(12) KLDCP
>;IFE FTF2
FCM(F.HELL,NOCORE!NOJOBN!NOLOGIN!NOINCK,HELLO)				;(13) HELLO
IFN FT11CLK,<
FCM(F.11TM,NOCORE!NOJOBN!NOLOGIN!NOINCK,KL11TM)				;(14) 11TIME
>;IFN FT11CLK
BEND COMTBL
PURGE NAMES		;RECLAIM SPACE FOR THE ASSMBLER
;COMMAND COM0 SCREWU NOSCRU CMDMSK

↑COMMAND:
	PUSHJ P,TTYCOM		;FIND A TTY THAT TYPED A COMMAND.
				;SETUP DDB, DAT, TAC, AND J
	 POPJ P,		;THERE WERE NO TTY'S WITH COMMANDS
	SETOM LINSV1		;MARK THAT WE SAW A COMMAND
COM0:	PUSH P,DDB		;SAVE TTY DEVICE DATA BLOCK ADDRESS
	SKIPGE IMLHAC(DDB)	;IS THIS A FORCED COMMAND?
	JRST FRCCOM		;YES, DON'T READ THE TTY
	PUSHJ P,CTEXT		;SCAN COMMAND NAME, RETURN IT IN TAC1
				;RETURN DELIMITER IN TEM.  DO NOT STEP ON TEM OR
				;STRANGE THINGS WILL HAPPEN
	CAIN TEM,"@"		;IF DELIMITER IS ATSIGN, WE RUN IT
	JUMPE TAC1,[	MOVSI TAC1,'@  ' ;FUTURE GENERATIONS WILL CURSE ME
			PUSHJ P,GETCHR	 ;FOR THIS HACK
			JRST .+1]
	CAMN TAC1,['HAL   ']	;LET ↑C THROUGH
	JRST NOSCRU
	JUMPE J,NOSCRU
	MOVE AC1,JBTSTS(J)
	TLNN AC1,JNA
	JRST NOSCRU
	TLNN AC1,JACCT		;THIS CAN'T HAPPEN EXCEPT FROM PARITY ERR ETC.
	TLNN AC1,JLOG
SCREWU:	MOVSI TAC1,'K  '	;NOT LOGGED IN - ANY COMMAND, OR AFTER ↑C FINISHES
NOSCRU:	SKIPN UUO,TAC1		;COPY COMMAND.  
	 JRST [	MOVE TAC1,[NOCORE!NOJOBN!NOLOGIN!NOINCK!NOCRLF,,CBLANK]
		JRST FRCCO1]	; NULL COMMAND

;  Open coded binary search.  As the name implies, it bisects the names table
; (whose size is a power of 2) and leaves AC1 pointing at the beginning of the
; section which contains the command.  Then it repeats the process.  After CCLOG
; iterations (log base 2 of the table length), AC1 is left pointing at the
; highest command which is less than or equal to what she typed in.

	SETZ AC1,		; MRC'S NEW OPEN CODED BINARY SEARCH
FOR CCNT←1,CCLOG
<	CAML TAC1,COMTAB+<CTBL⊗-CCNT>(AC1)
	 ADDI AC1,CTBL⊗-CCNT
>;REPEAT CCLOG
	CAMN TAC1,COMTAB(AC1)	; EXACT MATCH ALWAYS WINS, OTHERWISE BAD OR ABBREV
	 JRST COMFND

;  Command might be an abbreviation.  In this case, what we have can't be an
; abbreviation of the command we are looking at, since it is less than what she
; typed.  So we look at the next pair of commands.  We made a copy of the command
; in UUO at NOSCRU, now we change the padding bytes in UUO from 0's to 1's.  For
; the command she typed to be an unique abbreviation of the next command, the
; masked word must first be greater than the next command (else it is a bad
; command), and it must be less than the command after that (else non-unique
; abbreviation).

	ADDI AC1,1		; CONSIDER NEXT PAIR OF COMMANDS
	SKIPA AC2,[007777,,777777] ; MASK FOR A ONE CHARACTER WORD
CMDMSK:	 LSH AC2,-6		; MASK FOR A WORD ONE CHARACTER LONGER
	TDNE UUO,AC2		; DOES THIS MASK ONLY AFFECT NULL BYTES?
	 JRST CMDMSK		; NO, TRY NEXT ONE

;  We start at a mask for a one character word since a null command was checked
; for at NOSCRU.  Also, the loop only gets run through four times at most for a
; valid command, since the fifth (and last) time would be for a six character
; command which can never be an abbreviation!

	IOR UUO,AC2		; UUO ← COMMAND PADDED WITH 1'S INSTEAD OF 0'S
	CAML UUO,COMTAB(AC1)	; IS THIS COMMAND AN ABBREVIATION AT ALL?
	 CAML UUO,COMTAB+1(AC1)	; YES, IS IT AN UNIQUE ABBREVIATION?
	  MOVEI AC1,DSPLUZ	; SELECT INDEX OF LOSING COMMAND HANDLER
;	JRST COMFND

;FALLS THROUGH
;COMFND FRCCO1 COMNOL CHKNOX CHKNO CHKRUN CNCME2 CNCME4 CNCMES CNCMSG CNCME3 CNCMS2 JBCPEX FRCCOM

;DROPS IN

COMFND:	MOVE UUO,COMTAB(AC1)	;SAVE FULL COMMAND NAME
	MOVE TAC1,DISP(AC1)	;GET DISPATCH TABLE ENTRY.
FRCCO1:	PUSH P,TAC1		;SAVE RH(DISPATCH ADR.+BITS)
	MOVE AC1,JBTSTS(J)	;JOB STATUS WORD FOR THIS JOB
	TLNN AC1,JLOG		;IS JOB LOGGED IN?
	TLNE TAC1,NOLOGIN	;NO, CAN COMMAND PROCEED WITH NO LOGIN?
	JRST CHKNO		;YES
	TLNE TAC1,DOLOG		;THE REG KLUGE?
	JRST CHKNOX		;YES.  ALLOW THIS USER TO LOGIN NOW.
COMNOL:	JSP TAC,COMER		;NO, TYPE "LOGIN PLEASE"
	ASCIZ /Login please
/

CHKNOX:	LDB TAC1,PUNIT		;DON'T DO THIS KLUDGE ON POOR CTY
IFE FTF2,<
	CAIN TAC1,DIL0TT	; (NOR ON THE DIALER'S TTY)
	JRST COMNOL
>;IFE FTF2
	CAIN TAC1,TCONLN	; ESPECIALLY SINCE COMING OUT OF EDDT
	JRST COMNOL		; SOMETIMES PUTS SPURIOUS CHAR INTO TTY BUFFER
	MOVE TAC1,DISP-1	;INDEX FOR THE REG KLUDGE
	MOVEM TAC1,(P)		;STORE THE BITS ON THE STACK AGAIN
CHKNO:	JUMPN J,CHKRUN 		;JUMP IF JOB NUMBER ALREADY ASSIGNED.
	TLNE TAC1,NOJOBN	;NO, DOES THIS COMMAND NEED A JOB NUMBER?
	JRST COMGO		;NO
	PUSHJ P,INIJOB		;INITIALIZE A JOB
	 JRST JBCPEX		;NO JOBS AVAILABLE.
	 JRST [	MOVEI TAC1,DLYCM1	;WE NEED TO WAIT FOR FREE STORAGE.
		JRST COMDIS	]	;SO WE DELAY THIS COMMAND FOR A TICK.
	MOVE TAC1,(P)		;RESTORE TAC1 - CLOBBERED BY INIJOB
	SETZM DEVLOG(DDB)	;CLEAR LOGICAL NAME OF TTY
	JRST CHKCO1

CHKRUN:	TLNE AC1,RUN		;SKIP IF THE CURRENT JOB IS NOT RUNNABLE.
	TLNN TAC1,NORUN		;IS RUNNABLE.  SKIP IF COMMAND WANTS JOB STOPPED
	JRST CHKACT		;PROCEED WITH COMMAND.
	MOVM AC3,JOBQUE(J)	;IS THE JOB TRYING TO BE IN STOPQ?
	CAIE AC3,STOPQ
	JRST CNCMES		;NO - TELL HIM TO STOP FIRST.
	MOVSI AC3,RUN		;JOB IS IN STOPQ BUT RUN BIT IS SET.  CLEAR IT.
	ANDCAM AC3,JBTSTS(J)	;THIS IS A BUG FIX. - RPH
	JRST CHKACT

CNCME2:	MOVE TAC,JBTSTS(J)
	TLNE TAC,JACCT
	JRST CNCME4		;Can't type CALL, use different msg
	MOVEI TAC,CNCMSG	;ADDRESS OF ERROR MESSAGE
	JRST ERRMES		;TYPE ERROR MESSAGE AND RETURN

CNCME4:	MOVEI TAC,CNCMS2	;ADDRESS OF ERROR MESSAGE
	JRST ERRMES		;TYPE ERROR MESSAGE AND RETURN

CNCMES:	MOVE TAC,JBTSTS(J)
	TLNE TAC,JACCT
	JRST CNCME3		;Can't type CALL, use different msg
	JSP TAC,COMER	
CNCMSG:	ASCIZ /Please type ↑C first
/

CNCME3:	JSP TAC,COMER	
CNCMS2:	ASCIZ /Please type HAL<cr> first
/

JBCPEX:	JSP TAC,COMER
	ASCIZ /Job capacity exceeded
/

FRCCOM:	LDB TAC,FCMBPT		;GET FORCED COMMAND INDEX OUT OF DDB
	MOVE TAC1,FCMTAB(TAC)	;GET DISPATCH AND BITS
	SETZ UUO,		;NO NAME
	JRST FRCCO1		;REJOIN MAIN CODE
;CHKACT CHKCO2 CHKCO1 SQUASH

CHKACT:	TLNE AC1,SWP		;IS JOB ON DISK OR ON ITS WAY?
	TLNN TAC1,INCORE	;MUST JOB BE IN CORE?
	JRST CHKCO2		;NO
	TLNE TAC1,SHRINK	;SHALL WE SHRINK HIM BEFORE BRINGING HIM IN?
	PUSHJ P,SQUASH		;YES, CORE DOWN
	MOVEI TAC1,DLYCOR	;DELAY COMMAND.
	JRST COMDIS

CHKCO2:	TLNE TAC1,NOACT		;CAN COMMAND BE PERFORMED WITH ACTIVE DEVICES?
	PUSHJ P,ACTCHK		;NO, RETURN IF JOB STOPPED AND NO ACTIVE DEVICES
CHKCO1:	SKIPN JBTPAG(J)		;SKIP IF JOB IS IN CORE.
	TLNE TAC1,NOCORE	;DOES THIS COMMAND NEED CORE?
	JRST COMGO		;JOB INCORE OR INCORE ISN'T NECESSARY.
	JSP TAC,COMER		;NO, PRINT "NO CORE ASSIGNED"
	ASCIZ /No core assigned
/

SQUASH:	PUSHJ P,INTKILL		;KILL INTERRUPTS BEFORE SHRINK.
	SKIPE JBTPAG(J)		;IS THERE CORE ASSIGNED TO THIS JOB?
	POPJ P,			;YES. DON'T SHRINK IT WHILE THERE'S CORE ASSIGNED.
	MOVEI TAC,1		;SHRINK BEFORE SWAPIN.
	PUSHJ P,CORE0K		;SET IMGIN TO 1 PAGE BEFORE BRINGING HIM IN.
	 JFCL			;CORE0K ALWAYS SKIPS.
	POPJ P,
;COMER COMGO COMDIS COMDIP COMRET COMRNF COMRIP COMRE1 COMRT1 PCRLF PCRLF1 COMR2A SKPBRK SKPBR2 SKPBR1 SKPBR3 COMRT2 COMR2B COMR2F

;DISPATCH TO AND RETURN FROM COMMAND SETUP

COMER:	MOVSI TAC1,NOINCK	;SET ERROR CONDITIONS
	MOVEM TAC1,(P)
	MOVEI TAC1,ERRMES	;CALL ERROR MESSAGE ROUTINE
COMGO:	MOVSI IOS,NOSKPB	;CLEAR BIT THAT'S SHARED WITH PRE-DISPATCH
	ANDCAM IOS,(P)
	TLZ AC1,CMWB		;FLUSH CMWB FROM JBTSTS
	MOVEM AC1,JBTSTS(J)
COMDIS:	TLNE TAC1,NOPRIV	;NEED TO CLEAR TEMPORARY PRIVILEGES?
	PUSHJ P,CLRTP0		;YES, DO IT (clear some or all active privs)
IFN FTMONCIP,<
	MOVE IOS,(P)		;GET REAL BITS
	SKIPN FRCFLG		;NO SKPBRK TO WORRY ABOUT FOR FORCED CMD
	TLNN IOS,TTYRNU
	JRST COMDIP
	SKIPLE MONCIP(DDB)	;DON'T AVOID SKPBRK UNLESS LINE EDITOR IS WAITING
	HRROS MONCIP(DDB)	;FLAG THAT WE'RE RUNNING USER, AVOID SKPBRK
COMDIP:
>;IFN FTMONCIP

	MOVEI IOS,0		;CLEAR IOS FOR SETTING DISPATCH ADDRESSES
	TLNN TAC1,SETMAP	;NEED TO REFERENCE USER CORE?
	JRST .+3
	AOS AMC6		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;YES.
IFE FTCMDBUG,<
	AOS NCOMS
>

IFN FTCMDBUG,<
	PUSH P,AC1
	AOS AC1,NCOMS
	ANDI AC1,NLCOMS-1	;REMEMBER LAST 8 COMMANDS
	MOVEM TAC1,LCOMS(AC1)	;REMEMBER DISPATCH ADDRESS AND BITS
	MOVEM DDB,LDDBS(AC1)	;REMEMBER TTY DDB TOO
	PUSH P,UPTIME
	POP P,LTIMS(AC1)	;REMEMBER UPTIME AT TIME OF COMMAND EXECUTION
	POP P,AC1
>

;ABSOLUTELY EVERY COMMAND KNOWS THE STACK ENVIRONMENT IS PRECISELY:
;-3(P) THE RETURN TO CLOCK LEVEL PROCESSING,
;-2(P) THE TTY DDB,
;-1(P) THE COMMAND DISPATCH AND BITS
; 0(P) THE RETURN TO COMRET

	PUSHJ P,(TAC1)		;DISPATCH TO COMMAND SETUP ROUTINE.
COMRET:	POP P,AC2		;RESTORE COMMAND FLAGS
	POP P,DDB		;RESTORE TTY DDB ADDRESS.
	SKIPN FRCFLG
	JRST COMRNF		;NOT A FORCED COMMAND
	TLO AC2,NOSKPB!NOCRLF	;NEVER READ THE TTY IF FORCED, ALSO NO EXTRA CRLF
	PUSHJ P,FRCUSR		;MAKE USRB AGREE WITH TPMON
	 TLO AC2,NOPER		;NO DOT IF IN USER MODE
COMRNF:
IFN FTMONCIP,<
	HRRZS MONCIP(DDB)
	TLNN AC2,NOSKPB		;IF NO SKPBRK WANTED, DON'T MAKE IT HAPPEN LATER
	TLNN AC2,TTYRNU
	JRST COMRIP
	SKIPLE MONCIP(DDB)
	HRROS MONCIP(DDB)	;FLAG THAT WE'RE RUNNING USER, AVOID SKPBRK
COMRIP:
>;IFN FTMONCIP
	PUSHJ P,STLNAC		;SET UP LINE=TAC1
	TLNE TAC1,TLKRNG	;TALKING?
	TLO AC2,NOPER		;YES, NO DOT
	TLNN AC2,NOSKPB		;REQUESTED TO SKIP TO BREAK CHARACTER?
	PUSHJ P,COMR2A		;YES.
	PUSHJ P,COMR2B		;DECREMENT COMCNT
	TLNN AC2,NOACT		;DID WE STOP SPACEWAR?
	JRST COMRE1		;NO.
	MOVSI AC1,SPWSUS!SPWST1!SPWST2	;PREPARE TO RESTART IT
	ANDCAM AC1,JBTST2(J)	;ZERO OUT THE SUSPENSION BIT
COMRE1:	JUMPN J,COMRT1		;DID AN ERROR OCCUR?
	TLNN AC2,NOJOBN		;I.E., J=0 AND NOJOBN=0?
	MOVSI AC2,NOINCK!ERRFLG	;YES, PRINT ERROR MESSAGE ONLY.
COMRT1:	MOVE AC1,JBTSTS(J)	;JOB STATUS WORD
	TLNN AC2,NOINCK		;SUPPRESS JOB INIT. CHECK?
	TLOE AC1,JNA		;NO, IS JOB INIT BIT ALREADY SET?
	JRST PCRLF		;YES.
	MOVSI AC1,JNA		;NO, SET IT THIS COMMAND
	IORM AC1,JBTSTS(J)
	PUSHJ P,TTYATI		;ATTACH TTY TO JOB
	 JFCL			;IGNORE IF CAN NOT(SHOULD NEVER HAPPEN)
	PUSHJ P,PRJOB		;TYPE JOB # & CONFIG LINE
PCRLF:	TLNE AC2,ERRFLG		;DID AN ERROR OCCUR?
	PUSHJ P,PRQM		;YES. APPEND ?
	TLNN AC2,NOCRLF		;SUPRESS CRLF?
	PUSHJ P,CRLF		;NO
	TLNN AC2,NOPER		;SUPRESS PRINTING PERIOD?
	PUSHJ P,PRPER		;NO
	JUMPE J,PCRLF1		;JOB DOES NOT RUN IF ERROR OR NO JOB NUMBER ASSIGNED.
	TLNE AC2,TTYRNU		;JOB TO RUN WHEN TTY FINISHED TYPING?
				;COMMAND RESPONSE (TTY TO USER MODE)?
	PUSHJ P,TTYUSR		;YES, CALL SCANNER ROUTINE
	TLNE AC2,TTYRNC		;NO, JOB TO RUN AND REMAIN IN MONITOR MODE?
	PUSHJ P,SETRUN		;YES, CALL SCANNER ROUTINE	;MCF(JS)
PCRLF1:	TLNN AC2,NOMESS		;IS THERE A MESSAGE?
	JRST TTYSTR		;YES, START TTY TYPING IT OUT
	TLNE AC2,TYPEGO		;START TTY BUT WITHOUT DIDDLING TPMON?
	JRST TTYSTF		;YES (FOR FORCED COMMAND WHICH DOESN'T CHANGE STATE)
	POPJ P,			;NOTE NOMESS MUST BE SET ALONG WITH TYPEGO

↑COMR2A:LDB TEM,TITAKR(DDB)	;GET BREAK CHARACTER
	ANDI TEM,177
	MOVEI DAT,TTIBUF(DDB)	;IN CASE SOMEONE CLOBBERED IT.
SKPBRK:
IFN FTMONCIP,<
	SKIPGE MONCIP(DDB)	;ARE WE RUNNING USER PROGRAM?
	POPJ P,			;YES, DON'T READ REST OF COMMAND YET
	SETZM MONCIP(DDB)	;OTHERWISE, ALLOW TTY INPUT AND SKIP TO BRK CHAR
>;IFN FTMONCIP
	PUSH P,TAC
	PUSH P,TAC1		;GRUMBLE
	PUSHJ P,STLNAC		;SET UP AC "LINE" (I.E., TAC1) WITH CHARACTERISTICS
SKPBR2:	PUSHJ P,SPCHEK
	 JRST SKPBR1
	TLNE TAC,BREAKB		;IS THIS CHAR THE BREAK?
	JRST SKPBR3		;YES, RESTORE ACS AND RETURN
SKPBR1:	PUSHJ P,GETLCCHR	;GET A CHARACTER FROM COMMAND LINE
	JUMPN TEM,SKPBR2	;LOOK FURTHER FOR BREAK CHAR
SKPBR3:	POP P,TAC1		;UNLESS NO MORE CHARS
	JRST TPOPJ

;CALLED FROM COMMAND RETURN AND FROM DETACH (CDET,FORK,CFORK) COMMAND
COMRT2:	SKIPN FRCFLG		;FORCED COMMAND HADN'T OUGHTA READ TTY
	PUSHJ P,COMR2A		;SKIP TO BREAK CHAR
COMR2B:	SKIPE FRCFLG		;IS THIS A FORCED COMMAND?
	JRST COMR2F		;YES, DIFFERENT STUFF TO DO
	MOVSI AC1,COMBIT
	LDB TAC,PUNIT
	OFFSCN			;TURN OFF SCANNER CHANNEL
	SKIPGE TTYTAB(TAC)
	SOS COMCNT
	ANDCAM AC1,TTYTAB(TAC)
	JRST SCNONJ		;TURN ON SCANNER CHANNEL

COMR2F:	OFFSCN
	LDB TAC,FC2BPT
	JUMPE TAC,SCNONJ	;DON'T CLEAR IT TWICE
	MOVEI TAC,0		;FINISHING A FORCED COMMAND
	DPB TAC,FC2BPT		;CLEAR BOTH THE COMMAND INDEX AND THE BIT
	SOS COMCNT
	JRST SCNONJ
;⊗ CEDDT KLDLOD P2LOAD KLDLO2 KLDLO3 P2LOA2 KLDLDN P2LODN NBDCOM BRDCOM BRDOK BPCOM BPCMOK BPCOML BPCOM2 DQACOM DCACOM DCOCOM DCOCLP DCOULP DCOUL2 DCOUL3 DCOUL4 DCOUL5 DCODLP DCODL2 DCOTAB ECCCOM ECCCO2 ECCCOL ECCDUN ECCLUZ ECCOUT ECCOUL ECCOU2 SLEVEL TYPSL ELFQFI ELFQFL ELFQOK ELFQO2 ELFQLZ MTAFIX MTAFXL MTAFOK MTAOK MTAFLZ SETCTY SETCT2 SETCT3

;CEDDT - ENTER EXEC DDT (EDDT)

CEDDT:	PUSHJ P,STLNAC		;SET UP LINE(TAC1)
	TLNN TAC1,CTYLIN	;IS HE ON THE CTY?
	JRST COMERR		;NO, FLUSH HIM
IFN FTSUAI,<
	MOVE TAC,TIMDAT		;prevent ringing of the bell by faking a very
	MOVEM TAC,LASTDISASTER	; recent disaster.  (DDTCAL records real disaster)
>;IFN FTSUAI
	JRST DDTCAL		;YES, GET EXEC DDT

IFKL10,<
KLDLOD:	MOVE TAC,[F.KLDC,,['11LOAD'↔'  1  2'↔<REAPRV!DEVPRV,,0>↔0]]
	MOVE TAC1,JB2PRV(J)	;Passive privs
	TLNE TAC1,DEVPRV	;DEV priv enables you to use 11LOAD cmd
	JRST KLDLO3		;OK
	JRST KLDLO2		;Let it thru if on CTY

P2LOAD:	MOVE TAC,[F.P2LO,,['P2LOAD'↔'  1  2'↔<REAPRV!ACWPRV,,0>↔0]]
KLDLO2:	PUSHJ P,STLNAC		;SET UP LINE(TAC1)
	TLNN TAC1,CTYLIN	;IS HE ON THE CTY?
	JRST COMERR		;NO, FLUSH HIM
KLDLO3:	CAIE TEM,";"		;IF IT LOOKS LIKE A FILENAME OR SWITCHES ARE COMING,
	SKIPE MAINTM		; OR IF PHANTOMS AREN'T AVAILABLE,
	JRST P2LOA2		; THEN FORCE A CMD TO RUN JOB ON CTY
	PUSHJ P,FIREUP
	 CAIA			;NO FIREUP SLOTS
	POPJ P,
P2LOA2:	MOVSI TEM,NOCRLF!NOPER
	IORM TEM,-1(P)		;SUPPRESS CRLF AND PERIOD SINCE FORCING ANOTHER CMD
	HLRZ TAC,TAC		;FORCE CMD TO RUN PROGRAM TO LOAD P2 OR THE 11
	JRST FORCEC

KLDLDN:	PUSHJ P,HELP1		;GET A JOB
	 JFCL			;DOESN'T MATTER IF ALREADY LOGGED IN
	PUSH P,['11LOAD']
	MOVSI TAC,REAPRV!DEVPRV	;REA FOR READING PROTECTED DMP FILE
	JRST NSCOM3

P2LODN:	PUSHJ P,HELP1		;GET A JOB
	 JFCL			;DOESN'T MATTER IF ALREADY LOGGED IN
	PUSH P,['P2LOAD']
	MOVSI TAC,ACWPRV!REAPRV!DEVPRV ;REA FOR READING PROTECTED DMP FILE
	JRST NSCOM3		;DEV FOR MARKING P2 MEM UP OR DOWN
>;IFKL10

IFN PUPNUM,<
NBDCOM:	TDZA AC2,AC2		;Zero mean nope
BRDCOM:	MOVEI AC2,1		;One means OK to broadcast
	MOVE TAC1,JB2PRV(J)	;Let wizards through
	TLNE TAC1,DEVPRV
	JRST BRDOK
	PUSHJ P,STLNAC
	TLNN TAC1,CTYLIN	;ON CTY?
	JRST COMERR		;NO, FLUSH
BRDOK:	PUSHJ P,STPBRD		;Queue request to 11, flag is in AC2
	 JRST DLYCM1		;No FS, delay command and try again
	POPJ P,
>;IFN PUPNUM

BPCOM:	MOVE TAC1,PRJPRG(J)	;LET [1,2] BEEP TOO
	CAMN TAC1,['  1  2']
	JRST BPCMOK
	PUSHJ P,STLNAC
	TLNN TAC1,CTYLIN	;ON CTY?
	JRST COMERR		;NO, FLUSH
BPCMOK:	PUSHACS
	MOVEI TAC,TTPLEN-1	;BEEP ALL TTYS
	PUSH P,TAC
BPCOML:	HRRZ TAC1,LINBIT(TAC)	;SEE IF ON DCA
	JUMPE TAC1,BPCOM2	;JUMP IF NOT, SO OK TO BEEP
	SKIPGE DCATAB-400000(TAC1)	;ON DCA, SKIP IF DTR IS OFF (FLAGGED DOWN)
BPCOM2:	PUSHJ P,BEEPHY		;BEEP PHYSICAL TTY
	SOSL TAC,(P)
	JRST BPCOML
	SUB P,[1,,1]		;FLUSH LINE COUNTER
	POPACS
	POPJ P,

;COMMAND TO TYPE OUT DISK QUEUE AVERAGE.
;Dsk queue size = 2	Recent avg = 22.12	Long-term avg = 11.12
DQACOM:	PUSHJ P,INLMES
	 ASCIZ/Disk queue size = /
	MOVE TAC,DQCNT
	PUSHJ P,RADX10		;Print current size
	PUSHJ P,INLMES
	 ASCIZ/	Recent avg = /	;Starts with a tab
	MOVE TAC,DQAVG		;Get current disk queue average
	PUSH P,TAC		;Save copy of remainder in case it changes
	LSH TAC,-LDSHF-LDPWR	;Get integer part of avg for one tick
	PUSHJ P,RADX10		;Type integer part
	MOVEI TEM,"."
	XCT TYO			;Type decimal point
	POP P,TAC
	AND TAC,[1⊗(LDPWR+LDSHF)-1] ;Just remainder
	IMULI TAC,=100
	LSH TAC,-LDSHF-LDPWR	;Get remainder as hundredths
	PUSHJ P,PRTIM2		;Print 2-digit number with leading 0 if needed
	PUSHJ P,INLMES
	 ASCIZ/	Long-term avg = / ;Starts with a tab
	MOVEI TAC,=100		;Long-term total * 100
	IMUL TAC,DQTOT		;Figure avg to hundredths
	IDIV TAC,NDQTOT		;TAC ← AVG * 100
	IDIVI TAC,=100		;Integer part in TAC, fraction in TAC1
	PUSH P,TAC1
	PUSHJ P,RADX10		;Print integer part of avg in decimal
	MOVEI TEM,"."
	XCT TYO			;Print decimal point
	POP P,TAC		;Fractional part of avg
	PUSHJ P,PRTIM2		;Print in 2 digits
	JRST CRLF		;Print crlf

;Command to type out DCA interrupt rate average.
;Recent DCA int avg (ints/sec) = 22    Long-term avg = 11
DCACOM:	PUSHJ P,INLMES
	 ASCIZ $Recent DCA int avg (ints/sec) = $
	MOVE TAC,DCAAVG		;Get current DCA interrupt rate average
	LSH TAC,-LDSHF		;Gotta do some shifting over before the multiply
	IMULI TAC,JIFSEC*=10	;Convert from ints/tick to ints/sec * 10
	LSH TAC,-LDPWR		;Get integer part of avg for one tick
	IDIVI TAC,=10
	PUSH P,TAC1		;Save fraction
	PUSHJ P,RADX10		;Type integer part
	MOVEI TEM,"."
	XCT TYO
	POP P,TAC
	PUSHJ P,RADX10		;Print tenths
	PUSHJ P,INLMES
	 ASCIZ /    Long-term avg = /
	MOVEI TAC,JIFSEC	;Convert from ints/tick to ints/sec
	IMUL TAC,NDCAIN		;Total number of ints * 60
	IDIV TAC,NDQTOT		;TAC ← AVG * 60
	PUSHJ P,RADX10		;Print integer part of avg in decimal
	JRST CRLF		;Print crlf

IFN FTRH,<
EXTERN MAXRH	;In PHYPAR

;Command to type out error counts for all RH UDBs.
;Chan 0, Unit 0: SRE 0, SWE 0, HRE 0, HWE 0, SPE 7, HPE 10
DCOCOM:	MOVE AC1,[-CHNN,,CHNTAB] ;outer loop, go through all channels
DCOCLP:	HRRZ AC2,(AC1)		;get CDB addr
	JUMPE AC2,DCOUL4	;jump if no CDB
	MOVEI AC2,CDBUDB(AC2)	;address of UDB table for this channel
	HRLI AC2,-MAXRH		;max nbr of UDBs per CDB
DCOULP:	SKIPN SAVDDB(DDB)	;skip if delayed cmd
	JRST DCOUL2		;not delayed cmd
	CAMN AC2,SAVDDB(DDB)	;is this where we left off?
	SETZM SAVDDB(DDB)	;yes, will resume printing now
	JRST DCOUL3		;no, keep scanning for last UDB we did

DCOUL2:	HRRZ DSER,(AC2)		;get address of UDB, if any
	JUMPE DSER,DCOUL3	;jump if no UDB here
	MOVE TAC,[US.DSK]	;disk bit
	TDNE TAC,UDBSTS(DSER)	;is this UDB for a disk?
	JRST DCOUL5		;yes, print its counts and then delay command
DCOUL3:	AOBJN AC2,DCOULP	;look for next UDB within CDB
DCOUL4:	AOBJN AC1,DCOCLP	;look for next CDB
	SETZM SAVDDB(DDB)	;make sure this is zero on completion of cmd
	POPJ P,

DCOUL5:	MOVEM AC2,SAVDDB(DDB)	;remember how far we got
	PUSHJ P,INLMES
	 ASCIZ/Chan /
	MOVEI TAC,-CHNTAB(AC1)	;channel number
	PUSHJ P,OCTPNT		;print chan in octal
	PUSHJ P,INLMES
	 ASCIZ/, Unit /
	MOVEI TAC,(AC2)		;address of UDB ptr within CDB
	MOVE AC1,(AC1)		;get CDB again
	SUBI TAC,CDBUDB(AC1)	;unit number within channel table
	PUSHJ P,OCTPNT		;print unit in octal
	MOVEI AC2,0		;pointer into printout table
DCODLP:	MOVS AC1,DCOTAB(AC2)	;get offset to count cell
	ADDI AC1,(DSER)		;make ptr to count cell in UDB
	SKIPN TAC,(AC1)		;get count
	JRST DCODL2		;nothing counted yet
	MOVEI TEM,","		;print comma between counts
	TLON DSER,1		;first nonzero count?
	MOVEI TEM,":"		;yes, print colon before first count
	XCT TYO
	MOVEI TEM," "
	XCT TYO
	HRLZ TAC1,DCOTAB(AC2)	;get name of count
	PUSHJ P,PRNAME		;print sixbit name
	MOVEI TEM," "
	XCT TYO
	MOVE TAC,(AC1)		;get count again
	PUSHJ P,RADX10		;print in decimal
DCODL2:	SKIPLE DCOTAB+1(AC2)	;end of table?
	AOJA AC2,DCODLP		;loop through table of offsets
	PUSHJ P,CRLF
	JRST DLYCM2		;delay command until output buffer emtpy

;Table defining which error counts are typed out by DCOUNT command.
;Chan 0, Unit 0: SRE 1, SWE 2, HRE 3, HWE 4, SPE 7, HPE 10, ACT 5, VCT 1, ECT 1
DEFINE XX $(NAM)<UDB$NAM↑,,'NAM'> ;left half is offset, right half is sixbit to type
DCOTAB:	XX(SRE)
	XX(SWE)
	XX(HRE)
	XX(HWE)
	XX(SPE)
	XX(HPE)
	XX(ACT)
	XX(VCT)
	XX(ECT)
	0		;end of table (and patch spaces)
	0
	0
	0		;must end with zero (or negative number)
>;IFN FTRH

;COMMAND TO SUPPRESS ECC TYPEOUT FOR GIVEN DISK TRACK
;IF NO TRACK GIVEN, TYPES DATA
ECCCOM:	MOVE AC1,JB2PRV(J)	;GET JOB PRIVILEGES (PASSIVE)
	TLNE AC1,DEVPRV		;HAS HE THIS PRIV?
	JUMPN J,ECCCO2		;YES
	PUSHJ P,STLNAC
	TLNN TAC1,CTYLIN	;ALSO LEGAL FROM CTY
	JRST COMERR
ECCCO2:	PUSHJ P,OCTINS		;CONVERT POSSIBLE OCTAL NO ARG.
	 JRST ECCOUT		;NO ARGUMENT.  TYPE OUT DATA
	 JRST COMERA		;ILLEGAL CHARACTER.
	CAILE TAC1,LSTBIT	;LEGAL TRACK NUMBER?
	JRST COMERA		;NOPE
	MOVE AC1,[-LECCQU,,ECCQUI] ;AOBJN PTR TO TABLE (FOR SYSTEM FILE STRUCTURE)
	MOVEI AC3,0		;HAVEN'T FOUND HOLE IN TABLE YET
ECCCOL:	SKIPN AC2,(AC1)
	MOVEI AC3,(AC1)		;REMEMBER UNUSED SLOT IN TABLE
	CAIN TAC1,(AC2)		;THIS TRACK ALREADY IN TABLE
	JRST ECCDUN
	AOBJN AC1,ECCCOL
	JUMPE AC3,ECCLUZ
	MOVEM TAC1,(AC3)	;PLACE INTO TABLE
ECCDUN:	CAIN TEM,","
	JRST ECCCO2		;LOOP FOR NEXT TRACK NUMBER
	POPJ P,

ECCLUZ:	PUSHJ P,INLMES
	ASCIZ/Table full
/
	POPJ P,

ECCOUT:	MOVE AC1,[-LECCQU,,ECCQUI]
ECCOUL:	SKIPN TAC,(AC1)		;GET ENTRY IN ECC QUIET TABLE
	JRST ECCOU2
	PUSHJ P,OCTPNT
	PUSHJ P,TYCRLF
ECCOU2:	AOBJN AC1,ECCOUL
	POPJ P,

;SLEVEL -  SERVICE LEVEL COMMAND PRINT CURRENT SERVICE LEVEL

MAXLEV ←← =80		;NOBODY CAN HAVE MORE THAN 80% OF THE MACHINE

IFN FTPRIQ,<
SLEVEL:
TYPSL:
	PUSHJ P,SPRSSL		;MAKE SURE CURRENT SERVICE LEVEL IS SPREAD
				;SPRSSL IS IN UUOCON
	HRRZ TAC,JBTGSL(J)
	IMULI TAC,=100
	ADDI TAC,400000		; TRY TO CORRECT FOR ROUNDOFF ERROR
	HLRZS TAC
	PUSHJ P,RADX10
	JSP TAC,CONMES
	ASCIZ /% SL
/
>;IFN FTPRIQ

IFN ELFNUM,<
ELFQFI:	MOVEI AC2,ELFDDB	;Make sure no one has the ELF inited
ELFQFL:	MOVE AC1,DEVMOD(AC2)
	TRNE AC1,ASSPRG		;Assigned by program?
	JRST ELFQLZ		;Yes, can't fix ELFREQ, say why
	HLRZ AC2,DEVSER(AC2)	;Next DDB in chain
	JUMPE AC2,ELFQOK	;If no more DDBs, OK to fix now
	HRRZ AC1,DEVSER(AC2)	;Get dispatch table pointer for this device
	CAIN AC1,ELFDSP		;Skip if device isn't ELF, OK to fix now
	JRST ELFQFL
ELFQOK:	SKIPGE ELFREQ		;Skip if interlock is screwed up
	JRST ELFQO2
	SETOM ELFREQ		;Fix request count
	SETZM ELFAVA		;And clear just-gone-available flag
	JSP TAC,CONMES
	 ASCIZ/Clearing jammed ELF interlock./

ELFQO2:	JSP TAC,ERRMES
	 ASCIZ/ELF interlock wasn't jammed!/

ELFQLZ:	JSP TAC,ERRMES
	 ASCIZ/Sorry, someone has the ELF currently INITed./
>;IFN ELFNUM

IFN MTCNUM,<
MTAFIX:	SKIPGE AC2,MTREQ	;Skip if interlock is screwed up (or in use)
	AOJE AC2,MTAOK		;jump unless count is too negative!
	MOVEI AC2,MTCDDB	;Make sure no one has the MTA inited
MTAFXL:	MOVE AC1,DEVMOD(AC2)
	TRNE AC1,ASSPRG		;Assigned by program?
	JRST MTAFLZ		;Yes, can't fix MTREQ, say why
	HLRZ AC2,DEVSER(AC2)	;Next DDB in chain
	JUMPE AC2,MTAFOK	;If no more DDBs, OK to fix now
	HRRZ AC1,DEVSER(AC2)	;Get dispatch table pointer for this device
	CAIN AC1,MTCDSP		;Skip if device isn't MTA, OK to fix now
	JRST MTAFXL
MTAFOK:	SETOM MTREQ		;Fix request count
	SETZM MTAVAL		;And clear just-gone-available flag
	JSP TAC,CONMES
	 ASCIZ/Clearing jammed MTA interlock./

MTAOK:	JSP TAC,ERRMES
	 ASCIZ/MTA interlock wasn't jammed!/

MTAFLZ:	JSP TAC,ERRMES
	 ASCIZ/Sorry, someone has an MTAn currently INITed./
>;IFN MTCNUM

IFN FTSCTY,<
SETCTY:	PUSHJ P,STLNAC		;Get line bits
	MOVE AC1,JB2PRV(J)	;Maybe is privileged user
	TLNN AC1,DEVPRV		;OK if priv'd
	TLNE TAC1,CTYLIN	;Is this the CTY (either real or scanner)?
	JRST SETCT2		;OK
	JRST COMERA

SETCT2:	MOVNI TAC1,1		;Assume restoring normal CTY, indicated by -1
	CAIN TEM,175		;End with altmode to reset to normal CTY
	JRST SETCT3		;Back to normal
	PUSHJ P,OCTIN		;GET OCTAL ARG (PORT NUMBER)
	 JRST NOTENF		;NO ARGUMENT
	 JRST COMERA		;ILLEGAL CHARACTER.
IFE FTF2,<
	CAIGE TAC1,DCADP0	;Better not be DD/III line!
	CAIL TAC1,DCANUM	;Reasonable port number?
	JRST COMERA		;Nope
>;IFE FTF2
IFN FTF2,<
	CAIGE TAC1,DCANUM	;Reasonable port number?
	SKIPGE TAC1
	JRST COMERA		;Nope
	HLL TAC1,LINTAB(TAC1)	;Get type of TTY
	TLNE TAC1,DMLIN!DDDLIN!DISLIN!PTYLIN	;Is it something bad?
	JRST COMERA		;Yes, this also makes sure they say TTY NO DM
>;IFN FTF2
SETCT3:	HRREM TAC1,SCNCTY	;Oh, boy, here goes!!  Set new CTY port number!
	POPJ P,
>;IFN FTSCTY
;NOTLOG PTTY PTTY1 PTTYDT CLSCOM

;TYPE THE LOGICAL NAME OF THE TTY THE USER IS ON.
;"PTTY N", AS ABOVE FOR JOB N.

↑NOTLOG:JSP TAC,ERRMES
	ASCIZ /No such job
/

PTTY:	MOVEI AC2,(DDB)		;NEED DDB OF TTY IN AC2
	PUSHJ P,DECIN		;LOOK FOR JOB NUMBER ARGUMENT.
	 JRST PTTY1		;NONE. USE THIS TTY.
	 JRST COMERA
	JUMPE TAC1,NOTLOG
	CAIL TAC1,JOBN		;LEGAL?
	JRST NOTLOG		;NONE SUCH JOB
	MOVE TAC,JBTSTS(TAC1)
	TLNN TAC,JNA		;DOES HE HAVE A JOB NUMBER?
	JRST NOTLOG		;NO, LOSE
	MOVE AC1,JBTLIN(TAC1)	;LINE NUMBER
	CAMN AC1,[-1]		;DETACHED?
	JRST PTTYDT		;YES
	HRRZ AC2,TTYTAB(AC1)	;GET DDB OF TERMINAL S/HE WANTS
PTTY1:	MOVE TAC1,DEVNAM(AC2)
	PUSHJ P,PRNAME
	LDB AC1,[POINT PUNITS,DEVUNI(AC2),35-PUNITP] ; CAN'T USE PUNIT
	HLL AC1,LINTAB(AC1)
	TLNN AC1,DDDLIN
	JRST CRLF
	PUSHJ P,INLMES
	 ASCIZ /, DD/
	MOVE AC1,LETAB(AC1)	;NONZERO IT SAYS HERE
	HLRZ TAC,PRGNUM(AC1)
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES
	 ASCIZ / (at TV-/
	LDB TAC,[POINT PUNITS,DEVUNI(AC2),35-PUNITP]
	LDB TAC,[DDQREQ+TAC,,LSTESC] ;GET RESPONSIBLE TTY
	PUSHJ P,OCTPNT
	JSP TAC,CONMES
	 ASCIZ /)
/

PTTYDT:	JSP TAC,CONMES
	ASCIZ /Detached
/

CLSCOM:	PUSHJ P,INLMES
	 ASCIZ/?Use the QUIT command to close a network connection./
	POPJ P,
;⊗ PJOBDV PJOB DECLF PJOBX FNDDEV FNDD1A FNDDV1 FNDDV2 FNDDV3 PJPTY PJOBDL PJOBD2 PJBICK PJBGEN PJBGNL PJBGND PJBGN2 PJBGN6 PJBGN5 PJBG12 PJBG14 PJBG15 PJBG13 STTTAB STTLEN PJBGN4 PJBGN9 PJBGN3 PJBGN7 PJBIM2 PJBIMP PJBGN8 PJBG10 INLSPA SPAOUT SIXCNT SIXCN2 PJBUDP PJDVLZ PJGNLZ DEVFR2 DEVFR3 DEVFR1 DEVFR5 DEVFRE DEVFT2 PJBMSG PJPRNM

;PJOB COMMAND.
;"PJOB" PRINT JOB NUMBER OF JOB TTY IS ATTACHED TO
;"PJOB DEV" PRINT JOB NUMBER OF JOB USING DEVICE "DEV"

LOSYS

PJOBDV:	SKIPE TAC1,SAVDDB(DDB)
	JRST PJOBDL		;DELAYED TO FIT 2ND WHOLINE
	PUSHJ P,CTEXT1		;GET DEVICE NAME ARGUMENT
	JUMPN TAC1,PJOBX	;JUMP IF ARGUMENT WAS GIVEN
	JUMPE J,LOGPLS		;NO ARGUMENT.  JUMP IF NO JOB HERE
↑PJOB:	MOVE TAC,J		;JOB NO.
↑DECLF:	PUSHJ P,RADX10		;PRINT TAC AS DEC. THEN CRLF
	JRST CRLF

HISYS


PJOBX:	HLRZ TAC,TAC1		;See if this is a UDP
	CAIN TAC,'UDP'
	TRZ TAC1,-1		;Flush any unit number from UDP device
	MOVE TAC,TAC1		;TAC←SIXBIT DEVICE NAME.
	PUSH P,TAC		;SAVE DEVICE NAME.
	PUSHJ P,DEVPHY
	 SKIPA DDB,-3(P)	;NOT A REAL DEVICE.  GET BACK TTY DDB. SKIP
	JRST FNDDEV		;DEVICE NAME FOUND.  
IFE FTF2,<
	PUSHJ P,DADD00		;NOT DEVICE, PERHAPS DD CHAN
>;IFE FTF2
	 JRST PJDVLZ		;NO, NO SUCH DEVICE.
IFE FTF2,<
;Here if this is a DD channel.  See who's using it.
	LDB TAC1,[DDUSR+<(TAC1)>] ;YES, GET USE CODE
	JUMPE TAC1,DEVFRE	;0, NOT IN USE
	MOVEI AC2,0		;TESTED AT FNDDV1 TO CATCH PTYS
	CAIGE TAC1,DTTUSR	;IF LESS THAN THIS,
	JRST FNDDV1		;IT'S ASSIGNED TO THAT JOB
	CAIL TAC1,DSPUSR	;ABOVE THIS IS SPECIAL
	JRST DEVFR2		;DETACHED FROM SYS (OR AVLCHN)
	SUBI TAC1,DTTUSR-DTTL0	;ELSE MAKE IT A TTY LINE NUMBER
	CAIL TAC1,TTPLEN	;MAKE SURE REASONABLE TTY NUMBER
	JRST DEVFR2		;Say detached for screwed up TTY number
	PUSH P,TAC1
	PUSHJ P,INLMES		;TYPE OUT THE TTY NUMBER, THEN A CRLF
	 ASCIZ/TTY/		;FOR PJOB DDn.  THIS IS ONLY OF MARGINAL
	HRRZ TAC,(P)		;UTILITY SINCE IF THERE IS A JOB ON THE
	PUSHJ P,OCTPNT		;DD IT WILL SAY SO IN THE WHOLINE.  FLUSH?
	PUSHJ P,CRLF
	POP P,TAC1
	SKIPN DDB,TTYTAB(TAC1)	;DOES IT HAVE A DDB?
	JRST DEVFRE		;NO ONE HAS IT
>;IFE FTF2
FNDDEV:	MOVE AC1,DEVMOD(DDB)
	LDB AC2,PUNIT
	TLNE AC1,DVUDP
	JRST PJBUDP		;SPECIAL FOR UDP.
IFN FTP2,<
	MOVE TAC1,DEVCMR(DDB)	;SEE IF THIS IS A P2 DEVICE
	TLNE TAC1,DEVP2		;SKIP IF ON P2
	SKIPE DETFLG		;BUT IS P2 RUNNING?
	JRST FNDD1A
	JRST DEVFR3		;NO P2, SAY SO

FNDD1A:
>;IFN FTP2
	LDB TAC1,PJOBN
	JUMPN TAC1,FNDDV1	;Jump if in use
	PUSHJ P,PJPTY		;skip if owned PTY
	 JRST DEVFR1		;Not an owned pty, just say not in use
;Device in use, type wholine of job using device.
FNDDV1:	PUSH P,TAC		;(MAKE STACK DEPTH RIGHT!)
	PUSHJ P,PJPRNM		;PRINT DEVICE NAME.  TAC1→-1(P)
	PUSHJ P,PR2SP
	POP P,TAC
	POP P,TAC1
	JUMPE TAC1,FNDDV2	;ONLY FOR PTY OWNED BUT NOT IN USE
	PUSH P,AC1
	PUSH P,AC2
	PUSHJ P,PJBWHO		;GET TTYSER TO TYPE ITS WHOLINE
	POP P,AC2
	POP P,AC1
	PUSHJ P,PJPTY		;do special test for PTY
	 POPJ P,		;not PTY or not owned
	JRST FNDDV3		;PTY in use, type owner's wholine

FNDDV2:	PUSHJ P,INLMES		;HERE FOR PTY WITH OWNER BUT NO PJOBN
	ASCIZ /not logged in,
/
FNDDV3:	PUSHJ P,INLMES
	ASCIZ / owner: /
	HRRZM AC2,SAVDDB(DDB)	;save owner job or IMP DDB for later
	JRST DLYCM2		;LET'S COME BACK LATER

;Subroutine for PJOB to skip if device is a PTY owned by some job or Telnet server.
;Returns job number or IMP DDB in AC2 if owned PTY.
PJPTY:	TLNN AC1,DVTTY		;SKIP IF DEVICE IS A TTY
	POPJ P,
	CAIGE AC2,PTYL0		;IS IT A PTY?
	POPJ P,			;nope
	SKIPE PTYJOB-PTYL0(AC2)	;AND IN USE?
	SKIPA AC2,PTYJOB-PTYL0(AC2) ;get owner job
	SKIPE AC2,PTYIMP-PTYL0(AC2) ;maybe it's an ITY (Telnet server PTY)
	AOS (P)			;PTY in use--skip
	POPJ P,			;NO

;Here when resuming delayed command.  Maybe delayed because of second wholine
;for PTY owner, or because of generic PJOB cmd showing many DDB users.
PJOBDL:	SETZM SAVDDB(DDB)	;NO LONGER DELAYED COMMAND
	TLNN TAC1,-1		;Skip if this is a delayed generic PJOB cmd
	JRST PJBICK		;Check whether have job nbr or IMP DDB in TAC1
	HLLZ TAC,TAC1		;Get back the remembered generic device name
	HLRZ AC2,DEVLST		;Walk down device chain to place where we left off
	PUSH P,[-1]		;Set flag indicating we've already typed something
PJOBD2:	CAIN AC2,(TAC1)		;Skip unless this is the remembered DDB
	JRST PJBGND		;Resume generic search at this DDB
	HLRZ AC2,DEVSER(AC2)	;Get pointer to next DDB
	JUMPN AC2,PJOBD2	;Loop until end of chain
	JRST TPOPJ		;Oh well, DDB must have gone away in mean time

;Here on delayed command with LH of SAVDDB zero.  RH is either job number or
;IMP DDB of server.  In former case, print job's wholine; in latter, print msg.
PJBICK:	CAIGE TAC1,JOBN		;skip if not valid job number
	JRST PJBWHO		;Jump to TTYSER, job number for wholine is in TAC1
	PUSHJ P,INLMES		;must have been IMP DDB
	 ASCIZ/Telnet server in system.
/
	POPJ P,

;Here if can't find specific device.  Maybe user gave a generic name.  If we
;can find a device in the device chain with matching LH of device name, then
;we'll type out device name and user wholine.
;Here with generic device name in LH TAC.  We keep current DDB addr in AC2.
PJBGEN:	PUSH P,[0]		;Flag that we haven't seen any matching DDBs yet
	HLRZ AC2,DEVLST		;Start at beginning of device chain
PJBGNL:	HLLZ TAC1,DEVNAM(AC2)	;Get left half of device name
	CAMN TAC1,TAC		;See if left half of name matches
	JRST PJBGN2		;Yes!  Type device name and wholine
PJBGND:	HLRZ AC2,DEVSER(AC2)	;Next DDB
	JUMPN AC2,PJBGNL	;Jump unless end of chain
	POP P,TAC		;Get flag indicating success or failure
	JUMPE TAC,PJGNLZ	;Jump if never found a match, say no such device
	POPJ P,			;All done

;Here when found DDB matching given generic name.  Type device name and user's
;wholine (or something special if detached or not in use).  DDB addr is in AC2.
PJBGN2:	CAMN AC2,SWPDDB		;Special check for swapping DDB
	JRST PJBGND		;Ignore swapping DDB
	ADJSP P,-1		;Flush no longer needed flag from stack
	HLL AC2,TAC		;Make it generic name,,DDB to remember
	MOVEM AC2,SAVDDB(DDB)	;Remember data in TTY DDB for resuming command
	MOVE TAC1,DEVNAM(AC2)	;Get name of device
	PUSHJ P,SIXCNT		;Count non-blank leading chars, result in UCHN
	MOVE TAC1,DEVNAM(AC2)	;Get name of device again
	PUSHJ P,PRNAME		;Print it
	MOVE AC1,DEVMOD(AC2)	;See if UDP
	TLNN AC1,DVUDP		;UDP is special
	JRST PJBGN8		;Not UDP
NoStructure,<
	LDB TAC,[POINT PUNITS,DEVUNI(AC2),35-PUNITP] ;UDP unit number
	SKIPLE TAC1,UDPOWN-1(TAC) ;How's it in use?
>;NoStructure
IfStructure,<
	MOVE	TAC,SDBPTR(AC2)	;Get the SDB for unit
	SKIPLE	TAC1,ST.JOB(TAC);Skip unless privately owned
>;IfStructure
	JRST PJBGN4		;PRIVATELY OWNED, TAC1←JOB NUMBER
	JUMPL TAC1,PJBGN5	;Jump if not in use or public
PJBGN6:	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/detached from system
/
	JRST DLYCM2		;Delay cmd now until output buffer clears

PJBGN5:				;Here if UDP is idle or public.  Which?
NoStructure,<
	SKIPN UDPCNT-1(TAC)	;TAC has Unit number
>;No Structure
IfStructure,<
	SKIPN	ST.CNT(TAC)	;TAC has SDB address
>;IfStructure
	JRST PJBGN3		;NO DDBS, NOT IN USE
	LDB TAC1,[POINT JOBNSZ,DEVJBN(AC2),JOBNPS] ;Get owner
	JUMPN TAC1,PJBG10	;Jump if this DDB in use
	PUSH P,TAC		;Save Unit Number (Or SDB Address)
	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/public /
	POP P,TAC		;Restore Unit number (Or SDB Address)
NoStructure,<
	SKIPLE TAC,SATADR(TAC)	;IS THE SATID KNOWN?
	PUSHJ P,SATTAC		;YES, PRINT SATID 
>;NoStructure
IfStructure,<
	SKIPE	TAC,ST.NAM(TAC)	;Is the Structure name known?
	PUSHJ	P,PSTRID	;Yes, Print it
>;IfStructure
	PUSHJ P,TYCRLF		;Type a CRLF
	JRST DLYCM2		;Delay cmd now until output buffer clears

PJBG12:	TLNN AC1,DVIMP		;skip if this is an IMP DDB
	JRST PJBG13		;nope, just say sharable
	MOVEI AC1,(AC2)		;just DDB adr
	CAIN AC1,IMPDDB		;is this the prototype?
	JRST PJBG13		;yes, then really is sharable
	PUSHJ P,INLSPA		;no, must be closing
	 ASCIZ/Dis-owned/
PJBG14:	PUSHJ P,INLMES		;Enter here from PJBIMP (telnet server closing)
	 ASCIZ/ connection; state /
	SKIPL TAC,STATE(AC2)	;Get connection state, skip if negative
	CAIL TAC,STTLEN		;Check against table upper bound
	JRST PJBG15		;Not a state we know about
	MOVEI TAC,STTTAB(TAC)	;Get address of state name
	PUSHJ P,CONMES		;Print state name
	PUSHJ P,CRLF
	JRST DLYCM2
	
PJBG15:	PUSHJ P,OCTPNT		;Print octal state number
	PUSHJ P,CRLF
	JRST DLYCM2		;Delay cmd now until output buffer clears

PJBG13:	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/sharable
/
	JRST DLYCM2		;Delay cmd now until output buffer clears

;Table of names for TCP states (no longer than 4 characters each)

STTTAB:	ASCIZ/Clos/
	ASCIZ/List/
	ASCIZ/SynS/
	ASCIZ/SyRP/
	ASCIZ/SyRA/
	ASCIZ/Estb/
	ASCIZ/Fin1/
	ASCIZ/Fin2/
	ASCIZ/Clsn/
	ASCIZ/TimW/
	ASCIZ/ClsW/
	ASCIZ/LAck/
STTLEN←←.-STTTAB

;Here if UDP is private.  There must be at least two DDBs in this case, the
;model DDB, and an ASSIGNed DDB.  If this is the model, we just say "private",
;else we say who owns it.
PJBGN4:	LDB TAC,[POINT JOBNSZ,DEVJBN(AC2),JOBNPS] ;Get owner
	JUMPN TAC,PJBG10	;Jump if this DDB is in use
	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/private
/
	JRST DLYCM2

;Here if PJOBN of generic match is zero and device isn't UDP.
PJBGN9:	HRR AC1,DEVMOD(AC2)	;See if maybe detached from system
	TRNE AC1,ASSCON		;Skip unless device is detached
	JRST PJBGN7		;Detached (maybe special if IMP)
	HLR AC1,DEVCMR(AC2)	;If this is sharable device, must be model DDB
	TRNE AC1,DEVSHR		;Skip unless sharable device
	JRST PJBG12		;Model DDB, say sharable
PJBGN3:	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/not in use
/
	JRST DLYCM2		;Delay cmd now until output buffer clears

;Here if ASSCON bit on and PJOBN zero in generic match, not UDP.  Maybe IMP.
PJBGN7:	TLNN AC1,DVIMP		;skip if this is an IMP DDB
	JRST PJBGN6		;nope, say detached
	MOVEI AC1,(AC2)		;just DDB adr
	CAIN AC1,IMPDDB		;is this the prototype?
	JRST PJBGN6		;yes, then really is detached!
	MOVE AC1,TTYLIN(AC2)	;see if this is a DDB awaiting a server
	TLNN AC1,IMPSRV		;skip if DDB awaiting a server
	JRST PJBIMP		;not awaiting server job
	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/Awaiting server, port (octal) /
	MOVE TAC,LCLPRT(AC2)	;get local port number
PJBIM2:	PUSHJ P,OCTPNT		;print in octal
	PUSHJ P,TYCRLF		;output crlf
	JRST DLYCM2		;Delay cmd now until output buffer clears

;Here with IMP DDB w/ASSCON bit on, PJOBN zero, not prototype, IMPSRV off.
;Must be a telnet server DDB.
PJBIMP:	PUSHJ P,INLSPA		;Put out spaces to right column, print msg
	 ASCIZ/Telnet server/
	HRRZ AC1,TTYLIN(AC2)	;get line number
	CAIGE AC1,PTYL0		;skip if really a PTY
	JRST PJBG14		;must be closing connection
	PUSHJ P,INLMES
	 ASCIZ/ for TTY/
	MOVE TAC,AC1		;ITY line number
	JRST PJBIM2		;print octal line number and CRLF, delay cmd

;Here if device matches generic name but isn't UDP.
PJBGN8:	LDB TAC1,[POINT JOBNSZ,DEVJBN(AC2),JOBNPS] ;Get owner
	JUMPE TAC1,PJBGN9	;Jump if not in use
PJBG10:	PUSH P,TAC1		;Preserve job number of owner through TYO, SPAOUT
	MOVE AC1,DEVMOD(AC2)	;See if this is an ASSIGNed DDB
	MOVEI TEM,"#"		;Char to print if assigned
	TRNE AC1,ASSCON		;Skip if not assigned
	XCT TYO			;Assigned, print "#"
	TRNE AC1,ASSCON		;Skip if not assigned
	ADDI UCHN,1		;Count another char output
	PUSHJ P,SPAOUT		;Put out spaces to right column
	POP P,TAC1		;Get back job number
	PUSHJ P,PJBWHO		;Get TTYSER to print job's wholine w/CRLF
	JRST DLYCM2		;Delay cmd now until output buffer clears

;Like INLMES but prints spaces first, message follows call in-line
INLSPA:	PUSHJ P,SPAOUT		;put out spaces to right column
	JRST INLMES		;print message that followed call to here

;Here to simulate "small" tab.  UCHN has count of chars already put out
SPAOUT:	SUBI UCHN,7		;Subtract number of chars we want to have put out
	JUMPGE UCHN,CPOPJ	;Done if already put out enough spaces
	MOVEI TEM," "
	XCT TYO			;Put out spaces until have enough
	AOJL UCHN,.-1
	POPJ P,

;Here to count how many chars will be printed for sixbit name in TAC1.
;Return count in UCHN.  (Note: only counts leading chars, not any after spaces.)
SIXCNT:	TDZA UCHN,UCHN		;Maybe no chars at all
SIXCN2:	LSH TAC1,6		;Next position
	TLNE TAC1,770000	;Any char there?
	AOJA UCHN,SIXCN2	;Yes, count it and loop
	POPJ P,			;Nope, all done

PJBUDP:
NoStructure,<
	LDB	TAC,PUNIT	;UDP: GET INDEX TO TABLES
	SKIPLE	TAC1,UDPOWN-1(TAC)
	JRST	FNDDV1		;PRIVATELY OWNED, TAC1←JOB NUMBER
	JUMPE	TAC1,DEVFR2	;DETACHED
	SKIPN	UDPCNT-1(TAC)	;skip if DDBs exist
>;NoStructure
IfStructure,<
	MOVE	TAC,SDBPTR(DDB)	;Get SDB Address
	SKIPLE	TAC1,ST.JOB(TAC);Skip if idle or public or detached
	JRST	FNDDV1		;PRIVATELY OWNED, TAC1←JOB NUMBER
	JUMPE	TAC1,DEVFR2	;DETACHED
	SKIPN	ST.CNT(TAC)	;skip if DDBs exist
>;IfStructure
	JRST	DEVFRE		;NO DDBS, NOT IN USE
	PUSH	P,TAC		;(MAKE STACK DEPTH RIGHT FOR PJPRNM)
	PUSHJ	P,PJPRNM
	POP	P,TAC	
NoStructure,<
	SKIPLE	TAC,SATADR(TAC)	;IS THE SATID KNOWN?
	PUSHJ	P,SATTAC	;YES, PRINT SATID IF ANY
>;NoStructure
IfStructure,<
	SKIPE	TAC,ST.NAM(TAC)	;Is the structure name Known?
	PUSHJ	P,PSTRID	;YES, PRINT SATID IF ANY
>;IfStructure
	SUB P,[1,,1]		;discard return to caller?
	JSP TAC,CONMES
	ASCIZ / public
/

PJDVLZ:	POP P,TAC		;Get back device name specified
	MOVE DDB,-2(P)		;Restore TTY DDB
	TRNN TAC,-1		;If any unit number, or big name, no generics
	JRST PJBGEN		;Try a generic search of DDB chain
PJGNLZ:	MOVEI DAT,TTOBUF(DDB)
	JRST NOTDEV

DEVFR2:	JSP TAC,PJBMSG
	ASCIZ /Detached from system
/

DEVFR3:	JSP TAC,PJBMSG
	ASCIZ /Unavailable, P2 not running
/

;Here if device found has a PJOBN of zero.  Never here for UDPs (earlier test).
;Not an owned PTY.  See if this is model DDB of sharable device.
DEVFR1:	HLL AC1,DEVCMR(DDB)	;If this is sharable device, must be model DDB
	TLNN AC1,DEVSHR		;Skip if sharable device
	JRST DEVFR5		;Not sharable
	MOVE TAC,(P)		;Get back device name
	TRNN TAC,-1		;If no right half text in name,
	JRST PJDVLZ		; then go look for all DDBs for shared device
	TRNE AC1,ASSCON		;skip unless detached
	JRST DEVFR2		;detached
	JSP TAC,PJBMSG		;Else, say sharable
	ASCIZ /Sharable
/

;Here if non-sharable device, PJOBN is zero (as is TAC1).
DEVFR5:	TRNE AC1,ASSCON		;skip unless detached
	JRST DEVFR2		;detached
	TLNE AC1,DVTTY
	JRST DEVFT2		;SPECIAL FOR TTYS, we know it isn't an owned PTY
DEVFRE:	JSP TAC,PJBMSG
	ASCIZ /Not in use
/

DEVFT2:	PUSHJ P,TTYDIE		;THIS COMMAND MADE A TTY DDB, kill it quickly
	JRST DEVFRE

PJBMSG:	POP P,(P)
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JRST CONMES

PJPRNM:	MOVE DDB,-5(P)		;THE TTY DDB
	MOVEI DAT,TTOBUF(DDB)	;OUTPUT BYTE POINTER
	EXCH TAC1,-2(P)		;BLARGH!
	JRST PRNAME		;PRINT SIXBIT AND POPJ.
;PPPN PPPN5 PPPN6 PPPN65 PPPN7 PPPN8 PPPN9

PPPN:	PUSHJ P,DECIN		;GET ARGUMENT, IF ANY
	JRST PPPN6		;NO ARGUMENT. PPN FOR CURRENT JOB.
	JRST COMERA		;ILL. ARGUEMENT
	MOVSI TAC,NOINCK	;DON'T INITIALIZE A JOB JUST FOR ME!
	IORM TAC,-1(P)
	CAIGE TAC1,JOBN		;OUT OF BOUNDS?
	CAIG TAC1,0
	JRST ECOMA		;PRINT "OUT OF BOUNDS"
	MOVE AC1,TAC1		;USE THAT JOB NUMBER
PPPN5:	MOVE TAC,JBTSTS(AC1)
	SKIPE PRJPRG(AC1)
	TLNN TAC,JNA
	JRST NOTLOG
	MOVE TAC,[POINT 6,PRJPRG(AC1)]
	PUSHJ P,PPPN65		;WRITE PPN
	SKIPN DSKPPN(AC1)	;ANY ALIAS PPN?
	JRST CRLF		;NO.  TYPE CRLF AND RETURN
	PUSHJ P,INLMES
	ASCIZ /  Alias  /
	MOVE TAC,[POINT 6,DSKPPN(AC1)]
	PUSHJ P,PPPN65
	JRST CRLF		;TYPE CRLF AND POPJ

PPPN6:	MOVEI AC1,(J)		; NO ARGUMENT USE PPN OF CURRENT JOB
	MOVE AC2,JBTSTS(J)
	TLNN AC2,JLOG
	JRST LOGPLS
	JRST PPPN5

PPPN65:	PUSHJ P,PPPN7		;WRITE 3 SIXBIT CHARACTERS
	MOVEI TEM,","
	XCT TYO
PPPN7:	MOVEI TAC1,3		;3 CHARACTERS
PPPN8:	ILDB TEM,TAC		;LOAD THE NEXT BYTE
	JUMPE TEM,PPPN9		;FLUSH NULL BYTES
	ADDI TEM," "		;MAKE SIXBIT INTO ASCII
	XCT TYO			;TYPE ONE CHARACTER
PPPN9:	SOJG TAC1,PPPN8		;LOOP
	POPJ P,
;SDSKPPN SDKPP1 SDKPP2 CNGPRJ CDSKPPN ALDFL1 ALDFL2 GETWRB NOJUST GTWRB1
;SDSKPPN - ALIAS COMMAND

;ALIAS COMMAND	"ALIAS PRJ,PRG", "ALIAS PRJ", "ALIAS PRJ," OR "ALIAS"
;THE FIRST THRE SET DSKPPN(J) AND THE LAST RESETS IT
SDSKPPN:MOVSI TAC1,AAOPRV	;ALIAS COMMAND ALWAYS DISABLES AAO PRIVILEGE
	ANDCAM TAC1,JB2PRV(J)
	CAIE TEM,";"
	CAIN TEM,12		;TERMINATOR SEEN ALREADY?
	JRST CDSKPPN		;YES. SET ALIAS TO LOGGED-IN NAME.
	PUSHJ P,GETWRB		;LOOK FOR PRJ
	JUMPN TAC1,SDKPP1
	CAIE TEM,12		;NO ARG AT ALL?
	CAIN TEM,";"
	JRST CDSKPPN		;NO ARG IS OK
	JRST COMERR		;BAD ARGUMENT, BAD DELIMITER

SDKPP1:	HLLZ AC2,TAC1		;SAVE PRJ
	TRNE TAC1,-1		;CHECK SYNTAX.
	JRST COMERR
	CAIE TEM,"."
	CAIN TEM,","		;COMMA OR DOT SEEN?
	JRST SDKPP2		;YES.
	CAIE TEM,12		;NO COMMA MEANS ONLY PRJ TYPED. MAKE PRG FROM PRJPRG
	CAIN TEM,";"		;BUT ONLY IF THE DELIMTER IS EITHER LF OR SEMICOLON
	JRST ALDFL2		;NO. ONLY PRJ TYPED.  MAKE PRG FROM PRJPRG
	JRST COMERR		;BAD DELIMITER

SDKPP2:	PUSHJ P,GETWRB		;SCAN PRG
	JUMPE TAC1,ALDFL1	;IF NONE, PRG SET FROM OLD DSKPPN.
	HLR AC2,TAC1		;DON'T CARE ABOUT TERMINATOR HERE
	TRNE TAC1,-1
	JRST COMERR
CNGPRJ:	CAMN AC2,MFDENT		;SAME AS 1,1?
	JRST COMERR		;SOME THINGS NOT ALLOWED.
	CAMN AC2,PRJPRG(J)	;SKIP UNLESS EXPLICITLY RESETTING ALIAS
CDSKPPN:MOVEI AC2,0		;CLEAR ALIAS
	MOVEM AC2,DSKPPN(J)
	SETZM JBTUFD(J)		;CLEAR JBTUFD.
	POPJ P,

ALDFL1:	SKIPN TAC1,DSKPPN(J)
ALDFL2:	MOVE TAC1,PRJPRG(J)
	HRR AC2,TAC1
	JRST CNGPRJ

GETWRB:	PUSHJ P,CTEXT
	JUMPE TAC1,GTWRB1	;NO TOKEN
	TLNN TAC1,7777
	LSH TAC1,-14
	TLNN TAC1,77
	LSH TAC1,-6
NOJUST:	PUSHJ P,SKIPSB		;SKIP TO BREAK.  THIS GUY MAY CALL TPOPJ!
	CAIN TEM,"]"
	PUSHJ P,SKIPSA
	POPJ P,			;BEWARE OF UPLEVEL RETURN FROM SKIPSB/A

GTWRB1:	CAIE TEM,"["
	JRST NOJUST
	JRST GETWRB		;CTEXT WILL SKIP OVER BRACKET
;⊗ KJOB0 KJOB NOTLGI LOGPLS KJOB0A LOGPLM ADSRST ADSRSL ADSRS2 ADSRS3 KJOB1A KJOB1 JOBKL0 KJOB2 JOBKL JOBKL1 JOBKL2

;JOB IS GUARANTEED BY THE COMMAND DISPATCHER TO BE INCORE. (POSSIBLY SHRUNK)
KJOB0:	SKIPA TAC1,[KJOB0A]	;K AND KJOB ENTER HERE TO MAYBE RESET AUDIO SWITCH
KJOB:	MOVEI TAC1,KJOB1
	JUMPG J,(TAC1)		;JUMP IF THERE IS A JOB HERE.
	SETZM -1(P)		;CLEAR NOJOBN SO COMRET WILL PRINT MESSAGE
	LDB AC1,PUNIT		;get TTY number
	HLL AC1,LINTAB(AC1)	;get line characteristics
	TLNN AC1,IMPBIT		;network TTY?
	JRST NOTLGI		;no, say not logged in
	PUSHJ P,INLMES
	 ASCIZ /?Not logged in.  (Use QUIT to close your network connection.)/
	POPJ P,

NOTLGI:	PUSHJ P,INLMES
	 ASCIZ /?You were already not logged in!/
	POPJ P,

LOGPLS:	JSP TAC,ERRMES
	ASCIZ /Login please
/

KJOB0A:	PUSHJ P,ADSRST		;CLEAR AUDIO IF THIS IS LAST TTY USED BY THIS KBD
	JRST KJOB1		;ADSRST PRESERVES ALL ACS

LOGPLM:	MOVSI TAC,NOMESS!NOPER!NOCRLF
	ANDCAM TAC,-1(P)	;PRINT MESSAGE PLEASE
	JRST LOGPLS

;HERE FROM KJOB COMMAND TO FLUSH AUDIO IF NOT RESPONSIBLE FOR ANYONE ELSE
ADSRST:	PUSHACS			;WE COULD JUST PUSH AC1,2,3,DSER,TAC,DDB
	LDB AC1,PUNIT		;GET TTY NUMBER
	LDB AC2,[DDQREQ+AC1,,LSTESC] ;GET RESPONSIBLE TTY (MUST BE ONE)
	MOVEI AC3,TTPLEN-1	;LOOK AT ALL TTYS
ADSRSL:	CAIN AC3,(AC1)		;DON'T CARE ABOUT THE TTY THAT IS LOGGING OUT
	JRST ADSRS2
	LDB TAC,[DDQREQ+AC3,,LSTESC] ;GET SOMEONE'S RESPONSIBLE TTY
	CAIN TAC,(AC2)		;IS THAT US?
	SKIPN DDB,TTYTAB(AC3)	;YES, BUT IS THERE A JOB THERE?
	JRST ADSRS2		;NO
	LDB TAC,PJOBN		;GET JOB NUMBER
	JUMPN TAC,ADSRS3	;STILL RESPONSIBLE SOMEWHERE, LEAVE AUDIO
ADSRS2:	SOJGE AC3,ADSRSL
	MOVE TAC,[320000,,0]	;SELECT AUDIO CHANNEL 0 PERMANENTLY, NO WAITING
	PUSHJ P,ADSMAP		;SIMULATE THE UUO
ADSRS3:	POPACS
	POPJ P,

;ENTER AT KJOB1.  AT KJOB1A IF JOB HAS NO CORE AND WE NEED TO RUN LOGOUT.
KJOB1A:	MOVEI TAC,ASSPRG	;JOB HAS NO CORE. CLEAR ASSPRG IN TTY DDB
	ANDCAM TAC,DEVMOD(DDB)
	MOVEI TAC,JOBDA		;REQUEST JUST ENOUGH CORE FOR A JOB DATA AREA
	PUSHJ P,CORE0		;GET NEW CORE
	JFCL
	SKIPN JBTPAG(J)
	JRST DLYCOR		;DELAY IF NEW CORE IS ON THE DISK (IT WILL BE)
	MOVE AC1,JBTSTS(J)
KJOB1:	PUSHJ P,STLNAC		;GET TTY BITS
	TLNN TAC1,IMPBIT	;IMP'S GET TO RUN LOGOUT, DESPITE BEING ON PTYS.
	TLNN TAC1,PTYLIN	;FLUSH PTY JOBS INSTANTLY!
	TLZN AC1,JLOG!JACCT	;SHALL WE RUN LOGOUT?
	JRST KJOB2		;NO.
	SKIPN JBTPAG(J)		;YES. WE'LL RUN LOGOUT. SKIP IF JOB HAS CORE.
	JRST KJOB1A		;WE NEED TO GET SOME CORE FIRST
	TLO AC1,JACCT		;SET "ACCOUNTING PGM RUNNING"
	HLLM AC1,JBTSTS(J)
	PUSHJ P,ALOGN1
	MOVSI TAC,TTYRNU+NOMESS
	XORM TAC,-1(P)		;TURN ON TTYRNU, TURN OFF NOMESS
IFN FTMONCIP,<
	SKIPLE MONCIP(DDB)
	HRROS MONCIP(DDB)	;SUPPRESS SKPBRK SINCE RUNNING USER PROGRAM
>;IFN FTMONCIP
	PUSH P,['LOGOUT']
	PUSH P,['  1  2']
	JRST ARPCOM		;RUN LOGOUT.DMP[1,2]
;LOGOUT TERMINATES VIA EXIT UUO WHICH JUMPS TO JOBKL.

COMMENT $
JOBKL -- KILL AT UUO LEVEL.  CALLED FROM:
		ESTOP3 - KILL PHANTOMS (SCHEDULE A MONITOR JOB)
		ESTOP - KILL PHANTOMS - (ESTOP CALLED AT UUO LEVEL)
		EXIT UUO - KILL UNLOGGED-IN JOBS
		LOGOUT UUO
		KILCM1 - KILL COMMAND

$

;AT KJOB2 FROM KJOB COMMAND FOR KILLING JOB ON A PTY OR UNLOGGED IN JOBS.
;IF JOB HAS CORE, SCHEDULE A MONITOR JOB TO RUN AT UUO LEVEL AND KILL IT.

JOBKL0:	PUSHJ P,COMR2B		;CLEAR COMBIT IN CASE OF NO CORE (I.E. NO MONJOB)
	JRST JOBKL1

KJOB2:	SKIPN JBTPAG(J)		;SKIP IF JOB HAS CORE.
	JRST JOBKL0		;NO CORE.
	AOS AMC7		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP MAP FOR THIS JOB.
	JSP TAC1,MONJOB		;SCHEDULE MONITOR JOB.  EXIT TO COMRET.
JOBKL:	MOVEI TAC1,ESTOP2	;ESTOP AT END OF PDL
	JSP TAC,MONSTR		;SET UP ACS AND PDL LIST
↑JOBKL1:PUSHJ P,DSFLUSH		;MAKE RESET TO KILL SPECIAL DETACHED SEGMENTS.
	PUSHJ P,RESETSEG	;KILL DETACHED SEGMENTS
	SKIPN JBTPAG(J)		;SKIP IF JOB IS IN CORE
	JRST JOBKL2		;JUMP IF THERE'S NO CORE ASSIGNED TO THIS JOB.
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,10		;signature of this event
>;IFN FTUFDB
	PUSHJ P,RESET		;FINISH IO BEFORE DEASSIGNING
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,0		;signature of this event
>;IFN FTUFDB
	PUSHJ P,DEASTY		;WHILE WE STILL HAVE CORE, DEASSIGN DEVICES XCPT TTY
	PUSHJ P,JOB1		;RESET, CORE 0, FLUSH JBTMAP, FLUSH SWAP IMAGE.
JOBKL2:	PUSHJ P,DEASTY		;DEASSIGN ALL BUT TTY
	PUSHJ P,TTYERR		;GET TTY FOR OUTPUT
	PUSHJ P,INLMES
	ASCIZ /Kjob
/
	PUSHJ P,PRPER
	PUSHJ P,TTYSTR		;IF WE EVER FORCE A KJOB THIS SHOULD BE TTYSTF
	PUSHJ P,TTYKIL		;RETURN TTY TO VIRGIN STATE
	SKIPE AC1,JBTJL(J)	;AND JOB PRIORITY HISTORY
	PUSHJ P,FSGIVE
	SETZM JBTJL(J)
	SKIPE AC1,JBTFS(J)	; ANY SPARE FREE STORAGE?
	PUSHJ P,FSGIVE
	SETZM JBTFS(J)
	PUSHJ P,TMPKIL		;FLUSH ALL HIS TMPCOR FILES (IGNORING ALIAS)
	HLRZ AC1,SAVSAI(J)
	JUMPE AC1,.+2
	PUSHJ P,FSGIVE		;RETURN SWAP UUO AC SAVE BLK
	SETZM SAVSAI(J)
	PUSHJ P,RELPDL		;RELEASE PDL. PDL MAY BE USED UNTIL WE LEAVE 
				;UUO LEVEL OR CH7

IFN FTP2,<
	CAMN J,XFCJN
	SETZM XFCJN		;NO LONGER THE FONT COMPILER
>;IFN FTP2
	MOVSI TAC,JNA!JLOG!JACCT ;CLEAR BITS  (FORMERLY CALLED KSTOP)
	ANDCAM TAC,JBTSTS(J)
	SETZM PRJPRG(J)		;KEEP TABLE ACCURATE
	SETZM JOBNAM(J)
	SETZM TTIME(J)		;CLEAR RUN TIME FOR *SPY*
	SETZM JBTBTM(J)		;CLEAR LOGIN TIME FOR ACCOUNTING
	SETZM JBTGSL(J)		;CLEAR GUARANTEED SERVICE WORDS
	SETOM JBTWKM(J)		;WAKE ON ALL INTERRUPTS
	SETOM JBTIRU(J)		;INITIALIZE THE I-LEVEL RUN MASK
	MOVEI TAC,400000
	IORM TAC,JBTLIN(J)	;MAKE AN INVALID TTY NUMBER
	JRST ESTOP2
;RESCOM RESCO3 RESCO2 KILUUO KILUU2 SOMCOR FKILLC KILCOM KILOK0 KILOK KILCM3 KILCM4 KILCM6 KILCM5 ILLKIL KILCMF KILCM1 RESCM1 FINCM1

;RESET AND KILL COMMANDS, KILL UUO, PART OF FINISH COMMAND

;HERE FOR RESET MONITOR COMMAND
RESCOM:	PUSHJ P,NBRPPN		;GET NUMBER AND PPN OF JOB TO RESET
	 JRST COMERA		;ILLEGAL CHAR IN JOB NUMBER
	 SKIPA TAC1,J		;NO ARGUMENT, RESET OWN JOB
	 JRST NOTLOG		;SEGMENT CAN'T BE RESET--SAY NO SUCH JOB
	CAME TAC1,J		;RESETING OURSELF?
	JRST RESCO2		;NO
	MOVE AC1,JBTSTS(J)	;YES, MAKE SURE JOB NOT RUNNING
	TLNN AC1,RUN		;SKIP IF THE CURRENT JOB IS RUNNABLE.
	JRST RESCO3		;PROCEED WITH COMMAND.
	MOVM AC1,JOBQUE(J)	;IS THE JOB TRYING TO BE IN STOPQ?
	CAIE AC1,STOPQ
	JRST CNCME2		;NO - TELL HIM TO STOP FIRST.
RESCO3:	MOVSI TAC,NOPER
	IORM TAC,-1(P)		;TELL COMRET NOT TO TYPE DOT (RESCM1 WILL)
RESCO2:	MOVEI AC1,RESCM1	;ADDRESS OF MONITOR JOB
	PUSH P,J
	MOVE J,TAC1		;Job number of RESETee
	PUSHJ P,KILSPW		;Kill off its spacewar quickly, clobbers TAC
	POP P,J
	JRST KILOK		;USE COMMON CODE

;HERE FOR KILL UUO.  KILL JOB WHOSE NUMBER IS IN TAC.  MUST HAVE MESPRV
KILUUO:	MOVE AC2,JB2PRV(J)	;GET OUR PRIVILEGES
	JUMPL TAC,CPOPJ		;BAD JOB NUMBER
	CAIGE TAC,JOBN		;MAKE SURE LEGAL JOB NUMBER
	TLNN AC2,MESPRV		;ARE WE ALLOWED TO DO THIS?
	POPJ P,			;NOPE
	MOVE AC1,TAC		;GET VICTIM'S JOB NUMBER INTO AC1
KILUU2:	MOVE AC2,JBTSTS(AC1)	;IS THERE REALLY A JOB THERE?
	TLNN AC2,JNA
	POPJ P,			;NO JOB, RETURN
	HRRE DDB,JBTLIN(AC1)	;GET VICTIM'S TTY NUMBER
	JUMPGE DDB,.+2		; IF ANY
	MOVEI DDB,TCONLN	;IF DETACHED, FORCE COMMAND ON CTY
	SKIPN DDB,TTYTAB(DDB)	;GET THE DDB
	POPJ P,			;IT CAN'T HAPPEN
	MOVEI TAC,F.KILL	;INDEX OF FORCED KILL COMMAND
	PUSHJ P,FORCEA		;FORCE COMMAND WITH ARGUMENT IN AC1
	JUMPE CHR,CPOPJ		;JUMP IF SUCCESSFUL
	PUSHJ P,WSCHED		;IF AT FIRST YOU DON'T SUCCEED,
	JRST KILUU2		; TRY, TRY AGAIN

SOMCOR:	SKIPE JBTPAG(J)		;SKIP IF NOT IN CORE.
	JRST CPOPJ1		;VICTIM HAS CORE ASSIGNED.
	MOVEI TAC,JOBDA		;MAKE JOB DATA AREA FOR THE VICTIM
	PUSH P,AC1		;SAVE ADDRESS OF MONITOR JOB
	PUSHJ P,CORE0
	 JFCL
	POP P,AC1
	SKIPE JBTPAG(J)		;SKIP IF STILL NO JOB DATA AREA IN CORE
	AOS (P)			;NOW HE HAS CORE IN CORE
	POPJ P,

FKILLC:	LDB TAC1,ARGBPT		;FORCED KILL, GET JOB NUMBER TO KILL
	CAIL TAC1,JOBN		;Make sure arg is within range
	POPJ P,			;Shouldn't ever happen, but be safe
	MOVEI AC1,KILCMF	;SPECIFY AT MONJOB LEVEL THAT IT WAS FORCED
	JRST KILOK0		;SKIP SCAN AND SUICIDE CHECK

KILCOM:	MOVEI AC1,(DDB)		;LET THE CTY KILL TO HELP WIZARD WHO CAN'T
	CAIE AC1,SCNDDB		;GET LOGGED IN OTHERWISE!
	JUMPE J,LOGPLM		;NOT CTY, DEMAND LOGIN
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,6		;signature of this event
>;IFN FTUFDB
	PUSHJ P,NBRPPN		;GET NUMBER AND PPN OF JOB TO KILL
	 JRST COMERA		;ILLEGAL CHAR IN JOB NUMBER
	 JRST NOTENF		;NO ARGUMENT--GOTTA BE ONE
	 JRST KILCM5		;JOB IS A SEGMENT--GO CHANGE ITS NAME
	CAMN J,TAC1		;NO SUICIDE!
	JRST ILLKIL
	MOVEI AC1,KILCM1	;ADDRESS OF MONITOR JOB
KILOK0:	MOVSI TAC,NSLPRV	;Doing a KILL, flush NSL priv to avoid delay
	ANDCAM TAC,JB2PRV(TAC1)	;Flush NSL in victim's privs
KILOK:	MOVE TAC,JBTSTS(TAC1)	;RESET AND FINISH COMMANDS JOIN KILL HERE
	PUSH P,J		;KILLER'S JOB
	MOVE J,TAC1		;J←VICTIM
	TLNE TAC,SWP		;SWAPPED OUT?
	JRST KILCM3		;YES, GET HIM IN
	PUSHJ P,SOMCOR		;MAKE SURE HE'S GOT SOME CORE
	 JRST KILCM4		;NO CORE NOW, DELAY CMD UNTIL HE HAS CORE IN CORE
	MOVSI TAC1,CMWB		;CLEAR COMMAND WAIT BIT
	ANDCAM TAC1,JBTSTS(J)	;SO VICTIM WILL RUN
	AOS AMC8		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP MAP TO POINT TO VICTIM.
	MOVEI TAC1,(AC1)	;ADDRESS OF ROUTINE TO RUN AT UUO LEVEL
	PUSH P,DDB		;SAVE KILLER'S TTY DDB
	PUSH P,TAC1		;SAVE DESIRED PC
	PUSHJ P,TTYSRC		;SET UP TTY DDB OF TARGET JOB
	POP P,TAC1
	PUSHJ P,MONJOB		;SCHEDULE A MONITOR JOB.
	POP P,DDB		;RESTORE KILLER'S TTY DDB
	MOVE IOS,DEVIOS(DDB)	;GET KILLER'S TTY IOS BACK
	POP P,J
	XCTR XW,[MOVEM J,JOBFDV] ;SAVE JOB NUMBER OF KILLER
	POPJ P,			;COMRET WILL RESTORE MAP.

KILCM3:	PUSHJ P,DLYCOM		;SET CMWB. GET VICTIM IN CORE IF NECESSARY.
KILCM4:	POP P,J
	MOVE TAC1,LINSAV	;GET LINE NUMBER OF KILLER
	OFFSCN

;What this really does is:  Turn on (or leave on) COMBIT to make sure we
;retry the command every tick, since we have no way of knowing when the
;other guy has been swapped in.  Normally we AOS COMCNT when turning on
;COMBIT, and we would here, but if this is a forced command we need to
;simulate DLYCR2's SOSing of COMCNT (which DLYCR2 does because IT doesn't
;want COMMAND to be called needlessly.  Thus if COMBIT is already set,
;we don't need the AOS but we still need the SOS.

	SKIPN FRCFLG
	JRST KILCM6		;IF SO, THIS IS REGULAR, NOT FORCED, KILL CMD
	SKIPGE TTYTAB(TAC1)	;IS COMBIT ALREADY ON?
	SOS COMCNT		;YES, AVOID AOS AND JUST SIMULATE DLYCR2'S SOS
	MOVSI DDB,COMBIT	;FORCED.  WE MUST SET COMBIT TO TELL TTYCOM
	IORB DDB,TTYTAB(TAC1)	;  TO RETRY THE COMMAND UNTIL VICTIM COMES IN
KILCM6:	ONSCN
	JRST DLYCM		;DELAY KILLER.

KILCM5:	MOVE TAC,PRJPRG(TAC1)	;HERE TO KILL A SEGMENT.
	MOVEM TAC,JOBNAM(TAC1)	;JUST CLOBBER IT'S NAME
IFN FTSTAT,<
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
	POPJ P,

ILLKIL:	JSP TAC,CONMES
	ASCIZ /Use "KJOB" to log yourself out
/

;KILL ROUTINE, FLUSHES THINGS WITHOUT WAITING
;ENTER HERE FROM KILL COMMAND AS A MONITOR JOB, I.E., RUNNING AT UUO LEVEL.
KILCMF:	XCTR XW,[SETOM JOBFDV]	;FLAG FORCED KILL
KILCM1:	MOVEI TAC1,ESTOP
	JSP TAC,MONSTR		;SETUP UUO LEVEL ACS.
	MOVEI TAC,[ASCIZ/KILLed /] ;MESSAGE TO LOG
	XCTR XR,[MOVE TAC1,JOBFDV] ;GET JOB NUMBER OF KILLER
IFN FTUFDB,<
	pushj p,devent		;record this event
	 tro tac,7		;signature of this event
>;IFN FTUFDB
	PUSHJ P,LOGKIL		;TELL KILLEE AND MAYBE CTY WHAT'S HAPPENING
	PUSHJ P,RESETSEG	;FLUSH HIS SEGMENT
	PUSHJ P,IOKILL		;KILL ALL IO WITHOUT WAITING
	PUSHJ P,TTYFND		;FIND TTY
	PUSHJ P,KILSPW		;KILL SPACEWAR
	JRST JOBKL		;LET KJOB ROUTINE DO THE REST

;ENTER HERE FROM RESET COMMAND AS A MONITOR JOB, I.E., RUNNING AT UUO LEVEL.
RESCM1:	MOVEI TAC1,ESTOP
	JSP TAC,MONSTR		;SETUP UUO LEVEL ACS.
	MOVEI TAC,[ASCIZ/RESET /] ;MESSAGE TO LOG
	XCTR XR,[MOVE TAC1,JOBFDV] ;GET JOB NUMBER OF RESETTER
	PUSHJ P,LOGIT		;TELL RESETEE AND MAYBE CTY WHAT'S HAPPENING
	PUSHJ P,RESETU		;CALL THE RESET UUO CODE
	JRST FINRD2		;FINISH UP LIKE FINISH COMMAND DOES

;ENTER HERE FROM FINISH COMMAND AS A MONITOR JOB, I.E., RUNNING AT UUO LEVEL.
FINCM1:	MOVEI TAC1,ESTOP
	JSP TAC,MONSTR		;SETUP UUO LEVEL ACS.
	MOVEI TAC,[ASCIZ/FINISHed /] ;MESSAGE TO LOG
	XCTR XR,[MOVE TAC1,JOBFDV] ;GET JOB NUMBER OF FINISHER
	PUSHJ P,LOGIT		;TELL FINISHEE AND MAYBE CTY WHAT'S HAPPENING
	JRST FINALL		;NOW FINISH OFF ALL DEVICES FOR THIS JOB
;CORE CNOT0 COR3 CORFX CORFX1 COR0 JOB1 JOB1A
;CORE COMMAND.  JOB1
; "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
;"CORE" WITH NO ARG. WILL PRINT NO OF FREE BLOCKS LEFT

CORE:	PUSHJ P,DECIN		;GET NO. OF 1K BLOCKS (OR PAGES!)
	JRST COR4		;NO ARGUMENT - TYPE INFORMANTION
	JRST COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
	MOVE TAC,JBTSTS(J)	;GET JOB STATUS WORD
	TLNN TAC,JLOG		;IS JOB LOGGED IN?
	JRST LOGPLS		;NO, TYPE OUT MESSAGE
	PUSHJ P,CLRTPV		;CLEAR TEMPORARY PRIVILEGES
	PUSH P,TAC1
	LDB TAC1,PSEGN
	SKIPE TAC1		;SKIP IF NO SEGMENT
	PUSHJ P,CORSGT		;GET NUMBER OF WORDS IN SEGEMENT
	MOVN AC1,TAC1		;-CORE SIZE OF UPPER, IF ANY
;;;	ADD AC1,SWAPLIMIT	;RESULT IS MAXIMUM PERMISSIBLE SIZE OF LOWER
	ADD AC1,USRMAX		;BH 7/22/78 USRMAX IS NOW ALWAYS LESS THAN SWAPLI
	LSH AC1,CSHIFT		;CONVERT TO PAGES OR K
	POP P,TAC1		;CORE SIZE HE IS REQUESTING (IN PAGES OR K)
	CAMLE TAC1,AC1		;TOO BIG?
	JRST CORFX1		;YES. TELL HIM SO.
	JUMPN TAC1,CNOT0	;JUMP UNLESS REQUESTING ZERO CORE
	PUSH P,J
	PUSH P,TAC
	MOVE J,TAC1		;Job number of RESETee
	PUSHJ P,KILSPW		;Kill off its spacewar quickly (clobbers TAC)
	POP P,TAC
	POP P,J
CNOT0:	TLNN TAC,SWP		;IS HE SWAPPED OUT?
	JRST COR3		;NO. CONTINUE
	SKIPE JBTPAG(J)		;SKIP IF THERE'S NO CORE IN CORE.
	JRST DLYCR1		;JOB IS IN TRANSIT.  WAIT FOR SWAPPING TO FINISH
	SKIPN TAC,TAC1		;IS HE REQUESTING 0 CORE?
	TROA TAC,1		;YES.  SET CORE SIZE TO 1K - SHRINK BEFORE SWAPIN
	SOSA (P)		;NOT 0.  CORE0K ALWAYS SKIPS - RETURN TO COMRET
	PUSH P,[DLYCOR-1]	;FOR CORE 0, WE DELAY COMMAND AFTER CORE0K
	JRST CORE0K		;SET SWAPIN IMAGIN SIZE.  RETURN, BEING DONE.

COR3:	JUMPE TAC1,COR0		;RELEASE DEVICES IF ASKING FOR 0 CORE
	MOVE TAC,TAC1	
	LSH TAC,-CSHIFT		;CONVERT REQUEST TO WORDS
	SUBI TAC,1		;HIGHEST REL. LOC.
	PUSH P,JBTPAG(J)	;SAVE OLD CORE ASSIGNMENT
	LDB TAC1,PSEGN		;SEE IF HE HAS AN UPPER
	SKIPE TAC1
	PUSHJ P,CORSGT		;YES, GET ITS SIZE INTO TAC1
	ADD TAC1,TAC		;ADD LOWER SIZE + UPPER SIZE
	CAMLE TAC1,USRMAX	;WILL IT FIT?
	JRST CORFX		;NO
;IF THE JOB HAS NO CORE AT ALL, CORE0 WILL ONLY ASSIGN CORE ON THE DISK.  REG
	PUSHJ P,CORE0		;TRY TO ASSIGN CORE
	JRST CORFX		;CAN'T DO IT
	POP P,AC1		;GET BACK OLD CORE ASSIGNMENT
	JUMPN AC1,CPOPJ		;RETURN NOW IF THERE WAS CORE ASSIGNED PREVIOUSLY
	JRST ESTOP2		;PREVENT CONTINUE COMMAND.
				;IMGOUT=0 SO SWAPPER (INJO2) WIPES JOBDAT ON SWAPIN

CORFX:	POP P,(P)		;POP OFF OLD CORE ASSIGNMENT
CORFX1:	MOVE DDB,-2(P)		;GET TTY DDB BACK
	JSP TAC,ERRMES
	ASCIZ /Not enough core
/

COR0:	SKIPN JBTPAG(J)		;HERE FOR CORE 0 COMMAND.  SKIP IF JOB HAS CORE.
	POPJ P,			;RETURN QUICK IF USER HAS NO CORE ALREADY
	MOVSI TAC,TTYRNU!NOPER!NOCRLF
	IORM TAC,-1(P)		;TELL COMRET TO PUT TTY IN USER MODE
IFN FTMONCIP,<
	SKIPLE MONCIP(DDB)
	HRROS MONCIP(DDB)	;SUPPRESS SKPBRK SINCE RUNNING USER PROGRAM
>;IFN FTMONCIP
	AOS AMC9		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP
	JSP TAC1,MONJOB		;SETUP MONITOR JOB.  EXIT TO COMRET.
	MOVEI TAC1,HOLD		;HERE AT UUO LEVEL.  PUT ERROR STOP ON END OF PDL
	JSP TAC,MONSTR		;SETUP ACS FOR MONITOR JOB.
JOB1:	PUSHJ P,RESET		;RELEASE ALL IO DEVICES ASSIGNED TO THIS JOB
	PUSHJ P,TTYFNU		;FIND TTY FOR THIS JOB (SETUP J WITH JOB NO.)
	SETOM STIME(J)		;MARK CORE IMAGE ALTERED
	LDB DAT,PSEGN
	MOVE TEM,JBTSTS(DAT)
	TLNN TEM,JWP
	SETOM STIME(DAT)
	MOVEI TAC,0		;TAC←0 NEW CORE ASSIGNMENT
	PUSHJ P,CORE1		;RELEASE OLD CORE ASSIGNMENT.
	JRST JOB1A		;CORE1 WILL SKIP. - IF IT DOESN'T WE'RE IN TROUBLE
	PUSHJ P,NOCORQ		;JOB TO NULQ.  CLEAR SWAP IMAGE.  RELEASE JBTMAP
IFN FTDRD,<
	SKIPN JBTPAG(J)		;THE FOLLOWING IS MORE DRD CODE
	POPJ P,
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JBTPAG NOT 0 AT JOB1 / 
	PUSHJ P,DISJOB
	PUSHJ P,DISCRLF
	POPACS
>;IFN FTDRD
	POPJ P,

JOB1A:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / CORE1 FAILED TO RELEASE CORE AT JOB1.
/
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCAL
	POPACS
	PUSHJ P,WSCHED		;ALLOW THE ERROR CONDITION TO GO AWAY.
	JRST JOB1
;CSHIFT COR4 COR4A COR2.1
;COR4 - CORE COMMAND WITHOUT ARGUMENT - PRINT STUFF

↑↑CSHIFT←←-9 	;SHIFT FROM WORD COUNT TO PAGES

COR4:	MOVSI TAC,NOINCK	;DON'T INITIALIZE A JOB
	IORM TAC,-1(P)
	MOVE DDB,-2(P)		;RESTORE TTY DDB
	MOVE TAC,JBTSTS(J)	;GET JOB STATUS WORD
	TLNN TAC,JLOG		;IS JOB LOGGED IN?
	JRST COR2.1		;NOT LOGGED IN. HE HAS NO CORE.
	MOVEI TAC1,(J)		;GET JOB NUMBER
	PUSHJ P,CORSGT		;GET CORE SIZE IN WORDS
	LSH TAC1,CSHIFT		;COMPUTE PAGES
	MOVEI TAC,(TAC1)
	PUSHJ P,RADX10
	LDB TAC1,PSEGN
	JUMPE TAC1,COR4A
	PUSHJ P,CORSGT		;CORE SIZE OF UPPER IN WORDS
	LSH TAC1,CSHIFT		;COMPUTE PAGES
	PUSH P,TAC1
	MOVEI TEM,"+"
	XCT TYO
	POP P,TAC
	PUSHJ P,RADX10
COR4A:	PUSHJ P,INLMES
	ASCIZ / pages 
/

COR2.1:	MOVE TAC,USRMAX		;AVAIL CORE.
	CAMLE TAC,SWAPLIMIT	;BIGGER THAN SWAPLIMIT?
	MOVE TAC,SWAPLIMIT	;YES, PRINT IT INSTEAD
	LSH TAC,CSHIFT		;COMPUTE K (OR PAGES)
	PUSHJ P,RADX10		;WRITE
	PUSHJ P,INLMES
	ASCIZ / pages maximum
/
	MOVE TAC,CORMAX		;GET SIZE OF USER CORE
	LSH TAC,CSHIFT		;COMPUTE PAGES
	PUSHJ P,RADX10		;YES, PRINT IT ALSO
	JSP TAC,CONMES		;PRINT MESSAGE AND POPJ
	ASCIZ / pages user core
/
;START STARTC STARTB STARTA STARTE REENTE REENTN REENTM STRTCK
;START, STARTC, REENTE,   START, CSTART, REENTER COMMANDS

; "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
; "CSTART L" OR  "CSTART" - START AT LOC. L(TTY IN COMMAND MODE)

START:					;SAME AS STARTC
STARTC:	PUSHJ P,SKIPSJ			;GET ARGUMENT, IF ANY
	CAIE TEM,"+"
	CAIN TEM,"-"			;REQUESTING INCREMENT?
	JRST STARTA			;YES, SCAN
	PUSHJ P,OCTIN			;CONVERT POSSIBLE OCTAL NO ARG.
	 XCTR XR,[SKIPA TAC1,JOBSA]	;NO ARGUMENT. GET JOBSA
	 JRST COMERA			;ILLEGAL CHARACTER.
	XCTR XR,[CAME TAC1,JOBSA]	;STARTUP ADDRESS TYPED?
	PUSHJ P,CLRTPV			;YES, CLEAR TEMP PRIVILEGES
	HRRZ TAC,TAC1			;GET STARTUP ADDR
	TDZA TAC1,TAC1
STARTB:	XCTR XR,[HRRZ TAC,JOBSA]
	JUMPN TAC,STRTCK		;ADD INCREMENT AND START
	JSP TAC,ERRMES
	ASCIZ /No starting address
/

STARTA:	CAIE TEM,"+"			;+?
	JRST STARTE			;NO, MUST BE -
	PUSHJ P,OCTINS			;YES, READ INC
	SKIPA TAC1,[1]			;INVENT 1 FOR NO ARG
	JRST COMERA
	JRST STARTB

STARTE:	PUSHJ P,OCTINS			;GET - INC
	SKIPA TAC1,[1]			;INVENT 1 FOR NO ARG
	JRST COMERA
	MOVN TAC1,TAC1			;NOW NEGATE
	JRST STARTB

;"REENTER" - REENTER USER PROGRAM
REENTE:	PUSHJ P,SKIPSJ
	CAIN TEM,"-"
	JRST REENTM			;GET - INC
	PUSHJ P,OCTIN
	TDZA TAC1,TAC1			;0 FOR NO ARG
	JRST COMERA			;ILL CHAR
REENTN:	XCTR XR,[HRRZ TAC,JOBREN]
	JUMPN TAC,STRTCK		;ADD INCREMENT AND START
	JSP TAC,ERRMES
	ASCIZ /No Reenter address
/

REENTM:	PUSHJ P,OCTINS
	SKIPA TAC1,[1]
	JRST COMERA
	MOVN TAC1,TAC1
	JRST REENTN

STRTCK:	JUMPE TAC1,.+2			;ANY INCREMENT?
	PUSHJ P,CLRTPV			;YES, CLEAR TEMP PRIVILEGES
	ADD TAC1,TAC			;ADD INCREMENT
	JRST USTART			;NOW START IT UP
;DDTGO DDTG2 DDTG3 DDTPUR DDTGOE
;DDTGO - DDT COMMAND

DDTGO:	XCTR XR,[HRRZ TAC1,JOBDDT] ;DDT STARTING ADR. IN JOB DATA AREA
	SKIPN TAC1		;SKIP IF NO DDT
	JRST DDTGOE		;IT'S A LOSER
	HLRZ TAC,JBTPAG(J)
	LSH TAC,9
	CAIGE TAC1,(TAC)	;SKIP IF DDT IS NOT IN THE LOWER
	JRST USTART		;SETUP JOBOPC, START DDT IN USER MODE.
	CAILE TAC,400000
	MOVEI TAC,400000	;HERE'S WHERE THE UPPER STARTS
	CAILE TAC,(TAC1)	;SKIP UNLESS DDT BETWEEN UPPER AND LOWER
	JRST DDTGOE
	LDB AC1,PSEGN		;GET THE UPPERS JOB NUMBER
	JUMPE AC1,DDTGOE	;NO UPPER, NO DDT
	PUSH P,TAC1
	MOVE TAC1,AC1
	PUSHJ P,CORSGT		;GET SIZE OF UPPER (MAY NOT BE IN CORE)
	MOVE AC1,TAC1
	POP P,TAC1
	LSH AC1,9
	ADD TAC,AC1
	CAIG TAC,(TAC1)		;SKIP UNLESS DDT BEGINS PAST END OF UPPER
	JRST DDTGOE
;KLUDGE TO MAKE SURE DDT MEMORY IS WRITEABLE
	XCTR XR,[MOVE TAC1,JOBPC] ;GET CURRENT PC.  (SEE USTART)
	TLNN TAC1,USRMOD
	JRST DDTG2
	MOVSI TAC,JOBDAC	;MOVE DUMP ACS TO USER'S SHADOW ACS
	XCTR XBLTRW,[BLT TAC,17]
DDTG2:	JSP TAC1,MONJOB		;GET TO UUO LEVEL.  CALL MSTART
	JSP TAC,MONSTR		;HERE AT UUO LEVEL. SETUP ACS.
	PUSHJ P,UNPURE		;TRY TO UNPURIFY UPPER
	JRST DDTPUR		;FAILED TO UNPURIFY UPPER.
DDTG3:	XCTR XR,[HRRZ TAC,JOBDDT] ;DDT STARING ADDRESS.
	XCTR XR,[HLL TAC,JOBOPC] ;WITH HIS OLD FLAGS
	TLO TAC,USRMOD		;SET USER MODE.
IFKL10,<
	TLZ TAC,4037!PCPUBL	;CLEAR IOT-USER AND @() BITS.  SET PRIVATE
>;IFKL10
NOKL10,<
	TLZ TAC,4037		;CLEAR IOT-USER AND @() BITS.
>;NOKL10
	MOVEM TAC,UUOPC(J)	;STORE AS RETURN FROM UUOLEVEL
	JRST USRXIT		;UUOCON "RETURNS" TO DDT'S START ADDRESS.

DDTPUR:	MOVE J,JOB		;J WAS CLOBBERED BY UNPURE.
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
	ASCIZ /Couldn't unpurify upper.  Continue to try anyway/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC		;NOW, FORCE TTY TO TYPE STUFF.
	PUSHJ P,SETSTP		;MAKE US STOP SOON
	JRST DDTG3		;RETURN FROM UUOLEVEL TO DDT,BUT UUOCON WILL STOP US.

DDTGOE:	JSP TAC,ERRMES		;ZERO PRINT "NO DDT"
	ASCIZ /No DDT
/
;STOP STOPB STOPB1 MAKCNC MAKCN2 CONTC CONT NOCONT

;STOP, "HALT" OR "<CONTROL>C",  CONT, CONTC - CONTINUE AND CCONTINUE COMMAND
;SCANNER ROUTINES DUMMY UP 'HAL' (HALT) WHEN CONTROL C TYPED IN.
;STOP MUST BE DELAYED IF THIS JOB IS SYSTEM TAPE USER
;AND SYSTEM TAPE IS ACTIVE. OTHERWISE, THE JOB WILL NOT BE
;STOPPED WHEN DONE USING THE SYSTEM TAPE.


↑STOP:	JUMPE J,STOPB
	MOVSI TAC,JNA		;MAKE SURE THIS JOB IS FULLY INITIALIZED.
	IORM TAC,JBTSTS(J)	;(SINCE HE MAY HAVE BEEN IN CMWQ BEFORE CALL)
	PUSHJ P,STOPCK		;CAN THE JOB STOP? (CHECK DSK DDBS)
	JRST MAKCNC		;PUT BACK CONTROL C.
	PUSHJ P,STOP1		;STOP JOB
STOPB:	MOVSI TAC,JACCT
	ANDCAB TAC,JBTSTS(J)	;GOODBYE LOSER!
	TLNN TAC,JLOG		;IS JOB LOGGED IN?
	JUMPN J,STOPB1		;NO.  JUMP IF THERE'S A JOB NUMBER ASSIGNED
	MOVE TAC1,LINSAV
	MOVE TAC1,TTYTAB(TAC1)	;DDB
	MOVEI TAC,25		;ROOM TO PRINT ↑C CRLF AND DOT and fill, etc.
	CAML TAC,TOFCTR(TAC1)	;SEE IF WE HAVE ENOUGH ROOM IN OUTPUT BUFFER
	JRST MAKCN2		;NOT ENOUGH ROOM IN BUFFER, TRY AGAIN LATER
	MOVEI TAC,[BYTE(7)"↑","C",15,12]	;↑C CRLF
	JRST CONMES		;PRINT ↑C CRLF.  RETURN TO COMRET

;HERE TO KILL UNLOGGED-IN JOB THAT TYPES ↑C.  INVENT A K COMMAND FOR THEM.
STOPB1:	SUB P,[2,,2]		;FLUSH RETURN TO COMRET + MAGIC BITS/DISPATCH
	JRST SCREWU		;ONCE MORE THRU THE COMMAND LOOP.  WITH A 'K'.

MAKCNC:	MOVE TAC1,LINSAV
	MOVE TAC1,TTYTAB(TAC1)
	MOVEI TAC,600
	DPB TAC,TITAKR(TAC1)
	JRST DLYCR1		;DON'T REQUE, OR HE WON'T GET OUT OF THIS STATE!!!

MAKCN2:	MOVEI TAC,600		;PUT THE ↑C BACK
	DPB TAC,TITAKR(TAC1)
	JRST DLYCM2		;Wait for output buffer to empty.

;CCONTINUE, CONTINUE,

; "CCONT" - CONTINUE EXECUTION(TTY REMAINS IN COMMAND MODE)
; "CONT" - CONTINUE EXECUTION FROM WHERE LEFT OFF

CONTC:				;SAME AS CONT
CONT:	MOVSI TAC1,JERR
	TDNE TAC1,JBTSTS(J)	;IS JOB ERROR BIT SET?
	JRST NOCONT		;YES, LOSE
	MOVNI TAC1,RUNQ		;NO, REQUE TO RUN QUEUE
	MOVEM TAC1,JOBQUE(J)
	JRST REQUE

NOCONT:	JSP TAC,ERRMES		;YES, PRINT CANT CONTINUE
	ASCIZ /Can't continue
/
;SETWPS CLRWPS NOSPRO NOSPR1 SETRLC WPGTUP WPSEG NXSEG ILLPRO
;SETUWP CLRUWP COMMANDS, SETWPS, CLRWPS


SETWPS:	PUSH P,[-1,,0]		;NO PRO BITS YET
	CAIA
CLRWPS:	PUSH P,[0]		;NO PRO BITS YET
	PUSHJ P,OCTIN
	 JRST NOSPRO		;NO SET PRO
	 JRST [	POP P,(P)
		JRST COMERA	]
	CAILE TAC1,777		;LEGAL?
	JRST ILLPRO
	TRO TAC1,400000		;FLAG THAT ARGUMENT WAS TYPED.
	HRRM TAC1,(P)		;STORE ARGUMENT.
NOSPRO:	PUSH P,J		;MUST PUSH THIS - ARG TO ACCESS.
	LDB J,PSEGN
	JUMPE J,NXSEG
	PUSHJ P,ACCESS
	 JRST WPSEG
	 JRST WPSEG
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		;OK TO GO HEAD IF UPPER IS IN CORE
	JRST WPGTUP		;GET IT IN, NOW.
	HRRZ TAC1,-1(P)		;GET PRO BITS
	TRNN TAC1,400000	;IS HE REQUESTING BIT SETTINGS?
	JRST NOSPR1		;NO
;	MOVE TAC1,(P)			;JOB NUMBER OF LOWER
;	MOVE TAC1,JBTPRV(TAC1)
;	TLNN TAC1,SEGPRV		;DOES HE HAVE PRIV?
	TRNN TAC,400		;NO, CHECK PROTECTION PROTECTION
	CAIA			;OKAY TO DIDDLE
	JRST WPSEG		;LOSE
	HRRZ TAC1,-1(P)		;GET BITS AGAIN
	ANDI TAC1,377		;DON'T LET HIM SET UNPURIFIED BIT
	DPB TAC1,[POINT 9,JOBCRD(J),8]
NOSPR1:	MOVSI TAC,JWP
	SKIPGE -1(P)
	IORB TAC,JBTSTS(J)	;SETUWP
	SKIPL -1(P)
	ANDCAB TAC,JBTSTS(J)	;CLRUWP
	POP P,-1(P)		;MOVE J BACK ONTO FLAG
	HLRZ AC1,JBTPAG(J)	;GET NUMBER OF PAGES IN SEGMENT
	LSH AC1,9		;CONVERT TO SEGMENT WORD COUNT
	ADDI AC1,400000-1	;SEGMENT PROTECTION
	TLNE TAC,JWP
	TLO AC1,400000		;SET WP BIT IF JWP SET
	PUSHJ P,UAPPLY		;APPLY TO ALL LOWERS
	 PUSHJ P,SETRLC		;(ARGUMENT TO UAPPLY)
	LDB DDB,[POINT 1,JBTSTS(J),JWPPOS]
	PUSHJ P,WPMAPL		;SET WRITE PROTECT ACCORDING TO DDB
	PUSHJ P,AUPMAP		;CHANGE ALL LOWERS OF OUR UPPER
	POP P,J
	POPJ P,

SETRLC:	SKIPN JBTPAG(J)
	POPJ P,			;LOWER IS NOT INCORE.
	AOS AMC10		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP MAP TO POINT TO THE LOWER
	XCTR XW,[MOVEM AC1,JOBRL2]
	POPJ P,

WPGTUP:	MOVSI TAC,COMSNB
	PUSHJ P,SETSIN		;GET THE UPPER IN CORE
	POP P,J			;GET LOWER'S JOB NUMBER BACK
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	;KEEP LOWER IN CORE
	POP P,(P)		;FLUSH FLAGS
	JRST DLYCM1		;AND DELAY

WPSEG:	SKIPA TAC,[[ASCIZ /Protection failure
/]]
NXSEG:	MOVEI TAC,[ASCIZ /No upper segment
/]
	SUB P,[2,,2]
	JRST ERRMES

ILLPRO:	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /Illegal protection code
/
;DISABL ENABLE NXPRV ILLPRV LFTTAB LFTLEN RHTTAB RHTLEN PRVSET FNDLFT FNDRHT ISALL ISLFT ISRHT
;DISABL, ENABLE PRIVILEGES

DISABL:	PUSHJ P,PRVSET		;GET BIT INTO TAC
	 JRST NXPRV		;NO SUCH PRIVILEGE
	 JRST NOTENF		;DISABLE WHAT?
	 JFCL			;CAN'T ENABLE THIS PRIV, BUT LET DISABLE IT
	JUMPN TAC,.+2		;JUMP IF A SPECIFIC PRIV TYPED
	MOVE TAC,[<-1-LUPPRV>,,<-1-LIVPRV>]	;"DIS ALL" CLEARS ALL BUT THESE
;;;	TDNE TAC,[ENACTV]
	ANDCAM TAC,JBTPRV(J)	;TURN OFF IN ACTIVE PRIV
;;;	TDNE TAC,[ENPASS]
	ANDCAM TAC,JB2PRV(J)	;TURN OFF IN PASSIVE PRIV
	POPJ P,

ENABLE:	PUSHJ P,PRVSET
	 JRST NXPRV		;NO SUCH PRIVILEGE
	 JRST NOTENF		;ENABLE WHAT?
	 JRST ILLPRV		;NOT LEGAL FOR THIS USER
	JUMPE TAC,ILLPRV	;"ENA ALL" ILLEGAL
	LDB TAC1,PUNIT		;GET LINE NUMBER
	HLL TAC1,LINTAB(TAC1)	;GET LINE CHARACTERISTICS
	TLNN TAC1,DISLIN!DDDLIN!CTYLIN ;LOCAL LINE (REALLY!)?
	TLNN TAC,LUPPRV		;NO, CAN'T HAVE LOCAL USER PRIV
	JRST .+2
	JRST ILLPRV
	TDNE TAC,[ENACTV]
	IORM TAC,JBTPRV(J)	;TURN ON IN ACTIVE PRIV
	TDNE TAC,[ENPASS]
	IORM TAC,JB2PRV(J)	;TURN ON IN PASSIVE PRIV
	POPJ P,

NXPRV:	JSP TAC,ERRMES
	ASCIZ /No such privilege
/

ILLPRV:	JSP TAC,ERRMES
	ASCIZ /You can't have it
/

LOSYS			;PUT PRIVILEGE NAMES IN LOW CORE FOR PEEK TO SEE

DEFINE XLPRIV(NAM,VAL)<	'NAM',,VAL>
DEFINE XRPRIV(NAM,VAL)<>

↑LFTTAB:PRIVS
↑LFTLEN←←.-LFTTAB

DEFINE XLPRIV(NAM,VAL)<>
DEFINE XRPRIV(NAM,VAL)<'NAM',,VAL>

↑RHTTAB:PRIVS
↑RHTLEN←←.-RHTTAB

HISYS

PRVSET:	PUSHJ P,CTEXT1
	JUMPE TAC1,CPOPJ1	;CR OR DELIM TYPED
	CAMN TAC1,['ALL   ']
	JRST ISALL		;'DIS ALL' TO CLEAR ALL PRIVS
IFG LFTLEN,<
	MOVSI TAC,-LFTLEN	;LENGTH OF LEFT TABLE
FNDLFT:	HLLZ AC1,LFTTAB(TAC)
	CAMN AC1,TAC1
	JRST ISLFT
	AOBJN TAC,FNDLFT
>;LFTLEN
IFG RHTLEN,<
	MOVSI TAC,-RHTLEN
FNDRHT:	HLLZ AC1,RHTTAB(TAC)
	CAMN AC1,TAC1
	JRST ISRHT
	AOBJN TAC,FNDRHT
>;RHTLEN
	POPJ P,			;NO SUCH PRIVILEGE

ISALL:	TDZA TAC,TAC		;0 FLAGS 'ALL'
ISLFT:	HRLZ TAC,LFTTAB(TAC)	;LEFT HALF BIT
	CAIA
ISRHT:	HRRZ TAC,RHTTAB(TAC)	;RIGHT HALF BIT
	AOS (P)
	AOS (P)			;AT LEAST 2 SKIPS
	JUMPE TAC,CPOPJ1	;ENA ALL WILL BE CAUGHT UPLEVEL
	TDNE TAC,[<ENPASS>!<ENACTV>] ;LEGAL TO ENABLE?
	AOS (P)
	POPJ P,
;PRJOB PRCNFG HELLO ALOGIN ALOGN1 SETTPV CLRTP0 CLRTPV ;⊗ PRJOB PRCNFG HELLO ALOGIN ALOGN1 SETTPV CLRTP0 CLRTPV

PRJOB:	PUSHJ P,INLMES
	ASCIZ /Job /
	MOVE TAC,J
	PUSHJ P,RADX10
	PUSHJ P,PRSPC
PRCNFG:	MOVEI TAC,CONFIG
	JRST CONMES

HELLO:	MOVEI TAC,[ASCIZ /System down for debugging.  /]
	SKIPN TTYLOK
	SKIPE MAINTM
	PUSHJ P,CONMES		;report that the system is down since it is
	PUSHJ P,PRCNFG		;TELL HIM WHAT FLAVOR SYSTEM WE ARE!
	JRST CRLF		;TYPE CRLF


ALOGIN:	MOVEM TAC,PRJPRG(J)
	SETZM JBTUFD(J)
	SETZM DSKPPN(J)		;INTIALIZE DISK ALIAS PPN
	SETZM JBTKCJ(J)
	SETZM JBTMSC(J)
	SETZM JBTDDB(J)		;NO DDB FOR WHOLINE
	MOVSI TAC,JLOG
	ANDCAM TAC,JBTSTS(J)
ALOGN1:	PUSHJ P,TTYATI		;MAKE SURE TTY IS ATTACHED IN CASE THIS
	JFCL			;COMMAND MUST BE DELAYED BECAUSE NO CORE YET.
	POPJ P,

SETTPV:	IORM TAC,JBTPRV(J)	;GIVE HIM THE TEMP PRIVS
	MOVSI TAC,TEMPPR	;NOTE SPECIAL TEMPORARY PRIVS ON
	IORM TAC,JBTMSC(J)
	POPJ P,

;Clear temporary privs.  Cmds that run new program clear all active privs.
;Other commands allow program-enable-able privs to stay on (real priv'd user).
;Enter here only from COMDIS, with command bits in LH TAC1.
CLRTP0:	TLNN TAC1,NORUN		;Command legal while program running?
	JRST CLRTPV		;Yes, just clear privs user doesn't own.
	SETZM JBTPRV(J)		;Clear all active privs when running a program
	POPJ P,

;Command routines that only clear temp privs in some cases call this routine,
;since such commands never run a new program.
CLRTPV:	PUSH P,TAC
	SETCM TAC,JB2PRV(J)	;Get bits we don't have in passive privs
	ANDCAM TAC,JBTPRV(J)	;And turn them off in active privs
	JRST TPOPJ
;LOGDET LOGREF CLOGNF CLOGIN CXLOGI FLOGI2
;CLOGIN		LOGIN COMMAND

LOGDET:	JSP TAC,ERRMES
	ASCIZ /You are already logged in
/

;HERE FOR ONE FREE LOGIN WHEN REFLAG IS SET
LOGREF:	MOVEM TAC,PRJPRG(J)	;PPN FROM REFLAG
	MOVSI TAC,JLOG
	IORM TAC,JBTSTS(J)	;LOG HIM IN.
	MOVE TAC,[NXPRIV]
	TLO TAC,NSLPRV		;Don't give him the negative SL anti-priv!
	SETCAM TAC,JB2PRV(J)	;GIVE HIM ALL THE real PRIVS!
	SETZM -1(P)		;CLEAR ALL FLAGS FOR COMRET.
	SKIPN MAINTM		;During maintenance, keep lettin' 'em in
	SETZM REFLAG		;ONLY ONCE.
	POPJ P,

CLOGNF:	HLLOS SAVSAI(J)		;START LOGIN AT SA-1 FOR ATTACH COMMAND
	LDB TAC,ARGBPT		;HAVE WE ALREADY SAVED A JOB NUMBER?
	JUMPN TAC,FLOGI2	;YES, WE'VE BEEN DELAYED, DON'T DO IT AGAIN
	DPB J,ARGBPT		;NO, SAVE ORIGINAL JOB NUMBER TO TELL LOGIN
	SKIPE JBTPAG(J)		;DON'T DO FORK IF NO CORE IMAGE TO CLOBBER 
	TLNN AC1,JLOG		;FORCED LOGIN FROM ATTACH COMMAND
	JRST FLOGI2		;WE CAN FIRE UP LOGIN IN THIS JOB
	JRST FORK		;ALREADY LOGGED IN WITH CORE, GET US A NEW JOB

CLOGIN:	TLNE AC1,JLOG		;IS HE LOGGED IN?
	JRST LOGDET		;YES. REMIND HIM
	SKIPE TAC,REFLAG	;DEC 3.16
	JRST LOGREF		;DEC 3.16
	TDZA TAC,TAC
CXLOGI:	MOVEI TAC,1
	HRRM TAC,SAVSAI(J)	;SET STARTING OFFSET.
FLOGI2:	MOVE TAC,DUMPPN		;SET PRJPRG TO DMPPPN
	MOVEM TAC,JOBPPN(J)	;LOGIN.DMP IS ON [1,2]
	MOVE AC1,JBTSTS(J)	;THIS HAS BEEN CLOBBERED BY FORK IF F.LOG
	TLNN AC1,JLOG		;PRESERVE OUR PPN IF ALREADY LOGGED IN
	PUSHJ P,ALOGIN		;AUTOMATIC LOGIN
	MOVSI TAC,JACCT		;FLAG ACCOUNTING PROGRAM RUNNING
	IORM TAC,JBTSTS(J)
	PUSHJ P,SKPBRK		;(NOTE: REAL LOGIN BETTER NOT EVER AXXCOM)
	LDB TEM,ARGBPT		;GET ORIGINAL JOB NUMBER FOR LOGIN
	HRL TEM,SAVDDB(DDB)	;ALSO GET TARGET JOB NUMBER
	MOVSI TAC,REAPRV	;NEED THIS TO READ THE FILE IF NOT 1,2
	IORM TAC,JBTPRV(J)
	MOVE TAC,[SIXBIT /LOGIN/]	;LOGIN FILE NAME.
	MOVEM TAC,JOBNAM(J)	;STORE FILE NAME
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI TAC1,'DSK'	;READ FROM DSK, DMPPPN AREA.
	JRST RUNCO4		;ENTRY POINT TO USE NONSTANDARD JOBPPN
;⊗ HELP1 HLPRUN HELPX WHOCOM ERPGCM RPGCOM ACCCOM ETCOM PUMCOM DSCCOM CPYCOM ORACOM WHECOM TSTCOM MAICOM TSTCO2 FNDCOM DRDCOM SPLCOM NICCOM PRSRUN ATCOM TNCOM SDCOM LSPCOM TLKPGM UNPCOM UNDCOM UDPCOM UNPCO1 NSCOM3 FNGCOM CKMCOM CKMCO2 DSKCOM NSCOM2 NSCOM NSCOM1 HOTCOM HOTCOM MRDCOM MCOCOM MCOCO2
;COMMANDS THAT RUN PROGRAMS.

HELP1:	MOVE TAC,HELPPP
	TLNE AC1,JLOG
	POPJ P,			;RETURN IF LOGGED IN ALREADY. 
	PUSHJ P,ALOGIN
	AOS (P)			;SKIP RET TO ALLOW LUP FOR WHO
	JRST SETLOG		;AND SET-UP LOGIN STUFF

HLPRUN:	PUSH P,UUO		;ANY CMD WHICH RUNS SAME-NAME PGM
HELPX:	PUSHJ P,HELP1
	 JFCL
	JRST ARCOM

WHOCOM:	PUSH P,['WHO   ']
	PUSHJ P,HELP1
	 JRST ARCOM
	MOVSI TAC1,LUPPRV	;GIVE 100,100 THE LOCAL USER PRIV
	IORM TAC1,JB2PRV(J)	;BECAUSE HE CAN'T HARM US
	JRST ARCOM

ERPGCM:				;HERE FOR EDIT-STYLE RPG-COMMANDS
RPGCOM:	PUSH P,['SNAIL ']
	JRST AXXCOM

ACCCOM:	PUSH P,['ACCESS']
	MOVSI TAC,AAOPRV!REAPRV
	JRST NSCOM3		; DON'T CALL UNPCO1

ETCOM:	PUSH P,['E     ']
	JRST ARCOM

PUMCOM:	MOVSI TAC,REAPRV!WRTPRV
	PUSHJ P,SETTPV		;PUMPKIN COMMAND NEEDS TO WRITE PROTECTED FILE
DSCCOM:	PUSH P,['DART  ']
	JRST HELPX

CPYCOM:	PUSH P,['COPY  ']
	JRST HELPX

ORACOM:	PUSH P,['ORACLE']
	JRST HELPX

WHECOM:	PUSH P,['WHERE ']
	JRST HELPX

TSTCOM:	PUSH P,['TEST  ']
	JRST TSTCO2

MAICOM:	PUSH P,['MAIL  ']
TSTCO2:	PUSHJ P,HELP1
	JFCL
	JRST AXXCOM

FNDCOM:	PUSH P,['FIND  ']
	JRST HELPX

DRDCOM:	PUSH P,['DIRED ']
	JRST ARCOM

SPLCOM:	PUSH P,['SPOOL ']
	JRST HELPX

NICCOM:	PUSH P,['WHOIS ']
	JRST HELPX

IFN PUPNUM,<
PRSRUN:	PUSH P,['PRESS ']	;Dover Command.  Maybe more?
	JRST ARCOM
>;IFN PUPNUM

ATCOM:	PUSH P,['ATSIGN']
	JRST ARCOM

IFN FTIP!PUPNUM,<
TNCOM:	PUSH P,['TELNET']
	JRST ARCOM
>;IFN FTIP!PUPNUM

IFN FTIP,<
SDCOM:	PUSH P,['SUPDUP']
	JRST ARCOM
>;IFN FTIP

LSPCOM:	PUSH P,['MACLSP']
	JRST ARCOM

TLKPGM:	PUSH P,['TALK  ']
	JRST ARCOM

UNPCOM:	PUSH P,['UNPROT']	;UNPROTECT A FILE REGARDLESS
	MOVSI TAC,REAPRV!WRTPRV!PROPRV
	JRST UNPCO1		;MUST BE LOCAL

UNDCOM:	PUSH P,['UNDEL ']	;UNDELETE A USER'S FILE
	MOVSI TAC,INFPRV
	JRST UNPCO1

UDPCOM:	PUSH P,['UFD   ']
	MOVSI TAC,INFPRV!DAWPRV!REAPRV!WRTPRV!PROPRV
UNPCO1:	MOVE TAC1,JB2PRV(J)	;GET USER'S REAL PRIVS (PASSIVE)
	TLNN TAC1,LUPPRV	;IS HE LOCAL?
	JRST NSCOM2		;NOPE, FLUSH HIM
NSCOM3:	PUSHJ P,SETTPV		;SET TEMPORARY PRIVILEGES
	PUSH P,['  1  2']
	JRST ARPCOM

FNGCOM:	PUSH P,['FINGER']	;needs REA to check protected mailboxes
	PUSHJ P,HELP1		;MAKE SURE THERE'S A JOB THERE!
	 CAI
	MOVSI TAC,REAPRV!WRTPRV	;needs to look at protected mail files
	JRST NSCOM3

CKMCOM:	PUSH P,['CKMAIL']
CKMCO2:	PUSHJ P,HELP1		;MAKE SURE THERE'S A JOB THERE!
	 CAI
	MOVSI TAC,REAPRV	;GIVE HER REA TO CHECK PROTECTED MAILBOXES
	JRST NSCOM3

DSKCOM:	PUSH P,['DSKSIZ']
	MOVSI TAC,INFPRV!REAPRV
	JRST NSCOM3

NSCOM2:	POP P,TAC
	JRST COMERR		;PRETEND IGNORANCE

IFN FTNEWS,<
NSCOM:	PUSH P,['NS    ']
NSCOM1:	MOVE TAC,JB2PRV(J)	;GET USER'S REAL PRIVS (PASSIVE)
	TLNN TAC,LUPPRV		;IS HE LOCAL?
	JRST NSCOM2		;NOPE, FLUSH HIM
	MOVSI TAC,REAPRV
	JRST NSCOM3

HOTCOM:	PUSH P,['HOT   ']
	JRST NSCOM1
>;IFN FTNEWS

IFE FTF2,<
IFE FTNEWS,<
HOTCOM:	NSCOM:
	JSP TAC,ERRMES
ASCIZ /The News Service is unavailable due to lack of computing resources
/
>;NO NEWS
>;IFE FTF2

IFN FTF2!FTKLB,<
MRDCOM:	PUSHJ P,SKPBRK
	MOVE TAC1,['MREAD ']
	MOVEM TAC1,JOBNAM(J)	;SET JOB NAME
IFN FTSTAT,< PUSHJ P,NAMSTT >
	SETZM JOBPPN(J)		;DISABLE JOBPPN KLUGE FOR SGSET
	MOVEI IOS,MRDJOB	;SPECIAL DISPATCH TO SET UP USER CORE TO READ TAPE
	MOVSI TAC1,'SYS'	;DEVICE, SORT OF
	JRST RUNCM		;GO START JOB
>;IFN FTF2!FTKLB

;Here for MCOPY command - master tape copy.
MCOCOM:	MOVE TAC,PRJPRG(J)	;see if we're right user
	MOVE TAC1,DSKPPN(J)	;or aliased to right place
	CAMN TAC,[' MCSYS']	;must be this user
	JUMPE TAC1,MCOCO2	;OK unless aliased elsewhere
	MOVE TAC,JB2PRV(J)	;aliased there, must also have right priv
	CAMN TAC1,[' MCSYS']	;not right user, maybe aliased there
	TLNN TAC,INFPRV		;must have the priv too
	JRST COMERR		;sorry, lose
MCOCO2:	PUSH P,['MCOPY ']	;program to run
	PUSH P,[0]		;run program off own area (verified PPN above)
	JRST ARPCOM		;do it
;CMDRUN ARCOM AXCOM ARCOM1 AXXCOM ARPCOM RCOM RUNCOM RUNCO2 RUNCO4 RUNCM RUNCO1 NOTPR0 NOTPRC GET SSAVE SAVE

;ARCOM---CALL WITH JOBNAM STACKED.  RUN IT FROM SYS:
;AXCOM---SAME AS ARCOM, EXCEPT JOB STARTS AT C(JOBSA)+1
;CMDRUN--RUNS PROGRAM OF SAME NAME AS COMMAND

CMDRUN:	PUSH P,UUO
ARCOM:	TDZA TAC,TAC		;AUTOMATIC RUN COMMAND
AXCOM:	MOVEI TAC,1		;START WITH OFFSET=1
	PUSHJ P,SKPBRK
ARCOM1:	HRRM TAC,SAVSAI(J)	;SET STARTUP OFFSET
	POP P,JOBNAM(J)		;STORE FILE NAME
IFN FTSTAT,< PUSHJ P,NAMSTT >
	MOVSI TAC1,'SYS'	;READ FROM SYSTEM DEVICE
	JRST RUNCO2

;START UP WITH DOUBLE-SKIP C(JOBSA)+2, TTY POINTS TO THE REST OF LINE
AXXCOM:	MOVSI TAC,NOSKPB	;DOUBLE-SKIP ENTRY
	IORM TAC,-2(P)		;TELL COMRET NOT TO CALL SKPBRK (JOBNAME STILL ON STACK)
	MOVEI TAC,2		;SET FOR DOUBLE-SKIP ENTRY
	JRST ARCOM1

;ARPCOM: CALL WITH JOBNAM STACKED, AND PPN STACKED TOO!

ARPCOM:	HLLZS SAVSAI(J)		;ZERO STARTING OFFSET
	POP P,JOBPPN(J)		;SETUP SGSET KLUDGE
	PUSHJ P,SKPBRK		;SKIP TO END OF LINE
	POP P,JOBNAM(J)
IFN FTSTAT,< PUSHJ P,NAMSTT >
	MOVSI TAC1,'DSK'	;READ FROM DSK
	JRST RUNCO4

;"R CUSPNAME CORE" - DOES "RUN SYS:CUSPNAME"
RCOM:	PUSH P,[0]		;ZERO OUT PROGRAM NAME
	MOVEI TAC,0
	JRST ARCOM1

;"RUN DEVICE:FILE[PROJECT,PROGRAMMER] (CORE)"
;DOES A CORE,GET,START ALL IN ONE
;IF CORE ARG IS MISSING, SIZE IN DIRECTORY IS USED


RUNCOM:	PUSHJ P,CTEXT1		;GET DEVICE NAME FROM COMMAND STRING
	SETZM JOBNAM(J)		;CLEAR OUT OLD JOB NAME
IFN FTSTAT,< PUSHJ P,NAMSTT >
	HLLZS SAVSAI(J)		;CLEAR STARTUP INCREMENT
RUNCO2:	SETZM JOBPPN(J)		;DISABLE JOBPPN KLUGE FOR SGSET
RUNCO4:	MOVEI IOS,RUNJOB
	MOVSI TAC,JACCT
	TDNN TAC,JBTSTS(J)	;Skip if this is LOGIN/LOGOUT
	JRST RUNCM		;No accounting for this program
	MOVSI TAC,TEMPPR	;Remember that this job was special
	IORM TAC,JBTMSC(J)
RUNCM:	PUSH P,IOS		;SAVE DISPATCH
	MOVEI TAC,LIVPRV	;LIV PRIVILEGE (PREVENTING AUTOLOGOUT)
	ANDCAM TAC,JB2PRV(J)	; GOES AWAY WHEN YOU RUN ANOTHER PROGRAM
	SKIPE JBTPAG(J)		;SKIP IF THERE'S NO CORE FOR THIS JOB
	JRST RUNCO1	
	PUSH P,TAC1		;SAVE DEVICE NAME
	MOVEI TAC,ASSPRG	;CLEAR TTY "ASSIGNED BY PROGRAM" BIT
	ANDCAM TAC,DEVMOD(DDB)
	MOVEI TAC,JOBDA		;REQUEST JUST ENOUGH CORE FOR A JOB DATA AREA
	PUSHJ P,CORE0		;IF OLD CORE (DEVICE ASSIGNMENTS RETAINED
	JFCL			;CAN'T BECAUSE EITHER NO ROOM OR ACTIVE IO
	POP P,TAC1		;RESTORE DEVICE NAME
RUNCO1:	POP P,IOS		;ADR. OF MONITOR JOB
	SKIPN JBTPAG(J)		;SKIP IF WE HAVE CORE IN CORE
	JRST DLYCOR		;DELAY IF CORE ASSIGNED IS ON THE DISK
	AOS AMC11		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP APR MAP SO XCTR WILL WORK.
	XCTR XW,[SETZM 0]	;Clear all user ACs
	MOVEI AC2,1		;BLT source is 0, dest is 1
	XCTR XBLTRW,[BLT AC2,17] ;clear out the old user ACs just in case
	MOVE AC2,JBTMSC(J)	;get job misc flags
	TLNN AC2,TEMPPR		;job been priv'd?
	JRST NOTPR0		;no
	PUSH P,AC1
	HLRZ AC1,JBTPAG(J)	;number of pages in the job
	LSH AC1,9		;make it words
	XCTR XW,[SETZM JOBPFI+1] ;clear most of core, but avoid JOBJDA
	MOVE AC2,[JOBPFI+1,,JOBPFI+2]
	XCTR XBLTRW,[BLT AC2,-1(AC1)] ;yes, clear out the old user core just in case
	POP P,AC1
NOTPR0:	MOVSI AC2,JACCT
	TDNE AC2,JBTSTS(J)	;Skip unless job is LOGIN/LOGOUT (priv'd!)
	JRST NOTPRC		;Don't clear temp priv flag
	MOVSI AC2,TEMPPR
	SKIPN JBTPRV(J)		;Skip if we've given this job special privs
	ANDCAM AC2,JBTMSC(J)	;Note no special temporary privs on now
NOTPRC:	XCTR XW,[MOVEM UUO,COMWRD] ;PUT COMMAND IN AC FOR PROGRAM TO SEE
	XCTR XW,[MOVEM TEM,CHRWRD] ;ALSO DELIMITER CHAR
	SETZM SAVDDB(DDB)	;FLUSH POSSIBLE ARGUMENT FROM ATTACH TO LOGIN
	SKIPN AC2,JOBPPN(J)	;SPECIAL PPN HACK?
	JRST SGSET		;NO
	JRST SGSET0		;YES. SPECIAL ENTRY

;"GET DEVICE:FILE-NAME[PROJ.,PROG.] CORE" - SETS UP JOB AREA FROM RETREIVABLE
;DEVICE AND ASSIGNS CORE.


GET:	MOVEI IOS,GETJOB	;SETUP TO RUN GETJOB
	PUSHJ P,CTEXT1		;GET DEVICE NAME
	SETZM JOBNAM(J)		;CLEAR JOB NAME
IFN FTSTAT,< PUSHJ P,NAMSTT >
	SETZM JOBPPN(J)		;DISABLE JOBPPN KLUGE FOR SGSET
	JRST RUNCM


;"SAVE FILE-NAME[PROJ.,PROG.] CORE" - SAVES JOB AREA ON RETRIEVABLE DEVICE
;ONLY A SAVE OR A GET IN PROGRESS FOR EACH JOB
;NO ATTEMPT IS MADE TO SAVE DEVICE ASSIGNMENTS, AC'S, OR PC


SSAVE:	TROA IOS,SSAVJB		;SAVE UPPER ALSO (IOS CLEARED BEFORE DISPATCH)
SAVE:	MOVEI IOS,SAVJOB	;SETUP TO RUN SAVJOB 
	PUSHJ P,PRVCHK		;CAN WE ALLOW THIS SAVE?
	 JRST COMERR		;NOPE
	PUSHJ P,CTEXT1		;GET THE FIRST COMMAND ARGUMENT (DEV OR FILENAME)
	SETZM JOBNAM(J)		;CLEAR JOB NAME.
IFN FTSTAT,< PUSHJ P,NAMSTT >
	JRST SGSET		;SCAN THE REST OF THE ARGUMENTS
;⊗ ASSIGN ASSPP9 ASSPP1 ASSPP2 ASSPP3 ASSPP0 PUBBIT PRIBIT OLDBIT ASATTT NASATT ASATTB ASATBB ASSPP2 ASSPPX ASSG3 ASSG0 ASSG4 ASSUDP ASSUD1 ASSUD1 ASSUD2 AUDPPV ASSUD4 ASSUD5 ASSUD3 AUDPPB AUDPNU AUDCCN AUDFOO AUDPOL AUDOK ASSCKS ASCKS1 ASCKS2 ASCKS9 ASSG1 ASSG2

; "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME

BEGIN ASSIGN

↑ASSIGN:MOVEI AC1,0		;START WITH NO ATTRIBUTES
ASSPP9:	PUSHJ P,CTEXT1		;GET FIRST ARGUMENT
	JUMPE TAC1,NOTENF	;NO ARGUMENT TYPED IF 0
	MOVEI AC2,0
	MOVSI TAC,770000
ASSPP1:	TDNN TAC,TAC1
	JRST ASSPP2
	IORM TAC,AC2		;MAKE MASK FOR NUMBER OF CHARACTERS TYPED
	LSH TAC,-6
	JUMPN TAC,ASSPP1
IFN UPACKS,<
ASSPP2:	MOVSI TAC,-NASATT
ASSPP3:	CAMN TAC1,ASATTT(TAC)
	JRST ASSPP0		;EXACT MATCH.  GET BITS AND LOOP
	MOVE AC3,ASATTT(TAC)	;GET NAME OF ATTRIBUTE
	AND AC3,AC2		;AND WITH MASK
	CAMN TAC1,AC3
	TLON AC1,400000(TAC)
	AOBJN TAC,ASSPP3
	JUMPL TAC,ASSPPX	;AOBJN DIDN'T FALL THROUGH (TOO MANY MATCHES)
	JUMPGE AC1,ASSPPX	;IF SIGN BIT OFF THERE WERE NO MATCHES
	LDB TAC,[POINT 17,AC1,17] ;GET INDEX OF MATCHING ENTRY
ASSPP0:	TDNE AC1,ASATBB(TAC)	;CHECK FOR EXCLUDED BITS
	JRST COMERR		;NAUGHTY NAUGHTY
	IOR AC1,ASATTB(TAC)	;OK, TURN ON NEW BIT
	MOVEI AC1,(AC1)		;FLUSH CRUFT IN LH
	JRST ASSPP9

PUBBIT←←1
PRIBIT←←2
OLDBIT←←4

ASATTT:	'PUBLIC'
	'PRIVAT'
	'OLD   '
NASATT←←.-ASATTT

ASATTB:	PUBBIT
	PRIBIT
	OLDBIT
IFN .-ASATTB-NASATT,<PRINTS /SOMEONE CAN'T COUNT AT ASATTB
/>

ASATBB:	PRIBIT!OLDBIT		;TABLE OF BITS NOT ALLOWED WITH NEW ONE
	PUBBIT!OLDBIT
	PUBBIT!PRIBIT
IFN .-ASATBB-NASATT,<PRINTS /ASATBB WRONG SIZE
/>
>;IFN UPACKS

IFE UPACKS,<
ASSPP2:
>;IFE UPACKS
ASSPPX:	MOVE AC2,TAC1		;SAVE DEVICE NAME
	PUSHJ P,CTEXT1		;GET LOGICAL NAME, IF ANY
	MOVEM TAC1,ASSLGN	;SAVE FOR LATER
	MOVE TAC1,AC2		;RESTORE TAC1 TO PHYS NAME
	HRRZS (P)		;CLEAR PARTIAL MATCH FOUND FLAG
	PUSH P,DDB		;SAVE TTY DDB ADDRESS
	MOVE TAC,TAC1
	PUSH P,AC1		;SAVE ATTRIBUTE BITS
	PUSHJ P,DEVPHY
	JRST ASSG3
	POP P,AC1
	JRST ASSG4

ASSG3:	POP P,AC1
	HLRZ DDB,DEVLST
ASSG0:	MOVE TAC,DEVNAM(DDB)
	CAME AC2,DEVNAM(DDB)	;DOES PHYSICAL NAME MATCH?
	JRST ASSG1		;NO
ASSG4:
IFN UPACKS,<
	PUSHJ P,ASSUDP		;TEST VARIOUS UDP CASES
	JRST ASSR1A		;CAN'T GET UDPN SINCE PRIVATE AND NOT OURS
>;IFN UPACKS
	PUSHJ P,ASSCKS		;NOW CHECK FOR RECYCLABLE DDB
	JRST ASLNOK		;I.E., SHARABLE DEVICE AND OUR ASSCON DDB
	MOVEI TAC1,ASSCON	;SETUP ASSIGNED BY CONSOLE BIT
	PUSHJ P,ASSASG		;TRY TO ASSIGN DEVICE
	JRST ASSER1		;ALREADY ASSIGNED TO ANOTHER JOB
	JRST ASSFIN		;ASSIGNED

IFN UPACKS,<
ASSUDP:	HLRZ AC3,TAC
	CAIE AC3,'UDP'
	JRST CPOPJ1		;NOT UDP.
NoStructure,<
	LDB	AC3,PUNIT	;Unit number
	CAMN	AC2,[SIXBIT /UDP/]
	JRST	ASSUD1		;Asked for generic UDP. See if this one is public or ours
	SKIPL	TAC,UDPOWN-1(AC3)	;Wants UDPn
	CAMN	J,UDPOWN-1(AC3)
	JRST	ASSUD2		;OK. UDP is either ours or Public
	POPJ	P,		;CAN'T GET UDPN SINCE PRIVATE NOT OURS
				;Returns Job # of user of UDPn in TAC
;here for generic UDP
ASSUD1:	SKIPGE TAC,UDPOWN-1(AC3) ;NEED THIS IN CASE SWAPPING PACK--BH 5/25/75
	SKIPE UDPCNT-1(AC3)	;ANY DDBS IN USE FOR THIS UDP?
	POPJ P,			;YES.
	;fall to ASSUD2
>;NoStructure

IfStructure,<
	MOVE	AC3,SDBPTR(DDB)	;Get Structure Data Block
	CAMN	AC2,[SIXBIT /UDP/]
	JRST	ASSUD1		;Asked for generic UDP. See if this one is public or ours
	SKIPL	TAC,ST.JOB(AC3)	;Wants UDPn.  Skip if public
	CAMN	J,ST.JOB(AC3)	;Not public.  Skip unless it's ours
	JRST ASSUD2		;OK. UDP is either ours or Public
	POPJ P,			;CAN'T GET UDPN SINCE PRIVATE NOT OURS
				;Returns Job # of user of UDPn in TAC
;here for generic UDP
ASSUD1:	SKIPGE	TAC,ST.JOB(AC3)	;Skip if Assigned or Detached (i.e., Swapping)
	SKIPE	ST.CNT(AC3)	;Any DDBs in use for this UDP?
	POPJ	P,		;Yes.
	;fall to ASSUD2
>;IfStructure

ASSUD2:	TRNE AC1,PUBBIT		;WANTS TO MAKE IT PUBLIC?
	JRST AUDPPB		;YES.
	TRNE AC1,OLDBIT		;WANTS TO MAKE IT OLD STYLE?
	JRST AUDPOL		;YES.
	TRNN AC1,PRIBIT		;MAKE IT PRIVATE?
	JRST CPOPJ1		;NO.
	PUSHJ P,AUDPNU		;YES, FIRST MAKE IT NEW STYLE
	PUSHJ P,AUDPPV		;THEN MAKE IT PRIVATE
	JFCL			;IGNORE FAILURE RETURN
	JRST CPOPJ1

AUDPPV:		;Here to make a private UDP.  Call with AC3/ Unit (or SDB Address)
NoStructure,<
	SKIPN UDPCNT-1(AC3)
>;NoStructure
IfStructure,<
	SKIPN	ST.CNT(AC3)	;Skip if DDBs exist
>;IfStructure
	JRST ASSUD3		;OK TO PRIVATIFY UNUSED UDP
	PUSH P,DDB
ASSUD4:	HLRZ DDB,DEVSER(DDB)
	JUMPE DDB,ASSUD5
	CAME AC2,DEVNAM(DDB)
	JRST ASSUD5		;NO MORE DDBS FOR THIS UDP
	LDB TAC,PJOBN
	CAIN TAC,(J)
	JRST ASSUD4		;SAME JOB SAME UDP IS OK
	MOVE DDB,-3(P)		;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /Already in use - can't make private
/
	POP P,DDB
	MOVE TAC,DEVNAM(DDB)
	POPJ P,			;FAILURE RETURN

ASSUD5:	POP P,DDB
ASSUD3:	MOVE TAC,DEVNAM(DDB)
NoStructure,<
	MOVEM J,UDPOWN-1(AC3)	;MAKE UDP PRIVATE
>;NoStructure
IfStructure,<
	MOVEM J,ST.JOB(AC3)	;MAKE UDP PRIVATE
>;IfStructure
	JRST CPOPJ1		;SUCCESS RETURN

AUDPPB:	PUSHJ P,AUDPNU		;WANTS PUBLIC: FIRST MAKE NEW-STYLE
	MOVE TAC,DEVMOD(DDB)	;DDB POINTS TO MODEL DDB IT SAYS HERE
	TLNE TAC,DVDSK		;IF WE MANAGED NEW-STYLE,
NoStructure,<
	SETOM UDPOWN-1(AC3)	;PUBLICIFY IT
>;NoStructure
IfStructure,<
	SETOM ST.JOB(AC3)	;PUBLICIFY IT
>;IFStructure
	JRST CPOPJ1

;Make a new style UDP
AUDPNU:	MOVE TAC,DEVMOD(DDB)
	TLOE TAC,DVDSK		;OK IF ALREADY NEW-STYLE
	JRST AUDOK		;was already new style
AUDCCN:				;Here to change to old/new, only if not in use
NoStructure,<
	SKIPN UDPCNT-1(AC3)	;OR IF NO DDBS YET
>;NoStructure
IfStructure,<
	SKIPN ST.CNT(AC3)	;OR IF NO DDBS YET
>;IfStructure
	JRST AUDOK
AUDFOO:	EXCH DDB,-2(P)		;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /Already in use - can't change format
/
	EXCH DDB,-2(P)
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

;Here to make old style
AUDPOL:	PUSHJ P,AUDPPV		;WANTS OLD-STYLE.  FIRST PRIVATIFY
	JRST CPOPJ1		;FAILED TO PRIVATIFY, SO NO OLD-STYLE
	AOS (P)			;WIN OR LOSE, WE'VE ESTABLISHED ACCESS
	MOVE TAC,DEVMOD(DDB)
	TLZE TAC,DVDSK		;it's ok if already old-Style
	JRST AUDCCN		;must check to see no DDBs yet
AUDOK:	MOVEM TAC,DEVMOD(DDB)	;Set (Or Clear) DVDSK format bit
	TLNN TAC,DVDSK		;Skip if new style
	SKIPA TAC,[UDPDSP]	;set the dispatch address for old sty;e
	MOVEI TAC,DSKDSP	;set dispatch address for new style
	HRRM TAC,DEVSER(DDB)	;SET THE NEW DISPATCH TABLE TOO
	MOVE TAC,DEVNAM(DDB)
	POPJ P,
>;IFN UPACKS

;ROUTINE TO TRY TO RECYCLE ASSCON-TYPE DDB FOR SHAREABLE DEVICE
ASSCKS:	MOVE AC3,DEVCMR(DDB)	;FIRST OF ALL, GOTTA BE SHARABLE DEV
	TLNN AC3,DEVSHR		;OR ASSASG WON'T COPY IT ANYWAY
	JRST CPOPJ1
	MOVE AC3,DDB		;NOW SEARCH ALL DDBS FOR THIS DEV
ASCKS1:	LDB TAC,[POINT JOBNSZ,DEVJBN(AC3),JOBNPS] ;PJOBN
	CAIE TAC,(J)		;MUST MATCH OUR JOB TO BE A CANDIDATE
	JRST ASCKS9		;ELSE CONTINUE THROUGH DDBS
	MOVE TAC,DEVMOD(AC3)	;MUST HAVE ASSCON
	TRNN TAC,ASSCON		;PERHAPS NEEDLESSLY CONSERVATIVE, BUT
	JRST ASCKS9		;PERHAPS SOMEONE NEEDS NOT CON+PRG SAME DDB
	SKIPE TAC,DEVLOG(AC3)	;OK IF NO LOGICAL NAME IN THE DDB
	CAMN TAC,ASSLGN		;OR IF IT'S THE SAME AS LOG NAME ARG NOW
	JRST ASCKS2
	SKIPE ASSLGN		;ALSO OK IF NO LOG NAME ARG IN COMMAND
	JRST ASCKS9		;BUT LOSE IF 2 DIFFERENT LOG NAMES
ASCKS2:	MOVE DDB,AC3		;GOT ONE!  SAVE POINTER
	POPJ P,

ASCKS9:	HLRZ AC3,DEVSER(AC3)	;CONTINUE THROUGH DDB CHAIN
	JUMPE AC3,CPOPJ1	;CAN'T HAPPEN MAYBE
	MOVE TAC,DEVNAM(AC3)	;MAKE SURE THIS IS SAME DEVICE
	CAMN TAC,DEVNAM(DDB)
	JRST ASCKS1		;OK, CONTINUE TESTING
	JRST CPOPJ1		;NO, POP AC3, SKIP RET

;NOT MATCH OF ARG AND PHYSICAL NAME.

ASSG1:	LDB AC3,PJOBN		;SAVE OLD JOB NUMBER FOR THIS DEVICE
	MOVEM AC3,ASSJBN
	TRZ TAC,-1		;COMPARE LEFT HALF ONLY
	CAME TAC,AC2
	JRST ASSG2
	HRROS -1(P)		;FLAG PARTIAL NAME MATCH FOUND
IFN UPACKS,<
	PUSHJ P,ASSUDP		;DO UDP CHECKS
	JRST ASSG2		;THIS UDP NOT FREE TRY NEXT
>;IFN UPACKS
	PUSHJ P,ASSCKS		;NOW CHECK FOR RECYCLABLE DDB
	JRST ASLNOK		;NONSKIP RETURN MEANS SUCCESS, GOT A DDB
	MOVEI TAC1,ASSCON
	PUSHJ P,ASSASG		;MATCH, TRY TO ASSIGN IT
	JRST ASSG2		;KEEP LOOKING
	SKIPN ASSJBN
	JRST ASSFIN		;IF OLD JOB NUMBER 0,
				; DEVICE PREVIOUSLY UNASSIGNED

ASSG2:	HLRZ DDB,DEVSER(DDB)
	JUMPN DDB,ASSG0
	POP P,DDB
	SKIPL (P)		;DID WE HAVE ANY PARTIAL MATCHES?
	JRST NOTDEV		;PRINT NO SUCH DEVICE
	MOVE DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ P,INLMES
	ASCIZ /No /
	MOVE TAC1,AC2
	PUSHJ P,PRNAME
	JSP TAC,CONMES
	ASCIZ /'s available
/
;ASSR1A ASSER1 ASSMS2 ASSFIN ASLNOK DEFLOS ASSF1 ASSF2 NOLOGP LOGERR DEFASS

;ALREADY ASSIGNED TO ANOTHER JOB

ASSR1A:
NoStructure,<
	LDB	TAC,PUNIT
	SKIPA TAC,UDPOWN-1(TAC)	;GET JOB NUMBER OF PRIVATE OWNER OF UDPN
>;NoStructure
IfStructure,<
	MOVE	TAC,SDBPTR(DDB)
	SKIPA	TAC,ST.JOB(TAC)	;GET JOB NUMBER OF PRIVATE OWNER OF UDPN
>;IfStructure
↑ASSER1:LDB TAC,PJOBN		;GET JOB NUMBER FOR DEVICE
	POP P,DDB		;GET DDB FOR TTY
	PUSH P,TAC		;SAVE JOB NUMBER
	MOVEI TAC,ASSMS2	;TYPE ERROR MESSAGE
	PUSHJ P,ERRMES
	POP P,TAC		;GET JOB NUMBER BACK
	JRST DECLF

ASSMS2:	ASCIZ /Already assigned to job /

;DEVICE ASSIGNED, GIVE IT A LOGICAL NAME

ASSFIN:	SETZM DEVLOG(DDB)	;CLEAR LOGICAL NAME
ASLNOK:	EXCH DDB,(P)		;GET TTY DDB, SAVE DEVICE DDB
	MOVE TAC1,ASSLGN	;RETRIEVE SAVED LOGICAL NAME ARG
	SKIPN TAC,TAC1		;IS THERE A LOGICAL NAME SPECIFIED?
	JRST DEFASS		;NO.  CHECK FOR DEFAULTING ASSIGNMENT
	PUSHJ P,DEVLG		;SEE IF IT IS ALREADY IN USE BY THIS USER
	JRST ASSF1		;NO
	MOVEI TAC,LOGERR	;YES, PRINT ERROR
	MOVE DDB,-3(P)		;RESTORE TTY DDB
	PUSHJ P,ERRMES
DEFLOS:	MOVEI TAC,0		;CLEAR LOGICAL NAME FOR THIS DEVICE
ASSF1:	POP P,DDB
	SKIPN DEVLOG(DDB)	;WILL BE NONZERO ONLY FOR RECYCLED DDB
	MOVEM TAC,DEVLOG(DDB)	;STORE IN DEVICE DATA BLOCK
	MOVSI TAC1,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAM TAC1,DEVMOD(DDB)
	MOVE TAC1,DEVNAM(DDB)	;PHYSICAL NAME
NoStructure,<
	LDB AC1,PUNIT		;SAVE UNIT FOR UDP TEST
>;NoStructure
IfStructure,<
	MOVE AC1,SDBPTR(DDB)	;SAVE UNIT FOR UDP TEST
>;IfStructure
	MOVE AC2,DDB
	MOVE DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ P,PRNAME		;PRINT IT
	MOVSI TAC,DVDSK		;IS IT DISK OR UDP?
	TDNN TAC,DEVMOD(AC2)
	JRST ASSF2		;NO, NO SATID
NoStructure,<
	JUMPE AC1,ASSF2		;YES, BUT NOT INTERESTED IF UNIT 0 (DSK)
	SKIPLE TAC,SATADR(AC1)
	PUSHJ P,SATTAC		;TYPE SATID IF ANY
>;NoStructure
IfStructure,<
	CAIN	AC1,SDB0	;Skip unless DSK
	JRST	ASSF2		;Don't print SATID for DSK
	SKIPE	TAC,ST.NAM(AC1)
	PUSHJ	P,PSTRID	;TYPE SATID IF ANY
>;IfStructure
ASSF2:	PUSHJ P,INLMES
	ASCIZ / Assigned/
	SKIPN DEVLOG(AC2)
	JRST NOLOGP
	PUSHJ P,INLMES
	ASCIZ / as /
	MOVE TAC1,DEVLOG(AC2)
	PUSHJ P,PRNAME
NOLOGP:	JSP TAC,CONMES
	ASCIZ/
/

LOGERR:	ASCIZ /Logical name already in use, /

DEFASS:	MOVE DDB,(P)
	CAME AC2,DEVNAM(DDB)
	CAMN AC2,['TTY   ']	;DON'T DO IT FOR TTY
	JRST ASSF1
	MOVE TAC,AC2
	PUSHJ P,DEVLG		;IN USE?
	 JRST ASSF1
	JRST DEFLOS
BEND ASSIGN
;DEASSI DEAER4 DEAER3 DEADON DEADN1 NOTDEV DEAER1 PNOTDV DEAER2 DEALL
;"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE


DEASSI:	JUMPE J,CPOPJ		;NO-OP IF NO JOB NUMBER
	PUSHJ P,CTEXT1		;GET DEVICE NAME
	JUMPE TAC1,DEALL 	;NO ARG. IF 0, DEASSIGN ALL BUT TTY
	MOVE TAC,TAC1		;DEVICE NAME
DEAER4:	PUSHJ P,DEVLG		;SEARCH LOGICAL NAMES FIRST
	JRST DEAER3
	PUSHJ P,DEASG
	CAIA
	JRST DEADON
	PUSH P,[DEAER4+1]
	JRST DEV0

DEAER3:	PUSHJ P,DEVPHY		;NOT FOUND, TRY PHYSICAL NAMES
	JRST DEAER2		;NOT FOUND AT ALL, LOSE!
	PUSHJ P,DEASG		;FOUND, DEASSIGN IT
	CAIA
	JRST DEADON
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,DVTTY		;STOP IF FOUND A TTY
	POPJ P,			;QUIT HERE ELSE LOOP INDEFINITELY. FLUSH UNUSED TTYS
	PUSH P,[DEAER3+1]
	JRST DEVLP2

DEADON:	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,TTYATC		;NOT FOR CONSOLE OF LOSER
	POPJ P,
	TRNN AC1,ASSPRG		;STILL ASSIGNED BY PROGRAM?
	JRST DEADN1		;NO.
	MOVE TAC1,DEVNAM(DDB)
	MOVE DDB,-2(P)
	PUSHJ P,PRNAME
	JSP TAC,ERRMES
	ASCIZ / deassigned, but still INITed
/

DEADN1:	TLNN AC1,DVTTY		;IF TTY
	POPJ P,
	JRST TTYREL		;RELEASE IT SO DDB WILL BE LET GO

↑NOTDEV:
DEAER1:	SKIPA DDB,-2(P)		;RESTORE TTY DDB
PNOTDV:	POP P,DDB		;HERE FROM ATTACH OR DETACH CMD
	JSP TAC,ERRMES		;PRINT 'NO SUCH DEVICE'
	ASCIZ /No such device
/

DEAER2:	MOVE TAC1,TAC		;PRINT PHYSICAL DEVICE NAME
	MOVE DDB,-2(P)		;RESTORE TTY DDB FIRST
	PUSHJ P,PRNAME
	JSP TAC,ERRMES
	ASCIZ / wasn't assigned
/

DEALL:	PUSH P,DDB
	MOVEI DDB,0
	PUSHJ P,DEASTY
	POP P,DDB
	POPJ P,
;REASSI REASS REASS1 REASS4 REASS2 REASS8 REAST2 REAST3 REAST1 REASS3 REASE1 REASE4 REASE3 REASE2 REASE5 REASE6 REASE7 REASSX
;REASSI, REASS,  REASSIGN UUO AND COMMAND.

;CALL:	MOVE AC,<NEW JOB NUMBER>
;	MOVE AC+1,<SIXBIT /DEVICE/> OR <IO CHANNEL NUMBER>
;	CALL AC,[SIXBIT /REASSIGN/]
;IF C(AC)=0, JOB HAS NOT BEEN INITIALIZED
;IF C(AC+1)=0, DEVICE NOT ASSIGNED TO THIS JOB OR DEVICE IS A TTY


;HERE FROM UUOCON.

REASSI:	LDB UUO,PUUOAC
	HRLI UUO,100000		;UUO POSTIVE SIGNIFIES REASSIGN UUO
	XCTR XR,[PUSH P,(UUO)]	;STACK JOB NUMBER ARGUMENT.
	XCTR XR,[MOVE TAC1,1(UUO)] ;FETCH DEVICE NAME.
	JRST REASS1		;JUMP TO COMMON CODE.

;"REASSIGN DEV:JOB" - REASSIGN DEVICE "DEV" TO JOB "JOB"

REASS:	PUSHJ P,CTEXT1		;GET DEVICE NAME
	JUMPE TAC1,NOTENF	;NULL NAME?
	MOVE UUO,TAC1		;SAVE DEVICE NAME.
	PUSHJ P,DECIN1		;GET NEW JOB NUMBER
	JRST NOTENF		;NONE SPECIFIED. DOESN'T RETURN IF ERROR
	JRST COMERA		;ILLEGAL CHARACTER
	SKIPN JBTPAG(J)		;DOES THIS JOB HAVE ANY CORE?
	JRST .+3
	AOS AMC12		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;YES.  SETUP THE MAP.
	PUSH P,TAC1		;PUT JOB NUMBER ON STACK
	MOVE TAC1,UUO		;DEVICE NAME IN TAC1
	MOVEI UUO,0		;UUO←0 SIGNIFIES REASSIGN COMMAND
REASS1:	EXCH J,(P)		;J←NEW JOB NUMBER. (STACK CURRENT J)
	MOVE TAC,JBTSTS(J)	;NEW JOB STATUS
	EXCH J,(P)		;RESTORE J AND STACK
	TLNN TAC,JNA		;DOES NEW JOB EXIST?
	JRST REASE1		;NO.
	MOVE TAC,TAC1		;DEVICE NAME.
	PUSHJ P,FNDDDB		;SEARCH FOR DEV (OR OPTIONAL CHANNEL # IF UUO)
	JRST REASE2		;NOT FOUND
	LDB TAC,PJOBN		;GET JOB NUMBER OF THAT DEVICE
	CAME TAC,J		;IS IT ASSIGNED TO THIS JOB?
	JRST REASE3		;NO
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,TTYATC		;IS IT HIS CONSOLE?
	JRST REASE6		;CAN'T REASSIGN CONSOLE.
	TRNN TAC,ASSPRG		;IS DEVICE INITED?
	JRST REASS3		;NO.
	JUMPN UUO,REASS4	;DEVICE IS INITED.  JUMP IF THIS IS AT UUO LEVEL
	HRL DDB,(P)		;COMMAND LEVEL. RUN MONITOR JOB TO DO RELEASE
	XCTR XW,[MOVEM DDB,JOBFDV] ;STORE ARGUMENT.
	POP P,TAC1		;JOB NUMBER OF DESTINATION.
	MOVE DDB,-2(P)		;TTY DDB
	MOVSI TAC1,TTYRNC	;SET TTYRNC SO JOB WILL RUN
	IORM TAC1,-1(P)
	JSP TAC1,MSTART		;SCHEDULE MONITOR JOB.
	JSP TAC,MONSTR		;HERE WE ARE AT UUO LEVEL.  SETUP ACS.
	XCTR XR,[HLRZ TAC,JOBFDV] ;GET THE JOB NUMBER BACK
	PUSH P,TAC		;STACK THE JOB NUMBER.
	XCTR XR,[HRRZ DDB,JOBFDV] ;AND SETUP THE DDB ADDRESS.
	MOVNI UUO,1		;SET FLAG TO STOP JOB EXITING COMMAND.
REASS4:	HRRZ DSER,DEVSER(DDB)
	XCTR XW,[HRRZM DDB,JOBFDV] ;SAVE DDB ADDRESS.
	SKIPGE UCHN,USRHCU	;HAS SAVGET BEEN HERE?
	JRST REASS3		;YES, WE CAN'T BE IN USRJDA LIST.
	CAILE UCHN,17
	MOVEI UCHN,17
REASS2:	HRRZ DDB,USRJDA(UCHN)
	PUSH P,UCHN
	XCTR XR,[CAME DDB,JOBFDV]
	JRST REASS8		;FAILS TO MATCH.
	HLL DDB,USRJDA(UCHN)	;PICK UP UUO FLAGS FIRST
	PUSHJ P,RELEA5		;GO RELEASE DEVICE.
REASS8:	POP P,UCHN
	SOJGE UCHN,REASS2	;MAY BE INITED ON SEVERAL CHANNELS.
	SKIPL UCHN,JBTIOP(J)	;LOOK IN THE IOPDL
	JRST REAST1
REAST2:	HRRZ DDB,(UCHN)
	XCTR XR,[CAME DDB,JOBFDV]
	JRST REAST3
	MOVE DDB,USRJDA
	EXCH DDB,(UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	MOVEI UCHN,0
	PUSHJ P,RELEA5		;RELEASE DEVICE FROM IOPDL
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
REAST3:	ADD UCHN,[2,,2]
	JUMPL UCHN,REAST2
REAST1:	XCTR XR,[MOVE DDB,JOBFDV]
REASS3:	MOVEI TAC,ASSCON	;ASSIGN IT BY CONSOLE
	IORM TAC,DEVMOD(DDB)
	POP P,J
	DPB J,PJOBN		;PUT IN NEW JOB NUMBER
	SETZM DEVLOG(DDB)	;FLUSH LOGICAL DEVICE NAME
	PUSHJ P,RELDVW		;REG 11/74.  JOB MAY BE WAITING IN DWQ
	MOVE J,JOB		;RESTORE CURRENT JOB NUMBER
	JUMPL UUO,ESTOP		;IF REASSI COMMAND AT UUO LEVEL, WE STOP.
	POPJ P,			;RETURN TO USER, OR COMRET

;ERRORS FROM REASSIGN

REASE1:	POP P,TAC		;NO SUCH JOB.  ADJUST STACK.  
	JUMPE UUO,NOTLOG	;JUMP IF REASSIGN COMMAND - PRINT MESSAGE
REASE4:	XCTR XW,[SETZM (UUO)]	;CLEAR C(AC) - NO SUCH JOB RETURN
	POPJ P,

REASE3:	SKIPA TAC,[REASSX]	;WASN'T ASSIGNED
REASE2:	MOVEI TAC,NOTDEV	;NO SUCH DEVICE
REASE5:	POP P,TAC1
	JUMPE UUO,(TAC)		;PRINT MESSAGE.
	AOJA UUO,REASE4		;ZERO C(AC+1) - CAN'T REASSIGN DEVICE

REASE6:	MOVEI TAC,REASE7	;USER'S TERMINAL CAN'T BE REASSIGNED.
	JRST REASE5

REASE7:	MOVE TAC1,DEVNAM(DDB)
	MOVE DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ P,PRNAME
	JSP TAC,ERRMES
	ASCIZ / can't be reassigned
/

REASSX:	MOVE TAC,DEVNAM(DDB)
	JRST DEAER2		;PRINT DEVICE XXX WAS NOT ASSIGNED.
;ATTDLY ATTJBU FATTCH FATT2 ATTACH FATT1 THEHUN THEHU2 ATTFF1 ATTFF2 ATTNUM ATTNU0 ATTNU1 ATTNU3 ATTNER ATTCHK ATTCH2 ATTLOG ATTFOO ATTPTY ATTILA

;ATTACH CATTACH COMMANDS

; ATTACH - ATTACHES TO NEXT DETACHED JOB WITH SAME PPN.
;"ATTACH DEVNAM" -ATTACHES A PREVIOUSLY DETACHED DEVICE.  MUST HAVE DEVPRV
;"ATTACH N [PROJ.,PROG.]" - ATTACH CONSOLE TO JOB N
;CHANGES ADDRESS OF TTY DDB THAT WAS STORED IN -2(P) BY THE COMMAND DECODER

;HERE IF WE COULDN'T GET F.S. FOR NEW DDB FOR ATTACHEE SO WE CAN SEND HIM THE MSG
ATTDLY:	POP P,J			;ATTACHEE'S JOB
	PUSHJ P,TTYATI		;ATTACH HIM BACK!
	ONSCN
	POP P,J			;OUR JOB
	POP P,DDB		;OUR DDB
	JRST DLYCM1		;DELAY COMMAND UNTIL WE CAN GET FREE STORAGE

;HERE FOR ATTJOB UUO, PRIVILEGED CALLI GIVEN BY LOGIN PROGRAM FOR ATTACH CMD
↑ATTJBU:MOVE AC2,JBTPRV(J)	;GET OUR PRIVILEGES
	JUMPL TAC,CPOPJ		;BAD JOB NUMBER
	CAIGE TAC,JOBN		;MAKE SURE LEGAL JOB NUMBER
	TLNN AC2,INFPRV		;ARE WE ALLOWED TO DO THIS?
	POPJ P,			;NOPE
	HRRE TAC1,JBTLIN(J)	;GET TTY DDB
	JUMPL TAC1,CPOPJ	;SHOULDN'T BE DETACHED
	SKIPN DDB,TTYTAB(TAC1)
	POPJ P,			;NO DDB?
	SETZM SAVDDB(DDB)	;JUST IN CASE LOGIN LOST
	MOVEI AC1,(TAC)		;JOB NUMBER IS ARGUMENT FOR FORCED ATT CMD
	MOVEI TAC,F.ATT		;COMMAND INDEX
	JRST FORCEA		;QUEUE FORCED CMD WITH ARGUMENT

;HERE FOR FORCED ATTACH COMMAND
FATTCH:	LDB TAC1,ARGBPT		;GET JOB NUMBER TO ATTACH
	CAIL TAC1,JOBN		;Make sure job number is reasonable
	POPJ P,			;Shouldn't happen, but be safe
	JRST FATT1		;SKIP LEGALITY CHECKS

;HERE WHEN ATTACH COMMAND DECIDES TO ASK FOR FORCED LOGIN CMD
FATT2:	MOVEM TAC1,SAVDDB(DDB)	;SAVE TARGET JOB NUMBER FOR LOGIN PROGRAM
	MOVEI TAC,F.LOG		;ELSE CHANGE THIS TO FORCED LOGIN CMD
	MOVEI AC1,0		;ARGUMENT MUST BE ZERO (WILL BECOME JOB NUMBER)
	PUSHJ P,FORCEA
	MOVEI J,0
	MOVSI TAC,NOPER!NOCRLF	;PREVENT SPURIOUS PERIOD
	IORM TAC,-1(P)
	POPJ P,

ATTACH:	PUSHJ P,NBRPPN		;GET JOB NUMBER(TAC1) AND PPN(AC2)
	 JRST DEVATT		;ILLEGAL NUMBER, MAYBE WANTS TO ATTACH DEVICE
	 JRST ATTNUM		;NO NUMBER -- SEE IF HE HAS DET JOB
	 JRST NOTLOG		;JOB NUMBER IS SEGMENT -- NOT REAL JOB
	CAMN TAC1,J		;TRYING TO ATTACH TO SELF?
	JRST ATT8		;YUP, THAT'S SILLY
	PUSHJ P,ATTCHK		;SEE IF OK TO ATTACH THIS JOB
	 JRST FATT2		;NEED TO RUN LOGIN TO DO THIS ATTACH
	 JRST [	MOVEI J,0
		JRST ERRMES]	;LOSE, ERROR MESSAGE ADDRESS ALREADY IN TAC
FATT1:	HRRE TAC,JBTLIN(TAC1)	;SEE IF JOB IS ALREADY ATTACHED
	PUSH P,TAC		;SAVE ATTACHEE'S LINE FOR US AND FOR THEHUN
	JUMPL TAC,THEHUN	;JUMP IF JOB IS DETACHED
	PUSH P,DDB		;ATTACHER'S DDB
	PUSH P,J		;ATTACHER'S JOB
	PUSH P,TAC1		;ATTACHEE'S JOB
	MOVE J,TAC1		;ATTACHEE'S JOB IS TO HAVE ITS DPY RESET
	PUSHJ P,DPYRST		;RESET HIS DISPLAY BEFORE WE DETACH HIM!
;HERE WE FORCIBLY DETACH THE JOB SO THAT WE CAN ATTACH IT, BY GOLLY
;(BELOW AT THEHUN).  BUT WE MUST MAKE A NEW DDB FOR THE TTY THAT WE'RE
;DETACHING THE JOB FROM SO WE CAN TELL THAT TTY WHAT HAPPENED TO ITS JOB.
	MOVE TAC,-3(P)		;RESTORE ATTACHEE'S LINE NUMBER
	OFFSCN
	MOVE DDB,TTYTAB(TAC)	;GET ATTACHEE'S DDB
	PUSHJ P,DETCHB		;DETACH ATTACHEE SO WE CAN ATTACH JOB
	 JRST ATTDLY		;CAN'T GET NEW DDB FOR LOSER'S TTY--DELAY CMD
	ONSCN
;NOW WE LOG WHAT WE HAVE DONE.  THIS MUST COME AFTER WE HAVE GOTTEN A NEW
;DDB FOR THE GUY WHOSE JOB WAS STOLEN AWAY (ALONG WITH ITS DDB) SO THAT WE
;CAN TYPE THE MESSAGE TO THE LOSER (OTHERWISE IT WOULD GO TO THE THIEF).
	MOVE J,(P)		;ATTACHEE'S JOB
	MOVE TAC1,-1(P)		;ATTACHER'S JOB
	MOVEI TAC,[ASCIZ /ATTACHed /] ;MESSAGE TO TYPE OUT ON LOSER'S TTY
	PUSHJ P,LOGIT		;TELL ATTACHEE AND MAYBE CTY WHAT'S HAPPENING
	PUSHJ P,PRPER		;PRINT A DOT
	PUSHJ P,TTYKIL		;NOW KILL THE NEW DDB WE GOT THE ATTACHEE
	POP P,TAC1		;ATTACHEE'S JOB
	POP P,J			;ATTACHER'S JOB
	POP P,DDB		;ATTACHER'S DDB
;NOW ATTACH US TO THE JOB, WHOSE FORMER LINE NUMBER (IF ANY) IS ON TOP OF STACK.
THEHUN:	MOVSI TAC,JLOG		;MAKE SURE THE JOB THAT'S BEING
	IORM TAC,JBTSTS(TAC1)	; ATTACHED IS LOGGED IN
	PUSH P,J		;SAVE NUMBER OF JOB BEING DETACHED
	MOVE J,TAC1		;JOB NUMBER TO J
	PUSHJ P,COMRT2		;FIX COMCNT
	PUSH P,IMLHAC(DDB)	;SAVE MISC TTY VALUES
	PUSHJ P,TTYATT		;NO, ATTACH TTY
	 JRST ATT2		;ERROR CAN'T ATTACH (SHOULDN'T HAPPEN ANY MORE)
	POP P,IMLHAC(DDB)	;RETAIN OLD VALUES
	SETZM SAVDDB(DDB)	;FLUSH ATT ARG LEFT OVER FROM FORCED LOGIN CMD
	MOVEM DDB,-4(P)		;CHANGE DEV DATA BLOCK ADDRESS
	PUSHJ P,TTYFND		;ATTACHED. GO SET UP OUTPUT BYTE PTR.
	POP P,TAC		;NUMBER OF JOB THAT WAS DETACHED
	JUMPE TAC,THEHU2	;JUMP IF DIDN'T HAVE JOB ORIGINALLY
	SKIPN FRCFLG		;DON'T CONFUSE USER IF LOGIN DOES ATTJOB UUO
	PUSHJ P,DETNBR		;PRINT PREVIOUS JOB'S NUMBER
THEHU2:	PUSHJ P,INLMES
	ASCIZ /
Attaching job /
	MOVE TAC,J
	PUSHJ P,RADX10		;PRINT JOB NUMBER
	MOVEI TEM," "
	XCT TYO
	MOVE TAC1,JOBNAM(J)
	PUSHJ P,PRNAME		;PRINT SIXBIT JOB NAME
	SKIPGE (P)		;SKIP UNLESS DETACHED
	JRST ATTFF1		;SAY NO MORE IF JOB WAS DETACHED
	PUSHJ P,INLMES
	ASCIZ/ away from TTY/
	POP P,TAC		;GET BACK LINE NUMBER WHERE JOB CAME FROM
	PUSHJ P,OCTPNT		;PRINT TTY NUMBER IN OCTAL
	JRST ATTFF2

ATTFF1:	POP P,TAC
ATTFF2:	SKIPN FRCFLG
	POPJ P,			;DONE UNLESS FORCED COMMAND
	JRST CRLF		;FORCED CMD CLEVERLY SETS NOCRLF

ATTNUM:	JUMPE J,LOGPLS		;LOGIN PLEASE
ATTNU0:	MOVEI TAC1,1(J)
	MOVE AC3,PRJPRG(J)	;GET HIS PPN
ATTNU1:	CAIL TAC1,JOBN		;TAC1 ≥ MAX JOB #?
	MOVEI TAC1,1		; YES - START OVER AT JOB NUMBER 1
	CAME AC3,PRJPRG(TAC1)	;DOES JOB TAC1 HAVE SAME PPN?
	AOJA TAC1,ATTNU1	;NO
	CAIN TAC1,(J)		;BACK TO WHERE WE STARTED?
	JRST ATTNER		; YES - ERROR - NO OTHER DETACHED JOBS SAME PPN
	MOVE AC2,JBTSTS(TAC1)
	TLNE AC2,JNA
	TLNE AC2,JSEG
	AOJA TAC1,ATTNU1	;NOT A REAL JOB SLOT, OR IT'S AN UPPER SEGMENT
	MOVE AC2,JBTLIN(TAC1)
	AOJN AC2,ATTNU3		;JUMP IF NOT DETACHED
	PUSHJ P,ATTCHK		;SEE IF WE ARE ALLOWED TO ATTACH THIS GUY
	 JRST FATT2		;NEED TO RUN LOGIN TO ATTACH THIS GUY
ATTNU3:	 AOJA TAC1,ATTNU1	;LOSE, LOOK FOR ANOTHER DETACHED JOB
	PUSH P,JBTLIN(TAC1)	;TELL THEHUN THAT WE'RE ATTACHING A DETACHED JOB
	JRST THEHUN

ATTNER:	MOVEI J,0
	JSP TAC,ERRMES
	ASCIZ /No other detached jobs with same ppn.
/

;DDB IS ATTACHER'S, J IS ATTACHER'S.
;TAC1 IS ATTACHEE'S JOB
;DIRECT RETURN IF NEED TO RUN LOGIN TO ATTACH THIS GUY (MORE PRIVS OR WE NOT LOCAL)
;SKIP RETURN IF CAN'T ATTACH, ADDRESS OF ERROR MESSAGE IN TAC.
;DOUBLE SKIP IF OK TO ATTACH
ATTCHK:	AOS (P)			;ASSUME NOT GONNA NEED TO RUN LOGIN
	PUSHJ P,ATTPTY		;MAKE SURE NOT ILLEGAL ATTACH LOOP
	 POPJ P,		;ILLEGAL ATTEMPT TO ATTACH TO OUR PTY'S OWNER
	MOVSI AC2,JLOG
	TDNE AC2,JBTSTS(TAC1)	;SKIP IF JOB WE'RE ATTACHING IS LOGGED IN
	JRST ATTCH2		;JOB IS LOGGED IN
	MOVE TAC,JB2PRV(J)	;CHECK ATTPRV OUT OF PASSIVE PRIVS
	TRNE TAC,ATTPRV		;NOT LOGGED IN.  SKIP IF WE'RE UNPRIVILEGED
	JRST CPOPJ1		;WE'RE PRIVILEGED, ALL OK
	MOVE AC2,PRJPRG(J)	;PHANTOM AND NOT PRIVILEGED TO ATTACH
	CAME AC2,PRJPRG(TAC1)	;BUT OK IF PHANTOM HAS SAME PPN AS ATTACHER
	JRST ATTFOO		;NOT ATTACHER'S OWN PHANTOM
	MOVEI AC2,(AC2)		;SAME PPN, ATTACH OK UNLESS HE IS SYS
	CAIN AC2,'SYS'
	JRST ATTFOO		;IN WHICH CASE WE DON'T ALLOW ATTACH
ATTCH2:	MOVE TAC,JB2PRV(TAC1)	;GET ATTACHEE'S PRIVILEGES
	MOVE AC2,PRJPRG(TAC1)	; AND PPN
;If you change the privs in the next instruction, do the same to LOGIN at ATTBEG.
	TDZ TAC,[UPGPRV!NSLPRV!LUPPRV,,LIVPRV!DETPRV]	;THESE ARE OK
	TDZ TAC,JB2PRV(J)	;ALSO OK IF WE ALREADY HAVE THE PRIVS
	JUMPN TAC,ATTLOG	;ELSE MUST RUN LOGIN
	CAMN AC2,PRJPRG(J)
	JRST CPOPJ1		;OK TO ATTACH
ATTLOG:	SOS (P)			;UNDO EARLIER AOS, TO GET DIRECT RETURN AFTER ALL
	POPJ P,

ATTFOO:	JSP TAC,CPOPJ		;RETURN THE ADDRESS OF ERROR MESSAGE
	ASCIZ /Can't Attach job
/

;HERE TO SEE IF A PTY IS TRYING TO ATTACH (ONE OF) IT'S CONTROLLING JOB(S)
;DIRECT RETURN IF SO (ILLEGA), SKIPS IF NOT (OK TO CONTINUE).
ATTPTY:	LDB TAC,PUNIT		;GET LINE NUMBER OF TTY THAT'S TYPING.
	JRST .+2
ATTILA:	HRRE TAC,JBTLIN(TAC)	;GET LINE NUMBER OF CONTROLING JOB.
	CAIGE TAC,PTYL0		;IS THIS ON A PTY?
	JRST CPOPJ1		;NO. ATTACH IS LEGAL.
	MOVE TAC,PTYJOB-PTYL0(TAC) ;GET JOB NUMBER OF CONTROLING JOB.
	CAIE TAC,(TAC1)		;CONTROLLER=JOB TO ATTACH TO?
	JRST ATTILA		;NO.  KEEP LOOPING
	JSP TAC,CPOPJ		;RETURN THE ADDRESS OF ERROR MESSAGE
	ASCIZ /Illegal attach loop
/
;DEVATT ATTCTY CTYAT1 DADD02 DADD0X CTYATT ATTUDP DADD00 DADD01 DADD03 DADD04 ATT2 ATT8 ATT3 ATT5A ATT5 ATT7 ATT6

;ATTACH DEVICE

DEVATT:	ADDI TEM,20		; MAKE FIRST CHAR OF DEVICE NAME INTO SIXBIT
	PUSH P,TEM		; NOW SAVE IT
	PUSHJ P,CTEXT		;GET DEVICE ARGUMENT
	JFCL			;SHOULD NEVER RETURN
	POP P,TEM		; GET CHARACTER BACK
	MOVEI AC1,(DDB)		;BH 8/5/78 ATTACH DEVICE CMD OK FROM CTY
	CAIN AC1,SCNDDB		;BH
	JRST ATTCTY		;BH
	MOVE AC1,JB2PRV(J)	;GET JOB PRIVILEGES (PASSIVE)
	TLNN AC1,DEVPRV		;HAS HE THIS PRIV?
	JRST ATT5		;NO - ERROR
ATTCTY:	MOVE TAC,TAC1		;YES-SET UP DEVICE NAME
	LSH TAC,-6
	DPB TEM,[POINT 6,TAC,5]	;INCLUDE FIRST CHAR OF NAME (READ BY ATTACH)
	MOVEM TAC,ATTDEV	;REMEMBER NAME OF DEVICE (OR DD CHAN) FOR CTY MSG
	PUSH P,DDB		;SAVE DDB FOR THIS TTY
	PUSHJ P,DEVSRC		;SEARCH FOR DEVICE
IFE FTF2,<
	 JRST DADD01		;NOT FOUND
>;IFE FTF2
IFN FTF2,<
	 JRST PNOTDV		;NOT FOUND
>;IFN FTF2
	LDB AC1,PJOBN		;GET JOB NUMBER
	JUMPN AC1,ATT6		;IS IT = 0?
	MOVE TAC,DEVMOD(DDB) 	;CHECK TO SEE IF THIS IS A TTY
	TRNE TAC,ASSPRG		;IN USE BY JOB 0?
	JRST ATT5A		;YES, CAN'T ATTACH IT
	TLNE TAC,DVUDP
	JRST ATTUDP		;UDP IS SPECIAL
	TRNN TAC,ASSCON		;Was device really detached?
	JRST ATT7		;No
	MOVE TAC1,DEVCMR(DDB)	;If this is sharable device, must be model DDB
	TLNE TAC1,DEVSHR	;Skip unless sharable device
	JRST CTYATT		;Re-attach sharable device without setting PJOBN
	JUMPE J,CTYATT		;THIS IS THE CTY ATTACHING IT
	DPB J,PJOBN		;SET JOB NUMBER
CTYAT1:	TLNE TAC,DVTTY		;SKIP IF NOT TTY
	PUSHJ P,ATTTTY		;ALSO CALL TTYSER TO TURN ON DCA PORT
DADD02:	POP P,DDB		;GET BACK TYPER'S TTY DDB
	PUSHACS
	PUSHJ P,DISUSR
	 SIXBIT/DEVICE/
	PUSHJ P,DISERR
	DISARG SIX,ATTDEV	;PRINT NAME OF DEVICE
	[ASCIZ/ re-attached to system/]
	-1
	MOVEI TEM,(DDB)
	CAIN TEM,SCNDDB		;ON CTY?
	JRST DADD0X		;YES
	PUSHJ P,DISERR
	[ASCIZ/ by /]
	DISARG SIX,<PRJPRG(J)>
	[ASCIZ/ /]
	-1
	PUSHJ P,DISJOB
DADD0X:	PUSHJ P,DISCRLF
	POPACS
	POPJ P,

;Here with ATTACH from CTY or ATTACH of detached sharable device.
CTYATT:	MOVEI TAC1,ASSCON	;Just clear the console-assigned bit without
	ANDCAM TAC1,DEVMOD(DDB)	;  setting PJOBN, thus making it available to all.
	JRST CTYAT1

NoStructure,<
ATTUDP:	LDB TAC,PUNIT		;TRYING TO ATTACH UDP
	SKIPN UDPCNT-1(TAC)	;MUST BE NO DDBS
	SKIPE UDPOWN-1(TAC)	;AND OWNER 0
	JRST ATT6		;ELSE IN USE, PUBLIC, OR SWAPPING DEVICE!
	SETOM UDPOWN-1(TAC)	;OK, MAKE IT PUBLIC
	JRST DADD02		;NOTE THAT YOU DON'T HAVE IT ASSIGNED NOW!
>;NoStructure
IfStructure,<
ATTUDP:	MOVE TAC,SDBPTR(DDB)
	SKIPN ST.CNT(TAC)	;MUST BE NO DDBS
	SKIPE ST.JOB(TAC)	;AND OWNER 0
	JRST ATT6		;ELSE IN USE, PUBLIC, OR SWAPPING DEVICE!
	SETOM ST.JOB(TAC)	;OK, MAKE IT PUBLIC
	JRST DADD02		;NOTE THAT YOU DON'T HAVE IT ASSIGNED NOW!
>;IfStructure

IFE FTF2,<
;NOTE: THIS ROUTINE IS ALSO CALLED FROM PJOB COMMAND
DADD00:	MOVEI TAC1,0		;SUBROUTINE TO CHECK "DEV" NAME FOR DD
	ROTC TAC,14
	CAIN TAC1,'DD'		;NOT A DEVICE, IS IT A DD CHANNEL?
	PUSHJ P,SIX2LN		;YES, GOBBLE NUMBER
	POPJ P,			;NOT DD OR NO NUMBER
	CAIL TAC1,=32
	POPJ P,
;	MOVSI TAC,DDDETU!DDANYW	;DETACHED USE CODE
;	HRRI TAC,(TAC1)
	JRST CPOPJ1

DADD01:	PUSHJ P,DADD00		;NOT A REAL DEVICE, TRY DD CHAN
	 JRST PNOTDV		;NOPE
	MOVEI TAC,DDKILL	;Always clear bit that would detach this channel
	ANDCAM TAC,DDTAB(TAC1)	;  when it went available.
	MOVEI TAC,DDBADB	;YES, GET BAD BIT MASK
	TDNN TAC,DDTAB(TAC1)
	JRST DADD03		;WASN'T DET
	ANDCAM TAC,DDTAB(TAC1)	;CLEAR THE BIT
	PUSHJ P,DADD04		;TRY TO CLEAR 201 USE CODE
	 JRST DADD02		;WASN'T SET, SO WHAT.
	JRST DADD02

DADD03:	PUSHJ P,DADD04		;TRY TO CLEAR 201 USE CODE
	 JRST ATT6		;WASN'T DET
	JRST DADD02

DADD04:	MOVEI TAC,(TAC1)	;CHANNEL NUMBER IN TAC
	LDB AC1,[DDUSR+<(TAC)>]	;USE CODE
	CAIE AC1,DDDETU		;DETACHED?
	POPJ P,			;NO
	AOS (P)			;YES, SKIP RETURN
	HRLI TAC,DDDETU		;USE CODE FOR ALREADY-DETACHED CHANNEL
	JRST DDREL		;Go release the channel, thus un-detaching it
>;IFE FTF2

ATT2:	EXCH DDB,TAC1		;PUT LINE NO. OF OUR TTY IN DDB
	ADJSP P,-3		;FLUSH LINE NUMBER (ATTACHEE), OLD IMLHAC, OLD JOB
	MOVE TAC1,DEVNAM(TAC1)	;PRINT PHYSICAL NAME
	MOVE DDB,TTYTAB(DDB)	;PRINT MESSAGE ON RIGHT TTY !!
	PUSHJ P,PRNAME
	JSP TAC,ERRMES
	ASCIZ / already attached
/

ATT8:	JSP TAC,ERRMES		;HERE WHEN ALREADY ATTACHED TO JOB ASKED FOR
	ASCIZ /Already attached!
/

ATT3:	JSP TAC,ERRMES
	ASCIZ /PPN mismatch
/

ATT5A:	POP P,DDB
ATT5:	JSP TAC,ERRMES
	ASCIZ /Can't attach device
/

ATT7:	TLNE TAC,DVTTY		;If this is this a TTY,
	PUSHJ P,TTYDIE		; then FLUSH DDB WE CREATED (PJOBN is 0), quickly
ATT6:	POP P,DDB		;HERE WHEN DEVICE ASKED FOR WASN'T DETACHED
	JSP TAC,ERRMES
	ASCIZ /Wasn't detached.
/
;FLUSH FLUSH0 FLUSH1 NOTTTY INUSE
;FLUSH THIS TTY'S BUFFERS IF NOT IN USE BY A JOB

FLUSH:	PUSHJ P,CTEXT1
	JUMPE TAC1,NOTENF	;NO ARG?
	MOVE TAC,TAC1
	PUSHJ P,LOG2LN		;CONVERT TO LINE NUMBER
	JRST NOTTTY
	SKIPN DDB,TTYTAB(TAC1)
	JRST FLUSH1
	MOVSI TAC,UPGPRV	;ALLOW UPGPRV TO FLUSH ANYONE
	TDNE TAC,JBTPRV(J)
	JRST FLUSH0
	LDB TAC,PJOBN
	CAME TAC,J		;LET HIM DO IT TO HIMSELF
	JUMPN TAC,INUSE		;JOB ON IT
↑FLUSH0:PUSHJ P,TSETBF		;CLEAR BUFFERS
	MOVSI TAC,TPMON!IOFST	;NO NEED TO CALL MCMSKP SINCE CLEARED INPUT BUFFER
	MOVEM TAC,DEVIOS(DDB)	;MAKE HIM A VIRGIN
	SKIPE FRCFLG		;HERE FROM CH3 RUNAWAY TTY TRAP?
	POPJ P,			;YES, DONE (VIA FORCED COMMAND ON CTY)
FLUSH1:	MOVE DDB,-2(P)		;GET BACK OUR DDB
	MOVSI TAC,UPGPRV
	ANDCAM TAC,JBTPRV(J)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,CONMES
	ASCIZ /Flushed/

NOTTTY:	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,ERRMES
	ASCIZ /Not a TTY
/

↑INUSE:	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,ERRMES
	ASCIZ /In use.
/
;MFORK CFORK FORK FORK1 FORKC LOSEJB DETCHA DETCHB DETCHD DETCHE DETCHC DETCH1 CDETACH PDETCH DETCH0 DETNBR DETACH DETCTY DDDD03 DETSHR DDDUDP LOGER1 DDDDDD DDDD01 TEMP1 INUSE1 NODTTY NOATTY NOADD

;"FORK", "CFORK", "DETACH" AND "CDETACH" COMMANDS
;"DETACH" - DETACH CONSOLE FROM JOB 
;"DETACH DEVNAM" - DETACHES DEVICE FROM THE SYSTEM SOFTWAREWISE

MFORK:	PUSH P,J		;SAVE J
	PUSHJ P,INIJOB		;INITIALIZE A JOB
	 JRST [	POP P,J		;NO JOBS AVAILABLE.
		POP P,(P)	;FLUSH CALL TO MFORK
		MOVSI TAC,NOMESS ;LET ERROR MESSAGE THROUGH
		ANDCAM TAC,-1(P)
		JRST LOSEJB]
	 JRST [	POP P,J
		POP P,(P)
		JRST DLYCM1]	;DELAY THIS COMMAND UNTIL FREE STORAGE AVAILABLE
	MOVE TAC,J
	POP P,J
	POPJ P,

CFORK:	MOVSI TAC,JERR
	TDNE TAC,JBTSTS(J)
	JRST NOCONT
	MOVM TAC,JOBQUE(J)
	CAIE TAC,STOPQ		;START HIM ONLY IF STOPPED.
	JRST FORK		;ALREADY RUNNING(MIGHT NOT BE IN RUNQ)
	PUSHJ P,MFORK		;GET A NEW JOB NUMBER IN TAC
	PUSH P,TAC
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	PUSHJ P,SETRUN
	JRST FORK1		;WE HAVE NEW JOB NUMBER ON STACK.

FORK:	PUSHJ P,MFORK		;GET US A NEW JOB NUMBER IN TAC
	PUSH P,TAC		;ALL SET.
FORK1:	OFFSCN			;TURN OFF SCANNER CHANNEL
	SETOM RSPLOK		;DON'T TOUCH RESPONSIBLE TTY IN DETCH1 & DDBSRC
	PUSH P,SAVDDB(DDB)	;SAVE ARGUMENT FROM ATTACH COMMAND TO F.LOG
	PUSH P,IMLHAC(DDB)	;SAVE MISC TTY FIELDS
	PUSH P,DEVIOS(DDB)	;SAVE OLD TOIP!IO
	PUSH P,JBTLIN(J)
	PUSHJ P,DETCH1
	POP P,TAC1		;GET BACK OLD LINE NUMBER
	HRLM J,-4(P)		;SAVE THE OLD JOB NUMBER OVER PC FLAGS FOR FORKC
	PUSHJ P,DDBSRC		;GET A NEW DDB
	 JRST [	PUSHJ P,CLRRSP	;CLEAR RSPLOK AND RESP TTY SINCE DIDN'T GET DDB
		ONSCN		;TURN SCANNER CHANNEL BACK ON
		ADJSP P,-3	;FLUSH SAVED IMLHAC AND IOS AND SAVDDB
		POP P,J		;LOSE.
		PUSHJ P,RELJOB	;RELEASE THE JOB WE GOT
		MOVEI J,0	;SIGNAL ERROR TO COMRET
		POPJ P,]
	SETZM RSPLOK
	POP P,TAC		;OLD IOS
	AND TAC,[TOIP!IO,,0]	;ONLY BITS TO BE PRESERVED
	IORM TAC,DEVIOS(DDB)	;INTO THE NEW DDB
	POP P,IMLHAC(DDB)	;RETAIN OLD IMLHAC IN NEW DDB
	POP P,SAVDDB(DDB)
	ONSCN			;TURN ON SCANNER CHANNEL
	MOVSI TAC,NOMESS
	ANDCAM TAC,-2(P)	;OK TO TALK NOW
	MOVEM DDB,-3(P)		;AND WHERE TO SAY IT
	MOVEI DAT,TTOBUF(DDB)
	POP P,J			;GET THE JOB NUMBER OF NEW JOB.
	PUSHJ P,FORKC		;COPY OLD JOB'S POOP
	HLRZ TAC,(P)		;GET OLD JOB NUMBER
	PUSHJ P,DETNBR		;TYPE NUMBER OF JOB BEING DETACHED
	PUSHJ P,CRLF
	SKIPE FRCFLG		;DID WE COME FROM FORCED LOGIN CMD FROM ATTACH
				;COMMAND WHILE LOGGED IN TO ATTACH PRIVILEGED JOB?
	JRST FLOGI2		;YES, NOW WE CAN RUN LOGIN
	PUSHJ P,PRJOB
	PUSHJ P,INLMES
	ASCIZ /
Fork you very much/
	JRST PRCRCC

↑FORKC:	MOVSI TAC,JLOG!JNA
	IORM TAC,JBTSTS(J)	;MAKE THIS JOB HIS
	SETZM DEVLOG(DDB)	;ZERO LOGICAL NAME OF TTY
	PUSHJ P,TTYATI
	HLRZ TAC,-1(P)		;GET THE OLD JOB NUMBER BACK
	MOVE TAC,PRJPRG(TAC)
	MOVEM TAC,PRJPRG(J)	;GIVE HIM SAME PPN
	HLRZ TAC,-1(P)
	MOVE TAC,JBTPRV(TAC)
	MOVEM TAC,JBTPRV(J)	;COPY PRIVILEGES
	HLRZ TAC,-1(P)
	MOVE TAC,JB2PRV(TAC)
	TLZ TAC,NSLPRV		;Don't copy the negative SL anti-priv!
	MOVEM TAC,JB2PRV(J)	;ALSO PASSIVE ONES
	PUSHJ P,SETLOG		;GET GOOD STUFF
	HLRZ TAC,-1(P)		;GET THE OLD JOB NUMBER BACK
	MOVE TAC,DSKPPN(TAC)
	MOVEM TAC,DSKPPN(J)	;GIVE HIM THE SAME ALIAS
	POPJ P,

LOSEJB:	JSP TAC,ERRMES
	ASCIZ /Job capacity exceeded
/

DETCHA:	PUSHJ P,COMRT2		;FIX COMMAND BIT, COMCNT BEFORE DETACHING.
DETCHB:	OFFSCN
	SETOM RSPLOK		;PRESERVE RESPONSIBLE TTY
	PUSH P,DEVIOS(DDB)	;SAVE OLD TOIP, IO, AND IRMA
	PUSH P,SAVDDB(DDB)	;NEEDED FOR ATTACH OLD JOB BACK AFTER LOSING F.LOG
	PUSH P,IMLHAC(DDB)	;SAVE VARIOUS VALUES FOR TTY
	PUSHJ P,TTYDET		;DETACH TTY
	 JRST DETCHC		;ALREADY DETACHED--CAN'T HAPPEN
	MOVSI IOS,IO!TOIP!IRMA
	ANDCAB IOS,DEVIOS(DDB)	;TURN OFF OLD BITS IN OLD DDB
	LDB TAC1,PUNIT		;GET LINE NUMBER (FROM NOW-DETACHED DDB)
	PUSHJ P,DDBSRC		;GET A NEW DDB
	 JRST DETCHE		;NO FREE STORAGE -- TOUGH
	MOVSI IOS,IO!TOIP!IRMA
	ANDCAM IOS,DEVIOS(DDB)	;MAKE SURE THESE BITS ARE OFF IN NEW DDB
	HLL TAC1,LINTAB(TAC1)
	TLNE TAC1,DISLIN!DDDLIN!PTYLIN
	JRST DETCHD		;NOT ON TTY SCANNER
	AND IOS,-2(P)		;SET NEW BITS FROM OLD VALUES IN OLD DDB
	IORB IOS,DEVIOS(DDB)	;COPY IO!TOIP!IRMA TO NEW DDB (ONLY IF REAL TTY)
DETCHD:	POP P,IMLHAC(DDB)	;RETAIN OLD IMLHAC
	POP P,SAVDDB(DDB)	;DITTO SAVDDB
	ADJSP P,2		;RE-PUSH IT
	AOSA -3(P)		;SUCCESS
DETCHE:	PUSHJ P,CLRRSP		;DIDN'T GET NEW DDB, GOTTA CLEAR RESPONSIBLE TTY!
DETCHC:	SETZM RSPLOK
	ADJSP P,-3		;OLD IOS AND IMLHAC
	JRST SCNONJ

;NOBODY BETTER CALL DETCH1 WITH FRCFLG SET EXCEPT FORCED LOGIN COMMAND VIA FORK
DETCH1:	SKIPN FRCFLG
	PUSHJ P,COMRT2		;FIX COMMAND BIT, COMCNT BEFORE DETACHING.
	PUSHJ P,TTYDET		;GO DETACH TTY.
	 POPJ P,		;ALREADY DETACHED
	POPJ P,

CDETACH:MOVSI TAC,JERR
	TDNE TAC,JBTSTS(J)
	JRST NOCONT
	MOVM TAC,JOBQUE(J)
	CAIE TAC,STOPQ
	JRST DETCH0
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	PUSHJ P,SETRUN
	JRST DETCH0		;NOW DO THE DETACH

;HERE FOR PDETACH COMMAND AND FORCED PDETACH FROM PTJOBX.
;TURN JOB INTO PHANTOM BEFORE DETACHING IT.
PDETCH:	JUMPE J,LOGPLM		;ERROR IF NOT ALREADY LOGGED IN
	MOVSI TAC,JLOG		
	ANDCAM TAC,JBTSTS(J)	;MAKE US INTO A PHANTOM, THEN FALL INTO DETACH CODE
;ENTER HERE FROM DETACH BELOW AND FROM FORCED DETACHED COMMAND.
DETCH0:	JUMPE J,LOGPLM		;LOGIN PLEASE
	PUSHJ P,DETCHA		;DETACH JOB AND GET A NEW DDB
	 POPJ P,		;COULDN'T GET A NEW DDB
	MOVEM DDB,-2(P)		;TELL COMRET WHERE OUR NEW DDB IS
	MOVSI TAC,NOPER!NOMESS!NOCRLF	;ASK TO TYPE OUT A PERIOD
	ANDCAM TAC,-1(P)	; BY ZEROING THESE IN THE COMMAND FLAGS
	PUSHJ P,TTYDAT		;DETACHED. GO SET UP OUTPUT BYTE PTR.
	MOVE TAC,J		;NUMBER OF JOB BEING DETACHED
	SKIPE FRCFLG		;IF FORCED DETACH COMMAND, WE NEED AN EXTRA CRLF
	PUSH P,[TYCRLF]		; AFTER PRINTING THE JOB NUMBER
DETNBR:	PUSH P,TAC
	PUSHJ P,INLMES
	ASCIZ /
Detaching job /
	POP P,TAC
	JRST RADX10		;PRINT JOB NUMBER

DETACH:	PUSHJ P,CTEXT		;GET ARGUMENT
	JUMPE TAC1,DETCH0	;ONLY "DET" TYPED
	MOVSI TAC,NOPER!NOCRLF!NOMESS	;ASK TO TYPE OUT A CRLF AND A PERIOD
	ANDCAM TAC,-1(P)	; BY ZEROING THESE IN THE COMMAND FLAGS
	MOVEI AC1,(DDB)		;BH 8/5/78 DETACH DEVICE LEGAL FROM CTY
	CAIN AC1,SCNDDB		;BH
	JRST DETCTY		;BH
	JUMPE J,LOGPLM		;BH (HAD TO MAKE THIS CMD NOJOBN!NOLOGIN FOR CTY)
	MOVE AC1,JB2PRV(J)	;GET PRIV BITS (PASSIVE)
	TLNN AC1,DEVPRV		;DEVICE DETACH-ATTACH PRIV?
	JRST LOGER1		;NO-PRINT ERROR MSG.
DETCTY:	MOVE TAC,TAC1		;YES-SET UP DEVICE NAME
IFE FTF2,<
	CAIN TEM,"!"		;CHECK FOR "DET DDn!"
	JRST DDDDDD		; MEANS "HARD" DETACH OF DD CHAN ONLY
>;IFE FTF2
	PUSH P,DDB		;SAVE TTY DDB
	PUSHJ P,DEVPHY		;SEARCH FOR PHYSICAL DEVICE (returns SYSDEV in LH)
IFE FTF2,<
	 JRST DDDD01		;DEVICE NOT FOUND
>;IFE FTF2
IFN FTF2,<
	 JRST TEMP1		;DEVICE NOT FOUND
>;IFN FTF2
	MOVE TAC,DEVMOD(DDB)	;CHECK TO SEE IF THIS IS DSK
	TLNE TAC,DVUDP		;IS IT A UDP?
	JRST DDDUDP		;YES, BIG MESS
	MOVE TAC1,DEVCMR(DDB)	;If this is sharable device, must be model DDB
	TLNE TAC1,DEVSHR	;Skip unless sharable device
	JRST DETSHR		;Sharable, mark model DDB with ASSCON
	TLNE TAC,DVTTY		;IS IT A TTY?
	JRST NODTTY		;YES, CAN'T DETACH
	MOVEI TAC1,ASSPRG	;IS DEVICE IN USE BY ANY PROGRAM?
	TDNE TAC1,DEVMOD(DDB)
	JRST ASSER1		;DEVICE IS BUSY (DON'T DET IF IN USE BY THIS JOB).
	MOVEI TAC1,ASSCON	;FOUND-SET UP ASSIGNED BY CONSOLE
	PUSHJ P,ASSASG		;TRY TO ASSIGN
	 JRST ASSER1		;CAN'T ASSIGN
	TLNE DDB,SYSDEV		;IS THIS SYSTEM DEVICE?
	JRST TEMP1		;YES-PRINT ERROR MSG. (after we assigned it?)
	MOVEI AC1,0		;NO-SET TO ZERO
	DPB AC1,PJOBN		;SET JOB NUMBER TO NULL JOB
DDDD03:	SKIPE FRCFLG		;FORCED DEVICE DETACH? (FROM CH3 RUNAWAY TTY TRAP)
	JRST FLUSH0		;YES, FLUSH BUFFERS TOO
	POP P,DDB		;RESTORE OUR TTY DDB
	MOVSI TAC,NOPER!NOCRLF!NOMESS	;ASK TO TYPE OUT A CRLF AND A PERIOD
	ANDCAM TAC,-1(P)	; BY ZEROING THESE IN THE COMMAND FLAGS
	POPJ P,			;SUCCESSFUL RETURN

;Here to detach a sharable device.  DDBs of this device that are already in
;use will continue undisturbed, but no more can be made after this until device
;is re-attached to system.  BE CAREFUL USING THIS: it works for device DSK! 
DETSHR:	MOVEI TAC1,ASSCON	;Mark model DDB as in use (PJOBN always zero)
	IORM TAC1,DEVMOD(DDB)	;Model is "in use by console"
	JRST DDDD03		;Rejoin normal detach code for return

NoStructure,<
DDDUDP:	LDB TAC,PUNIT		;TRYING TO DETACH UDP, GET UNIT NUMBER
	SKIPE UDPCNT-1(TAC)	;MUST HAVE NO OUTSTANDING DDBS
	JRST TEMP1		;ELSE LOSE
	SETZM UDPOWN-1(TAC)	;OK, SET JOB 0 AS OWNER
	JRST DDDD03		;ANNOUNCE WIN
>;NoStructure
IfStructure,<
DDDUDP:	MOVE TAC,SDBPTR(DDB)	;TRYING TO DETACH UDP, GET SDB Address
	SKIPE ST.CNT(TAC)	;MUST HAVE NO OUTSTANDING DDBS
	JRST TEMP1		;ELSE LOSE
	SETZM ST.JOB(TAC)	;OK, SET JOB 0 AS OWNER
	JRST DDDD03		;ANNOUNCE WIN
>;IfStructure

LOGER1:	JSP TAC,ERRMES
	ASCIZ /Can't detach device
/

IFE FTF2,<
DDDDDD:	PUSHJ P,DADD00		;"DET DDN!" ARG MUST BE DD CHANNEL
	 JRST LOGER1		;NOPE
	MOVEI TAC,(TAC1)	;YES, CHANNEL NUMBER IN TAC
	HRLI TAC,DDDETU!DDANYW	;USE FIELD AND BIT IN LH
	PUSHJ P,DDCGET		;TRY TO GET THE CHANNEL
	 CAIA			;FAILED, MAYBE IT IS ALREADY DETACHED
	POPJ P,			;WON (NOT DDDD03 BECAUSE DDB ISN'T PUSHED)
	LDB TAC1,DDUSRT		;Get use field for DD whose number is in TAC
	CAIN TAC1,DDDETU	;Is channel already detached?
	POPJ P,			;Yes
;;;	HRRZM TAC,DDDETQ	;No, queue it (one-entry queue) for det on kill
	MOVEI TAC1,DDKILL	;No, turn on bit
	IORM TAC1,DDTAB(TAC)	; to detach it when it goes available
	JSP TAC,ERRMES
	ASCIZ /In use, will be detached when available.
/

DDDD01:	PUSHJ P,DADD00		;NOT A DEV, TRY DD CHAN
	 JRST TEMP1		;NO
	MOVEI TAC,DDBADB	;GET BAD BIT
	IORM TAC,DDTAB(TAC1)	;SET IN TABLE
	JRST DDDD03		;WIN
>;IFE FTF2

TEMP1:	POP P,DDB		;RESTORE TTY DDB
INUSE1:	JSP TAC,ERRMES
	ASCIZ /In use.
/

NODTTY:	LDB TAC,PJOBN		;SEE IF THIS DDB IS IN USE
	JUMPN TAC,.+2
	PUSHJ P,TTYDIE		;NOT IN USE, FLUSH DDB WE CREATED, quickly
	POP P,DDB		;RESTORE OUR TTY DDB
	JSP TAC,ERRMES
	ASCIZ /Can't detach TTY.  Use "TTY NO EXIST nnn" instead.
/
;"DAYTIME" COMMAND ;⊗ DAYTIM PRDATM SETTIM SETTI0 SETTI2 SETTI3 DAYT2 PDDATE DAYTAB MONTHB KL11TM KL11T2 DAYCNT MONTHX DCTOSD DCTOS1 DCTOS2 DCTOS3 DCTOS4 DCTOS5

↑DAYTIM:PUSHJ P,DECIN		;PICK UP JOB NUMBER ARGUMENT
	JRST DAYT2		;NO ARGUMENT.  GIVE HIM DAY, DATE & TIME
	JRST COMERA		;ILLEGAL DECIMAL ARGUMENT
	JUMPN TAC1,.+2		;ZERO ARGUMENT?
	MOVE TAC1,J		;YES.  "DAYTIME 0" GETS TIMES FOR OWN JOB
	MOVE TAC,JBTSTS(TAC1)
	TLNE TAC,JNA!CMWB
	TLNE TAC,JSEG
	JRST NOTLOG		;NO JOB OR A SEGMENT.  PRINT NO SUCH JOB.

	PUSH P,[0]		;INITIALIZE A FLAG - DON'T PRINT DATES
	HLRZ TAC,JBTBTM(TAC1)	;GET LOGIN DATE
	CAME TAC,THSDAT		;DID HE LOGIN TODAY?
	SETOM (P)		;NO.  FLAG TO PRINT DATES
	MOVEI TAC,[ASCIZ /Login   Run    Now
/]
	SKIPE (P)		;PRINTING DATES?
	MOVEI TAC,[ASCIZ /  Login      Run       Now
/]				;YES, LEAVE ROOM FOR DATES
	PUSHJ P,CONMES		;PRINT TITLES
	MOVE TAC,JBTBTM(TAC1)	;GET LOGIN DATE/TIME
	PUSHJ P,PRDATM		; AND PRINT IT
	MOVE TAC,FTIME(TAC1)	;GET DATE/TIME LAST RUN
	PUSHJ P,PRDATM		; AND PRINT IT
	MOVE TAC,TIMDAT		;GET CURRENT DATE/TIME
	PUSHJ P,PRDATM		; AND PRINT IT
	SUB P,[1,,1]		;POP FLAG
	JRST CRLF		;PRINT CRLF, AND RETURN

PRDATM:	SKIPN -1(P)		;ARE WE PRINTING DATES?
	JRST PDTIM0		;NO.  JUST PRINT TIME
	PUSH P,TAC1		;YES.
	PUSH P,TAC
	HLRZ TAC,TAC		;GET DATE
	IDIVI TAC,=31		;CONVERT TO DAY OF MONTH
	MOVEI TAC,1(TAC1)	; WHICH IS THE REMAINDER+1
	MOVEI TEM," "
	PUSHJ P,PRTIM3		;PRINT DATE IN 2 COLS PADDING WITH LEADING BLANK
	MOVEI TEM,"-"
	XCT TYO
	POP P,TAC
	ANDI TAC,-1		;CLEAR THE DATE HALF OF TAC
	JRST PDTIM1		;PRINT TIME

SETTIM:	PUSHJ P,STLNAC		;SET UP LINE(TAC1)
IFE FTF2,<
	TLNN TAC1,CTYLIN	;IS HE ON THE CTY? (Leave evidence there of change)
	JRST COMERR		;NO, FLUSH HIM
>;IFE FTF2
IFN FTF2,<	;Grumble, grumble.  DWP should fix the tape controller.
	TLNN TAC1,CTYLIN	;IS HE ON THE CTY? (Leave evidence there of change)
	JUMPE J,COMERR		;  No, must be logged in then.
>;IFN FTF2
	PUSHJ P,DECIN		;Read four digit decimal time
	 JRST COMERA		;NO ARG GIVEN
	 JRST COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
	MOVE AC1,TAC1		;Get time given
	CAIE TEM,":"		;Either form is OK, with or without colon
	JRST SETTI0		;Must be four digit time
	PUSHJ P,DECIN		;Read minutes
	 JRST COMERA		;NO ARG GIVEN
	 JRST COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
	SKIPA AC2,TAC1		;Minutes to AC2, hours already in AC1
SETTI0:	IDIVI AC1,=100		;Hours to AC1, Minutes to AC2
	CAIL AC2,=60		;Make sure minutes field isn't too big!
	JRST COMERA
	IMULI AC1,=60		;Convert hours to minutes
	ADDI AC1,(AC2)		;Add in minutes
	CAILE AC1,=24*=60	;Make sure time isn't greater than 2400
	JRST COMERA		;Oops
	IMULI AC1,JIFMIN	;Convert minutes to ticks
	SUB AC1,TIME		;Get amount of time change, so can pass to PSTIME
	JUMPGE AC1,SETTI2	;Jump if later in day
	CAIE TEM,175		;Next day, I assume, must have used altmode
	JRST SETTI3		;No, tell him to use altmode, can't back up time
	ADD AC1,[=24*=60*JIFMIN] ;Really wants next day, leave work to MIDCHK
SETTI2:	ADDM AC1,TIME		;Update time of day
	ADDM AC1,PSTIME		;And PST version too
	MOVEI AC1,TIME
	MOVEI AC2,THSDAT
	PUSHJ P,MIDCHK		;CHECK FOR HAVING PASSED MIDNIGHT (LOCAL TIME)
	MOVEI AC1,PSTIME
	MOVEI AC2,PSDATE
	PUSHJ P,MIDCHK		;CHECK FOR HAVING PASSED MIDNIGHT (PST)
	PUSHJ P,TDSET		;Set up TIMDAT, PSTDAT
	PUSH P,TIMDAT		;Time correction usually indicates a disaster
	POP P,LASTDISASTERTIME	; stopped the system, so record disaster time
	CAIN TEM,175
	PUSHJ P,TYCRLF		;Altmode used, get new line for typeout
IFN FTF2,<
	PUSHJ P,STLNAC		;SET UP LINE(TAC1)
	TLNE TAC1,CTYLIN	;IS HE ON THE CTY? (Leave evidence there of change)
	 JRST DAYT2		;  Yes, no need to log it.
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /SETTIM/
	LDB J,PJOBN		;JOB NUMBER OF INITIATING JOB
	PUSHJ P,DISJOB		;PRINT JOB NUMBER AND NAME OF INITIATING JOB
	MOVE TAC,PRJPRG(J)
	PUSHJ P,DISPPN		;PRINT PPN OF INITIATING JOB
	HRRZ J,JBTLIN(J)	;TTY NUMBER OF INITIATING JOB
	PUSHJ P,DISMES
	ASCIZ/ on TTY/
	MOVE TAC,J		;TTY NUMBER
	PUSHJ P,DISLOC		;PRINT TTY NUMBER (SHOULDN'T BE DETACHED!)
	PUSHJ P,DISCRLF
>;IFN FTF2
	JRST DAYT2		;Now type out new date and time

SETTI3:	JSP TAC,ERRMES
	ASCIZ/Can't backup time!  End time with Altmode to mean next day.
/

LOSYS		;CALLED FROM ONCE BEFORE MAP SETUP

↑DAYT2:	PUSH P,DAT
	PUSH P,J
	MOVE TAC,THSDAT		;PICKUP DATE
	PUSHJ P,DAYCNT		;CALCULATE
	IDIVI TAC,7
	LSH TAC1,1
	MOVEI TAC,DAYTAB(TAC1)	;LOAD ADDRESS OF ASCIZ STRING
	PUSHJ P,CONMES
	PUSHJ P,PRSPC
	POP P,J
	POP P,DAT
	MOVE TAC,THSDAT
	PUSHJ P,PDDATE
	PUSHJ P,PRSPC		;ADD SPACES
	HRRZ TAC,TIMDAT		;PRINT TIME OF DAY
	PUSHJ P,PDTIME
IFE FTF2,<
	MOVE TAC,UPTIME		;DON'T PRINT TEMPS IF HAVEN'T READ THERMO YET
	CAIG TAC,JIFSEC
	JRST CRLF
	MOVE TAC,OTHERM		;GET OUTSIDE TEMPERATURE
	PUSH P,TAC		;SAVE FOR CENTIGRADE PRINTOUT
	PUSHJ P,SRAD10		;PRINT SIGNED FAHRENHEIT TEMP
	MOVEI TEM,"F"
	XCT TYO
	PUSHJ P,PR2SP
	POP P,TAC
	SUBI TAC,=32
	IMULI TAC,5
	IDIVI TAC,9
	CAILE TAC1,4
	AOJA TAC,.+3
	CAMGE TAC1,[-4]
	SUBI TAC,1
	PUSHJ P,SRAD10
	MOVEI TEM,"C"
	XCT TYO
>;IFE FTF2
	JRST CRLF

PDDATE:	IDIVI TAC,=31
	EXCH TAC,TAC1		;YEAR AND MONTH IN TAC1
	AOS TAC			;DAY IN TAC
	PUSHJ P,RADX10		;PRINT DAY
	MOVEI TAC,0
	DIVI TAC,=12
	EXCH TAC,TAC1
	MOVE TAC,MONTAB(TAC)	;MONTH
	DPB TAC,[POINT 21,DAMESS,27]
	MOVEI TAC,DAMESS
	PUSHJ P,CONMES		;PRINT DAY
	MOVEI TAC,=64(TAC1)
	JRST RADX10		;PRINT YEAR AND RETURN

↑DAYTAB:ASCIZ/Wednesday/
	ASCIZ/Thursday/
	ASCIZ/Friday/
	ASCIZ/Saturday/
	ASCIZ/Sunday/
	ASCIZ/Monday/
	ASCIZ/Tuesday/

MONTHB:	0			;JAN
	=31			;FEB
	=59			;MAR
	=90			;APR
	=120			;MAY
	=151			;JUN
	=181			;JUL
	=212			;AUG
	=243			;SEP
	=273			;OCT
	=304			;NOV
	=334			;DEC

IFN FT11CLK,<
;Here for 11TIME command -- show last time read from PDP-11 realtime clock.
;Note that that time may have been read up to 5 mins ago.  If you want it
;read right away, then clear CONYET and wait a tick.
KL11TM:	PUSHJ P,CTEXT1		;GET ARGUMENT, if any
	CAME TAC1,['NOW   ']	;use this arg to force 11 to give us time of day
	JRST KL11T2
	SETZM CONALV		;Make sure 11 is giving us the time
	SETZM CONYET		;Quickly ask 11 for time
KL11T2:	MOVEI TAC,[ASCIZ /Console-11 last claimed:  /]
	PUSHJ P,CONMES
	MOVE TAC,DATE11		;get 11's date
	PUSHJ P,PDDATE		;print date
	PUSHJ P,PRSPC		;ADD SPACES
	MOVE TAC,TIME11		;get time in ticks
	IDIVI TAC,JIFSEC	;make it seconds
	PUSHJ P,PDTIME		;PRINT TIME 11 told us
	MOVEI TAC,[ASCIZ / standard time/]
	JRST CONMES
>;IFN FT11CLK

;CALL WITH TAC SET UP W/ SYSTEM FORMAT DATE.
;RETURN W/ TAC= NUMBER OF DAYS SINCE JAN 1, 1964
;TAC1 AND DAT CLOBBERED
↑DAYCNT:IDIVI TAC,=31		;DAY OF THE MONTH IN TAC1
	MOVEI DAT,1(TAC1)	;DAY INTO DAT
	IDIVI TAC,=12		;MONTHS IN TAC1, YEARS IN TAC
	ADD DAT,MONTHB(TAC1)	;ADD NUMBER OF DAYS IN YEAR BEFORE THE 1st OF MONTH
	TRNN TAC,3		;SKIP UNLESS LEAP YEAR
	CAIGE TAC1,2		;LY. SKIP IF AFTER FEBRUARY
	SUBI DAT,1		;NOT LEAP YEAR. OR BEFORE MARCH
	MOVEI TAC1,3(TAC)
	LSH TAC1,-2		;NUMBER OF LY SINCE '64 NOT INCLUDING THIS YEAR
	IMULI TAC,=365		;NUMBER OF YEARS TIMES 365
	ADDI TAC,(TAC1)		;PLUS NUMBER OF PRIOR LEAP YEARS
	ADDI TAC,(DAT)		;PLUS NUMBER OF DAYS SO FAR THIS YEAR.
	POPJ P,

MONTHX:	0			;JAN
	=31			;FEB
	=60			;MAR
	=91			;APR
	=121			;MAY
	=152			;JUN
	=182			;JUL
	=213			;AUG
	=244			;SEP
	=274			;OCT
	=305			;NOV
	=335			;DEC


;DAYCOUNT IN TAC TO SYSTEM DATE FORMAT IN TAC.
↑DCTOSD:MOVEI AC3,=1964		;COUNT YEARS.  START AT 1964
DCTOS1:	TRNE AC3,3		;IS THIS A LEAP YEAR?
	JRST DCTOS3		;NO.
	MOVE AC1,AC3		;IS THIS A CENTURY YEAR
	IDIVI AC1,=100	
	JUMPN AC2,DCTOS2	;JUMP IF NOT CENTURY YEAR. THIS IS A LEAP YEAR
	TRNE AC1,3		;CENTURY YEARS ARE LEAP YEARS IF MULTIPLES OF 400
	JRST DCTOS3		;CENTURY YEAR NOT A MULTIPLE OF 400 ISN'T LEAP
DCTOS2:	CAIGE TAC,=366		;A FULL YEAR'S WORTH OF DAYS LEFT?
	JRST DCTOS5		;NO.  AC3 CONTAINS CORRECT YEAR.
	SUBI TAC,=366
	AOJA AC3,DCTOS1		;COUNT A YEAR AND LOOP

DCTOS3:	CAIGE TAC,=365
	JRST DCTOS4		;AC3 HAS CORRECT YEAR
	SUBI TAC,=365
	AOJA AC3,DCTOS1

DCTOS4:	CAIL TAC,=31+=28	;NOT A LEAP YEAR. IS THIS MARCH OR LATER?
	ADDI TAC,1		;YES.  COMPENSATE FOR MONTHX
DCTOS5:	SUBI AC3,=1964
	IMULI AC3,=12*=31
	MOVEI AC2,=11		;COUNT DOWN MONTHS TO FIND FIRST ONE THAT'S SMALL
	CAMGE TAC,MONTHX(AC2)
	SOJA AC2,.-1
	SUB TAC,MONTHX(AC2)
	IMULI AC2,=31
	ADD TAC,AC2
	ADD TAC,AC3
	POPJ P,
	
HISYS
;RUNTIM CRUN3 CRUN4 CRUN4D CRUN4C CRUN1 CRUN2 CRUN2X CRUN4B PITIME PITIM2 PITIML PITNAM PERCN0 PERCNT PERCN1 PR2SP TYOPOP PRCOMA PRCOLN PRTIME PRTIM1 PDTIMX PRTIM2 PRTIM3 PDTIM0 PDTIME PDTIM1
;"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
;"TIME 0" IMPLIES RUNTIME FOR NULL JOB AND THE TOTAL TIME SPENT SHUFFLING USERS
;	IF NO JOB NO. GIVEN-TIME WILL BE FOR CURRENTLY LOGGED IN JOB NO.

RUNTIM:	PUSHJ P,DECIN		;GET JOB NO. ARG.
	JRST CRUN1		;NO ARG. GIVEN
	JRST COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
	JUMPE TAC1,CRUN2	;RUNTIME 0 GIVEN?
	CAIL TAC1,JOBN		;JOB NO. TOO BIG?
	JRST NOTLOG		;YES, ILLEGAL JOB NUMBER
CRUN3:	MOVE TAC,JBTSTS(TAC1)	;IS THIS A REAL JOB WE HAVE HERE?
	TLNE TAC,JNA		;SKIP IF NO NUMBER ASSIGNED.
	TLNE TAC,JSEG		;THERE IS A JOB HERE. SKIP IF NOT A SEGMENT
	JRST NOTLOG		;NO JOB OR A SEGMENT. PRINT NO SUCH JOB.
	PUSHJ P,INLMES		;PRINT TITLES
IFE FTMTRTIME,<
	ASCIZ /Total,Increment,Wait,PS = 
/
>;IFE FTMTRTIME
IFN FTMTRTIME,<
	ASCIZ /Total,Increment,Wait,PS,EBOX msec,Incr=
/
>;IFN FTMTRTIME
IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST CRUN4
	PUSH P,TAC1
	LSH TAC1,1
	DMOVE TAC,MTRTTIME(TAC1)
	PUSHJ P,MTRCVT		;CONVERT TO TICS IN TAC
	POP P,TAC1
	CAIA
CRUN4:
>;IFN FTMTRACT
	MOVE TAC,TTIME(TAC1)	;CPU TIME SINCE LAST LOGIN
	PUSH P,TAC
	PUSHJ P,PRTIME		;PRINT COMPUTE TIME USED
	MOVE TAC,(P)		;CALCULATE INCREMENTAL RUN TIME
	SUB TAC,RTIME(TAC1)
	PUSHJ P,PRTIME		; AND PRINT IT
	POP P,TAC
	CAMN J,TAC1		;PRINTING TIME OUT FOR OWN JOB?
	MOVEM TAC,RTIME(TAC1)	;YES.  RESET INCREMENTAL TIME.

	SKIPGE TAC,JBTWAT(TAC1)	;GET TIME WAITING FOR SYSTEM
	ADD TAC,UPTIME		;MAKE THIS TIME REAL
	PUSHJ P,PRTIME		; AND PRINT IT
	MOVE TAC,JBTKCJ(TAC1)	;PAGE-JIFFIES USED
	PUSH P,TAC1
	IDIVI TAC,=60		;CONVERT TO PAGE-SECONDS
	POP P,TAC1
IFE FTMTRTIME,<
	JRST DECLF		;PRINT DECIMAL WITH A CRLF.  RETURN TO COMRET.
>;IFE FTMTRTIME
IFN FTMTRTIME,<
	PUSHJ P,RADX10		;PRINT DECIMAL
	SKIPN MTRBKG
	JRST CRUN4C
	PUSHJ P,PRCOMA		;PRINT A COMMA
	LSH TAC1,1
	DMOVE AC1,MTRETIME(TAC1);GET DOUBLEWORD EBOX TIME FOR JOB
	PUSHJ P,MTRMSC		;CONVERT TO MSECONDS IN TAC
	PUSHJ P,RADX10		;PRINT IT
	SKIPGE MTRRTIME(TAC1)
	JRST CRUN4D
	PUSHJ P,PRCOMA
	DMOVE AC1,MTRETIME(TAC1)
	DSUB AC1,MTRRTIME(TAC1)
	PUSHJ P,MTRMSC		;INCREMENTAL RUN TIME IN MSEC
	PUSHJ P,DECLF		;PRINT IN DECIMAL WITH CRLF
	CAIA
CRUN4D:	PUSHJ P,CRUN4C
	DMOVE AC1,MTRETIME(TAC1)
	DMOVEM AC1,MTRRTIME(TAC1)
	POPJ P,
>;IFN FTMTRTIME

IFN FTMTRTIME,<
CRUN4C:	PUSHJ P,INLMES
	ASCIZ /,unknown
/
	POPJ P,
>;IFN FTMTRTIME

CRUN1:	SKIPE TAC1,J		;LOGGED IN?
	JRST CRUN3		;YES.  GIVE HIM HIS OWN TIME.
CRUN2:	PUSHJ P,INLMES		;"TIME 0" OR UNLOGGED IN "TI"
	ASCIZ /Up /
	MOVE TAC,UPTIME
	IDIVI TAC,=60*=60	;CONVERT TO MINUTES
	IDIVI TAC,=60		;CALCULATE HOURS
	PUSH P,TAC1		;SAVE MINUTES
	PUSHJ P,RADX10		;PRINT HOURS
	PUSHJ P,INLMES
	ASCIZ / hr /
	POP P,TAC		;RETRIEVE MINUTES
	PUSHJ P,RADX10		;PRINT MINUTES
	SKIPN LASTDISASTERTIME
	 JRST CRUN2X		;NO DISASTER HAS OCCURED (BUT DON'T BET ON IT!)
	PUSHJ P,INLMES
	ASCIZ /; paused /
	HLRZ TAC,LASTDISASTERTIME
	CAME TAC,THSDAT
	PUSHJ P,PDDATE
	PUSHJ P,PR2SP		;ADD SPACES
	HRRZ TAC,LASTDISASTERTIME ;PRINT TIME OF DAY
	PUSHJ P,PDTIMX
CRUN2X:	PUSHJ P,INLMES
	ASCIZ /;  Null /
IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST CRUN4B
	DMOVE TAC,MTRTTIME
	PUSHJ P,MTRCVT		;CONVERT TO TICS IN TAC
	CAIA
CRUN4B:
>;IFN FTMTRACT
	MOVE TAC,TTIME		;GET NULL TIME
	PUSHJ P,PERCNT		;AND PRINT AS A PERCENTAGE OF UPTIME
	PUSHJ P,INLMES
	ASCIZ /;  Ilev /
	MOVE TAC,INTIME
	PUSHJ P,PERCNT
	PUSHJ P,INLMES
	ASCIZ /;  RIT /
	MOVE TAC,JLRIT
	JRST PERCN1		;print percentage and return

;Here for PITIME command to show approx times in each PI channel below the
;APR channel, plus time spent below the scanner channel with that channel off.
PITIME:	MOVE UCHN,[APRCHN-7-2,,USTIME] ;aobjn ptr to all clk int counts
	MOVEI DSER,0		;count total of recorded clk ints
PITIM2:	ADD DSER,(UCHN)		;count more ints
	AOBJN UCHN,PITIM2	;add USTIME, UUTIME, and PI chans below APRCHN
;Now we have the total in DSER.  Print individual percentages like this:
;User 61.3%  UUO 10.0%  Ch7 10.1%  Ch6 0.1%  Ch5 5.5%  Ch4 3.3%  ScnOff 10.1%
	MOVSI UCHN,APRCHN-7-3	;make aobjn ptr to counts/names
PITIML:	MOVEI TAC,PITNAM(UCHN)	;ptr to ASCIZ name
	PUSHJ P,CONMES		;print title
	MOVEI TEM," "
	XCT TYO			;print space between title and percentage
	MOVE TAC,USTIME(UCHN)	;get int count of this kind
	PUSHJ P,PERCN0		;print percentage
	AOBJP UCHN,CPOPJ	;avoid spaces at end of line, jump if all done
	PUSHJ P,INLMES
	ASCIZ/  /		;two spaces between items
	JRST PITIML

;Table of titles used to label interrupt percentages.
;This table must parallel that at USTIME in CACDAT.
PITNAM:	ASCII/User/		;All but last must be one word ASCIZ
	ASCII/UUO/
FOR @' I←7,APRCHN+1,-1<
	ASCII/Ch'I/
>;FOR
	ASCIZ/ScnOff/		;must be last, since more than one word


;ROUTINE TO PRINT A PERCENTAGE OF UPTIME IN FORM "DD.D%"
;CALL WITH TIME (IN TICKS) IN TAC: PUSHJ P,PERCNT

PERCN0:	SKIPA TEM,DSER		;enter here to print percentage of TAC/DSER
PERCNT:	MOVE TEM,UPTIME		;percentage of TAC/UPTIME
	MULI TAC,=1000		;allow for double word intermediate result
	DIV TAC,TEM
PERCN1:	IDIVI TAC,=10		;CALCULATE PERCENTAGE
	PUSH P,TAC1		;SAVE FRACTION
	PUSHJ P,RADX10		;PRINT INTEGRAL PART OF PERCENTAGE
	PUSHJ P,PRPER		;PRINT A PERIOD
	POP P,TEM
	ADDI TEM,"0"
	XCT TYO			;PRINT TENTHS OF A PERCENT
	MOVEI TEM,"%"
	XCT TYO			;PRINT PERCENT SIGN
	POPJ P,

PR2SP:	MOVEI TEM," "
	XCT TYO
TYOPOP:	XCT TYO			;PRINT TWO SPACES AFTER TIME
	POPJ P,

PRCOMA:	SKIPA TEM,[","]
PRCOLN:	MOVEI TEM,":"		;PRINT COLON
	JRST TYOPOP

;ROUTINE TO PRINT A TIME IN FORMAT "H:MM:SS'TT  " (HOURS, MINS, SECS, TICKS)
;CALL WITH TIME IN TICKS IN TAC.  PRESERVES TAC1!
PRTIME:	PUSH P,TAC1
	IDIVI TAC,=60*=60*=60	;HOURS INTO TAC
	JUMPE TAC,PRTIM1	;PRINT 2 SPACES INSTEAD OF 0: FOR HOURS
	PUSHJ P,RADX10
	PUSHJ P,PRCOLN		;PRINT COLON
	TRCA TEM,"0"≠":"	;MAKE SURE MINUTES GET PADDED WITH 0 IF NECESSARY
PRTIM1:	PUSHJ P,PR2SP		;PRINT 2 SPACES
	MOVE TAC,TAC1
	IDIVI TAC,=60*=60	;MINUTES INTO TAC
	PUSHJ P,PRTIM3
	PUSHJ P,PRCOLN
	MOVE TAC,TAC1
	IDIVI TAC,=60		;SECONDS INTO TAC
	PUSHJ P,PRTIM2		;PRINT WITH LEADING 0 IF NECESSARY
	MOVEI TEM,"'"		;USE RIGHT QUOTE TO PUNCTUATE TICKS
	XCT TYO
	MOVE TAC,TAC1		;TICKS INTO TAC
	PUSHJ P,PRTIM2
	PUSHJ P,PRCOMA
	POP P,TAC1		;RESTORE TAC1 FROM STACK
	POPJ P,			;AND RETURN

PDTIMX:	IDIVI TAC,=60*=60	;HOURS INTO TAC
	PUSHJ P,PRTIM2		;PRINT HOURS WITH LEADING 0 IF NECESSARY
	PUSHJ P,PRCOLN
	MOVE TAC,TAC1
	IDIVI TAC,=60		;MINUTES INTO TAC
PRTIM2:	MOVEI TEM,"0"		;PAD WITH LEADING 0 IF NECESSARY
PRTIM3:	CAIGE TAC,=10		;ANY PADDING NEEDED?
	XCT TYO			;YES.  ONE CHARACTER OF PADDING PLEASE
	JRST RADX10		;NOW PRINT TAC AS DECIMAL NUMBER AND RETURN

;ROUTINE TO PRINT TIME OF DAY IN FORMAT "HH:MM  "
;CALL WITH TIME IN SECONDS IN TAC.  PRESERVES TAC1
PDTIM0:	ANDI TAC,-1		;CLEAR DATE IN LEFT HALF OF TAC
PDTIME:	PUSH P,TAC1		;SAVE TAC1
PDTIM1:	PUSHJ P,PDTIMX
	POP P,TAC1		;RESTORE TAC1
	JRST PR2SP
;TALK TALK0 TALK00 TALK9 TALK0L TALK1 TALK3 TALK4 TALK5 TALK5B TALK5A TALK7 TALK6 TALK62 TALK61 TALK8 TALKE4 TALKE5 TALKE6 TALKE7 TALKE8 TALKE9 NETALK

;ROUTINE TO LET TTY TALK TO ANY OTHER RING OF TTYS
;	"TALK TTYN" OR "TALK PRG" IF ONLY ONE NON-DETACHED JOB WITH THAT PRG
;	TTYN NEED NEVER HAVE BEEN TYPED ON BEFORE

TALK:	PUSHJ P,CTEXT		;GET ARGUMENT
	JUMPE TAC1,[MOVEM J,-1(P) ;NONE SPECIFIED
		    JRST NOTENF]
TALK0:	CAIE TEM,175
	CAIN TEM,12
	JRST TALK00		;REACHED END OF LINE
	CAIE TEM,"%"
	CAIN TEM,"@"
	JRST NETALK
	PUSHJ P,GETCHR
	JRST TALK0

TALK00:	MOVE TAC,TAC1
	JUMPN J,TALK9		;PUT NOT LOGGED IN CHECK HERE FOR SPECIAL MESSAGE
	PUSHJ P,STLNAC
	TLNE TAC1,DISLIN!DDDLIN!CTYLIN
	 JRST TALK9		;LOCAL TERMINALS ARE GOOD GUYS
	TLNE TAC1,PTYLIN	;A LITTLE PARANOIA NEVER HURT NOBODY
	 TLNN TAC1,IMPBIT	;ARPA PTY?
	  JRST TALK0L		;NO, DEFINITELY A LOSER
	SKIPN J,PTYJOB-PTYL0(TAC1) ;GET JOB NUMBER OF OWNER
	 JRST TALK0L		;ORPHANS ARE DEFINITE LOSERS
	DMOVE AC1,[SIXBIT/NETSYSRSSER/] ;[NET,SYS] RSSER IS A WINNER
	CAMN AC1,PRJPRG(J)
	 CAME AC2,JOBNAM(J)
	  JRST TALK0L
TALK9:	PUSHJ P,DEVSRC		;SEARCH FOR DEVICE
	 JRST TALK3		;NONE AVAIL
	MOVE TEM,DEVMOD(DDB)
	TLNN TEM,DVTTY
	JRST TALK3		;TRY IT AS A USER NAME
	PUSHJ P,TTYTLK
	 JRST TALK1
	POPJ P,

TALK0L:	MOVE DDB,-2(P)
	MOVSI J,NOINCK
	MOVEM J,-1(P)
	JSP TAC,ERRMES
	ASCIZ /Please use the SEND command and let the user link back to you
/

TALK1:	MOVE DDB,-2(P)		;RESTORE TTY DDB
	MOVSI J,NOINCK		;SET FLAGS TO PRINT RESPONSE
	MOVEM J,-1(P)
	JSP TAC,ERRMES
	ASCIZ /busy
/

TALK3:	TLC TAC,'TTY'
	TLNN TAC,-1
	JRST TALKE6		;NON-EX PTY OR TTY
	TLC TAC,'TTY'		;ELSE RESTORE TAC
	TRNE TAC,77		;RIGHT ADJUST PRG
	JRST TALK4		;OK
	LSH TAC,-6
	JUMPN TAC,TALK3		;CAN'T NOT JUMP BUT IT'S FREE
TALK4:	MOVE DDB,-2(P)		;RESTORE OUR TTY DDB
	MOVE AC2,TAC		;PRG IN AC2 FOR ESCQY
	TLNE AC2,-1		;TOO BIG?
	JRST TALKE4		;YUP
	MOVEI AC3,1		;FORWARD DIRECTION
	MOVEI AC1,0		;STARTING JOB NUMBER
TALK5:	PUSHJ P,ESCQX		;LOOK FOR A JOB (SKIPS ON FAILURE)
	 SKIPA TAC,JBTLIN(AC1)	;FOUND ONE, SEE IF DETACHED
	JRST TALKE9		;NOT EVEN ONE JOB FOUND
	AOJE TAC,TALK5		;DETACHED, FIND ANOTHER
	JRST TALK5A

TALK5B:	PUSHJ P,ESCQX		;BUSY, LOOK FOR A JOB (SKIPS ON FAILURE)
	 SKIPA TAC,JBTLIN(AC1)
	JRST TALKE5		;NO WINNERS FOUND
	AOJE TAC,TALK5B		;TRY AGAIN IF DETACHED
TALK5A:	PUSHJ P,TALK6		;TYPE THE NAME
	 JRST TALK5B		;BUSY, TRY NEXT
	PUSH P,AC1		;OK, SAVE THE NUMBER
TALK7:	PUSHJ P,ESCQX		;GET ANOTHER JOB IF ANY
	 SKIPA TAC,JBTLIN(AC1)	;HO HUM
	JRST TALK8		;NO MORE JOBS
	AOJE TAC,TALK7
	PUSHJ P,TALK6
	 JRST TALK7		;JUMP IF BUSY
	SETZM (P)		;FLAG TWO ATTACHED JOBS FOUND
	JRST TALK7

TALK6:	HRRZ TAC1,TTYTAB-1(TAC)	;GET DDB OF TARGET
	CAIN TAC1,(DDB)		;RETURN BUSY QUIETLY IF DDB IS OUR OWN
	POPJ P,
	MOVE TAC1,DEVNAM(TAC1)	;GET TTY NAME
	PUSH P,TAC1		;SAVE IT
	PUSHJ P,PRNAME		;TYPE IT
	POP P,TAC
	PUSH P,AC1		;SAVE JOB NUMBER
	PUSH P,DDB		;SAVE CALLER
	PUSHJ P,TLKTST		;SEE IF BUSY
	 JRST TALK61		;OOPS
	POP P,DDB
	POP P,AC1
	AOS (P)			;OK RETURN
TALK62:	PUSHJ P,PR2SP		;2 SPACES
	MOVEI AC3,1		;CLOBBERED BY OUTCHS
	POPJ P,

TALK61:	POP P,DDB
	POP P,AC1
	PUSHJ P,INLMES
	ASCIZ /(busy)/
	JRST TALK62

TALK8:	POP P,AC1		;GET BACK JOB # OR ERROR FLAG
	JUMPE AC1,TALKE8	;ERROR IF MORE THAN ONE HIT
	MOVE TAC1,JBTLIN(AC1)	;GET JOB'S TTY
	MOVE TAC1,TTYTAB(TAC1)	;GET ITS DDB
	MOVE TAC,DEVNAM(TAC1)	;GET ITS NAME
	JRST TALK9		;NOW TRY TALKING TO IT

TALKE4:	MOVSI J,NOINCK		;SET FLAGS TO PRINT RESPONSE
	MOVEM J,-1(P)
	MOVE DDB,-2(P)
	JSP TAC,ERRMES
	ASCIZ /Please specify a TTY device name or user name
/

TALKE5:	PUSHJ P,CRLF
	MOVSI J,NOINCK		;SET FLAGS TO PRINT RESPONSE
	MOVEM J,-1(P)
	JSP TAC,ERRMES
	ASCIZ /All of the user's TTYs are busy
/				;MAYBE THIS IS LESS CRYPTIC

TALKE6:	MOVSI J,NOINCK		;SET FLAGS TO PRINT RESPONSE
	MOVEM J,-1(P)
	MOVE DDB,-2(P)
	TRNE TAC,77		;NUMBER IS LEGAL IF NOT 3 DIGITS
	CAIGE TAC,TTPSIX	;LEGAL TTY NUMBER?
	JRST TALKE7		;YES
	JSP TAC,ERRMES
	ASCIZ /No such TTY number
/

TALKE7:	JSP TAC,ERRMES
	ASCIZ /TTY not in use
/

TALKE8:	PUSHJ P,CRLF
	MOVSI J,NOINCK		;SET FLAGS TO PRINT RESPONSE
	MOVEM J,-1(P)
	JSP TAC,ERRMES
	ASCIZ /Please specify which TTY to talk to
/

TALKE9:	MOVSI J,NOINCK		;SET FLAGS TO PRINT RESPONSE
	MOVEM J,-1(P)
	JSP TAC,ERRMES
	ASCIZ /User not logged in
/

NETALK:	MOVEI TAC,F.TALK	;INDEX FOR FORCED NET TALK COMMAND
	JRST FORCEC		;HIT IT
;EXAMINE/DEPOSIT commands ;⊗ ECOM ECOM1 ECOM2 DCOM DCOMIX DEAT TESTIN ECOMP ECOMA PRVCHK PRVCH2 TTPOPJ

;"E LOC" - EXAMINE AND PRINT IN OCTAL THE CONTENTL OF LOC.  PRINT TAB, NOT CRLF.
;    IF LOC IS OMITTED, NEXT LOC (FOLLWING ONE PREVIOUSLY EXAMINED) IS PRINTED.

;"DE LH RH LOC" - DEPOSITS  LH,,RH IN LOC.  IF LOC OMITTED, USES CURRENT LOC.


ECOM:	PUSHJ P,PRVCHK		;CAN WE ALLOW THIS?
	 JRST COMERR		;NOPE
	PUSHJ P,OCTIN		;GET OCTAL LOCATION IN TAC1
	JRST ECOM2		;NO ARG - GET CURRENT LOC
	JRST COMERA		;ILLEGAL CHARACTER
ECOM1:	PUSHJ P,TESTIN		;GET SET UP.  MAKE SURE UPPER, IF NEEDED, IS INCORE
	 JFCL			;OK IF WRITE-PROT
	PUSHJ P,DEAT		;CHECK FOR AC REFERENCE.  TAC1←USER RELATIVE ADDRESS
	PUSH P,TAC1		;SAVE USER-RELATIVE ADDRESS ON STACK.
	XCTR XR,[HRRZ TAC,JOBEXM]	;PRINT LOC BEING EXAMINED
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES		;PRINT SLASH TAB
	ASCIZ %/	%
	XCTR XR,[HLRZ TAC,@(P)]	;PRINT LEFT HALF
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES		;PRINT SPACE
	ASCIZ / /
	XCTR XR,[HRRZ TAC,@(P)]	;PRINT RIGHT HALF
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES		;PRINT FINAL TAB
	ASCIZ /	/
	JRST TPOPJ

;GET THE PREVIOUS LOC+1.  DON'T AOS JOBEXM SINCE WE MAY HAVE TO COME THROUGH
;HERE SEVERAL TIMES SINCE TESTIN MAY CALL DLYCOM
ECOM2:	XCTR XR,[MOVE TAC1,JOBEXM]
	AOJA TAC1,ECOM1

;HERE FOR DEPOSIT COMMAND.

DCOM:	PUSHJ P,PRVCHK		;CAN WE ALLOW THIS?
	 JRST COMERR		;NOPE
	PUSHJ P,OCTIN		;GET LH
	JRST NOTENF		;NOT ENOUGH ARGUMENTS
	JRST COMERA		;ILLEGAL CHARACTER
	MOVSI IOS,(TAC1)	;SAVE LH.
	PUSHJ P,OCTIN		;GET RH
	JRST NOTENF		;NOT ENOUGH ARGUMENTS
	JRST COMERA		;ILLEGAL CHARACTER
	HRRI IOS,(TAC1)		;SAVE RH
	PUSHJ P,OCTIN		;GET LOC
	XCTR XR,[SKIPA TAC1,JOBEXM]	;NOT SPECIFIED (DO DEPOSIT-THIS)
	JRST COMERA		;ILLEGAL CHARACTER
	PUSHJ P,TESTIN		;RETURN IF READY FOR DEPOSIT.
	 JRST ECOMP		;LOSE IF WRITE-PROT
	CAIE TAC1,JOBUUO	;LET THE USER FROB HIS LOC 40
	CAIN TAC1,JOB41		;AND 41!!!!!!
	JRST DCOMIX		;I LIKE PUNS
	CAIGE TAC1,20		;IN USER ACS?
	JRST DCOMIX		;YES
	CAIG TAC1,JOBPFI	;IN PROTECTED PART?
	JRST ECOMA		;YES.  DISALLOW.
DCOMIX:	PUSHJ P,DEAT		;CHECK FOR AC REFERENCE.  TAC1←RELATIVE ADDRESS.
	XCTR XW,[MOVEM IOS,(TAC1)]
	JUMPE AC3,CPOPJ		;RETURN UNLESS DEPOSIT IN UPPER.
	SETOM STIME(AC1)	;MARK UPPER AS ALTERED.
	POPJ P,

;HERE ARE SOME SUBROUTINES FOR EXAMINE/DEPOSIT

DEAT:	XCTR XW,[MOVEM TAC1,JOBEXM]	;STORE FOR NEXT TIME - MODIFIES CORE IMAGE.
	SETOM STIME(J)			;AND NOTE THIS CORE IMAGE CHANGED
	XCTR XR,[MOVE TAC,JOBPC]	;GET THE PC.
	CAMN J,JOB			;IS THIS JOB RUNNING (MAYBE CCONTINUED)
	MOVE TAC,USRPC			;YES, THIS IS THE PC WE NEED.
	CAIL TAC1,20			;IS IT AN AC?
	POPJ P,				;NO
;(IF PC IS IN EXEC MODE, EXEC ACS ARE IN JOBDAC, AND USER LEVEL ACS ARE IN JOBAC)
	TLNE TAC,USRMOD			;USER MODE?
	ADDI TAC1,JOBDAC		;ACS ARE IN JOBDAC WHILE NOT RUNNING.
	POPJ P,

;SETUP ROUTINE FOR EXAMINE/DEPOSIT COMMANDS
;ADDRESS CHECKS, AND WAITS FOR SWAP (VIA DLYCOM) IF NEEDED FOR UPPER
;EXECUTES INSTRUCTION FOLLOWING CALL IF WRITE-PROTECTED UPPER
;RETURNS AC3 NON-ZERO IF THIS REFERENCE IS TO AN UPPER. AC1←UPPER'S JOB NUMBER.

TESTIN:	ANDI TAC1,-1		;FLUSH EXTRANEOUS GARBAGE
	MOVEI AC3,0		;INITIALLY ASSUME LOWER
	HLRZ TAC,JBTPAG(J)	;PAGE COUNT OF LOWER
	LSH TAC,9		;SIZE OF LOWER IN WORDS
	CAIGE TAC1,(TAC)	;SKIP IF ILLEGAL LOCATION
	JRST CPOPJ1		;LEGAL
	MOVEI AC3,(TAC)		;COMPUTE POSSIBLE UPPER ORIGIN
	LDB AC1,PSEGN		;# OF UPPER
	JUMPE AC1,ECOMP		;NONE
	MOVE AC2,JBTSTS(AC1)
	TLNE AC2,JWP		;IF WRITE-PROTECTED,
	XCT @(P)		;CHECK LEGALITY BEFORE TRYING TO SWAP
	PUSH P,TAC1		;SAVE USER-RELATIVE ADDRESS
	MOVE TAC1,AC1		;TAC1←JOB NUMBER OF UPPER.
	PUSHJ P,CORSGT		;TAC1←CORE SIZE IN WORDS, OF UPPER
	SOS TAC,TAC1		;TAC←PROTECTION SIZE OF UPPER
	POP P,TAC1		;RESTORE USER'S ADDRESS.
	CAIGE AC3,400000
	MOVEI AC3,400000	;AC3 IS NOW ORIGIN OF UPPER
	ADDI TAC,(AC3)		;RELOCATE PROT TO UPPER
	CAIL TAC1,(AC3)
	CAILE TAC1,(TAC)	;LEGAL
	JRST ECOMP		;NO
	TLNN AC2,SWP		;IS UPPER IN CORE
	JRST CPOPJ1
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	;KEEP US IN
	EXCH J,AC1
	MOVSI TAC,COMSNB
	PUSHJ P,SETSIN		;AND GET HIM IN
	MOVE J,AC1
	POP P,(P)
	JRST DLYCM1		;AND DELAY

ECOMP:	POP P,TAC		;POP OFF RETURN (CALLED FROM INSIDE TESTIN)
ECOMA:	JSP TAC,ERRMES		;ILLEGAL MEMORY REFERENCE
	ASCIZ /Out of bounds
/

;PRVCHK SKIPS IF THE CORE IMAGE HAS NOT BEEN TEMPORARILY PRIVILEGED.  ENTER
;WITH JOB NUMBER TO VERIFY IN J.  FOR THE CONVENIENCE OF WIZARDS, PRVCHK
;SKIPS IF THE USER CAN ENABLE THOSE PRIVS FROM HIS PASSIVE PRIVS.

↑PRVCHK:PUSH P,TAC		;THIS ROUTINE CLOBBERS NO AC'S
	PUSH P,TAC1
	CONSZ PI,77400		;Skip if at UUO level
	SKIPA TAC1,J		;Must be clock level, asking job is target job
	MOVE TAC1,JOB		;UUO level, asking job is currently running job
	MOVSI TAC,DAWPRV!PROPRV!WRTPRV!ACWPRV!INFPRV
	ANDCM TAC,JB2PRV(TAC1)	;DISCOUNT PRIVS USER HAS IN PASSIVE
	JUMPN TAC,PRVCH2	;SUCCESS IF HAS ALL THOSE PASSIVE PRIVS
	MOVE TAC,JB2PRV(TAC1)	;HAS ALL THE PRIVS
	TDNN TAC,[NXPRIV]	;MAKE SURE DOESN'T HAVE ANY NON EX PRIVS
	JRST TTPPJ1		;ALL OK, GOOD GUY (I GUESS)
	JRST TTPOPJ		;BAD GUY, APPARENTLY

;J contains number of job whose core is to be looked at.
PRVCH2:	TDNE TAC,JBTPRV(J)	;USER HAS DANGEROUS TEMPORARY PRIVS?
	JRST TTPOPJ		;LOSE
	MOVSI TAC,TEMPPR	;GET SPECIAL TEMP PRV FLAG
	TDNN TAC,JBTMSC(J)	;SKIP IF CORE IMAGE HAS HAD SPECIAL PRIVS
	JRST TTPPJ1		;OKAY TO DO COMMAND/UUO
↑TTPOPJ:POP P,TAC1
	POP P,TAC
	POPJ P,
;CBLANK NOCOM
;BLANK OR NO ALPHA NUMERIC BEFORE BREAK CHAR.
;DISPATCHED TO LIKE ANY OTHER COMMAND IN COMMAND TABLE
;NOCOM IS LAST IN THE COMMAND DISPATCH TABLE

CBLANK:	CAIE TEM,12		;WAS BREAK A L.F.?
	CAIN TEM,";"		;NO, IS IT SEMI COLON(MONITOR COMMENT)
	POPJ P,			;YES, IGNORE FALL IN UNKNOWN COMMAND
NOCOM:	JRST COMERR		;NO, APPEND ? TO WHAT HE TYPED IN
;FINIS FINPHA FIN00 FIN0 FIN3 FIN1 FIN2 FINRDV FINRD1 FINRD2 FINXIT FINREL FINRL2 FINRL1 FINSTK FINST1 FINST2 FINALL FINAL1 FINAL3 FINST4 FINST5 FINST3
;FINISH DEVICE - CLOSES,RELEASE AND DEASSIGNS DEVICE(S)

FINIS:	PUSHJ P,NBRPPN		;GET NUMBER AND PPN OF JOB TO FINISH
	 JRST FIN0		;NOT A JOB NUMBER, MAYBE A DEVICE
	 SKIPA TAC1,J		;NO ARG AT ALL, FINISH ALL DEVICES OF OUR JOB
	 JRST NOTLOG		;JOB IS A SEGMENT--SAY NO SUCH JOB
	MOVE AC1,JB2PRV(J)	;GET FINISHER'S PASSIVE PRIVS
	MOVSI TAC,JLOG		;SEE IF JOB TO BE FINISHED IS A PHANTOM
	TDNN TAC,JBTSTS(TAC1)	;SKIP IF FINISHEE IS NOT A PHANTOM
	TRNE AC1,ATTPRV		;CAN'T FINISH A PHANTOM UNLESS YOU CAN ATTACH IT
	JRST FIN00		;OK
	MOVE TAC,PRJPRG(TAC1)	;GET PHANTOM'S PPN
	CAME TAC,PRJPRG(J)	;GET TYPER'S PPN
	JRST FINPHA
	MOVEI TAC,(TAC)		;JUST PROGRAMMER NAME
	CAIE TAC,'SYS'		;DON'T LET RMD,SYS USER FINISH THE REMIND PHANTOM
	JRST FIN00		;OK, SAME PPN AND NOT SYS
FINPHA:	MOVEI J,0
	JSP TAC,ERRMES
	ASCIZ/Can't FINISH phantom.
/

FIN00:	MOVSI TAC,NOPER
	CAME TAC1,J		;RESETING SOMEONE ELSE?
	ANDCAM TAC,-1(P)	;YES, TELL COMRET TO TYPE DOT AFTER ALL
	MOVEI AC1,FINCM1	;ADDRESS OF MONITOR JOB
	JRST KILOK		;USE COMMON CODE FOR THE REST

;USE OLD FINISH CODE FOR SPECIFIC DEVICES
FIN0:	SKIPN JBTPAG(J)		;SKIP IF CORE IS ASSIGNED
	POPJ P,			;NO CORE, NO DEVICES, NO FINISH.
	PUSHJ P,CTEXT1		;READ IN THE DEVICE NAME
	XCTR XW,[MOVEM TAC1,JOBFDV]	;SAVE THE SIXBIT OF THE DEVICE NAME
	MOVSI TAC,TTYRNU	;PUT TTY INTO USER MODE
	IORM TAC,-1(P)		;TELL COMRET
IFN FTMONCIP,<
	SKIPLE MONCIP(DDB)
	HRROS MONCIP(DDB)	;SUPPRESS SKPBRK SINCE RUNNING USER PROGRAM
>;IFN FTMONCIP
	JSP TAC1,MSTART		;MAKE US A MONITOR JOB
	JSP TAC,MONSTR		;RETURN HERE AT UUO LEVEL. SETUP ACS
	XCTR XR,[SKIPN TAC,JOBFDV]	;SET UP TO SEARCH FOR THIS DEVICE
	JRST FINALL		;NONE GIVEN.  FINISH ALL.
FIN3:	PUSHJ P,DEVLG		;TRY LOGICAL NAMES FIRST
	JRST FIN1		;NOT FOUND, TRY PHYSICAL NAMES
	PUSHJ P,FINRDV		;TRY TO FINISH IT
	PUSH P,[FIN3+1]		;IF WE RETURN, THAT WASN'T THE RIGHT DEVICE
	JRST DEV0		;CONTINUE SCANNING THE DEVICES

FIN1:	PUSHJ P,DEVPHY		;SEARCH PHYSICAL NAMES
	JRST FIN2			;NO NAMES, ERROR
	PUSHJ P,FINRDV
	PUSH P,[FIN1+1]
	MOVE AC1,DEVMOD(DDB)
	TLNN AC1,DVTTY		;FINISH TTY?
	JRST DEVLP2		;NO - SEARCH FOR ANOTHER DEVICE OF SAME NAME
FIN2:	PUSHJ P,TTYFNU		;GET A TTY FOR US
	PUSHJ P,INLMES		;GIVE AN ERROR MESSAGE
	ASCIZ /
Finish what?/
	JRST FINXIT		;STOP JOB, RESCHEDULE.


;FINISH A DEVICE BY RELEASING IT.  DDB MUST BE IN USRJDA OR IN IOPDL

FINRDV:	SKIPGE UCHN,USRHCU	;SKIP UNLESS SAVGET IO ACTIVE.
	JRST FIN2		;NO CHANNELS, NO DEVICES 
	CAILE UCHN,17
	MOVEI UCHN,17		;A LITTLE BULLETPROOFING.
FINRD1:	HRRZ AC1,USRJDA(UCHN)	;GET DDB ADDRESS.
	CAIE AC1,(DDB)		;IS THIS IT?
	SOJGE UCHN,FINRD1	;NO, LOOK AT ANOTHER
	JUMPL UCHN,FINSTK	;IF NOT FOUND, GO CHECK IO PDL
	PUSHJ P,FINREL		;RELEASE IT
FINRD2:	PUSHJ P,TTYFNU		;GET OUR TTY DDB (RESET COMMAND ENTERS HERE)
FINXIT:	PUSHJ P,PRCRCC		;PRINT CRLF AND ↑C AND DOT
	PUSHJ P,TTYSTC		;KEEP THE TTY IN COMMAND MODE
	JRST ESTOP		;STOP THE JOB NOW.

FINREL:	PUSH P,UCHN
	MOVSI UUO,(<RELEAS>)	;NOW SET UP TO RELEASE IT
	DPB UCHN,PUUOAC
	MOVE UCHN,DEVMOD(DDB)
	TRNE UCHN,ASSCON	;WILL DDB BE THERE AFTER RELEASE?
	JRST FINRL1		;YES
	XCT UUO			;RELEASE THE DEVICE
FINRL2:	POP P,UCHN
	POPJ P,

FINRL1:	PUSH P,DDB
	XCT UUO
	POP P,DDB
	MOVSI UCHN,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAM UCHN,DEVMOD(DDB)
	JRST FINRL2

FINSTK:	MOVE J,JOB
	SKIPL UCHN,JBTIOP(J)
	POPJ P,			;NOTHING ON STACK
FINST1:	HRRZ AC1,(UCHN)
	CAIE AC1,(DDB)
	JRST FINST2
	MOVE DDB,USRJDA
	EXCH DDB,(UCHN)		;SAVE CHANNEL 0
	MOVEM DDB,USRJDA	;AND PUT THIS DDB IN CHANNEL 0
	PUSH P,UCHN
	MOVEI UCHN,0
	PUSHJ P,FINREL		;RELEASE CHANNEL 0
	POP P,UCHN
	MOVE DDB,(UCHN)		;RESTORE CHANNEL 0
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)	;STORE ZERO (FROM RELEASE) IN IOPDL
	JRST FINRD2

FINST2:	ADD UCHN,[2,,2]
	JUMPL UCHN,FINST1
	POPJ P,

FINALL:	SKIPGE UCHN,USRHCU	;SEE IF HE HAS CHANNELS OPEN
	JRST FINAL3		;NONE LEFT OPEN.
	CAILE UCHN,17
	MOVEI UCHN,17		;MAKE SURE IT'S REASONABLE..
FINAL1:	SKIPE DDB,USRJDA(UCHN)	;IS THERE ANYONE HERE?
	PUSHJ P,FINREL
	SOJGE UCHN,FINAL1
FINAL3:	MOVE J,JOB		;DEPARTMENT OF REDUNDANCY DEPARTMENT
	SKIPL UCHN,JBTIOP(J)	;ANY IO PDL?
	JRST FINST3		;NO. WE'RE DONE.
FINST4:	SKIPN DDB,(UCHN)
	JRST FINST5
	SETZM (UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	MOVEI UCHN,0
	PUSHJ P,FINREL
	POP P,UCHN
FINST5:	ADD UCHN,[2,,2]
	JUMPL UCHN,FINST4
	HRRZ AC1,JBTIOP(J)
	SETZM JBTIOP(J)
	PUSHJ P,FSGIVE
FINST3:	PUSHJ P,IOALLR		;RELEASE ANYTHING ELSE WE CAN FIND.
	JRST FINRD2
;FREDEV FRUDP1 FRUDP2 FRUDP3 FRUDP4 FRUDP5 LOP01 LOP04 RESRES RESRE1 RESRE2 LP1RET SIXDKL RESOOP RESWAT RESCON RESCOL SATTAC
;"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK

FREDEV:	SKIPE AC2,SAVDDB(DDB)	;Skip if not resuming delayed RESO cmd
	JRST RESCON		;Continue RESO where we left off

NoStructure,<
;In the code below, AC2 is the unit number.
;Fall in with AC2 set to zero.  Loop from below, counting unit numbers
FRUDP1:	JUMPE AC2,FRUDP2	;Skip one test for main disk
	SKIPN UDPOWN-1(AC2)	;IS UDP IN USE FOR SWAPPING OR DET?
	JRST FRUDP5		;YES. PRINT NOTHING. (NOT A RESOURCE)
FRUDP2:	MOVE TAC,DKDBML(AC2)	;ELSE GET ADDR OF MODEL DDB
	MOVE TAC1,DEVNAM(TAC)	;GET device Name FROM MODEL
	PUSHJ P,PRNAME		;PRINT THE NAME
	SKIPG SATADR(AC2)
	JRST FRUDP3		;NO SATADR, NO DSKRES.
	MOVEI TEM," "
	XCT TYO
	MOVEI TAC1,(AC2)
	PUSHJ P,DSKRES		;GET FREE BLOCK COUNT FROM DSKSER
	PUSHJ P,RADX10		;CONVERT TO DECIMAL
FRUDP3:	JUMPE AC2,FRUDP4	;AVOID UDP STUFF FOR DSK
	SKIPG UDPCNT-1(AC2)	;SKIP IF NOT FREE
	JRST [MOVEI TAC,[ASCIZ/ Free /]
	      PUSHJ P,CONMES	;is free, say so
	      JRST FRUDP4]
	MOVEI TAC,[ASCIZ / Public /]
	SKIPL UDPOWN-1(AC2)	;SKIP IF PUBLIC
	MOVEI TAC,[ASCIZ / Private /]
	PUSHJ P,CONMES
	SKIPLE TAC,SATADR(AC2)
	PUSHJ P,SATTAC		;TYPE SATID IF ANY
FRUDP4:	PUSHJ P,CRLF
FRUDP5:	CAIGE AC2,UPACKS	;DONE ENOUGH?
	AOJA AC2,FRUDP1		;INCREMENT COUNT AND DO IT AGAIN
>;NoStructure
IfStructure,<
;In the code below, AC2 is the unit number; AC3 is SDB
;Fall in with AC2 set to zero.  Loop from below, counting structure numbers
FRUDP1:	SKIPN AC3,SDBADR(AC2)
	JRST FRUDP5		;No work if structure is undefined
	JUMPE AC2,FRUDP2	;Skip one test for main disk
	SKIPN ST.JOB(AC3)	;Skip unless UDP used for SWAP or DETached
	JRST FRUDP5		;YES. PRINT NOTHING. (NOT A RESOURCE)
FRUDP2:	MOVE TAC,ST.MDB(AC3)	;Address of the model DDB
	MOVE TAC1,DEVNAM(TAC)	;GET device Name FROM MODEL
	PUSHJ P,PRNAME		;PRINT THE NAME
	MOVE AC3,SDBADR(AC2)
	SKIPG ST.SAD(AC3)
	JRST FRUDP3		;NO SATADR, NO DSKRES.
	MOVEI TEM," "
	XCT TYO
	MOVEI TAC1,(AC2)
	PUSHJ P,DSKRES		;GET FREE BLOCK COUNT FROM DSKSER
	PUSHJ P,RADX10		;CONVERT TO DECIMAL
	MOVE AC3,SDBADR(AC2)
FRUDP3:	JUMPE AC2,FRUDP4	;AVOID UDP STUFF FOR DSK
	SKIPG ST.CNT(AC3)	;skip if not free
	JRST [MOVEI TAC,[ASCIZ/ Free /]
	      PUSHJ P,CONMES	;is free, say so
	      JRST FRUDP4]
	MOVEI TAC,[ASCIZ / Public /]
	SKIPL ST.JOB(AC3)
	MOVEI TAC,[ASCIZ / Private /]
	PUSHJ P,CONMES
	MOVE AC3,SDBADR(AC2)
	SKIPE TAC,ST.NAM(AC3)	;Type Structure name if known
	PUSHJ P,PSTRID
FRUDP4:	PUSHJ P,CRLF
FRUDP5:	CAIGE AC2,STRMAX	;DONE ENOUGH?
	AOJA AC2,FRUDP1		;INCREMENT COUNT AND DO IT AGAIN
>;IfStructure

	HLRZ AC1,DEVLST		;GET DDB POINTER
	PUSH P,[0]
LOP01:	MOVE TAC,DEVMOD(AC1)	;GET DEVMOD
	TRNN TAC,ASSCON+ASSPRG	;ASSIGNED BY CONSOLE OR PROGRAM?
	TLNE TAC,DVTTY!DVDSK!DVUDP ;TTY,DSK,UDP?
	JRST LP1RET		;ASSIGN, OR SPECIAL DEVICE or detached
IFN FTIP,<
	TLNE TAC,DVIMP		;special case for IMPs
	CAIN AC1,IMPDDB		;only list prototype IMP DDB
	CAIA			;not non-prototype IMP DDB
	JRST LP1RET		;don't list this IMP DDB that's waiting for close
>;IFN FTIP
IFN FTP2,<
	MOVE TAC,DEVCMR(AC1)	;SEE IF THIS IS A P2 DEVICE
	TLNE TAC,DEVP2		;SKIP IF ON P2
	SKIPE DETFLG		;BUT IS P2 RUNNING?
	JRST LOP04
	JRST LP1RET		;NO P2, DON'T SAY THIS DEVICE IS AVAILABLE

LOP04:
>;IFN FTP2
	MOVEI TEM,","		;GET A COMMA
	SKIPE (P)		;SKIP IF FIRST DEVICE
	XCT TYO			;NOT FIRST.  PRINT COMMA
	MOVEI TAC,6+4		;Takes up to 6 chars to print device
	CAML TAC,TOFCTR(DDB)	;Enough room in buffer for device name?
	JRST RESWAT		;No, start output and delay the RESO cmd
RESRES:	MOVE TAC1,DEVNAM(AC1)	;GET DEVICE NAME
	HLRZ AC2,DEVNAM(AC1)	;SAME DEVICE-TYPE AS PREVIOUS ONE?
	CAMN AC2,(P)
	JRST RESRE1		;YES, JUST PRINT NUMBER
	LDB TAC,PHPOS		;GET HORIZ POSITION
	LDB TEM,PUNIT
	SKIPE TEM,LETAB(TEM)
	SKIPA TEM,DPYWID(TEM)	;GET DPY WIDTH
	LDB TEM,PTTYWD		;GET TTY WIDTH
	CAIGE TEM,13(TAC)	;4 CHAR NAME AND COMMA AND MAYBE 4 OF THEM
	PUSHJ P,CRLF
	JRST RESRE2

RESRE1:	HRLZ TAC1,TAC1		;YES.  PRINT ONLY NUMBER (FLUSH LEFT SIDE)
RESRE2:	MOVEM AC2,(P)		;AND SAVE FOR NEXT DEVICE
	PUSHJ P,PRNAME		;GO AND PRINT IT OUT
LP1RET:	HLRZ AC1,DEVSER(AC1)	;GET NEXT DDB
IFN FTSIX,<	;THIS ISN'T NEEDED ANY MORE IF NO PDP-6 PSEUDO-DEVICES -- MRC
	CAIE AC1,ADCDDB		;HAPPY KS
	JRST SIXDKL
	SETZM (P)
	PUSHJ P,CRLF
SIXDKL:
>;IFN FTSIX
	JUMPN AC1,LOP01		;END OF CHAIN?
RESOOP:	PUSHJ P,CRLF		;YES
	SETZM SAVDDB(DDB)	;No longer waiting for output buffer
	JRST TPOPJ		;GET THAT EXTRA WORD OFF THE STACK

RESWAT:	HRL AC1,(P)		;Save generic name of prev device printed
	MOVEM AC1,SAVDDB(DDB)	;Make us continue from middle of dev list
	SUB P,[1,,1]		;Flush previous device name from stack
	JRST DLYCM2		;Delay command until output buffer empties

RESCON:	HLRZ TAC,AC2		;Get back name of prev device printed
	PUSH P,TAC		;Put prev generic device name on stack
	HLRZ AC1,DEVLST		;Get pointer to first ddb in chain
RESCOL:	CAIN AC1,(AC2)		;Is this where we left off?
	JRST RESRES		;Yes, jump back into printing loop
	HLRZ AC1,DEVSER(AC1)	;Get next ddb
	JUMPN AC1,RESCOL	;End of chain?
	JRST RESOOP		;Yes!  Failed to find old ddb!  We tried.

NoStructure,<
SATTAC:	PUSH P,SATID(TAC)	;SAVE SATID ON STACK
>;NoStucture
IfStructure,<
PSTRID:	PUSH	P,TAC		;Save Structure name on Stack
>;IfStructure
	MOVEI TEM,"("		;(SATTAC CALLED BY PJOB FOR UDP)
	XCT TYO
	POP P,TAC1		;GET VOLUME ID
	PUSHJ P,PRNAME		;(IBM VOCABULARY TAKES OVER THE WORLD)
	MOVEI TEM,")"
	XCT TYO
	POPJ P,
;ACTCHK ACTCH1 DLYCR2 DLYCR1 DLYCOR DLYCM DLYCM1 DLYCM3 DLYCM2 FRCUSR

ACTCHK:	SKIPN JBTPAG(J)		;SKIP IF JOB HAS CORE INCORE
	JRST ACTCH1		;JOB HAS NO CORE INCORE.
	TLNE AC1,SWP		;JOB HAS CORE. IS IT IN TRANSIT? 
	JRST ACTCH1		;YES. - IN TRANSIT.
	PUSHJ P,ANYACT		;NOT IN TRANSIT.  ARE DEVICES ACTIVE?
	JRST DLYCM1		;DEVICES ARE ACTIVE - DELAY COMMAND.
ACTCH1:	MOVE TAC1,-1(P)		;RESTORE COMMAND DISPATCH ADDRESS
	MOVE DDB,-2(P)		;RESTORE TTY DDB ADDRESS
	MOVE AC1,JBTSTS(J)	;RESTORE JOB STATUS
	POPJ P,

;ROUTINE TO DELAY A COMMAND

;DELAYS COMMAND TO BE EXECUTED WHEN JOB IN CORE MEMORY AND POPS UP ONE LEVEL.
DLYCR2:	MOVE TAC1,LINSAV	;GET THE LINE NUMBER
	MOVSI TAC,COMBIT
	OFFSCN			;TURN OFF SCANNER CHANNEL
	SKIPGE IMLHAC(DDB)	;SKIP UNLESS DELAYING FORCED COMMAND
	SOS COMCNT		;PREVENT CALLING COMMAND UNTIL UNDELAYED--SEE TTYCM4
	TDNE TAC,TTYTAB(TAC1)
	SOS COMCNT		;DECREMENT IF COMMAND BIT WAS SET
	ANDCAM TAC,TTYTAB(TAC1)
	JRST SCNONJ		;TURN ON SCANNER CHANNEL AND RETURN

DLYCR1:	PUSHJ P,DLYCR2		;CLEAR COMBIT
	JRST DLYCM1

DLYCOR:	PUSHJ P,DLYCR2		;CLEAR COMBIT
DLYCM:	PUSHJ P,DLYCOM		;REQUEUE JOB TO CMWQ 
↑DLYCM1:AOS NDLYCMS		;COUNT A DELAYED COMMAND
	MOVE TAC1,LINSAV	;HERE WHEN COMMAND MUST BE DELAYED
	MOVSI DDB,DLYBIT	;TTYTAB BIT FOR TTYCM TO SET
	IORB DDB,TTYTAB(TAC1)	;turn on the delaying bit, get DDB ptr back
DLYCM3:	ADJSP P,-3		;FLUSH THE RETURN TO COMRET
				; AND THE COMMAND BITS
				; AND THE TTY DDB POINTER.
	PUSHJ P,TTYCM		;DELAY PRESENT COMMAND AND GET A NEW COMMAND
	 POPJ P,		;THERE ARE NO NEW COMMANDS
	JRST COM0		;PROCESS A COMMAND.

;HERE TO DELAY A COMMAND UNTIL OUTPUT BUFFER EMPTY
↑DLYCM2:SKIPE FRCFLG
	PUSHJ P,FRCUSR		;SET USRB IF NOT TPMON
	 JFCL
	MOVE TAC1,LINSAV	;make sure have right line number
	MOVSI DDB,PAUSEB	;BIT meaning cmd waiting for empty output buffer
	IORB DDB,TTYTAB(TAC1)	;set cmd typeout wait bit before starting typeout
	PUSHJ P,DLYCR2		;CLEAR COMBIT (before starting output)
	MOVE IOS,DEVIOS(DDB)	;set up IOS
	PUSHJ P,UTYPET		;START TYPEOUT, BUT DON'T SET IO BIT (KEEP DDB)
	JRST DLYCM3		;go delay this cmd and get a new one

;HERE WHEN EXITING OR DELAYING FORCED COMMAND
FRCUSR:	MOVE IOS,DEVIOS(DDB)	;MAKE USRB AGREE WITH TPMON FOR FORCED COMMAND
	TLNE IOS,TPMON
	JRST CPOPJ1		;COMRET WON'T SET NOPER WHEN WE SKIP RETURN
	MOVSI IOS,USRB		;MAKE SURE WE STAY IN USER MODE
	IORB IOS,DEVIOS(DDB)
	POPJ P,
;STOPCK STOPC1 STOPC2 STOPD STOPC

;SEARCH DEVICE CHAIN FOR DSK WITH COUNTS ON
;CALL:	MOVE J,JOB NO
;	PUSHJ P,STOPCK
;	CAN'T STOP RETURN
;	OK TO STOP RETURN

↑STOPCK:PUSH P,DDB
	PUSHJ P,STOPC1
	SOS -1(P)		;MAKE NON-SKIP RETURN.
	POP P,DDB
	JRST CPOPJ1

STOPC1:	MOVEI DDB,DSKDDB
↑STOPC2:MOVSI TAC1,DSKFGS	;CALLED FROM PARSER TO FLUSH GOBIT
STOPD:	LDB TAC,PJOBN
	CAIE J,(TAC)		;ASSIGNED TO THIS JOB?
	JRST STOPC		;NO
	TDNE TAC1,DEVIOS(DDB)	;UNSTOPPABLE?
	POPJ P,			;YES. DELAY.  OFFENDING DDB IN DDB.
STOPC:	HLRZ DDB,DEVSER(DDB)
	MOVE TAC,DEVMOD(DDB)	;LOOP THRU DSK AND UDP DDBS
	TLNE TAC,DVDSK
	JRST STOPD		;ONLY LOOK AT DVDSK ONES
	TLNE TAC,DVUDP
	JRST STOPC		;BUT KEEP SEARCHING IF DVUDP
	JRST CPOPJ1		;OK TO STOP
;"FILES <filename or job number>" -- print status of open files. ;⊗ FILCOM FIL0 FIL6D FIL6 FIL6A FIL6E FIL6B FIL4 FIL3 FIL99 FIL88 FIL5 FIL5Q FIL5C FIL5D FIL5A FIL5G FIL5B FIL5F FIL2JB FIL2JL FIL2LZ FIL2JX FIL2 FIL2A PTFILE PTFIL0 PTFIL2 PR3SIX PR6SIX PRSIXA PRRECD PRRECL PRREC3 PRREC2 NXTDSK

FILCOM:	SKIPE TAC,SAVDDB(DDB)	;SKIP UNLESS CONTINUING DELAYED COMMAND
	PUSHJ P,FIL2		;FIND PLACE TO CONTINUE FROM
	 MOVEI AC1,DSKDDB	;FIL2 SKIPS ON SUCCESS WITH SIGN BIT OF AC1 SET
	SKIPN FRCFLG
	JRST FIL0		;NOT FORCED COMMAND
	SKIPN SAVDDB(DDB)	;DON'T PUT OUT CRLF AGAIN IF RESUMING CMD
	PUSHJ P,CRLF		;MAKE SURE AT LEFT MARGIN ON FORCED COMMAND
	LDB TAC,ARGBPT		;GET (MAYBE) JOB NUMBER or zero
	CAIL TAC,JOBN		;Make sure reasonable job number
	JRST NOTLOG		;No such job
	JRST FIL5Q

FIL0:	PUSHJ P,CTEXT1		;GET ARG OF COMMAND
	JUMPE TAC1,FIL5C	;NO ARG
	PUSH P,TAC1		;SAVE ARG
	CAIN TEM,"."		;DELIMITING PERIOD MEANS FILENAME EXT COMING
	JRST FIL3		;READ EXT
	CAIN TEM,"["		;DELIMITING LEFT BRACKET MEANS PPN COMING
	JRST FIL4		;READ PPN
	PUSHJ P,FIL2JB		;SEE IF ARG WAS A JOB NUMBER RATHER THAN FILENAME
	 JRST FIL5		;GOT JOB NUMBER
	PUSH P,[0]		;MUST BE FILE NAME WITH ZERO EXTENSION.
FIL6D:	SKIPN AC2,DSKPPN(J)	;GET APPROPRIATE PPN FOR FILE
	MOVE AC2,PRJPRG(J)
FIL6:	PUSH P,AC2		;SAVE PPN
	PUSHJ P,FIL99		;SEE IF ANYTHING LEFT IN COMMAND LINE
	JUMPL AC1,FIL6E		;DON'T ADVANCE TO NEXT DDB IF CONTINUING DELAYED CMD
FIL6A:	PUSHJ P,NXTDSK		;GET NEXT DSK DDB
	 JRST FIL6B		;NONE, DONE
FIL6E:	MOVE TAC,DEVFIL(AC1)	;GET NAME OF FILE OPEN
	CAME TAC,-2(P)		;SAME AS FILE OF INTEREST?
	JRST FIL6A		;NOPE
	HLLZ TAC,DEVEXT(AC1)	;GET EXT OF FILE OPEN
	CAME TAC,-1(P)		;SAME AS FILE OF INTEREST?
	JRST FIL6A		;NOPE
	MOVE TAC,FILPPN(AC1)	;AND PPN
	CAMN TAC,(P)		;SAME?
	PUSHJ P,PTFIL0		;YES.  PRINT STATUS OF THIS FILE
	 JRST FIL6A		;NOT SAME, OR STATUS PRINTED OK.
FIL6B:	SUB P,[3,,3]		;RE-ADJUST STACK, FLUSHING FILE NAME, EXT, PPN
	JRST FIL5F		;EXIT COMMAND

FIL4:	SKIPA TAC1,[0]		;ZERO FILE EXTENSION
FIL3:	PUSHJ P,CTEXT		;READ FILE EXTENSION
	PUSH P,TAC1		;SAVE EXT
	PUSHJ P,PJPGNO		;READ PPN
	 JRST FIL6D		;NONE TYPED, GET DEFAULT PPN
	JRST FIL6		;GO SAVE PPN TYPED

FIL99:	PUSHJ P,SKIPS1		;SEE IF ANYTHING EXTRANEOUS AT END OF LINE
	SUB P,[4,,4]		;YES.  ERROR
	JRST COMERA		;(SKIPS1 RETURNS UP A LEVEL IF FINDS END OF LINE)

FIL88:	PUSHJ P,SKIPS1		;COMEND MAKES THIS CHECK ALSO BUT ONLY REMOVES
	SUB P,[2,,2]		;	ONE ENTRY FROM STACK INSTEAD OF TWO
	JRST COMERA

FIL5:	SUB P,[1,,1]		;DISCARD SIXBIT JOB NUMBER ON STACK
FIL5Q:	JUMPN TAC,FIL5D		;ZERO JOB NUMBER MEANS OWN JOB,
FIL5C:	SKIPN TAC,J		; IF ANY.
	JRST LOGPLS		; IF NONE, CANT HELP YOU
FIL5D:	MOVE TAC1,JBTSTS(TAC)	;SEE IF THIS JOB NUMBER IS ASSIGNED
	TLNE TAC1,JNA
	TLNE TAC1,JSEG		;NO SEGMENTS PLEASE
	JRST NOTLOG		;NO SUCH JOB
	PUSH P,TAC		;SAVE JOB NUMBER
	SKIPN FRCFLG		;DON'T TRY TO READ TTY ON FORCED COMMAND
	PUSHJ P,FIL88		;MAKE SURE NOTHING EXTRANEOUS AFTER JOB NUMBER
	MOVE AC2,DEVMOD(AC1)	;GET DEVICE CHARACTERISTICS, in case delayed cmd
	JUMPL AC1,FIL5G		;JUMP IF CONTINUING DELAYED COMMAND
FIL5A:	PUSHJ P,NXTDSK		;GET NEXT DSK DDB
	 JRST FIL5B		;NONE, DONE
FIL5G:	LDB TAC1,[POINT JOBNSZ,DEVJBN(AC1),JOBNPS] ;PICK UP JOB NUMBER FROM DDB
	CAMN TAC1,(P)		;IS IT THE JOB OF INTEREST?
	PUSHJ P,PTFILE		;YUP.  PRINT FILE STATUS
	 JRST FIL5A		;NOT CORRECT JOB, OR FILE STATUS PRINTED OK
FIL5B:	SUB P,[1,,1]		;REMOVE JOB NUMBER FROM STACK
FIL5F:	HRRZM AC1,SAVDDB(DDB)	;REMEMBER WHETHER WE FINISHED PROCESSING DDB LIST
	JUMPN AC1,DLYCM2	;IF NOT END OF LIST, DELAY COMMAND
	POPJ P,

FIL2JB:	TDNE TAC1,[-1⊗(-JOBNDG*6)] ;CONVERT SIXBIT TEXT TO JOB NUMBER
	JRST CPOPJ1		;MORE THAN N CHARS MEANS NOT JOB NUMBER
	JUMPE TAC1,CPOPJ1	;If no text, no job number
	PUSH P,AC1
	PUSH P,[POINT 6,TAC1]	;Byte pointer to sixbit text that might be number
	MOVEI TAC,0		;Job number accumulated so far
FIL2JL:	ILDB AC1,(P)		;Get next sixbit char
	JUMPE AC1,FIL2JX	;If null, then done (can't happen first time)
	SUBI AC1,'0'		;Convert to binary
	JUMPL AC1,FIL2LZ	;Negative means not digit, not job number
	CAILE AC1,9		;Skip if really digit
	JRST FIL2LZ
	IMULI TAC,=10
	ADDI TAC,(AC1)		;Add new digit into total
	JRST FIL2JL		;Guaranteed to stop unless JOBNDG is 6 or more!!

FIL2LZ:	AOS -2(P)		;Skip if no job number found
FIL2JX:	SUB P,[1,,1]		;Flush byte pointer from stack
	JRST POPAJ

REPEAT 0,<
	SETZ TAC,
	LSHC TAC,6		;GET FIRST SIXBIT CHAR
	SUBI TAC,'0'		;CONVERT DIGIT TO BINARY
	JUMPL TAC,CPOPJ1	;NOT DIGIT MEANS NOT JOB NUMBER
	CAILE TAC,9
	JRST CPOPJ1		;NOT DIGIT
	JUMPE TAC1,CPOPJ	;IF NO SECOND DIGIT, THEN DONE
	ROT TAC1,6		;GET SECOND DIGIT
	SUBI TAC1,'0'		;CONVERT SIXBIT DIGIT TO BINARY
	JUMPL TAC1,CPOPJ1	;NO DIGEE, NO JOBEE
	CAILE TAC1,9
	JRST CPOPJ1		;LOSE
	IMULI TAC,=10		;SHIFT HIGH-ORDER DIGIT
	ADD TAC,TAC1		; AND ADD IN LOW-ORDER DIGIT
	POPJ P,			;DIRECT RETURN WITH JOB NUMBER IN TAC
>;REPEAT 0

↑FIL2:	MOVEI AC1,DSKDDB	;LOOK THROUGH DISK DDBS FOR PLACE WE QUIT LAST TIME
FIL2A:	PUSHJ P,NXTDSK		;GET NEXT DSK DDB
	 POPJ P,		;NO MORE.  CAN'T FIND RIGHT PLACE.  START OVER.
	CAME TAC,AC1		;IS THIS THE DDB WHERE WE QUIT?
	JRST FIL2A		;NO, TRY AGAIN.
	TLO AC1,400000		;FLAG NOT TO ADVANCE TO NEXT DDB
	JRST CPOPJ1		;SKIP WITH SUCCESS

PTFILE:	TRNN AC2,ASSPRG		;AC2 HAS DEVMOD
	POPJ P,			;DON'T TYPE ASSCON DDBS
PTFIL0:	MOVEI TAC,=39+4		;PRINT A FILE'S STATUS, AT MOST =39 CHARS NEEDED.
	CAML TAC,TOFCTR(DDB)	;SEE IF WE HAVE ENOUGH ROOM IN OUTPUT BUFFER
	JRST CPOPJ1		;NOT ENOUGH ROOM IN BUFFER
	LDB TAC,[POINT JOBNSZ,DEVJBN(AC1),JOBNPS] ; GET NUMBER OF JOB WITH FILE OPEN
	MOVEI TEM," "
	CAIGE TAC,=10		;IF JOB NUMBER LESS THAN =10,
	XCT TYO			; THEN PAD NUMBER WITH A SPACE
	PUSHJ P,RADX10		;PRINT JOB NUMBER
	MOVE TAC1,DEVFIL(AC1)	;GET FILE NAME
	PUSHJ P,PR6SIX		; AND PRINT 6 CHARS AFTER SPACE
	HLLZ TAC1,DEVEXT(AC1)	;GET FILE EXT
	PUSHJ P,PR3SIX		; AND PRINT 3 CHARS AFTER SPACE
	MOVE TAC1,FILPPN(AC1)	;GET FILE PPN
	PUSHJ P,PR6SIX		; AND PRINT 6 CHARS AFTER SPACE
	MOVE TAC,FILLNG(AC1)	;GET FILE LENGTH
	PUSHJ P,DGETL1		; AND CONVERT TO RECORDS (DGETL1 IS IN DSKSER)
	SKIPE TAC1,TAC		;IF NON-ZERO, SUBTRACT ONE TO GET NUMBER
	SUBI TAC1,1		; OF LAST RECORD, NOT FIRST FREE RECORD
	PUSHJ P,PRRECD		; PRINT FILE LENGTH IN RECORDS
	MOVE TAC1,USETP(AC1)	;GET CURRENT USET POINTER
	PUSHJ P,PRRECD		; AND PRINT IT
	MOVEI TEM," "
	XCT TYO			;PRINT A SPACE
	MOVEI TEM,"U"
	TLNE AC2,DVUDP		;IS THIS A UDP?
	XCT TYO			;YES, PRINT "U"
	MOVE TAC,DEVIOS(AC1)	;SEE WHAT IS HAPPENING TO THIS FILE
	TLNN TAC,READB		;BEING READ?
	JRST PTFIL2		;NO
	MOVEI TEM,"R"		;YES.  PRINT "R"
	XCT TYO
	MOVEI TEM,"A"
	TLNE TAC,ALTERB		;OPEN IN READ-ALTER MODE?
	XCT TYO			;YUP,  PRINT "A" AFTER THE "R"
	MOVEI TEM,"E"
	TLNE TAC,IOEND		;END OF FILE?
	XCT TYO			;YES, PRINT "E"
	JRST CRLF		;PRINT CRLF AND RETURN FROM PTFILE

PTFIL2:	MOVEI TEM,"W"
	TLNE TAC,WRITEB		;IS FILE BEING WRITTEN?
	XCT TYO			;YES, PRINT "W"
	JRST CRLF		;PRINT CRLF AND RETURN FROM PTFILE

PR3SIX:	MOVEI UCHN,3		;PRINT 3 SIXBIT CHARS
	JRST .+2
PR6SIX:	MOVEI UCHN,6		;PRINT 6 SIXBIT CHARS
	MOVEI TEM," "
	XCT TYO
PRSIXA:	SETZ TAC,
	LSHC TAC,6		;GET NEXT SIXBIT CHAR
	MOVEI TEM,40(TAC)	;PRINT ASCII
	XCT TYO
	SOJG UCHN,PRSIXA	;PRINTED ENOUGH CHARS YET?
	POPJ P,			;YUP

;Print decimal number from TAC in 6 chars w/leading blanks
PRRECD:	MOVEI UCHN,6		;Min number of chars to print
	MOVE TAC,TAC1		;Get number where we can divide
PRRECL:	IDIVI TAC,=10		;Usual decimal print routine
	PUSH P,TAC1		;Save remainder
	SUBI UCHN,1		;Count another digit to be printed later
	JUMPE TAC,PRREC2	;If no more digits, put out leading spaces needed
	PUSHJ P,PRRECL		;Calculate remaining digits
PRREC3:	POP P,TEM		;Digit to print
	ADDI TEM,"0"
	XCT TYO			;Print digit
	POPJ P,

PRREC2:	JUMPLE UCHN,PRREC3	;Jump back to main printer if no padding needed
	MOVEI TEM," "
	XCT TYO			;Output some leading spaces
	SOJG UCHN,.-1
	JRST PRREC3		;Now go print the actual number

↑NXTDSK:HLRZ AC1,DEVSER(AC1)	;GET LINK TO NEXT DDB
	JUMPE AC1,CPOPJ		;DIRECT RETURN IF NONE
	MOVE AC2,DEVMOD(AC1)	;GET DEVICE CHARACTERISTICS
	TLNN AC2,DVDSK!DVUDP	;IS THIS A DSK DDB? (keep going past OLD mode UDPs)
	JRST NXTDSK		;NO.  GET NEXT DDB
	JRST CPOPJ1		;YES.  SKIP RETURN WITH DSK DDB
