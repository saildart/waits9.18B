COMMENT ⊗   VALID 00018 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	RBNTRY UDIREN UNWFRE ULINKF UDMP UREV URDIR UDSD SL DTR DT RDS RD WD RB GR JDE EE TFE DCIN DCOUT
C00005 00003	DTCDSP DTCINI
C00007 00004	MINTER UINTER DINTER
C00010 00005	DIRCHK DIRCH1 UDIRSH UDIR2 UDIR3
C00013 00006	DTCREN DTCDEL ULOOK UENTER UENTE1 UENTE2
C00019 00007	UTPCLS UTPCLR UTPREL UTPRL1
C00023 00008	BLKCHK SETI SETO GETF
C00026 00009	UOUTD UTBERR UIND DFILL COMCK0 COMCK1 COMCK3 COMCK2 UMPIN IMPOT COMCKE
C00033 00010	UOUT UOUT2 UOUTGO UOUT1 DTNOPO
C00037 00011	UIN UIN3 UINGO MFILL FILL FILL1 FILLER FILLC
C00043 00012	RDBN1 BAKWRD DXIT DXIT1 LOW ISLOW RBNLOS
C00046 00013	WRITE REVBLK BLKXIT BNEXIT WRFORW FORBLK READ RDFORW DWRITE DEXIT DREAD
C00051 00014	WTRV1 RDRV1 ENPT2
C00054 00015	DMPA0 DMPA1 DMPA2 DMPA3
C00057 00016	DTCINT DCCONO CHKCNT UIN1 BN
C00063 00017	DTCHNG DTC1 DTC3 DTC2 UTIME
C00066 00018	DTREDO ERSTOP DIRERR DIRER1
C00071 ENDMK
C⊗;
;RBNTRY UDIREN UNWFRE ULINKF UDMP UREV URDIR UDSD SL DTR DT RDS RD WD RB GR JDE EE TFE DCIN DCOUT

IFE FTF2,<	;Whole file

BEGIN DTCSER ↔ SUBTTL DTCSER - DECTAPE SERVICE ROUTINE - 8 SEPT 67

;SPECIAL I/O STATUS BITS

RBNTRY←←20	;NUMBER OF TIMES HE CAN

UDIREN←←200	;DIRECTORY HAS BEEN CHANGED AND MUST BE WRITTEN BY RELEASE
UNWFRE←←400	;FREE BLOCK POINTER HAS BEEN CHANGED IN CORE
ULINKF←←1000	;LAST OUTPUT BLOCK LINKED TO FREE STORAGE
UDMP←←2000	;DUMP MODE I OR O, INSTEAD OF BUFFERED MODE
UREV←←10000	;UNIT LAST WENT IN REVERSE DIRECTION
URDIR←←20000	;DIRECTORY OPERATION
UDSD←←100	;SUPPRESS DIRECTORY HANDLING (RH IOS).  SET BY INIT OR SETSTS

;CONO BITS FOR UTC

SL←←220000	;TURN ON, SELECT UNIT
DTR←←3000	;START/STOP DELAY (300 MS)
DT←←2000	;TURN AROUND DELAY (160 MS)
RDS←←1000	;RESELECT DELAY (20 MS)
RD←←300		;READ DATA
WD←←700		;WRITE DATA
RB←←200		;READ BLOCK NOS.
GR←←10000	;GO IN REVERSE DIRECTION(BACKWARDS)
JDE←←40000	;JOB DONE ENABLE
EE←←100000	;ENABLE END FLAG
TFE←←4000	;TIME FLAG ENABLE

DCIN←←4010+DCTCHN
DCOUT←←3410+DCTCHN
;DTCDSP DTCINI

;DECTAPE DISPATCH TABLE

	JRST	DTCINI	;INITILIZE
	JRST	DTC1	;DEVICE HUNG TIME OUT, STOP TAPE, AND JOB
↑DTCDSP:JRST	UTPREL	;RELEASE
	JRST	UTPCLS	;CLOSE
	JRST	UOUT	;OUTPUT - BUFFERED
	JRST	UIN	;INPUT - BUFFERED
	JRST	UENTER	;ENTER FILE NAME IN DIRECTORY
	JRST	ULOOK	;LOOKUP FILE NAME IN DIRECTORY
	JRST	UOUTD	;OUTPUT - DUMP MODE
	JRST	UIND	;INPUT - DUMP MODE
	JRST	SETO	;USETO - SET NEXT OUTPUT BLOCK NO.
	JRST	SETI	;USETI - SET NEXT INPUT BLOCK NO.
	JRST	GETF	;UGETF - GET NEXT FREE BLOCK NO.
	JRST	DTCREN	;RENAME - CALL NEW ROUTINE - RPH
	POPJ	P,	;CLOSE - INPUT
	JRST	UTPCLR	;UTPCLR - CLEAR DIRECTORY (CALL [SIXBIT /UTPCLR/]
	POPJ	P,	;MTAPE - IGNORE ON DECTAPE


DTCINI:	CONO	DTC,0	;INITIALIZE DECTAPE.  CLEAR CONTROL
	HLLZS	DTCCON	;CLEAR CONSO FLAGS
	CONO	DC,0	;CLEAR DATA CONTROL

IFE MTCNUM,<					;IF MAGTAPES EXIST, THEY DO THIS.
NOKL10,<	MOVEI	TAC,40+DCTCHN*2
IFE FTMAOFF,<
		IORI TAC,MATOFF		;INCLUDE OFFSET OF 0 OR 100
>;IFE FTMAOFF
IFN FTMAOFF,<
		CONSZ	APR,MAOFF		;TRAP OFFSET?
		IORI	TAC,100			;YES, OFFSET ADDRESS
>;IFN FTMAOFF
>;NOKL10

IFKL10,<	MOVEI	TAC,KLEPT+40+DCTCHN*2	>;IFKL10  ADDRESS FOR INTERRUPTS

		MOVEM	TAC,DCLOC
		ADDI	TAC,1
		MOVEM	TAC,DCLOC1  		>;IFE MTCNUM

	POPJ	P,
;MINTER UINTER DINTER

;COMMON ROUTINE TO CHECK INTERLOCK, INITIALIZE.  UUO LEVEL ONLY.
;BITS IN IOS HAVE BEEN SET BUT NOT STORED.
;TAC CONTAINS DISPATCH ADR. WHEN BLOCK NO. FOUND (READ,WRITE,DREAD,DWRITE)

;MINTER CALLED FOR DUMP MODE I/O
MINTER:	MOVEI	AC3,200		;GET A FREE STORAGE BLOCK FOR THE COMMAND LIST
	SKIPN	AC1,DMPFST(DDB)
	PUSHJ	P,UFSGET	;GET FREE STG BEFORE GETTING THE TAPE AND DC
	HRRZM	AC1,DMPFST(DDB)
UINTER:	TLZA	IOS,URDIR	;CLEAR DIRECTORY OPERATION BIT
DINTER:	TLO	IOS,URDIR	;FLAG DIRECTORY OPERATION
	PUSHJ	P,GETDCDT	;GET DATA CONTROL AND DECTAPE CONTROL
	 AOSE	 DTREQ		;(ARGUMENT EXECUTED BY GETDCDT)
	CONO	DC,0		;TURN OFF DATA CONTROL
	HRRM	TAC,BNDISP	;STORE DISPATCH ADR. WHEN BLOCK NO. FOUND
	LDB	TAC,PUNIT	;UNIT NO. OF THIS DECTAPE
	LSH	TAC,3		;SHIFT TO UNIT POSITION
	IORI	TAC,DTCCHN	;OR IN DT CHANNEL
	MOVEM	TAC,DTUNIT	;SAVE
	MOVEI	TAC,116
	HRRM	TAC,CONSZ1
	HLRE	TAC,UFREE(DDB)	;RESET BLOCK QUANTUM ALLOTMENT
;AS LONG AS THE TAPE KEEPS MOVING, ONE JOB MAY READ THIS MANY BLOCKS
;BEFORE RELINQUISHING THE DC AND DTC TO ANOTHER JOB.
	MOVEM	TAC,BLKCNT
IFN FTXADR,<
	MOVE TAC,[XPCW ENPT]	;SETUP END FOR NON-DUMP DC OPERATIONS
>;IFN FTXADR
IFE FTXADR,<
	MOVE	TAC,[JSR ENPT]	;SETUP END FOR NON-DUMP DC OPERATIONS
>;IFE FTXADR
	MOVEM	TAC,@DCLOC1	;IN PI TRAP LOC+1
	PUSHJ	P,SETACT	;SET IOACT.  STORE IOS.  RESET HUNG TIMEOUT
	MOVEM	DDB,USVDB	;SAVE ADR. OF DEVICE DATA BLOCK
	LDB	J,PJOBN
IFE FTMPP2,<
	MOVE TAC,JBTMAP(J)
	LSH TAC,9
	MOVEM TAC,UTCMAP	;POINTER TO JOB'S MAP
>;IFE FTMPP2
IFN FTMPP2,<
	MOVEI AC1,DTUEXP	;EXEC VIRTUAL PAGE WHERE WE WANT UPMP
	PUSHJ P,JOBEVP		;SET UP POINTER TO UPMP
	 JFCL
>;IFN FTMPP2
	POPJ P,
;DIRCHK DIRCH1 UDIRSH UDIR2 UDIR3

;CHECK IF DIRECTORY IN CORE. IF IT ISN'T, WE'LL READ IT IN

DIRCHK:	TRNN	IOS,UDSD		;DIRECTORY BEING SUPPRESSED?
	SKIPGE	DEVMOD(DDB)		;NO. DIRECTORY IN CORE?
	POPJ	P,			;YES
	MOVEI	TAC,READ		;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ	P,UTPRL1		;READ DIRECTORY.  RETURN WHEN FINISHED.
	HRRZ	TAC,@UDIR(DDB)		;CHECK REL. POINTER TO FIRST DIR. ENTRY
	JUMPE	TAC,DIRERR		;BAD IF ZERO
	CAIL	TAC,174
	JRST	DIRERR			;PRINT BAD DIRECTORY.  DO NOT RETURN
	TLZ	IOS,UDIREN+ULINKF+UNWFRE	;DIRECTORY IN CORE, BUT NOT CHANGED
DIRCH1:	MOVSI	TAC,DVDIRIN		;DIRECTORY IN CORE.  (CLEARED BY ASSIGN)
	IORM	TAC,DEVMOD(DDB)
	HLRZ	TAC,@UDIR(DDB)		;LAST BLOCK WRITTEN
	HRRM	TAC,UFREE(DDB)		;SAVE IN DEVICE DATA BLOCK
	POPJ	P,



;UDIRSH  - SEARCH DIRECTORY FOR ENTER AND LOOKUP - UUO LEVEL ONLY
;CALL:	PUSHJ	P,UDIRSH
;	NOT IN DIRECTORY RETURN
;	NORMAL RETURN WHEN ENTRY IS FOUND
;	NEVER RETURNS IF DIRECTORY FULL

UDIRSH:	XCTR	XR,[MOVE TAC,3(UUO)]	;ADDRESS CHECK LAST WORD OF ARGUMENT BLOCK
	PUSHJ	P,DIRCHK		;READ DIRECTORY IF NECESSARY.
	HRRZ	TAC,UDIR(DDB)		;LOC. OF DIRECTORY
	HRRZ	TAC1,(TAC)		;REL. ADR. OF 1ST ENTRY
	HRLI	TAC,-=129+4(TAC1)	;ENTRY COUNTER
	ADDI	TAC,(TAC1)		;START OF FIRST ENTRY.  -=120,,FIRST ADDR.
UDIR2:	SKIPN	TAC1,(TAC)		;FIRST WORD OF NEXT ENTRY
	POPJ	P,			;FILE NOT IN DIRECTORY RETURN
	XCTR	XR,[CAME TAC1,(UUO)]	;CHECK IF EQUAL TO USER'S ARGUMENT
	JRST	UDIR3			;NO.
	XCTR	XR,[HLRZ TAC1,1(UUO)]	;GET EXTENSION FROM USER
	HLRZ	DAT,1(TAC)		;EXTENSION FROM DIRECTORY.
	CAIN	DAT,(TAC1)		;EXTENSION MATCH?
	JRST	CPOPJ1			;YES, GIVE FILE FOUND RETURN.
UDIR3:	ADD	TAC,[XWD 4,4]
	JUMPL	TAC,UDIR2		;FINISHED YET?
	JRST	TPOPJ			;YES ERROR RETURN TO USER.
;DTCREN DTCDEL ULOOK UENTER UENTE1 UENTE2

;RENAME LOOKUP ENTER

DTCREN:	TRNE	IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST	CPOPJ1			;YES, GIVE SUCCESS RETURN
	SKIPE	TAC,CURENT(DDB)		;PICK UP CURRENT ENTRY POINTER AND CHECK
	SKIPN	(TAC)			;AND MAKE SURE ITS THERE
	POPJ	P,			;ERROR RETURN
	MOVSI	IOS,UDIREN		;MARK DIRECTORY HAS CHANGED.
	IORB	IOS,DEVIOS(DDB)
	XCTR	XR,[SKIPN (UUO)]		;DELETING?
	JRST	DTCDEL				;YES
	XCTR	XR,[MOVE TAC1,(UUO)]
	MOVEM	TAC1,(TAC)			;FILE NAME
	XCTR	XR,[MOVE TAC1,1(UUO)]
	HLLM	TAC1,1(TAC)			;EXT.
	XCTR	XR,[MOVE TAC1,2(UUO)]
	MOVEM	TAC1,2(TAC)			;LOW DATE.
	XCTR	XLB,[LDB TAC1,[POINT 3,1(UUO),20]]	;GET HIGH DATE.
	DPB	TAC1,[POINT 3,2(TAC),23]	;STUFF HIGH DATE. REG.
	XCTR	XR,[MOVE TAC1,3(UUO)]
	MOVEM	TAC1,3(TAC)			;IOWD FOR DMP FILES.
	JRST	CPOPJ1

DTCDEL:	SETZM	CURENT(DDB)		;NO CURRENT FILE
	HRLI	TAC,4(TAC)		;BLT THE REST OF THE DIRECTORY DOWN
	HRRZ	TAC1,UDIR(DDB)		;OVER THIS ENTRY.  TAC1←ADDR OF DIR.
	BLT	TAC,177(TAC1)		;BLT DIRECTORY DOWN
	SETZM	174(TAC1)		;CLEAR END OF THE DIRECTORY.
	SETZM	175(TAC1)		;IN CASE ITS WASN'T 0
	SETZM	176(TAC1)
	SETZM	177(TAC1)
	JRST	CPOPJ1

;LOOKUP UUO

;CALL:	LOOKUP D,E
;	NOT FOUND IN DIRECTORY RETURN
;	FOUND

;C(E)=LEFT JUSTIFIED SIXBIT FILE NAME
;C(E+1)=LH=LEFT JUSTIFIED 3 CHAR. SIXBIT FILE NAME EXTENSION
;  RH=FIRST BLOCK NO. IN FILE
;  BITS 18-21 HIGH DATE. (RETURNED ON LOOKUP, SET ON ENTER) ;REG DATE75
;C(E+2)=RIGHT 12 BITS=DATE FILE WAS CREATED		;REG 11/08/74 DATE75
;C(E+3)=BLKI POINTER FOR DUMPED SAVE-GET FILES



ULOOK:	TRNE	IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST	CPOPJ1			;YES.
	SETZM	CURENT(DDB)		;NO CURRENT FILE YET
	PUSHJ	P,UDIRSH		;SEARCH DIRECTORY.
	POPJ	P,			;NOT FOUND. GIVE ERROR RETURN.
	HRRZM	TAC,CURENT(DDB)		;SAVE ADDRESS OF CURRENT ENTRY
	HRR	DAT,1(TAC)		;FIRST BLOCK OF FILE
	HRRM	DAT,DTNEXT(DDB)		;SAVED AS NEXT INPUT BLOCK NUMBER
	MOVE	TAC1,(TAC)		;FILE NAME
	XCTR	XW,[MOVEM TAC1,(UUO)]
	MOVE	TAC1,1(TAC)		;EXT,,BLOCK NUMBER
	LDB	DAT,[POINT 3,2(TAC),23]	;GET HIGH DATE
	DPB	DAT,[POINT 3,TAC1,20]
	XCTR	XW,[MOVEM TAC1,1(UUO)]	;EXT,,DATE,BLOCK NUMBER
	MOVE	TAC1,2(TAC)
	ANDI	TAC1,7777
	XCTR	XW,[MOVEM TAC1,2(UUO)]	;LOW DATE ONLY.
	MOVE	TAC1,3(TAC)
	XCTR	XW,[MOVEM TAC1,3(UUO)]	;IOWD OR ZERO
	JRST	CPOPJ1			;SKIP RETURN TO USER.


;ENTER UUO

UENTER:	TRNE	IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST	CPOPJ1			;YES. GIVE SUCCESSFUL RETURN
	SETZM	CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	XCTR	XR,[SKIPN (UUO)]	;NULL NAME?
	POPJ	P,			;YES. GIVE ERROR RETURN.
	PUSHJ	P,UDIRSH		;SEARCH DIRECTORY, WE MAY BE SUPERCEDING
	JRST	UENTE1			;NOT IN DIRECTORY, AND DIRECTORY NOT FULL
	SKIPL	3(TAC)			;IN DIRECTORY. IS OLD A DUMP FILE?
	JRST	UENTE1			;OLD WASN'T A DMP FILE.
	XCTR	XR,[SKIPGE TAC1,3(UUO)]	;GET NEW BLKO POINTER
	CAMGE	TAC1,3(TAC)		;IS NEW FILE SHORTER THAN OLD?
	JRST	UENTE1			;NEW IS LONGER, OR NO BLKO. ADD AT THE EOT
	HRRZ	DAT,1(TAC)		;RE-SAVE NEW FILE AT SAME SPOT ON TAPE.
	TLO	IOS,UDIREN		;NO. SET TO WRITE DIRECTORY AT RELEASE
	JRST	UENTE2

UENTE1:	TLO	IOS,UNWFRE+ULINKF+UDIREN	;FILE GOES AT END OF TAPE
	AOS	DAT,UFREE(DDB)			;GET FIRST FREE BLOCK
UENTE2:	HRRZM	TAC,CURENT(DDB)			;SAVE CURRENT ENTRY POINTER
	XCTR	XDB,[DPB DAT,[POINT 15,1(UUO),35]]	;FIRST BLOCK NO. OF FILE
	HRLM	DAT,DTNEXT(DDB)			;STORE NEXT BLOCK TO WRITE
	MOVEM	IOS,DEVIOS(DDB)			;STORE IOS.
	XCTR	XR,[MOVE TAC1,(UUO)]		;FILE NAME
	MOVEM	TAC1,(TAC)
	XCTR	XR,[MOVE TAC1,1(UUO)]		;EXT,,HIGH DATE, BLOCK NUMBER
	TRZ	TAC1,700000			;CLEAR HIGH DATE.
	MOVEM	TAC1,1(TAC)
	MOVE	TAC1,THSDAT
	MOVEM	TAC1,2(TAC)			;ALWAYS ENTER CURRENT DATE.
	XCTR	XR,[MOVE TAC1,3(UUO)]
	MOVEM	TAC1,3(TAC)			;IOWD OR ZERO
	JRST	CPOPJ1
;UTPCLS UTPCLR UTPREL UTPRL1

;CLOSE, RELEASE, UTPCLR UUOS

;CLOSE UUO - CALLED ONLY IF THIS USER CHANNEL HAS DONE OUTPUT

UTPCLS:	SETZM	CURENT(DDB)		;CLEAR CURRENT FILE
	LDB	TAC,PIOMOD		;GET DATA MODE?
	CAIGE	TAC,DR			;IS IT DR OR D(DUMP MODE)?
	TLNN	IOS,ULINKF		;NO, NOT LINKED TO FREE STORAGE?
	POPJ	P,			;YES, DON'T WRITE OUT LAST BUFFERFUL
	HRRZ	TAC,DEVOAD(DDB)		;ADDRESS OF USER'S OUTPUT BUFFER
	MOVEI	TAC1,1			;SET LINK TO 1 IN LH OF THIRD WORD
	XCTR	XRW,[HRLM TAC1,1(TAC)]	;IN USER AREA (FLAG AS LAST BLOCK)
	JRST	OUT			;DO OUTPUT

;UTPCLR UUO - CLEAR DECTAPE DIRECTORY

UTPCLR:	TRNE	IOS,UDSD		;DIRECTORY BEING SUPPRESSED?
	POPJ	P,			;YES
	TLO	IOS,UDIREN+UNWFRE	;FLAG DIRECTORY CHANGED. UFREE MODIFIED
	MOVE	TAC,UDIR(DDB)		;INITIALIZE EXEC CORE DIRECTORY
	MOVE	TAC1,[1,,5]		;SET FIRST WORD IN DIRECTORY
	MOVEM	TAC1,(TAC)		;LH=LAST BLOCK USED,RH=FIRST FREE DIR ENTRY
	HRL	TAC,TAC
	AOBJN	TAC,.+1			;INCREMENT BOTH HALVES
	SETZM	(TAC)			;CLEAR SECOND WORD
	MOVE	TAC1,TAC
	AOS	TAC
	BLT	TAC,176(TAC1)		;CLEAR REST OF 200 WORD DIRECTORY
	PUSHJ	P,DIRCH1		;SET DVDIRIN AND UFREE.  ALWAYS WRITE TAPE

;RELEASE.  WRITE DIRECTORY IF CORE VERSION DIFFERS FROM TAPE VERSION (BLOCK 1)

UTPREL:	SKIPE	AC1,DMPFST(DDB)		;IN CASE OF ↑C FROM DUMP I/O UUO
	PUSHJ	P,FSGIVE
	SETZM	DMPFST(DDB)
	TRNE	IOS,UDSD		;SUPPRESSING DIRECTORY?
	POPJ	P,			;YES, JUST RETURN
	SKIPG	DEVMOD(DDB)		;IS DIRECTORY IN CORE?
	TLZN	IOS,UDIREN+UNWFRE	;YES.  DOES DIR NEED TO BE WRITTEN?
	POPJ	P,			;NO, DO NOT WRITE DIRECTORY
	MOVEI	TAC,WRITE		;DISPATCH WHEN BLOCK IS FOUND
;ENTER UTPRL1 WITH TAC SET TO READ, FOR READING DIRECTORY.
UTPRL1:	PUSHJ	P,DINTER		;GET INTERLOCK.  FLAG DIRECTORY OP.
	MOVE	TAC,UFREE(DDB)		;NEW FREE BLOCK POINTER
	HRLM	TAC,@UDIR(DDB)		;STORE IN LH OF FIRST WORD OF DIR.
	HRRZ	TAC,UDIR(DDB)		;ADD. OF EXEC DIR. CORE BUFFER
	SOS	TAC			;ADRRESS-1
	MOVEM	TAC,UBUF		;STORE BUFFER ADR.
	MOVEI	TAC,1			;WRITE (OR READ) BLOCK 1
	PUSHJ	P,FILL			;GO START TAPE
	JRST	WAIT1			;WAIT BEFORE RETURNING TO USER
;BLKCHK SETI SETO GETF

;CHECK FOR LEGAL BLOCK NUMBER.  SUBR FOR USETO, USETI
;BLOCK NUMBERS LESS THAN 1102 ARE LEGAL, OR ALL BLOCK NUMBERS IF NON-STANDARD TAPE
;CALL:	MOVE	UUO,<BLOCK>
;	PUSHJ	P,BLKCHK
;	<RETURN HERE ALWAYS>	;IOBKTL WILL BE SET IF BLOCK NUMBER IS ILLEGAL

BLKCHK:	HRRZ	UUO,UUO		;RIGHT HALF ONLY FOR COMPARE.
	TRNN	IOS,UDSD	;NON-STANDARD TAPE?
	CAIG	UUO,1101	;NO.  LEGAL BLOCK NUMBER?
	POPJ 	P,		;LEGAL BLOCK, OR NON-STANDARD TAPE.
	TRO	IOS,IOBKTL	;NO. SET IOBKTL.
	MOVEM	IOS,DEVIOS(DDB)
	POPJ	P,


;USETI UUO - SET NEXT BLOCK NUMBER FOR INPUT
SETI:	PUSHJ	P,BLKCHK		;CHECK FOR ILLEGAL BLOCK NUMBER
	PUSHJ	P,WAIT1			;WAIT TILL ALL BUFFERS FILLED.
	TLZ	IOS,IOEND		;CLEAR END OF FILE BIT
	TRZ	IOS,IODEND		;SYSTEM AND USER
	HRRM	UUO,DTNEXT(DDB)		;STORE NEXT BLOCK TO READ IN DDB
	MOVEM	IOS,DEVIOS(DDB)
	POPJ	P,

;USETO UUO - SET NEXT BLOCK NUMBER FOR OUTPUT
SETO:	PUSHJ	P,BLKCHK		;CHECK FOR ILLEGAL BLOCK NUMBER
	PUSHJ	P,WAIT1		;WAIT TILL ALL BUFFERS EMPTIED.
	HRLM	UUO,DTNEXT(DDB)	;SET NEXT BLOCK NO. IN DEVICE DATA BLOCK
	POPJ	P,

;UGETF UUO - GET NEXT FREE BLOCK NO.
;IF DIRECTORY IS SUPPRESSED, RETURNS: [NEXT BLOCK TO WRITE,,NEXT BLOCK TO READ]

GETF:	PUSHJ	P,WAIT1			;WAIT TILL DEVICE INACTIVE
	MOVE	TAC,DTNEXT(DDB)
	TRNE	IOS,UDSD		;IS DIRECTORY BEING SUPPRESSED?
	JRST	STOTAC			;YES
	PUSHJ	P,DIRCHK		;CHECK TO SEE IF DIRECTORY IN CORE
	TLO	IOS,UNWFRE		;FLAG FREE BLOCK POINTER ALTERED
	MOVEM	IOS,DEVIOS(DDB)
	AOS	TAC,UFREE(DDB)		;GET FREE BLOCK POINTER
	HRLM	TAC,DTNEXT(DDB)		;SET NEXT BLOCK TO WRITE
	HRRZ	TAC,TAC
	JRST	STOTAC			;STORE TAC IN USER AREA
;UOUTD UTBERR UIND DFILL COMCK0 COMCK1 COMCK3 COMCK2 UMPIN IMPOT COMCKE

;DUMP MODE I/O UUOS

;CALL:	OUTPUT D,ADR  OR  INPUT D,ADR
;
;WHERE ADR IS START OF A COMMAND LIST OF FOLLOWING FORM:
;	IOWD N,LOC	;ARBITRARY NO OF THESE
;	LOC1		;ARBITRARY NO OF THESE
;	0


UOUTD:	TLO IOS,IO!UDMP		;FLAG OUTPUT AND DUMP MODE
	MOVEI TAC,DWRITE	;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ P,MINTER		;CHECK INTERLOCK AND INITIALIZE
	HLRZ TAC,DTNEXT(DDB)	;NEXT OUTPUT BLOCK NO.
	TRNN IOS,UDSD		;SUPPRESSING DIRECTORY?
	CAILE TAC,1		;TRYING TO WRITE BLOCK 0 OR BLOCK 1
	JRST DFILL		;NO.
UTBERR:	TRO IOS,IOBKTL		;ILLEGAL BLOCK NUMBER.  SET IOBKTL
	JRST DTC1		;STOP TAPE AND DESELECT


UIND:	TLZ IOS,IO		;FLAG INPUT IN PROGRESS
	TLO IOS,UDMP		;DUMP MODE
	MOVEI TAC,DREAD		;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ P,MINTER		;CHECK INTERLOCK
	HRRZ TAC,DTNEXT(DDB)	;BLOCK NO. TO BE READ
DFILL:	HRRZM TAC,UBKN		;STORE FIRST BLOCK NO (LAST WILL BE CHECKED)
IFN FTXADR,<
	MOVE TAC1,[XPCW DMPADV]
>;IFN FTXADR
IFE FTXADR,<
	MOVE TAC1,[JSR DMPADV]
>;IFE FTXADR
	MOVEM TAC1,@DCLOC1	;WHERE TO GO WHEN BLKO/BLKI FINISHED
	MOVEI TAC1,16		;SET ERROR FLAGS (ALL EXCEPT INCOMPLETE BLOCK)
	HRRM TAC1,CONSZ1

;HERE WE ADDRESS CHECK THE COMMAND LIST, COPYING IT TO FREE STORAGE (PROTECTED
;FROM INPUT OPERATIONS) AND BREAKING UP EACH COMMAND WORD INTO A MAXIMUM OF
;TWO ALIGNED PAGES.  THIS FACILITATES THE CONVERSION TO EXEC MAPPING.
	MOVE AC1,DMPFST(DDB)
	HRLI AC1,-177		;COUNT,,POINTER

	MOVEI AC2,JOBPFI	;HIGHEST LOC PROTECTED FROM IO IN JOB DATA AREA
	MOVE AC3,UUOPC(J)
	TLNN AC3,USRMOD		;IF THIS A MONITOR CALL, THEN
	MOVEI AC2,JOBSAV	;     HIGHEST LOCATION NOT USED BY SAVGET IO
	MOVEI DAT,0		;TOTAL WORD COUNT.
	MOVEI J,100		;MAXIMUM OF 100 LISTS.
	JRST COMCK1

COMCK0:	MOVEI UUO,(TAC1)	;CHANGE COMMAND LIST POINTER ON GO TO WORD
	MOVE TEM,JOB
	HLRZ TEM,JBTPAG(TEM)
	LSH TEM,9		;LOWER SEGMENT WORD COUNT.
	CAILE UUO,(AC2)		;ADR ABOVE PROTECETED AREA?
	CAML UUO,TEM		;AND WITHIN USER'S CORE?
	JRST COMCKE		;ADDRESS ERROR.
COMCK1:	SOJLE J,COMCKE		;JUMP IF WE EXCEED 100 WORDS FETCHED
	XCTR XR,[SKIPN TAC1,(UUO)]	;GET NEXT IOWD.
	JRST COMCK2		;END OF LIST.
	TLNN TAC1,-1		;IS IT A GO TO WORD?
	JRST COMCK0		;YES.  INTERPRET JUMP COMMANDS
	HLRO AC3,TAC1		;NO.  SAVE NEGATIVE WORD COUNT
	SUB DAT,AC3		;ACCUMULATE -WC
	HRRZ TAC1,TAC1		;GET LOWEST ADDRESS-1
	CAIGE TAC1,(AC2)	;ABOVE LOWEST PROTECTED ADDRESS?
	JRST COMCKE		;NO.  ERROR.
	SUB TAC1,AC3		;COMPUTE LAST LOCATION
	MOVE TEM,JOB
	HLRZ TEM,JBTPAG(TEM)
	LSH TEM,9		;LOWER SEGMENT WORD COUNT.
	TLNN TAC1,-1		;SKIP IF WRAP AROUND (AN ERROR)
	CAML TAC1,TEM		;IN BOUNDS?
	JRST COMCKE		;NO.  ERROR.
	XCTR XR,[HRRZ TAC1,(UUO)]	;GET THE STARTING ADDRESS AGAIN
COMCK3:	MOVEI TEM,777
	ANDI TEM,(TAC1)
	CAIN TEM,777
	MOVNI TEM,1
	SUBI TEM,1777		;-(NUMBER OF WORDS BEFORE END OF 2ND PAGE)
	CAMGE TEM,AC3		;IS MAX WC (TEM) LARGER THAN REMAINING WC?
	MOVE TEM,AC3		;YES, REDUCE IT (THIS IS THE LAST ONE)
	HRLZM TEM,(AC1)		;STORE -WC.
	HRRM TAC1,(AC1)		;STORE ADDRESS-1
	AOBJP AC1,COMCKE	;INCREMENT FREE STG POINTER. JUMP IF LOSING
	SUB AC3,TEM		;DECREMENT WC BY THE AMOUNT WE JUST NIBBLED
	SUB TAC1,TEM		;AND ADVANCE THE CORE ADDRESS BY THE SAME
	JUMPL AC3,COMCK3	;LOOP UNLES WE'RE DONE WITH THIS IOWD
	AOJA UUO,COMCK1		;FETCH NEXT IOWD

COMCK2:	SETZM (AC1)		;END BY STORING A ZERO.
	SKIPN @DMPFST(DDB)	;IS COMMAND LIST EMPTY?
	JRST DTC1		;YES, STOP TAPE AND RETURN
	SOS DAT			;CONVERT WC TO BLOCK COUNT-1
	ASH DAT,-7
	ADD DAT,UBKN		;PLUS FIRST BLOCK NUMBER = LAST BLOCK
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	JRST .+3		;YES, DON'T CHECK BLOCK NUMBERS
	CAILE DAT,1101		;LAST BLOCK TOO HIGH?
	JRST UTBERR		;YES
	TLNN IOS,IO		;OUTPUT?
	AOJA DAT,UMPIN		;NO, SET DAT TO NEXT BLOCK AFTER FILE
	HRRZ TAC,UFREE(DDB)
	CAMGE DAT,TAC		;OUTPUT. GREATER THAN CURRENT FREE BLOCK?
	JRST IMPOT		;NO
	HRRM DAT,UFREE(DDB)	;YES, SET LAST BLOCK USED
	ADDI DAT,1		;SET DAT TO BLOCK NUMBER AFTER THIS OP.
	HRLM DAT,DTNEXT(DDB)	;SET NEXT BLOCK TO WRITE (AFTER THIS)
	TLOA IOS,UNWFRE		;FLAG AS MODIFIED
UMPIN:	HRRM DAT,DTNEXT(DDB)	;SET NEXT BLOCK TO READ
IMPOT:	MOVEM IOS,DEVIOS(DDB)
	JRST FILL1		;GO START TAPE (FIRST BLOCK STORED IN UBKN)

COMCKE:	PUSHJ P,DTC1		;ADDRESS CHECK.  RELEASE TAPE.
	JRST ADRERR		;STOP JOB.  PRINT MESSAGE.
;UOUT UOUT2 UOUTGO UOUT1 DTNOPO

;BUFFERED OUTPUT


UOUT:	HRRZ	TAC,DEVOAD(DDB)		;RELATIVE ADDRESS OF BUFFER.
	XCTR	XR,[SKIPN 1(TAC)]	;WORD COUNT ZERO?
	JRST	DTNOPO			;YES. 
	TLZ	IOS,UDMP+ULINKF		;CLEAR DUMP MODE AND LINKED TO FREE STG
	TLO	IOS,IO			;FLAG THAT OUTPUT IS BEING DONE
	HLRZ	TAC1,DTNEXT(DDB)	;OUTPUT BLOCK NUMBER TO WIRTE
	TRNN	IOS,UDSD		;SUPPRESSING DIRECTORY?
	CAIE	TAC1,1			;NO. TRYING TO WRITE BLOCK 1?
	JRST	UOUT2			;NOT BLOCK 1 OR SUPPRESSED DIRECTORY
;COPY USER BUFFER INTO EXEC DIRECTORY CORE BUFFER
	MOVSI	TAC1,1(TAC)		;SOURCE IS THIRD WORD OF USER BUFFER
	HRR	TAC1,UDIR(DDB)		;ADR. OF DIRECTORY BUFFER IN EXEC
	MOVE	TAC,TAC1
	XCTR	XBLTR,[BLT TAC1,177(TAC)]	;MOVE 200 WORDS FROM USER TO EXEC
	SETZM	CURENT(DDB)		;NO CURRENT FILE.
	TLO	IOS,UDIREN		;FLAG DIRECTORY NEEDS OUTPUT.
	MOVEM	IOS,DEVIOS(DDB)
	PUSHJ	P,ADVBFE
	JFCL
	JRST	DIRCH1			;SET DVDIREN AND UFREE


UOUT2:	MOVEI	TAC,WRITE		;DISPATCH AFTER BLOCK IS FOUND
	PUSHJ	P,UINTER		;CHECK INTERLOCK.  GET CONTROL

;HERE AT INTERRUPT LEVEL IF NEXT BUFFER READY WITH DATA TO GO OUT

UOUTGO:	HRRZ	TAC,DEVOAD(DDB) 	;RELATIVE ADDRESS OF USER'S OUTPUT BUFFER-1
	MOVEM	TAC,UBUF
	TLZ	IOS,ULINKF		;FLAG THIS BLOCK NOT LINKED TO FREE STORAGE
	XCTR	XR,[HLRZ TAC1,1(TAC)]	;BLOCK TIE FROM BUFFER (NEXT BLOCK)
	JUMPN	TAC1,UOUT1		;USE BLOCK NO.INDICATED IF NON ZERO
	TLO	IOS,UNWFRE+ULINKF	;FLAG LINKED TO FREE STORAGE
	AOS	TAC1,UFREE(DDB)		;NEXT FREE BLOCK
UOUT1:	MOVEM	IOS,DEVIOS(DDB)		;STORE IOS LINKED FLAG, ETC.
	TLZ	TAC1,-1			;GET UFREE ALONE
	CAIN	TAC1,1			;IF 1, THIS IS LAST BLOCK (SET BY CLOSE)
	MOVEI	TAC1,0			;SET BLOCK TIE TO 0
	XCTR	XRW,[HRLM TAC1,1(TAC)]	;IN USER BUFFER, WHERE WE'LL WRITE IT.
	HLRZ	TAC,DTNEXT(DDB)		;BLOCK TO WRITE NOW
	HRLM	TAC1,DTNEXT(DDB)	;STORE BLOCK TO WRITE NEXT
	JRST	MFILL			;GO START TAPE

DTNOPO:	PUSHJ	P,ADVBFE		;WORD COUNT WAS ZERO. IGNORE BUFFER
	JFCL
	POPJ	P,			;RETURN TO UUOCON
;UIN UIN3 UINGO MFILL FILL FILL1 FILLER FILLC

;BUFFERED INPUT

UIN:	TLZ	IOS,UDMP!IO		;FLAG INPUT AND NOT DUMP MODE
	HRRZ	TAC,DTNEXT(DDB)		;NEXT BLOCK TO READ
	TRNN	IOS,UDSD		;SUPPRESSING DIRECTORY?
	CAIE	TAC,1			;NO. IS THIS BLOCK 1?
	JRST	UIN3			;NOT BLOCK 1 OR DIRECTORY SUPPRESSED.
	PUSHJ	P,DIRCHK		;MAKE SURE DIRECTORY IS IN CORE.
	MOVE	TAC1,UFREE(DDB)		;PLACE FREE BLOCK POINTER
	HRLM	TAC1,@UDIR(DDB)		;IN DIRECTORY
	HRRZ	TAC,DEVIAD(DDB)		;REL ADDRESS OF 2ND WORD OF BUFFER.
	MOVEI	TAC1,1(TAC)		;BUFFER ADDRESS DESTINATION
	HRL	TAC1,UDIR(DDB)		;SOURCE
	XCTR	XBLTW,[BLT TAC1,200(TAC)]	;MOVE DIRECTORY TO BUFFER
	PUSHJ	P,ADVBFF		;ADVANCE INPUT BUFFER
	JFCL				;IGNORE IF NEXT ONE STILL FULL
	POPJ	P,


UIN3:	MOVEI	TAC,READ		;DISPATCH WHEN BLOCK IS FOUND
	PUSHJ	P,UINTER		;GET INTERLOCK

;HERE AT INTERRUPT LEVEL IF NEXT INPUT BUFFER READY FOR DATA

UINGO:	MOVE	TAC,DEVIAD(DDB)		;RELATIVE ADDRESS OF USER'S BUFFER
	MOVEM	TAC,UBUF
	HRRZ	TAC,DTNEXT(DDB)		;NEXT BLOCK TO READ
;HERE FOR OUTPUT.  BLOCK TO READ OR WRITE IN TAC. RELATIVE BUFFER ADDRESS IN UBUF.
MFILL:

	AOS	UBUF			;ADVANCE TO FIRST CORE ADDRESS
	LDB	AC2,[POINT 9,UBUF,26]	;AC2←PAGE NUMBER OF FIRST WORD
	MOVEI	AC3,DTCEXP		;NUMBER OF FIRST EXEC PAGE FOR DTC
	DPB	AC3,[POINT 9,UBUF,26]	;STORE EXEC PAGE NUMBER INSTEAD
	SOS	UBUF			;RE-CONVERT TO IOWD FORMAT
IFE FTMPP2,<
	ADD	AC2,UTCMAP		;POINTER TO USER'S PAGE MAP ENTRY
>;IFE FTMPP2
IFN FTMPP2,<
	ADDI AC2,DTUEXP⊗9		;UPMP ALWAYS IN SAME EXEC VIRTUAL PG
>;IFN FTMPP2
	MOVE	AC3,(AC2)
	MOVEM	AC3,EXPGT+DTCEXP	;MAKE EXEC MAP POINT TO USER'S PAGES
	MOVE	AC3,1(AC2)
	MOVEM	AC3,EXPGT+DTCEXP+1
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,DTCEXP⊗9		;CLEAR PAGE TABLE RAM FOR DTCEXP
>;IFKL10

;HERE FROM UTCRL1 DOING IO INTO THE DDB. - NO SPECIAL EXEC PAGES ARE SETUP.
FILL:	HRRZM	TAC,UBKN		;STORE BLOCK NO.TO READ OR WRITE
	TRNE	IOS,UDSD		;NON-STANDARD TAPE?
	JRST	FILL1			;YES. DON'T CHECK BLOCK NO.
	CAIL	TAC,1102		;IS IT TOO LARGE?
	JRST	UTBERR			;YES,ILLEGAL BLOCK NO.
FILL1:	SETZM	UERRCN			;NO ERRORS FOR THIS OP.  (HERE FOR DUMP IO)
	SETZM	ERRFLG			;CLEAR DC DATA MISSED FLAG
FILLER:
IFN FTXADR,<
	MOVE TAC,[XPCW RDBN]		;SETUP TO READ BLOCK NOS. (RETRY IF ERRORS)
>;IFN FTXADR
IFE FTXADR,<
	MOVE	TAC,[JSR RDBN]		;SETUP TO READ BLOCK NOS. (RETRY IF ERRORS)
>;IFE FTXADR
	MOVEM	TAC,@DCLOC		;IN EVEN DC PI LOC
	PUSHJ	P,STOIOS		;STORE IOS AND RESET HUNG DEVICE COUNT
	MOVEI	TAC,RBNTRY		;NUMBER OF REVERSALS WE WILL ALLOW
	MOVEM	TAC,RBNCNT
	MOVE	TAC,DTUNIT		;GET UNIT NO + DTC CHANNEL
	CONO	DC,DCIN			;SET TO READ BLOCK NOS FROM DECTAPE
	CONO	PI,DCTON		;TURN DC PI CHANNEL ON
	CONSZ	DTC,20000		;IS TAPE MOVING? (ARE WE AT INTERRUPT LEVEL)
	JRST	FILLC			;YES
	TLNN	IOS,UREV		;NO, WAS LAST DIRECTION REVERSE?
	IORI	TAC,GR			;NO,REVERSE THIS TIME
	HRLI	TAC,17			;CONSZ TEST FLAGS
	IORI	TAC,SL+DTR+RB+EE	;CONO FLAGS
	SYSPIFF
	HLRM	TAC,DTCCON		;PARITY ERR, TAPE END, ILL OP, JOB DONE.
	CONO	DTC,(TAC)		;SELECT, START DELAY, READ BN, EOT ENABLE
	SYSPIN
	POPJ	P,			;RETURN

FILLC:	CONSZ	DTC,GR			;TAPE ALREADY MOVING, GOING BACKWARD?
	IORI	TAC,DT			;YES,TURN AROUND DELAY
	CONO	DTC,SL+RB+EE(TAC)	;MAKE GO FORWARD ALWAYS
	POPJ	P,			;RETURN AT UUO LEVEL OR DISMISS INTERRUPT
;RDBN1 BAKWRD DXIT DXIT1 LOW ISLOW RBNLOS

;READ BLOCK NUMBERS

;IN ALLDAT:
;	↑RDBN:		0
;			JRST RDBN1

↑RDBN1:	MOVEM	TAC,DTTAC
	EXCH	DDB,USVDB	;RESET HUNG DEVICE TIME COUNT
	LDB	TAC,PDVTIM	;TIME IN SECONDS
	DPB	TAC,PDVCNT	;COUNT DOWN TO 0 BEFORE HUNG
	EXCH	DDB,USVDB
	DATAI	DC,TAC		;READ IN BLOCK NO. JUST READ
	ANDI	TAC,7777	; FOR PDP-8 FORMAT TAPE, MASK OUT CRAP
	SUB	TAC,UBKN	;COMPARE WITH DESIRED ONE
	JUMPE	TAC,@BNDISP	;IS IT EQUAL?
	SOS	BLKCNT		;DECREMENT COUNT OF BLOCKS READ
	JUMPL	TAC,LOW		;NO,IS IT LESS THAN DESIRED?
	MOVE	TAC,DTUNIT	;NO, UNIT NO.+DT CHANNEL
	CONSZ	DTC,GR		;IS TAPE GOING BACKWARD?
	JRST	BAKWRD
	SOSGE	RBNCNT		;ANOTHER REVERSAL
	JRST	RBNLOS		;TOO MANY!
	IORI	TAC,DT		;NO,ADD IN DELAY TO CHANGE DIRECTION
BAKWRD:	CONO	DTC,SL+RB+GR+EE(TAC)	;MAKE TAPE GO BACKWARD
DXIT:	CONO	DC,DCIN		;SET DATA CONTROL TO READ BLOCK NOS.
DXIT1:	MOVE	TAC,DTTAC
IFN FTXADR,<
	XJEN RDBN
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@RDBN
>;IFE FTXADR

LOW:	MOVE	TAC,DTUNIT	;POSITION IS BEFORE DESIRED BLOCK
	CONSO	DTC,GR		;IS TAPE GOING FORWARD
	JRST	ISLOW
	SOSGE	RBNCNT		;ANOTHER REVERSAL
	JRST	RBNLOS		;TOO MANY!
	IORI	TAC,DT		;NO, ADD IN DELAY TO CHANGE DIRECTION
ISLOW:	CONO	DTC,SL+RB+EE(TAC)	;MAKE TAPE GO FORWARD
	JRST	DXIT

RBNLOS:	CONO	DC,0		;SHUT OFF DATA CONTROL
	CONO	PI,DCTOFF	;TELL PI ABOUT SHUTTING OFF DC.
	CONO	DTC,200000!JDE!TFE!DTR(TAC)	;TURN OFF.  INTERRUPT ON TIME FLAG.
	MOVEI	TAC,DTTRY	;MAKE SURE THAT WE
	MOVEM	TAC,UERRCN	;DON'T TRY AGAIN
	MOVEI	TAC,20		;ENABLE CONSZ TO SEE TIME FLAG INTERRUPT.
	IORM	TAC,DTCCON
	SETOM	ERRFLG		;MAKE SURE IT LOOKS LIKE AN ERROR!
	JRST	DXIT1
;WRITE REVBLK BLKXIT BNEXIT WRFORW FORBLK READ RDFORW DWRITE DEXIT DREAD

;HERE WHEN CORRECT BLOCK NUMBER IS FOUND.

WRITE:	CONO	DC,DCOUT		;SET DC FOR WRITING ON DC CHANNEL
	MOVE	TAC,DTUNIT		;DT UNIT+DT CHANNEL
	CONSO	DTC,GR			;GOING BACKWARD?
	JRST	WRFORW			;NO, WRITE FORWARD
	CONO	DTC,SL+WD+GR+JDE+EE(TAC)	;WRITE REVERSED
IFN FTXADR,<
	MOVE TAC,[XPCW WTRV]		;PLACE TO GO FOR EVERY WORD
>;IFN FTXADR
IFE FTXADR,<
	MOVE	TAC,[JSR WTRV]		;PLACE TO GO FOR EVERY WORD
>;IFE FTXADR
REVBLK:	MOVEM	TAC,@DCLOC		;STORE JSR FOR WORD INTERRUPT FOR REVERSE
	MOVE	TAC,UBUF		;ADDRESS OF BUFFER-1(SECOND WORD)
	ADDI	TAC,200-1		;LAST ADDRESS OF 200 WORD BUFFER
BLKXIT:	HRLI	TAC,-200		;WORD COUNT FOR 1 BLOCK
BNEXIT:	MOVEM	TAC,BLKPTR		;STORE BLKI OR BLKO POINTER
	JRST	DXIT1

WRFORW:	CONO	DTC,SL+WD+JDE+EE(TAC)	;WRITE FORWARD (JOB DONE ENABLED)
	MOVE	TAC,[BLKO DC,BLKPTR]	;BLKO POINTER FOR INTERRUPT LOCATION
FORBLK:	MOVEM	TAC,@DCLOC		;STORE BLKI/BLKO IN INTERRUPT LOC.
	MOVE	TAC,UBUF		;ADDRESS OF BUFFER
	JRST	BLKXIT			;STORE BLKI/O POINTER

READ:	MOVE	TAC,DTUNIT		;UNIT+UTC CHANNEL
	CONSO	DTC,GR			;GOING BACKWARD?
	JRST	RDFORW			;NO,READ FORWARD
	CONO	DTC,SL+GR+RD+JDE+EE(TAC)	;YES, READ BACKWARD(JOB DONE ENB.)
IFN FTXADR,<
	MOVE TAC,[XPCW RDRV]		;PLACE TO GO FOR EACH WORD
>;IFN FTXADR
IFE FTXADR,<
	MOVE	TAC,[JSR RDRV]		;PLACE TO GO FOR EACH WORD
>;IFE FTXADR
	JRST	REVBLK

RDFORW:	CONO	DTC,SL+RD+JDE+EE(TAC)	;READ FORWARD(JOB DONE ENABLED)
	MOVE	TAC,[BLKI DC,BLKPTR]	;BLKI POINTER
	JRST	FORBLK			;SET BLKPTR FOR FORWARD

DWRITE:	MOVE	TAC,DTUNIT		;UNIT+DT CHANNEL
	CONSZ	DTC,GR			;TAPE GOING IN REVERSE?
	JRST	BAKWRD			;YES, MAKE IT GO BACKWARD ONE MORE BLOCK
	CONO	DC,DCOUT		;SET DATA CONTROL TO WRITE ON DC CHANNEL
	CONO	DTC,SL+WD+JDE+EE(TAC)
	MOVE	TAC,[BLKO DC,BLKPTR]	;IO INSTR. FOR PI LOC
DEXIT:	MOVEM	TAC,@DCLOC		;STORE BLKI/BLKO IN EVEN DC CHANNEL LOC.
	EXCH	DDB,USVDB		;SET HUNG DEVICE COUNT TO 60 SECONDS
	MOVEI	TAC,=60			;SINCE DUMP MODE CAN TAKE A LONG TIME
	DPB	TAC,PDVCNT
	MOVE	TAC,RDBN
	MOVEM	TAC,DMPADV		;EXIT VIA JRST 12,@DMPADV or XJEN DMPADV
IFN FTXADR,<
	MOVE TAC,RDBN+1			;set up PC word in addition to flag word
	MOVEM TAC,DMPADV+1
>;IFN FTXADR
	MOVE	TAC,DMPFST(DDB)		;HERE'S HOW WE START THE DUMP COMMAND LIST
	MOVEM	TAC,DMPLST		;C(TAC)=C(DMPLST) AT DMPA1
	EXCH	DDB,USVDB
	JRST	DMPA1			;SIMULATE A PREVIOUS COMMAND FINISHING.

DREAD:	MOVE	TAC,DTUNIT		;UNIT + DT CHANNEL
	CONSZ	DTC,GR			;GOING BACKWARDS?
	JRST	BAKWRD			;YES, MAKE IT GO BACKWARD ONE MORE BLOCK.
	CONO	DTC,SL+RD+JDE+EE(TAC)	;NO, SET TO READ (JOB DONE ENABLED)
	MOVE	TAC,[BLKI DC,BLKPTR]
	JRST	DEXIT
;WTRV1 RDRV1 ENPT2

;(CALLED BY WTRV, RDRV, ENPT, ENPT1)
;HERE FOR REVERSE DIRECTION TRANSFERS FOR BUFFERED MODE, AND TO
;STOP TRANSFER WHEN BLKI/O POINTER RUNS OUT (BUFFERED MODE)

;IN ALLDAT:
;↑WTRV:		0
;		JRST WTRV1

↑WTRV1:	BLKO DC,BLKPTR	;WRITE 1 BLOCK IN REVERSE DIRECTION
IFN FTXADR,<
	XPCW ENPT1	;END OF BLOCK
>;IFN FTXADR
IFE FTXADR,<
	JSR ENPT1	;END OF BLOCK
>;IFE FTXADR
	SOS BLKPTR
	SOS BLKPTR
IFN FTXADR,<
	XJEN WTRV
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@WTRV
>;IFE FTXADR


;IN ALLDAT:
;↑RDRV:		0
;		JRST RDRV1

↑RDRV1:	BLKI DC,BLKPTR	;READ 1 BLOCK IN REVERSE DIRECTION
IFN FTXADR,<
	XPCW ENPT1	;END OF BLOCK.
>;IFN FTXADR
IFE FTXADR,<
	JSR ENPT1	;END OF BLOCK.
>;IFE FTXADR
	SOS BLKPTR
	SOS BLKPTR
IFN FTXADR,<
	XJEN RDRV
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@RDRV
>;IFE FTXADR

;IN ALLDAT:
;↑ENPT:		0
;IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
;IFN FTXADR,<
;		XPCW ENPT1
;>;IFN FTXADR
;IFE FTXADR,<
;		JSR ENPT1
;>;IFE FTXADR
;IFN FTXADR,<
;		XJEN ENPT
;>;IFN FTXADR
;IFE FTXADR,<
;		JRST 12,@ENPT
;>;IFE FTXADR
;
;↑ENPT1:	0
;		JRST ENPT2

;END OF BLKI OR BLKO BUFFERED IO OR END OF DUMP MODE COMMAND LIST
;IF WRITING, AFTER TRANSMITTING THE LAST WORD, THE DC WILL EVENTUALLY EMPTY,
;AND EITHER JOB DONE (AND MAYBE INCOMPLETE BLOCK) WILL COME ON.
↑ENPT2:	CONSZ DC,10000		;DATA MISSED?
	SETOM ERRFLG		;YES,SET FLAG
	CONSO DTC,400		;SKIP IF WRITING (LAST WORD STILL IN DC)
	CONO DC,0		;READING.  DESELECT DC - CAUSES JOB DONE
	CONO PI,DCTOFF		;TURN OFF DATA CONTROL CHANNEL
	JRST @ENPT1		;THIS DOES not DISMISS INTERRUPT!
;DMPA0 DMPA1 DMPA2 DMPA3

;DMPA0 (CALLED FROM DMPADV) - FINISH ONE DUMP MODE BLKI/O POINTER.
;IN ALLDAT:
;	↑DMPADV:	0
;			JRST	DMPA0

↑DMPA0:	MOVEM	TAC,DTTAC		;END OF BLKI/BLKO DUMP MODE
	AOS	TAC,DMPLST		;INCREMENT POINTER TO FREE STG COMMANDS
DMPA1:	SKIPN	TAC,(TAC)		;FETCH IOWD FROM FREE STG.
	JRST	DMPA3			;END OF THE LIST.  STOP EVERYTHING.

	ADDI	TAC,1			;FIRST CORE ADDRESS
	MOVEM	TAC,BLKPTR		;SAVE BLKI/O POINTER+1
	MOVEM	TAC1,DTTAC1		;SAVE ANOTHER AC
	LDB	TAC,[POINT 9,BLKPTR,26]	;AC2←PAGE NUMBER OF FIRST WORD
	MOVEI	TAC1,DTCEXP		;NUMBER OF FIRST EXEC PAGE FOR DTC
	DPB	TAC1,[POINT 9,BLKPTR,26];STORE EXEC PAGE NUMBER INSTEAD
	SOS	BLKPTR			;RE-CONVERT TO IOWD FORMAT
IFE FTMPP2,<
	ADD	TAC,UTCMAP		;POINTER TO USER'S PAGE MAP ENTRY
>;IFE FTMPP2
IFN FTMPP2,<
	ADDI TAC,DTUEXP⊗9
>;IFN FTMPP2
	MOVE	TAC1,(TAC)
	MOVEM	TAC1,EXPGT+DTCEXP	;MAKE EXEC MAP POINT TO USER'S PAGES
	MOVE	TAC1,1(TAC)
	MOVEM	TAC1,EXPGT+DTCEXP+1
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,DTCEXP⊗9		;CLEAR PAGE TABLE RAM FOR DTCEXP
>;IFKL10
	MOVE	TAC1,DTTAC1

DMPA2:	MOVE	TAC,DTTAC
IFN FTXADR,<
	XJEN DMPADV
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@DMPADV
>;IFE FTXADR

DMPA3:
IFN FTXADR,<
	XPCW ENPT1
>;IFN FTXADR
IFE FTXADR,<
	JSR	ENPT1
>;IFE FTXADR
	JRST	DMPA2
;DTCINT DCCONO CHKCNT UIN1 BN

;HERE ON INTERRUPTS ON DECTAPE CONTROL AFTER DATA TRANSMITTED

;
;DTCCON:	CONSZ	DTS,0		;DEC TAPE CONTROLLER?
;		JRST	DTCINT		;YES.

COMMENT $
While reading block numbers, we are enabled for End Zone interrupts
but not for Job Done.  Interrupts go to BN, which reverses the tape
if End Zone is seen, or calls DCCONO for any other errors.

If we get to RBNLOS, after failing to find the block after some number of
reversals, then the Time Flag and Job Done will be enabled, and RBNCNT will
be negative.  Interrupts will get to DCCONO with ERRFLG set.

While transmitting data, JDE and EE are set, Time Flag is not set.
Interrupts go to DCCONO.

In order to stop the tape, the DTC is CONOed deselect all units, with
JDE and TFE set.  DTCCON is enabled for only Time Flag interrupts.
DTCINT will transfer to UTIME to finish stopping the tape.

$

↑DTCINT:JSR	DTCSAV			;SAVE ACS.
	CONSO	DTC,JDE			;JOB DONE ENABLED? (ANY OP EXCEPT RD BN)
	JRST	BN			;WE ARE READING BLOCK NUMBERS
	CONSO	DTC,4000		;TIME FLAG ENABLED? (STOP, OR RBNLOS)
	JRST	DCCONO			;NO.
	SKIPL	RBNCNT			;HERE FROM RBNLOS?
	JRST	UTIME			;NOPE.  HERE FROM DTC1 TO STOP TAPE.
	SETZM	RBNCNT			;SO WE DON'T GO THIS WAY AGAIN
	MOVEI	TAC,20			;SHUT OFF BIT THAT RBNLOS SET
	ANDCAM	TAC,DTCCON		;SHUT OFF BIT
DCCONO:	CONO	DC,0			;TURN OFF DATA CONTROL
	MOVE	DDB,USVDB		;SETUP DDB ADDRESS
	LDB	J,PJOBN
	PUSHJ	P,MAPSET		;SETUP APR MAP
	MOVE	IOS,DEVIOS(DDB)		;IO STATUS
	CONSO	DTS,@CONSZ1		;ERRORS? (16 FOR DUMP, 116 FOR BUFFERED)
	SKIPE	ERRFLG			;OR DC DATA MISS?
	JRST	DTREDO			;YES, SOME KIND OF ERROR.  REDO OPERATION
	SETZM	EXPGT+DTCEXP		;FLUSH USER PAGES FROM EXEC MAP
	SETZM	EXPGT+DTCEXP+1
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,DTCEXP⊗9		;CLEAR PAGE TABLE RAM FOR DTCEXP
>;IFKL10
	TLZE	IOS,IOW			;NO ERROR. JOB IN IO WAIT?
	PUSHJ	P,SETIOD		;SET WAIT SATISFIED.  JOB WILL RUN AGAIN
	TLZN	IOS,URDIR		;DIRECTORY OPERATION?
	TLNE	IOS,UDMP		;OR DUMP MODE?
	JRST	DTC1			;YES, DUMP OP OR DIRECTORY OP.  STOP HERE.
	TLNN	IOS,IO			;OUTPUT OP?
	JRST	UIN1			;NO.
	PUSHJ 	P,ADVBFE		;IS NEXT OUTPUT BUFFER READY YET?
	JRST	DTC1			;NO READY BUFFER
	MOVEI	TAC,UOUTGO		;DISPATCH UNLESS QUANTUM EXHAUSTED.
CHKCNT:	SOSLE	BLKCNT			;QUANTUM RUN OUT?
	JRST	(TAC)			;NO. DISPATCH TO CONTINUE I/O
	SKIPN	DCREQ			;IS SOMEONE WAITING FOR DATA CONTROL?
	SKIPE	DTREQ			;OR DECTAPE CONTROL?
	JRST	DTC1			;YES. SOMEONE IS WAITING.  GO STOP TAPE.
	JRST	(TAC)

UIN1:	HRRZ	TAC,DEVIAD(DDB)		;INPUT OP.  GET BUFFER JUST READ INTO
	XCTR	XR,[HLRZ TAC1,1(TAC)]	;GET LINK TO NEXT BLOCK
	HRRM	TAC1,DTNEXT(DDB)	;STORE NEXT BLOCK TO READ
	JUMPN	TAC1,.+2		;WAS THIS LAST BLOCK
	TLO	IOS,IOEND		;YES.  SET END OF FILE.
	PUSHJ	P,ADVBFF		;ADVANCE INPUT BUFFER
	JRST	DTC1			;NO EMPTIED BUFFER AVAILABLE.  STOP TAPE.
	TLNE	IOS,IOEND		;WAS THIS LAST BLOCK?
	JRST	DTC1			;YES, STOP TAPE
	MOVEI	TAC,UINGO		;DISPATCH UNLESS QUANTUM EXHAUSTED.
	JRST	CHKCNT

BN:	CONSO	DTS,2			;END OF TAPE FLAG?
	JRST	DCCONO			;NO.  MUST BE AN ERROR.  STOP TAPE
	MOVE	TAC,DTUNIT		;MUST BE READING BLOCK NOS.
	CONSO	DTC,GR			;GOING BACKWARDS?
	IORI	TAC,GR			;NO, MAKE IT GO BACKWARDS.
	CONO	DTC,SL+RB+EE+DT(TAC)	;KEEP READING BLOCK NOS.
	CONO	DC,DCIN			;SET DC TO READ BLOCK NOS. AGAIN.
	POPJ	P,
;DTCHNG DTC1 DTC3 DTC2 UTIME

;HERE FOR HUNG TIMEOUT.
DTCHNG:	CONO	DC,0		;MAKE SURE THESE GET DONE.
	CONO	PI,DCTOFF

;STOP TAPE AND DESELECT THIS UNIT BEFORE GOING TO ANOTHER UNIT
DTC1:	SKIPE	AC1,DMPFST(DDB)
	PUSHJ	P,FSGIVE
	SETZM	DMPFST(DDB)
	CONSO	DTC,20000	;IS TAPE MOVING? I.E., AT INTERRUPT LEVEL?
	JRST	DTC2		;NO.
	SKIPG	TAC,BLKCNT	;RESTORE BLOCK COUNT
	MOVEI	TAC,BLKQNT
	HRLM	TAC,UFREE(DDB)
	MOVEI	TAC,DTCCHN	;DTC PI CHANNEL
	TLO	IOS,UREV	;REMEMBER DIRECTION, SET REVERSE BIT
	CONSO	DTC,GR		;TAPE GOING FORWARDS?
	TLZA	IOS,UREV	;YES, CLEAR REVERSE BIT
	TRO	TAC,GR		;NO, PRESERVE DIRECTION FOR STOP CONO
	MOVEI	TAC1,20		;ENABLE SOFTWARE FOR TIME FLAG ONLY
	HRRM	TAC1,DTCCON
	CONO	DTC,TFE+RDS+JDE(TAC)	;STOP TAPE. (TIME FLAG AND JDE) CALLS UTIME.
DTC3:	SOSL	DCREQ		;DECREMENT DATA CONTROL REQUEST COUNT
	SETOM	DCAVAL
	PUSHJ	P,CLRACT	;CLEAR DEVICE ACTIVE FLAG, STORE IOS
	LDB	J,PJOBN
	TLNN	DDB,SYSDEV	;SYSTEM TAPE?
	POPJ	P,		;NO
	HLRZ	TAC,JBTSTS(J)	;YES
	TRNN	TAC,CMWB	;DELAY ↑C?
	POPJ	P,		;NO
	JRST	RELEA9		;YES. RELEASE SYSTEM TAPE.

DTC2:	PUSHJ	P,DTC3		;FREE DC AND SYSTEM TAPE
	CONO	DC,0
	CONO	PI,DCTOFF
;ENTER UTIME ON TIME FLAG INTERRUPT AFTER STOPPING DEVICE.
UTIME:	SOSL	DTREQ		;REDUCE DECTAPE CONTROL REQUEST COUNT
	SETOM	DTAVAL		;SET AVAILABLE FLAG FOR SCHEDULER
	CONO	DTC,0		;CLEAR CONTROL(AND UTS)
	HLLZS	DTCCON		;CLEAR CONSO UTS, FLAGS
	POPJ	P,		;DISMISS INTERRUPT.
;DTREDO ERSTOP DIRERR DIRER1

COMMENT $

Here on each of 5 types of hardware detected errors.  Each operation
causing an error is tried DTTRY times.  A "fatal error" is an
operation which fails DTTRY times in a row.  For fatal errors, the
IOS word is set appropriately to indicate to the user that an error
has occurred.  A record of all errors (fatal and non-fatal) is kept
for all drives combined.  Also, a record of each fatal error is kept
for each drive and for all drives combined.

$

;THE ERROR COUNT IS SPLIT INTO 5 FIELDS TO MAKE A TOTAL OF 36 BITS:
;THE 5 TYPES IF ERRORS ARE:
;ERROR COUNT	      IOS BIT	;DESCRIPTION
ECDERR←←1	;(RH) IODERR	;DC DETECTS DATA MISSED(DEVICE ERROR)
ECDTER←←1000	;(RH) IODTER	;PARITY ERROR(UTS)(DATA ERROR)
ECBKTL←←1	;(LH) IOBKTL	;INCOMPLETE BLOCK(UTS)(BLOCK TOO LARGE)
ECIMPM←←100	;(LH) IOIMPM	;TWO UNITS DIALED THE SAME, OR MARK-TRACK ERROR.
				;(BOTH DETECTED WHILE READING BLOCK NUMBERS)
ECIMP1←←10000	;(LH) IOIMPM	;ATTEMPT TO WRITE ON WRITE-LOCKED TAPE

DTREDO:	SKIPE	TAC,ERRFLG		;CLEAR ERROR COUNT,DID DC MISS DATA?
	MOVEI	TAC,IODERR+ECDERR	;TAC←DEVICE ERROR, ERROR COUNT POSITION
	CONSZ	DTS,10			;NO, PARITY ERROR?
	TRO	TAC,IODTER+ECDTER	;YES, SET DATA ERROR FLAG+COUNT
	CONSZ	DTS,100			;NO, INCOMPLETE BLOCK?
	TDO	TAC,[ECBKTL,,IOBKTL]	;YES, SET BLOCK TOO LARGE+COUNT
	CONSO	DTS,4			;NO, ILLEGAL OPERATION?
	JRST	ERSTOP			;NO
	TRO	TAC,IOIMPM		;YES, FLAG AS IMPROPER MODE
	CONSO	DTC,JDE			;READING B.NOS. (JOB DONE NOT ENABLED)?
	TLOA	TAC,ECIMPM		;YES, 2 UNITS MUST BE DIALED THE SAME
	TLO	TAC,ECIMP1		;NO, MUST BE WRITE LOCKED
ERSTOP:	MOVE	TAC1,TAC		;INCREMENT ERROR COUNT
	TRZ	TAC1,IODERR+IODTER+IOBKTL+IOIMPM	;CLEAR OUT IOS ERROR BITS
	ADDM	TAC1,DTOTAL		;ADD TO TOTAL ERROR COUNT FOR ALL UNITS
	AOS	DAT,UERRCN		;INCREMENT ERROR COUNT
	CAIGE	DAT,DTTRY		;EQUAL TO DTTRY YET?
	JRST	FILLER			;NO, TRY AGAIN
	ADDM	TAC1,DFTOTAL		;ADD TO TOTAL FATAL ERROR COUNT
	ADDM	TAC1,DTERR(DDB)		;ADD TO FATAL COUNT FOR THIS UNIT
	TRZ	TAC,ECDERR+ECDTER	;CLEAR RH COUNT BITS
	TRNE	IOS,IOIMPM		;HAS USER BEEN TOLD ABOUT BAD OPERATION?
	TLZ	IOS,URDIR		;YES. CLEAR URDIR SO WILL RETURN TO USER
	TRO	IOS,(TAC)		;SET ERROR BITS IN IO STATUS WORD
	TLZE	IOS,IOW			;JOB IN IO WAIT?
	PUSHJ	P,SETIOD		;YES, START JOB UP AGAIN
	TLZN	IOS,URDIR		;DIRECTORY ERROR?
	JRST	DTC1			;NO. STOP TAPE. DON'T SET BUFFER USE BIT.
	PUSHJ	P,DTC1
DIRERR:	MOVSI	TAC,DVDIRIN		;CLEAR DIRECTORY IN CORE BIT
	ANDCAM	TAC,DEVMOD(DDB)
	HRLI	DDB,DIRER1		;CAN'T PRINT MSG ABOVE CLK LEVEL.
	SYSPIFF		;SO WE MAKE A CLK RQ TO PRINT MSG LATER
	IDPB	DDB,CLKQ
	SYSPIN
	LDB	J,PJOBN			;REQUIRED FOR ESTOP
	JRST	ESTOP			;STOP JOB.  PRINT MSG FROM CLK LEVEL

;HERE AT CLK LEVEL TO PRINT BAD DIRECTORY MESSAGE.
DIRER1:	MOVEI	DDB,(DAT)		;GET PARAMETER OUT OF THE CLK RQ.
	LDB	J,PJOBN			;LOAD JOB NUMBER INTO J.
	JRST	BADDIR			;PRINT BAD DIRECTORY.  STOP JOB (AGAIN)

BEND DTCSER

>;IFE FTF2	;Whole file
