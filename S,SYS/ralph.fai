COMMENT ⊗   VALID 00067 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00012 00002	RALLOC NEWUFD FL A B C D W X Y Z K L M N R S P REBCN DSK LPT FILE REBC PDLEN DAWPRV PROPRV REAPRV WRTPRV ACWPRV INFPRV WANTPR
C00016 00003	NPACK NUDPS SWPAKS NBPT NSWCYL WDRTVL WDRTV2 WDREC NPACK NUDPS SWPAKS NBPT NSWCYL WDRTVL WDRTV2 WDREC NUDPS NPACK SWPAKS NCYL NTPC TRKGRP SAT2RC NTPP TRACKS DWDTRK WDTRK TTMAX TTUDP UDPORG UDPORG TTUDP UFDN DDNAM DDEXT DDPRO DDPPN DDLOC DDLNG DREFTM DDMPTM DGRP1R DNXTGP DSATID DQINFO DOFFST DDRET
C00022 00004	CRLF CPOPJ2 CPOPJ1 CPOPJ OLDCYL OLDPAS TTRD TTRD1 TRRD TRRD1 CTRD CTRD0 CTRD1 CTWRT CTWRT0 CTWRT1 SATRD SATRD2 SATK2A TTWRT TTWRT1 TRWRT TRWRT1 CSAT CSAT1 FSAT SATSET SSAT1 STUSE STUSE1 UUOLST MONTAB
C00026 00005	LPAT PATCH PATCH1 PATCH2 PATCH3 PDLIST MTRACK UDPFLG DEFDEV MFDPTR UFDPTR DIOWD NFT SAVFF FILEON PHI1 SATTK2 LASTOP FSIZE TOTSIZ SATBYT SSATBT PPUFD SATFLG ALLNAM ALLUFD NOSTOP NRTCHK WDSTOP TTRK2 TTRACK TTRA0 RR BD SSAT LSTBLK SATID SATBIT NXTSAT XTRA TRACK2 SATTAB SATEND RTSAV UTSAV PH2CFG PH2SFG MAINTM JBTPRV LSTRD CTYTYO LPTFLG LPTBF THSPPN THSFIL THSEXT OUTEXT QMODE UFDADR UDPOK UDPONL THSLNG THSTRK NOPHS2 FSWPTK SWPRET QQQ XXX XXX QQQ XXX XXX QQQ XXX XXX QQQ XXX XXX SWPRXX THSDAX THSDAZ REBLDF REBNUM REBBUF REBCBF REBCHD GRP1R RPCNT UFDLEN
C00034 00006	UUUO USKIP UUORET UUUO1 UUOERR UUUO2 UUTBL UUTBLN READ.C REA.CL WRT.C WRT.CL READ.T READ.R READ.S WRT.T WRT.R C.SAT S.SAT F.ORCE T.PRIN R.PRIN RPRIN1 RPRN1A RPRN1B RPRN1C RPRN1D RPRIN2 RPRN2A RPRN2B RPRIN3 ADRCHK IVTADR UDPTAR ADRCK1 DISERR DISER2 ILLOPR UTT1 UTT1A LPTPUT UTT3 UTT3A LPTSTR LPTST1 ST.USE SPRED
C00049 00007	NOCORE NODISK GOEXIT
C00050 00008	BEGIN REOPEN CMD TTYGET TTYFLU TTYFL1 TTYFL2 CMTAB CMTABL CMD2 GUNAM DDTCALL DDTGO DDTGO1 CMD1 QM1 QM
C00055 00009	AP1MES REBILD PHASE1 REBIL1 PHSI1A PHSI1B PHSI1C PH1LOP PHLP1 PHSTAB PHSTL PHSQ PHSG PHSW PHSU PHSF PHSL NOLPT
C00059 00010	PHLP2 PH1.1 PH1.1A PH1.2 PH1.3 PH1.4 EMMFD EMUFD PH1.5 BITCNT BTCT1
C00065 00011	PHASE2 PH2.1 PH2.1A PH2.1B PH2TAB PH2TL PH2C.C PH2C.S PH2.1C PH2.2 PH2.2A PH2.2B PH2.3 PH2.4 PH2.4A SPAUSE GPAUSE QDDT CPAUSE
C00070 00012	FREAD FRD0 FREAD0 FREAD1 FREAD2 FRD2A FREAD3 FREAD7 FRD7A FRD7B SIZCHK FREAD6
C00077 00013	RTRD RTRDU1 RTRDNU RTRD1 RTRD2 RTRD3 RTRD7 SEEK FIND RTRD7A RTRDUE TRACK RTRD6 RTRD8 EXAM1 EXAM13 EXAM99 EXAM12 EXAM11 EXAM2
C00084 00014	DREAD DREAD0 DREAD1 DREAD2
C00086 00015	MBYTE MBYTE1 SBYTE1 SBYTE
C00088 00016	REGSAV REGUSV SIXOUT SIXOT1 SIXOT2 TYFIL TYPPN TYPPN1 DECOUT OCTOUT OCTOU2 OCTHWT ALLRAD ALLRD1 ALLRD2 TTIME TTIME1 TDATE TDATE1
C00093 00017	UHELP UH1 UH2 UH3 UNOMFD UH4 UH5 UH6 UHFILE UH7 UH8 UH9 UH8A UH8B UH8C UH10 UH10A UALLFL UALLF1 UALLF2 ALLSER ALSR1 ALSR2 SATCHK ALSR4 ALSR3 RECOV RECOV1 RECOV2 RECOV3 RECOVX FIXUFD UFDENT
C00107 00018	GPPN ILLPPN GPPN1 GETSIX GETSX1 GETSX2 GETSX3 GETFIL GETFL1 GETFL2 GETFL0 RJUST GO.ON YORN
C00111 00019	HACK: SEARCH PACK 5 AND COPY FILES TO 4-PACKS. 17 FEB 1973
C00114 00020	OLDIOP OLDSRC OLDOOP OLDDST SRCPAK DSTPAK SRCTRK DSTTRK PACK12 PACK13 PACKST PACK24 ENTLUZ NOOPEN PACKCF PACKCE PACKGO PACKG3 PACKG2 PACKCL PACKUP PACKU1 PACKU1 PACKC1 PACKCA PK1V PK1V1 PACKC2 PACKCB PK2V PK2V1 PACKUP PACKU1 PKMES
C00130 00021		PACK-TO-PACK COPY FOR UNIFORM COMPOSITION SYSTEM.  C1PACK
C00132 00022		RETFIX:	CLEAR OLD RETRIEVAL DATA.
C00133 00023		DETEST	DATA TESTING OF ONE TRACK
C00136 00024	HDTEST	WHDTST
C00139 00025	PHDTST:	PACK TESTING - WRITES!
C00141 00026	HERE WE MAKE A PASS THROUGH THE DISK AND REINITIALIZE EVERYONE'S REFTIME
C00143 00027		DOUBLE DENSITY CONVERSION  6/27/74	CDBL:
C00145 00028		GRIMM
C00149 00029	QUAM	COPY SYS PACK TO QUAM PACK
C00150 00030	DATE75  PASS THROUGH THE DISK TO CLEAR THE HIGH DATE OF ALL FILES
C00151 00031		RETRY TESTING
C00153 00032		SHAKE	VIBRATION TESTING
C00155 00033		STEST	SURFACE TESTING OF ENTIRE DISK (FILE SYSTEM)
C00157 00034		ATEST	PRE-ACCEPTANCE TESTING OF THE DISK
C00161 00035		handle the head/pack retry counts
C00165 00036		SUBTTL	CPYALL
C00172 00037	MORE CPYALL
C00176 00038	MORE CPYALL
C00183 00039	SWPSYS  WRITE THE FILE [SWAP].SYS[1,4] ON THE FILE SYSTEM
C00191 00040	C1MAKE  MAKE A SMALL FILE SYSTEM FOR C1 USE
C00206 00041	AMPEX DISK TESTING UNDER TIMESHARING.
C00209 00042	ANOTHER DISK TEST PROCEDURE
C00210 00043	SYSTST  - A TEST OF THE SYSTEM, NOT OF THE DISK, WRITES TRACK 0 OF UDP1
C00211 00044	RECOVER  SEARCH ENTIRE DISK TO REPAIR DAMAGED DIRECTORIES
C00213 00045	UFDSRC		GET ALL UFD NAMES INTO CORE
C00214 00046	RECOVER  SEARCH ENTIRE DISK TO REPAIR DAMAGED DIRECTORIES
C00218 00047	GPC - GENERAL PACK COPY.
C00223 00048		SUBTTL	UFDFIX	- EXTEND THE MFD AND ALL UFDS FOR 16 WORDS/ENTRY.
C00233 00049		SUBTTL	REFIX
C00237 00050		SUBTTL REBLD2 -- PHASE 2 OF REBUILD
C00242 00051	SPREAD	SPREAD RETRIEVAL
C00244 00052	BYTE1 BYTEN BYTER8 BYTERL BYTEL8 BYTELL
C00246 00053		SUBTTL SCOUT	LOOK AROUND A PARTICULAR AREA FOR A FILE
C00248 00054	F2OPEN F2LOGI F2NOTA F2TEST F2TSTL
C00251 00055	DEADP recons RECON1 REC.1 REC.2 REC.3 REC.4 EMUFD REC.5 RCBITC RBTCT1
C00259 00056	RFRED RFRD0 RFRED0 RFRED1 RFRED2 RFRD2A RFRED3 RFRED7 RFRD7Y RFRD7X RFRD7A RFRD7B RFRED6
C00269 00057	RRCHECK.RETRIEVAL RRTD RRTD1 RRTD2 RRTD3 RRTD7 RRTD7Y RRTD7B RRTD7A RRTD7X RRTD7C RRTD6
C00278 00058	UFD.Scan RECUFD RECUF1 RECUF2 RECUF3 RECUF4 RECUF5 RCUFE1 RCUFE2
C00282 00059	File.RTVL.Spread FRSPRD FRSPR1 FRSPR2 FRSPR3 FRSPR4 FRSPR6 FRSPR5 FRSPE2
C00286 00060	Group.RTVL.Spread GRSPRD GRSPR1 GRSPR3 GRSPR4 GRSPR5 GRSPR6 GRSPR7 GRSPE2
C00293 00061	File.rtvl.extend NOTE FREXTD FREXT1 FREXT2 FREXT3 NEWGRP FREXT4 FREXT5 FREXT8 FREXT6 FREXT9 GSPRED GSPRD1 FREXTE FRXGET FRXGT1 FRXGT0 FRXGT3 FRXGT4
C00304 00062	Group.RTVL.Verify GRVERF GRVER1 GRVER3 GRVER4 GRVER5 GRVER6 GRVER7 GRVER8 GRVRE1 NGDDL IGDDLC IDETGP GDDLOC DETGRP
C00312 00063	UFD.rebuild UFDRBL UFDRB1 UFDRB2 UFDRX1 UFDRX2 UFDRB3 UFDRB4 UFDRB5 UFDRB7 UFDRB6 UFDRB8 UFDEXR UFDRB9 UFDEXT UFDEX2 UFDEX3 FRZGET FRZGT3 UFDRE1 UFDRE2 FNDHOL FNDHO1 FNDHE1 FNDHOE UFDSHL UFSHL1 UFSHL3 UFSHL4 UFSHL2 UFSHL6 UFLSTL UFSHLC UFDEAD
C00330 00064	Undo.rtvl.extend     UNRETR UNRET1 UNRET2 UNRET8 UNRET3 UNRET4
C00335 00065	Catalog.Dead.Files CCDEF CCLNK CCNAM CCEXT CCPRO CCPPN CCLNG CCREF CCDMP CCJOB CCAUT CCLEN CATGUT CATEND COMPXX DEDCAT DEDCT1 DEDCT2 DEDCT3 DEDCT4 DEDCT5 CATWRT CATWR1 CATPNT PDMPNV PDMINV PDMPTM DECBFL DECBF1 DECBF2 LITSRT LITSR1 LITSR2 LITSR3 LITSR4 NAMCMP TAPCMP LADJ NOENT
C00356 00066	List.UNFIXED.Files CATGON CATOK UNFIXF UNFIX1 UFXFL UFXFL1 UNFIX2 UNFIX3 ADDOK FNDOK FNDFL2 FNDGON FNDFL1 FIXPNT
C00363 00067	NPCHK CHKALL CHKL1 CHKL2 CHKL3 CHKLU2 CHKLUZ GENDAT GENLUP CHKCHK CHKIT
C00375 ENDMK
C⊗;
;RALLOC NEWUFD FL A B C D W X Y Z K L M N R S P REBCN DSK LPT FILE REBC PDLEN DAWPRV PROPRV REAPRV WRTPRV ACWPRV INFPRV WANTPR
	TITLE RALPH DISK AUDITOR AND HELPER
	SUBTTL	R. E. GORIN. 20 JAN 72.

FTF2←←0		;NON-ZERO MEANS SET UP F2 DISK SIZE PARAMETERS
FTLLL←←0	;NON-ZERO FOR LLL (ZERO FOR CCRMA) IF FTF2 IS ON
RALLOC←←0	;ASSEMBLY SWITCH FOR CPYALL CODE
NEWUFD←←0	;NEW UFD FORMAT, CHECK UFD ENTRY IN AUDIT
FT1PAK←←0	;NON-ZERO MEANS WANT TO CONFIGURE FOR ONLY ONE SYSTEM PACK
FTRP07←←0	;Non-zero for RP07 file system parameters.

IFN FTF2,<
PRINTS /*** You are assembling F2 RALPH, whether you like it or not! ***
/
>;IFN FTF2
IFN FTLLL,<
PRINTS /
*** This is the LLL version ***
/
>;IFN FTLLL

IFN FTRP07,<
PRINTS /*** This is the RP07 version ***
/
>;IFN FTRP07

;	ACCUMULATORS

↓FL←0
↓A←1
↓B←2
↓C←3
↓D←4
↓W←5
↓X←6
↓Y←7
↓Z←10
↓K←11
↓L←12
↓M←13
↓N←14
↓R←15
↓S←16
↓P←17

;	IO CHANNELS

REBCN←←6

DSK←←1
LPT←←2
FILE←←3
OLDI←←4		;OLD MODE UDP input
OLDO←←5		;OLD MODE UDP output
REBC←←6		;REBUILD CHANNEL
;CHANNELS THROUGH REBC+REBCN-1 IN USE FOR REBUILD

;	OPDEFS

DEFINE NAMES (QQ0,QQ1) <
QQ0
I	TREAD,1		;READ A TRACK
I	RREAD,2		;READ RETRIEVAL ONLY
I	SREAD,3		;READ SAT TABLE FROM SYSTEM
I	TWRITE,4	;WRITE TRACK FROM TTRACK
I	RWRITE,5	;WRITE RETRIEVAL FROM TTRACK
I	CLRSAT,6	;CLEAR ONE SAT BIT
I	SETSAT,7	;SET A SAT BIT
I	FORCE,10	;FORCE THE SYSTEM TO WRITE THE SAT TABLE
I	TPRINT,11	;TYPE A LIST OF UUO'S 
I	RPRINT,12	;TYPE RETRIEVAL FROM ADRESS NAMED
I	PUTSTR,13	;SAME AS OUTSTR, XCPT TO PRINTER TOO
I	PUTCHR,14	;SAME AS OUTCHR, XCPT TO LPT TOO
I	SETUSE,15	;SET DSKUSE (IN SYSTEM) TO E.A.
I	CREAD,16	;READ A CYLINDER
I	CWRITE,17	;WRITE A CYLINDER
QQ1
>

DEFINE I (A,B)<
OPDEF A	[BYTE (9) B]>

	NAMES			;MAKES THE OPDEFS HAPPEN


PDLEN←←200			;PUSH DOWN STORE CAPACITY (RECURSIVE UUO CALLS)
DAWPRV←←200000			;NEED PRIVILEGE FOR AUDITING
PROPRV←←100000
REAPRV←←40000
WRTPRV←←20000
ACWPRV←←40
INFPRV←←20

WANTPR←←REAPRV!WRTPRV!PROPRV!INFPRV!DAWPRV!ACWPRV	;MOST EVERYTHING

EXTERN JOBREL,JOBFF,JOBDDT,JOBOPC

	LOC 41
	PUSHJ P,UUUO		;UUO TRAP
	RELOC 0			;RELOCATE

DEFINE	CALL	<.FATAL	Did you want PUSHJ or CALLI?>	;Which?
;NPACK NUDPS SWPAKS NBPT NSWCYL WDRTVL WDRTV2 WDREC NPACK NUDPS SWPAKS NBPT NSWCYL WDRTVL WDRTV2 WDREC NUDPS NPACK SWPAKS NCYL NTPC TRKGRP SAT2RC NTPP TRACKS DWDTRK WDTRK TTMAX TTUDP UDPORG UDPORG TTUDP UFDN DDNAM DDEXT DDPRO DDPPN DDLOC DDLNG DREFTM DDMPTM DGRP1R DNXTGP DSATID DQINFO DOFFST DDRET
	SUBTTL	DISK PARAMETERS

IFE FTF2,<

NPACK←←6		;NUMBER OF PACKS IN FILE SYSTEM
NUDPS←←2		;NUMBER OF UDPS, SOME CODE STILL ASSUMES EXACTLY 2 UDPS
SWPAKS←←4		;NUMBER OF PACKS WITH SWAPPING AREAS ASSIGNED
NBPT←←=18		;NUMBER OF 128 WORD RECORDS/TRACK
NSWCYL←←=18		;NUMBER OF SWAPPING CYLINDERS (ABOUT 6156 PAGES)

↓WDRTVL←←40		;NUMBER OF WORDS IN RECORD ZERO (RETRIEVAL)
WDRTV2←←40		;NUMBER OF WORDS OF RETRIEVAL TO CHECK FOR GOOD RETRIEVAL
WDREC←←200		;NUMBER OF WORDS IN A DATA RECORD
>;IFE FTF2

IFN FTF2,<

IFE FTLLL,<
NPACK←←1		;NUMBER OF PACKS IN FILE SYSTEM
NUDPS←←1		;NUMBER OF UDPS, SOME CODE STILL ASSUMES EXACTLY 2 UDPS
SWPAKS←←1		;NUMBER OF PACKS WITH SWAPPING AREAS ASSIGNED
>;IFE FTLLL
IFN FTLLL,<
NPACK←←2		;NUMBER OF PACKS IN FILE SYSTEM
NUDPS←←0		;NUMBER OF UDPS, SOME CODE STILL ASSUMES EXACTLY 2 UDPS
SWPAKS←←2		;NUMBER OF PACKS WITH SWAPPING AREAS ASSIGNED
>;IFN FTLLL
NBPT←←=31		;NUMBER OF 128 WORD RECORDS/TRACK
NSWCYL←←=34		;NUMBER OF SWAPPING CYLINDERS (ABOUT 5000 PAGES)

↓WDRTVL←←200		;NUMBER OF WORDS IN RECORD ZERO (RETRIEVAL)
WDRTV2←←40		;NUMBER OF WORDS OF RETRIEVAL TO CHECK FOR GOOD DATA
WDREC←←200		;NUMBER OF WORDS IN A DATA RECORD
>;IFN FTF2

IFN FT1PAK,<
;This feature is for compiling version of ralph that works with special system
;living on a UDP (WAITS0 UDP).
NUDPS←←NPACK+NUDPS-1	;MAKE ALL BUT ONE PACK BE UDPS
NPACK←←1		;AND MAKE ONE SYSTEM PACK
SWPAKS←←1		;AND ONLY ONE SWAPPING PACK
>;IFN FT1PAK

IFE RALLOC,<
DEFINE CONFIG(SYSPAK,USRPAK)<
PRINTS/ Configured for: SYSPAK * 815 system packs;  USRPAK * 815 UDPs.
/
>;DEFINE
CONFIG(\NPACK,\NUDPS)	;Type out pack configuration at assembly time
>;IFE RALLOC

NCYL←←=815		;NUMBER OF CYLINDERS/PACK
NTPC←←=19		;NUMBER OF TRACKS/CYLINDER
↓TRKGRP←←40		;NUMBER OF TRACKS PER GROUP
SAT2RC←←7		;REST OF SAT BIT TABLE BEGINS AT REC 7 ON SECOND TK

NTPP←←NCYL*NTPC		;NUMBER OF TRACKS/PACK
TRACKS←←NPACK*NTPP	;NUMBER OF TRACKS IN FILE SYSTEM
DWDTRK←←NBPT*WDREC	;NUMBER OF DATA WORDS IN A TRACK
WDTRK←←DWDTRK+WDRTVL	;NUMBER OF WORDS/TRACK INCLUDING RETRIEVAL

TTMAX←←TRACKS-1		;MAXIMUM TRACK NUMBER. (COUNT FROM 0)
TTUDP←←TTMAX+NTPP*NUDPS	;MAX TRACK ADDRESS IN UDP

IFE RALLOC,<
UDPORG←←<NPACK+1>*NTPP	;ABSOLUTE ADDRESS OF UDP2 TRACK 0
>;IFE RALLOC

IFN RALLOC,<
PRINTX CONFIGURED FOR  3*800 SYSTEM, 1*800 UDP1, 3*815 UDP2,3,4
UDPORG←←TTUDP+1		;ORIGIN FOR UDP2
TTUDP←←TTUDP+3*=815*=19
>;IFN RALLOC

UFDN←←20			;NUMBER OF WORDS IN A DIRECTORY ENTRY

;RETRIEVAL PARAMETERS
DDNAM←←0			;NAME
DDEXT←←1			;EXT,,HIDATE-1 DATE-2
DDPRO←←2			;PRO,MODE,TIME,LODATE-1
DDPPN←←3			;PPN
DDLOC←←4			;NUMBER OF THE FIRST TRACK OF THIS FILE
DDLNG←←5			;POSITIVE LENGTH OF THIS FILE, IN WORDS.
DREFTM←←6			;REFERENCE DATE
DDMPTM←←7			;DUMP DATE, TAPE NUMBER, ETC.
DGRP1R←←10			;RECORD NUMBER OF THE FIRST RECORD OF THIS GROUP
DNXTGP←←11			;BLOCK NUMBER OF FIRST TRACK OF NEXT GROUP
DSATID←←12			;THIS WORD SHOULD CONTAIN THE SATID
DQINFO←←13			;LOC RESERVED FOR INFO.SYS
DOFFST←←17			;OFFSET
DDRET←←20
;CRLF CPOPJ2 CPOPJ1 CPOPJ OLDCYL OLDPAS TTRD TTRD1 TRRD TRRD1 CTRD CTRD0 CTRD1 CTWRT CTWRT0 CTWRT1 SATRD SATRD2 SATK2A TTWRT TTWRT1 TRWRT TRWRT1 CSAT CSAT1 FSAT SATSET SSAT1 STUSE STUSE1 UUOLST MONTAB
	SUBTTL	CONSTANTS AND SPECIAL STUFF
CRLF:	BYTE(7) 15,12		;ASCII CRLF
CPOPJ2:	AOS (P)
CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,

OLDCYL:	-<WDTRK*NTPC>,,TTRACK-1	;IOWD for old mode udp pack copy code
	0			;disk address goes here

OLDPAS:	0			;Password normally goes here
	0			;Error code returned here

TTRD:	'GODMOD'		;GODMODE TRACK READ
	1			;1 FOR READ
	IOWD WDTRK,TTRACK	;READ A WHOLE TRACK
TTRD1:	0			;RECORD NUMBER,,TRACK NUMBER

TRRD:	'GODMOD'		;READ RETRIEVAL ONLY INTO TTRACK
	1
	IOWD WDRTVL,TTRACK
TRRD1:	0			;0,,TRACK NUMBER 

CTRD:	'GODMOD'		;GODMODE TRACK READ, FOR CYLINDER READ
	1			;1 FOR READ
CTRD0:	IOWD WDTRK,TTRACK	;READ A WHOLE TRACK
CTRD1:	0			;RECORD NUMBER,,TRACK NUMBER

CTWRT:	'GODMOD'		;GODMOD WRITE OF 1 TRACK, FOR CYLINDER WRITE
	2
CTWRT0:	IOWD WDTRK,TTRACK	;WRITE TRACK FROM OUR CORE
CTWRT1:	0			;0,,TRACK NUMBER

SATRD:	'GODMOD'		;READ SAT TABLE INTO SSAT
	1			;READ SAT TABLE
	IOWD WDTRK,SSAT	;ADDRESS OF OUR COPY OF SYSTEM SAT TABLE
	0			;FROM TRACK ZERO

SATRD2:	'GODMOD'		;READ SAT TABLE INTO SSAT (2ND TRACK)
	1			;READ SAT TABLE
	IOWD XTRA,TRACK2	;ADDRESS OF SECOND TRACK'S WORTH OF DATA
SATK2A:	SAT2RC,,0		;SET FROM FIRST READ

TTWRT:	'GODMOD'		;GODMOD WRITE OF 1 TRACK
	2
	IOWD WDTRK,TTRACK	;WRITE TRACK FROM OUR CORE
TTWRT1:	0			;0,,TRACK NUMBER

TRWRT:	'GODMOD'		;WRITE RETRIEVAL ONLY FROM OUR
	2
	IOWD WDRTVL,TTRACK	;CORE
TRWRT1:	0			;0,,TRACK ADDRESS

CSAT:	'GODMOD'		;CLEAR A SAT BIT
	4
CSAT1:	0			;TRACK NUMBER

FSAT:	'GODMOD'		;FORCE SYSTEM TO WRITE SAT TABLE
	7

SATSET:	'GODMOD'		;SET A SAT BIT
	3
SSAT1:	0			;TRACK NUMBER HERE

STUSE:	'GODMOD'
	6			;WRITE
	IOWD 1,STUSE1		;IOWD OF TRANSFER
	0			;RELATIVE ADDRESS ZERO

STUSE1:	0

;GENERATE THE ASCIZ TEXT FOR THE UUO NAMES.
UUOLST:	NAMES(<ASCIZ $ >,<$>)

MONTAB:	ASCII /Jan-/
	ASCII /Feb-/
	ASCII /Mar-/
	ASCII /Apr-/
	ASCII /May-/
	ASCII /Jun-/
	ASCII /Jul-/
	ASCII /Aug-/
	ASCII /Sep-/
	ASCII /Oct-/
	ASCII /Nov-/
	ASCII /Dec-/
;LPAT PATCH PATCH1 PATCH2 PATCH3 PDLIST MTRACK UDPFLG DEFDEV MFDPTR UFDPTR DIOWD NFT SAVFF FILEON PHI1 SATTK2 LASTOP FSIZE TOTSIZ SATBYT SSATBT PPUFD SATFLG ALLNAM ALLUFD NOSTOP NRTCHK WDSTOP TTRK2 TTRACK TTRA0 RR BD SSAT LSTBLK SATID SATBIT NXTSAT XTRA TRACK2 SATTAB SATEND RTSAV UTSAV PH2CFG PH2SFG MAINTM JBTPRV LSTRD CTYTYO LPTFLG LPTBF THSPPN THSFIL THSEXT OUTEXT QMODE UFDADR UDPOK UDPONL THSLNG THSTRK NOPHS2 FSWPTK SWPRET QQQ XXX XXX QQQ XXX XXX QQQ XXX XXX QQQ XXX XXX SWPRXX THSDAX THSDAZ REBLDF REBNUM REBBUF REBCBF REBCHD GRP1R RPCNT UFDLEN
	SUBTTL	STORAGE AREAS
LPAT←←40
PATCH:	BLOCK LPAT
PATCH1:	BLOCK LPAT
PATCH2:	BLOCK LPAT
PATCH3:	BLOCK LPAT
PDLIST:	BLOCK PDLEN
MTRACK:	0			;NUMBER OF TRACKS (IN FILE SYS OR IN A UDP)
UDPFLG:	0			;SET TO -1 WHEN USING UDP1
DEFDEV:	'DSK   '		;DEFAULT DEVICE FOR OPENS
MFDPTR:	0			;POINTER TO MFD IMAGE IN CORE
UFDPTR:	0			;POINTER TO UFD IMAGE IN CORE
DIOWD:	0			;SAVE IOWD FROM FREAD
NFT:	0			;SAVE TRACK NUMBER FROM FREAD
SAVFF:	0			;SAVE JOBFF FOR READING UFDS
FILEON:	0			;SET 0 FOR RETRIEVAL CHECK,
				; ≠ 0 FOR READING THE WHOLE FILE
PHI1:	0			;SET ≠ 0 TO MAKE SAT TABLE MARKING HAPPEN
SATTK2:	0			;SECOND TRACK OF SAT
LASTOP:	0			;DISK ADDRESS OF LAST OPERATION
FSIZE:	0			;TRACK SIZE OF LAST FILE READ
TOTSIZ:	0			;TOTAL SIZE OF FILES IN FILE SYSTEM
SATBYT:	0			;PLACE TO STICK BYTE POINTER TO SATTAB
SSATBT:	0			;BYTE POINTER TO SATBIT!
PPUFD:	0			;NAME OF CURRENT UFD
SATFLG:	0			;SET IF BLOCK IN SAT MARKED 2 TIMES
ALLNAM:	0			;TYPE ALL NAMES IN PHASE1
ALLUFD:	0			;TYPE ALL UFD NAMES
NOSTOP:	0			;IF THIS IS SET, DON'T STOP FOR ERRORS (PHASE1)
NRTCHK:	0			;≠0 TO SUPPRESS REDUNDANT DISK OPS TO CHECK
WDSTOP:	0			;≠0 FOR WARNINGS ABOUT TRACK CAP > WD COUNT
				;FOR CONSISTIENT RETRIEVAL IN A GROUP

TTRK2:	BLOCK WDTRK		;SECOND TRACK BUFFER FOR COMPARISONS

TTRACK:	BLOCK WDTRK*NTPC	;AREA FOR READING FILES, A WHOLE CYLINDER'S WORTH
RADIX 5+5	;For decimal number in track addresses, e.g., TTRA18, TT9.
FOR @' I←0,NTPC-1<
TTRA'I←TTRACK+<I*WDTRK>		;ADDRESS OF RETRIEVAL OF THIS TRACK OF CYLINDER
TT'I←TTRA'I+WDRTVL		;ADDRESS OF DATA AREA OF THIS TRACK OF CYLINDER
>;FOR
RADIX 4+4	;Back to normal octal
;TT0←TTRACK+WDRTVL		;FIRST DATA IN FILE
TTRA0←←TTRA0			;MAKE DDT TYPE OUT TTRACK INSTEAD OF TTRA0
RR←←TTRACK			;ALTERNATE NAME FOR TTRACK
BD←←TT0				;BEGINING OF DATA

SSAT:	DSKUSE:	0		;PLACE TO SAVE SYSTEM'S COPY OF SAT 
LSTBLK:	0			;LAST BLOCK NUMBER ASSIGNED
SATID:	0			;SAT ID
	BLOCK WDTRK-3		;MORE SPACE  (NOTE THIS SPACE USED BY WTEST!)
SATBIT←SSAT+71			;BEGINNING OF SYSTEM'S BIT TABLE
NXTSAT←SSAT+62			;ADDRESS OF 2ND SAT TRACK

XTRA←<1+TRACKS/44>-<.-SATBIT>	;NUMBER OF WORDS OF SAT BITS NOT INCLUDED IN WDTRK
TRACK2:
IFG XTRA,<	BLOCK XTRA >	;NEEDED ONLY IF SIX OR MORE FILE PACKS

	BLOCK 3			;MAKE SURE ENOUGH ROOM FOR WTEST

SATTAB:	BLOCK 1+TRACKS/44	;ALLOW ONE BIT PER TRACK FOR
				;THE SAT TABLE
SATEND==.-1			;LAST LOC IN SAT TABLE
RTSAV:	BLOCK WDRTVL		;PLACE TO SAVE RETRIEVAL
UTSAV:	BLOCK WDRTVL		;Another PLACE TO SAVE RETRIEVAL
PH2CFG:	0
PH2SFG:	0
MAINTM:	0			;COPY SYSTEM CELL TO HERE.
JBTPRV:	0			;SAVE USER'S PRIVS HERE
LSTRD:	0				;ADDRESS OF LAST READ OP
CTYTYO:	0			;SET TO DIRECT OUTSTR UUO TO CTY.
LPTFLG:	0			;SET IF USING LPT
LPTBF:	BLOCK 3			;OUTPUT BUFFER FOR LPT
THSPPN:	0
THSFIL:	0
THSEXT:	0
OUTEXT:	0			;OUTPUT EXTENSION DURING RECOVERY
QMODE:	0
UFDADR:	0
UDPOK:	0			;SET TO -1 TO READ UDP WITHOUT SQUAWK
UDPONL:	0			;SET TO -1 TO ALLOW ONLY ACCESS OF UDPS
THSLNG:	0			;LENGTH OF CURRENT RECOVERING FILE
THSTRK:	0			;TRACK INDEX IN GROUP WHILE RECOVERING.

NOPHS2:	0

FSWPTK←←16612			;FIRST SWAPPING TRACK (COMPUTED SO THAT IF A
				;BAND NSWCYL CYLINDERS LONG BEGINS HERE, IT WILL
				;BE CENTERED ON THE PACK)
SWPRET:
QQQ←←0
XXX←←FSWPTK-5000		;(-5000 BECAUSE GORIN CHANGED A 166 INTO A 116!!)
REPEAT NSWCYL*NTPC,<
XXX
XXX←←XXX+1
>
IFG SWPAKS-1,<
QQQ←←QQQ+1
XXX←←FSWPTK+NTPP*QQQ
REPEAT NSWCYL*NTPC,<
XXX
XXX←←XXX+1
>
IFE FTF2,<
QQQ←←QQQ+1
XXX←←FSWPTK+NTPP*QQQ
REPEAT NSWCYL*NTPC,<
XXX
XXX←←XXX+1
>
QQQ←←QQQ+1
XXX←←FSWPTK+NTPP*QQQ-5000	;(-5000, ANOTHER GORIN SCREWUP!!)
REPEAT NSWCYL*NTPC,<
XXX
XXX←←XXX+1
>
>;IFE FTF2
>;IFG SWPAKS-1
SWPRXX←←.-SWPRET
IFN QQQ+1-SWPAKS,<.FATAL SWPRET TABLE NOT SETUP FOR SWPAKS PACKS>

THSDAX:	0
THSDAZ:	0

REBLDF:	0			;-1 FOR REBUILD PREPASS VERSION OF AUDIT
REBNUM←←100
REBBUF:	BLOCK REBNUM+1
REBCBF:	BLOCK 2*203*REBCN
REBCHD:	BLOCK 3*REBCN

GRP1R:	0		;cell to count DGRP1R
RPCNT:	0		;Cell used to suppress superfluous RPRINTs in FRSPRD
UFDLEN:	0		;Hold UFD length while reconstructing
;UUUO USKIP UUORET UUUO1 UUOERR UUUO2 UUTBL UUTBLN READ.C REA.CL WRT.C WRT.CL READ.T READ.R READ.S WRT.T WRT.R C.SAT S.SAT F.ORCE T.PRIN R.PRIN RPRIN1 RPRN1A RPRN1B RPRN1C RPRN1D RPRIN2 RPRN2A RPRN2B RPRIN3 ADRCHK IVTADR UDPTAR ADRCK1 DISERR DISER2 ILLOPR UTT1 UTT1A LPTPUT UTT3 UTT3A LPTSTR LPTST1 ST.USE SPRED

	SUBTTL	UUO HANDLER
UUUO:	MOVEM	16,17(P)	;PUSHJ 17, TO HERE. SAVE 16 ON THE STACK
	MOVEI	16,1(P)		;SOURCE,,DESTINATION IN 16
	BLT	16,16(P)	;STUFF ALL THE AC'S ON THE STACK
	ADD	P,[XWD 17,17]	;ADJUST THE STACK!
	JRST	UUUO1		;THINK ABOUT THE UUO

USKIP:	AOS	-17(P)		;MAKE A SKIP RETURN HAPPEN
UUORET:	SUB	P,[XWD 17,17]	;RESET THE STACK
	MOVSI	16,1(P)		;SOURCE,,DESTINATION IN 16
	BLT	16,16		;RESTORE ALL AC'S
	POPJ	P,		;RETURN

UUUO1:	LDB	A,[POINT 9,40,8];GET THE OPCODE
	LDB	B,[POINT 4,40,12]	;GET THE AC
	HRRZ	C,40		;
	JUMPE	A,UUOERR	;LOSE
	CAIGE	A,UUTBLN	;IS IT A LEGAL UUO?
	JRST	UUUO2		;OK
UUOERR:	OUTSTR [ASCIZ/ILLEGAL USER LEVEL UUO
/]
	JRST	UUORET

UUUO2:	PUSHJ	P,@UUTBL(A)	;DISPATCH
	JRST	UUORET
	JRST	USKIP

UUTBL:	UUOERR			;THIS CAN'T HAPPEN AT THIS POINT
	READ.T			;READ A TRACK
	READ.R			;READ RETRIEVAL
	READ.S			;READ SAT TABLE
	WRT.T			;WRITE TRACK
	WRT.R			;WRITE RETRIEVAL
	C.SAT			;CLEAR A SAT BIT
	S.SAT			;SET A SAT BIT
	F.ORCE			;FORCE THE SYSTEM TO WRITE SAT TABLE
	T.PRIN			;PRINT A LIST OF UUO'S
	R.PRIN			;PRINT RETRIEVAL FROM ADDRESS
	UTT3			;FAKE OUTSTR
	UTT1			;FAKE OUTCHR
	ST.USE			;STORE DSKUSE IN SYSTEM
	READ.C			;READ A CYLINDER
	WRT.C			;WRITE A CYLINDER
UUTBLN←←.-UUTBL			;LENGTH OF UUOTABL

;Read a cylinder.  Arg in effective address is cylinder number.
READ.C:	IMULI C,NTPC		;Convert cylinder number to track number
	SKIPE C			;LOSING ADDRESS CHECK WILL BARF ON THIS
	JSR ADRCHK		;CHECK TRACK ADDRESS
	HRLI C,-NTPC		;Read one cylinder's worth of tracks
	MOVEI W,TTRACK-1	;Start reading at place where single tracks go
REA.CL:	HRRZM C,CTRD1		;SAVE TRACK ADDRESS
	HRRZM C,LSTRD		;SAVE ADDRESS OF LAST READ
	HRRM W,CTRD0		;Save core address for UUO
	MTAPE DSK,CTRD		;READ IT
	 JSR DISERR		;THERE'S SOME SORT OF ERROR
	ADDI W,WDTRK		;Point to next track's place in core
	AOBJN C,REA.CL		;Loop through whole cylinder
	POPJ P,			;RETURN AND BE HAPPY

;Write a cylinder.  Arg in effective address is cylinder number.
WRT.C:	IMULI C,NTPC		;Convert cylinder number to track number
	JSR ADRCHK		;ADDRESS CHECK	
	HRLI C,-NTPC		;Read one cylinder's worth of tracks
	MOVEI W,TTRACK-1	;Start writing at place where single tracks live
WRT.CL:	HRRZM C,CTWRT1		;SAVE DISK ADDRESS FOR UUO
	HRRM W,CTWRT0		;Save core address for UUO
	MTAPE DSK,CTWRT		;WRITE
	 JSR DISERR		;ERROR STATUS?
	ADDI W,WDTRK		;Point to next track's place in core
	AOBJN C,WRT.CL		;Loop through whole cylinder
	POPJ P,			;OK

READ.T:	SKIPE	C		;LOSING ADDRESS CHECK WILL BARF ON THIS
	JSR	ADRCHK		;CHECK TRACK ADDRESS
	HRRZM	C,TTRD1		;SAVE TRACK ADDRESS
	HRRZM	C,LSTRD		;SAVE ADDRESS OF LAST READ
	MTAPE	DSK,TTRD	;READ IT
	JSR	DISERR		;THERE'S SOME SORT OF ERROR
	POPJ	P,		;RETURN AND BE HAPPY

READ.R:	SKIPE	C		;SEE READ.T
	JSR	ADRCHK		;ADDRESS CHECK
	HRRZM	C,TRRD1		;SAVE TRACK ADDRESS
	HRRZM	C,LSTRD
	MTAPE	DSK,TRRD
	JSR	DISERR		;SOME SORT OF DISK ERROR
	POPJ	P,

READ.S:	MTAPE	DSK,SATRD	;READ THE SAT TABLE
	 JSR	DISERR		;GIVE HIM THE ERROR
	MOVE W,NXTSAT		;COPY ADDRESS OF SECOND SAT TRACK
	MOVEM W,SATTK2		;IN CASE WTEST OVERWRITES IT!
	SKIPE UDPFLG		;BUT IF THIS IS A UDP,
	SETZM SATTK2		; THEN THERE IS NO 2ND TRACK
IFG XTRA,<			;ASSEMBLE THIS CODE ONLY IF ENOUGH DISKS
	SKIPN W,SATTK2		;SKIP IF WE HAVE ANOTHER TRACK TO READ
	POPJ	P,
	HRRM W,SATK2A		;STORE IN MTAPE BLOCK
	MTAPE DSK,SATRD2	;YES, READ IT
	 JSR DISERR
>;IFG XTRA
	POPJ P,

WRT.T:	JSR	ADRCHK		;ADDRESS CHECK	
	HRRZM	C,TTWRT1	;SAVE ADDRESS
	MTAPE	DSK,TTWRT	;WRITE
	JSR	DISERR		;ERROR STATUS?
	POPJ	P,		;OK

WRT.R:	JSR	ADRCHK
	HRRZM	C,TRWRT1
	MTAPE	DSK,TRWRT
	JSR	DISERR
	POPJ	P,

C.SAT:	JSR	ADRCHK
	HRRZM	C,CSAT1
	MTAPE	DSK,CSAT
	POPJ	P,

S.SAT:	JSR	ADRCHK		;DO ADDRESS CHECK
	HRRZM	C,SSAT1
	MTAPE	DSK,SATSET
	POPJ	P,		;NO ERRORS

F.ORCE:	MTAPE	DSK,FSAT	;FORCE SAT TABLE OUT
	POPJ	P,		;

T.PRIN:	OUTSTR UUOLST		;WRITE A LIST OF THE UUOS
	POPJ	P,

R.PRIN:	PUSH	P,B		;SAVE AC FIELD OF UUO
	JUMPN	C,.+2		;JUMP IF EA NON ZERO
	MOVEI	C,TTRACK	;USE TTRACK FOR DATA
	MOVE	W,LSTRD		;GET LAST READ OP NUMBER
	PUTSTR	[ASCIZ/TRACK /]
	MOVEI	Y,10
	SETZ	Z,
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/;  /]
	SKIPN	W,DDNAM(C)	;GET THE NAME
	JRST	RPRIN3		;BLANK NAME - EMPTY BLOCK
	PUSHJ	P,SIXOT1	;TYPE NAME
	HLLZ	X,DDEXT(C)	;GET THE EXTENSION
	MOVEI	Z,3		;3 CHARACTERS ONLY
	JUMPE	X,RPRIN1	;JUMP IF NO EXTENSION
	PUTSTR	[ASCIZ/./]
	PUSHJ	P,SIXOT2	;TYPE IT
RPRIN1:	MOVE	W,DDPPN(C)	;GET THE PPN
	PUSHJ	P,TYPPN1	;TYPE IT
	POP	P,B		;GET AC FIELD OF UUO
	CAIN	B,1
	JRST	RPRN2B		;RPRINT 1, RETURNS NOW.
	PUTSTR	[ASCIZ/  PRO(/]
	MOVEI	Z,3
	LDB	W,[POINT 9,DDPRO(C),8]	;GET THE PROTECTION
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/)  MODE(/]
	LDB	W,[POINT 4,DDPRO(C),12]
	MOVEI	Z,0
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/)  TIME(/]
	LDB	W,[POINT 11,DDPRO(C),23]
	PUSHJ	P,TTIME1		;TYPE TIME IN MINUTES
	PUTSTR	[ASCIZ/)  DATE(/]
	LDB	W,[POINT 12,DDPRO(C),35]
	LDB	X,[POINT 3,DDEXT(C),20]	;LOAD HIGH DATE - DATE75
	DPB	X,[POINT 3,W,23]	;STUFF HIGH DATE - DATE75
	PUSHJ	P,TDATE1		;TYPE DATE
	PUTSTR	[ASCIZ/)
/]
	PUTSTR	[ASCIZ/DDLOC = /]
	MOVE	W,DDLOC(C)	;GET THE LOCATION OF FIRST TRACK OF GROUP1
	MOVEI	Y,10		;RESET RADIX
	PUSHJ	P,ALLRAD	;TYPE IN OCTAL
	PUTSTR	[ASCIZ/;  FILE LENGTH = /]
	MOVE	W,DDLNG(C)	;GET THE LENGTH
	PUSHJ	P,ALLRAD	;Y,Z STILL SET UP
	MOVE	W,DGRP1R(C)	;GET POINTER TO HEAD OF THIS GROUP
	PUTSTR	[ASCIZ/;  DGRP1R = /]
	PUSHJ	P,ALLRAD
	PUTSTR	CRLF
	SKIPN	W,DNXTGP(C)
	JRST	RPRN1A
	PUTSTR	[ASCIZ/NEXT GROUP = /]
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/;  /]
RPRN1A:	MOVE	W,DSATID(C)
	CAME	W,SATID
	JRST	RPRN1B
	PUTSTR	[ASCIZ/VALID SATID/]
	JRST	RPRN1C
RPRN1B:	PUTSTR	[ASCIZ/INVALID SATID = /]
	PUSHJ	P,ALLRAD
RPRN1C:	PUTSTR	[ASCIZ/    PROGRAM= /]
	MOVE	W,15(C)
	PUSHJ	P,SIXOT1
	PUTSTR	[ASCIZ/   USER /]
	MOVE	W,16(C)
	PUSHJ	P,SIXOT1
	PUTSTR	[ASCIZ/   RECORD OFFSET= /]
	HRRZ	W,17(C)
	PUSHJ	P,ALLRAD
RPRN1D:	PUTSTR	[ASCIZ/
RETRIEVAL POINTERS:
/]
	MOVSI	A,-<TRKGRP/2>	;NUMBER OF WORDS OF POINTERS
	HRRI	A,DDRET(C)	;MAKE POINTER TO THE RETRIEVAL WORDS
RPRIN2:	SKIPN	(A)
	JRST	RPRN2A
	HLRE	B,A		;GET THE POSITION -20
	ADDI	B,TRKGRP/2	;ADD 20 TO MAKE POSITION
	LSH	B,1		;DOUBLE
	MOVEI	W,1(B)
	PUSHJ	P,ALLRAD	;TYPE BLOCK NUMBER
	PUTSTR	[ASCIZ "/"]
	MOVEI	W,2(B)
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/	/]
	HLRZ	W,0(A)		;GET AN ODD ONE
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/,,/]
	HRRZ	W,0(A)
	PUSHJ	P,ALLRAD
	PUTSTR	CRLF
RPRN2A:	AOBJN	A,RPRIN2
RPRN2B:	PUTSTR	CRLF
	POPJ	P,

RPRIN3:	PUTSTR	[ASCIZ/ EMPTY BLOCK
/]
	POP	P,B		;IGNORE.
	POPJ	P,

ADRCHK:	0			;JSR TO HERE
	JUMPLE	C,IVTADR	;INVALID TRACK ADDRESS
	CAMGE	C,MTRACK	;BEYOND FILE SYSTEM (OR UDP SYSTEM IF UDP INITED)?
	JRST [	SKIPE UDPONL	;NO, IS IT SUPPOSED TO BE?
		JRST IVTADR	;YES, DISALLOWED FILE SYSTEM REF
		JRST ADRCK1]	;OK.
	SKIPE	UDPFLG
	JRST	IVTADR		;INVALID TRACK IF WE'RE IN UDP MODE
	CAIG	C,TTUDP		;IS THIS IN A UDP?
	JRST	UDPTAR		;CHECK FOR DDT EXECUTION OF UUO
IVTADR:	OUTSTR [ASCIZ/INVALID TRACK ADDRESS FOR MTAPE.
TRACK ADDRESS = /]
	HRRZ	W,40		;GET THE ADDRESS FROM JOBUUO
	PUSHJ	P,OCTOUT	;WRITE IN OCTAL
	OUTSTR CRLF
	HALT	CPOPJ		;LET HIM RETURN BY A POPJ

UDPTAR:	SKIPE	UDPOK		;FLAG SET?
	JRST	ADRCK1		;YES. RETURN
	PUTSTR	[ASCIZ/OPERATION ON UDP.
PROCEED? /]
	PUSHJ	P,YORN
	POPJ	P,		;OPERATION WILL BE FLUSHED.
	PUTSTR	[ASCIZ/DO YOU WANT UDP WARNINGS SUPRESSED? /]
	PUSHJ	P,YORN
	JRST	ADRCK1		;NO SUPRESSION
	SETOM	UDPOK		;SET FLAG
ADRCK1:	JRST	@ADRCHK		;LET HIM BY

DISERR:	0			;JSR TO HERE
	GETSTS	DSK,W		;GET THE DISK STATUS
	TRNN	W,740000	;LOOK AT STATUS BITS
	JRST	ILLOPR		;MUST BE AN INVALID OPERATION
	OUTSTR [ASCIZ/DISK ERROR. STATUS = /]
DISER2:	PUSHJ	P,OCTOUT	;WRITE IN OCTAL
	OUTSTR CRLF
	HALT	CPOPJ		;
ILLOPR:	OUTSTR [ASCIZ/ILLEGAL OPERATION? /]
	HALT	CPOPJ

UTT1:	CAIGE	C,17		;IS ARGUMENT IN AN AC?
	ADDI	C,-17(P)	;
	OUTCHR (C)		;DO THE USUAL WORK
	SKIPN	LPTFLG
	JRST	UTT1A
	MOVE	A,(C)
	PUSHJ	P,LPTPUT
UTT1A:	SKIPN	CTYTYO		;OUTPUT TO CTY?
	POPJ	P,		;NO.
	MOVE	D,(C)
	ANDI	D,177
	ROT	D,-7
	MOVEI	A,['CTY   '
		    D]
	TTYMES	A,
	JFCL
	POPJ	P,

LPTPUT:	SOSG	LPTBF+2
	OUTPUT	LPT,
	IDPB	A,LPTBF+1
	POPJ	P,

UTT3:	OUTSTR (C)
	SKIPN	CTYTYO
	JRST	UTT3A
	HRRZ	C,C
	MOVSI	B,'CTY'
	MOVEI	A,B
	TTYMES	A,
	JFCL
UTT3A:	SKIPN	LPTFLG
	POPJ	P,
LPTSTR:	HRLI	C,(<POINT 7,0>)
LPTST1:	ILDB	A,C
	JUMPE	A,CPOPJ
	PUSHJ	P,LPTPUT
	JRST	LPTST1


ST.USE:	HRRZM	C,STUSE1	;SAVE
	MTAPE	DSK,STUSE	;DO THE MTAPE
	POPJ	P,		;RETURN


;SPREAD UUO.  SPREAD RETRIEVAL FROM TTRACK.
SPRED:	CLRBFI
	RPRINT	TTRACK
	PUTSTR	[ASCIZ/
Spread this retrieval?  /]
	PUSHJ	P,GO.ON
	POPJ	P,			;NO
	MOVEI	D,0			;TRACK NUMBER IN THE FILE.
	MOVE	A,[TTRACK,,RTSAV]	;SAVE THE RETRIEVAL
	BLT	A,RTSAV+WDRTVL-1	;...
;I HAVE DECIDED THAT I DON'T KNOW WHAT I'M DOING SO I QUIT UNTIL NEXT TIME.
;NOCORE NODISK GOEXIT
	SUBTTL	ERROR MESSAGES
NOCORE:	OUTSTR [ASCIZ/NOT ENOUGH CORE!
/]
	HALT	GOEXIT

NODISK:	OUTSTR [ASCIZ/OPEN FAILED ON DEVICE: /]
	MOVE	W,B
	PUSHJ	P,SIXOUT
	OUTSTR CRLF
	HALT	GOEXIT
GOEXIT:	EXIT
;BEGIN REOPEN CMD TTYGET TTYFLU TTYFL1 TTYFL2 CMTAB CMTABL CMD2 GUNAM DDTCALL DDTGO DDTGO1 CMD1 QM1 QM
	SUBTTL	INITIALIZE
BEGIN:	RESET				;CLEAR IO
	MOVE A,JOBFF
	MOVEM A,SAVFF
	MOVEI A,0
	GETPRV A,
	TLO A,WANTPR
	SETPRV A,
	TLC A,WANTPR
	TLCE A,WANTPR
	JRST [	OUTSTR [ASCIZ /You cannot run this program.  Please consult a wizard.
/]
		EXIT	]
	SETZM LPTFLG
	SETZM CTYTYO
	MOVSI A,'DSK'
	MOVEM A,DEFDEV			;DEFAULT DISK DEVICE
	SETZM UDPFLG			;NOT UDP
	SETZM UDPONL			;CAN REFERENCE FILE DISK
	MOVEI A,TRACKS
	MOVEM A,MTRACK			;NUMBER OF TRACKS IN FILE SYS
	MOVE P,[IOWD PDLEN,PDLIST]	;INITIALIZE STACK
	MOVEI A,254
	PEEK A,
	PEEK A,
	MOVEM A,MAINTM			;SAVE STATUS OF MAINTMODE
	MOVNI A,1
	SETPRV A,
	MOVEM A,JBTPRV			;SAVE JOB PRIVILEGES
REOPEN:	MOVEI A,217			;GET A DISK CHANNEL - MODE
	MOVE B,DEFDEV			;USE DEFAULT DEVICE
	MOVEI C,0			;NO BUFFERS
	OPEN DSK,A
	JRST NODISK		;THIS CAN'T HAPPEN TO ME!
	SREAD			;READ THE SAT TABLE FROM THE SYSTEM
	MOVE W,SATID		;GET THE SYSTEM'S SATID
	OUTSTR [ASCIZ/Welcome to RALPH, the disk auditor.
SATID = /]
	SKIPN	UDPFLG
	PUSHJ	P,OCTOUT	;TYPE THE NUMBER
	SKIPE	UDPFLG
	PUSHJ	P,SIXOUT
	OUTSTR CRLF
;	PUSHJ	P,QM
	OUTSTR [ASCIZ/Type ?<cr> for Help
/]
CMD:	OUTCHR ["*"]
	PUSHJ	P,TTYGET	;GET ONE CHARACTER IN A
	PUSHJ	P,TTYFLU	;FLUSH TO END OF LINE
	OUTSTR CRLF
	MOVSI	B,-CMTABL	;GET LENGTH OF COMMAND TABLE
	HLRZ	C,CMTAB(B)	;GET A LETTE
	CAME	A,C
	AOBJN	B,.-2		;LOOP
	JUMPL	B,CMD1		;DISPATCH
	OUTSTR [ASCIZ/Unknown command "/]
	OUTCHR A
	OUTSTR [ASCIZ/".  Type ? for help
/]
	JRST	CMD		;LOOP

TTYGET:	INCHWL	A
	CAIL	A,"A"+40
	CAILE	A,"Z"+40
	POPJ	P,
	SUBI	A,40
	POPJ	P,

TTYFLU:	PUSH	P,A
TTYFL1:	CAIE	A,12
	CAIN	A,175
	JRST	TTYFL2		;WE HAVE AN ACTIVATOR.
	INCHWL	A
	JRST	TTYFL1

TTYFL2:	POP	P,A
	POPJ	P,

CMTAB:	XWD	"C",PHASE1	;CLEAN DISK
	XWD	"U",GUNAM	;GET NAME OF UDP DEVICE
	XWD	12,CMD2		;IGNORE
	XWD	15,CMD2		;IGNORE
	XWD	"$",DDTGO	;GET THEE TO DDT
	XWD	175,DDTGO	;GET THEE TO DDT
	XWD	"H",UHELP	;HELP A USER
	XWD	"?",QM		;TYPE COMMAND LIST
CMTABL←←.-CMTAB			;LENGTH OF COMMAND TABLE

CMD2:	POP	P,(P)		;FLUSH THE PUSH
	JRST	CMD		;LOOK FOR MORE COMMANDS

GUNAM:	MOVE	A,['UDP1  ']
	MOVEM	A,DEFDEV
	MOVEI	A,NTPP		;NUMBER OF TRACKS/UDP
	MOVEM	A,MTRACK
	SETOM	UDPFLG
	JRST	REOPEN

DDTCALL:
DDTGO:	HRRZ	A,JOBDDT
	JUMPN	A,DDTGO1
	OUTSTR [ASCIZ/NO DDT
/]
	JRST	CMD2		;GET BACK SOMEHOW

DDTGO1:	OUTSTR [ASCIZ/(DDT)
/]
	MOVE A,[10000,,CPOPJ]
	MOVEM A,JOBOPC		;Set up $P address
	HRRZ A,JOBDDT		;Get DDT address again
	JRST	(A)

CMD1:	HRRZ	C,CMTAB(B)	;GET JUMP ADDRESS
	PUSHJ	P,0(C)		;DISPATCH
	JRST	CMD		;LOOK FOR MORE

QM1:	ASCIZ	/Commands are:
C	Clean disk.  Write a new SAT table
H	Help to inspect or recover a user's file
U	Enter UDP mode
$	Call DDT
?	Type this list
/

QM:	OUTSTR QM1
	POPJ	P,
;AP1MES REBILD PHASE1 REBIL1 PHSI1A PHSI1B PHSI1C PH1LOP PHLP1 PHSTAB PHSTL PHSQ PHSG PHSW PHSU PHSF PHSL NOLPT
	SUBTTL	AUDIT PHASE1 - INITIALIZE

AP1MES:	ASCIZ	/Phase 1 options are:

U	Type all UFD names
F	Type all file names
W	Extra Tracks Warning
Q	No Redundant Retrieval Check
G	Don't stop at error conditions

Type one line of letters selecting options.
*/

REBILD:	SETOM REBLDF
	SETZM REBBUF
	JRST REBIL1

PHASE1:	OUTSTR [ASCIZ/Audit Phase 1.
/]
	SETZM	NOPHS2			;ASSUME PHASE2 WILL BE RUN.
	MOVSI	A,DAWPRV
	TDNE	A,JBTPRV
	JRST	PHSI1A			;HAS PRIV.
	OUTSTR [ASCIZ/(You are not privileged to do Phase 2 of the Audit)
/]
REBIL1:	SETOM	NOPHS2
PHSI1A:	SKIPE	UDPFLG		;DISK OR UDP?
	JRST	PHSI1B		;UDP.
	SKIPE	MAINTM
	JRST	PHSI1C
	OUTSTR [ASCIZ/(Set MAINTMODE and restart if you plan to do phase 2)
/]
	SETOM	NOPHS2
	JRST	PHSI1C

PHSI1B:	MOVEI	A,DSK
	DEVUSE	A,
	TLNE	A,2000
	JRST	PHSI1C
	OUTSTR [ASCIZ/(ASSIGN PRIVATE UDP and restart if you plan to do phase 2)
/]
	SETOM	NOPHS2
PHSI1C:	SKIPE	NOPHS2
	OUTSTR [ASCIZ/Restart now if you intend to do phase 2
/]
	OUTSTR AP1MES
PH1LOP:	PUSHJ	P,TTYGET	;GET A CHARACTER
	MOVSI	B,-PHSTL
	HLRZ	C,PHSTAB(B)
	CAME	A,C
	AOBJN	B,.-2		;LOOP
	JUMPL	B,PHLP1		;OK GOT ONE
	OUTSTR [ASCIZ/
"/]
	OUTCHR A
	OUTSTR [ASCIZ/" unknown.
/]
	JRST	PH1LOP		;LOOP

PHLP1:	HRRZ	C,PHSTAB(B)
	PUSHJ	P,0(C)		;DISPATCH
	JRST	PH1LOP
	JRST	PHLP2		;ALL DONE

PHSTAB:	XWD	15,CPOPJ	;IGNORE CR
	XWD	12,CPOPJ1	;LF TERMINATES
	XWD	175,DDTGO	;SET DDT
	XWD	"$",DDTGO
	XWD	"Q",PHSQ
	XWD	"G",PHSG
	XWD	"W",PHSW
	XWD	"U",PHSU
	XWD	"F",PHSF
PHSTL←←.-PHSTAB

PHSQ:	SETOM	NRTCHK
	POPJ	P,

PHSG:	SETOM	NOSTOP
	POPJ	P,

PHSW:	SETOM	WDSTOP
	POPJ	P,

PHSU:	SETOM	ALLUFD
	POPJ	P,
PHSF:	SETOM	ALLNAM
	POPJ	P,

PHSL:	INIT	LPT,200
	'LPT   '
	XWD 	LPTBF,0
	JRST	NOLPT
	OUTBUF	LPT,3
	SETOM	LPTFLG
	POPJ	P,

NOLPT:	OUTSTR [ASCIZ/LPT IS UNAVAILABLE
/]
	POPJ	P,

;PHLP2 PH1.1 PH1.1A PH1.2 PH1.3 PH1.4 EMMFD EMUFD PH1.5 BITCNT BTCT1
	SUBTTL	AUDIT PHASE1 - READ ALL THE RETRIEVAL IN THE WORLD

PHLP2:	SETZM	SATTAB		;ZERO OUR COPY OF SAT TABLE
	MOVE	A,[XWD SATTAB,SATTAB+1]
	BLT	A,SATEND
	SETOM	PHI1		;SET TO MAKE MARKS IN SAT
	SKIPE R,SATTK2		;GET TRACK NUMBER OF SECOND SAT TRACK
	PUSHJ P,MBYTE		;MARK SECOND SAT TRACK AS TAKEN
	MOVE	A,['  1  1']	;GET NAME OF MFD
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV +3	;SAVE AS EXPECTED RETRIEVAL
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	MOVEI	R,1		;READ FILE FROM BLOCK 1
	PUSHJ	P,FREAD		;READ FILE
	MOVE	W,FSIZE
	MOVEM	W,TOTSIZ	;SAVE TOTAL SIZE
	SKIPE SATTK2		;IF THERE IS A SECOND SAT TRACK,
	AOS TOTSIZ		; INCLUDE IT
	MOVE	Z,DIOWD		;GET THE IOWD OF FILE
	MOVEM	Z,MFDPTR	;SAVE AS MFD POINTER
	PUTSTR	[ASCIZ/MFD READ.  /]
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ TRACKS.
/]
	AOJGE	Z,EMMFD		;JUMP IF EMPTY MFD!
	MOVE	A,JOBFF		;GET JOBFF
	MOVEM	A,SAVFF		;SAVE IT
PH1.1:	SKIPN	A,(Z)		;GET THE NAME OF A USER
	JRST	PH1.4		;EMPTY ENTRY
	MOVEM	A,PPUFD		;SAVE THE PPN OF THIS UFD
	MOVEM	A,RTSAV		;SAVE NAME OF UFD 
	MOVE	A,['  1  1']	;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+3	;SAVE
	HLLZ	B,1(Z)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1	;SAVE IT
	CAME	B,['UFD   ']	;MUST BE SIXBIT UFD
	JRST	PH1.5		;MENTION GARBAGED NAME.  RTSAV,RTSAV+1 SETUP
	HRRZ	R,3(Z)		;GET THE TRACK ADDRESS
	MOVE	A,SAVFF
	MOVEM	A,JOBFF
	PUSHJ	P,FREAD
	MOVE	W,FSIZE
	ADDM	W,TOTSIZ
	SKIPN	ALLUFD
	JRST	PH1.1A
	MOVE	W,PPUFD		;GET NAME
	PUSHJ	P,TYPPN
	PUTSTR	[ASCIZ/ /]
	MOVE	W,FSIZE		;GET FILE SIZE
	PUSHJ	P,DECOUT	;ARG STILL IN W, I HOPE
	PUTSTR	CRLF
PH1.1A:	MOVE	Y,DIOWD		;GET THE IOWD OF THE FILE
	AOJGE	Y,EMUFD		;TELL ABOUT THIS EMPTY UFD
PH1.2:	SKIPN	A,0(Y)		;GET A FILE NAME
	JRST	PH1.3		;EMPTY NAME
	MOVEM	A,RTSAV		;SAVE RETRIEVAL
	HLLZ	B,1(Y)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1
	MOVE	C,PPUFD
	MOVEM	C,RTSAV+3
	HRRZ	R,3(Y)		;GET THE TRACK ADDRESS
	PUSHJ	P,RTRD		;READ THE RETRIEVAL
	MOVE	W,FSIZE
	ADDM	W,TOTSIZ
	SKIPN	ALLNAM		;SKIP IF BEING NOISY
	JRST	PH1.3
	PUSHJ	P,TYFIL
	PUTSTR	[ASCIZ/ /]
	PUSHJ	P,DECOUT
	PUTSTR	CRLF
PH1.3:	ADD	Y,[XWD UFDN,UFDN]
	JUMPL	Y,PH1.2		;LOOP
PH1.4:	ADD	Z,[XWD UFDN,UFDN]
	JUMPL	Z,PH1.1		;LOOP
	PUTSTR	[ASCIZ/PHASE 1 COMPLETE.
/]
	SETZM	PHI1
	PUTSTR	[ASCIZ/THERE ARE /]
	MOVE	W,TOTSIZ
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ TRACKS IN THIS FILE SYSTEM.
/]
	PUSHJ	P,BITCNT
	POPJ	P,

EMMFD:	PUTSTR	[ASCIZ/
THE MFD IS EMPTY!
/]
	POPJ	P,

EMUFD:	PUTSTR	[ASCIZ/EMPTY UFD. /]
	PUSHJ	P,TYFIL		;TYPE THE NAME OF THE FILE
	PUTSTR	CRLF
	JRST	PH1.4

PH1.5:	PUTSTR	[ASCIZ/A FILE, NOT A UFD, FOUND IN [1,1].
/]
	PUSH	P,Z
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
	POP	P,Z
	SKIPN REBLDF
	HALT	PH1.4		;GET ANOTHER ENTRY FROM MFD
	PUSHJ P,EXAM1
	JRST PH1.4

BITCNT:	MOVE	R,MTRACK	;GET THE MAXIMUM TRACK NUMBER
	SUBI	R,1
	SETZ	A,		;ZERO COUNTER
BTCT1:	PUSHJ	P,SBYTE		;MAKE A BYTE POINTER
	LDB	B,SATBYT
	JUMPE	B,.+2
	ADDI	A,1
	SOJG	R,BTCT1		;LOOP
	CAMLE	A,TOTSIZ
	MOVEM	A,TOTSIZ	;SAVE BIGGEST OF ALL
	PUTSTR	[ASCIZ/
THERE ARE /]
	MOVE	W,A
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ BLOCKS CLAIMED IN MY VERSION OF THE SAT TABLE
/]
	SKIPE	NOPHS2		;PHASE 2 SUPPRESSED?
	POPJ	P,		;YES.
	OUTSTR [ASCIZ/TYPE Y TO GET PHASE 2:  /]
	PUSHJ	P,TTYGET
	PUSHJ	P,TTYFLU
	CAIN	A,"Y"
	JRST	PHASE2
	POPJ	P,
;PHASE2 PH2.1 PH2.1A PH2.1B PH2TAB PH2TL PH2C.C PH2C.S PH2.1C PH2.2 PH2.2A PH2.2B PH2.3 PH2.4 PH2.4A SPAUSE GPAUSE QDDT CPAUSE
	SUBTTL	PHASE2 - CLEAR SAT BITS AND ZERO SATID OF DISCONNECTED BLOCKS

PHASE2:	OUTSTR [ASCIZ/PHASE2. YOU'D BETTER BE SERIOUS ABOUT THIS!
TYPE Y TO CONTINUE, N TO FLUSH PHASE2: /]
	CLRBFI
	PUSHJ	P,TTYGET
	PUSHJ	P,TTYFLU
	OUTSTR CRLF
	CAIN	A,"N"
	POPJ	P,		;JUST RETURN IF HE'S NOT SERIOUS
	CAIE	A,"Y"
	JRST PHASE2		;TRY IT AGAIN TURKEY
PH2.1:	OUTSTR [ASCIZ/TYPE ONE LINE OF OPTIONS
C	STOP WHEN CLEARING A SAT BIT
S	STOP WHEN SETTING A SAT BIT
*/]
PH2.1A:	PUSHJ	P,TTYGET	;READ HIS OPTIONS
	MOVSI	B,-PH2TL
	HLRZ	C,PH2TAB(B)
	CAME	A,C
	AOBJN	B,.-2
	JUMPL	B,PH2.1B	;WIN
	OUTSTR [ASCIZ/"/]
	OUTCHR A
	OUTSTR [ASCIZ/" UNKNOWN
/]
	JRST	PH2.1A

PH2.1B:	HRRZ	C,PH2TAB(B)
	PUSHJ	P,(C)
	JRST	PH2.1A
	JRST	PH2.1C

PH2TAB:	XWD	"C",PH2C.C
	XWD	"S",PH2C.S
	XWD	15,CPOPJ
	XWD	12,CPOPJ1
	XWD	175,DDTGO
	XWD	"$",DDTGO
PH2TL←.-PH2TAB

PH2C.C:	SETOM	PH2CFG
	POPJ	P,

PH2C.S:	SETOM	PH2SFG
	POPJ	P,

PH2.1C:	MOVEI	R,1
	SUB	R,MTRACK	;#OF TRACKS - SAT TRACKS
	SKIPE	UDPFLG
	ADDI	R,1		;LEAVE PASSWORD BLOCK ALONE ON UDP
	MOVSI	R,(R)
	HRRI	R,1
PH2.2:	PUSHJ	P,SBYTE		;LOOK AT A BYTE
	LDB	Y,SATBYT	;GET BYTE
	LDB	Z,SSATBT	;GET BYTE FROM (OUR COPY) OF THE REAL SAT TABLE
	CAMN	Y,Z		;SKIP IF DIFFERENT!
	JRST	PH2.4		;IS ALREADY SET!
	JUMPN	Y,PH2.3		;SET FOR US, BUT NOT FOR SYSTEM. GO MARK IT
	RREAD	(R)		;READ THE RETRIEVAL FOR THIS BLOCK
	MOVE	Y,SATID
	CAME	Y,TTRACK+DSATID
	JRST	PH2.2A		;SATID INVALID - DON'T WRITE ON DISK.
	SKIPE	PH2CFG
	PUSHJ	P,CPAUSE	;PAUSE FOR CLEAR
PH2.2A:	SKIPN	TTRACK+DSATID
	JRST	PH2.2B
	SETZM	TTRACK+DSATID
	RWRITE	(R)		;YES: REWRITE RETRIEVAL WITH ZERO SATID
PH2.2B:	CLRSAT	(R)		;CLEAR THIS TRACK'S SAT BIT IN THE SYSTEM
	JRST	PH2.4

PH2.3:	SKIPE	PH2SFG
	PUSHJ	P,SPAUSE
	SETSAT	(R)		;MAKE SYSTEM MARK THIS BIT
PH2.4:	AOBJN	R,PH2.2		;LOOP
	SKIPN	UDPFLG
	JRST	PH2.4A
	SETSAT	(R)		;MAKE SURE PASSWORD BLOCK MARKED IN UDP
	AOSA	A,TOTSIZ	;AND COUNT ANOTHER BLOCK IN DSKUSE
PH2.4A:	MOVE	A,TOTSIZ	;SET DSKUSE IN SYSTEM TO CONTENTS OF TOTSIZ
	SETUSE	(A)		;
	FORCE			;FORCE THE SYSTEM TO WRITE A NEW SAT TABLE
	PUTSTR	[ASCIZ/PHASE2 COMPLETE
/]
	POPJ	P,

SPAUSE:	PUTSTR	[ASCIZ/SETTING. TRACK = /]
	HRRZ	W,R
	PUSHJ	P,OCTOUT
	PUTSTR	CRLF
	RREAD	(R)
GPAUSE:	MOVE	W,[XWD TTRACK,RTSAV]
	BLT	W,RTSAV+WDRTVL-1
	PUSHJ	P,TYFIL
QDDT:	OUTSTR [ASCIZ/
TYPE "$" TO ENTER DDT, OTHERWISE CONTINUE
*/]
	INCHWL A
	CLRBFI
	CAIE	A,175
	CAIN	A,"$"
	JRST	DDTGO
	POPJ	P,		;CONTINUE

CPAUSE:	PUTSTR	[ASCIZ/CLEARING.  TRACK = /]
	HRRZ	W,R
	PUSHJ	P,OCTOUT
	PUTSTR	CRLF
	JRST	GPAUSE		;FIND OUT IF HE WANTS TO STOP
;FREAD FRD0 FREAD0 FREAD1 FREAD2 FRD2A FREAD3 FREAD7 FRD7A FRD7B SIZCHK FREAD6
	SUBTTL	FREAD READ A FILE INTO CORE
;THIS ROUTINE USES R AS A PARAMETER, RETURNS DIOWD, FSIZE
;ACCUMULATORS  K,L,M,N,AND S ARE CLOBBERED
FREAD:	SETOM	FILEON		;SET FLAG
	SETZM	FSIZE		;COUNT FILE SIZE
	SETZM	DIOWD
	PUSHJ	P,DREAD		;READ 
	AOS	FSIZE		;COUNT FILE SIZE
	MOVE	S,RTSAV		;GET EXPECTED NAME
	CAME	S,TTRACK	;CHECK
	JRST	FREAD7		;BAD RETRIEVAL
	HLLZ	S,TTRACK+1
	CAME	S,RTSAV+1
	JRST	FREAD7
	MOVE	S,RTSAV+3
	CAME	S,TTRACK+3
	JRST	FREAD7
	MOVE	S,SATID
	CAME	S,DSATID+TTRACK
	JRST	FREAD7			;INVALID SATID
	MOVM	S,TTRACK+5	;GET THE WORD COUNT
	CAIGE	S,400000	;SKIP IF FILE IS NOT "SMALL"
	JRST	FRD0		;REQUEST IS "REASONABLE"
	OUTSTR [ASCIZ/FILE SIZE ≥ 128K. I WON'T READ THIS INTO CORE!
/]
	HALT	.		;STOP HERE!

FRD0:	MOVN	S,S		;GET - WORD COUNT
	MOVS	S,S		;SWAP S
	HRR	S,JOBFF		;
	SUBI	S,1		;MAKE IOWD FORMAT FOR LATER OPS.
	MOVEM	S,DIOWD		;SAVE DUMP IOWD
	MOVM	S,TTRACK+5	;GET WORD COUNT
	ADDB	S,JOBFF		;MAKE NEW JOBFF
	CAMGE	S,JOBREL	;TEST AGAINT CORE BOUNDS
	JRST	FREAD0		;IS OK
	CORE	S,		;GET MORE CORE
	JRST	NOCORE		;NONE AVAILABLE?
FREAD0:	MOVE	S,DIOWD		;GET THE ORIGINAL IOWD
FREAD1:	HLRZ	N,TTRACK+DDRET		;GET FIRST RETRIEVAL POINTER
	HRRZ	R,R			;ONLY THE BLOCK NUMBER IN R
	CAME	N,R			;SHOULD BE SAME AS CURRENT OPERATION
	JRST	FREAD7			;LOSE
	MOVE	N,[XWD TTRACK,RTSAV]	;SAVE RETRIEVAL OF THIS BLOCK
	BLT	N,RTSAV+WDRTVL-1	;BLT IT OVER.
	SETZM	NFT
	SKIPE	LPTFLG
	RPRINT	TTRACK
FREAD2:	JUMPGE	S,FRD2A			;JUMP IF ACTUAL DATA TRANSFER IS DONE
	MOVSI	N,TTRACK+WDRTVL		;SOURCE OF DATA
	HRRI	N,1(S)			;DESTINATION OF DATA
	HLRE	K,S			;GET -WD COUNT
	MOVN	L,K			;GET TOTAL WD COUNT
	CAILE	L,200*NBPT		;SKIP IF AMOUNT TO GO ≤ 1 TRACK
	MOVEI	L,200*NBPT		;SHORTEN REQUEST
	ADD	K,L			;DECREASE THE -WD COUNT
	ADD	S,L			;INCREASE THE IOWD
	HRL	S,K			;S IS IOWD FOR NEXT XFER
	BLT	N,0(S)			;BLT THE DATA TO THE DATA STORE
FRD2A:	AOS	K,NFT			;READ ANOTHER TRACK
	CAIL	K,TRKGRP		;MAKE SURE WE'RE IN GROUP STILL
	JRST	FREAD3			;GO READ FROM ANOTHER GROUP
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	R,TTRACK+DDRET(K)	;GET TRACK NUMBER OF NEXT
	TLNE	L,400000
	HRRZ	R,TTRACK+DDRET(K)	;
	JUMPE	R,FREAD6		;JUMP IF THERE ARE NO MORE TRACKS
	PUSHJ	P,SIZCHK
	PUSHJ	P,DREAD
	AOS	FSIZE
	MOVE	K,RTSAV
	CAME	K,TTRACK
	JRST	FREAD7
	HLLZ	K,RTSAV+1
	HLLZ	L,TTRACK+1
	CAME	K,L
	JRST	FREAD7

;COMPARE ALL RETRIEVAL STARTING WITH WORD 7 (DDMPTM)
;NOTE THAT DREFTM IS NOT SPREAD OVER THE GROUP TO SAVE TIME ON LOOKUP
;ALSO, IT IS CLAIMED THAT THE FILE LENGTH NEED NOT BE CONSISTIENT.
	MOVSI	K,7-WDRTV2
	MOVE	L,TTRACK+7(K)		;LOOK 
	CAMN	L,RTSAV+7(K)
	AOBJN	K,.-2			;LOOP
	JUMPL	K,FREAD7		;FREAD BAD RETRIEVAL
	JRST	FREAD2			;GO DEPOSIT THE DATA

FREAD3:	HRRZ	R,TTRACK+DNXTGP		;GO GET ANOTHER GROUP
	JUMPE	R,FREAD6		;JUMP IF NO MORE GROUPS
	PUSHJ	P,SIZCHK
	PUSHJ	P,DREAD
	AOS	FSIZE
	MOVE	L,TTRACK		;MATCH FIRST WORDS
	CAMN	L,RTSAV
	JRST	FREAD7			;BAD RETR.
	HLLZ	K,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	L,K
	JRST	FREAD7			;LOSE
	MOVE	K,TTRACK+3
	CAMN	K,RTSAV+3
	JRST	FREAD1			;RETRIEVAL MATCHES WELL ENOUGH.
FREAD7:	PUTSTR	[ASCIZ/
BAD RETRIEVAL AT FREAD7!
/]
	PUSHJ	P,TYFIL
	PUTSTR	[ASCIZ/ FILE POINTS TO /]
	RPRINT	TTRACK
	SOS	FSIZE
	SETZ	W,
	SKIPN	SATFLG
	DPB	W,SATBYT
	PUSHJ	P,EXAM1
	SKIPE REBLDF
	JRST FRD7A
	SKIPN	NOSTOP			;CAN WE STOP?
	JRST	FRD7B			;YES ASK ABOUT FLUSHING
FRD7A:	PUTSTR	[ASCIZ/THIS FILE WILL BE FLUSHED!
/]
	SETZM	DIOWD
	POPJ	P,

FRD7B:	PUTSTR	[ASCIZ/
TYPE Y TO FLUSH THIS FILE: /]
	INCHWL A
	CLRBFI
	CAIE	A,"Y"
	CAIN	A,"y"
	JRST	FRD7A
	SKIPN	DIOWD
	POPJ	P,			;NO FLUSH: JUST RETURN
	SETZM	1(S)
	AOBJN	S,.-1
	POPJ	P,			;NO FLUSH: JUST RETURN

SIZCHK:	JUMPL	S,CPOPJ			;QUICK RETURN IF WD COUNT OK
	PUSHJ	P,TYFIL			;TYPE FILE NAME
	PUTSTR	[ASCIZ/ WORD COUNT EXHAUSTED, BUT MORE TRACKS TO READ.
/]
	SKIPN	WDSTOP			;SKIP IF FLAG SET
	POPJ	P,			;RETURN QUICK
	JRST	EXAM1			;GO TELL THE USER MORE

FREAD6:	JUMPGE	S,CPOPJ			;RETURN IF WORD COUNT EXHAUSTED
	PUTSTR	[ASCIZ/FREAD6: NO MORE TRACKS AND WORD COUNT UNEXHAUSTED!
/]
	RPRINT	TTRACK			;TYPE Stuff
	SETZM	1(S)			;return zeroes when ready
	AOBJN	S,.-1
	JRST	EXAM1			;ALLOW USER TO EXAMINE THINGS
;RTRD RTRDU1 RTRDNU RTRD1 RTRD2 RTRD3 RTRD7 SEEK FIND RTRD7A RTRDUE TRACK RTRD6 RTRD8 EXAM1 EXAM13 EXAM99 EXAM12 EXAM11 EXAM2
	SUBTTL	RTRD - CHECK RETRIEVAL
;THIS ROUTINE USES R AS A PARAMETER.
;ACCUMULATORS  K,L,M,N,AND S ARE CLOBBERED
RTRD:	SETZM	FILEON		;RETRIEVAL ONLY!
	SETZM	FSIZE
	PUSH	P,NRTCHK	;SAVE FLAG
	SETZM	NRTCHK		;CLEAR FLAG
	PUSHJ	P,DREAD		;READ 
	POP	P,NRTCHK	;RESTORE FLAG. IF SET, DISK OPS DON'T HAPPEN
	AOS	FSIZE
	MOVE	S,RTSAV		;GET EXPECTED NAME
	CAME	S,TTRACK	;CHECK
	JRST	RTRD7		;BAD RETRIEVAL
	HLLZ	S,TTRACK+1
	CAME	S,RTSAV+1
	JRST	RTRD7		;EXT LOSES
	MOVE	S,RTSAV+3
	CAME	S,TTRACK+3
	JRST	RTRD7		;PPN WRONG
	MOVE	S,SATID
	CAME	S,DSATID+TTRACK
	JRST	RTRD7		;INVALID SATID
IFN NEWUFD,<
	SKIPN PHI1
	JRST RTRDNU		;NOT FROM AUDIT, DON'T CHECK UFD ENTRY
;HERE FROM AUDIT.  Y POINTS TO UFD ENTRY IN CORE, TTRACK HAS FIRST TRACK OF
;FILE.
	MOVE S,TTRACK+5		;FILE LENGTH
	CAME S,4(Y)
	JRST RTRDUE
	MOVE S,TTRACK+6		;REFERENCE DATE
	CAME S,6(Y)
	JRST RTRDUE
	MOVE S,TTRACK+7		;DUMP DATE
	CAME S,7(Y)
	JRST RTRDUE
	MOVSI K,12-DDRET	;SATID, FILE INFO, OFFSET
	MOVEI L,12(Y)
RTRDU1:	MOVE S,(L)
	ADDI L,1
	CAMN S,TTRACK+12(K)
	AOBJN K,RTRDU1
	JUMPL K,RTRDUE
RTRDNU:
>;IFN NEWUFD
	MOVM	S,TTRACK+5	;GET THE WORD COUNT
	MOVN	S,S		;GET - WORD COUNT
;FIRST BLOCK OF A GROUP.
RTRD1:	HLRZ	N,TTRACK+DDRET		;GET RETRIEVAL
	HRRZ	R,R
	CAME	R,N
	JRST	RTRD7			;LOSE BLOCK SHOULD POINT TO SELF
	MOVE	N,[XWD TTRACK,RTSAV]	;SAVE RETRIEVAL OF THIS BLOCK
	BLT	N,RTSAV+WDRTVL-1	;BLT IT OVER.
	SETZM	NFT
	SKIPE	LPTFLG
	RPRINT	TTRACK
;SUBSEQUENT BLOCKS OF A GROUP
RTRD2:	MOVM	L,S			;GET + WD COUNT
	CAILE	L,200*NBPT		;SKIP IF AMOUNT TO GO ≤ 1 TRACK
	MOVEI	L,200*NBPT		;SHORTEN REQUEST
	ADD	S,L			;DECREASE THE -WD COUNT
	AOS	K,NFT			;READ ANOTHER TRACK
	CAIL	K,TRKGRP		;MAKE SURE WE'RE IN GROUP STILL
	JRST	RTRD3			;GO READ FROM ANOTHER GROUP
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	R,TTRACK+DDRET(K)	;GET TRACK NUMBER OF NEXT
	TLNE	L,400000
	HRRZ	R,TTRACK+DDRET(K)	;
	JUMPE	R,RTRD6		;JUMP IF NO MORE TRACKS
	PUSHJ	P,SIZCHK	;CHECK TO MAKE SURE WORD COUNT GREATER THAN 0
	PUSHJ	P,DREAD		;READ SUBSEQUENT TRACK OF A GROUP
	AOS	FSIZE
	MOVE	K,TTRACK
	CAME	K,RTSAV
	JRST	RTRD7		;LOSE  FILE
	HLLZ	K,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	K,L
	JRST	RTRD7		;LOSE  EXT
	MOVE	K,TTRACK+3
	CAME	K,RTSAV+3
	JRST	RTRD7		;LOSE  PPN
	MOVE	K,TTRACK+4
	CAME	K,RTSAV+4
	JRST	RTRD7		;LOSE  DDLOC MISMATCH

;COMPARE ALL RETRIEVAL STARTING WITH WORD 7 (DDMPTM)
;NOTE THAT DREFTM IS NOT SPREAD OVER THE GROUP TO SAVE TIME ON LOOKUP
;ALSO, IT IS CLAIMED THAT THE FILE LENGTH NEED NOT BE CONSISTIENT.
	MOVSI	K,7-WDRTV2		;COMPARE ALL RETRIEVAL
	MOVE	L,TTRACK+7(K)		;LOOK
	CAMN	L,RTSAV+7(K)
	AOBJN	K,.-2			;LOOP
	JUMPL	K,RTRD7			;RTRD BAD RETRIEVAL
	JRST	RTRD2			;GO DEPOSIT THE DATA

RTRD3:	HRRZ	R,TTRACK+11		;GO GET ANOTHER GROUP
	JUMPE	R,RTRD6		;JUMP IF NO MORE GROUPS
	PUSHJ	P,SIZCHK	;CHECK FOR MORE WORDS
	PUSH	P,NRTCHK
	SETZM	NRTCHK
	PUSHJ	P,DREAD
	POP	P,NRTCHK
	AOS	FSIZE
	MOVE	K,TTRACK
	CAME	K,RTSAV
	JRST	RTRD7		;LOSE
	HLLZ	K,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	K,L
	JRST	RTRD7
	MOVE	K,TTRACK+3
	CAMN	K,RTSAV+3
	JRST	RTRD1		;RETRIEVAL IS CONSISTIENT
RTRD7:	PUTSTR	[ASCIZ/
BAD RETRIEVAL AT RTRD7!
SEEK:
/]
	RPRINT	1,RTSAV		;PRINT SHORT RETRIEVAL
	PUTSTR	[ASCIZ/
FIND:
/]
RTRD7A:	RPRINT	TTRACK
	SOS	FSIZE
	SETZ	W,
	SKIPN	SATFLG
	DPB	W,SATBYT
	JRST	RTRD8		;GO REREAD THE BLOCK

IFN NEWUFD,<
RTRDUE:	PUTSTR [ASCIZ /
UFD ENTRY INCONSISTENT AT RTRDUE!
TRACK:
/]
	JRST RTRD7A
>;IFN NEWUFD


RTRD6:	JUMPGE	S,CPOPJ			;RETURN IF WD COUNT DONE
	PUTSTR	[ASCIZ/RTRD6: NO MORE TRACKS AND WORD COUNT UNEXHAUSTED.
/]
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
RTRD8:	TREAD	@LASTOP			;READ TRACK FROM LAST OP ADDRESS
EXAM1:	SKIPN REBLDF		;REBUILD FLAG SET?
	JRST EXAM11		;NO
	PUSH P,W
	PUSH P,X
	MOVE X,RTSAV+3
	CAMN X,['  1  1']
	MOVE X,RTSAV
	MOVE W,[-REBNUM,,REBBUF]
EXAM13:	CAMN X,(W)
	JRST EXAM12		;PPN ALREADY IN LIST
	SKIPE (W)
	AOBJN W,EXAM13
	JUMPGE W,EXAM12
EXAM99:	MOVEM X,(W)
	SETZM 1(W)
EXAM12:	POP P,X
	POP P,W
	POPJ P,

EXAM11:	SKIPE	NOSTOP			;IF SET, DON'T STOP FOR EXCEPTIONS
	POPJ	P,			;DON'T STOP
	SKIPN	JOBDDT			;DO WE HAVE DDT?
	JRST	EXAM2			;NOPE.
	OUTSTR [ASCIZ/EXAMINE CONTENTS OF TTRACK AND TT0.
CONTINUE BY CPOPJ$G.
(YOU'RE IN DDT)
/]
	JRST	@JOBDDT
EXAM2:	OUTSTR [ASCIZ/NO DDT.  TYPE "CON" TO CONTINUE
/]
	HALT	CPOPJ
;DREAD DREAD0 DREAD1 DREAD2
	SUBTTL	DREAD - READ TRACK OR RETRIEVAL
DREAD:	CAMGE	R,MTRACK	;TRACK ADDRESS IN BOUNDS?
	JUMPG	R,DREAD1	;YES
DREAD0:	OUTSTR [ASCIZ/TRACK NUMBER OUT OF BOUNDS AT DREAD!
/]
	SKIPE REBLDF
	PUSHJ P,EXAM1
	SKIPN REBLDF
	HALT	.+1
	SETZM	LASTOP
	POPJ	P,

DREAD1:	MOVEM	R,LASTOP	;SAVE ADDRESS OF LAST OPERATION
	SKIPE	PHI1		;SKIP IF NOT PHASE 1
	PUSHJ	P,MBYTE		;MARK A BYTE IN SAT TABLE!
	SKIPN	FILEON		;SKIP IF READING A WHOLE FILE
	JRST	DREAD2		;JUST READ RETRIEVAL
	TREAD	(R)		;READ
	POPJ	P,		;RETURN
DREAD2:	SKIPE	NRTCHK		;SUPPRESS REDUNDANT DISK OPS?
	POPJ	P,		;YES!
	RREAD	(R)		;READ RETRIEVAL ONLY INTO TTRACK
	POPJ	P,
;MBYTE MBYTE1 SBYTE1 SBYTE
	SUBTTL	SAT TABLE STUFF
;	ASSUME THAT R CONTAINS THE BLOCK NUMBER OF OUR READ

MBYTE:	JSR	REGSAV
	SETZM	SATFLG			;INITIALLY OK.
	PUSHJ	P,SBYTE1		;MAKE A BYTE POINTER TO SAT TABLE
	LDB	X,SATBYT
	JUMPN	X,MBYTE1
	MOVEI	X,1
	DPB	X,SATBYT		;TURN ON A BIT!
	JRST	REGUSV			;RESTORE TO NORMAL
MBYTE1:	SETOM	SATFLG			;ANOUNCE THE HORROR
	PUTSTR	[ASCIZ/
TRACK ALREADY MARKED IN SATTAB!
/]
	RPRINT
	JRST	REGUSV			;RETURN. HE'LL HAVE BAD RETRIEVAL

SBYTE1:	MOVEI	W,-1(R)		;MAP 1→0 ETC.
	IDIVI	W,44		;X IS BIT NUMBER, SORT OF; W IS WORD #
	MOVSI	Y,100
	MOVSI	Z,100
	DPB	X,[POINT 6,Y,5]		;DEPOSIT POSITION FIELD
	DPB	X,[POINT 6,Z,5]		;DEPOSIT POSITION FIELD
	ADDI	Y,SATTAB(W)		;ADD THE DISPLACEMENT
	ADDI	Z,SATBIT(W)		;FOR OUR COPY OF SYSTEM SAT TOO.
	MOVEM	Y,SATBYT		;SAVE AS SAT BYTE POINTER
	MOVEM	Z,SSATBT		;SAVE THIS ONE TOO
	POPJ	P,			;RETURN
SBYTE:	JSR	REGSAV
	PUSHJ	P,SBYTE1
	JRST	REGUSV	
;REGSAV REGUSV SIXOUT SIXOT1 SIXOT2 TYFIL TYPPN TYPPN1 DECOUT OCTOUT OCTOU2 OCTHWT ALLRAD ALLRD1 ALLRD2 TTIME TTIME1 TDATE TDATE1
	SUBTTL	SOME OUTPUT ROUTINES
;SIXOUT: SIXBIT TO ASCII AND TYPE IT.
;DON'T DELETE SPACES, ETC.
;ARGUMENT IN W. ALL REGISTERS ARE PRESERVED

REGSAV:	0		;CALL WITH A JSR
	PUSH	P,W
	PUSH	P,X
	PUSH	P,Y
	PUSH	P,Z
	JRST	@REGSAV
REGUSV:	POP	P,Z	;CALL BY A JRST AT END OF SUBROUTINE, OR PUSHJ
	POP	P,Y
	POP	P,X
	POP	P,W
	POPJ	P,

SIXOUT:	JSR	REGSAV		;SAVE W,X,Y,Z
	PUSHJ	P,SIXOT1	;DO THE REAL WORK
	JRST	REGUSV		;UNSAVE AC'S AND RETURN

SIXOT1:	MOVEI	Z,6		;COUNT SIX CHARACTERS
	MOVE	X,W		
SIXOT2:	SETZ	W,
	LSHC	W,6
	ADDI	W," "
	PUTCHR	W
	SOJG	Z,SIXOT2
	POPJ	P,

TYFIL:	JSR	REGSAV		;SAVE SOME AC'S
	MOVE	W,RTSAV		;GET FILE NAME FROM RTSAV
	PUSHJ	P,SIXOT1	;WRITE IT
	HLLZ	X,RTSAV+1	;GET EXTENSION
	MOVEI	Y,"."
	JUMPN	X,.+2
	MOVEI	Y," "
	PUTCHR	Y
	MOVEI	Z,3
	PUSHJ	P,SIXOT2
	MOVE	W,RTSAV+3
	PUSHJ	P,TYPPN1
	JRST	REGUSV		;RESTORE AC'S AND RETURN

TYPPN:	JSR	REGSAV		;SAVE AC'S
	PUSHJ	P,TYPPN1	;DO THE WORK
	JRST	REGUSV		;RETURN
TYPPN1:	PUSH	P,W		;SAVE W AGAIN
	PUTSTR	[ASCIZ/[/]
	MOVEI	Z,3
	HLLZ	X,W		;GET PROJ PART ONLY
	PUSHJ	P,SIXOT2	;GET DEEP INTO GUTS OF SIXOUT
	POP	P,X		;GET THE PPN BACK
	PUTSTR	[ASCIZ/,/]
	HRLZ	X,X		;GET THE PROG NAME ONLY
	MOVEI	Z,3
	PUSHJ	P,SIXOT2
	PUTSTR	[ASCIZ/]/]
	POPJ	P,


DECOUT:	JSR	REGSAV		;ARG IN W.
	MOVEI	Y,12		;LET Y BE THE RADIX
	MOVEI	Z,0		;NO MINIMUM CHARACTER COUNT
	PUSHJ	P,ALLRAD
	JRST	REGUSV		;RESTORE REGISTERS AND RETURN

OCTOUT:	JSR	REGSAV
	MOVEI	Y,10
	MOVEI	Z,0
	JUMPGE W,OCTOU2		;ALLRAD doesn't work for negative numbers
	PUSH P,W		;  so we make sure it sees only positive ones
	LSH W,-3		;Shift out one octal digit, making W positive
	PUSHJ P,ALLRAD		;Print all but low octal digit
	POP P,W			;Whole number again
	ANDI W,7		;Just low digit for printing to finish number
OCTOU2:	PUSHJ	P,ALLRAD	;Print whole number or just low-order digit
	JRST	REGUSV

OCTHWT:	JSR	REGSAV
	PUSH	P,W
	HLRZ	W,W
	MOVEI	Y,10
	MOVEI	Z,6
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/,,/]
	POP	P,W
	HRRZ	W,W
	MOVEI	Y,10
	MOVEI	Z,6
	PUSHJ	P,ALLRAD
	JRST	REGUSV

ALLRAD:	IDIV	W,Y
	HRLM	X,(P)
	SUBI	Z,1		;DECREMENT Z
	JUMPE	W,ALLRD1
	PUSHJ	P,ALLRAD
ALLRD1:	JUMPLE	Z,ALLRD2
	PUTSTR	[ASCIZ/0/]
	SOJG	Z,.-1
ALLRD2:	HLRZ	W,(P)
	ADDI	W,"0"
	PUTCHR	W
	POPJ	P,

TTIME:	JSR	REGUSV
	PUSHJ	P,TTIME1
	JRST	REGUSV

TTIME1:	IDIVI	W,74		;HOURS IN W,MINUTES IN X
	IMULI	W,144		;HOURS*100 IN W
	ADD	W,X		;WILL BE DECODED AS HHMM
	MOVEI	Z,4		;DEMAND 4 DIGITS
	MOVEI	Y,12		;BASE 10
	JRST	ALLRAD		;DO THE ALLRAD THING, RETURNS WITH POPJ

TDATE:	JSR	REGSAV
	PUSHJ	P,TDATE1
	JRST	REGUSV

TDATE1:	IDIVI	W,37		;GET DAY-1 IN X
	PUSH	P,W
	MOVEI	W,1(X)
	MOVEI	Y,12
	MOVEI	Z,2
	PUSHJ	P,ALLRAD
	PUTSTR	[ASCIZ/-/]
	POP	P,W
	IDIVI	W,14		;MONTH-1 IN X
	PUTSTR	MONTAB(X)	;TYPE 3 LETTERS OF MONTH AND -
	ADDI	W,100
	MOVEI	Z,2
	JRST	ALLRAD		;TYPE YEAR AND RETURN
;UHELP UH1 UH2 UH3 UNOMFD UH4 UH5 UH6 UHFILE UH7 UH8 UH9 UH8A UH8B UH8C UH10 UH10A UALLFL UALLF1 UALLF2 ALLSER ALSR1 ALSR2 SATCHK ALSR4 ALSR3 RECOV RECOV1 RECOV2 RECOV3 RECOVX FIXUFD UFDENT
	SUBTTL	UHELP	HELP A USER
UHELP:	OUTSTR [ASCIZ/
USER NAME = /]
	SETZM	THSPPN
	PUSHJ	P,GPPN		;READ A PPN FROM THE TTY
	CAIE	A,"$"
	CAIN	A,175
	PUSHJ	P,DDTGO
	SKIPN	THSPPN
	POPJ	P,		;RETURN TO OUTER LEVEL.
	MOVE A,SAVFF
	MOVEM A,JOBFF
	MOVE	A,['  1  1']
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV+3
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	MOVEI	R,1
	PUSHJ	P,FREAD		;READ THE MFD
	MOVE	A,DIOWD
	MOVEM	A,MFDPTR	;SAVE POINTER TO MFD!
	AOJGE	A,UNOMFD	;EMPTY MFD!
	MOVE	B,THSPPN	;LOOKING FOR PARTICULAR UFD
	CAMN	B,['  1  1']	;SPECIAL HACK FOR 1,1
	JRST	UH2		;
UH1:	CAME	B,(A)		;LOOK
	JRST	UH3
	HLRZ	C,1(A)
	CAIE	C,'UFD'
	JRST	UH3
	SKIPA	A,3(A)		;GET THE TRACK ADDRESS
UH2:	MOVEI	A,1		;FAKE FOR 1,1
	JRST	UH4		;OK
UH3:	ADD	A,[XWD UFDN,UFDN]
	JUMPL	A,UH1
	OUTSTR [ASCIZ/UFD NOT FOUND FOR THIS PPN
/]
	JRST	UHELP
UNOMFD:	OUTSTR [ASCIZ/THE MFD APPEARS TO BE EMPTY!
FIND A WIZARD, QUICK!
/]
	HALT	DDTGO

UH4:	MOVEM	A,UFDADR		;SAVE ADDRESS OF THIS UFD
	CAIE	A,1			;IS THIS THE MFD?
	JRST	UH5			;NOPE.
	MOVE	A,MFDPTR		;GET THE MFD POINTER
	MOVEM	A,UFDPTR		;SAVE AS THE UFD POINTER
	JRST	UH6			;ALL SET
UH5:	MOVE	R,A			;GET THE ADDRESS
	MOVE	A,THSPPN
	MOVEM	A,RTSAV
	MOVSI	B,'UFD'
	MOVEM	B,RTSAV+1
	MOVE	A,['  1  1']
	MOVEM	A,RTSAV+3
	PUSHJ	P,FREAD			;READ THE ENTIRE UFD
	MOVE	A,DIOWD			;GET THE IOWD
	MOVEM	A,UFDPTR		;SAVE
UH6:	OUTSTR [ASCIZ/A PARTICULAR FILE NAME, OR CR FOR ALL FILES: /]
	PUSHJ	P,GETFIL	;GET A FILE NAME
	JRST	UALLFL		;CHECK ALL OF A USER'S FILES
;	A PARTICULAR FILE...
UHFILE:	MOVE	D,UFDPTR	;GET POINTER TO UFD
	AOJL	D,UH7
	OUTSTR [ASCIZ/THIS UFD IS EMPTY!
/]
	PUSHJ	P,GO.ON		;ASK ABOUT CONTINUING
	JRST	UHELP
	JRST	ALLSER		;SEARCH WHOLE DISK FOR THIS GUY'S FILES

UH7:	MOVE	A,THSFIL
	MOVE	B,THSEXT
UH8:	CAME	A,(D)
	JRST	UH9
	HLLZ	C,1(D)
	CAMN	B,C
	JRST	UH10
UH9:	ADD	D,[XWD UFDN,UFDN]
	JUMPL	D,UH8			;LOOP
	OUTSTR [ASCIZ/FILE NOT FOUND IN THE UFD.
DO YOU WANT TO LOOK THROUGH THE HOLES IN THE UFD? /]
	PUSHJ	P,YORN
	JRST	UHELP
	MOVE	D,UFDPTR		;LOOK
	ADDI	D,1
UH8A:	SKIPN	(D)			;SKIP IF ENTRY NOT EMPTY
	SKIPG	A,3(D)			;GET THE OLD POINTER, IF ANY
	JRST	UH8B			;NOT EMPTY, NO POINTER
	RREAD	(A)			;READ RETRIEVAL
	MOVE	A,TTRACK
	HLLZ	B,TTRACK+1
	CAMN	A,THSFIL
	CAME	B,THSEXT
	JRST	UH8B			;LOSER
	MOVE	A,TTRACK+DDPPN		;
	CAME	A,THSPPN
	JRST	UH8B			;LOSE
	HRRZ	A,3(D)			;GET THE TRACK ADDRESS
	MOVEM	A,LSTRD			;SAVE AS ADDRESS OF LAST READ OP.
	OUTSTR [ASCIZ/I THINK I'VE GOT IT:
/]
	RPRINT	TTRACK
	OUTSTR [ASCIZ/DO YOU WANT THIS FILE BACK (TYPE Y),
ELSE, LOOK FOR ANOTHER? /]
	PUSHJ	P,YORN
	JRST	UH8B
	JRST	RECOV

UH8B:	ADD	D,[XWD UFDN,UFDN]
	JUMPL	D,UH8A
UH8C:	OUTSTR [ASCIZ/FILE DOES NOT EXIST IN DIRECTORY.
WANT TO LOOK THRU THE WHOLE DISK?  /]
	PUSHJ	P,YORN
	JRST	UHELP
	JRST	ALLSER			;LOOK AROUND FOR IT

UH10:	MOVE	R,3(D)			;GET THE FILE ADDRESS
	MOVEM	A,RTSAV
	MOVEM	B,RTSAV+1
	MOVE	A,THSPPN
	MOVEM	A,RTSAV+3
	CAML	R,MTRACK
	JRST	UH8C
	JUMPLE	R,UH8C
	PUSHJ	P,RTRD			;CHECK ALL RETRIEVAL
	OUTSTR [ASCIZ/DONE. THIS FILE APPEARS TO BE NORMAL.
/]
	RPRINT
	OUTSTR [ASCIZ/DO YOU WANT TO LOOK FOR SOME OTHER VERSION
OF THIS FILE? /]
	PUSHJ	P,YORN
	JRST	UH10A
	OUTSTR [ASCIZ/CONTINUING THROUGH THIS UFD.
/]
	JRST	UH9		;CONTINUE
UH10A:	OUTSTR [ASCIZ/
ANOTHER FILE NAME, ↑C TO QUIT, OR CR FOR ANOTHER USER: /]
	PUSHJ	P,GETFIL
	JRST	UHELP
	JRST	UHFILE

UALLFL:	MOVE	D,UFDPTR
	AOJL	D,UALLF1	;MAKE AOBJN POINTER
	OUTSTR [ASCIZ/THIS UFD IS EMPTY!
/]
	JRST	UHELP

UALLF1:	SKIPN	A,(D)
	JRST	UALLF2		;NO FILE IN THIS SLOT
	MOVEM	A,RTSAV
	HLLZ	A,1(D)
	MOVEM	A,RTSAV+1
	MOVE	A,THSPPN
	MOVEM	A,RTSAV+DDPPN
	HRRZ	R,3(D)
	PUSHJ	P,RTRD		;READ RETRIEVAL
UALLF2:	ADD	D,[XWD UFDN,UFDN]
	JUMPL	D,UALLF1
	OUTSTR [ASCIZ/DONE.
/]
	JRST	UHELP		;ALL DONE

ALLSER:	OUTSTR [ASCIZ/LOOKING THROUGH THE DISK.....
/]
	MOVE	A,THSFIL
	MOVEM	A,RTSAV		;SAVE THE FILE NAME WE WANT
	HLLZ	B,THSEXT
	HLLZM	B,RTSAV+1	;SAVE THE EXTENSION
	MOVE	C,THSPPN	;GET THE PPN
	MOVEM	C,RTSAV+3	;SAVE THE PPN
	MOVEI	R,1
	SUB	R,MTRACK
	MOVSI	R,(R)
	HRRI	R,1		;AOBJN POINTER TO DISK TRACKS
ALSR1:	PUSHJ	P,SATCHK	;CHECK TO SEE IF THIS IS FREE IN SAT TABLE
	JRST	ALSR2		;NOT FREE.
	RREAD	(R)		;READ RETRIEVAL OF THIS TRACK
	CAMN	A,TTRACK+DDNAM
	CAME	C,TTRACK+DDPPN
	JRST	ALSR2		;NOT THIS ONE
	HLLZ	D,TTRACK+DDEXT	;GET THE EXTENSION
	CAMN	B,D		;CHECK
	JRST	ALSR3		;
ALSR2:	AOBJN	R,ALSR1		;LOOP
	PUTSTR	[ASCIZ/NO SUCH FILE, ANYWHERE ON THIS DISK, THAT I CAN FIND.
/]
	JRST	UHELP		;GO AND WEEP.
SATCHK:	PUSHJ	P,SBYTE		;COMPUTE BYTE POINTER
	LDB	D,SSATBT	;GET BYTE FROM SYSTEM SAT TABLE
	JUMPE	D,CPOPJ1	;SKIP RETURN FOR UNCLAIMED.
	POPJ	P,

ALSR4:	PUTSTR	[ASCIZ/INCONSISTIENT RETRIEVAL.
PART OF THIS FILE HAS BEEN CLOBBERED ALREADY.
YOU'LL HAVE TO TRY BY HAND.
/]
	HALT	ALSR2		;LOOP

ALSR3:	PUTSTR	[ASCIZ/IS THIS IT?
/]
	RPRINT	TTRACK
	PUTSTR	[ASCIZ/TYPE Y TO RECOVER THIS VERSION: /]
	PUSHJ	P,YORN
	JRST	ALSR2		;TRY SOME MORE.
	PUSH	P,R		;SAVE R
	MOVE	A,TTRACK+DDLOC
	TREAD	(A)
	HRRZM	A,LSTRD		;SAVE ADDRESS OF LAST TRACK READ.
	MOVE	A,THSFIL
	HLLZ	B,THSEXT
	MOVE	C,THSPPN
	CAMN	A,TTRACK+DDNAM
	CAME	C,TTRACK+DDPPN
	JRST	ALSR4
	HLLZ	D,TTRACK+DDEXT
	CAME	B,D
	JRST	ALSR4

RECOV:	MOVEI	A,17
	MOVE	B,DEFDEV
	MOVEI	C,0
	OPEN	FILE,A
	JRST	NODISK
	PUTSTR	[ASCIZ/OUTPUT FILE WILL HAVE THE ORIGINAL NAME AND .XX0 EXTENSION.
/]
	MOVEI	A,'XX0'
	MOVSM	A,OUTEXT
RECOV1:	MOVE	A,THSFIL
	HLLZ	B,OUTEXT
	SETZ	C,
	MOVE	D,THSPPN
	ENTER	FILE,A		;ATTEMPT TO ENTER USING THE FILE SYSTEM
	JRST	[PUTSTR	[ASCIZ/ENTER FAILED. WILL INCREMENT THE EXTENSION.
/]
		MOVSI	A,1
		ADDM	A,OUTEXT
		JRST	RECOV1]
	TREAD	@LSTRD		;READ THE LAST TRACK
	MOVE	A,TTRACK+DDLNG	;GET FILE LENGTH
	MOVEM	A,THSLNG	;SAVE LENGTH
	SETZM	THSTRK		;INDEX TO THIS TRACK IN THIS GROUP
RECOV2:	MOVE	A,THSFIL
	MOVE	C,THSPPN
	CAMN	A,TTRACK+DDNAM
	CAME	C,TTRACK+DDPPN
	JRST	RECOVX
	HLLZ	D,TTRACK+DDEXT
	CAME	D,THSEXT
	JRST	RECOVX
	MOVE	A,THSLNG	;GET THE LENGTH
	CAILE	A,NBPT*200	;IS THE SIZE LESS THAN A TRACK?
	MOVEI	A,NBPT*200	;NO. THIS IS ALL THE DATA WE HAVE RIGHT NOW.
	MOVN	A,A		;NEGATE THE WORD COUNT
	ADDM	A,THSLNG	;DECREMENT THE REMAINING LENGTH
	HRLZ	A,A		;GET THE -WC IN THE LEFT
	HRRI	A,TT0-1		;AND MA-1 IN THE RIGHT
	SETZ	B,
	OUTPUT	FILE,A		;DO A DUMP MODE OUTPUT
	SKIPE	THSLNG
	JRST	RECOV3		;HAVE TO GET MORE TRACKS
	CLOSE	FILE,
	RELEAS	FILE,
	PUTSTR	[ASCIZ/YOU WIN, I THINK.
/]
	JRST	UHELP		;DONE.

RECOV3:	AOS	A,THSTRK	;INCREMENT TRACK NUMBER.
	CAIL	A,TRKGRP	;STILL INSIDE THIS GROUP?
	JRST	[MOVE	A,TTRACK+DNXTGP	;READ FROM INDICATED NEXT GROUP
		RREAD	(A)
		SETZB	A,THSTRK	;ZERO INDICIES
		JRST	.+1]		;BACK TO MAIN STREAM
	LSHC	A,-1		;SHIFT TO DIVIDE BY 2
	HRRZ	C,TTRACK+DDRET(A) ;ASSUME ODD
	JUMPL	B,.+2
	HLRZ	C,TTRACK+DDRET(A) ;IT WAS EVEN
	TREAD	(C)		;READ THE TRACK
	JRST	RECOV2

RECOVX:	PUTSTR	[ASCIZ/INCONSISTIENT RETRIEVAL.
ANY PARTS OF THE FILE THAT HAVE BEEN RECOVERED HAVE BEEN WRITTEN
/]
	CLOSE	FILE,
	RELEAS	FILE,
	JRST	UHELP

FIXUFD:	MOVE A,TTRACK
	MOVEM A,UFDENT
	MOVE A,TTRACK+1
	MOVEM A,UFDENT+1
	MOVE A,TTRACK+2
	MOVEM A,UFDENT+2
	MOVE A,TTRACK+DDLOC
	MOVEM A,UFDENT+3
	MOVE A,TTRACK+DDLNG
	MOVEM A,UFDENT+4
	SETZM UFDENT+5		;FIX THIS
	MOVE A,TTRACK+DREFTM
	MOVEM A,UFDENT+6
	MOVE A,TTRACK+DDMPTM
	MOVEM A,UFDENT+7
	SETZM UFDENT+10
	SETZM UFDENT+11
	MOVE A,SATID
	MOVEM A,UFDENT+12
	MOVE A,TTRACK+DQINFO
	MOVEM A,UFDENT+13
	MOVE A,TTRACK+DQINFO+1
	MOVEM A,UFDENT+14
	MOVE A,TTRACK+DQINFO+2
	MOVEM A,UFDENT+15
	MOVE A,TTRACK+DQINFO+3
	MOVEM A,UFDENT+16
	MOVE A,TTRACK+DOFFST
	MOVEM A,UFDENT+17
	RREAD @UFDADR		;READ THE UFD'S RETRIEVAL
	HRRZ A,D		;ADDR IN CORE OF UFD ENTRY
	HRRZ B,UFDPTR
	SUBI A,1(B)		;ADDR RELATIVE TO START OF UFD
	IDIVI A,DWDTRK		;A IS TRACK # IN FILE, B IS WORD IN TK
	MOVE C,B		;WD IN TRACK
	TRNE C,UFDN-1		;MULTIPLE OF 20?  (UFDN MUST BE ONE BIT!)
	 HALT .			;NO, SOMETHING WRONG
	MOVEI B,0
	LSHC A,-1		;FIND CORRECT 1/2 WD IN RETRIEVAL
	MOVE A,TTRACK+DDRET(A)	;GET TWO TRACK ADDRS FROM RETRIEVAL
	JUMPN B,.+2
	MOVSS A			;IF FIRST TK, GET IT IN RIGHT HALF
	TREAD (A)		;READ THE UFD TRACK
	MOVEI B,TT0(C)		;WORD IN CORE FOR START OF ENTRY
	MOVE C,3(B)		;GET DDLOC FROM EXISTING UFD ENTRY
	CAME C,UFDENT+3		;SEE IF IT AGREES WITH OUR NEW ONE
	 HALT .			;NOPE
	MOVEI C,17(B)		;END OF BLT
	HRLI B,UFDENT		;SOURCE OF DATA
	BLT B,(C)		;INTO UFD
	TWRITE (A)		;ON THE DISK
	POPJ P,			;CONTINUE THE SCAN

UFDENT:	BLOCK UFDN
;GPPN ILLPPN GPPN1 GETSIX GETSX1 GETSX2 GETSX3 GETFIL GETFL1 GETFL2 GETFL0 RJUST GO.ON YORN
	SUBTTL	GPPN,GETFIL,GETSIX

GPPN:	PUSHJ	P,GETSIX		;GET SIXBIT INTO B. DELIM IN A
	JUMPE	B,CPOPJ			;SO CRLF WILL GET PAST.
	CAIE	A,","
	CAIN	A,"/"
	JRST	GPPN1			;OK SO FAR.
ILLPPN:	OUTSTR [ASCIZ/ILLEGAL PPN. TRY AGAIN
/]
	CLRBFI
	JRST	GPPN
GPPN1:	HLRZ	B,B			;GET THE LEFT SIDE ONLY
	PUSHJ	P,RJUST			;RIGHT JUSTIFY
	HRLZ	D,B			;SAVE PROJ PART IN D
	PUSHJ	P,GETSIX		;GET MORE
	CAIE	A,12
	CAIN	A,175
	JRST	.+2
	JRST	ILLPPN			;LOSER
	HLRZ	B,B
	PUSHJ	P,RJUST
	HRR	D,B			;GET THE WHOLE PPN
	MOVEM	D,THSPPN		;SAVE AS THE PPN OF INTEREST
	POPJ	P,

GETSIX:	SETZB	B,QMODE			;B ACCUMULATES, QUOTE MODE
	MOVE	C,[POINT 6,B]
GETSX1:	INCHWL A
	CAIE	A,1			;↑A = DOWN ARROW IS ESCAPE CHARACTER
	JRST	GETSX2			;NOT THE QUOTE CHARACTER
	SETCMM	QMODE			;COMPLEMENT QUOTE FLAG
	JRST	GETSX1			;GOBBLE MORE
GETSX2:	SKIPE	QMODE
	JRST	GETSX3			;TAKE A CHARACTER LITERALLY
	CAIE	A,175			;ALT-MODE OR DOLLAR SIGN?
	CAIN	A,"$"
	POPJ	P,			;YES. LET IT UP.
	CAIE	A," "
	CAIN	A,15
	JRST	GETSX1			;FLUSH BLANK, CRLF
	CAIE	A,"."
	CAIN	A,","
	POPJ	P,			;TERMINATOR
	CAIE	A,12
	CAIN	A,"/"
	POPJ	P,			;TERMINATOR
GETSX3:	CAIL	A,"a"
	CAILE	A,"z"
	SUBI	A," "
	TRZ	A,100			;FOR LOWERCASE, JUST TURN OFF 100
	TLNE	C,770000		;OVERFLOW OF BYTE?
	IDPB	A,C			;NO DEPOSIT THE BYTE
	JUMPL	A,CPOPJ			;RETURN IF WE JUST LOST!
	JRST	GETSX1			;LOOP

GETFIL:	PUSHJ	P,GETSIX		;LOOK FOR A FILE NAME
	MOVEM	B,THSFIL		;SAVE IT
	JUMPE	B,GETFL0
	SETZM	THSEXT			;ZERO EXTENSION
	CAIE	A,"."
	JRST	GETFL1			;DONE?
	PUSHJ	P,GETSIX
	HLLZM	B,THSEXT		;SAVE
GETFL1:	CAIN	A,12
	JRST	CPOPJ1
GETFL2:	OUTSTR [ASCIZ/ILLEGAL FILE NAME
TRY AGAIN: /]
	JRST	GETFIL
GETFL0:	CAIN	A,12
	POPJ	P,			;HE TYPED CR
	JRST	GETFL2

RJUST:	JUMPE	B,CPOPJ
	TRNE	B,77
	POPJ	P,
	LSH	B,-6
	JRST	.-3

GO.ON:	OUTSTR [ASCIZ/TYPE Y TO GO ON: /]
YORN:	INCHWL A
	CLRBFI
	CAIE	A,"Y"
	CAIN	A,"y"
	AOS	(P)
	POPJ	P,

;HACK: SEARCH PACK 5 AND COPY FILES TO 4-PACKS. 17 FEB 1973
REPEAT 0,<
HACK:	INIT	17,17				
	'DSK   '
	0
	HALT	HACK
	INIT	16,617				;LONG ENTER MODE.
	'DSK   '
	0
	HALT	HACK

	MOVE	R,[-=7600,,73300]		;AOBJN POINTER TO PACK 5
HACK0:	MOVE	A,SATID				;GET THE VALID SATID
HACK1:	RREAD	(R)				;READ RETRIEVAL
	CAMN	A,TTRACK+DSATID
	JRST	HACK3
HACK2:	AOBJN	R,HACK1
	PUTSTR	[ASCIZ/DONE
/]
	POPJ	P,


HACK3:	MOVE	A,TTRACK+DDNAM
	MOVE	B,TTRACK+DDEXT
	MOVE	D,TTRACK+DDPPN
	LOOKUP	17,A
	JRST	HACK6				;LOOKUP FAILURE.
	MOVS	D,D
	MOVN	D,D
	CAMN	D,TTRACK+DDLNG			;CHECK LENGTH
	CAME	C,TTRACK+DDPRO			;CHECK DATE, MODE, ETC.
	JRST	HACK9				;BAD RETRIEVAL
	CAME	B,TTRACK+DDEXT
	JRST	HACK9
	MOVE	D,[TTRACK+DDNAM,,A]
	BLT	D,D
	MOVE	W,TTRACK+DREFTM
	MOVE	X,TTRACK+DDMPTM
	ENTER	16,A
	JRST	HACK5				;ENTER FAILURE.
	MOVE	S,TTRACK+DDLNG			;GET FILE LENGTH
HACK4:	MOVEI	A,(S)
	CAILE	A,4400				;SMALL ENOUGH TO FIT IN TT0?
	MOVEI	A,4400
	SUBI	S,(A)
	MOVNI	A,(A)
	MOVSI	A,(A)
	HRRI	A,TT0-1
	MOVEI	B,0
	INPUT	17,A
	STATZ	17,740000
	JRST	HACK7				;INPUT ERROR
	OUTPUT	16,A
	STATZ	16,740000
	JRST	HACK8
	JUMPG	S,HACK4
	CLOSE	17,
	CLOSE	16,
	MOVE	A,SATID
	JRST	HACK2

HACK5:	PUTSTR	[ASCIZ/ENTER FAILED/]
	CLOSE	17,
	JRST	HACKER
HACK6:	PUTSTR	[ASCIZ/LOOKUP FAILURE/]
	JRST	HACKER

HACK7:	PUTSTR	[ASCIZ/INPUT ERROR/]	;INPUT ERROR
	JRST	HACKER
HACK8:	PUTSTR	[ASCIZ/OUTPUT ERROR/]	;OUTPUT ERROR
	JRST	HACKER
HACK9:	PUTSTR	[ASCIZ/BLOCK'S RETRIEVAL AND LOOKUP'S RETRIEVAL DISAGREE./]
HACKER:	PUTSTR	CRLF
	MOVEI	C,TTRACK
	MOVE	W,DDNAM(C)	;GET THE NAME
	JRST	HKR1		;BLANK NAME
	PUSHJ	P,SIXOT1	;TYPE NAME
	HLLZ	X,DDEXT(C)	;GET THE EXTENSION
	MOVEI	Z,3		;3 CHARACTERS ONLY
	JUMPE	X,HKR1		;JUMP IF NO EXTENSION
	PUTSTR	[ASCIZ/./]
	PUSHJ	P,SIXOT2	;TYPE IT
HKR1:	MOVE	W,DDPPN(C)	;GET THE PPN
	PUSHJ	P,TYPPN1	;TYPE IT
	HALT	.+1
	MOVE	A,SATID
	JRST	HACK2
>

;OLDIOP OLDSRC OLDOOP OLDDST SRCPAK DSTPAK SRCTRK DSTTRK PACK12 PACK13 PACKST PACK24 ENTLUZ NOOPEN PACKCF PACKCE PACKGO PACKG3 PACKG2 PACKCL PACKUP PACKU1 PACKU1 PACKC1 PACKCA PK1V PK1V1 PACKC2 PACKCB PK2V PK2V1 PACKUP PACKU1 PKMES

;PACK-TO-PACK COPY FOR UNIFORM COMPOSITION SYSTEM.
;PACKUP,PACKC1,PACKC2,PACK12,PACK34.

OLDIOP:	217	;Source UDP OPEN block
OLDSRC:	'UDP2  '
	0

OLDOOP:	217	;Dest UDP OPEN block
OLDDST:	'UDP1  '
	0

;The next four parameters are computed at runtime.
SRCPAK:	NPACK+1	;Pack number of source pack
DSTPAK:	NPACK	;Pack number of dest pack
SRCTRK:	<NPACK+1>*NTPP	;First track on source pack
DSTTRK:	NPACK*NTPP 	;First track on dest pack


;PACK13 and PACK34 are routines to copy between two UDP drives, e.g.,
;for making pack copies of system disks (running sys with at least 4 UDPs).
;PACK12 is version that can be used while running sys with only 2 UDPs.
;All of these can be done with the system up (and/or other jobs running)
;since no one else can use these UDPs at the same time.  The UDPs are
;used in OLD mode.

;Start here to copy UDP2 to UDP1 (uses both controllers for one copy)
PACK12:	MOVE A,['2  1  ']
	JRST PACKST

;Start here to copy UDP3 to UDP1 (on one controller)
PACK13:	MOVE A,['3  1  ']
PACKST:	HLRM A,OLDSRC	;Store unit number of source UDP
	HRRM A,OLDDST	;Store unit number of destination UDP
	JRST PACKGO

;Start here to copy UDP4 to UDP2 (on other controller)
PACK24:	MOVE A,['4  2  ']
	JRST PACKST

ENTLUZ:	PUTSTR [ASCIZ /ENTER failed to get write access to destination UDP.
Stick pack password into OLDPAS and type $P to try again.
/]
	PUSHJ P,DDTCAL
	JRST PACKGO	;Try again

NOOPEN:	PUTSTR [ASCIZ /OPEN failed on some UDP!

/]
	JRST PACKGO	;Let him try again

PACKCF:	PUTSTR [ASCIZ /Don't use UDPn as LOGICAL name of another device!

/]
	JRST PACKGO

PACKCE:	PUTSTR [ASCIZ /Some UDP not assigned as OLD!

/]
PACKGO:	PUTSTR	[ASCIZ \PACK COPY between UDPs using OLD format UDP I/O with system up.
\]
	MOVEI A,[RADIX50 0,FPACKS↔0]
	.SYML A,
	 JRST PACKG3		;Force compare failure for uuo failure
	CAIN A,NPACK		;Make sure system and I agree on number of packs
	JRST PACKG2		;OK, we agree
	OUTSTR [ASCIZ/***
THE SYSTEM AND I DISAGREE ABOUT HOW MANY SYSTEM PACKS THERE ARE!!
Fix one of us so that my NPACK matches system's FPACKS.
***
(Or type CONTINUE to ignore that problem and go on; you better know what's up.)
***/]
	EXIT 1,
	JRST PACKG2		;Well, give it a try, he says

PACKG3:	OUTSTR [ASCIZ/***
Can't check to make sure my NPACK (/]
	MOVEI W,NPACK
	PUSHJ P,OCTOUT		;Print my NPACK
	OUTSTR [ASCIZ/) matches system's FPACKS (maybe no exec DDT?)!
If you're sure they match, type CONTINUE to go on.
***/]
	EXIT 1,			;Stop and let him decide, go on if he says so
PACKG2:	PUTSTR [ASCIZ/Copying from /]
	MOVE W,OLDSRC		;Source device
	PUSHJ P,SIXOUT		;type dev name
	PUTSTR [ASCIZ/ to /]
	MOVE W,OLDDST		;dest device
	PUSHJ P,SIXOUT		;type dev name
	PUTSTR [ASCIZ/ with system up.

Begin with ASSIGN OLD /]
	MOVE W,OLDDST
	PUSHJ P,SIXOUT		;type dest UDP name
	PUTSTR [ASCIZ/ and ASSIGN OLD /]
	MOVE W,OLDSRC
	PUSHJ P,SIXOUT		;type source UDP name
	PUTSTR [ASCIZ/

Then type CONTINUE./]
	EXIT 1,
	MOVE A,OLDDST
	PNAME A,
	 JRST PACKCE		;No such device
	MOVE B,OLDSRC
	PNAME B,
	 JRST PACKCE		;No device
	CAMN A,OLDDST
	CAME B,OLDSRC
	JRST PACKCF		;Some UDP is a logical name of some other device!
	DEVUSE A,
	DEVUSE B,
	HLRZ A,A		;Ignore people waiting for UDP
	HLRZ B,B
	PJOB R,
	CAIN A,442000(R)	;Must be Assigned Private or Old by me, not INITed
	CAIE B,442000(R)
	JRST PACKCE
	OPEN OLDI,OLDIOP	;open source UDP on input channel
	 JRST NOOPEN
	OPEN OLDO,OLDOOP	;Open dest UDP on output channel
	 JRST NOOPEN
	MOVEI A,OLDI
	DEVCHR A,
	MOVEI B,OLDO
	DEVCHR B,
	HLRZ A,A
	HLRZ B,B
	CAIN A,101047
	CAIE B,101047	;Should be UDP, not new mode, long-dispatch, avail, I/O, dir
	JRST PACKCE	;Well, that's strange, could that number be wrong?
	MOVEI A,OLDI	;Input channel number
	DEVNUM A,	;Get UDP unit number
	ADDI A,NPACK-1	;Convert to pack number
	MOVEM A,SRCPAK	;Save input pack number
	IMULI A,NTPP	;Make number of first track on pack
	MOVEM A,SRCTRK	;Remember first source track
	MOVEI B,OLDO	;Output channel number
	DEVNUM B,	;Get UDP unit number
	ADDI B,NPACK-1	;Convert to pack number
	MOVEM B,DSTPAK	;Save output pack number
	IMULI B,NTPP	;Make number of first track on pack
	MOVEM B,DSTTRK	;Remember first dest track
	PUTSTR [ASCIZ/
Mount the SOURCE (old) pack at drive # /]
	MOVE	W,SRCPAK	;Source pack number
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE LOCKED.
Mount the DESTINATION (new) pack at drive # /]
	MOVE	W,DSTPAK	;Dest pack number
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE ENABLED.
Verify that both of those drives are for UDPs.
Then type CONTINUE./]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	PUSH P,UDPONL
	SETOM UDPONL			;ONLY ALLOW OPERATION ON UDP

;Here we try to guarantee success of the ENTER below by clearing last track of
;destination UDP before ENTERing it (using normal DSK RWRITE to that track).
	SETZM TTRACK		;Clear retrieval area
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDRTVL-1	;Zero it all
	MOVE A,DSTTRK		;First trk on dest pack
	RWRITE NTPP-1(A)	;Write zero retrieval on last track of destination

	ENTER OLDO,OLDPAS
	 JRST ENTLUZ		;Need password
	OUTSTR [ASCIZ/Here we go, by cylinders.../]
	MOVSI R,-NCYL		;-COUNT OF CYLINDERS PER PACK
PACKCL:	MOVEI C,(R)		;Cylinder
	IMULI C,NTPC		;Convert cylinder number to track number
	MOVEM C,OLDCYL+1	;Store disk address for read and write
	IN OLDI,OLDCYL		;Read a cylinder
	 CAIA			;OK
	JSR DISERR		;THERE'S SOME SORT OF ERROR
	OUT OLDO,OLDCYL		;Write at same disk address on different pack!
	 CAIA			;OK
	JSR DISERR		;Some error
	AOBJN R,PACKCL
	RELEAS OLDI,
	RELEAS OLDO,
	PUTSTR [ASCIZ/DONE
/]
	POP P,UDPONL
	POP P,UDPOK			;RESTORE STATE
	JRST DDTCALL

REPEAT 1,<
PACKUP:	PUTSTR	[ASCIZ /PACK COPY, USING ONLY ONE CONTROLLER.
MOUNT THE SOURCE (OLD) PACK AT PACK # /]
	MOVEI W,NPACK		;COUNTS FROM ZERO
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE LOCKED.
MOUNT THE DESTINATION (NEW) PACK AT PACK # /]
	MOVEI	W,NPACK+1
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE ENABLED.
THEN TYPE CONTINUE.
/]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
REPEAT 0,<	;Old one track at a time version
	MOVSI	R,-NTPP			;-COUNT OF TRACKS/PACK
PACKU1:	TREAD	NTPP*<NPACK>(R)		;READ DATA
	TWRITE	NTPP*<NPACK+1>(R)	;WRITE DATA
>;REPEAT 0
	MOVSI	R,-NCYL			;-COUNT OF CYLS/PACK
PACKU1:	CREAD	NCYL*<NPACK>(R)		;READ A CYLINDER
	CWRITE	NCYL*<NPACK+1>(R)	;WRITE A CYLINDER
	AOBJN	R,PACKU1
	PUTSTR	[ASCIZ/DONE
/]
	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL
	POPJ P,
>;END REPEAT

PACKC1:	PUTSTR	[ASCIZ /PACK COPY USING TWO CONTROLLERS: CONTROLLER A.
MOUNT THE SOURCE (OLD) PACK AT PACK # /]
	MOVEI W,NPACK-2		;COUNTS FROM ZERO
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE LOCKED.
MOUNT THE DESTINATION (NEW) PACK AT PACK # /]
	MOVEI	W,NPACK
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE ENABLED.
THEN TYPE CONTINUE.
/]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	MOVSI	R,-NTPP			;-COUNT OF TRACKS/PACK
PACKCA:	TREAD	NTPP*<NPACK-2>(R)	;READ DATA
	TWRITE	NTPP*<NPACK>(R)		;WRITE DATA
REPEAT 0,<	;Disable verify.
	MOVE A,[TTRACK,,TTRK2]
	BLT A,TTRK2+WDTRK-1		;SAVE OLD DATA
	TREAD	NTPP*<NPACK>(R)		;READBACK NEW TO VERIFY
	MOVSI B,-WDTRK			;VERIFY LOOP
PK1V:	MOVE A,TTRACK(B)
	CAME A,TTRK2(B)
	HALT .
	AOBJN B,PK1V
>;REPEAT 0
REPEAT 0,<	;Why read the old track again?
	MOVE A,[TTRACK,,TTRK2]
	BLT A,TTRK2+WDTRK-1		;SAVE NEW DATA
	TREAD	NTPP*<NPACK-2>(R)	;READBACK OLD (!) TO VERIFY
	MOVSI B,-WDTRK			;VERIFY LOOP
PK1V1:	MOVE A,TTRACK(B)
	CAME A,TTRK2(B)
	HALT .
	AOBJN B,PK1V1
>;REPEAT 0
	AOBJN	R,PACKCA
	PUTSTR	[ASCIZ/DONE
/]
	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL
	POPJ P,

PACKC2:	PUTSTR	[ASCIZ /PACK COPY USING TWO CONTROLLERS: CONTROLLER B.
MOUNT THE SOURCE (OLD) PACK AT PACK # /]
	MOVEI	W,NPACK-1		;COUNTS FROM ZERO
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE LOCKED.
MOUNT THE DESTINATION (NEW) PACK AT PACK # /]
	MOVEI	W,NPACK+1
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE ENABLED.
THEN TYPE CONTINUE.
/]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	MOVSI	R,-NTPP			;-COUNT OF TRACKS/PACK
PACKCB:	TREAD	NTPP*<NPACK-1>(R)	;READ DATA
	TWRITE	NTPP*<NPACK+1>(R)	;WRITE DATA
REPEAT 0,<	;Disable verify
	MOVE A,[TTRACK,,TTRK2]
	BLT A,TTRK2+WDTRK-1		;SAVE OLD DATA
	TREAD	NTPP*<NPACK+1>(R)	;READBACK TO VERIFY
	MOVSI B,-WDTRK			;VERIFY LOOP
PK2V:	MOVE A,TTRACK(B)
	CAME A,TTRK2(B)
	HALT .
	AOBJN B,PK2V
>;REPEAT 0
REPEAT 0,<	;Why read the old track again?
	MOVE A,[TTRACK,,TTRK2]
	BLT A,TTRK2+WDTRK-1		;SAVE NEW DATA
	TREAD	NTPP*<NPACK-1>(R)	;READBACK OLD TO VERIFY
	MOVSI B,-WDTRK			;VERIFY LOOP
PK2V1:	MOVE A,TTRACK(B)
	CAME A,TTRK2(B)
	HALT .
	AOBJN B,PK2V1
>;REPEAT 0
	AOBJN	R,PACKCB
	PUTSTR	[ASCIZ/DONE
/]
	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL
	POPJ P,

;	PACK-TO-PACK COPY FOR LOGICAL 6+2 SYSTEM (PHYSICAL 2+2*2+2)
REPEAT 0,<
PACKUP:	PUTSTR	PKMES
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	MOVSI	R,-NTPP			;-COUNT OF TRACKS/PACK
PACKU1:	TREAD	NTPP*6(R)		;READ DATA
	TWRITE	NTPP*7(R)		;WRITE DATA
	AOBJN	R,PACKU1
	PUTSTR	[ASCIZ/DONE
/]
	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL

PKMES:	ASCIZ/ASSUMED CONFIGURATION:
PACKS 0,1 SINGLE DENSITY FILE SYSTEM
PACKS 2,3 DOUBLE DENSITY FILE SYSTEM
PACKS 4,5 SINGLE DENSITY UDP0 AND UDP1
MOUNT THE SOURCE (OLD) PACK AT PACK # 4 (WRITE LOCK OPTIONAL)
MOUNT THE DESTINATION (NEW) PACK AT PACK # 5 WRITE ENABLED)
THEN TYPE CONTINUE.
/
>
;	PACK-TO-PACK COPY FOR UNIFORM COMPOSITION SYSTEM.  C1PACK
REPEAT 0,<
C1PACK:	PUTSTR	[ASCIZ/MOUNT THE SOURCE (OLD) PACK AT PACK # /]
	MOVEI	W,NPACK-1		;COUNTS FROM ZERO
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE LOCKED.
MOUNT THE DESTINATION (NEW) PACK AT PACK # /]
	MOVEI	W,NPACK
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/ WRITE ENABLED.
THEN TYPE CONTINUE.
/]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	MOVSI	R,-NTPP			;-COUNT OF TRACKS/PACK
C1PCK1:	TREAD	NTPP*<NPACK-1>(R)	;READ DATA
	PUSHJ P,CNVT
	TWRITE	TRACKS(R)		;WRITE DATA
;	TREAD	TRACKS(R)		;READBACK TO VERIFY
	AOBJN R,C1PCK1
	PUTSTR	[ASCIZ/DONE
/]
	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL
>;END REPEAT 0

CNVT:	MOVSI A,-4440
CNVT1:	MOVE B,TTRACK+1(A)
	ROT B,4
	MOVEM B,TTRACK+1(A)
	ADD A,[1,,1]
	AOBJN A,CNVT1
	POPJ P,

CNVTB:	MOVSI A,-4440
CNVTB1:	MOVE B,TTRACK+1(A)
	ROT B,-4
	MOVEM B,TTRACK+1(A)
	ADD A,[1,,1]
	AOBJN A,CNVTB1
	POPJ P,
;	RETFIX:	CLEAR OLD RETRIEVAL DATA.
REPEAT 0,<
RETFIX:
	PUTSTR	[ASCIZ/WE ARE ABOUT TO ZERO WORD 17 OF
EVERY FILE'S RETRIEVAL.  TYPE CONTINUE./]
	EXIT	1,
	MOVE	R,[1-TRACKS,,1]		;-COUNT OF TRACKS/FILE SYSTEM
RETFX1:	RREAD	(R)			;READ DATA
	MOVE	A,TTRACK+17		;GET PPN
	MOVEM	A,TTRACK+16		;SAVE PPN HERE
	SETZM	TTRACK+17		;AND ZERO MEANS NO USET HACK.
	RWRITE	(R)			;WRITE DATA
	AOBJN	R,RETFX1
	PUTSTR	[ASCIZ/DONE
/]
	JRST	DDTCALL
>
;	DETEST	DATA TESTING OF ONE TRACK
;	WE ACKNOWLEDGE THE US GOVERMENT WITHOUT WHOSE PROPERTY TAGS, ALL THIS
;	WOULD HAVE BEEN UNNECESSARY.   REG 22 APR 73
TESTNO:	0				;DEPOSIT TRACK NUMBER TO TEST HERE.
TESTCN: 1000				;SET UP TEST COUNT HERE.
TDATA:	0
	0
DETEST:	PUTSTR	DEMES
	SKIPG	TESTNO			;IS THIS SET UP?
	PUSHJ	P,DDTCALL		;NO. CALL DDT
	RREAD	@TESTNO			;READ THE RETRIEVAL
	RPRINT
	PUTSTR	[ASCIZ/ IF THIS RETRIEVAL DOESN'T BELONG TO A FILE,
TYPE CONTINUE.
/]
	EXIT	1,
DTEST1:	PUSHJ	P,RPAT		;GENERATE A PATTERN
	TWRITE	@TESTNO
	PUSHJ	P,CLRPAT	;CLEAR PATTERN
	TREAD	@TESTNO
	PUSHJ	P,CMPPAT	;COMPARE PATTERN
	SOSLE	TESTCN
	JRST	DTEST1
	PUTSTR	[ASCIZ/TEST COUNT EXHAUSTED.
/]
	JRST	DDTCALL

RPAT:	MOVE	0,TDATA			;GENERATE TEST PATTERNS
	MOVE	1,TDATA+1
	ROTC	0,1			;ROTATE TEST PATTERN
	TLNN	0,400000
	TRC	1,1
	MOVEM	0,TDATA
	MOVEM	0,TT0
	MOVEM	1,TDATA+1
	MOVEM	1,TT0+1
	MOVE	0,[TT0,,TT0+2]
	BLT	0,TT0+NBPT*200-1	;STORE THRU THE END OF THE DATA AREA
	POPJ	P,

CLRPAT:	MOVE	0,[TT0,,TT0+1]		;CLEAR PATTERN
	SETZM	TT0
	BLT	0,TT0+NBPT*200-1
	POPJ	P,

CMPPAT:	MOVE	0,TDATA			;COMPARE PATTERN
	MOVE	1,TDATA+1
	MOVSI	2,-NBPT*200
CMPPA1:	CAMN	0,TT0(2)
	CAME	1,TT0+1(2)
	JRST	CMPPA3			;COMPARE NOT EQUAL
	ADD	2,[2,,2]
	JUMPL	2,CMPPA1
	POPJ	P,

CMPPA3:	PUTSTR	[ASCIZ/DATA COMPARE ERROR. 
TEST DATA PATTERN:	/]
	PUSH	P,2
	HLRZ	W,TDATA
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/,,/]
	HRRZ	W,TDATA
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/	/]
	HLRZ	W,TDATA+1
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/,,/]
	HRRZ	W,TDATA+1
	PUSHJ	P,OCTOUT
	POP	P,W
	HRRZ	W,W
	PUTSTR	[ASCIZ/ LOCATION OF ERROR: /]
	PUSHJ	P,OCTOUT
	PUTSTR	CRLF
	POPJ	P,

DEMES:	ASCIZ/PARAMETERS ARE:
TESTNO:	TRACK NUMBER TO TEST
TESTCN:	COUNT OF DATA PATTERNS TO TEST.
THIS PROGRAM WILL NOT MODIFY THE RETRIEVAL OF THE TRACK TESTED.
PLEASE BE SURE THAT THE TRACK DOESN'T REALLY BELONG TO A FILE.
/
;HDTEST	WHDTST
HDTST:	;HEAD TESTING ON ONE PACK-read only
	MOVEI	A,NTPP			;NUMBER OF BLOCKS/PACK
	IMULI	A,2			;TIMES THE PACK NUMBER = FIRST BLOCK NUMBER
	ADDI	A,17			;ADD THE HEAD NUMBER TO TEST.
	MOVSI	R,-NCYL			;COUNT OF CYLINDERS/PACK.
	HRRI	R,(A)
	PUSH	P,R
HDT1:	TREAD	(R)			;READ DATA
	ADD	R,[1,,NTPC]
	JUMPL	R,HDT1
	MOVE	R,(P)
	PUTSTR	[ASCIZ/PASS DONE.
/]
	JRST	HDT1

WHDTST:	;HEAD TESTING ON ONE PACK - writes!
	PUTSTR	[ASCIZ/TEST ONE HEAD ON ONE PACK.  DATA TESTS ENTIRE SURFACE.
PACK AND HEAD NUMBER ARE COMPILED INTO CODE AT WHPACK AND WHHEAD.
YOU'D BETTER BE SURE WHAT YOU'RE DOING.
/]
	EXIT	1,

	MOVEI	A,NTPP			;NUMBER OF BLOCKS/PACK
WHPACK:	IMULI	A,5	;pack #		;TIMES THE PACK NUMBER = FIRST BLOCK NUMBER
WHHEAD:	ADDI	A,22	;head #		;ADD THE HEAD NUMBER TO TEST.
	MOVSI	R,-NCYL			;COUNT OF CYLINDERS/PACK.
	HRRI	R,(A)
	PUSH	P,R

	SETZM	PASSN
WHDT3:	SETOM	CYLN			;HERE TO INITIATE A PASS
	MOVE	R,(P)			;GET INITIAL TRACK NUMBER
;FOR EACH CYLINDER
WHDT2:	MOVEI	A,1
	MOVEM	A,TESTCN		;SET MODERATE TEST COUNT FOR EACH TRACK
	PUTSTR	[ASCIZ/CYL = /]
	AOS	W,CYLN
	PUSHJ	P,DECOUT

	PUTSTR	CRLF
WHDT1:	PUSHJ	P,RPAT			;GENERATE A PATTERN
	TWRITE	(R)
	PUSHJ	P,CLRPAT		;CLEAR PATTERN
	TREAD	(R)
	PUSHJ	P,CMPPAT		;COMPARE PATTERN
	SOSLE	TESTCN
	JRST	WHDT1			;LOOP. TESTING THIS CYL.
	ADD	R,[1,,NTPC]		;ADVANCE TO NEXT CYL
	JUMPL	R,WHDT2	

	PUTSTR	[ASCIZ/PASS /] 		;ADV TO NEXT PASS
	AOS	W,PASSN
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ DONE
/]
	JRST	WHDT3

CYLN:	0
PASSN:	0

PHDTST:	;PACK TESTING - WRITES!
	PUTSTR	[ASCIZ/TEST ENTIRE PACK.  DATA TESTS ENTIRE SURFACE.
PACK NUMBER IS COMPILED INTO CODE AT PPACK.
YOU'D BETTER BE SURE WHAT YOU'RE DOING.
/]
	EXIT	1,

	SETZM	PASSN
PHDTS1:	MOVEI	A,NTPP			;NUMBER OF BLOCKS/PACK
PPACK:	IMULI	A,2	;pack #		;TIMES THE PACK NUMBER = FIRST BLOCK NUMBER
	MOVSI	R,-NTPP
	HRRI	R,(A)			;AOBJN PTR FOR ENTIRE PACK

PHDTS2:	MOVEI	A,1
	MOVEM	A,TESTCN		;SET MODERATE TEST COUNT FOR EACH TRACK
PHDTS3:	PUSHJ	P,RPAT			;GENERATE A PATTERN
	TWRITE	(R)
	PUSHJ	P,CLRPAT		;CLEAR PATTERN
	TREAD	(R)
	PUSHJ	P,CMPPAT		;COMPARE PATTERN
	SOSLE	TESTCN
	JRST	PHDTS3			;LOOP. TESTING THIS TRACK
	AOBJN	R,PHDTS2		;ADV TO NEXT TRK
	PUTSTR	[ASCIZ/PASS /]
	AOS	W,PASSN
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ DONE
/]
	JRST	PHDTS1
;HERE WE MAKE A PASS THROUGH THE DISK AND REINITIALIZE EVERYONE'S REFTIME
REPEAT 0,<
.FATAL THIS CODE DOESN'T WORK AFTER JANUARY 5,1975
REREF:	PUTSTR	[ASCIZ/THIS CODE REINITIALIZES REFTIME OF ALL FILES.
/]
	EXIT	1,
	MOVE	R,[-TTMAX,,1]		;FROM TRACK 1 TO ∞
REREF1:	RREAD	(R)
	MOVE	A,TTRACK+DSATID
	CAME	A,SATID			;CHECK FOR VALID SATID
	JRST	REREF2			;NO. SKIP THE WRITE
	LDB	A,[POINT 12,TTRACK+DDPRO,35]
	MOVEM	A,TTRACK+DREFTM		;SET REFTIME
	HRROI	A,007777
	ANDM	A,TTRACK+DDEXT		;CLEAR BITS 18-23 FOR FUTURE DATE75
	RWRITE	(R)			;REWRITE RETRIEVAL
REREF2:	AOBJN	R,REREF1		;LOOP
	PUTSTR	[ASCIZ/DONE
/]
	JRST	DDTCAL

>;REPEAT 0
;	DOUBLE DENSITY CONVERSION  6/27/74	CDBL:
REPEAT 0,<
CDBL:	PUTSTR	FOOMES
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP

	MOVSI	R,-NTPP*2		;TWO SINGLES PACK'S WORTH OF TRACKS
CDBL1:	TREAD	NTPP*6(R)		;READ DATA
	TWRITE	NTPP*2(R)		;WRITE DATA
	AOBJN	R,CDBL1

	PUTSTR	FOOMS1
	EXIT	1,
	MOVSI	R,-NTPP			;ONE PACK'S WORTH
CDBL2:	TREAD	NTPP*6(R)
	TWRITE	NTPP*4(R)
	AOBJN	R,CDBL2

	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL

FOOMES:	ASCIZ	/
This code assumes that the system is configured as follows:
Pack	Density	Function
0	1	System
1	1	System
2	2	System
3	2	System
4	1	UDP0
5	1	UDP1

This code copies packs 4 and 5 to pack 2.
Then it pauses while you switch packs, and copies pack 4 to pack 3.

Mount two blank, formatted, double density packs in drives 2 and 3.
Mount old logical #2 in drive 4, and old logical #3 in drive 5.
All drives except 2 and 3 may be write locked.  Type continue when ready.  
/

FOOMS1:	ASCIZ	/
Mount old logical #4 in drive 4.  Type continue when ready.
/
>;END REPEAT 0
;	GRIMM
REPEAT 0,<
OBUFH:	BLOCK	3
WRTCHR:	SOSG	OBUFH+2
	OUTPUT	17,
	IDPB	A,OBUFH+1
	TTYUUO	1,A
	POPJ	P,

GRIMM:	INIT	17,0		;ASCII CHARACTERS
	'DSK   '
	OBUFH,,0
	HALT
	MOVE	A,['GRIMM']
	SETZB	B,C
	MOVEI	D,0
	ENTER	17,A
	HALT
	OUTBUF	17,2
	MOVE	R,[-=397,,1000+<=7600*8>]		;PACK 4 (COUNTING0,1,2 AND 3 TWICE)
GRML:	TREAD	(R)		;READ
	MOVE	D,[POINT 8,TT0]	;INPUT BYTE POINTER
	MOVEI	C,=61		;NUMBER OF LINES/TRACK
GRML0:	MOVEI	B,=80		;CHARS/LINE
GRML1:	ILDB	A,D		;READ A BYTE
	SKIPE	A,H2A(A)
	PUSHJ	P,WRTCHR	;WRITE A BYTE
	SOJG	B,GRML1
	MOVEI	A,15		;DONE WITH LINE
	PUSHJ	P,WRTCHR
	MOVEI	A,12
	PUSHJ	P,WRTCHR
	SOJG	C,GRML0
	AOBJN	R,GRML		;DONE WITH TRACK
	CLOSE	17,		;DONE WITH FILE
	RELEAS	17,
	PUTSTR	[ASCIZ/DONE
/]
	JRST	DDTCAL

;HEX TO ASCII
XLIST
H2A:	REPEAT	100,<0>		;00-3F
	" "			;40
	REPEAT =10,<0>		;41-4A
	"."			;4B
	"<"			;4C
	"("			;4D
	"+"			;4E
	"|"			;4F
	"&"			;50
	REPEAT =9,<0>		;51-59
	"!"			;5A
	"$"			;5B
	"*"			;5C
	")"			;5D
	";"			;5E
	"¬"			;5F
	"-"			;60
	"/"			;61
	REPEAT 9,<0>		;62-6A
	","			;6B
	"%"			;6C
	"_"			;6D
	">"			;6E
	"?"			;6F
	REPEAT =10,<0>		;70-79
	":"			;7A
	"#"			;7B
	"@"			;7C
	"'"			;7D
	"="			;7E
	'"'+40			;7F
IFN .-H2A-=128,<.FATAL TABLE LOSES>
	0			;80
	"a"			;81
	"b"			;82
	"c"			;83
	"d"			;84
	"e"			;85
	"f"			;86
	"g"			;87
	"h"			;88
	"i"			;89
	REPEAT 7,<0>		;8A-90
	"j"			;91
	"k"			;92
	"l"			;93
	"m"			;94
	"n"			;95
	"o"			;96
	"p"			;97
	"q"			;98
	"r"			;99
	REPEAT 8,<0>		;9A-A1
	"s"			;A2
	"t"			;A3
	"u"			;A4
	"v"			;A5
	"w"			;A6
	"x"			;A7
	"y"			;A8
	"z"			;A9
	REPEAT 6+=16+1,<0>	;AA-C0
	"A"			;C1
	"B"			;C2
	"C"			;C3
	"D"			;C4
	"E"			;C5
	"F"			;C6
	"G"			;C7
	"H"			;C8
	"I"			;C9
	REPEAT 7,<0>		;CA-D0
	"J"			;D1
	"K"			;D2
	"L"			;D3
	"M"			;D4
	"N"			;D5
	"O"			;D6
	"P"			;D7
	"Q"			;D8
	"R"			;D9
	REPEAT 8,<0>		;DA-E1
	"S"			;E2
	"T"			;E3
	"U"			;E4
	"V"			;E5
	"W"			;E6
	"X"			;E7
	"Y"			;E8
	"Z"			;E9
	REPEAT 6,<0>		;EA-EF
	"0"			;F0
	"1"			;F1
	"2"			;F2
	"3"			;F3
	"4"			;F4
	"5"			;F5
	"6"			;F6
	"7"			;F7
	"8"			;F8
	"9"			;F9
	REPEAT 6,<0>		;FA-FF
IFN .-H2A-=256,<.FATAL TABLE LOSES>
>;END REPEAT 0
;QUAM	COPY SYS PACK TO QUAM PACK

repeat 0,<
QUAM:	MOVSI	R,-NTPP
	MOVSI	A,'SYS'
	MOVSI	B,'PDQ'
	PUTSTR	[ASCIZ/
MOUNT	SYS 	ON	2	WRITE LOCK
MOUNT	PDQ	ON	3	R-W
WRITE LOCK OTHER PACKS.  THEN TYPE CONTINUE.
/]
	EXIT	1,

LOOP:	TREAD	2*NTPP(R)
	CAMN	A,TTRACK+DSATID
	MOVEM	B,TTRACK+DSATID
	TWRITE	3*NTPP(R)
	TREAD	3*NTPP(R)
	AOBJN	R,LOOP
	PUTSTR	[ASCIZ/
DONE. NOW, BY HAND, FIX SATID IN BLOCK 0 AND PASSWORD IN LAST TRACK
/]
	POPJ	P,

>
;DATE75  PASS THROUGH THE DISK TO CLEAR THE HIGH DATE OF ALL FILES
repeat 0,<

DATE75:	PUTSTR	[ASCIZ/THIS CLEARS ALL HIGH DATES FOR DATE75
/]
	EXIT	1,
	MOVE	R,[-TTMAX,,1]		;FROM TRACK 1 TO ∞
REREF1:	RREAD	(R)
	LDB	A,[POINT 6,TTRACK+DDEXT,23]	;GET HIGH DATE (OF 2 DATE FIELDS)
	JUMPE	A,REREF2		;JUMP IF OK
	RPRINT
	pushj	p,ddtcall
	MOVEI	A,0
	DPB	A,[POINT 6,TTRACK+DDEXT,23]	;ZERO IT
	RWRITE	(R)			;REWRITE RETRIEVAL
REREF2:	AOBJN	R,REREF1		;LOOP
	PUTSTR	[ASCIZ/DONE
/]
	JRST	DDTCAL

>;end repeat 0
;	RETRY TESTING
;!!!!!  NONE OF THIS CODE WORKS WITHOUT MODIFICATIONS.

repeat 0,<

RTSADR:	12655		;ADDRESS OF RTYCNT IN SYSTEM
RTTRK:	121307		;TRACK NUMBER TO TEST
RTSDAT:	010177024144	;DATA WE EXPECT TO FIND
RTDADR:	TT0+4377	;ADDRESS WHERE WE EXPECT TO FIND IT.
RTTCNT:	0		;LOSSES,,WINS

RTTST:	SETZM	RTTCNT
RTTST1:	MOVE	A,RTSADR		;SYSTEM ADDRESS
	PEEK	A,
	setzm tt0
	move [tt0,,tt0+1]
	blt tt0+4400-1
	TREAD	@RTTRK
	MOVE	W,RTSADR
	PEEK	W,
	SUB	W,A
	PUSHJ	P,DECOUT		;PRINT DECIMAL
	PUTCHR	[" "]
	MOVE	A,RTSDAT		;GET CORRECT DATA
	MOVSI	B,1			;ASSUME LOSS
	CAMN	A,@RTDADR		;SKIP IF LOSS
	SKIPA	B,[1]			;WE WON. SKIP.
	PUTSTR	A,[ASCIZ/NO/]
	ADDM	B,RTTCNT
	PUTSTR	CRLF
	JRST	RTTST1
>;end repeat 0
;	SHAKE	VIBRATION TESTING

;TOTAL OF 22,400 OPERATIONS = 5,600 PER DRIVE
SHAKE:	PUSH	P,[DDTCAL]
SHAKE1:	MOVEI	Z,10		;CALL VIA SHAKE$G IN DDT
	PUTSTR	[ASCIZ/Disk Vibration Test
/]
	PUSH	P,UDPOK
	SETOM	UDPOK
	MOVE	Y,[3.141592]		;A RANDOM NUMBER
SHAKE2:
III==0
REPEAT NPACK+NUDPS,<
	MOVEI	R,III
	PUSHJ	P,SHAKER
III==III+NTPP
>
	SOJG	Z,SHAKE2
	POP	P,UDPOK
	POPJ	P,


SHAKER:	MOVEI	S,144			;700 OPERATIONS/CALL
SHAKR1:	RREAD	0(R)			;PATTERN IS 0,400,0,799,400,799,random
	RREAD	NTPP/2(R)
	RREAD	0(R)
	RREAD	NTPP-1(R)
	RREAD	NTPP/2(R)
	RREAD	NTPP-1(R)
	IMUL	Y,[2.7128576]
	MOVE	A,Y
	IDIVI	A,NTPP			;REMAINDER IN B IS TRACK NUMBER
	ADDI	B,(R)
	TREAD	(B)			;READ THE ENTIRE RANDOM TRACK
	SOJG	S,SHAKR1
	POPJ	P,


;TOTAL OF 20,000 OPERATIONS = 5,000 PER DRIVE
RSEEK:	PUSH	P,[DDTCAL]
RSEEK1:	MOVEI	Z,62			;CALL VIA RSEEK$G IN DDT
	PUSH	P,UDPOK
	SETOM	UDPOK
	MOVE	Y,[3.141592]		;A RANDOM NUMBER
	PUTSTR	[ASCIZ/Random Seek Test
/]
RSEEK2:
III==0
REPEAT NPACK+NUDPS,<
	MOVEI	R,III
	PUSHJ	P,RSEEKR
III==III+NTPP
>
	SOJG	Z,RSEEK2
	POP	P,UDPOK
	POPJ	P,


RSEEKR:	MOVEI	S,144
RSEEKX:	IMUL	Y,[2.7128576]
	MOVE	A,Y
	IDIVI	A,NTPP			;REMAINDER IN B IS TRACK NUMBER
	ADDI	B,(R)
	RREAD	(B)
	SOJG	S,RSEEKX
	POPJ	P,
;	STEST	SURFACE TESTING OF ENTIRE DISK (FILE SYSTEM)

STEST:	PUSH	P,[DDTCAL]
STEST1:	PUTSTR	[ASCIZ/Surface test
/]
	MOVSI	R,-TTUDP
	TREAD	(R)
	AOBJN	R,.-1
	POPJ	P,

WTEST:	PUTSTR	[ASCIZ/
This program reads every track, rewrites the data, reads it back and checks it.
Type CONTINUE to go on.
/]
	EXIT	1,
	PUSH	P,[DDTCAL]
WTEST0:	PUTSTR	[ASCIZ/Write-readback test
/]
	MOVE	R,[1-TTUDP,,1]		;DON'T WRITE TRACK 0
WTEST1:	TREAD	(R)
	MOVE	A,[TTRACK,,SATID+1]
	BLT	A,SATID+WDTRK
	TWRITE	(R)
	SETZM	TTRACK
	MOVE	A,[TTRACK,,TTRACK+1]
	BLT	A,TTRACK+WDTRK-1
	TREAD	(R)
	MOVEI	Z,0			;NO ERRORS YET.
	MOVSI	S,-WDTRK
WTEST2:	MOVE	A,TTRACK(S)
	CAME	A,SATID+1(S)
	JRST	WTEST4
WTES2A:	AOBJN	S,WTEST2
WTEST3:	CAIG	Z,10
	JRST	WTES3A
	MOVEI	W,(Z)
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ errors
/]
WTES3A:	AOBJN	R,WTEST1
	POPJ	P,

WTEST4:	JUMPG	Z,WTEST5		;SKIP PREAMBLE
	PUTSTR	[ASCIZ/Readback error.  Track = /]
	MOVEI	W,(R)
	PUSHJ	P,OCTOUT
	PUTSTR	[ASCIZ/
Correct		Incorrect
/]
WTEST5:	ADDI	Z,1
	CAILE	Z,10
	JRST	WTES2A
	MOVE	W,TTRACK(S)
	PUSHJ	P,OCTHWT
	PUTSTR	[ASCIZ/	/]
	MOVE	W,SATID+1(S)
	PUSHJ	P,OCTHWT
	PUTSTR	[ASCIZ/
/]
	JRST	WTES2A
;	ATEST	PRE-ACCEPTANCE TESTING OF THE DISK

ATEST:	PUSH	P,CTYTYO
	PUSH	P,UDPOK
	SETOM	UDPOK
	SETOM	CTYTYO
	PUSHJ	P,PHSL			;OUTPUT SUMMARY TO THE LPT
	PUTSTR	[ASCIZ/Pre-acceptance disk test
MOUNT PLUGS-PACKS-DRIVES AS FOLLOWS:
DRIVE  D C B A
PACK   0 1 2 3
/]
	PUSHJ	P,EPAUSE
	PUSHJ	P,ZRRCNT		;ZERO RETRY COUNTS
	PUSHJ	P,STEST1		;SURFACE TEST
	PUTSTR	[ASCIZ/ECC counts due to surface test
/]
	PUSHJ	P,PRRCNT
	PUSHJ	P,SHAKE1		;SHAKER TEST
	PUSHJ	P,ZRRCNT
	PUSHJ	P,STEST1		;see if we can read it now
	PUTSTR	[ASCIZ/ECC counts due to surface test after vibration test
/]
	PUSHJ	P,PRRCNT
	PUSHJ	P,WTEST0		;DO WRITE-READBACK.
	PUTSTR	[ASCIZ/ECC counts due to write-readback:
/]
	PUSHJ	P,PRRCNT

	PUTSTR	[ASCIZ/
CROSS-DRIVE ALIGNMENT CHECK.  
MOUNT PLUGS-PACKS-DRIVES AS FOLLOWS:
DRIVE  D C B A
PACK   3 0 1 2
/]
	PUSHJ	P,EPAUSE
	PUSHJ	P,STEST1
	PUTSTR	[ASCIZ/ECC counts due to alignment check:
/]
	PUSHJ	P,PRRCNT

	PUTSTR	[ASCIZ/
CROSS-DRIVE ALIGNMENT CHECK.  
MOUNT PLUGS-PACKS-DRIVES AS FOLLOWS:
DRIVE  D C B A
PACK   2 3 0 1
/]
	PUSHJ	P,EPAUSE
	PUSHJ	P,STEST1
	PUTSTR	[ASCIZ/ECC counts due to alignment check:
/]
	PUSHJ	P,PRRCNT

	PUTSTR	[ASCIZ/
CROSS-DRIVE ALIGNMENT CHECK.  
MOUNT PLUGS-PACKS-DRIVES AS FOLLOWS:
DRIVE  D C B A
PACK   1 2 3 0
/]
	PUSHJ	P,EPAUSE
	PUSHJ	P,STEST1
	PUTSTR	[ASCIZ/ECC counts due to alignment check:
/]
	PUSHJ	P,PRRCNT

	PUTSTR	[ASCIZ/Preacceptance test complete
/]
	POP	P,UDPOK
	POP	P,CTYTYO
	RELEAS	LPT,
	SETZM	LPTFLG
	JRST	DDTCAL



EPAUSE:	OUTSTR [ASCIZ/Type CONTINUE when ready
/]
	EXIT	1,
	POPJ	P,

;TEST LOGICAL # 3 COMPLETELY
BTEST:	PUSH	P,UDPOK
	SETOM	UDPOK
	PUSHJ	P,PHSL			;OUTPUT SUMMARY TO THE LPT
	PUTSTR	[ASCIZ/Surface test of logical #3.
/]
	OUTSTR [ASCIZ/Please enter one line of drive ID, etc.
*/]
	PUSHJ	P,INPNT			;READ TTY AND PRINT ON LPT
	PUSHJ	P,ZRRCNT		;ZERO RETRY COUNTS
	OUTSTR [ASCIZ/Type any character to abort
/]
	MOVE	R,[-NTPP,,NTPP*3]
btest1:	TREAD	(R)
	TRNN	R,77			;SEE IF HE WANT'S TO STOP
	INSKIP				;SKIP IF TYPED SOMETING
	AOBJN	R,btest1
	PUTSTR	[ASCIZ/ECC counts due to surface test.  Logical #3 only
/]
	PUSHJ	P,PRRCNT
	POP	P,UDPOK
	RELEAS	LPT,
	JRST	DDTCAL

INPNT:	INCHWL	A
	PUTCHR	A
	CAIE	A,12
	JRST	INPNT
	POPJ	P,
;	handle the head/pack retry counts
;this code uses the array RTRHCT in the operating system - pointed to by 320
;

NOSET2:	OUTSTR [ASCIZ/Setpr2 failure
/]
	HALT	CPOPJ

NORCNT:	OUTSTR [ASCIZ/No RTRHCT array
/]
	HALT	CPOPJ

PRRCNT:	MOVSI	A,376001	;PRINT THE HEAD/RETRY COUNTS
	SETPR2	A,
	JRST	NOSET2
	HRRZ	A,400320
	JUMPE	A,NORCNT
	MOVSI	B,-<NPACK+NUDPS>
PRRC1:	MOVEI	W,(B)
	SETZM	PTOT(B)		;ERRORS/PACK COUNTER
	PUTSTR	[ASCIZ/	Pk /]
	PUSHJ	P,DECOUT
	AOBJN	B,PRRC1
	PUTSTR	[ASCIZ/
/]
	MOVEI	C,2
	SKIPE	CTYTYO
	SLEEP	C,		;LET CTY COOL OFF
	MOVSI	B,-NTPC		;NUMBER OF HEADS
PRRC1A:	MOVSI	C,-<NPACK+NUDPS>	;NUMBER OF DRIVES
	HRRI	C,(B)
	ADDI	C,400000(A)
PRRC1B:	SKIPE	(C)
	JRST	PRRC2		;THERE'S SOMETHING TO PRINT ON THIS LINE
	ADD	C,[1,,NTPC]
	JUMPL	C,PRRC1B	;LOOK FOR NON ZERO THING TO PRINT
	JRST	PRRC3A		;NO ERRORS FOR THIS HEAD ON ANY PACK

PRRC2:	MOVEI	W,(B)		;HEAD NUMBER
	PUTSTR	[ASCIZ/Hd /]
	PUSHJ	P,DECOUT	;PRINT HEAD NUMBER
	MOVSI	C,-<NPACK+NUDPS>
	HRRI	C,(B)
	ADDI	C,400000(A)
PRRC3:	PUTSTR	[ASCIZ/	  /]
	MOVE	W,(C)
	HLRE	D,C			;PACK NUMBER - <NPACK+NUDPS> IN D
	ADDM	W,PTOT+NPACK+NUDPS(D)	;COUNT ERRORS/PACK
	PUSHJ	P,DECOUT
	ADD	C,[1,,NTPC]
	JUMPL	C,PRRC3
	PUTSTR	[ASCIZ/
/]
	MOVEI	C,2
	SKIPE	CTYTYO
	SLEEP	C,		;LET THE CTY COOL OFF
PRRC3A:	AOBJN	B,PRRC1A
	PUTSTR	[ASCIZ/
Totals:/]
	MOVSI	B,-<NPACK+NUDPS>
PRRC4:	MOVE	W,PTOT(B)
	PUTSTR	[asciz/	  /]
	PUSHJ	P,DECOUT
	AOBJN	B,PRRC4
	PUTSTR	[ASCIZ/
Ops:/]
	MOVE	B,400320		;ADDRESS OF HEAD COUNTS
	ADDI	B,400000-<NPACK+NUDPS>	;ADDRESS OF DRIVE OPERATION COUNTS
	HRLI	B,-<NPACK+NUDPS>
PRRC4A:	MOVE	W,(B)
	PUTCHR	[11]
	PUSHJ	P,DECOUT
	AOBJN	B,PRRC4A
	PUTSTR	[ASCIZ/
Percent/]
	MOVSI	B,-<NPACK+NUDPS>
	MOVE	C,400320	;ADDRESS OF HEAD COUNTS
	SUBI	C,NPACK+NUDPS	;ADDRESS OF DRIVE OPERATION COUNTS
PRRC5:	MOVE	W,PTOT(B)
	IMULI	W,144*144
	IDIV	W,400000(C)
	SKIPN	400000(C)
	MOVEI	W,0
	IDIVI	W,144		;PERCENT IN W, HUNDRETHS OF PCT IN X
	PUTCHR	[11]
	PUSHJ	P,DECOUT
	PUTCHR	["."]
	MOVE	W,X
	CAIGE	W,12
	PUTCHR	["0"]		;TWO DIGITS HERE
	PUSHJ	P,DECOUT
	PUTCHR	["%"]
	ADDI	C,1
	AOBJN	B,PRRC5
	PUTSTR	[ASCIZ/

/]				;NOW FALL INTO ZEROING THE STUFF

ZRRCNT:	MOVSI	A,376000	;ZERO THE HEAD/RETRY ARRAY IN THE SYSTEM
	SETPR2	A,
	JRST	NOSET2
	HRRZ	A,400320
	JUMPE	A,NORCNT
	MOVSI	B,-<NPACK+NUDPS>*<NTPC+1> ;NUMBER OF PACKS*HEADS+PACKS
	HRRI	B,400000-<NPACK+NUDPS>(A)
	SETZM	(B)		;UNLIKE BLT THIS IS FREE FROM TIMING ERRORS
	AOBJN	B,.-1
	DETSEG			;FLUSH SETPR2 UPPER
	POPJ	P,

PTOT:	BLOCK	NPACK+NUDPS

	SUBTTL	CPYALL
;REALLOCATE THE DISK TO USE "EXTRA" CYLINDERS AND TO MAKE [SWAP].SYS[1,4]

IFN RALLOC,<


CPYALL:	PUTSTR	[ASCIZ/Mount source packs 0,1,2 on IBM 0,1,2, write locked.
write lock IBM 3.
mount destination packs 0,1,2 on AMPEX 0,1,2, write enabled.
The operating system must be configured for 3*800 files system, 1*800 UDP1,
and 3*815 UDP2,3,4.  If not, you'll be very sorry.  Type continue.
/]
	EXIT	1,

	PUSH	P,UDPOK
	SETOM	UDPOK
;BUILD INCORE SAT
	PUSH	P,SATID			;SAVE SATID
	SETZM	SSAT
	MOVE	B,[SSAT,,SSAT+1]
	BLT	B,SATEND		;ZERO SAT (AND RALPH SPECIAL COPY OF SAT)
	POP	P,SATID			;RESTORE SATID

;SETUP DATE AND TIME PARAMTERS
	DATE	B,
	MOVEM	B,THSDAZ		;FILE SYSTEM DATE AND TIME
	LDB	C,[POINT 3,B,23]
	DPB	C,[POINT 3,B,20]
	MOVEM	B,THSDAX		;DATE SUITABLE FOR RH OF FILE EXT
	TIMER	C,
	IDIVI	C,=60*=60		;MINUTES SINCE MIDNITE IN C
	DPB	C,[POINT 11,THSDAZ,23]	;STORE FOR WORD 3 OF FILE RTVL

;READ MFD INTO CORE.
	MOVE	A,['  1  1']	;GET NAME OF MFD
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV+3	;SAVE AS EXPECTED RETRIEVAL
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	RREAD	1		;READ MFD RTVL
	MOVEI	A,UFDN
	ADDM	A,JOBFF		;MAKE ROOM FOR [1,4].UFD
	ADDM	A,TTRACK+5	;ADD TO MFD LENGTH TOO
	MOVE	A,[TTRACK,,MRTSV]
	BLT	A,MRTSV+DDRET-1	;SAVE MFD RTVL
	MOVEI	R,1		;READ MFD FROM BLOCK 1
	PUSHJ	P,FREAD		;READ FILE
	MOVE	Z,DIOWD		;GET THE IOWD OF FILE
	SUB	Z,[UFDN,,UFDN]	;INCLUDE SPACE FOR [1,4]
	MOVEM	Z,MFDPTR	;SAVE AS MFD POINTER
	HLRO	A,Z
	MOVN	A,A
	IDIVI	A,4400
	JUMPE	B,.+2
	ADDI	A,1
	MOVEM	A,LSTBLK	;NUMBER OF BLOCKS NEEDED FOR THE MFD.

;BUILD [1,4].UFD, CONTAINING ONE FILE, [SWAP].SYS
	SETZM	TTRACK
	MOVE	A,[TTRACK,,TTRACK+1]
	BLT	A,TTRACK+WDTRK-1
	MOVE	A,['  1  4']
	MOVEM	A,TTRACK
	MOVEM	A,1(Z)		;STORE UFD NAME.
	MOVSI	A,'UFD'
	HRR	A,THSDAX
	MOVEM	A,2(Z)
	MOVEM	A,TTRACK+1
	MOVSI	A,155740	;PREVENT ALL ACCESS TO THIS DIRECTORY
	IOR	A,THSDAZ
	MOVEM	A,3(Z)
	MOVEM	A,TTRACK+2
	MOVE	A,['  1  1']
	MOVEM	A,TTRACK+3
	AOS	R,LSTBLK	;FIRST FREE BLOCK AFTER MFD
	MOVEM	R,4(Z)		;STORE AS POINTER TO UFD.
	MOVEM	R,TTRACK+4	;DDLOC = FIRST BLOCK OF FILE
	MOVEI	B,UFDN
	MOVEM	B,TTRACK+5	;DDLNG LENGTH
	MOVEI	B,1
	MOVEM	B,TTRACK+10	;DGRP1R RECORD NUMBER OF FIRST RECORD OF THIS GR.
	MOVE	B,SATID
	MOVEM	B,TTRACK+12	;DSATID
	MOVE	B,['[SWAP]']
	MOVEM	B,TTRACK+13	;PASSWORD
	HRLZM	R,TTRACK+DDRET	;RETRIEVAL POINTERS.
	MOVEM	B,TT0		;FILE NAME
	MOVSI	B,'SYS'
	HRR	B,THSDAX
	MOVEM	B,TT0+1
	MOVSI	B,777740
	IOR	B,THSDAZ
	MOVEM	B,TT0+2
	MOVE	B,SWPRET	;LOCATION OF THE FILE [SWAP].SYS
	MOVEM	B,TT0+3
	PUSHJ	P,XWRITE	;WRITE '  1  4'.UFD[1,1] (USES TRACK NUMBER IN R)
	PUTSTR	[ASCIZ/  1  4.UFD WRITTEN
/]

;CREATE THE FILE [SWAP].SYS[1,4] AND WRITE ITS RETRIEVAL
	MOVE	A,[TT0,,TTRACK]
	BLT	A,TTRACK+2	;DDNAM, DDEXT, DDPRO.
	MOVE	A,['  1  4']
	MOVEM	A,TTRACK+3	;DDPPN
	MOVE	A,SWPRET
	MOVEM	A,TTRACK+4	;DDLOC
	MOVE	A,[14,,014000]	;DDLNG
	MOVEM	A,TTRACK+5
	SETZM	TTRACK+13
	MOVE	A,[TTRACK+13,,TTRACK+14]
	BLT	A,TTRACK+WDTRK-1
	MOVE	Z,[-SWPRXX,,SWPRET]	;POINTER TO THE TRACKS WE NEED.
;START A GROUP.
GRW:	MOVSI	Y,-TRKGRP		;NUMBER OF TRACKS/GROUP
	SETZM	TTRACK+DDRET
	MOVE	A,[TTRACK+DDRET,,TTRACK+DDRET+1]
	BLT	A,TTRACK+DDRET+<TRKGRP/2>-1
GRW0:	MOVE	A,(Z)			;GET A TRACK NUMBER
	MOVEI	B,(Y)
	ROT	B,-1			;DIVIDE BY 2
	JUMPL	B,GRW1
	HRLM	A,TTRACK+DDRET(B)
	JRST	GRW2

GRW1:	HRRM	A,TTRACK+DDRET(B)
GRW2:	AOBJP	Z,GRW3			;ADVANCE TO NEXT TRACK. JUMP IF NO NEXT.
	AOBJN	Y,GRW0			;LOOP TO NEXT TRACK IN GROUP
	SKIPA	A,(Z)			;GET NEXT TRACK = DNXTGP
GRW3:	MOVEI	A,0			;NO NEXT TRACK
	HRRZM	A,TTRACK+11		;STORE NEXT GROUP POINTER
	MOVSI	Y,-TRKGRP
GRW4:	MOVEI	B,(Y)
	ROT	B,-1
	JUMPL	B,GRW5
	HLRZ	R,TTRACK+DDRET(B)
	JRST	GRW6

GRW5:	HRRZ	R,TTRACK+DDRET(B)
GRW6:	JUMPE	R,GRW7			;WHEN ALL OUT OF RTVL, WE'RE DONE!
	PUSHJ	P,XWRITE		;WRITE ONE TRACK
	AOBJN	Y,GRW4
	MOVEI	A,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDM	A,TTRACK+10		;DGRP1R
	JUMPL	Z,GRW			;WRITE ANOTHER GROUP.
GRW7:	PUTSTR	[ASCIZ/[SWAP].SYS[1,4]
/]
;FALL THROUGH
;MORE CPYALL
;GO THROUGH MFD, READ EACH UFD INTO CORE, RECOPY EACH FILE,
;REWRITE UPDATED UFD, REWRITE UPDATED MFD.

	MOVE	Z,MFDPTR
	ADD	Z,[UFDN,,UFDN+1]	;ADVANCE PAST [1,4].UFD
	MOVE	A,JOBFF
	MOVEM	A,SAVFF

;HERE FOR EVERY ENTRY IN THE MFD
GRY.1:	SKIPN	A,(Z)		;GET THE NAME OF A USER
	JRST	GRY.4		;EMPTY ENTRY
	MOVEM	A,PPUFD		;SAVE THE PPN OF THIS UFD
	MOVEM	A,RTSAV		;SAVE NAME OF UFD 
	MOVE	A,['  1  1']	;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+3	;SAVE
	HLLZ	B,1(Z)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1	;SAVE IT
	CAME	B,['UFD   ']	;MUST BE SIXBIT UFD
	JRST	GRY.5		;MENTION GARBAGED NAME.  RTSAV,RTSAV+1 SETUP
	HRRZ	R,3(Z)		;GET THE TRACK ADDRESS
	RREAD	(R)		;READ UFD RTVL
	MOVE	A,[TTRACK,,URTSV]
	BLT	A,URTSV+DDRET-1	;SAVE UFD RTVL
	MOVE	A,SAVFF
	MOVEM	A,JOBFF
	PUSHJ	P,FREAD
	MOVE	W,PPUFD		;GET NAME
	PUSHJ	P,TYPPN
	PUTSTR	CRLF
GRY.1A:	MOVE	Y,DIOWD		;GET THE IOWD OF THE UFD
	AOJGE	Y,GRY.3A	;IGNORE IF EMPTY.

;HERE FOR EVERY ENTRY IN THE UFD
GRY.2:	SKIPN	A,0(Y)		;GET A FILE NAME
	JRST	GRY.3		;EMPTY NAME
	MOVEM	A,RTSAV		;SAVE RETRIEVAL
	HLLZ	B,1(Y)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1
	MOVE	C,PPUFD
	MOVEM	C,RTSAV+3
	HRRZ	R,3(Y)		;GET THE TRACK ADDRESS
	PUSHJ	P,FCOPY		;COPY THE FILE FROM OLD TO NEW.
GRY.3:	ADD	Y,[XWD UFDN,UFDN]
	JUMPL	Y,GRY.2		;LOOP
	PUSHJ	P,UWRITE	;HERE AT END OF UFD.  WRITE UFD
	JRST	GRY.4

GRY.3A:	SETZM	(Z)		;EMPTY UFD ISN'T COPIED TO NEW PACKS.
GRY.4:	ADD	Z,[XWD UFDN,UFDN] ;ADVANCE TO NEXT UFD
	JUMPL	Z,GRY.1		;LOOP
	PUSHJ	P,MWRITE	;WRITE MFD

;WRITE SAT
	MOVE	A,[SSAT,,TTRACK]
	BLT	A,TTRACK+WDTRK-1
	TWRITE	UDPORG		;WRITE SAT TABLE
	PUTSTR	[ASCIZ/DONE!
/]
	HALT	CPOPJ
	

GRY.5:	PUTSTR	[ASCIZ/A FILE, NOT A UFD, FOUND IN [1,1].
/]
	PUSH	P,Z
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
	POP	P,Z
	SETZM	(Z)		;ZERO ILLEGAL FILE NAME
	HALT	GRY.4		;GET ANOTHER ENTRY FROM MFD

REPEAT 0,<
XWRITE:	PUSHJ	P,SBYTE		;CALC. BYTE POINTER FROM R, TO SSATBT
	LDB	A,SSATBT
	JUMPE	A,XWRIT1
	PUTSTR	[ASCIZ/SAT BYTE ALREADY MARKED!
/]
	HALT	.

XWRIT1:	MOVEI	A,1
	DPB	A,SSATBT
	TWRITE	UDPORG(R)
	POPJ	P,
>;REPEAT 0

XWRITE:	PUSH	P,A
	MOVE	A,[TTRACK,,BUFR]
	BLT	A,BUFR+WDRTVL-1
	RREAD	(R)
	MOVE	A,TTRACK
	CAMN	A,BUFR
	JRST	TWOK
	SKIPE	TTRACK+DSATID
	JRST	4,.
TWOK:	MOVE	A,[BUFR,,TTRACK]
	BLT	A,TTRACK+WDRTVL-1
	POP	P,A
	SETSAT	(R)
	TWRITE	(R)
	POPJ	P,

BUFR:	BLOCK	WDRTVL

MRTSV:	BLOCK	DDRET	;SAVE MFD ORIGINAL RTVL INFO
URTSV:	BLOCK	DDRET	;SAVE UFD ORIGINAL RTVL INFO
;MORE CPYALL

;COPY A FILE.  GROUP RETRIEVAL IS IN R.  Y POINTS TO UFD ENTRY IN CORE

FCOPY:	PUSHJ	P,GETBLK	;GET A BLOCK NUMBER FOR USE ON THE NEW DISK
	MOVEM	A,3(Y)		;MAKE INCORE UFD POINT TO NEW PLACE.
	SOS	LSTBLK		;UNWIND LSTBLK SO NEXT TRY WILL GET SAME BLOCK
FCOPY1:	RREAD	(R)		;GET GROUP RTVL IN.
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1 ;COPY RTVL
	MOVE	A,3(Y)
	MOVEM	A,RTSAV+4	;DDLOC = POINTER TO FIRST TRACK OF FIRST GROUP
	MOVSI	X,-TRKGRP	;TRANSLATE RTVL POINTERS.
	MOVEI	C,0		;FLAG THAT NO ZERO POINTER HAS BEEN SEEN YET.
FCOPY2:	MOVEI	B,(X)
	ROT	B,-1
	JUMPL	B,FCOPY3
	HLRZ	A,RTSAV+DDRET(B)
	JRST	FCOPY4
FCOPY3:	HRRZ	A,RTSAV+DDRET(B)
FCOPY4:	JUMPE	A,FCP6A
	JUMPE	C,FCOPY5
	HALT	.		;INCONSISTIENT RTVL (NON ZERO POINTER FOLLOWS 0)
FCOPY5:	PUSHJ	P,GETBLK	;GET A BLOCK ON THE NEW DISK.
	JUMPL	B,FCOPY6
	HRLM	A,RTSAV+DDRET(B)
	JRST	FCOPY7
FCOPY6:	HRRM	A,RTSAV+DDRET(B)
	JRST	FCOPY7
FCP6A:	MOVEI	C,1		;FLAG THAT A ZERO POINTER HAS BEEN SEEN
FCOPY7:	AOBJN	X,FCOPY2
	SKIPN	RTSAV+11	;DNXTGP
	JRST	FCOPY8		;NO NEXT GROUP
	JUMPE	C,.+2		;JUMP IF NO ZERO POINTERS HAVE BEEN SEEN
	HALT	.		;INCONSISTENT RTVL (NON ZERO DNXTGP FOLLOWS 0 PNTR)
	PUSHJ	P,GETBLK
	MOVEM	A,RTSAV+11	;NEW NEXT GROUP
	SOS	LSTBLK		;SO NEXT TIME WE ASK WE GET THE SAME.
FCOPY8:	MOVSI	X,-TRKGRP	;NUMBER OF TRACKS TO READ IN GROUP.
FCOPY9:	TREAD	(R)		;READ A TRACK
	MOVEI	A,0
	MOVEI	B,1(X)
	CAILE	B,TRKGRP-1
	JRST	FCP11A
	ROT	B,-1
	JUMPL	B,FCP.10
	HLRZ	A,TTRACK+DDRET(B)
	JRST	FCP.11
FCP.10:	HRRZ	A,TTRACK+DDRET(B)
	JRST	FCP.11
FCP11A:	HRRZ	A,TTRACK+11	;DNXTGP
FCP.11:	PUSH	P,A		;TRACK ADDRESS OF NEXT TRACK TO READ.
	MOVEI	B,(X)		;GET ADDRESS OF WHERE TO WRITE
	ROT	B,-1
	JUMPL	B,FCP.12
	HLRZ	R,RTSAV+DDRET(B)
	JRST	FCP.13
FCP.12:	HRRZ	R,RTSAV+DDRET(B)
FCP.13:	MOVE	A,[RTSAV,,TTRACK]
	BLT	A,TTRACK+WDRTVL-1
	PUSHJ	P,XWRITE	;WRITE ONE TRACK (R= TRACK NUMBER)
	POP	P,R		;POP NEXT TRACK TO READ
	JUMPE	R,CPOPJ
	AOBJN	X,FCOPY9	;CONTINUE IN THIS GROUP
	JRST	FCOPY1		;ADVANCE TO NEXT GROUP

;WRITE MFD OR UFD FROM CORE.
MWRITE:	MOVE	A,[MRTSV,,TTRACK]
	BLT	A,TTRACK+DDRET-1
	SETZM	LSTBLK
	MOVEI	A,1
	MOVEM	A,TTRACK+4
	MOVE	X,MFDPTR
	JRST	UWRIT1

UWRITE:	MOVE	A,[URTSV,,TTRACK] ;WRITE UFD FROM CORE
	BLT	A,TTRACK+DDRET-1 ;COPY RTVL OF ORIGINAL UFD
	PUSHJ	P,GETBLK	;GET A BLOCK FOR WRITING THE UFD
	MOVEM	A,3(Z)		;STORE IN INCORE COPY OF MFD
	SOS	LSTBLK		;DECREMENT SO NEXT TIME WE GET THE SAME ONE.
	HRRZM	A,TTRACK+4	;DDLOC
	MOVE	X,DIOWD		;IOWD FOR INCORE COPY OF UFD
UWRIT1:	MOVEI	R,(A)		;TRACK NUMBER FOR FIRST BLOCK.
	HLRO	A,X
	MOVN	A,A		;LENGTH OF THE FILE
	CAME	A,TTRACK+5	;SHOULD MATCH
	HALT	.
	IDIVI	A,4400		;NUMBER OF TRACKS NEEDED.
	JUMPE	B,.+2
	ADDI	A,1		;IF ANY REMAINDER, WE NEED ANOTHER TRACK
	CAILE	A,TRKGRP
	HALT	.		;SHIT. WE NEED ANOTHER GROUP.
	SETZM	TTRACK+11	;DNXTGP  NO NEXT GROUP
	MOVN	K,A		;NUMBER OF TRACKS NEEDED.
	MOVSI	K,(K)
	MOVE	L,K
UWRIT2:	PUSHJ	P,GETBLK
	MOVEI	B,(K)
	ROT	B,-1
	JUMPL	B,UWRIT3
	HRLM	A,TTRACK+DDRET(B)
	JRST	UWRIT4
UWRIT3:	HRRM	A,TTRACK+DDRET(B)
UWRIT4:	AOBJN	K,UWRIT2	;LOOP MAKING GROUP RTVL.
	MOVE	K,L
UWRIT5:	HLRO	A,X		;-WC
	MOVN	A,A
	CAILE	A,4400
	MOVEI	A,4400		;MAX COUNT PER TRACK
	MOVSI	B,(A)
	HRRI	B,(A)		;WC,,WC FOR THIS TRACK.
	MOVSI	C,1(X)		;SOURCE'OF DATA
	HRRI	C,TT0
	BLT	C,TT0-1(A)	;TRANSFER FROM CORE TO TTRACK
	ADD	X,B		;UPDATE IOWD FOR CORE FILE
	MOVEI	B,(K)
	ROT	B,-1
	JUMPL	B,UWRIT6
	HLRZ	R,TTRACK+DDRET(B)
	JRST	UWRIT7
UWRIT6:	HRRZ	R,TTRACK+DDRET(B)
UWRIT7:	PUSHJ	P,XWRITE	;WRITE TTRACK USING R AS TRACK NUMBER.
	AOBJN	K,UWRIT5	;LOOP
	POPJ	P,		;DONE.

GETBLK:	PUSH	P,R
GETBL1:	AOS	R,LSTBLK	;GET NUMBER OF LAST BLOCK ALLOCATED
	CAIL	R,1457*3*23	;IN BOUNDS?
	HALT	.		;NO.
	PUSHJ	P,SBYTE		;MAKE A BYTE POINTER
	LDB	R,SSATBT
	JUMPN	R,GETBL1
	POP	P,R
	MOVE	A,LSTBLK
	POPJ	P,

>;IFN RALLOC

;SWPSYS  WRITE THE FILE [SWAP].SYS[1,4] ON THE FILE SYSTEM

BEGIN SWPSYS

SWPSYS:	OUTSTR [ASCIZ /
This routine writes [SWAP].SYS[1,4] in all the appropriate places on the
file system packs.  You must already have ↓  1  4↓.UFD[1,1].  This must
be a bare machine that won't attempt to swap.  Type CONTINUE if it is
ok to go on.

/]
	EXIT 1,

;READ MFD INTO CORE.
	MOVE A,JOBFF
	MOVEM A,SAVFF
;SETUP DATE AND TIME PARAMETERS
	DATE B,
	MOVEM B,THSDAZ		;FILE SYSTEM DATE AND TIME
	LDB C,[POINT 3,B,23]
	DPB C,[POINT 3,B,20]
	MOVEM B,THSDAX		;DATE SUITABLE FOR RH OF FILE EXT
	TIMER C,
	IDIVI C,=60*=60		;MINUTES SINCE MIDNITE IN C
	DPB C,[POINT 11,THSDAZ,23]	;STORE FOR WORD 3 OF FILE RTVL
	MOVE A,['  1  1']	;GET NAME OF MFD
	MOVEM A,RTSAV
	MOVEM A,RTSAV+3		;SAVE AS EXPECTED RETRIEVAL
	MOVSI A,'UFD'
	MOVEM A,RTSAV+1
	MOVEI R,1		;READ MFD FROM BLOCK 1
	PUSHJ P,FREAD		;READ FILE
	MOVE Z,DIOWD		;GET THE IOWD OF FILE
	MOVEM Z,MFDPTR		;SAVE AS MFD POINTER
	AOJGE Z,EMMFD
S14LP:	SKIPN A,(Z)
	JRST S14L1
	HLRZ B,1(Z)
	CAMN A,['  1  4']
	CAIE B,'UFD'
	JRST S14L1
	JRST S14FND

S14L1:	ADD Z,[UFDN,,UFDN]
	JUMPL Z,S14LP
	OUTSTR [ASCIZ /
Can't find ↓  1  4↓.UFD in MFD!
/]
	JRST DDTCAL

S14FND:	MOVE A,['  1  4']
	MOVEM A,RTSAV
	MOVSI A,'UFD'
	MOVEM A,RTSAV+1
	MOVE A,['  1  1']
	MOVEM A,RTSAV+3
	MOVE R,3(Z)		;GET ADDRESS OF 1,4 UFD FROM MFD ENTRY
	PUSHJ P,RTRD		;READ AND CHECK RETRIEVAL
	MOVE R,3(Z)
	TREAD (R)		;FIRST (AND ONLY) TRACK OF 1,4 UFD

	SKIPE TTRACK+5		;skip if the UFD length is zero
	JRST BAD14		;must start with zero!
	MOVEI B,UFDN		;length of one UFD entry
	MOVEM B,TTRACK+5	;fix length of UFD
	MOVE A,['[SWAP]']
	MOVSI B,'SYS'
	MOVEM A,TT0		;save file name
	MOVEM B,TT0+1		;save ext
	MOVE A,SWPRET		;LOCATION OF THE FILE [SWAP].SYS
	MOVEM A,TT0+3		;set retreival
	MOVE A,THSDAX
	HRRM A,TT0+1		;fix date
	SETZM TT0+2		;zero protection/mode
	MOVE A,THSDAZ
	DPB A,[POINT 23,TT0+2,35]	;STORE NEW TIME AND DATE WRITTEN
	MOVE A,[SWPAKS*NSWCYL*NTPC*DWDTRK]
	MOVEM A,TT0+4			;FILE LENGTH IN UFD
	LDB A,[POINT 15,THSDAX,35]	;DATE
	LDB B,[POINT 11,THSDAZ,23]	;TIME IN MINUTES
	IMULI B,=60*=15			;TIME IN 15THS
	DPB A,[POINT 15,B,14]		;EXTENDED TIME WRITTEN FORMAT
	MOVEM B,TT0+5			;EXTENDED TIME WRITTEN
	SETZM TT0+6
	MOVE A,[TT0+6,,TT0+7]
	BLT A,TT0+UFDN-1		;CLEAR REST OF UFD ENTRY
	MOVE A,SATID
	MOVEM A,TT0+12			;SATID IN UFD ENTRY
;Put breakpoint here if you feel unsafe.
WRT14:	PUSHJ P,XWRITE			;WRITE 1  4.UFD BACK OUT
	SETZM TTRACK
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDTRK-1
	MOVE A,['[SWAP]']
	MOVEM A,TTRACK
	MOVSI A,'SYS'
	HRR A,THSDAX
	MOVEM A,TTRACK+1
	MOVSI A,777740
	IOR A,THSDAZ
	MOVEM A,TTRACK+2
	MOVE A,['  1  4']
	MOVEM A,TTRACK+3
	MOVE A,SWPRET
	MOVEM A,TTRACK+4		;DDLOC
	MOVE A,[SWPAKS*NSWCYL*NTPC*DWDTRK]	;NUMBER OF WORDS IN [SWAP].SYS FILE
	MOVEM A,TTRACK+5		;DDLNG
	MOVEI A,1
	MOVEM A,TTRACK+10		;DGRP1R
	MOVE A,SATID
	MOVEM A,TTRACK+12		;DSATID
	MOVE Z,[-SWPRXX,,SWPRET]	;POINTER TO THE TRACKS WE NEED.
;START A GROUP.
GRW:	MOVSI Y,-TRKGRP			;NUMBER OF TRACKS/GROUP
	SETZM TTRACK+DDRET
	MOVE A,[TTRACK+DDRET,,TTRACK+DDRET+1]
	BLT A,TTRACK+DDRET+<TRKGRP/2>-1
GRW0:	MOVE A,(Z)			;GET A TRACK NUMBER
	MOVEI B,(Y)
	ROT B,-1			;DIVIDE BY 2
	JUMPL B,GRW1
	HRLM A,TTRACK+DDRET(B)
	JRST GRW2

GRW1:	HRRM A,TTRACK+DDRET(B)
GRW2:	AOBJP Z,GRW3			;ADVANCE TO NEXT TRACK. JUMP IF NO NEXT.
	AOBJN Y,GRW0			;LOOP TO NEXT TRACK IN GROUP
	SKIPA A,(Z)			;GET NEXT TRACK = DNXTGP
GRW3:	MOVEI A,0			;NO NEXT TRACK
	HRRZM A,TTRACK+11		;STORE NEXT GROUP POINTER
	MOVSI Y,-TRKGRP
GRW4:	MOVEI B,(Y)
	ROT B,-1
	JUMPL B,GRW5
	HLRZ R,TTRACK+DDRET(B)
	JRST GRW6

GRW5:	HRRZ R,TTRACK+DDRET(B)
GRW6:	JUMPE R,GRW7			;WHEN ALL OUT OF RTVL, WE'RE DONE!
	PUSHJ P,XWRITE			;WRITE ONE TRACK
	AOBJN Y,GRW4
	MOVEI A,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDM A,TTRACK+10		;DGRP1R
	JUMPL Z,GRW			;WRITE ANOTHER GROUP.
GRW7:	PUTSTR [ASCIZ/[SWAP].SYS[1,4] written.  Done.
/]
	JRST DDTCAL

BAD14:	OUTSTR [ASCIZ /
1  4.UFD contains bad data.  Examine TTRACK.
/]
	JRST DDTCAL

EMMFD:	OUTSTR [ASCIZ /
The MFD is empty!!
/]
	JRST DDTCAL

XWRITE:	PUSH P,A
	MOVE A,[TTRACK,,BUFR]
	BLT A,BUFR+WDRTVL-1
	RREAD (R)
	MOVE A,TTRACK
	CAMN A,BUFR
	JRST TWOK
	SKIPE TTRACK+DSATID
	JRST 4,.
TWOK:	MOVE A,[BUFR,,TTRACK]
	BLT A,TTRACK+WDRTVL-1
	POP P,A
;;;PRINTX FIX ME--TWRITE to write 1,4 track is patched out at TWOK+3.
	TWRITE (R)
;;;	CAI (R)		;Patch this to TWRITE (R)
	POPJ P,

BUFR:	BLOCK WDRTVL

BEND SWPSYS
;C1MAKE  MAKE A SMALL FILE SYSTEM FOR C1 USE

C1MAKE:	PUTSTR [ASCIZ /MOUNT THE NEW C1 PACKS ON DRIVES 0,1,2 AND 3.
MAKE SURE THAT THE OLD SYSTEM PACKS ARE NOT WRITE ENABLED.
TYPE CONTINUE TO PROCEDE.
/]
	EXIT 1,
	PUSH P,UDPOK
	SETOM UDPOK
;BUILD INCORE SAT
	PUSH P,SATID			;SAVE SATID
	SETZM SSAT
	MOVE B,[SSAT,,SSAT+1]
	BLT B,SATEND			;ZERO SAT (AND RALPH SPECIAL COPY OF SAT)
	POP P,SATID			;RESTORE SATID

;SETUP DATE AND TIME PARAMTERS
	DATE B,
	MOVEM B,THSDAZ			;FILE SYSTEM DATE AND TIME
	LDB C,[POINT 3,B,23]
	DPB C,[POINT 3,B,20]
	MOVEM B,THSDAX			;DATE SUITABLE FOR RH OF FILE EXT
	TIMER C,
	IDIVI C,74*74			;MINUTES SINCE MIDNITE IN C
	DPB C,[POINT 11,THSDAZ,23]	;STORE FOR WORD 3 OF FILE RTVL

;BUILD MFD IN CORE
	SETZM TTRACK
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDTRK-1
	MOVE A,['  1  1']	;GET NAME OF MFD
	MOVEM A,TTRACK
	MOVEM A,TTRACK+3
	MOVSI A,'UFD'
	HRR A,THSDAX
	MOVEM A,TTRACK+1
	MOVSI A,000740		;PREVENT ALL ACCESS TO THIS DIRECTORY
	IOR A,THSDAZ
	MOVEM A,TTRACK+2
	MOVEI A,1
	MOVEM A,TTRACK+4	;DDLOC
	MOVEI A,4*UFDN
	MOVEM A,TTRACK+5	;DDLNG	;4 FILES IN MFD
	MOVEI A,1
	MOVEM A,TTRACK+10	;DGRP1R
	MOVE A,SATID
	MOVEM A,TTRACK+12	;DSATID
	MOVEI A,1
	MOVSM A,TTRACK+DDRET	;RETRIEVAL POINTERS
	MOVE A,['  1  2']
	MOVEM A,TT0
	MOVE A,['  1  3']
	MOVEM A,TT0+UFDN
	MOVE A,['  PSYS']
	MOVEM A,TT0+2*UFDN
	MOVE A,['  1  4']
	MOVEM A,TT0+3*UFDN
	MOVSI A,'UFD'
	HRR A,THSDAX
	MOVEM A,TT0+1
	MOVEM A,TT0+UFDN+1
	MOVEM A,TT0+2*UFDN+1
	MOVEM A,TT0+3*UFDN+1
	MOVSI A,000740		;PREVENT ALL ACCESS TO THIS DIRECTORY
	IOR A,THSDAZ
	MOVEM A,TT0+2
	MOVEM A,TT0+UFDN+2
	MOVEM A,TT0+2*UFDN+2
	MOVEM A,TT0+3*UFDN+2
	MOVEI A,2
	MOVEM A,TT0+3
	MOVEI A,3
	MOVEM A,TT0+UFDN+3
	MOVEI A,4
	MOVEM A,TT0+2*UFDN+3
	MOVEI A,5
	MOVEM A,TT0+3*UFDN+3
	MOVEI R,1		;WRITE THE MFD
	PUSHJ P,SWRITE

;BUILD [1,4].UFD, CONTAINING ONE FILE, [SWAP].SYS
	SETZM TTRACK
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDTRK-1
	MOVE A,['  1  4']
	MOVEM A,TTRACK
	MOVSI A,'UFD'
	HRR A,THSDAX
	MOVEM A,TTRACK+1
	MOVSI A,155740		;PREVENT ALL ACCESS TO THIS DIRECTORY
	IOR A,THSDAZ
	MOVEM A,TTRACK+2
	MOVE A,['  1  1']
	MOVEM A,TTRACK+3
	MOVEI R,5
	MOVEM R,TTRACK+4	;DDLOC = FIRST BLOCK OF FILE
	MOVEI B,UFDN
	MOVEM B,TTRACK+5	;DDLNG LENGTH	;1 FILE IN 1,4
	MOVEI B,1
	MOVEM B,TTRACK+10	;DGRP1R RECORD NUMBER OF FIRST RECORD OF THIS GR.
	MOVE B,SATID
	MOVEM B,TTRACK+12	;DSATID
	MOVE B,['[SWAP]']
	MOVEM B,TTRACK+13	;PASSWORD
	HRLZM R,TTRACK+DDRET	;RETRIEVAL POINTERS.
	MOVEM B,TT0		;FILE NAME
	MOVSI B,'SYS'
	HRR B,THSDAX
	MOVEM B,TT0+1
	MOVSI B,777740
	IOR B,THSDAZ
	MOVEM B,TT0+2
	MOVE B,SWPRET	;LOCATION OF THE FILE [SWAP].SYS
	MOVEM B,TT0+3
	PUSHJ P,SWRITE	;WRITE '  1  4'.UFD[1,1] (USES TRACK NUMBER IN R)
	PUTSTR [ASCIZ/  1  4.UFD WRITTEN
/]

;CREATE THE FILE [SWAP].SYS[1,4] AND WRITE ITS RETRIEVAL
	MOVE A,[TT0,,TTRACK]
	BLT A,TTRACK+2		;DDNAM, DDEXT, DDPRO.
	MOVE A,['  1  4']
	MOVEM A,TTRACK+3	;DDPPN
	MOVE A,SWPRET
	MOVEM A,TTRACK+4	;DDLOC
	MOVE A,[SWPAKS*NSWCYL*NTPC*DWDTRK]	;DDLNG (length of file)
	MOVEM A,TTRACK+5
	SETZM TTRACK+13
	MOVE A,[TTRACK+13,,TTRACK+14]
	BLT A,TTRACK+WDTRK-1
	MOVE Z,[-SWPRXX,,SWPRET]	;POINTER TO THE TRACKS WE NEED.
;START A GROUP.
CGRW:	MOVSI Y,-TRKGRP			;NUMBER OF TRACKS/GROUP
	SETZM TTRACK+DDRET
	MOVE A,[TTRACK+DDRET,,TTRACK+DDRET+1]
	BLT A,TTRACK+DDRET+<TRKGRP/2>-1
CGRW0:	MOVE A,(Z)			;GET A TRACK NUMBER
	MOVEI B,(Y)
	ROT B,-1			;DIVIDE BY 2
	JUMPL B,CGRW1
	HRLM A,TTRACK+DDRET(B)
	JRST CGRW2

CGRW1:	HRRM A,TTRACK+DDRET(B)
CGRW2:	AOBJP Z,CGRW3			;ADVANCE TO NEXT TRACK. JUMP IF NO NEXT.
	AOBJN Y,CGRW0			;LOOP TO NEXT TRACK IN GROUP
	SKIPA A,(Z)			;GET NEXT TRACK = DNXTGP
CGRW3:	MOVEI A,0			;NO NEXT TRACK
	HRRZM A,TTRACK+11		;STORE NEXT GROUP POINTER
	MOVSI Y,-TRKGRP
CGRW4:	MOVEI B,(Y)
	ROT B,-1
	JUMPL B,CGRW5
	HLRZ R,TTRACK+DDRET(B)
	JRST CGRW6

CGRW5:	HRRZ R,TTRACK+DDRET(B)
CGRW6:	JUMPE R,CGRW7			;WHEN ALL OUT OF RTVL, WE'RE DONE!
	PUSHJ P,SWRITE			;WRITE ONE TRACK
	AOBJN Y,CGRW4
	MOVEI A,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDM A,TTRACK+10		;DGRP1R
	JUMPL Z,CGRW			;WRITE ANOTHER GROUP.
CGRW7:	PUTSTR [ASCIZ/[SWAP].SYS[1,4]
/]

;BUILD [1,2].UFD CONTAINING LOGIN.DMP
	SETZM TTRACK
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDTRK-1
	MOVE A,['  1  2']
	MOVEM A,TTRACK
	MOVSI A,'UFD'
	HRR A,THSDAX
	MOVEM A,TTRACK+1
	MOVSI A,155740		;PREVENT ALL ACCESS TO THIS DIRECTORY
	IOR A,THSDAZ
	MOVEM A,TTRACK+2
	MOVE A,['  1  1']
	MOVEM A,TTRACK+3
	MOVEI R,2
	MOVEM R,TTRACK+4	;DDLOC = FIRST BLOCK OF FILE
IFE FTF2,<
	MOVEI B,UFDN		;ONE FILE IN 1,2
>;IFE FTF2
IFN FTF2,<
	MOVEI B,0		;Don't create any files
>;IFN FTF2
	MOVEM B,TTRACK+5	;DDLNG LENGTH
	MOVEI B,1
	MOVEM B,TTRACK+10	;DGRP1R RECORD NUMBER OF FIRST RECORD OF THIS GR.
	MOVE B,SATID
	MOVEM B,TTRACK+12	;DSATID
	HRLZM R,TTRACK+DDRET	;RETRIEVAL POINTERS.
IFE FTF2,<
	MOVE B,['LOGIN ']
	MOVEM B,TT0		;FILE NAME
	MOVSI B,'DMP'
	HRR B,THSDAX
	MOVEM B,TT0+1
	MOVE B,THSDAZ
	MOVEM B,TT0+2
	MOVEI B,6		;LOCATION OF LOGIN.DMP
	MOVEM B,TT0+3
>;IFE FTF2
	PUSHJ P,SWRITE	;WRITE '  1  2'.UFD[1,1] (USES TRACK NUMBER IN R)
	PUTSTR [ASCIZ/  1  2.UFD WRITTEN
/]

;BUILD [1,3].UFD, CONTAINING E, FAIL AND LOADER
	SETZM TTRACK
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDTRK-1
	MOVE A,['  1  3']
	MOVEM A,TTRACK
	MOVSI A,'UFD'
	HRR A,THSDAX
	MOVEM A,TTRACK+1
	MOVE A,THSDAZ
	MOVEM A,TTRACK+2
	MOVE A,['  1  1']
	MOVEM A,TTRACK+3
	MOVEI R,3
	MOVEM R,TTRACK+4	;DDLOC = FIRST BLOCK OF FILE
IFE FTF2,<
	MOVEI B,3*UFDN		;3 FILES IN 1,3
>;IFE FTF2
IFN FTF2,<
	MOVEI B,0		;No files
>;IFN FTF2
	MOVEM B,TTRACK+5	;DDLNG LENGTH
	MOVEI B,1
	MOVEM B,TTRACK+10	;DGRP1R RECORD NUMBER OF FIRST RECORD OF THIS GR.
	MOVE B,SATID
	MOVEM B,TTRACK+12	;DSATID
	HRLZM R,TTRACK+DDRET	;RETRIEVAL POINTERS.
IFE FTF2,<
	MOVE B,['E     ']
	MOVEM B,TT0		;FILE NAME
	MOVE B,['FAIL  ']
	MOVEM B,TT0+UFDN
	MOVE B,['LOADER']
	MOVEM B,TT0+2*UFDN
	MOVSI B,'DMP'
	HRR B,THSDAX
	MOVEM B,TT0+1
	MOVEM B,TT0+UFDN+1
	MOVEM B,TT0+2*UFDN+1
	MOVE B,THSDAZ
	MOVEM B,TT0+2
	MOVEM B,TT0+UFDN+2
	MOVEM B,TT0+2*UFDN+2
	MOVEI B,7		;LOCATION OF E.DMP
	MOVEM B,TT0+3
	MOVEI B,10		;LOCATION OF FAIL.DMP
	MOVEM B,TT0+UFDN+3
	MOVEI B,11
	MOVEM B,TT0+2*UFDN+3
>;IFE FTF2
	PUSHJ P,SWRITE	;WRITE '  1  3'.UFD[1,1] (USES TRACK NUMBER IN R)
	PUTSTR [ASCIZ/  1  3.UFD WRITTEN
/]

;BUILD [P,SYS].UFD, CONTAINING RALPH, RALPH.DMP
	SETZM TTRACK
	MOVE A,[TTRACK,,TTRACK+1]
	BLT A,TTRACK+WDTRK-1
	MOVE A,['  PSYS']
	MOVEM A,TTRACK
	MOVSI A,'UFD'
	HRR A,THSDAX
	MOVEM A,TTRACK+1
	MOVE A,THSDAZ
	MOVEM A,TTRACK+2
	MOVE A,['  1  1']
	MOVEM A,TTRACK+3
	MOVEI R,4
	MOVEM R,TTRACK+4	;DDLOC = FIRST BLOCK OF FILE
IFE FTF2,<
	MOVEI B,2*UFDN		;2 FILES IN P,SYS
>;IFE FTF2
IFN FTF2,<
	MOVEI B,0		;No files
>;IFN FTF2
	MOVEM B,TTRACK+5	;DDLNG LENGTH
	MOVEI B,1
	MOVEM B,TTRACK+10	;DGRP1R RECORD NUMBER OF FIRST RECORD OF THIS GR.
	MOVE B,SATID
	MOVEM B,TTRACK+12	;DSATID
	HRLZM R,TTRACK+DDRET	;RETRIEVAL POINTERS.
IFE FTF2,<
	MOVE B,['RALPH ']
	MOVEM B,TT0		;FILE NAME
	MOVEM B,TT0+UFDN
	MOVE B,THSDAX
	MOVEM B,TT0+1
	MOVSI B,'DMP'
	HRR B,THSDAX
	MOVEM B,TT0+UFDN+1
	MOVE B,THSDAZ
	MOVEM B,TT0+2
	MOVEM B,TT0+UFDN+2
	MOVEI B,12		;LOCATION OF RALPH
	MOVEM B,TT0+3
	MOVEI B,13		;LOCATION OF RALPH.DMP
	MOVEM B,TT0+UFDN+3
>;IFE FTF2
	PUSHJ P,SWRITE	;WRITE '  PSYS'.UFD[1,1] (USES TRACK NUMBER IN R)
	PUTSTR [ASCIZ/  PSYS.UFD WRITTEN
/]

;WRITE SAT
	MOVE A,[SSAT,,TTRACK]
	BLT A,TTRACK+WDTRK-1
IFN FTF2,<
	FORCE			;FORCE SAT OUT
>;IFN FTF2
IFE FTF2,<
	TWRITE 0		;WRITE SAT TABLE
>;IFE FTF2
	PUTSTR [ASCIZ/DONE!
/]
	JRST 4,CPOPJ

C1NEXT:	17			;NEXT FREE DISK ADDR
C1FILE:	'LOGIN '
	'DMP   '
	0
	'  1  2'
C1ADDR:	6
C1RETR:	BLOCK WDRTVL
C1FRST:	0

C1COP:	INIT 17,17
	'DSK   '
	0
	0
	MOVEI C,0
	MOVE X,[C1FILE,,A]
	BLT X,A+3
	LOOKUP 17,A
	JRST [	PUTSTR [ASCIZ /LOOKUP FAILED
/]
		JRST DDTCAL	]
	MTAPE 17,[	'GODMOD'
			14		;READ RETRIEVAL
			-WDRTVL,,TTRACK-1	]
	 JRST [	PUTSTR [ASCIZ /READ RETRIEVAL FAILED
/]
		JRST DDTCAL	]
	MOVE R,TTRACK+4		;DDLOC OF FILE
	TREAD (R)		;READ FIRST TRACK
	MOVE B,C1ADDR
	MOVEM B,C1FRST
C1COP2:	PUSHJ P,C1FIXG
	MOVEI X,TRKGRP		;TRACKS/GROUP
	MOVE Y,[POINT 18,RTSAV+DDRET]
	MOVE Z,[POINT 18,C1RETR+DDRET]
C1COPL:	ILDB R,Y
	JUMPE R,C1COP1
	TREAD (R)
	MOVE A,[C1RETR,,TTRACK]
	BLT A,TTRACK+WDRTVL-1
	PUSHJ P,CNVT
	ILDB R,Z
	TWRITE UDPORG(R)
	SOJG X,C1COPL
	SKIPN R,RTSAV+11	;DNXTGP
	JRST C1COP1
	TREAD (R)
	MOVE B,C1NEXT
	MOVEM B,C1FRST
	AOS C1NEXT
	JRST C1COP2

C1COP1:	RELEASE 17,
	PUTSTR [ASCIZ /DONE
/]
	JRST DDTCAL

C1FIXG:	MOVE A,[TTRACK,,RTSAV]	;FIX AND COPY GROUP RETRIEVAL
	BLT A,RTSAV+WDRTVL-1	;SAVE RETRIEVAL
	MOVE A,C1ADDR
	MOVEM A,TTRACK+4	;FIX DDLOC
	MOVEI X,TRKGRP		;TRACKS/GROUP
	MOVE Y,[POINT 18,TTRACK+DDRET]
	SOS C1NEXT
C1FIX1:	ILDB A,Y		;GET FILE DISK RETRIEVAL
	JUMPE A,C1FIX2		;END OF FILE
	MOVE B,C1NEXT
	DPB B,Y			;STORE NEW RETRIEVAL
	AOS C1NEXT
	SOJG X,C1FIX1
C1FIX2:	MOVE B,C1FRST
	HRLM B,TTRACK+DDRET
	MOVE A,C1NEXT
	SKIPE RTSAV+11		;IS THERE ANOTHER GROUP
	MOVEM A,TTRACK+11	;YES, STORE DNXTGP
	MOVE A,[TTRACK,,C1RETR]
	BLT A,C1RETR+WDRTVL-1
	POPJ P,

SWRITE:	SETSAT (R)
;	PUSHJ P,CNVT
	TWRITE (R)
;	PUSHJ P,CNVTB
	POPJ P,

MRTSV:	BLOCK	UFDN	;SAVE MFD ORIGINAL RTVL INFO
URTSV:	BLOCK	UFDN	;SAVE UFD ORIGINAL RTVL INFO

;AMPEX DISK TESTING UNDER TIMESHARING.

REPEAT 0,<

PRINTX	AMPEX DISK TESTING UNDER TIMESHARING -  3*815 SYSTEM + 6*815 UDPS

ORGAMP==NTPP*4	;ORIGIN OF AMPEX DISK.


AMPTST:	PUTSTR	[ASCIZ/TESTING OF AMPEX DISK DURING TIMESHARING.
USES AMPEX DRIVES 0,1, AND 2
/]
	SETZM	AMPASS#
	PUSH	P,UDPOK
	SETOM	UDPOK
	PUSHJ	P,AMPTS0
	POP	P,UDPOK
	JRST	DDTCAL

AMPTS0:	PUSH	P,CTYTYO
	SETOM	CTYTYO
	PUTSTR	[ASCIZ/AMPEX TEST PASS /]
	AOS	W,AMPASS
	PUSHJ	P,DECOUT
	PUTSTR	CRLF
	POP	P,CTYTYO
	MOVSI	R,-3*NTPP
AMPTS1:	TREAD	ORGAMP(R)
	TWRITE	ORGAMP(R)
	TREAD	ORGAMP(R)
	AOBJN	R,AMPTS1

AMPTS2:	MOVEI	Z,10
	MOVE	Y,[3.141592]		;A RANDOM NUMBER
AMPTS3:
III==ORGAMP
REPEAT 3,<
	MOVEI	R,III
	PUSHJ	P,SHAKER
III==III+NTPP
>
	SOJG	Z,AMPTS3
	JRST	AMPTS0

ACOPY:	PUTSTR	[ASCIZ/MOUNT THE SOURCE PACKS ON IBM, THE DESTINATION
PACKS ON AMPEX.  THEN TYPE CONTINUE
/]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	MOVSI	R,-NTPP*3		;-COUNT OF TRACKS/PACK
ACOPY1:	TREAD	(R)			;READ DATA
	TWRITE	ORGAMP(R)		;WRITE DATA
	TREAD	ORGAMP(R)		;READBACK TO VERIFY
	AOBJN	R,ACOPY1
	PUTSTR	[ASCIZ/DONE.  CHANGE AMPEX CU ADDRESS, TAKE IBM OFFLINE
AND MOVE THE SWAPPING PACK TO AMPEX #3
/]
	POP	P,UDPOK			;RESTORE STATE OF UDPOK.
	JRST	DDTCALL


>;REPEAT 0
;ANOTHER DISK TEST PROCEDURE

ADTP:	MOVEI	A,0
ADTP1:	MOVSI	R,-NTPP
	MOVSI	B,(A)
	HRRI	B,(A)
	ADD	R,B
ADTP2:	TREAD	(R)
	ADD	R,[NTPC+1,,NTPC+1]
	JUMPL	R,ADTP2
	CAIGE	A,NTPC
	AOJA	A,ADTP1
	TTYUUO	3,[ASCIZ/PASS COMPLETE
/]
	JRST	ADTP

;SYSTST  - A TEST OF THE SYSTEM, NOT OF THE DISK, WRITES TRACK 0 OF UDP1

SYSTST:	MOVSI	R,-WDTRK
	MOVEM	R,TTRACK(R)		;AN UNIQUE, IF UNDISTINGUISHED, PATTERN
	AOBJN	R,.-1
SYSTS0:	TWRITE	TRACKS			;WRITE ON TRACK 0 OF UDP1
	SETZM	TTRACK
	MOVE	R,[TTRACK,,TTRACK+1]
	BLT	R,TTRACK+WDTRK-1
	TREAD	TRACKS
	MOVSI	R,-WDTRK
	CAME	R,TTRACK(R)
SYSBRK:	JRST	SYSTST
	AOBJN	R,.-2
	JRST	SYSTS0
;RECOVER  SEARCH ENTIRE DISK TO REPAIR DAMAGED DIRECTORIES


URCOVR:	MOVSI	R,-TRACKS
	ADD	R,[1,,1]		;SKIP TRACK 0
URCOV1:	RREAD	(R)			;READ RETRIEVAL
	MOVSI	S,-NSKFIL		;NUMBER OF FILES WE'RE SEEKING
	MOVE	A,TTRACK
	HLLZ	B,TTRACK+1
	MOVE	D,TTRACK+3
URCOV2:	CAMN	A,SKFILE(S)
	CAME	B,SKFILE+1(S)
	JRST	URCOV3
	CAMN	D,SKFILE+3(S)
	SKIPN	TTRACK+DSATID		;MAKE SURE THERE'S A VALID SATID
	JRST	URCOV3
	MOVE	A,TTRACK+DDLOC
	MOVEM	A,SKFILE+3(S)		;IT'S REASONABLE TO ASSUME THAT NO PPN
	MOVE	B,TTRACK+1		;WILL MATCH A TRACK NUMBER
	MOVEM	B,SKFILE+1(S)
	MOVE	C,TTRACK+2
	MOVEM	C,SKFILE+2(S)
	HALT .+1
URCOV3:	ADD	S,[4,,4]
	JUMPL	S,URCOV2		;LOOP THRU FILE NAMES
	AOBJN	R,URCOV1		;LOOP THRU DISK
	JRST	DDTCALL

SKFILE:
	SIXBIT /MSG/
	0
	0
	SIXBIT /  1DGL/
	SIXBIT /   JJK/
	SIXBIT /MSG/
	0
	SIXBIT /  2  2/
NSKFIL←←.-SKFILE

;UFDSRC		GET ALL UFD NAMES INTO CORE

UFDSRC:	MOVSI	R,-TRACKS
	ADD	R,[1,,1]		;SKIP TRACK 0
	HRRZ S,JOBFF
	MOVEM S,UFDFST
	AOS UFDFST
	MOVE A,JOBFF
	ADDI A,=10000
	CORE A,
	 HALT .
UFDSR1:	RREAD	(R)			;READ RETRIEVAL
	HLRZ	B,TTRACK+1
	TRZ B,77
	SKIPE	TTRACK+DSATID		;MAKE SURE THERE'S A VALID SATID
	CAIE B,'UF '
	JRST UFDSR2
	PUSH S,TTRACK
	PUSH S,R
UFDSR2:	AOBJN	R,UFDSR1		;LOOP THRU DISK
	MOVEM S,UFDLST
	JRST	DDTCALL

UFDFST:	0
UFDLST:	0
;RECOVER  SEARCH ENTIRE DISK TO REPAIR DAMAGED DIRECTORIES

repeat 0,<

URCOVR:	INIT 17,17
	SIXBIT /DSK/
	0
	0
	MOVE A,[SIXBIT /FILES/]
	MOVE B,[SIXBIT /GON/]
	MOVEI C,0
	MOVE D,[SIXBIT /  SJBR/]
	LOOKUP 17,A
	JRST 4,.
	HRRI D,GONE-1			;IOWD TO FILES.GON
	MOVEI W,0
	INPUT 17,D
	SETZM SKFILE
	MOVE A,[SKFILE,,SKFILE+1]
	BLT A,SKEND-1
	MOVE S,[-4*=400,,SKFILE-1]
	MOVE W,[POINT 7,GONE]
URCOV0:	PUSHJ P,RDGONE
	JRST URCOVA			;NO MORE
	PUSH S,A
	PUSH S,B
	PUSH S,C
	PUSH S,D
	JRST URCOV0
URCOVA:	MOVSI R,-TRACKS
	ADD R,[1,,1]			;SKIP TRACK 0
	MOVE Y,[-10000,,UFDBAK-1]
URCOV1:	RREAD (R)			;READ RETRIEVAL
	SKIPE TTRACK
	SKIPN TTRACK+DSATID
	JRST URCOV4
	PUSHJ P,RCOVIT
	JRST URCOV4			;DON'T WANT IT BACK
	MOVE A,TTRACK+DDLOC
	MOVEM A,2(W)
URCOV4:	AOBJN R,URCOV1		;LOOP THRU DISK
	JRST DDTCALL

RCOVIT:	MOVE A,TTRACK
	HLLZ B,TTRACK+1
	MOVE D,TTRACK+3
	MOVEI W,SKFILE
RCOVI2:	CAMN A,(W)
	CAME D,3(W)
	JRST RCOVI1
	HLLZ C,1(W)
	CAME B,C
	JRST RCOVI1
	JRST CPOPJ1
RCOVI1:	ADDI W,4
	CAIG W,(S)
	JRST RCOVI2
	MOVSI W,-NSKUFD
RCOVI3:	CAMN D,SKUFD(W)
	JRST RCOVI4
	ADDI W,1
	AOBJN W,RCOVI3
	POPJ P,

RCOVI4:	MOVEI W,UFDBAK
	MOVE C,TTRACK+DDLOC
RCOVI5:	CAMN C,2(W)
	POPJ P,			;GOT IT IN THE LIST ALREADY
	ADDI W,4
	CAIG W,(Y)
	JRST RCOVI5
	PUSH Y,TTRACK
	PUSH Y,TTRACK+1
	PUSH Y,[0]
	PUSH Y,TTRACK+3
	MOVEI W,-3(Y)
	JRST CPOPJ1

RDGONE:	SETZB A,B
	MOVE X,[POINT 6,A]
RDGON0:	ILDB R,W
	CAIN R,"⊗"
	POPJ P,
	CAIE R,"."
	CAIN R,"["
	JRST RDGON1
	SUBI R,40
	IDPB R,X
	JRST RDGON0
RDGON1:	CAIE R,"."
	JRST RDGON3
	MOVE X,[POINT 6,B]
RDGON2:	ILDB R,W
	CAIN R,"["
	JRST RDGON3
	SUBI R,40
	IDPB R,X
	JRST RDGON2
RDGON3:	PUSHJ P,RDGONP
	MOVE C,D
	PUSHJ P,RDGONP
	HRL D,C
	MOVEI C,0
	ILDB R,W
	CAIE R,15
	JRST 4,.
	ILDB R,W
	CAIE R,12
	JRST 4,.
	AOS (P)
	POPJ P,

RDGONP:	MOVEI D,0
RDGNP1:	ILDB R,W
	CAIE R,","
	CAIN R,"]"
	POPJ P,
	LSH D,6
	SUBI R,40
	IORI D,(R)
	JRST RDGNP1

SKUFD:	SIXBIT /220 PW/	↔	0
	SIXBIT /PICPMF/	↔	0
	SIXBIT /TMPGHB/	↔	0
	SIXBIT /  1 BH/	↔	0
	SIXBIT /IBMTED/	↔	0
	SIXBIT /THEMJC/	↔	0
	SIXBIT /  1 AH/	↔	0
	SIXBIT /EX2LCS/	↔	0
	SIXBIT /PUBDRB/	↔	0
	SIXBIT /CONDCL/	↔	0
	SIXBIT /206PAM/	↔	0
	SIXBIT /PCNREM/	↔	0
	SIXBIT /  2SMG/	↔	0
	SIXBIT /  1SSO/	↔	0
NSKUFD←←<.-SKUFD>/2

GONE:	BLOCK 2*=1024
SKFILE:	BLOCK 4*=400
UFDBAK:	BLOCK =10000
SKEND←←.

>;repeat 0
;GPC - GENERAL PACK COPY.

;repeat 0,<

SRCDRV:	0		;SOURCE DRIVE
DSTDRV:	0		;DESTINATION DRIVE
SRCBAS:	0		;FIRST TRACK ON SOURCE DRIVE
DSTBAS:	0		;FIRST TRACK ON DEST DRIVE
GCBUFP:	0		;POINTER TO VERIFY BUFFER
RDBACK:	0		;NON ZERO FOR READBACK
RDVERF:	0		;NON ZERO IF VERIFY (RDBACK SHOULD BE NON ZERO TOO)

GPC:	PUTSTR	[ASCIZ/General pack copy.  Source Drive Number = /]
	PUSHJ	P,DECIN
	MOVEM	B,SRCDRV
GPC1:	PUTSTR	[ASCIZ/Destination Drive Number = /]
	PUSHJ	P,DECIN
	JUMPE	B,GPCER1		;CAN'T USE 0 AS DESTINATION
	MOVEM	B,DSTDRV
	PUTSTR	[ASCIZ/Mount Source Pack on Drive /]
	MOVE	W,SRCDRV
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ Write locked.
Mount Destination Pack on Drive /]
	MOVE	W,DSTDRV
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ Write enabled.  Write lock everything else.
Type Y to continue: /]
	PUSHJ	P,YORN
	JRST	GPC			;START OVER
	PUTSTR	[ASCIZ/Type Y for readback (without verify): /]
	PUSHJ	P,YORN
	TDZA	A,A
	MOVEI	A,1
	MOVEM	A,RDBACK		;FLAG (OR NOT) READBACK
	PUTSTR	[ASCIZ/Type Y for readback and verify: /]
	PUSHJ	P,YORN
	TDZA	A,A
	MOVEI	A,1
	MOVEM	A,RDVERF
	JUMPE	A,GPC2			;JUMP IF NO VERIFY
	MOVEM	A,RDBACK
	MOVE	B,JOBFF			;GET FIRST FREE LOCATION
	HRRZM	B,GCBUFP		;POINTER TO VERIFY BUFFER
	ADDI	B,WDTRK			;ADD SIZE OF VERIFY BUFFER.
	CORE	B,
	JRST	GPCER2			;OOPS.
GPC2:	PUTSTR	[ASCIZ/Here we go!
/]
	MOVE	A,SRCDRV
	IMULI	A,NTPP
	HRLI	A,R			;INSTALL R IN INDEX FIELD
	MOVEM	A,SRCBAS
	MOVE	A,DSTDRV
	IMULI	A,NTPP
	HRLI	A,R			;INSTALL R IN INDEX FIELD
	MOVEM	A,DSTBAS		;FISRT DESTINATION TRACK.
	MOVSI	R,-NTPP			;# OF TRACKS/PACK
GPCL:	TREAD	@SRCBAS			;(INDEX OF R)
	TWRITE	@DSTBAS
	SKIPN	RDBACK			;READBACK?
	JRST	GPCLX			;NO.
	SKIPE	RDVERF			;VERIFY TOO?
	JRST	GPCL1			;YES. UGH!
	TREAD	@DSTBAS			;READBACK AND NO VERIFY
	JRST	GPCLX			;DONE WITH TRACK.

GPCL1:	MOVSI	B,TTRACK		;SOURCE
	HRR	B,GCBUFP		;DESTINATION
	MOVEI	C,WDTRK(B)		;ONE BEYOND LAST DESTINATION
	BLT	B,-1(C)			;COPY OF WHAT WE WROTE
	MOVE	B,[TTRACK,,TTRACK+1]
	SETZM	TTRACK
	BLT	B,TTRACK+WDTRK-1	;CLEAR TRACK BUFFER
	TREAD	@DSTBAS			;READBACK WHAT WE WROTE
	MOVSI	W,-WDTRK		;
	HRRZ	B,GCBUFP		;POINTER TO ORIGINAL
GPCL2:	MOVE	A,TTRACK(W)
	CAME	A,(B)
	JRST	GPCER4
	ADDI	B,1
	AOBJN	W,GPCL2
GPCLX:	AOBJN	R,GPCL
	PUTSTR	[ASCIZ/Copy complete
/]
	JRST	DDTCAL

GPCER1:	PUTSTR	[ASCIZ/Drive 0 can't be used as destination.
/]
	JRST	GPC1

GPCER2:	PUTSTR	[ASCIZ/Insufficient core
/]
	JRST	DDTCAL

GPCER4:	PUTSTR	[ASCIZ/Verify error.  Type CONTINUE to procede.
/]
	HALT	GPCLX

DECINX:	PUTSTR	[ASCIZ/Error in number. Try again: /]
	CLRBFI
DECIN:	MOVEI	B,0
DECIN0:	INCHWL A
	CAIN	A,15
	JRST	DECIN0	;FLUSH CR
	CAIN	A,12
	POPJ	P,
	CAIL	A,"0"
	CAILE	A,"9"
	JRST	DECINX
	IMULI	B,12
	ADDI	B,-"0"(A)
	JRST	DECIN0

>;end repeat 0
	SUBTTL	UFDFIX	- EXTEND THE MFD AND ALL UFDS FOR 16 WORDS/ENTRY.

repeat 0,<

COMMENT ⊗ THE FOLLOWING IS TO BE USED ONLY ONCE.  CALL VIA PUSHJ P,UFDFIX
NOTE:  NEEDS SOME PATCHES IN SYSTEM TO MAKE IT WORK RIGHT.
⊗

BEGIN UFDFIX

GLOBAL A,B,C,D,Y,DSK,P

↑UFDFIX:SETSTS	DSK,617			;SET DUMPER MODE - DON'T UPDATE DATES
	MOVE	A,['  1  1']
	MOVSI	B,'UFD'
	MOVE	D,A
	LOOKUP	DSK,A
	HALT	.
	MOVE	Y,D
	MOVE	D,A
	ENTER	DSK,A
	HALT	.
	MOVE	A,JOBFF
	MOVEM	A,SAVFF
	PUSHJ	P,UFIX			;FIX THE MFD
	MOVE	A,XFF			;GET THE POINTER TO CORE PAST OLD MFD
	MOVEM	A,SAVFF			;DON'T OVERWRITE MFD IN CORE.
	MOVE	B,ALLPTR		;THIS IS THE POINTER TO THE MFD
MLOOP:	MOVEM	B,MFDPTR#
	SKIPN	A,(B)			;GET A UFD NAME
	JRST	MLOOPX			;NONE IN THIS SLOT.
	MOVSI	B,'UFD'
	MOVE	D,['  1  1']
	LOOKUP	DSK,A
	HALT	.
	MOVE	Y,D
	MOVE	D,['  1  1']
	ENTER	DSK,A
	HALT	.
	PUSHJ	P,UFIX
	MOVE	B,MFDPTR
MLOOPX:	ADD	B,[4,,4]
	JUMPL	B,MLOOP
	POPJ	P,

UFIX:	JUMPE	Y,LOOPY			;NO WORK IF WC=0
	HRR	Y,SAVFF			;Y HAS THE SWAPPED NEGATIVE WORD COUNT.
	MOVEM	Y,ALLPTR#		;SAVE -WC,,ADDRESS OF BUFFER.
	SUBI	Y,1			;NOW Y HAS -WC,,ADDRESS-1 OF BUFFER
	HLRO	C,Y			;C ← -WC
	HRRZ	B,SAVFF			;START OF BUFFER
	SUB	B,C			;BUFFER - -WC = END OF BUFFER+1
	MOVEM	B,XFF#			;SAVE UPDATED BUFFER ADDRESS
	CORE	B,			;REQUEST SUFFICIENT CORE FOR THIS FILE.
	HALT	.
	MOVE	A,Y			;A←IOWD TO FILE.
	SETZ	B,			;B←0
	INPUT	DSK,A			;READ FILE INTO CORE.
	STATZ	DSK,740000		;TEST FOR ERRORS
	HALT	.
	USETO	DSK,1			;REWRITE STARTING AT RECORD 1
	LSH	C,2			;MULTIPLY -WC BY 4
	MOVE	B,XFF			;GET FIRST FREE ADDRESS
	SUB	B,C			;ENDING ADDRESS
	CORE	B,
	HALT
	MOVE	A,ALLPTR		;-WC,,ADDRESS OF SOURCE.
	MOVE	B,XFF			;ADDRESS OF DESTINATION
LOOP:	SKIPN	(A)			;IS THERE A FILE NAME HERE?
	JRST	LOOPX			;NO.  SKIP THIS ONE.
	MOVSI	C,(A)			;SOURCE
	HRRI	C,(B)			;DESTINATION.
	BLT	C,3(B)			;COPY 4 WORDS.
	SETZM	4(B)			;CLEAR FIFTH WORD
	MOVSI	C,4(B)			;SOURCE
	HRRI	C,5(B)			;DESTINATION
	BLT	C,17(B)			;CLEAR NEXT 11 (DECIMAL) WORDS.
	ADDI	B,20			;ADVANCE DESTINATION POINTER
LOOPX:	ADD	A,[4,,4]		;ADVANCE SOURCE POINTR
	JUMPL	A,LOOP
	SUB	B,XFF			;2←WORD COUNT OF NEW FILE.
	JUMPE	B,LOOPY			;IF NEW WC IS ZERO, UFD IS EMPTY.
	HLRO	A,ALLPTR		;-WC OF OLD UFD
	MOVN	A,A
	CAML	B,A			;SKIP IF NEW WC IS SHORTER THAN OLD ONE.
	JRST	LOOPZ			;MAKING IT BIGGER IS EASY
	ADD	A,XFF			;CALCULATE ENDING ADDRESS.
	MOVE	D,A			;SAVE IT.
	CORE	A,			;MAKE SURE THERE'S ENOUGH ROOM
	HALT
	MOVE	C,B
	ADD	C,XFF			;FIRST ADDRESS TO ZERO.
	SETZM	(C)
	HRLI	C,1(C)
	MOVS	C,C
	BLT	C,-1(D)
	HLRO	B,ALLPTR
	MOVN	B,B			;SORRY.
LOOPZ:	MOVN	A,B
	HRLZ	A,A
	HRR	A,XFF
	SUBI	A,1
	MOVEI	B,0
	OUTPUT	DSK,A
	STATZ	DSK,740000
	HALT	.
LOOPY:	CLOSE	DSK,
	POPJ	P,

BEND UFDFIX

>;end repeat 0


repeat 1,<

COMMENT ⊗ THE FOLLOWING IS TO BE USED ONLY ONCE.  CALL VIA PUSHJ P,UFDFIX
NOTE:  NEEDS SOME PATCHES IN SYSTEM TO MAKE IT WORK RIGHT.
⊗

BEGIN UFDFIX

GLOBAL A,B,C,D,Y,DSK,P

UFDFIX:	MOVE	A,['  1  1']	;GET NAME OF MFD
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV+3	;SAVE AS EXPECTED RETRIEVAL
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	MOVEI	R,1		;READ FILE FROM BLOCK 1
	PUSHJ	P,FREAD		;READ FILE
	MOVE	W,FSIZE
	MOVE	Z,DIOWD		;GET THE IOWD OF FILE
	MOVEM	Z,MFDPTR	;SAVE AS MFD POINTER
	PUTSTR	[ASCIZ/MFD READ.  /]
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ TRACKS.
/]
	AOJGE	Z,EMMFD		;JUMP IF EMPTY MFD!
	MOVE	A,JOBFF		;GET JOBFF
	MOVEM	A,SAVFF		;SAVE IT
PH1.1:	SKIPN	A,(Z)		;GET THE NAME OF A USER
	JRST	PH1.4		;EMPTY ENTRY
	MOVEM	A,PPUFD		;SAVE THE PPN OF THIS UFD
	MOVEM	A,RTSAV		;SAVE NAME OF UFD 
	MOVE	A,['  1  1']	;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+3	;SAVE
	HLLZ	B,1(Z)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1	;SAVE IT
	CAME	B,['UFD   ']	;MUST BE SIXBIT UFD
	JRST	PH1.5		;MENTION GARBAGED NAME.  RTSAV,RTSAV+1 SETUP
	HRRZ	R,3(Z)		;GET THE TRACK ADDRESS
	MOVE	A,SAVFF
	MOVEM	A,JOBFF
	PUSHJ	P,FREAD
	MOVE W,[RTSAV+DDRET,,PTRSAV]
	BLT W,PTRSAV+<TRKGRP/2>-1 ;SAVE POINTERS TO UFD
	MOVE	W,PPUFD		;GET NAME
	PUSHJ	P,TYPPN
	PUTSTR	[ASCIZ/ /]
	MOVE	W,FSIZE		;GET FILE SIZE
	PUSHJ	P,DECOUT	;ARG STILL IN W, I HOPE
	PUTSTR	CRLF
PH1.1A:	MOVE	Y,DIOWD		;GET THE IOWD OF THE FILE
	AOJGE	Y,EMUFD		;TELL ABOUT THIS EMPTY UFD
PH1.2:	SKIPN	A,0(Y)		;GET A FILE NAME
	JRST	PH1.3		;EMPTY NAME
	MOVEM	A,RTSAV		;SAVE RETRIEVAL
	HLLZ	B,1(Y)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1
	MOVE	C,PPUFD
	MOVEM	C,RTSAV+3
	HRRZ	R,3(Y)		;GET THE TRACK ADDRESS
	RREAD (R)		;READ THE RETRIEVAL
;Y POINTS TO THE UFD ENTRY FOR THIS FILE.  FIX IT.
	MOVE A,TTRACK+5
	MOVEM A,4(Y)		;STORE FILE LENGTH
	LDB A,[POINT 3,1(Y),20]	;HI 3 BITS OF DATE WRITTEN
	LDB B,[POINT 12,2(Y),35]	;LO 12 BITS OF DATE WRITTEN
	DPB A,[POINT 3,B,23]	;DATE WRITTEN (15 BITS)
	LDB A,[POINT 11,2(Y),23]	;TIME WRITTEN IN MINUTES AFTER MIDNIGHT
	IMULI A,=60*=15		;15THS OF A SECOND AFTER MIDNIGHT
	DPB B,[POINT 15,A,14]	;VOILA
	MOVEM A,5(Y)		;STORE EXTENDED TIME WRITTEN
	MOVEI A,5(Y)
	PUSH A,TTRACK+6		;DREFTIM
	PUSH A,TTRACK+7		;DDMPTIM
	PUSH A,[0]		;UNUSED (DGRP1R)
	PUSH A,[0]		;UNUSED (DNXTGP)
	PUSH A,TTRACK+12	;DSATID
	PUSH A,TTRACK+13	;DQINFO
	PUSH A,TTRACK+14	;DQINFO+1
	PUSH A,TTRACK+15	;DQINFO+2
	PUSH A,TTRACK+16	;DQINFO+3
	PUSH A,TTRACK+17	;DOFFST
PH1.3:	ADD	Y,[XWD UFDN,UFDN]
	JUMPL	Y,PH1.2		;LOOP
	PUSHJ P,REWUFD		;REWRITE THE UFD
PH1.4:	ADD	Z,[XWD UFDN,UFDN]
	JUMPL	Z,PH1.1		;LOOP
	PUTSTR	[ASCIZ /DONE.
/]
	POPJ	P,

EMMFD:	PUTSTR	[ASCIZ/
THE MFD IS EMPTY!
/]
	POPJ	P,

EMUFD:	PUTSTR	[ASCIZ/EMPTY UFD. /]
	PUSHJ	P,TYFIL		;TYPE THE NAME OF THE FILE
	PUTSTR	CRLF
	JRST	PH1.4

PH1.5:	PUTSTR	[ASCIZ/A FILE, NOT A UFD, FOUND IN [1,1].
/]
	PUSH	P,Z
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
	POP	P,Z
	HALT	PH1.4		;GET ANOTHER ENTRY FROM MFD

;HERE TO WRITE UFD BACK OUT.  RETRIEVAL POINTERS ARE IN PTRSAV, IOWD TO UFD
;IN CORE IS IN DIOWD.
REWUFD:	MOVE Y,DIOWD
	ADDI Y,1
	MOVE A,[POINT 18,PTRSAV]	;BYTE POINTER TO RETRIEVAL POINTERS
REWUF2:	ILDB R,A
	JUMPE R,REWUF1
	TREAD (R)
	MOVE B,TTRACK
	CAME B,(Z)
	JRST 4,.
	MOVE B,TTRACK+WDRTVL
	CAME B,(Y)
	JRST 4,.
	MOVSI B,(Y)
	HRRI B,TTRACK+WDRTVL
	HLRE C,Y
	MOVN C,C			;THIS IS HOW MUCH UFD IS LEFT
	CAILE C,200*NBPT
	MOVEI C,200*NBPT
	HRL C,C
	ADD Y,C
	BLT B,TTRACK+WDRTVL-1(C)
CLOB:	TWRITE (R)
	JUMPL Y,REWUF2
	ILDB R,A
	SKIPE R
	JRST 4,.
	POPJ P,

REWUF1:	JRST 4,.

PTRSAV:	BLOCK TRKGRP/2

BEND UFDFIX

>;end repeat 1
	SUBTTL	REFIX

BEGIN REFIX
GLOBAL A,B,C,D,R,W,X,Y,Z,DSK,P
INTEGER NEWSIZ,NEWFIL

↑REFIX:	MOVE	A,['  1  1']	;GET NAME OF MFD
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV+3	;SAVE AS EXPECTED RETRIEVAL
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	MOVEI	R,1		;READ FILE FROM BLOCK 1
	MOVEM	R,NEWFIL	;DDLOC OF CURRENT FILE
	PUSHJ	P,FREAD		;READ FILE
	MOVE	W,FSIZE
	MOVEM	W,TOTSIZ	;SAVE TOTAL SIZE
	MOVE	Z,DIOWD		;GET THE IOWD OF FILE
	MOVEM	Z,MFDPTR	;SAVE AS MFD POINTER
	AOJGE	Z,EMMFD		;JUMP IF EMPTY MFD!
	PUSHJ	P,FILFIX	;FIX THE FILE
	MOVE	A,JOBFF		;GET JOBFF
	MOVEM	A,SAVFF		;SAVE IT
PH1.1:	SKIPN	A,(Z)		;GET THE NAME OF A USER
	JRST	PH1.4		;EMPTY ENTRY
	MOVEM	A,PPUFD		;SAVE THE PPN OF THIS UFD
	MOVEM	A,RTSAV		;SAVE NAME OF UFD 
	MOVE	A,['  1  1']	;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+3	;SAVE
	HLLZ	B,1(Z)		;GET THE EXTENSION
	MOVEM	B,RTSAV+1	;SAVE IT
	CAME	B,['UFD   ']	;MUST BE SIXBIT UFD
	JRST	PH1.5		;MENTION GARBAGED NAME.  RTSAV,RTSAV+1 SETUP
	HRRZ	R,3(Z)		;GET THE TRACK ADDRESS
	MOVEM	R,NEWFIL
	MOVE	A,SAVFF
	MOVEM	A,JOBFF
	PUSHJ	P,FREAD
	PUSHJ	P,FILFIX
PH1.4:	ADD	Z,[XWD 4,4]
	JUMPL	Z,PH1.1		;LOOP
	PUTSTR	[ASCIZ/DONE
/]
	POPJ	P,

EMMFD:	PUTSTR	[ASCIZ/
THE MFD IS EMPTY!
/]
	POPJ	P,

PH1.5:	PUTSTR	[ASCIZ/A FILE, NOT A UFD, FOUND IN [1,1].
/]
	PUSH	P,Z
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
	POP	P,Z
	HALT	PH1.4		;GET ANOTHER ENTRY FROM MFD

FILFIX:	HLRO	W,DIOWD
	MOVN	W,W
	TRNN	W,17		;IS SIZE OK?
	POPJ	P,
	ADDI	W,20
	TRZ	W,17
	MOVEM	W,NEWSIZ	;SAVE NEW RETRIEVAL SIZE
	MOVE	W,RTSAV
	PUSHJ	P,TYPPN
	PUTSTR	[ASCIZ/ /]
;SPREAD NEW RETRIEVAL.
	MOVE	R,NEWFIL
SPR1:	RREAD	(R)		;READ FIRST TRACK OF GROUP
	MOVE	W,NEWSIZ
	MOVEM	W,TTRACK+DDLNG
	MOVSI	W,-<TRKGRP/2>	;32 TRACKS/GROUP  2 PER WORD IN RTVL
SPR2:	HLRZ	X,TTRACK+DDRET(W)
	JUMPE	X,CPOPJ
	RWRITE	(X)
	HRRZ	X,TTRACK+DDRET(W)
	JUMPE	X,CPOPJ
	RWRITE	(X)
	AOBJN	W,SPR2
	SKIPE	R,TTRACK+DNXTGP	;GET THE NEXT GROUP #
	JRST	SPR1
	POPJ	P,
	
BEND REFIX
	SUBTTL REBLD2 -- PHASE 2 OF REBUILD

COMMENT ⊗
When we start up here, REBBUF should contain a list of PPNs to be rebuilt,
ending with a 0 word.  We create a file <ppn>.UFD[ERR,BH] for each ppn in
the list, based on scanning the entire disk.
⊗

REBLD2:	MOVSI W,-REBCN		;MAX NUMBER OF UFDS TO REMAKE AT ONCE
	MOVEI X,REBCBF		;POINTER TO BUFFER BLOCK
	MOVEI Y,REBCHD		;POINTER TO BUFFER HEADER BLOCK
REB2LP:	SKIPN REBBUF(W)		;SKIP IF THERE IS ANOTHER PPN TO REBUILD
	JRST REB2BG		;NO, BEGIN SCAN
	MOVEI A,10		;CREATE OPEN BLOCK
	MOVSI B,'DSK'
	MOVSI C,(Y)		;OUTPUT BUFFER HEADER
	MOVSI K,REBC(W)		;CHANNEL NUMBER
	LSH K,5			; IN AC FIELD
	MOVE L,K
	OR L,[OPEN A]
	XCT L
	 HALT .			;OPEN FAILED
	MOVE A,REBBUF(W)	;GET UFD NAME
	MOVSI B,'UFD'
	MOVEI C,0
	MOVE D,['ERR BH']
	MOVE L,K
	OR L,[ENTER A]
	XCT L
	 HALT .			;ENTER FAILED
	PUSH P,JOBFF
	HRRZM X,JOBFF
	MOVE L,K
	OR L,[OUTBUF 2]
	XCT L			;CREATE BUFFERS (2 OF THEM)
	POP P,JOBFF
	ADDI X,2*203
	ADDI Y,3
	AOBJN W,REB2LP
REB2BG:	MOVSI	R,-TRACKS
	ADD	R,[1,,1]		;SKIP TRACK 0
	MOVNI W,(W)			;- NUMBER OF UFDS, FOR AOBJN
REB2B1:	RREAD	(R)			;READ RETRIEVAL
	MOVSI	S,(W)			;NUMBER OF UFDS WE'RE SEEKING
	MOVE	D,TTRACK+3
REB2B2:	CAMN D,REBBUF(S)	;RIGHT PPN?
	SKIPN TTRACK+DSATID	; AND NOT DELETED?
	JRST REB2B3		;NO, DON'T COUNT IT

	MOVE Z,TTRACK+DDLOC	;GET FIRST TRACK OF FILE
	CAIN Z,(R)		;IS IT THIS TRACK?
	JRST REB22A		;YES, NO NEED TO READ ANOTHER
;;	RREAD (Z)		;NO, READ FIRST TRACK
;;	MOVE D,TTRACK+3		;GET NEW PPN
;;	MOVE C,TTRACK+DDLOC
;;	CAIN C,(Z)		;DOES THIS TRACK THINK IT'S FIRST?
;;	CAME D,REBBUF(S)	;AND IS PPN RIGHT?
	JRST REB2B3		;NO, FORGET IT
REB22A:	MOVSI K,REBC(S)		;GET PROPER IO CHANNEL FOR THIS UFD
	LSH K,5
	OR K,[OUT]
	MOVEI L,(S)
	IMULI L,3
	ADDI L,REBCHD		;BUFFER HEADER ADDR
	MOVE A,TTRACK		;FILNAM 0
	PUSHJ P,REBOUT
	MOVE A,TTRACK+1		;EXT 1
	PUSHJ P,REBOUT
	MOVE A,TTRACK+2		;DATES 2
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DDLOC	;DSK ADDR 3
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DDLNG	;LENGTH 4
	PUSHJ P,REBOUT
	LDB A,[POINT 11,TTRACK+2,23]	;SUPER WHOOPIE DATE 5
	IMULI A,=15*=60		;TIME FROM MINUTES INTO 15THS OF SECS
	LDB B,[POINT 12,TTRACK+2,35]	;LOW ORDER DATE75
	DPB B,[POINT 12,A,14]
	LDB B,[POINT 3,TTRACK+1,20]	;HIGH ORDER DATE75
	DPB B,[POINT 3,A,2]
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DREFTM	;REF DATE 6
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DDMPTM	;DART POOP 7
	PUSHJ P,REBOUT
	MOVEI A,0		;UNUSED 10 11
	PUSHJ P,REBOUT
	PUSHJ P,REBOUT
	MOVE A,SATID		;SATID 12
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DQINFO	;MAGIC STUFF 13-16
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DQINFO+1
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DQINFO+2
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DQINFO+3
	PUSHJ P,REBOUT
	MOVE A,TTRACK+DOFFST	;OFFSET 17
	PUSHJ P,REBOUT
REB2B3:	AOBJN S,REB2B2		;LOOP THROUGH DESIRED PPNS
	AOBJN	R,REB2B1		;LOOP THRU DISK
	MOVSI S,(W)		;AOBJN PTR TO CHANNELS
	MOVE L,[CLOSE REBC,]
	XCT L
	ADD L,[1,]
	AOBJN S,.-2
	JRST	DDTCALL

REBOUT:	SOSG 2(L)
	XCT K
	 JRST .+2
	HALT .
	IDPB A,1(L)
	POPJ P,
SUBTTL SPREAD	SPREAD RETRIEVAL

SPREAD:	MOVE A,TTRACK+DGRP1R
	MOVE B,TTRACK+DNXTGP
	CAIN A,1
	CAIE B,0
	JRST NOSPRD
	HLLZ X,TTRACK+1			;SAVE EXT FOR LATER CHECKS
	MOVE A,[TTRACK,,SPRTVL]
	BLT A,SPRTVL+WDRTVL-1		;COPY THE RETRIEVAL
	MOVEI W,SPRTVL+DDRET
	HRLI W,DDRET-WDRTVL		;AOBJN PTR TO TRACK ADDRS
SPREA1:	HLRZ R,(W)
	JUMPE R,SPREA9
	PUSHJ P,SPREA8			;DO THIS TRACK
	HRRZ R,(W)
	JUMPE R,SPREA9
	PUSHJ P,SPREA8
	AOBJN W,SPREA1
SPREOK:	PUTSTR [ASCIZ /OK.
/]
	JRST DDTCALL

SPREA8:	RREAD (R)
	MOVE A,TTRACK
	HLLZ B,TTRACK+1
	MOVE D,TTRACK+3
	CAMN A,SPRTVL
	CAME D,SPRTVL+3
	JRST SPREA7
	CAME B,X
	JRST SPREA7
	MOVE A,[SPRTVL,,TTRACK]
	BLT A,TTRACK+WDRTVL-1
	RWRITE (R)
	POPJ P,

SPREA7:	PUTSTR [ASCIZ /Track in R doesn't belong to this file!  You lose.
Tracks before this one have been modified, you better fix this.
/]
	RPRINT
	JRST DDTCALL

SPREA9:	AOBJP W,SPREOK
	SKIPN (W)
	AOBJN W,.-1
	JUMPGE W,SPREOK
	PUTSTR [ASCIZ /Zero track number in middle of retrieval pointers.
Ones before it have been modified, you better fix this.
/]
	JRST DDTCALL

NOSPRD:	PUTSTR [ASCIZ /File is more than one group, you lose.
/]
	JRST DDTCALL

SPRTVL:	BLOCK WDRTVL
;BYTE1 BYTEN BYTER8 BYTERL BYTEL8 BYTELL

BYTE1:	0
BYTEN:	0

;shift right by 8 bits.
BYTER8:	PUTSTR [ASCIZ /Routine to shift data RIGHT by 8 bits.

Put first bad addr in BYTE1, last in BYTEN
Then type $P.  (First fixed is C(BYTE1)+1.)
/]
	PUSHJ P,DDTCALL
	MOVE A,BYTE1		;FIRST WORD TO LOOK AT
	DMOVE B,(A)		;GET FIRST DOUBLE WORD
BYTERL:	MOVE D,C		;SAVE 2ND FOR NEXT TIME
	LSHC B,-8		;REPOSITION
	MOVEM C,1(A)		;FIX 2ND WORD
	ADDI A,1
	MOVE B,D
	MOVE C,1(A)
	CAMGE A,BYTEN		;DONE?
	JRST BYTERL
	PUTSTR [ASCIZ /OK, fixed in core, check it and TWRITE it.
/]
	JRST DDTCALL

;shift left by 8 bits
BYTEL8:	PUTSTR [ASCIZ /Routine to shift data LEFT by 8 bits.

Put first bad addr in BYTE1, last in BYTEN
Then type $P.  (First fixed is C(BYTE1)+1.)
/]
	PUSHJ P,DDTCALL
	MOVE A,BYTE1		;FIRST WORD TO LOOK AT
	ADDI A,1		;DON'T TOUCH FIRST WORD
BYTELL:	MOVE B,(A)
	MOVE C,1(A)
	LSHC B,8		;REPOSITION
	MOVEM B,(A)		;FIX 1st WORD
	ADDI A,1
	CAMGE A,BYTEN		;DONE?
	JRST BYTELL
	PUTSTR [ASCIZ /OK, fixed in core, check it and TWRITE it.
/]
	JRST DDTCALL
	SUBTTL SCOUT	LOOK AROUND A PARTICULAR AREA FOR A FILE

SCOUT:	PUTSTR [ASCIZ /Put filename and extension in SCOUTF and SCOUTE,
and approximate track in SCOUTK.  (We start looking in C(SCOUTK)-6000.)
Then type $P.
/]
	PUSHJ P,DDTCALL
	MOVE R,SCOUTK
	SUB R,SCOUTO		;SUBTRACT STARTING OFFSET
	HRL R,SCOUTR		;GET -RANGE TO MAKE AOBJN
	HLLZS SCOUTE		;DON'T KEEP ANY JUNK IN EXT WORD
SCOUT1:	RREAD (R)		;GET RETRIEVAL
	MOVE A,TTRACK
	HLLZ B,TTRACK+1
	CAMN A,SCOUTF		;RIGHT FILE?
	CAME B,SCOUTE
SCOUT2:	AOBJN R,SCOUT1		;NO
	JUMPGE R,SCOUT9		;FAILED
	TREAD (R)		;WIN, READ IN ENTIRE TRACK
	RPRINT			;TELL USER
	PUTSTR [ASCIZ /If you don't like this one, type $P to continue.
/]
	PUSHJ P,DDTCALL
	JRST SCOUT2

SCOUT9:	PUTSTR [ASCIZ /Not found.  Try again with another SCOUTK, or
modify SCOUTO (starting offset) or SCOUTR (negative range), or use H.
/]
	JRST DDTCALL

SCOUTO:	=6000
SCOUTR:	-=12000
SCOUTF:	0
SCOUTE:	0
SCOUTK:	0
;F2OPEN F2LOGI F2NOTA F2TEST F2TSTL

F2OPEN:	PUTSTR [ASCIZ /OPEN failed on UDP1!

/]
	JRST F2TEST	;Let him try again

F2LOGI:	PUTSTR [ASCIZ /Don't use UDP1 as LOGICAL name of another device!
/]
F2NOTA:	PUTSTR [ASCIZ /UDP1 not assigned as OLD!

/]
F2TEST:	PUTSTR	[ASCIZ /Speed test using fast pack read from UDP1.  Reads whole pack, or
change number of tracks to read at F2TSTL-1.

Begin with ASSIGN OLD UDP1.

Then type CONTINUE./]
	EXIT 1,
	MOVE A,['UDP1  ']
	PNAME A,
	 JRST F2NOTA		;No such device
	CAME A,['UDP1  ']
	JRST F2LOGI		;UDP1 is a logical name of some other device!
	DEVUSE A,
	HLRZ A,A		;Ignore people waiting for UDP
	PJOB R,
	CAIE A,442000(R)	;Must be Assigned Private or Old by me, not INITed
	JRST F2NOTA
	OPEN OLDI,[	217	;Open UDP1 on input channel
			'UDP1  '
			0]
	 JRST F2OPEN
	MOVEI A,OLDI
	DEVCHR A,
	HLRZ A,A
	CAIE A,101047	;Should be UDP, not new mode, long-dispatch, avail, I/O, dir
	JRST F2NOTA	;Well, that's strange, could that number be wrong?
	PUTSTR [ASCIZ/
WRITE LOCK the pack and use ID plug # /]
	MOVEI	W,NPACK		;COUNTS FROM ZERO
	PUSHJ	P,OCTOUT
	PUTSTR [ASCIZ/
Then type CONTINUE./]
	EXIT	1,
	PUSH	P,UDPOK
	SETOM	UDPOK			;SET THIS FLAG FOR OPERATION ON UDP
	PUSH P,UDPONL
	SETOM UDPONL			;ONLY ALLOW OPERATION ON UDP
	MOVSI R,-NCYL			;-COUNT OF CYLINDERS PER PACK
F2TSTL:	MOVEI C,(R)		;Cylinder
	IMULI C,NTPC		;Convert cylinder number to track number
	MOVEM C,OLDCYL+1	;Store disk address for read and write
	IN OLDI,OLDCYL		;Read a cylinder
	 CAIA			;OK
	JSR DISERR		;THERE'S SOME SORT OF ERROR
	AOBJN R,F2TSTL
	RELEAS OLDI,
	PUTSTR [ASCIZ/DONE
/]
	POP P,UDPONL
	POP P,UDPOK			;RESTORE STATE
	JRST DDTCALL
;DEADP recons RECON1 REC.1 REC.2 REC.3 REC.4 EMUFD REC.5 RCBITC RBTCT1
	SUBTTL	reconstruct disk

DEADP==1			;the pack number of the dead pack.
				;probably this code won't work if pack zero.

RECONS:	OUTSTR	[ASCIZ/We're trying to reconstruct a file system that
has one smashed disk.

Mount a replacement pack that is already formatted on drive number /]
	MOVEI	W,DEADP
	PUSHJ	P,OCTOUT
	OUTSTR	[ASCIZ/
This pack will be written on; write enable it.

Write lock everything else!

You really ought to know what you're doing.
/]
	EXIT	1,
	OUTSTR	[ASCIZ/

Restart at RECON0 if you've already cleared the replacement pack.
If you've fixed data on the new pack, you must NOT continue now.

Type CONTINUE to zero the replacement disk.
/]
	EXIT	1,
	OUTSTR	[ASCIZ/Zeroing the replacement disk.  Wait 10 minutes...
/]
	MOVE	A,[TTRACK,,TTRACK+1]
	SETZM	TTRACK
	BLT	A,TTRACK+WDTRK-1
	MOVSI	R,-NTPP		;for all tracks on subject pack
RECON1:	TWRITE	NTPP*DEADP(R)	;write lots of zeros everywhere on dead pack
	AOBJN	R,RECON1

RECON0:	OUTSTR	[ASCIZ/Read the MFD....
/]
	SETZM	SATTAB		;ZERO OUR COPY OF SAT TABLE
	MOVE	A,[XWD SATTAB,SATTAB+1]
	BLT	A,SATEND
	SETOM	PHI1		;SET TO MAKE MARKS IN SAT
	SKIPE R,SATTK2		;GET TRACK NUMBER OF SECOND SAT TRACK
	PUSHJ P,MBYTE		;MARK SECOND SAT TRACK AS TAKEN
	MOVE	A,['  1  1']	;GET NAME OF MFD
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV +3	;SAVE AS EXPECTED RETRIEVAL
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	MOVE	A,SATID
	MOVEM	A,RTSAV+DSATID
	SETZM	RTSAV+DNXTGP
	MOVEI	R,1		;READ FILE FROM BLOCK 1
	MOVEM	R,RTSAV+DGRP1R
	HRLZM	R,RTSAV+DDRET	;first MFD block
	SETZM	RTSAV+DDRET+1
	MOVE	A,[RTSAV+DDRET+1,,RTSAV+DDRET+2]
	BLT	A,RTSAV+WDRTVL-1

	PUSHJ	P,RFRED		;Read MFD; Reconstruct MFD rtvl
	MOVE	W,FSIZE
	MOVEM	W,TOTSIZ	;SAVE TOTAL SIZE
	SKIPE SATTK2		;IF THERE IS A SECOND SAT TRACK,
	AOS TOTSIZ		; INCLUDE IT
	MOVE	Z,DIOWD		;GET THE IOWD OF FILE
	MOVEM	Z,MFDPTR	;SAVE AS MFD POINTER
	PUTSTR	[ASCIZ/MFD READ.  /]
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ TRACKS.
/]
	AOJGE	Z,EMMFD		;JUMP IF EMPTY MFD!
	MOVE	A,JOBFF		;GET JOBFF
	MOVEM	A,SAVFF		;SAVE IT
REC.1:	SKIPN	A,(Z)		;GET THE NAME OF A USER
	JRST	REC.4		;EMPTY ENTRY
	MOVEM	A,PPUFD		;SAVE THE PPN OF THIS UFD
	HLLZ	B,1(Z)		;GET THE EXTENSION
	CAME	B,['UFD   ']	;MUST BE SIXBIT UFD
	JRST	REC.5		;MENTION GARBAGED NAME.  RTSAV,RTSAV+1 SETUP

	MOVSI	A,(Z)		;copy information from MFD
	HRRI	A,RTSAV
	BLT	A,RTSAV+DDRET-1
	MOVE	A,['  1  1']	;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+DDPPN	;SAVE
	HRRZ	R,3(Z)		;GET THE TRACK ADDRESS
	HRLZM	R,RTSAV+DDRET	;save as first rtvl pointer
	MOVEM	R,RTSAV+DDLOC	;DDLOC is mis-placed in UFD copy
	MOVE	A,4(Z)		;DDLNG is mis-placed in UFD copy
	MOVEM	A,RTSAV+DDLNG
	SETZM	RTSAV+DNXTGP
	MOVEI	A,1
	MOVEM	A,RTSAV+DGRP1R
	MOVE	A,SATID
	MOVEM	A,RTSAV+DSATID
	SETZM	RTSAV+DDRET+1
	MOVE	A,[RTSAV+DDRET+1,,RTSAV+DDRET+2]
	BLT	A,RTSAV+WDRTVL-1

	MOVE	A,SAVFF
	MOVEM	A,JOBFF
	PUSHJ	P,RFRED		;read and repair retrieval of a UFD
	MOVE	W,FSIZE
	ADDM	W,TOTSIZ
	MOVE	W,PPUFD		;GET NAME
	PUSHJ	P,TYPPN
	PUTSTR	[ASCIZ/ /]
	MOVE	W,FSIZE		;GET FILE SIZE
	PUSHJ	P,DECOUT	;ARG STILL IN W, I HOPE
	PUTSTR	CRLF
	MOVE	Y,DIOWD		;GET THE IOWD OF THE FILE
	AOJGE	Y,REMUFD	;TELL ABOUT THIS EMPTY UFD
REC.2:	SKIPN	A,0(Y)		;GET A FILE NAME
	JRST	REC.3		;EMPTY NAME

	MOVSI	A,(Y)		;copy information from UFD
	HRRI	A,RTSAV
	BLT	A,RTSAV+DDRET-1
	MOVE	A,PPUFD		;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+DDPPN	;SAVE
	HRRZ	R,3(Y)		;GET THE TRACK ADDRESS
	HRLZM	R,RTSAV+DDRET	;save as first rtvl pointer
	MOVEM	R,RTSAV+DDLOC	;DDLOC is mis-placed in UFD copy
	MOVE	A,4(Y)		;DDLNG is mis-placed in UFD copy
	MOVEM	A,RTSAV+DDLNG
	SETZM	RTSAV+DNXTGP
	MOVEI	A,1
	MOVEM	A,RTSAV+DGRP1R
	MOVE	A,SATID
	MOVEM	A,RTSAV+DSATID
	SETZM	RTSAV+DDRET+1
	MOVE	A,[RTSAV+DDRET+1,,RTSAV+DDRET+2]
	BLT	A,RTSAV+WDRTVL-1

	PUSHJ	P,RRTD		;Read and Repair RETRIEVAL of data file
	MOVE	W,FSIZE
	ADDM	W,TOTSIZ
	SKIPN	ALLNAM		;SKIP IF BEING NOISY
	JRST	REC.3
	PUSHJ	P,TYFIL
	PUTSTR	[ASCIZ/ /]
	PUSHJ	P,DECOUT
	PUTSTR	CRLF
REC.3:	ADD	Y,[XWD UFDN,UFDN]
	JUMPL	Y,REC.2		;LOOP
REC.4:	ADD	Z,[XWD UFDN,UFDN]
	JUMPL	Z,REC.1		;LOOP
	PUTSTR	[ASCIZ/PHASE 1 COMPLETE.
/]
	SETZM	PHI1
	PUTSTR	[ASCIZ/THERE ARE /]
	MOVE	W,TOTSIZ
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ TRACKS IN THIS FILE SYSTEM.
/]
	PUSHJ	P,RCBITC
	POPJ	P,

REMUFD:	PUTSTR	[ASCIZ/EMPTY UFD. /]
	PUSHJ	P,TYFIL		;TYPE THE NAME OF THE FILE
	PUTSTR	CRLF
	JRST	REC.4

REC.5:	PUTSTR	[ASCIZ/A FILE, NOT A UFD, FOUND IN [1,1].
/]
	PUSH	P,Z
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
	POP	P,Z
	SKIPN REBLDF
	HALT	REC.4		;GET ANOTHER ENTRY FROM MFD
	PUSHJ P,EXAM1
	JRST REC.4

RCBITC:	MOVE	R,MTRACK	;GET THE MAXIMUM TRACK NUMBER
	SUBI	R,1
	SETZ	A,		;ZERO COUNTER
RBTCT1:	PUSHJ	P,SBYTE		;MAKE A BYTE POINTER
	LDB	B,SATBYT
	JUMPE	B,.+2
	ADDI	A,1
	SOJG	R,RBTCT1	;LOOP
	CAMLE	A,TOTSIZ
	MOVEM	A,TOTSIZ	;SAVE BIGGEST OF ALL
	PUTSTR	[ASCIZ/
THERE ARE /]
	MOVE	W,A
	PUSHJ	P,DECOUT
	PUTSTR	[ASCIZ/ BLOCKS CLAIMED IN MY VERSION OF THE SAT TABLE
/]
	POPJ	P,
;RFRED RFRD0 RFRED0 RFRED1 RFRED2 RFRD2A RFRED3 RFRED7 RFRD7Y RFRD7X RFRD7A RFRD7B RFRED6

	SUBTTL	RFRED READ A FILE INTO CORE (Usually the MFD or a UFD)
;THIS ROUTINE USES R AS A PARAMETER, RETURNS DIOWD, FSIZE
;ACCUMULATORS  K,L,M,N,AND S ARE CLOBBERED
;Call with RTSAV through RTSAV+17 set up with the best retrieval data
;that you can imagine or invent.   It helps to have a good memory
;
RFRED:	SETOM	FILEON		;SET FLAG
	SETZM	FSIZE		;COUNT FILE SIZE
	SETZM	DIOWD
	SETZM	GRP1R
	AOS	GRP1R		;record number of first rec of group
	PUSHJ	P,DREAD		;READ FIRST TRACK OF FILE
	AOS	FSIZE		;COUNT FILE SIZE
	MOVE	S,RTSAV		;GET EXPECTED NAME
	CAME	S,TTRACK	;CHECK
	JRST	RFRD7Y		;BAD RETRIEVAL
	HLLZ	S,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	S,L
	JRST	RFRD7Y
	MOVE	S,RTSAV+3
	CAME	S,TTRACK+3
	JRST	RFRD7Y
	MOVE	S,SATID
	CAME	S,DSATID+TTRACK
	JRST	RFRD7Y		;INVALID SATID
	MOVM	S,TTRACK+5	;GET THE WORD COUNT
	CAIGE	S,400000	;SKIP IF FILE IS NOT "SMALL"
	JRST	RFRD0		;REQUEST IS "REASONABLE"
	OUTSTR	[ASCIZ/FILE SIZE ≥ 128K. I WON'T READ THIS INTO CORE!
/]
	HALT	.		;STOP HERE!

RFRD0:	MOVN	S,S		;GET - WORD COUNT
	MOVS	S,S		;SWAP S
	HRR	S,JOBFF		;
	SUBI	S,1		;MAKE IOWD FORMAT FOR LATER OPS.
	MOVEM	S,DIOWD		;SAVE DUMP IOWD
	MOVM	S,TTRACK+5	;GET WORD COUNT
	ADDB	S,JOBFF		;MAKE NEW JOBFF
	CAMGE	S,JOBREL	;TEST AGAINT CORE BOUNDS
	JRST	RFRED0		;IS OK
	CORE	S,		;GET MORE CORE
	JRST	NOCORE		;NONE AVAILABLE?
RFRED0:	MOVE	S,DIOWD		;GET THE ORIGINAL IOWD
;first track of a group.
RFRED1:	HLRZ	N,TTRACK+DDRET		;GET FIRST RETRIEVAL POINTER
	HRRZ	R,R			;ONLY THE BLOCK NUMBER IN R
	CAME	N,R			;SHOULD BE SAME AS CURRENT OPERATION
	JRST	RFRD7Y			;LOSE
	MOVE	N,[XWD TTRACK,RTSAV]	;SAVE RETRIEVAL OF THIS BLOCK
	BLT	N,RTSAV+WDRTVL-1	;BLT IT OVER.
	SETZM	NFT
	SKIPE	LPTFLG			;print everything on LPT?
	RPRINT	TTRACK			;yes.  what a mess
RFRED2:	JUMPGE	S,RFRD2A		;JUMP IF ACTUAL DATA TRANSFER IS concluded
	MOVSI	N,TTRACK+WDRTVL		;SOURCE OF DATA
	HRRI	N,1(S)			;DESTINATION OF DATA
	HLRE	K,S			;GET -WD COUNT
	MOVN	L,K			;GET TOTAL WD COUNT
	CAILE	L,200*NBPT		;SKIP IF AMOUNT TO GO ≤ 1 TRACK
	MOVEI	L,200*NBPT		;SHORTEN REQUEST
	ADD	K,L			;DECREASE THE -WD COUNT
	ADD	S,L			;INCREASE THE IOWD
	HRL	S,K			;S IS IOWD FOR NEXT XFER
	BLT	N,0(S)			;BLT THE DATA TO THE DATA STORE
RFRD2A:	AOS	K,NFT			;READ ANOTHER TRACK
	CAIL	K,TRKGRP		;MAKE SURE WE'RE IN GROUP STILL
	JRST	RFRED3			;GO READ FROM ANOTHER GROUP
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	R,TTRACK+DDRET(K)	;GET TRACK NUMBER OF NEXT
	TLNE	L,400000
	HRRZ	R,TTRACK+DDRET(K)	;
	JUMPE	R,RFRED6		;JUMP IF THERE ARE NO MORE TRACKS IN FILE
	PUSHJ	P,DREAD			;read additional tracks in this group
	AOS	FSIZE
	MOVE	K,RTSAV
	CAME	K,TTRACK
	JRST	RFRED7
	HLLZ	K,RTSAV+1
	HLLZ	L,TTRACK+1
	CAME	K,L
	JRST	RFRED7

;COMPARE ALL RETRIEVAL STARTING WITH WORD 7 (DDMPTM)
;NOTE THAT DREFTM IS NOT SPREAD OVER THE GROUP TO SAVE TIME ON LOOKUP
;ALSO, IT IS CLAIMED THAT THE FILE LENGTH NEED NOT BE CONSISTIENT.
	MOVSI	K,7-WDRTV2
	MOVE	L,TTRACK+7(K)		;LOOK 
	CAMN	L,RTSAV+7(K)
	AOBJN	K,.-2			;LOOP
	JUMPL	K,RFRED7		;RFRED BAD RETRIEVAL
	JRST	RFRED2			;GO DEPOSIT THE DATA

RFRED3:	HRRZ	R,TTRACK+DNXTGP		;GO GET ANOTHER GROUP
	JUMPE	R,RFRED6		;JUMP IF NO MORE GROUPS
	OUTSTR	[ASCIZ/Multi-Group file:
/]
	RPRINT	TTRACK			;enjoy yourself

	MOVEI	L,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDB	L,GRP1R
	MOVEM	L,RTSAV+DGRP1R		;set record number expected
	SETZM	RTSAV+DDRET
	MOVE	K,[RTSAV+DDRET,,RTSAV+DDRET+1]
	BLT	K,RTSAV+WDRTVL-1	;BLT IT OVER.
	HRLZM	R,RTSAV+DDRET		;this record is first of group
	SETZM	RTSAV+DNXTGP		;assume this is last group


	PUSHJ	P,DREAD
	AOS	FSIZE
	MOVE	L,TTRACK		;MATCH FIRST WORDS
	CAMN	L,RTSAV
	JRST	RFRD7Y			;BAD RETR.
	HLLZ	K,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	L,K
	JRST	RFRD7Y			;LOSE
	MOVE	K,TTRACK+3
	CAMN	K,RTSAV+3
	JRST	RFRED1			;RETRIEVAL MATCHES WELL ENOUGH.
	JRST	RFRD7Y

;Here if bad rtvl in the middle of a group
RFRED7:	CAIL	R,NTPP*DEADP
	CAIL	R,NTPP*(DEADP+1)
	JRST	RFRD7X			;bad rtr not on target pack.
;spread good rtvl to this place.
	MOVE	N,[RTSAV,,TTRACK]	;Copy good RETRIEVAL to THIS BLOCK
	BLT	N,TTRACK+WDRTVL-1	;BLT IT OVER.
	OUTSTR	[ASCIZ/Must spread retrieval to dead pack for
/]
	RPRINT	TTRACK
	OUTSTR	[ASCIZ/CPOPJ$G when ready to do it!
/]
	PUSHJ	P,DDTCALL
	RWRITE	(R)			;send it
	JRST	RFRED2			;add zeros to file.

;here on rtvl error on first track of a group (including 1st track of file)
RFRD7Y:	CAIL	R,NTPP*DEADP
	CAIL	R,NTPP*(DEADP+1)
	JRST	RFRD7X			;bad rtr not on target pack.
	OUTSTR	[ASCIZ/RFRD7Y.  Retrieval error for first track of group.
File sought:
/]
	RPRINT	RTSAV
	OUTSTR	[ASCIZ/
File found:
/]
	RPRINT	TTRACK
	OUTSTR	[ASCIZ/Continue, and the sought rtvl will be written here
The remainder of the file data will be assumed to be zero.
/]
	PUSHJ	P,DDTCALL
	MOVE	N,[RTSAV,,TTRACK]
	BLT	N,TTRACK+WDRTVL-1
	RWRITE	(R)
	SKIPN	DIOWD			;if this isn't set,
	POPJ	P,			;then there's no data present
	JUMPGE	S,CPOPJ
	SETZM	1(S)			;return zero for rest of file
	AOBJN	S,.-1			;it's slow and stupid and works
	POPJ	P,			;can't fix anything else!

RFRD7X:	PUTSTR	[ASCIZ/
BAD RETRIEVAL AT RFRED7! not on target pack
/]
	PUSHJ	P,TYFIL
	PUTSTR	[ASCIZ/ FILE POINTS TO /]
	RPRINT	TTRACK
	SOS	FSIZE
	SETZ	W,
	SKIPN	SATFLG
	DPB	W,SATBYT
	PUSHJ	P,EXAM1
	SKIPE REBLDF
	JRST RFRD7A
	SKIPN	NOSTOP			;CAN WE STOP?
	JRST	RFRD7B			;YES ASK ABOUT FLUSHING
RFRD7A:	PUTSTR	[ASCIZ/THIS FILE WILL BE FLUSHED!
/]
	SETZM	DIOWD
	POPJ	P,

RFRD7B:	PUTSTR	[ASCIZ/
TYPE Y TO FLUSH THIS FILE: /]
	INCHWL A
	CLRBFI
	CAIE	A,"Y"
	CAIN	A,"y"
	JRST	RFRD7A
	POPJ	P,			;NO FLUSH: JUST RETURN

RFRED6:	JUMPGE	S,CPOPJ			;RETURN IF WORD COUNT EXHAUSTED
	SETZM	1(S)			;supply zero for rest of data.
	AOBJN	S,.-1
	PUTSTR	[ASCIZ/RFRED6: NO MORE TRACKS AND WORD COUNT UNEXHAUSTED!
/]
	RPRINT	TTRACK			;TYPE THE FILE NAME
	PUSHJ	P,DDTCALL
	POPJ	P,

;RRCHECK.RETRIEVAL RRTD RRTD1 RRTD2 RRTD3 RRTD7 RRTD7Y RRTD7B RRTD7A RRTD7X RRTD7C RRTD6

COMMENT ⊗
RRCHECK.RETRIEVAL:
⊗
	SUBTTL	RRTD - CHECK RETRIEVAL:
;THIS ROUTINE USES R AS A PARAMETER.
;ACCUMULATORS  K,L,M,N,AND S ARE CLOBBERED
;Call with RTSAV through RTSAV+17 set up with the best retrieval data
;that you can imagine or invent.   It helps to have a good memory
;
RRTD:	SETZM	FILEON		;RETRIEVAL ONLY!
	SETZM	FSIZE
	SETZM	GRP1R
	AOS	GRP1R		;record number of first rec of group
	PUSH	P,NRTCHK	;SAVE FLAG
	SETZM	NRTCHK		;CLEAR FLAG
	PUSHJ	P,DREAD		;READ 
	POP	P,NRTCHK	;RESTORE FLAG. IF SET, DISK OPS DON'T HAPPEN
	AOS	FSIZE
	MOVE	S,RTSAV		;GET EXPECTED NAME
	CAME	S,TTRACK	;CHECK
	JRST	RRTD7Y		;BAD RETRIEVAL
	HLLZ	S,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	S,L
	JRST	RRTD7Y		;EXT LOSES
	MOVE	S,RTSAV+3
	CAME	S,TTRACK+3
	JRST	RRTD7Y		;PPN WRONG
	MOVE	S,SATID
	CAME	S,DSATID+TTRACK
	JRST	RRTD7Y		;INVALID SATID
	MOVM	S,TTRACK+5	;GET THE WORD COUNT
	MOVN	S,S		;GET - WORD COUNT
;FIRST BLOCK OF A GROUP.
RRTD1:	HLRZ	N,TTRACK+DDRET		;GET RETRIEVAL
	HRRZ	R,R
	CAME	R,N
	JRST	RRTD7Y			;LOSE BLOCK SHOULD POINT TO SELF
	MOVE	N,[XWD TTRACK,RTSAV]	;SAVE RETRIEVAL OF THIS BLOCK
	BLT	N,RTSAV+WDRTVL-1	;BLT IT OVER.
	SETZM	NFT
	SKIPE	LPTFLG
	RPRINT	TTRACK
;SUBSEQUENT BLOCKS OF A GROUP
RRTD2:	MOVM	L,S			;GET + WD COUNT
	CAILE	L,200*NBPT		;SKIP IF AMOUNT TO GO ≤ 1 TRACK
	MOVEI	L,200*NBPT		;SHORTEN REQUEST
	ADD	S,L			;DECREASE THE -WD COUNT
	AOS	K,NFT			;READ ANOTHER TRACK
	CAIL	K,TRKGRP		;MAKE SURE WE'RE IN GROUP STILL
	JRST	RRTD3			;GO READ FROM ANOTHER GROUP
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	R,TTRACK+DDRET(K)	;GET TRACK NUMBER OF NEXT
	TLNE	L,400000
	HRRZ	R,TTRACK+DDRET(K)	;
	JUMPE	R,RRTD6		;JUMP IF NO MORE TRACKS
	PUSHJ	P,DREAD		;READ SUBSEQUENT TRACK OF A GROUP
	AOS	FSIZE
	MOVE	K,TTRACK
	CAME	K,RTSAV
	JRST	RRTD7		;LOSE  FILE
	HLLZ	K,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	K,L
	JRST	RRTD7		;LOSE  EXT
	MOVE	K,TTRACK+3
	CAME	K,RTSAV+3
	JRST	RRTD7		;LOSE  PPN
	MOVE	K,TTRACK+4
	CAME	K,RTSAV+4
	JRST	RRTD7		;LOSE  DDLOC MISMATCH

;COMPARE ALL RETRIEVAL STARTING WITH WORD 7 (DDMPTM)
;NOTE THAT DREFTM IS NOT SPREAD OVER THE GROUP TO SAVE TIME ON LOOKUP
;ALSO, IT IS CLAIMED THAT THE FILE LENGTH NEED NOT BE CONSISTIENT.
	MOVSI	K,7-WDRTV2		;COMPARE ALL RETRIEVAL
	MOVE	L,TTRACK+7(K)		;LOOK
	CAMN	L,RTSAV+7(K)
	AOBJN	K,.-2			;LOOP
	JUMPL	K,RRTD7			;RRTD BAD RETRIEVAL
	JRST	RRTD2			;GO DEPOSIT THE DATA(what data!!!)

RRTD3:	HRRZ	R,TTRACK+11		;GO GET ANOTHER GROUP
	JUMPE	R,RRTD6			;JUMP IF NO MORE GROUPS

	MOVEI	L,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDB	L,GRP1R
	MOVEM	L,RTSAV+DGRP1R		;set record number expected
	SETZM	RTSAV+DDRET
	MOVE	K,[RTSAV+DDRET,,RTSAV+DDRET+1]
	BLT	K,RTSAV+WDRTVL-1	;BLT IT OVER.
	HRLZM	R,RTSAV+DDRET		;this record is first of group
	SETZM	RTSAV+DNXTGP		;assume this is last group

	PUSH	P,NRTCHK
	SETZM	NRTCHK
	PUSHJ	P,DREAD
	POP	P,NRTCHK
	AOS	FSIZE
	MOVE	K,TTRACK
	CAME	K,RTSAV
	JRST	RRTD7Y		;LOSE
	HLLZ	K,TTRACK+1
	HLLZ	L,RTSAV+1
	CAME	K,L
	JRST	RRTD7Y
	MOVE	K,TTRACK+3
	CAMN	K,RTSAV+3
	JRST	RRTD1		;RETRIEVAL IS CONSISTIENT
	JRST	RRTD7Y		;rtrvl loses

RRTD7:	CAIL	R,NTPP*DEADP
	CAIL	R,NTPP*(DEADP+1)
	JRST	RRTD7X			;bad rtr not on target pack.
;spread good rtvl to this place.
	MOVE	N,[RTSAV,,TTRACK]	;Copy good RETRIEVAL to THIS BLOCK
	BLT	N,TTRACK+WDRTVL-1	;BLT IT OVER.
	OUTSTR	[ASCIZ/Must spread retrieval to dead pack for
/]
	RPRINT	TTRACK
	OUTSTR	[ASCIZ/CPOPJ$G when ready to do it!
/]
	PUSHJ	P,DDTCALL
	RWRITE	(R)			;send it
	JRST	RRTD2			;add zeros to file. (What data!!!!)

;here on rtvl error on first track of a group (including 1st track of file)
RRTD7Y:	CAIL	R,NTPP*DEADP
	CAIL	R,NTPP*(DEADP+1)
	JRST	RRTD7X			;bad rtr not on target pack.
	OUTSTR	[ASCIZ/

RRTD7Y.  Retrieval error for first track of group.  File sought:
/]
	RPRINT	RTSAV
	SKIPN	TTRACK+DDNAM		;is there a name here?
	JRST	RRTD7B			;blank track.  go quick.
	OUTSTR	[ASCIZ/File found:
/]
	RPRINT	TTRACK
	SKIPE	A,TTRACK+DSATID		;skip if deleted file
	CAME	A,SATID			;skip if valid SATID
	JRST	RRTD7A			;not a valid file. ok to write
	OUTSTR	[ASCIZ/Note the selected track has a valid SATID.
Do you really want to re-write this apparently valid track?
If you don't want to write this, adjust the stack before returning from DDT.
/]
	PUSHJ	P,DDTCALL
RRTD7B:	OUTSTR	[ASCIZ/Found a blank track.
/]
RRTD7A:	OUTSTR	[ASCIZ/Continue, and the sought rtvl will be written here
/]
	PUSHJ	P,DDTCALL
	MOVE	N,[RTSAV,,TTRACK]
	BLT	N,TTRACK+WDRTVL-1
	RWRITE	(R)
	OUTSTR	CRLF
	POPJ	P,			;can't fix anything else!

RRTD7X:	PUTSTR	[ASCIZ/
BAD RETRIEVAL AT RRTD7X
/]
	PUSHJ	P,TYFIL
	PUTSTR	[ASCIZ/ FILE POINTS TO /]
	RPRINT	TTRACK
	SOS	FSIZE
	SETZ	W,
	SKIPN	SATFLG
	DPB	W,SATBYT
	PUSHJ	P,EXAM1
RRTD7C:	PUTSTR	[ASCIZ/
TYPE Y TO FLUSH THIS FILE: /]
	INCHWL A
	CLRBFI
	CAIE	A,"Y"
	CAIN	A,"y"
	JRST	RRTD7C
	POPJ	P,			;NO FLUSH: JUST RETURN


RRTD6:	JUMPGE	S,CPOPJ			;RETURN IF WD COUNT DONE
	PUTSTR	[ASCIZ/RRTD6: Track Count too short for Word Count.  /]
	PUSHJ	P,TYFIL
	PUTSTR	CRLF
	POPJ	P,
;UFD.Scan RECUFD RECUF1 RECUF2 RECUF3 RECUF4 RECUF5 RCUFE1 RCUFE2

Comment $
UFD.Scan:  Look for ufds that are missing because their first track
(UFDS are all single-group files) was allocated on pack 1 (DEADP).

Method.  Read rtvl of each track not on the dead pack.  If a file
is a UFD (ppn = 1,1, ext = UFD) then if the first track is on
the dead pack, we spread the retrieval onto the subject pack.

$

;Note this is REConstruct UFD, not wRECk UFD,
RECUFD:	MOVSI	R,-NTPP*NPACK		;scan entire disk,
RECUF1:	HRRZ	Z,R			;except avoid the dead pack
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	PUSHJ	P,RECUF3		;read a live track
RECUF2:	AOBJN	R,RECUF1
	OUTSTR	[ASCIZ/RECUFD done
/]
	JRST	DDTCALL

RECUF3:	RREAD	(R)			;read retrieval
	MOVE	A,TTRACK+DDPPN		
	HLLZ	B,TTRACK+DDEXT
	CAMN	A,['  1  1']
	CAME	B,['UFD   ']
	POPJ	P,			;not a UFD
	HLRZ	A,TTRACK+DDRET		;is track one on the dead pack?
	CAIL	A,NTPP*DEADP
	CAIL	A,NTPP*(DEADP+1)
	POPJ	P,
	RPRINT	TTRACK			;Print RTVL of what I found
	MOVE	A,TTRACK+DSATID
	CAME	A,SATID
	JRST	RCUFE1			;"UFD" found w/bad SATID
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl
	SETOM	NFT			;Count for blocks of this group.
RECUF4:	AOS	K,NFT			;Advance to next track.
	CAIL	K,TRKGRP		;MAKE SURE WE'RE IN GROUP STILL
	POPJ	P,			;no.  UFDs are one group only.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	A,TTRACK+DDRET(K)	;GET TRACK NUMBER OF NEXT
	TLNE	L,400000
	HRRZ	A,TTRACK+DDRET(K)	;
	JUMPE	A,CPOPJ			;Return if no more tracks to read.
	CAIL	A,NTPP*DEADP
	CAIL	A,NTPP*(DEADP+1)
	JRST	RECUF4			;not on dead pack. don't bother.
	RREAD	(A)			;read track from dead pack.
	MOVE	K,TTRACK+DSATID
	JUMPE	K,RECUF5		;must rewrite the RTVL
	CAME	K,SATID
	JRST	RCUFE2			;bad news. look.
	MOVE	K,TTRACK+DDNAM
	CAME	K,RTSAV+DDNAM
	JRST	RCUFE2			;bad news. look.
	MOVE	K,TTRACK+DDPPN
	CAME	K,RTSAV+DDPPN
	JRST	RCUFE2			;bad news. look.
	MOVE	K,TTRACK+DDEXT
	CAME	K,RTSAV+DDEXT
	JRST	RCUFE2			;bad news. look.
RECUF5:	MOVE	K,[RTSAV,,TTRACK]
	BLT	K,TTRACK+WDRTVL-1	;copy rtvl to place for writing
	RWRITE	(A)
	JRST	RECUF4			;look for more


RCUFE1:	OUTSTR	[ASCIZ/"UFD" with a bad SATID found.  See latest RPRINT above.
CPOPJ to ignore./]
	JRST	DDTCALL

RCUFE2:	OUTSTR	[ASCIZ/Some inconsistency found in the retrieval of a
track found on the dead pack.  Compare RPRINT above with the following:
/]
	RPRINT	TTRACK
	JRST	DDTCALL
;File.RTVL.Spread FRSPRD FRSPR1 FRSPR2 FRSPR3 FRSPR4 FRSPR6 FRSPR5 FRSPE2

Comment $
File.RTVL.Spread:

Look for files that have rtvl in pack 1 (DEADP).

Method.  Read rtvl of each track not on the dead pack.  If a file
has rtvl anywhere in the dead pack, we spread the rtvl to the dead pack.

$

FRSPRD:	MOVSI	R,-NTPP*NPACK		;scan entire disk,
FRSPR1:	HRRZ	Z,R			;except avoid the dead pack
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	PUSHJ	P,FRSPR3		;read a live track
FRSPR2:	AOBJN	R,FRSPR1
	OUTSTR	[ASCIZ/FRSPRD done
/]
	JRST	DDTCALL

FRSPR3:	RREAD	(R)			;read retrieval
	SKIPN	A,TTRACK+DSATID
	POPJ	P,
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl
	SETOM	NFT			;Count for blocks of this group.
	SETOM	RPCNT			;Flag to allow first RPRINT below
FRSPR4:	AOS	K,NFT			;Advance to next track.
	CAIL	K,TRKGRP		;MAKE SURE WE'RE IN GROUP STILL
	POPJ	P,			;no.  Spread one group at a time.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	A,TTRACK+DDRET(K)	;GET TRACK NUMBER OF NEXT
	TLNE	L,400000
	HRRZ	A,TTRACK+DDRET(K)	;
	JUMPE	A,CPOPJ			;Return if no more tracks to read.
	CAIL	A,NTPP*DEADP
	CAIL	A,NTPP*(DEADP+1)
	JRST	FRSPR4			;not on dead pack. don't bother.
	RREAD	(A)			;read track from dead pack.
	SKIPN	K,TTRACK+DSATID
	JRST	FRSPR5			;must rewrite the RTVL
	CAME	K,SATID
	JRST	FRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDNAM
	CAME	K,RTSAV+DDNAM
	JRST	FRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDPPN
	CAME	K,RTSAV+DDPPN
	JRST	FRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDEXT
	CAME	K,RTSAV+DDEXT
	JRST	FRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDPRO
	CAME	K,RTSAV+DDPRO
	JRST	FRSPE2			;bad news. look.
;check for perfection and avoid an RWRITE (AND ESPECIALLY THE RPRINT!)
	MOVSI	L,-WDRTVL
FRSPR6:	MOVE	K,TTRACK(L)
	CAME	K,RTSAV(L)
	JRST	FRSPR7			;maybe rewrite rtvl
	AOBJN	L,FRSPR6
	JRST	FRSPR4

FRSPR7:	MOVE	L,TTRACK+DDLNG		;length of extant copy
	CAML	L,RTSAV+DDLNG		;length of prototype
	JRST	FRSPR4			;Extant copy is longer = better.
FRSPR5:	MOVE	K,[RTSAV,,TTRACK]
	BLT	K,TTRACK+WDRTVL-1	;copy rtvl to place for writing
	AOSN	RPCNT			;Report only once per group
	RPRINT	RTSAV			;announce we're fixing this one.
	RWRITE	(A)
	JRST	FRSPR4			;look for more


FRSPE2:	RPRINT	RTSAV			;announce we're fixing this one.
	OUTSTR	[ASCIZ/Some inconsistency found in the retrieval of a
track found on the dead pack.  Compare RPRINT above with the following:
/]
	RPRINT	TTRACK
	JRST	DDTCALL

;Group.RTVL.Spread GRSPRD GRSPR1 GRSPR3 GRSPR4 GRSPR5 GRSPR6 GRSPR7 GRSPE2

Comment $
Group.RTVL.Spread:

Look for files that have DNXTGP or DDLOC pointing to the dead pack.

Read rtvl of each track.  If this track is first track of its
group then we look at DNXTGP and DDLOC.

If DNXTGP points onto the dead pack, we spread vestigal rtvl
to the specified track.

If a file has DGRP1R≠1 and DDLOC points to the dead pack,
then write vestigal rtvl onto the track specified by DDLOC.

	If the file's DGRP1R=1101 then the DNXTGP pointer will be set
	in the vestigal rtvl. 

	If the file's DGRP1R>1101 then the vestigal rtvl is missing
	the correct DNXTGP.  We'll warn, but not do anything else for
	this case now.
$

GRSPRD:	MOVSI	R,-NTPP*NPACK		;scan entire disk,
	AOBJP	R,.+1			;avoid SAT
GRSPR1:	PUSHJ	P,GRSPR3		;read a track
	AOBJN	R,GRSPR1
	OUTSTR	[ASCIZ/GRSPRD done
/]
	JRST	DDTCALL

GRSPR3:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	HRRZ	A,R
	HLRZ	B,TTRACK+DDRET
	CAME	A,B
	POPJ	P,			;not first track of group.
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl
	SKIPN	Z,TTRACK+DNXTGP		;get pointer to next group
	JRST	GRSPR5			;no next group
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	JRST	GRSPR5			;no. doesn't point inside
	RREAD	(Z)			;read rtvl of track in dead pack
	SKIPN	TTRACK+DSATID		;if zero now, ok to go.
	JRST	GRSPR4			;
	MOVE	K,TTRACK+DDNAM
	CAME	K,RTSAV+DDNAM
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDPPN
	CAME	K,RTSAV+DDPPN
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDEXT
	CAME	K,RTSAV+DDEXT
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDPRO
	CAME	K,RTSAV+DDPRO
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DGRP1R
	MOVE	L,RTSAV+DGRP1R
	ADDI	L,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	CAME	K,L
	JRST	GRSPE2			;DGRP1R inconsistent
	JRST	GRSPR5			;everything's fine.


GRSPR4:	OUTSTR	[ASCIZ/Spreading via DNXTGP
/]
	RPRINT	RTSAV
	MOVE	A,[RTSAV,,TTRACK]
	BLT	A,TTRACK+DDRET-1	;save rtvl
	SETZM	TTRACK+DDRET
	MOVE	A,[TTRACK+DDRET,,TTRACK+DDRET+1]
	BLT	A,TTRACK+WDRTVL-1
	HRLZM	Z,TTRACK+DDRET		;store this vestige
	SETZM	TTRACK+DNXTGP		;can't know the next group pointer
	MOVEI	A,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDM	A,TTRACK+DGRP1R		;set DGRP1R of next group.
	RWRITE	(Z)
;Now think about DDLOC
GRSPR5:	MOVE	Z,RTSAV+DDLOC		;get pointer to first group
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	POPJ	P,			;first isn't inside dead pack.
	RREAD	(Z)			;read rtvl of track in dead pack
	SKIPN	TTRACK+DSATID		;if zero now, ok to go.
	JRST	GRSPR6			;
	MOVE	K,TTRACK+DDNAM
	CAME	K,RTSAV+DDNAM
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDPPN
	CAME	K,RTSAV+DDPPN
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDEXT
	CAME	K,RTSAV+DDEXT
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DDPRO
	CAME	K,RTSAV+DDPRO
	JRST	GRSPE2			;bad news. look.
	MOVE	K,TTRACK+DGRP1R
	CAIE	K,1
	JRST	GRSPE2			;DGRP1R inconsistent
	SKIPE	TTRACK+DNXTGP		;is next group pointer present?
	POPJ	P,			;yes, assume we can't improve it.
	MOVE	A,RTSAV+DGRP1R
	CAIE	A,NBPT*TRKGRP+1		;Is this the second group?
	POPJ	P,			;nope.  can't fix DNXTGP
	RPRINT	RTSAV
	OUTSTR	[ASCIZ/Will use above rtvl to fix DNXTGP via its DDLOC (below):
/]
	RPRINT	TTRACK
	JRST	GRSPR7


GRSPR6:	OUTSTR	[ASCIZ/Spreading via DDLOC
/]
	RPRINT	RTSAV
	MOVE	A,[RTSAV,,TTRACK]
	BLT	A,TTRACK+DDRET-1	;save rtvl
	SETZM	TTRACK+DDRET
	MOVE	A,[TTRACK+DDRET,,TTRACK+DDRET+1]
	BLT	A,TTRACK+WDRTVL-1
	MOVEI	A,1			;Set DGRP1R of first group
	MOVEM	A,TTRACK+DGRP1R		;set DGRP1R of first group.
	HRLZM	Z,TTRACK+DDRET		;store this vestige
	SETZM	TTRACK+DNXTGP		;can't know the next group pointer
	MOVE	A,RTSAV+DGRP1R
	CAIN	A,NBPT*TRKGRP+1		;Is this the second group?
GRSPR7:	HRRZM	R,TTRACK+DNXTGP		;sometimes we know what to write here
	RWRITE	(Z)
	POPJ	P,

GRSPE2:	RPRINT	RTSAV			;announce we're fixing this one.
	OUTSTR	[ASCIZ/Some inconsistency found in the retrieval of a
track found on the dead pack.  The RPRINT above shows what we might want,
compared to the following that's already there:
/]
	RPRINT	TTRACK
	PUSHJ	P,DDTCALL
	POPJ	P,
;File.rtvl.extend NOTE FREXTD FREXT1 FREXT2 FREXT3 NEWGRP FREXT4 FREXT5 FREXT8 FREXT6 FREXT9 GSPRED GSPRD1 FREXTE FRXGET FRXGT1 FRXGT0 FRXGT3 FRXGT4

Comment $
File.rtvl.extend:
NOTE:  This procedure was executed too early in the reconstruction
phase.  We had forgotten to rerun the code to extend retrieval
from the UFDs that were reconnected in FRSPRD.  So we had to
undo this.

Read files on dead pack (DEADP).  Check to make sure they have
enough tracks assigned.  If not, extend current group by assigning
new tracks on the dead pack.

Method.  Read rtvl of each track from the dead pack.  If a file doesn't
have enough tracks assigned for its given length, we allocate blank
tracks on dead pack to extend only this group to it's proper length.

$

FREXTD:	OUTSTR	[ASCIZ/
FREXTD, Extend retrieval of vestigal files on dead pack.

You should run RECON0 before doing this, if you've made changes to
increase the validity of information contained in the collection of UFDs.

THIS IS ONE OF THE LAST RECONSTRUCTIVE PROCEDURES.
MUCH MUST BE DONE BEFORE DOING THIS; otherwise, you get to undo this
with code that hasn't been written yet, but see UNRETR for most of it.

Otherwise, just continue.
/]
	EXIT	1,
	OUTSTR	[ASCIZ/
Extending the retrieval of files on the dead pack to include enough
tracks to cover the file word count.
/]
	MOVE	R,[-NTPP,,NTPP*DEADP]	;scan dead pack
FREXT1:	PUSHJ	P,FREXT2		;read a track
	AOBJN	R,FREXT1
	OUTSTR	[ASCIZ/FREXT done
/]
	JRST	DDTCALL

FREXT2:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	MOVE	Y,R			;initial pointer for extra tracks
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl
;count number of blocks assigned in this group.
	MOVEI	A,0			;Count for blocks of this group.
	MOVE	B,[POINT 18,RTSAV+DDRET]
FREXT3:	ILDB	C,B
	JUMPE	C,FREXT4
	ADDI	A,1
	CAIGE	A,TRKGRP
	JRST	FREXT3
;this group is full.  Is there another group?
	SKIPE	RTSAV+DNXTGP		;any next group?
	POPJ	P,			;this grp is full and there's another.
	MOVE	K,RTSAV+DGRP1R		;test to see if need another group
	SUBI	K,1
	IMULI	K,WDREC			;number of words in all prev groups
	MOVE	B,RTSAV+DDLNG		;file length
	SUB	B,K			;# of words needed in this group and ff
	CAMG	B,[DWDTRK*TRKGRP]	;more than one group needed?
	POPJ	P,			;no next group is needed.
	OUTSTR	[ASCIZ/


This is the case of an already full group
that will have to be extended to another group. 
/]
	RPRINT	RTSAV
	PUSHJ	P,DDTCALL
;extend to a new group
NEWGRP:	PUSHJ	P,FRXGET		;get another track for next group
	HRRZM	Z,RTSAV+DNXTGP		;save pointer to next group
	OUTSTR	[ASCIZ/Please note, we're extending this file to another group.
Here's what we're planning to make this group look like:
/]
	RPRINT	RTSAV
	PUSHJ	P,DDTCALL
	PUSHJ	P,GSPRED		;spread this group.
;now, time for another group.
	MOVEI	A,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	ADDM	A,RTSAV+DGRP1R
	MOVE	Z,RTSAV+DNXTGP
	SETZM	RTSAV+DNXTGP
	SETZM	RTSAV+DDRET
	MOVE	A,[RTSAV+DDRET,,RTSAV+DDRET+1]
	BLT	A,RTSAV+WDRTVL-1
	HRLZM	Z,RTSAV+DDRET
	PUSHJ	P,GSPRED		;spread track, in case don't need more
	MOVEI	A,1			;There's one track in new group
;Here with A having count of tracks in current group.  Do we need more tracks?
FREXT4:	SKIPE	RTSAV+DNXTGP		;if there's another group
	JRST	FREXT5			;then this group must be made full.
	MOVE	K,RTSAV+DGRP1R
	SUBI	K,1
	IMULI	K,WDREC			;number of words in all prev groups
	MOVE	B,RTSAV+DDLNG		;file length
	SUB	B,K			;# of words needed in this group and ff
	CAMLE	B,[DWDTRK*TRKGRP]	;reduce to be no more than words/group
FREXT5:	MOVE	B,[DWDTRK*TRKGRP]	;make a full group
;B now has the number of words we must account for in current group.
;convert to number of tracks needed in current group
	IDIVI	B,DWDTRK		;data words per track
	SKIPE	C			;skip if no fractional tracks needed
	ADDI	B,1			;bump.   This is number of tracks needed
;B now has the number of tracks needed in this group.
	CAMG	B,A			;A is how many tracks we have
	POPJ	P,
	OUTSTR	[ASCIZ/


Here's one we have to fix
/]
	RPRINT	RTSAV			;here's a file we have to fix.
	CAIN	A,1			;is A other than 1?
	JRST	FREXT8			;A is 1,  this is normal.
	OUTSTR	[ASCIZ/Note the unusual case of the rtvl being other than
the vestigal rtvl that we've written before....
/]
	PUSHJ	P,DDTCALL
;Here A=number of tracks assigned.  B=total number needed in this group
;Y:=first possible assignment of free track
FREXT8:
FREXT6:	PUSHJ	P,FRXGET		;get free track number in Z. Preserve A,B,R.
	MOVE	K,A			;Advance to next track.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HRLM	Z,RTSAV+DDRET(K)
	TLNE	L,400000
	HRRM	Z,RTSAV+DDRET(K)
	ADDI	A,1
	CAMGE	A,B
	JRST	FREXT6
;We've just filled this group.  do we need another group?
	SKIPE	RTSAV+DNXTGP		;if there's already another group
	JRST	FREXT9			;yes, no need to worry.
	MOVE	K,RTSAV+DGRP1R
	SUBI	K,1
	IMULI	K,WDREC			;number of words in all prev groups
	MOVE	B,RTSAV+DDLNG		;file length
	SUB	B,K			;# of words needed in this group and ff
	CAMLE	B,[DWDTRK*TRKGRP]	;more than whole group needed?
	JRST	NEWGRP			;yes, need to add a new group
FREXT9:	OUTSTR	[ASCIZ/Here's what we're planning to make it look like:
/]
	RPRINT	RTSAV
	PUSHJ	P,DDTCALL		;one day, flush this.
	PUSHJ	P,GSPRED
	POPJ	P,

;spread new rtvl that's in RTSAV to all tracks in this group.
GSPRED:	MOVE	K,[RTSAV,,TTRACK]
	BLT	K,TTRACK+WDRTVL-1	;copy rtvl to place for writing
	SETOM	NFT
GSPRD1:	AOS	K,NFT			;Advance to next track.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	Z,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	Z,TTRACK+DDRET(K)	;
	JUMPE	Z,CPOPJ
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	PUSHJ	P,FREXTE		;What the hell is this doing here?
	RWRITE	(Z)
	MOVE	K,NFT			;Track number within group
	CAIGE	K,TRKGRP-1		;End of group?
	JRST	GSPRD1			;No
	POPJ	P,

FREXTE:	AOS	(P)
	OUTSTR	[ASCIZ/Here I am in GSPRED, spreading rtvl onto the wrong pack.
I won't do it, but you should investigate anyway.
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

;find a free track on dead pack.  Start at present contents of Y, + 1.
FRXGET:	MOVE	Z,Y			;Y is where to start on pack
	PUSHJ	P,FRXGT0
	MOVE	Y,Z			;start from here next time
	POPJ	P,

FRXGT1:	RREAD	(Z)
	SKIPN	TTRACK+DSATID
	POPJ	P,			;found a free track.
FRXGT0:	AOBJN	Z,FRXGT1
	OUTSTR	[ASCIZ/No free tracks left at the end of this pack;
we'll wrap to the front of this pack.
/]
	PUSHJ	P,DDTCALL
	MOVE	Z,[-NTPP,,NTPP*DEADP]	;scan dead pack from the front.
FRXGT3:	RREAD	(Z)
	SKIPN	TTRACK+DSATID
	POPJ	P,			;found a free track.
	AOBJN	Z,FRXGT3
FRXGT4:	OUTSTR	[ASCIZ/It's inconceivable, it has filled up?
/]
	PUSHJ	P,DDTCALL
	HALT	.-1
;Group.RTVL.Verify GRVERF GRVER1 GRVER3 GRVER4 GRVER5 GRVER6 GRVER7 GRVER8 GRVRE1 NGDDL IGDDLC IDETGP GDDLOC DETGRP

Comment $
Group.RTVL.Verify:

Read rtvl of each track.  If this track is first track of its
group and it's a multi-group file, then we go to DDLOC and
follow the DNXTGP pointer through the file.

If all groups (i.e., consistent with file length) are found
then the DDLOC of the file is recorded, to avoid doing this
again for the same file.

If some of the groups are not found, then the DDLOC of the file
is recorded, along with the location of the group that we just
came from.   We check here for the special case of the group
we started with (R) is the next group following the last
group chained from DDLOC.  If this is the case, we patch the
DNXTGP of the last group to point to (R).

Eventually, we'll end with a list of DDLOCs and corresponding
detached chunks.   We should do something about them.

$

GRVERF:	SETZM	IGDDLC			;number of good DDLOCs
	SETZM	IDETGP			;Index to DETGRP
	MOVSI	R,-NTPP*NPACK		;scan entire disk,
GRVER1:	PUSHJ	P,GRVER3		;read a track
	AOBJN	R,GRVER1
	OUTSTR	[ASCIZ/GRVERD done
/]
	JRST	DDTCALL

GRVER3:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	HRRZ	A,R
	HLRZ	B,TTRACK+DDRET
	CAME	A,B
	POPJ	P,			;not first track of group.
	MOVE	A,TTRACK+DGRP1R
	SKIPN	TTRACK+DNXTGP
	CAIE	A,1
	JRST	GRVER4			;multi-group file
	MOVE	A,TTRACK+DDLNG
	CAMG	A,[DWDTRK*TRKGRP]	;more than a full group?
	POPJ	P,
GRVER4:	MOVE	A,TTRACK+DDLOC		;get the first file address
	SKIPG	B,IGDDLC		;get the count of table entries
	JRST	GRVER5			;none present.  examine this one
	CAMN	A,GDDLOC-1(B)
	POPJ	P,
	SOJG	B,.-2
GRVER5:	RPRINT	1,TTRACK		;we are examining one. Short form
	AOS	B,IGDDLC		;bump count
	CAILE	B,NGDDL
	SOS	B,IGDDLC
	MOVEM	A,GDDLOC-1(B)
;now, start at DDLOC and look thru file, group by group....
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl
	MOVE	Z,TTRACK+DDLOC		;get pointer to first group
	RREAD	(Z)			;read rtvl of first track in group
	MOVEI	K,1			;Expected DGRP1R
	SKIPA	L,TTRACK+DDLNG		;length of the file.  First time only.
GRVER6:	RREAD	(Z)			;read another group.
	SKIPE	A,TTRACK+DSATID		;Check SATID
	CAME	A,SATID
	JRST	GRVRE1			;No SATID at DDLOC
	HLRZ	A,TTRACK+DDRET
	CAME	A,Z			;make assurance double sure
	JRST	GRVRE1
	MOVE	A,TTRACK+DDNAM
	CAME	A,RTSAV+DDNAM
	JRST	GRVRE1			;bad news. look.
	MOVE	A,TTRACK+DDPPN
	CAME	A,RTSAV+DDPPN
	JRST	GRVRE1			;bad news. look.
	MOVE	A,TTRACK+DDEXT
	CAME	A,RTSAV+DDEXT
	JRST	GRVRE1			;bad news. look.
	MOVE	A,TTRACK+DDPRO
	CAME	A,RTSAV+DDPRO
	JRST	GRVRE1			;bad news. look.
	MOVE	A,TTRACK+DGRP1R
	CAME	A,K			;Verify DGRP1R
	JRST	GRVRE1
	ADDI	K,NBPT*TRKGRP		;NUMBER OF RECORDS/GROUP
	SUB	L,[DWDTRK*TRKGRP]	;decrease word count. for full group
	JUMPLE	L,GRVER8		;Jump if exhausted.
	MOVE	Z,TTRACK+DNXTGP		;is there another group here?
	JUMPN	Z,GRVER6		;yes.  verify it.
	OUTSTR	[ASCIZ/Disconnected file.
/]
	CAME	K,RTSAV+DGRP1R		;can we patch this now?
	JRST	GRVER7			;no
	OUTSTR	[ASCIZ/I'm going to reconnect it!
/]
	HRRZM	R,TTRACK+DNXTGP		;Yes.  Set link to next group.
	PUSH	P,K
	PUSH	P,L
	RPRINT	TTRACK
	PUSHJ	P,DDTCAL
	SETOM	NFT
GRVER9:	AOS	K,NFT			;Advance to next track.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	Z,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	Z,TTRACK+DDRET(K)	;
	JUMPE	Z,CPOPJ
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	PUSHJ	P,FREXTE		;What the hell is this doing here?
	RWRITE	(Z)
	MOVE	K,NFT			;Track number within group
	CAIGE	K,TRKGRP-1		;End of group?
	JRST	GRVER9			;No
	POP	P,L
	POP	P,K
	HRRZ	Z,R
	JRST	GRVER6			;read the rest of it.

GRVER7:	SOS	IGDDLC			;remove this from list of good ones
	HRLZ	A,TTRACK+DDLOC
	HRR	A,R			;R may not be disconnected
	AOS	B,IDETGP
	CAILE	B,NGDDL
	SOS	B,IDETGP
	MOVEM	A,DETGRP-1(B)
	POPJ	P,

;here when WC is exhausted.  But are the groups exhausted?
GRVER8:	SKIPN	TTRACK+DNXTGP
	POPJ	P,			;everything ran out at once
	OUTSTR	[ASCIZ/Length ran out, but there's another group!
/]
	RPRINT	TTRACK
	PUSHJ	P,DDTCALL		;make a list
	MOVE	Z,TTRACK+DNXTGP
	JRST	GRVER6


GRVRE1:	RPRINT	RTSAV			
	OUTSTR	[ASCIZ/Some inconsistency found somewhere.
Look up, look down.
/]
	RPRINT	TTRACK
	PUSHJ	P,DDTCALL
	POPJ	P,

NGDDL==1000
IGDDLC:	0				;Index to GDDLOC
IDETGP:	0				;Index to DETGRP
GDDLOC:	BLOCK	NGDDL			;List of good multi-group DDLOCs
DETGRP:	BLOCK	NGDDL			;Detached group list.
					;Group address in right, DDLOC in left
;UFD.rebuild UFDRBL UFDRB1 UFDRB2 UFDRX1 UFDRX2 UFDRB3 UFDRB4 UFDRB5 UFDRB7 UFDRB6 UFDRB8 UFDEXR UFDRB9 UFDEXT UFDEX2 UFDEX3 FRZGET FRZGT3 UFDRE1 UFDRE2 FNDHOL FNDHO1 FNDHE1 FNDHOE UFDSHL UFSHL1 UFSHL3 UFSHL4 UFSHL2 UFSHL6 UFLSTL UFSHLC UFDEAD

Comment $
UFD.rebuild:

Read files on entire disk.   Check to make sure they have valid UFD
entries.

Read rtvl of each track.  If (current track address) = DDLOC of this
rtvl and  DDPPN is not [1,1] then this is an interesting track.
Read this file's UFD; locate an entry for this file.  If it can
be found, all is well.  Advance to next track, etc.

If the entry can't be found in the UFD then print a message.
If the UFD in question has a hole in a track allocated on DEADP,
then make an entry for this file in that hole.   If such a hole
can't be found, complain; file will not be linked into the ufd.

All writes are aimed at DEADP.

$

UFDRBL:	OUTSTR	[ASCIZ/UFD Rebuild phase
/]
	MOVE	A,['  1  1']	;GET NAME OF MFD
	MOVEM	A,RTSAV
	MOVEM	A,RTSAV+3	;SAVE AS EXPECTED RETRIEVAL
	MOVSI	A,'UFD'
	MOVEM	A,RTSAV+1
	MOVEI	R,1		;READ FILE FROM BLOCK 1
	PUSHJ	P,FREAD		;READ FILE
	MOVE	Z,DIOWD		;GET THE IOWD OF FILE
	ADDI	Z,1		;increment to make aobjn pointer.
	MOVEM	Z,MFDPTR	;SAVE AS MFD POINTER
	OUTSTR	[ASCIZ/MFD Read
/]
	PUSHJ	P,UFDSHL	;build UFD SHort List
	MOVE	A,JOBFF
	MOVEM	A,SAVFF		;base of each UFD that's read
	MOVSI	R,-NTPP*NPACK	;scan whole disk.
	PUSH	P,[0]		;room to preserve R
UFDRB1:	MOVEM	R,(P)		;preserve R
	PUSHJ	P,UFDRB2	;examine each track
	MOVE	R,(P)		;restore R
	AOBJN	R,UFDRB1
	POP	P,(P)		;fix stack
	OUTSTR	[ASCIZ/UFD Rebuild done
/]
	JRST	DDTCALL

UFDRB2:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	HRRZ	B,R
	CAME	B,TTRACK+DDLOC		;are we at first blk of file?
	POPJ	P,			;nope.
	MOVE	A,TTRACK+DDPPN		;does this belong to [1,1]?
	CAMN	A,['  1  1']
	POPJ	P,			;we were fortunate that 1,1 was ok.
	MOVE	A,[TTRACK,,UTSAV]
	BLT	A,UTSAV+WDRTVL-1	;save rtvl of subject file.
	MOVE	A,TTRACK+DDPPN		;PPN of this file.
	MOVE	B,UFSHLC		;first look thru list of damaged UFDs
UFDRX1:	CAMN	A,UFDEAD-1(B)
	JRST	UFDRX2			;UFD of this file is damaged.
	SOJG	B,UFDRX1
	POPJ	P,			;UFD not damaged.  Avoid much work

UFDRX2:	MOVE	Z,MFDPTR		;Get pointer to the MFD
UFDRB3:	MOVE	A,(Z)			;get UFD name from MFD
	HLLZ	B,1(Z)			;get extension
	CAMN	B,['UFD   ']		;match ext
	CAME	A,TTRACK+DDPPN		;matches what we seek?
	SKIPA				;no. get the next one
	JRST	UFDRB4			;here's the UFD name in the MFD
	ADD	Z,[XWD UFDN,UFDN]	;advance to next file name in MFD
	JUMPL	Z,UFDRB3		;jump unless exhausted.
	OUTSTR	[ASCIZ/Can't find UFD name in MFD for
/]
	RPRINT	UTSAV			;maybe UFD got deleted, but
	PUSHJ	P,DDTCALL		;there was a disconnected file
	POPJ	P,			;hanging around.

UFDRB4:	MOVEM	A,PPUFD			;SAVE THE PPN OF THIS UFD
	MOVEM	A,RTSAV+DDNAM		;SAVE NAME OF UFD 
	MOVEM	B,RTSAV+DDEXT
	MOVE	A,['  1  1']		;GET NAME OF UFD OWNER
	MOVEM	A,RTSAV+DDPPN		;SAVE
	HRRZ	R,3(Z)			;GET THE TRACK ADDRESS
	MOVEM	R,UFDADR
	MOVE	A,SAVFF
	MOVEM	A,JOBFF
	PUSHJ	P,FREAD			;read ufd as a file.
	MOVE	Y,DIOWD			;Get the IOWD of this file
	AOJGE	Y,UFDRB7		;Jump if this UFD is empty.  BUG?
	HLLZ	C,UTSAV+DDEXT		;extension of sought file
;Look for file's entry in the UFD we just read
UFDRB5:	MOVE	A,0(Y)
	HLLZ	B,1(Y)			;Get the extension
	CAMN	A,UTSAV+DDNAM
	CAME	B,C
	JRST	UFDRB6			;not a match
	MOVE	B,3(Y)			;this should match DDLOC of file
	CAMN	B,UTSAV+DDLOC
	POPJ	P,			;found the file in the UFD.
	RREAD	(B)
	OUTSTR	[ASCIZ/I was looking for a UFD entry for the following:
/]
	RPRINT	UTSAV
	OUTSTR	[ASCIZ/But I found a UFD entry for this instead:
/]
	RPRINT	TTRACK
	OUTSTR	[ASCIZ/I'm planning to ignore the first file listed above
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

UFDRB7:	OUTSTR	[ASCIZ/Found an empty UFD.  Will expand it.
/]
	RPRINT	TTRACK
	MOVE	A,TTRACK+DDLOC
	CAIL	A,NTPP*DEADP
	CAIL	A,NTPP*(DEADP+1)
	JRST	UFDRE2			;can't fix except on DEADP
	MOVEI	B,4400
	MOVEM	B,TTRACK+DDLNG
	RWRITE	(A)			;rewrite with full track allocated
	MOVEI	Y,0
UFDRB6:	ADD	Y,[UFDN,,UFDN]
	JUMPL	Y,UFDRB5
	OUTSTR	[ASCIZ/Can't find the UFD entry for:
/]
	RPRINT	UTSAV
	RREAD	@UFDADR			;get rtvl of UFD to TTRACK
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl of this UFD
	MOVE	A,TTRACK+DDLNG		;get length of UFD
	MOVEM	A,UFDLEN
	SETOM	NFT
UFDRB8:	AOS	K,NFT			;Advance to next track.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	Z,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	Z,TTRACK+DDRET(K)	;
	JUMPE	Z,UFDEXT		;can't find a hole, maybe extend UFD a trk
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	JRST	UFDRB9			;can't look except at DEADP
UFDEXR:	TREAD	(Z)			;Look for a hole here.
	PUSHJ	P,FNDHOL		;Skip if find a hole, return offset in S
	 JRST	UFDRB9			;can't find one.
	MOVSI	A,UTSAV			;add to hole
	HRRI	A,TT0(S)		;Copy file rtvl data to
	BLT	A,TT0+UFDN-1(S)		;hole in the UFD
	MOVE	A,UTSAV+DDLOC
	MOVEM	A,TT0+3(S)		;special location in UFD for DDLOC
	MOVE	A,UTSAV+DDLNG
	MOVEM	A,TT0+4(S)		;spec loc in ufd for length
	LDB A,[POINT 12,TT0+2(S),35]	;LOW DATE BITS
	LDB B,[POINT 3,TT0+1(S),20]	;HIGH 3 DATE BITS
	DPB B,[POINT 3,A,23]		;COMBINE HI AND LO DATE BITS
	LDB B,[POINT 11,TT0+2(S),23]	;TIME IN MINUTES
	IMULI B,=60*=15			;TIME IN 15THS
	DPB A,[POINT 15,B,14]		;EXTENDED TIME WRITTEN FORMAT
	MOVEM B,TT0+5(S)		;EXTENDED TIME WRITTEN
	SETZM TT0+10(S)			;Clear unused word in UFD
	SETZM TT0+11(S)			;Clear unused word in UFD
	OUTSTR	[ASCIZ/Ok. We're going to fill a hole in this UFD.
/]
	RPRINT	TTRACK
	PUSHJ	P,DDTCALL
	TWRITE	(Z)			;rewrite track.
	POPJ	P,

UFDRB9:	MOVE	K,NFT			;Track number within group
	CAIGE	K,TRKGRP-1		;End of group?
	JRST	UFDRB8			;Not yet.
	OUTSTR	[ASCIZ/End of the Group and there's no hole in this UFD.  Now what?
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

;Here if UFD has no holes we can use for this floating file.
;UFD group isn't full, so we will try to extend UFD to another track on the
;dead pack, provided the whole UFD so far is on the dead pack (otherwise,
;we can't spread the new retrieval to good (write-locked) packs, and
;anyway we should have had enough retrieval length from the good tracks
;in the first case if the UFD exists outside of the dead pack).
UFDEXT:	SETOM	NFT			;Make sure all tracks are on dead pack.
UFDEX2:	AOS	K,NFT			;Advance to next track.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	Z,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	Z,TTRACK+DDRET(K)	;
	JUMPE	Z,UFDEX3		;all tracks are on dead pack
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	JRST	UFDRE1			;can't alter UFD if outside DEADP
	MOVE	K,NFT			;Track number within group
	CAIGE	K,TRKGRP-1		;End of group?
	JRST	UFDEX2			;Not yet.
	OUTSTR	[ASCIZ/End of the group and there's no hole in this UFD,
but it didn't happen on the first time around!!  Now what?
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

;OK, we've made sure all of this UFD's tracks are on the dead pack, and the
;group isn't full, so now we can extend the UFD to another track on dead pack.
UFDEX3:	PUSHJ	P,FRZGET		;Make Z point to free track on dead pack
	MOVE	K,NFT			;set still from above
	LSHC	K,-1			;Store this Track Address in RTVL
	TLNN	L,400000
	HRLM	Z,RTSAV+DDRET(K)
	TLNE	L,400000
	HRRM	Z,RTSAV+DDRET(K)
	MOVE	A,NFT
	ADDI	A,1
	IMULI	A,DWDTRK
	MOVEM	A,RTSAV+DDLNG		;update length in rtvl.
	OUTSTR	[ASCIZ/I'm about to extend a UFD on the dead pack to another track.
Here is what I'm think it should look like (I'll spread to all tracks).
/]
	RPRINT	RTSAV
	PUSHJ	P,DDTCALL
	PUSH	P,Z			;Save address of new track for later
;GSPRED routine will BLT from RTSAV to TTRACK before spreading rtvl.
	PUSHJ	P,GSPRED		;Spread new rtvl to whole UFD group
	POP	P,Z			;Z:=address of last track in ufd
	JRST	UFDEXR			;Now go use a hole from new track

FRZGET:	MOVE	Z,[-NTPP,,NTPP*DEADP]	;scan dead pack from the front.
FRZGT3:	RREAD	(Z)
	SKIPN	TTRACK+DSATID
	POPJ	P,			;found a free track.
	AOBJN	Z,FRZGT3
	JRST	FRXGT4			;Pack has all filled up!!!??

UFDRE1:	OUTSTR	[ASCIZ/There's no hole I can use for this UFD and I can't
extend the UFD because part of it is outside the dead pack.  I give up.
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

UFDRE2:	OUTSTR	[ASCIZ/This empty UFD isn't located on
a track where I can write.  Now what?
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

;We have a track on the DEAD pack.  It's allocated to a UFD.
;Find a hole there in this track, for a file's UFD entry to go into.
FNDHOL:	MOVE	S,UFDLEN		;actual length of UFD
	MOVE	A,NFT			;number of prior tracks
	IMULI	A,DWDTRK		;number of data words on prior tracks
	SUB	S,A			;number of words left here and beyond
	CAILE	S,DWDTRK		;more than whole track left?
	MOVEI	S,DWDTRK		;yes, reduce to just this track.
	JUMPLE	S,FNDHOE		;if none left, an error.
	MOVN	S,S
	HRLZ	S,S			;-wc of this track
FNDHO1:	SKIPN	TT0(S)			;look for a hole
	JRST	CPOPJ1			;found one.
	ADD	S,[UFDN,,UFDN]
	JUMPL	S,FNDHO1		;loop looking for a hole.
;no hole.  Is this track maximally full?
	MOVE	S,UFDLEN		;actual length of UFD
	MOVE	A,NFT			;number of prior tracks
	IMULI	A,DWDTRK		;number of data words on prior tracks
	SUB	S,A			;number of words left here and beyond
	CAIL	S,DWDTRK		;is there less than a whole track used?
	POPJ	P,			;this track is full.
	SKIPE	NFT			;is this the first (only) trk of UFD?
	JRST	FNDHE1			;no.  Confusion.
	OUTSTR	[ASCIZ/Will augment the length of this UFD to one whole track
/]
	MOVEI	A,DWDTRK
	MOVEM	A,UFDLEN
	MOVEM	A,TTRACK+DDLNG		;new length will be written w/new data
	JRST	FNDHOL			;a hole will be found, all will be
					;made right.

FNDHE1:	OUTSTR	[ASCIZ/I want to extend a UFD, but I don't know how
because parts of it may be allocated outside of the dead pack.
/]
	PUSHJ	P,DDTCALL
	POPJ	P,

FNDHOE:	OUTSTR	[ASCIZ/Word count of UFD is inconsistent with track count.
WC is too small for the number of tracks actually allocated.
Needs manual intervention.
/]
	PUSHJ	P,DDTCALL
	POPJ	P,			;no hole return from FNDHOL

;UFDSHL build the list of UFDs that are partly destroyed, i.e., which
;have space allocated on DEADP

UFDSHL:	SETZM	UFSHLC			;none yet.
	MOVE	Z,MFDPTR		;Get pointer to the MFD
UFSHL1:	SKIPN	A,(Z)			;get UFD name from MFD
	JRST	UFSHL2			;no name.
	HLLZ	B,1(Z)			;get extension
	CAME	B,['UFD   ']		;match ext
	JRST	UFSHL2			;no.
	MOVE	R,3(Z)			;disk address of this UFD
	RREAD	(R)			;read ufd rtvl.
	SETOM	NFT
UFSHL3:	AOS	K,NFT			;Advance to next track.
	LSHC	K,-1			;FIND NEXT TRACK ADDRESS
	TLNN	L,400000
	HLRZ	A,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	A,TTRACK+DDRET(K)	;
	JUMPE	A,UFSHL2		;Nothing here of interest.
	CAIL	A,NTPP*DEADP
	CAIL	A,NTPP*(DEADP+1)
	JRST	UFSHL4			;not of interest. get next track
;this UFD was partly wiped out...
	AOS	A,UFSHLC
	CAILE	A,UFLSTL
	JRST	UFSHL6			;why think.  Make it bigger.
	MOVE	B,(Z)			;name of this damaged UFD
	MOVEM	B,UFDEAD-1(A)		;save in the list.
	JRST	UFSHL2			;now look at next ufd

UFSHL4:	MOVE	K,NFT			;Track number within group
	CAIGE	K,TRKGRP-1		;End of group?
	JRST	UFSHL3			;Not yet.
UFSHL2:	ADD	Z,[XWD UFDN,UFDN]	;advance to next file name in MFD
	JUMPL	Z,UFSHL1		;jump unless exhausted.
	POPJ	P,

UFSHL6:	OUTSTR	[ASCIZ/Edit the program to make UFLSTL larger and recompile.
/]
	JRST	DDTCALL

UFLSTL==2000
UFSHLC:	0				;count of entries in list below
UFDEAD:	BLOCK	UFLSTL
;Undo.rtvl.extend     UNRETR UNRET1 UNRET2 UNRET8 UNRET3 UNRET4

Comment $

Undo.rtvl.extend:

FREXTD was executed too early in the reconstruction
phase.  We had forgotten to rerun the code to extend retrieval
from the UFDs that were reconnected in FRSPRD.  So we had to
undo this.

Read tracks from dead pack (DEADP).  Check to see if their entire
group retrieval is allocated on DEADP.   If so, that file was allocated
by FREXTD, and must be deallocated now.  [It's a good thing that the
first version of FREXTD didn't allocate multi-group files.  As it
is, we can assume that DNXTGP is correct].

Method.  Read rtvl of each track from the dead pack.  If all of the
tracks in the group of the file are allocated on DEADP then we
will rewrite this retrieval as follows:
	If this file is [SWAP].SYS[1,4] don't touch it.
	if this track is the first track in the group, rewrite the 
		retrieval to show this as the only track in the group.
	if this track is not the first track of the group, write blank
		retrieval here.

;NOTE: FREXTD has beed CHANGED to work for MULTI-GROUP FILES, but UNRETR
;Has NOT BEEN UPDATED to unextend multi-group files.

$

UNRETR:	OUTSTR	[ASCIZ/Undo file retrieval extension
/]
	MOVE	R,[-NTPP,,NTPP*DEADP]	;scan dead pack
UNRET1:	PUSHJ	P,UNRET2		;read a track
	AOBJN	R,UNRET1
	OUTSTR	[ASCIZ/UNRETR done
/]
	JRST	DDTCALL

UNRET2:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	MOVE	A,TTRACK+DDNAM
	MOVE	B,TTRACK+DDPPN
	CAMN	A,['[SWAP]']		;don't touch swap.sys area
	CAME	B,['  1  4']
	SKIPA
	POPJ	P,
	MOVE	A,[TTRACK,,RTSAV]
	BLT	A,RTSAV+WDRTVL-1	;save rtvl

	SETOM	NFT
UNRET8:	AOS	K,NFT			;Advance to next track.
	LSHC	K,-1			;Find next track address
	TLNN	L,400000
	HLRZ	Z,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	Z,TTRACK+DDRET(K)	;
	JUMPE	Z,UNRET3		;none left.
	CAIL	Z,NTPP*DEADP
	CAIL	Z,NTPP*(DEADP+1)
	POPJ	P,			;Not on DEADP, not an interesting file
	MOVE	K,NFT			;Track number within group
	CAIGE	K,TRKGRP-1		;End of group?
	JRST	UNRET8			;Not yet.
UNRET3:	HRRZ	A,R			;end of group or end of rtvl.
	HLRZ	B,TTRACK+DDRET		;first track of this group
	CAME	A,B			;is this the first in a group?
	JRST	UNRET4			;no.  this track is blanked.
	MOVE	B,NFT			;first in group.  Is it ONLY one?
	CAIG	B,1
	POPJ	P,			;Only one track in group. Easy.
	SETZM	TTRACK+DDRET		;first in group.  Zero all rtvl
	MOVE	B,[TTRACK+DDRET,,TTRACK+DDRET+1]
	BLT	B,TTRACK+WDRTVL-1
	HRLZM	R,TTRACK+DDRET		;first track points to itself.
	OUTSTR	[ASCIZ/Shortening rtvl for first track of group.
/]
	RPRINT	RTSAV
	PUSHJ	P,DDTCALL
	RWRITE	(R)
	POPJ	P,

UNRET4:	SETZM	TTRACK
	MOVE	A,[TTRACK,,TTRACK+1]
	BLT	A,TTRACK+WDRTVL
	OUTSTR	[ASCIZ/Blanking rtvl for subsequent track of a group.
/]
	RPRINT	RTSAV
	PUSHJ	P,DDTCALL
	RWRITE	(R)
	POPJ	P,
;Catalog.Dead.Files CCDEF CCLNK CCNAM CCEXT CCPRO CCPPN CCLNG CCREF CCDMP CCJOB CCAUT CCLEN CATGUT CATEND COMPXX DEDCAT DEDCT1 DEDCT2 DEDCT3 DEDCT4 DEDCT5 CATWRT CATWR1 CATPNT PDMPNV PDMINV PDMPTM DECBFL DECBF1 DECBF2 LITSRT LITSR1 LITSR2 LITSR3 LITSR4 NAMCMP TAPCMP LADJ NOENT

Comment $
Catalog.Dead.Files:

Read tracks on dead pack.   If not already present, record the file
name of this track's file in the catalog.  BIG catalog.

$

;Catalog Data structure
CCDEF::	PHASE	0
CCLNK::	0			;Link to next entry  (MUST BE FIRST THING!)
CCNAM::	0			;NAME
CCEXT::	0			;EXT,,HIDATE-1 DATE-2
CCPRO:: 0			;PRO,MODE,TIME,LODATE-1
CCPPN:: 0			;PPN
CCLNG:: 0			;POSITIVE LENGTH OF THIS FILE, IN WORDS.
CCREF:: 0			;REFERENCE DATE
CCDMP:: 0			;DUMP DATE, TAPE NUMBER, ETC.
CCJOB:: 0			;Jobname of JOB that wrote file
CCAUT:: 0			;PPN of writer of file
CCSMA::	0			;zero if totally smashed, -1 if partly sm.
CCLEN==.
	DEPHASE
	ORG	CCDEF

LPTFF:	0			;location for DSK buffers for 'LPT'
CATGUT:	0			;pointer to first entry 
CATEND:	0			;end of mem allocated to catalog
COMPXX:	0			;store sorting comparison subr call here.

DEDCAT:	OUTSTR	[ASCIZ/Catalog of dead files.

(Files that were on DEADP prior to DECEMBER 25, 1980.)

Outputs will be:
	CATLOG.BIN		Binary file. Unsorted
	CATLOG.NAM		Text of smashed files, name sort
	CATLOG.TAP		Text of smashed files, tape order
	CATLOG.DRT		Binary file for DART MRESTORE (Dart format)
	NODUMP.LOG		Binary of files never dumped 4 word entries
	UFD.LOG			Binary of each smashed UFD name 1 word each

Assign logical name LPT before continuing.   (e.g., ASSIGN UDP1 LPT)

/]
	EXIT	1,

	MOVE	A,JOBFF
	MOVEM	A,LPTFF
	MOVE	A,['CATLOG']
	MOVSI	B,'BIN'
	PUSHJ	P,LPTBIN

	MOVE	A,JOBFF
	MOVEM	A,CATEND		;pointer to catalog
	SETZM	CATGUT			;no entries yet in the catalog
	MOVE	R,[-NTPP,,NTPP*DEADP]	;scan dead pack
DEDCT1:	PUSHJ	P,DEDCT2		;read a track
	AOBJN	R,DEDCT1
	CLOSE	LPT,
	RELEAS	LPT,


	MOVE	A,LPTFF
	MOVEM	A,JOBFF			;next mem space for buffers
	OUTSTR	[ASCIZ/Catalog in name sort order....
/]
	PUSHJ	P,PHSL			;Initialize output channel
	MOVE	A,['CATLOG']
	MOVSI	B,'NAM'
	SETZB	C,D
	ENTER	LPT,A
	 JRST	NOENT
	MOVE	A,[PUSHJ P,NAMCMP]
	MOVEM	A,COMPXX		;compare instr for sort
	MOVE	X,CATGUT
	PUSHJ	P,LITSRT
	MOVEM	X,CATGUT
	PUSHJ	P,CATWRT		;write sorted catalog (name sort)
	CLOSE	LPT,
	RELEAS	LPT,
	SETZM	LPTFLG

	OUTSTR	[ASCIZ/Catalog of smashed UFDs (as a binary file).  UFD.LOG
/]
	MOVSI	A,'UFD'
	MOVSI	B,'LOG'
	PUSHJ	P,LPTBIN		;setup LPT in binary mode
	PUSHJ	P,UFCWRT		;write for DART
	CLOSE	LPT,
	RELEAS	LPT,

	OUTSTR	[ASCIZ/Catalog of undumped files (as a binary file). NODUMP.LOG
/]
	MOVE	A,['NODUMP']
	MOVSI	B,'LOG'
	PUSHJ	P,LPTBIN		;setup LPT in binary mode
	PUSHJ	P,NDPWRT		;write 
	CLOSE	LPT,
	RELEAS	LPT,


	MOVE	A,LPTFF
	MOVEM	A,JOBFF			;next mem space for buffers
	OUTSTR	[ASCIZ/Catalog in tape sort order....
/]
	PUSHJ	P,PHSL			;Initialize output channel
	MOVE	A,['CATLOG']
	MOVSI	B,'TAP'
	SETZB	C,D
	ENTER	LPT,A
	 JRST	NOENT
	MOVE	A,[PUSHJ P,TAPCMP]
	MOVEM	A,COMPXX		;compare instr for sort
	MOVE	X,CATGUT
	PUSHJ	P,LITSRT
	MOVEM	X,CATGUT
	PUSHJ	P,CATWRT		;write sorted catalog (tape sort)
	RELEAS	LPT,
	SETZM	LPTFLG

	OUTSTR	[ASCIZ/Catalog for DART (as a binary file).  CATLOG.DRT
/]
	MOVE	A,['CATLOG']
	MOVSI	B,'DRT'
	PUSHJ	P,LPTBIN		;setup LPT in binary mode
	PUSHJ	P,DRTWRT		;write for DART
	CLOSE	LPT,
	RELEAS	LPT,


	OUTSTR	[ASCIZ/Catalog done
/]
	JRST	DDTCALL


LPTBIN:	PUSH	P,LPTFF
	POP	P,JOBFF			;next mem space for buffers
	INIT	LPT,10
	'DSK   '
	XWD 	LPTBF,0
	JRST	NOLPT
	OUTBUF	LPT,3
	SETZB	C,D
	ENTER	LPT,A
	JRST	NOENT
	POPJ	P,

DEDCT2:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	LDB	A,[POINT 12,TTRACK+DDPRO,35]
	LDB	B,[POINT 3,TTRACK+DDEXT,20]
	DPB	B,[POINT 3,A,23]
	CAILE	A,<<<=1980-=1964>*=12>+=11>*=31+=24>	;12/25/80
	POPJ	P,			;newer than a smashed file
	MOVEI	B,CATGUT-CCLNK		;pointer to start of catalog
DEDCT3:	SKIPN	B,CCLNK(B)
	JRST	DEDCT4			;no.  Add entry to catalog
	MOVE	A,TTRACK+DDNAM
	CAME	A,CCNAM(B)		;Is this entry already in catalog
	JRST	DEDCT3			;Not here, keep looking
	HLLZ	A,TTRACK+DDEXT
	HLLZ	C,CCEXT(B)		;Check extension
	CAME	A,C
	JRST	DEDCT3
	MOVE	A,TTRACK+DDPPN
	CAME	A,CCPPN(B)		;and PPN
	JRST	DEDCT3
	POPJ	P,			;already in catalog

DEDCT4:	MOVE	B,CATEND		;pointer to free space.
	MOVEI	A,CCLEN			;make space for more
	ADDB	A,CATEND
	CAMGE	A,JOBREL
	JRST	DEDCT5
	CORE	A,
	JRST	NOCORE
DEDCT5:	MOVE	A,CATGUT
	MOVEM	A,CCLNK(B)		;store this at front of list
	MOVEM	B,CATGUT
	MOVE	A,TTRACK+DDNAM
	MOVEM	A,CCNAM(B)
	MOVE	A,TTRACK+DDEXT
	MOVEM	A,CCEXT(B)
	MOVE	A,TTRACK+DDPRO
	MOVEM	A,CCPRO(B)
	MOVE	A,TTRACK+DDPPN
	MOVEM	A,CCPPN(B)
	MOVE	A,TTRACK+DDLNG
	MOVEM	A,CCLNG(B)
	MOVE	A,TTRACK+DREFTM
	MOVEM	A,CCREF(B)
	MOVE	A,TTRACK+DDMPTM
	MOVEM	A,CCDMP(B)
	MOVE	A,TTRACK+DQINFO+2	;JOBNAM
	MOVEM	A,CCJOB(B)
	MOVE	A,TTRACK+DQINFO+3	;Author's PPN
	MOVEM	A,CCAUT(B)
	SETZM	CCSMA(B)		;assume total smashup
	PUSHJ	P,SETSMA
	 SETOM	CCSMA(B)		;not total
	HRLI	B,-CCLEN		;form aobjn pointer
	ADD	B,[1,,1]		;skip link entry
BINWRT:	MOVE	A,(B)
	PUSHJ	P,LPTPUT
	AOBJN	B,BINWRT
	POPJ	P,

SETSMA:	MOVE	A,TTRACK+DDLOC
	HLRZ	C,TTRACK+DDRET
	CAME	A,C
SETSM1:	RREAD	(A)
	PUSHJ	P,SETSM2		;is any of group outside deadp?
	 POPJ	P,			;yes.  not totally dead
	SKIPE	A,TTRACK+DNXTGP		;Any next group?
	JRST	SETSM1			;yes.  look there too.
	JRST	CPOPJ1			;no.  TOTALLY Smashed.

SETSM2:	MOVEI	A,TRKGRP
	MOVE	D,[POINT 18,TTRACK+DDRET]
SETSM3:	ILDB	C,D
	JUMPE	C,CPOPJ1
	CAIL	C,NTPP*DEADP
	CAIL	C,NTPP*(DEADP+1)
	POPJ	P,			;Outside dead part
	SOJG	A,SETSM3
	JRST	CPOPJ1



DRTWRT:	MOVEI	C,CATGUT-CCLNK		;pointer to start of catalog
DRTWR1:	SKIPN	C,CCLNK(C)		;advance to next item in list
	POPJ	P,			;end of list
	SKIPE	B,CCDMP(C)		;skip if no dump date
	TLNE	B,20000			;skip unless date invalid
	JRST	DRTWR1			;ignore this entry
;for mysterious reasons, the format we write is
;PPN
;Filename
;EXT,,TAPE
;0
;Where TAPE is the dart tape number, plus 400000 if temporary.
	MOVE	A,CCPPN(C)
	PUSHJ	P,LPTPUT
	MOVE	A,CCNAM(C)
	PUSHJ	P,LPTPUT
	LDB	A,[POINT 12,B,20]	;tape number
	SKIPG	B
	TRO	A,400000		;set temporary tape number
	HLL	A,CCEXT(C)
	PUSHJ	P,LPTPUT
	MOVEI	A,0
	PUSHJ	P,LPTPUT
	JRST	DRTWR1

UFCWRT:	MOVEI	C,CATGUT-CCLNK		;pointer to start of catalog
UFCWR1:	SKIPN	C,CCLNK(C)		;advance to next item in list
	POPJ	P,			;end of list
	MOVE	A,CCPPN(C)		;get the PPN
	HLLZ	B,CCEXT(C)
	CAMN	B,['UFD   ']
	CAME	A,['  1  1']		;skip if it's a UFD
	JRST	UFCWR1			;ignore this entry
	MOVE	A,CCNAM(C)		;Write UFD name in file
	PUSHJ	P,LPTPUT
	JRST	UFCWR1


NDPWRT:	MOVEI	C,CATGUT-CCLNK		;pointer to start of catalog
NDPWR1:	SKIPN	C,CCLNK(C)		;advance to next item in list
	POPJ	P,			;end of list
	MOVE	A,CCPPN(C)		;get the PPN
	CAME	A,['  1  1']		;skip if it's a UFD
	CAMN	A,['  1  4']		;skip if it's not swapping space
	JRST	NDPWR1			;ignore this entry
	SKIPE	B,CCDMP(C)		;skip if no dump date
	TLNE	B,20000			;skip unless date invalid
	SKIPA				;not dumped.  Write this one
	JRST	NDPWR1
	MOVE	A,CCNAM(C)		;Write full file name to file
	PUSHJ	P,LPTPUT
	MOVE	A,CCEXT(C)
	PUSHJ	P,LPTPUT
	MOVE	A,CCPRO(C)		;Write full file name to file
	PUSHJ	P,LPTPUT
	MOVE	A,CCPPN(C)
	PUSHJ	P,LPTPUT
	JRST	NDPWR1



CATWRT:	MOVEI	C,CATGUT-CCLNK		;pointer to start of catalog
CATWR1:	SKIPN	C,CCLNK(C)		;advance to next item in list
	POPJ	P,			;end of list
	PUSHJ	P,CATPNT		;print this item
	JRST	CATWR1

CATPNT:	MOVE	W,CCNAM(C)		;File Name
	PUSHJ	P,SIXOT1		;Type it
	PUTSTR	[ASCIZ/./]
	HLLZ	X,CCEXT(C)		;File Extension
	MOVEI	Z,3			;Precisely 3 Characters
	PUSHJ	P,SIXOT2		;Type it
	MOVE	W,CCPPN(C)		;Get the PPN
	PUSHJ	P,TYPPN1		;Type it
	PUTSTR	[ASCIZ/ /]
	LDB	W,[POINT 11,CCPRO(C),23]
	PUSHJ	P,TTIME1		;Type Time in minutes
	PUTSTR	[ASCIZ/ /]
	LDB	W,[POINT 12,CCPRO(C),35]
	LDB	X,[POINT 3,CCEXT(C),20]	;LOAD HIGH DATE - DATE75
	DPB	X,[POINT 3,W,23]	;STUFF HIGH DATE - DATE75
	PUSHJ	P,TDATE1		;TYPE DATE
	MOVE	W,CCLNG(C)		;GET THE LENGTH
	MOVEI	Z,11
	PUSHJ	P,DECBFL		;decimal w/leading blank fill
	PUTSTR	[ASCIZ/  /]
	MOVE	W,CCJOB(C)		;jobname of author
	PUSHJ	P,SIXOT1
	PUTSTR	[ASCIZ/ /]
	MOVE	W,CCAUT(C)		;ppn of author
	PUSHJ	P,SIXOT1
	PUTSTR	[ASCIZ/ /]
	MOVE	W,CCDMP(C)		;Dump word
	PUSHJ	P,PDMPTM		
	SKIPE	CCSMA(C)
	PUTSTR	[ASCIZ/  Partial Loss/]
	SKIPN	CCSMA(C)
	PUTSTR	[ASCIZ/  Total Loss  /]
	PUTSTR	CRLF
	POPJ	P,

PDMPNV:	PUTSTR	[ASCIZ/ Never  /]
	POPJ	P,

PDMINV:	PUTSTR	[ASCIZ/ Invalid/]
	POPJ	P,

PDMPTM:	JUMPE	W,PDMPNV		;never dumped.
	TLNE	W,20000			;bit 4 Dump date invalid
	JRST	PDMINV
	PUSH	P,W
	SKIPGE	W
	PUTSTR	[ASCIZ/   T/]
	SKIPL	W
	PUTSTR	[ASCIZ/ P/]
	LDB	W,[POINT 12,W,20]	;the dump tape number
	MOVEI	Z,0
	MOVEI	Y,12
	PUSHJ	P,ALLRAD
	POP	P,W
	POPJ	P,

DECBFL:	IDIVI	W,12
	HRLM	X,(P)
	SUBI	Z,1		;DECREMENT Z
	JUMPE	W,DECBF1
	PUSHJ	P,DECBFL
DECBF1:	JUMPLE	Z,DECBF2
	PUTSTR	[ASCIZ/ /]
	SOJG	Z,.-1
DECBF2:	HLRZ	W,(P)
	ADDI	W,"0"
	PUTCHR	W
	POPJ	P,

;SORT a list.  RECURSIVE.  LIST HEADER IN X.  RETURNS SORTED LIST IN X.

LITSRT:	JUMPE	X,CPOPJ			;NO WORK FOR NO LIST
	SKIPN	W,CCLNK(X)		;GET LINK TO NEXT
	POPJ	P,			;JUMP IF NO NEXT. 1-ELEMENT LIST IS SORTED.
	MOVE	Y,W			;TAIL OF THE W LIST
	MOVE	Z,X			;TAIL OF THE X LIST
LITSR1:	MOVE	A,CCLNK(Y)		;GET LINK-OUT OF W LIST
	MOVEM	A,CCLNK(Z)		;STORE AS LINK-OUT IN X LIST
	SKIPN	Z,A			;ADVANCE X-TAIL
	JRST	LITSR2			;NO NEXT
	MOVE	A,CCLNK(Z)		;GET LINK-OUT OF X-LIST
	MOVEM	A,CCLNK(Y)		;STORE AS LINK-OUT OF W-LIST
	SKIPE	Y,A			;ADVANCE W-TAIL
	JRST	LITSR1			;MAKE LISTS OF ALTERNATE ELEMENTS.
LITSR2:	PUSH	P,W			;SAVE W-LIST
	PUSHJ	P,LITSRT		;SORT THE X-LIST (RECUR UNTIL DONE)
	EXCH	X,(P)			;EXCH SORTED X-LIST WITH W-LIST
	PUSHJ	P,LITSRT		;AND SORT W-LIST
	POP	P,W			;(X AND W ARE INTERCHANGED, BUT WHO CARES)
;W AND X NOW (ASSUME) POINT TO SORTED LISTS.  MERGE THEM INTO ONE LIST.
	MOVEI	Z,Y-CCLNK		;MERGE LIST HEAD IN Z
LITSR3:	XCT	COMPXX			;COMPARE.CAR(W) & CAR(X).  Skip if X small
	 EXCH	X,W			;X Larger. EXCH THEM
	MOVEM	X,CCLNK(Z)		;X<W. ADD CAR(X) TO OUT-LIST
	MOVE	Z,X			;ADVANCE END OF OUT-LIST.
	SKIPE	X,CCLNK(X)		;FORM CDR(NA)
	JRST	LITSR3			;CONTINUE THE MERGE
LITSR4:	MOVEM	W,CCLNK(Z)		;STORE OTHER LIST IN THE OUT-LIST
	MOVE	X,Y			;GET THE ADDRESS OF THE LIST-HEAD
	POPJ	P,			;RETURN, POINTER TO SORTED LIST IN NA


;X and W are pointers to catalog cards.  Skip if X is smaller than W
NAMCMP:	HRLZ	C,CCPPN(X)		;Prog name to LH of C
	PUSHJ	P,LADJ
	MOVE	A,C			;Leftjust Progname to LH of A
	HLLZ	C,CCPPN(X)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	A,C			;leftjust Proj to RH of A
	TLC	A,400000		;Force unsigned comparison below

	HRLZ	C,CCPPN(W)		;Prog name to LH of C
	PUSHJ	P,LADJ
	MOVE	B,C			;Leftjust Progname to LH of B
	HLLZ	C,CCPPN(W)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	B,C			;leftjust Proj to RH of B
	TLC	B,400000
;A has "PPN" from X, B from W.
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
	TLC	A,400000		;unadjust
	CAME	A,['1  1  ']		;[1,1] in adjusted form
	JRST	NAMCM1			;not a UFD name.
	HRLZ	C,CCNAM(X)		;UFDs are special
	PUSHJ	P,LADJ			;Prog name to LH of C
	MOVE	A,C			;Leftjust Progname to LH of A
	HLLZ	C,CCNAM(X)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	A,C			;leftjust Proj to RH of A
	TLC	A,400000		;Force unsigned comparison below

	HRLZ	C,CCNAM(W)		;Prog name to LH of C
	PUSHJ	P,LADJ
	MOVE	B,C			;Leftjust Progname to LH of B
	HLLZ	C,CCNAM(W)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	B,C			;leftjust Proj to RH of B
	TLC	B,400000
;A has "PPN" from X, B from W.
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
	JRST	NAMCM2			;not supposed to happen...

NAMCM1:	MOVE	A,CCNAM(X)
	MOVE	B,CCNAM(W)
	TLC	A,400000		;again, unsigned compare
	TLC	B,400000
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
NAMCM2:	HLRZ	A,CCEXT(X)
	HLRZ	B,CCEXT(W)
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	POPJ	P,			;W is smaller than X (or equal???)

;X and W are pointers to catalog cards.  Skip if X is smaller than W
TAPCMP:	LDB	A,[POINT 12,CCDMP(X),20]	;the dump tape number
	SKIPGE	CCDMP(X)
	TLO	A,1
	MOVE	C,CCDMP(X)
	TLNE	C,20000				;dump invalid?
	MOVEI	A,0				;yes. set tape to zero
	LDB	B,[POINT 12,CCDMP(W),20]	;the dump tape number
	SKIPGE	CCDMP(W)
	TLO	B,1
	MOVE	C,CCDMP(W)
	TLNE	C,20000				;dump invalid?
	MOVEI	B,0				;yes. set tape to zero
	CAMN	A,B
	JRST	NAMCMP				;compare by name if tapes =
	CAMG	A,B
	AOS	(P)
	POPJ	P,

LADJ:	TLNE	C,770000		;is it left adjusted yet?
	POPJ	P,			;yes
	LSH	C,6			;no. shove it some
	JUMPN	C,LADJ			;loop.
	POPJ	P,			;don't get stuck all day with zero

NOENT:	OUTSTR	[ASCIZ/ENTER FAILED.  I GIVE UP
/]
	HALT	DDTCALL
;List.UNFIXED.Files CATGON CATOK UNFIXF UNFIX1 UFXFL UFXFL1 UNFIX2 UNFIX3 ADDOK FNDOK FNDFL2 FNDGON FNDFL1 FIXPNT

Comment $
List.UNFIXED.Files:

Read tracks on dead pack.  If it has a valid SATID and all the data is zero,
record this file name in the catalog

$

CATGON:	0
CATOK:	0

UNFIXF:	OUTSTR	[ASCIZ/Catalog of Unfixed files.

Files that were on DEADP prior to DECEMBER 25, 1980. and which now
have zero data in those data tracks that are allocated on DEADP.

Outputs will be:

	UNFIXF.LOG		Text of unrepaired files.

/]
	PUSHJ	P,PHSL			;Initialize output channel
	MOVE	A,['UNFIXF']
	MOVSI	B,'LOG'
	SETZB	C,D
	ENTER	LPT,A
	 JRST	NOENT

	MOVE	A,JOBFF
	MOVEM	A,CATEND		;pointer to catalog
	SETZM	CATGON			;no entries yet in the catalog
	SETZM	CATOK			;none in the ok list either.
	MOVE	R,[-NTPP,,NTPP*DEADP]	;scan dead pack
UNFIX1:	PUSHJ	P,UNFIX2		;read a track
	AOBJN	R,UNFIX1

	MOVE	A,[PUSHJ P,NAMCMP]
	MOVEM	A,COMPXX		;compare instr for sort
	MOVE	X,CATGON
	PUSHJ	P,LITSRT
	MOVEM	X,CATGON
	MOVEI	C,CATGON-CCLNK		;pointer to start of catalog
UFXFL:	SKIPN	C,CCLNK(C)
	JRST	UFXFL1
	PUSHJ	P,FIXPNT
	JRST	UFXFL

UFXFL1:	SETZM	LPTFLG
	CLOSE	LPT,
	RELEAS	LPT,

	OUTSTR	[ASCIZ/Catalog of UNFIXED files has been written.
/]
	JRST	DDTCALL


UNFIX2:	RREAD	(R)			;read retrieval
	SKIPE	A,TTRACK+DSATID
	CAME	A,SATID
	POPJ	P,
	LDB	A,[POINT 12,TTRACK+DDPRO,35]
	LDB	B,[POINT 3,TTRACK+DDEXT,20]
	DPB	B,[POINT 3,A,23]
	CAILE	A,<<<=1980-=1964>*=12>+=11>*=31+=24>	;12/25/80
	POPJ	P,			;newer than a smashed file
	MOVE	A,TTRACK+DDNAM
	HLLZ	B,TTRACK+DDEXT
	MOVE	D,TTRACK+DDPPN
	PUSHJ	P,FNDGON		;is it in the GONE list?
	POPJ	P,			;Yes. too bad.
	PUSHJ	P,FNDOK			;in the ok list?
	POPJ	P,			;Yes.  good
	SETOM	NFT
UNFIX3:	AOS	K,NFT
	CAIL	K,TRKGRP
	JRST	ADDOK			;add to ok list?
	LSHC	K,-1
	TLNN	L,400000
	HLRZ	A,TTRACK+DDRET(K)
	TLNE	L,400000
	HRRZ	A,TTRACK+DDRET(K)
	JUMPE	A,ADDOK
	CAIL	A,NTPP*DEADP
	CAIL	A,NTPP*(DEADP+1)
	JRST	UNFIX3			;Not on DEADP.
	TREAD	(A)
	MOVSI	B,-DWDTRK
	SKIPE	TT0(B)
	JRST	ADDOK
	AOBJN	B,.-2
	SKIPA	W,[CATGON-CCLNK]
ADDOK:	MOVEI	W,CATOK-CCLNK
	MOVEI	A,CCLEN
	MOVE	B,CATEND
	ADDB	A,CATEND
	CAMGE	A,JOBREL
	 JRST	.+3
	CORE	A,
	 JRST	NOCORE
	MOVE	A,CCLNK(W)
	MOVEM	A,CCLNK(B)
	MOVEM	B,CCLNK(W)
	MOVE	A,TTRACK+DDNAM
	MOVEM	A,CCNAM(B)
	MOVE	A,TTRACK+DDEXT
	MOVEM	A,CCEXT(B)
	MOVE	A,TTRACK+DDPRO
	MOVEM	A,CCPRO(B)
	MOVE	A,TTRACK+DDPPN
	MOVEM	A,CCPPN(B)
	MOVE	A,TTRACK+DDLNG
	MOVEM	A,CCLNG(B)
	MOVE	A,TTRACK+DREFTM
	MOVEM	A,CCREF(B)
	MOVE	A,TTRACK+DDMPTM
	MOVEM	A,CCDMP(B)
	MOVE	A,TTRACK+DQINFO+2	;JOBNAM
	MOVEM	A,CCJOB(B)
	MOVE	A,TTRACK+DQINFO+3	;Author's PPN
	MOVEM	A,CCAUT(B)
	HLRZ	A,TTRACK+DDRET
	MOVEM	A,CCSMA(B)
	POPJ	P,


FNDOK:	SKIPA	W,[CATOK-CCLNK]
FNDFL2: SKIPN	W,CCLNK(W)
	JRST	CPOPJ1			;not present
	CAMN	D,CCPPN(W)
	CAME	A,CCNAM(W)		;Is this entry already in catalog
	JRST	FNDFL2			;Not here, keep looking
	HLLZ	C,CCEXT(W)		;Check extension
	CAME	B,C
	JRST	FNDFL2
	HLRZ	C,TTRACK+DDRET		;For OK files, only one group at at time.
	CAME	C,CCSMA(W)
	JRST	FNDFL2
	POPJ	P,			;Found it.



FNDGON:	MOVEI	W,CATGON-CCLNK		;pointer to start of catalog
FNDFL1:	SKIPN	W,CCLNK(W)
	JRST	CPOPJ1			;not present
	CAMN	D,CCPPN(W)
	CAME	A,CCNAM(W)		;Is this entry already in catalog
	JRST	FNDFL1			;Not here, keep looking
	HLLZ	C,CCEXT(W)		;Check extension
	CAME	B,C
	JRST	FNDFL1
	POPJ	P,			;Found it.

FIXPNT:	MOVE	W,CCNAM(C)		;File Name
	PUSHJ	P,SIXOT1		;Type it
	PUTSTR	[ASCIZ/./]
	HLLZ	X,CCEXT(C)		;File Extension
	MOVEI	Z,3			;Precisely 3 Characters
	PUSHJ	P,SIXOT2		;Type it
	MOVE	W,CCPPN(C)		;Get the PPN
	PUSHJ	P,TYPPN1		;Type it
	PUTSTR	[ASCIZ/ /]
	LDB	W,[POINT 11,CCPRO(C),23]
	PUSHJ	P,TTIME1		;Type Time in minutes
	PUTSTR	[ASCIZ/ /]
	LDB	W,[POINT 12,CCPRO(C),35]
	LDB	X,[POINT 3,CCEXT(C),20]	;LOAD HIGH DATE - DATE75
	DPB	X,[POINT 3,W,23]	;STUFF HIGH DATE - DATE75
	PUSHJ	P,TDATE1		;TYPE DATE
	MOVE	W,CCLNG(C)		;GET THE LENGTH
	MOVEI	Z,11
	PUSHJ	P,DECBFL		;decimal w/leading blank fill
	PUTSTR	[ASCIZ/  /]
	MOVE	W,CCJOB(C)		;jobname of author
	PUSHJ	P,SIXOT1
	PUTSTR	[ASCIZ/ /]
	MOVE	W,CCAUT(C)		;ppn of author
	PUSHJ	P,SIXOT1
	PUTSTR	[ASCIZ/ /]
	MOVE	W,CCDMP(C)		;Dump word
	PUSHJ	P,PDMPTM		
	PUTSTR	CRLF
	POPJ	P,
;NPCHK CHKALL CHKL1 CHKL2 CHKL3 CHKLU2 CHKLUZ GENDAT GENLUP CHKCHK CHKIT

;Routine to write whole pack with special pattern and then read all back,
;checking pattern.
NPCHK←←6	;Unit number of pack to destroy.
CHKCNT:	-NTPP,,0		;number of tracks to check

CHKAL0:	SKIPA R,[-NTPP/4,,0]	;small amount to check
CHKALL:	MOVSI R,-NTPP		;number of tracks to check
	MOVEM R,CHKCNT		;remember
;Start here with CHKCNT already set up.
CHKAL1:	OUTSTR [ASCIZ/This routine will destroy all the data on the
pack on UDP1.  That better be a real scratch pack!!!

If it really is, then type CONTINUE to go ahead./]
	EXIT 1,
	PUSH P,UDPOK
	PUSH P,UDPONL
	SETOM UDPOK		;We know we're working on UDP
	SETOM UDPONL		;No system disk transfers please!
	PUSHJ P,CHKIT
	 JRST CHKCHK		;Hmmm
	OUTSTR [ASCIZ/Are you really sure?  If so, type CONTINUE./]
	EXIT 1,
	PUSHJ P,CHKIT		;In case someone just changed packs!
	 JRST CHKCHK		;Maybe real UDP
	OUTSTR [ASCIZ/Writing patterns.../]
	MOVE R,CHKCNT		;Number of tracks to do
CHKL1:	MOVEI S,TTRACK
	PUSHJ P,GENDAT		;Generate data for this track in TTRACK
	TWRITE NPCHK*NTPP(R)	;Write a track with special pattern
	AOBJN R,CHKL1		;Loop writing whole pack
	OUTSTR [ASCIZ/Reading back and checking.../]
	MOVE R,CHKCNT
CHKL2:	TREAD NPCHK*NTPP(R)	;Read back a track
	MOVEI S,TTRK2
	PUSHJ P,GENDAT		;Generate data for this track in TTRK2
	MOVSI S,-WDTRK		;Now check whole track for pattern match
CHKL3:	MOVE A,TTRACK(S)
	CAME A,TTRK2(S)
	JRST CHKLUZ		;Comparison mismatch!!!
CHKLU2:	AOBJN S,CHKL3		;Next word
	AOBJN R,CHKL2		;Next track
	POP P,UDPONL
	POP P,UDPOK		;Restore normal flags
	OUTSTR [ASCIZ/All done.
/]
	JRST DDTCAL

CHKLUZ:	OUTSTR [ASCIZ/

Readback comparison failure!  Track number is in R, word offset in S.
See actual data at TTRACK(S) and correct data at TTRK2(S).  $P to continue.  /]
	PUSHJ P,DDTCAL
	JRST CHKLU2		;Resume checking

;Pattern is byte (12) word (18) track (6) word
GENDAT:	MOVEI A,0
	HRLI S,-WDTRK		;Make aobjn ptr to track
GENLUP:	DPB R,[POINT 18,(S),29]	;Stuff in track number
	DPB A,[POINT 12,(S),11]	;and word nbr
	DPB A,[POINT 6,(S),35]	;and low bits of word nbr a second time
	ADDI A,1
	AOBJN S,GENLUP
	POPJ P,

CHKCHK:	OUTSTR [ASCIZ/
This pack looks like a normal UDP, with UDP password!
You'll have to zero the password indication and try again.
/]
	JRST DDTCAL

CHKIT:	TREAD NPCHK*NTPP+NTPP-1 ;Read last track of pack, to make sure
	MOVE A,TTRACK
	MOVE B,TTRACK+1
	CAME A,['PASS  ']
	CAMN B,['PASS  ']
	POPJ P,
	JRST CPOPJ1

	END	BEGIN
