COMMENT ⊗   VALID 00021 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	ERRMSK XFCNAM VSDONE VNOTOK VBFBSY VPCBSY VRDRDY VOFFLN VSUPLO VVDBSY VTEST VDATRQ VPIENB VPIMSK
C00008 00003	XGPDSP VRNDSP
C00013 00004	Documentation of XGP MTAPE UUO
C00021 00005	XMTAPE XMTTAB XMTTLN XMTP0 XMTP7 XMTP1 XMTP2 XMTP3 XMTP3A XMTP4 XMTP6 XMTP10 XMTP11 VMTAPE VMTTAB VMTTLN VMTP4
C00029 00006	XERR1 XERR2 XERR3 XERR4 XERR5 XERR6 XERR7 XERR10 XERR11 XERR12 XERR13 XERR14 XERR15 XERR16 XERRC XERRCL XGPSET XSYNCX XGPCLR PSYNCX
C00035 00007	FCERRX XGPINI XGPIN1 XGPREL VRNINI VRNIN1 VRNRE2 VRNREL XGPOPN VRNOPN
C00041 00008	 XDMPHG XDMPO2 XDMPO XCSHOK XDMPO5 XDMPO8 XDMPO1 XDMPXT XDMPFC XGPSIW XGPSI2 XGPSI3 XGPSI9
C00049 00009	P2DINT P2DIOK P2DIN1 P2DIVE P2DINE
C00055 00010	XGPSTR XGSTR2 XGSTR4 VRNST1 XSIOS
C00060 00011	 SETXIO SETVIE SETXI1 SETVIO XIODSP XCIBEG XDI
C00065 00012	XCLSP XCLSO XOUT XOUT1 XOUT2 XOUT2A XOUT3 XOUT4 XOUT5 XBTLRR
C00075 00013	XGPIOW XGPIO0 XGPIO1
C00080 00014	XGPUUO XGPUU1 XPAUSE XGPUU2
C00086 00015	FCREQX FCREQ FCREQ1 FCWAIT FCWAT1 FCRQCK XWAKE XWAKE0 XWAKE1 FCWAKE
C00094 00016	FCLOCK FCKILL $FCKIL XBIDSP NFONT F.LOSE
C00101 00017	HUNG HUNG1 XGPP1 XGPP1D XGPP1C VHUNG VHUNG1
C00107 00018	Documentation of User Programming for the XGP
C00117 00019	Documentation of Character Mode for the XGP
C00132 00020	Documentation of internal structure for mode 0
C00146 00021	BEND XGPSER
C00147 ENDMK
C⊗;
;ERRMSK XFCNAM VSDONE VNOTOK VBFBSY VPCBSY VRDRDY VOFFLN VSUPLO VVDBSY VTEST VDATRQ VPIENB VPIMSK

IFN FTP2,<	;Whole file

BEGIN	XGPSER	↔SUBTTL	XGPSER	SERVICE ROUTINES FOR XEROX GRAPHICS PRINTER
;R. E. GORIN JANUARY, 1973


;I/O STATUS BITS
ERRMSK←←IOIMPM!IODTER!IODERR!IOBKTL	;ERROR BITS
XOVERL←←100				;OVERLAPPED MODE

XFCNAM←←'[-FC-]'			;FONT COMPILER NAME

;VRN INTERFACE CONO/CONI BITS
VSDONE←←100000		;(CONI) Scan complete
VNOTOK←←40000		;(CONI) System not ready		
VBFBSY←←20000		;(CONI) Buffer busy
VPCBSY←←10000		;(CONI) Paper controller busy
;VBTFRM←←4000		;(CONI) Bottom of form (unused)
;2000			;(CONI) Always zero
VRDRDY←←1000		;(CONI) Read ready
VOFFLN←←400		;(CONI) Not on-line (i.e., off-line)
VSUPLO←←200		;(CONI) Supplies low
VVDBSY←←100		;(CONI) Video busy
VTEST←←40		;(CONO) Test
VDATRQ←←20		;(CONI) Data request (cleared by any DATAO)
VPIENB←←10		;(CONI/CONO) Interrupt enable
VPIMSK←←7		;(CONI/CONO) PI channel

;XGPDSP VRNDSP

IFG XGPNUM,<
;XGP UUO DISPATCH TABLE.

	JRST XGPINI		;SYSTEM INITIALIZATION
	JRST HUNG		;HUNG TIME OUT
↑XGPDSP:JRST XGPREL		;RELEASE
	JRST XCLSO		;CLOSE OUTPUT
	JRST XOUT		;BUFFERED OUTPUT
	JRST ILLINP		;INPUT ILLEGAL
	JRST CPOPJ1		;ENTER
	JRST CPOPJ1		;LOOKUP
	JRST XDMPO		;DUMP MODE OUTPUT
	JRST ILLINP		;DUMP INPUT
	POPJ P,			;USETO
	POPJ P,			;USETI
	POPJ P,			;UGETF
	JRST CPOPJ1		;RENAME
	POPJ P,			;CLOSE INPUT
	POPJ P,			;UTPCLR
	JRST XMTAPE		;MTAPE
>;IFG XGPNUM


IFN FTVRN,<
;VRN UUO DISPATCH TABLE.

	JRST VRNINI		;SYSTEM INITIALIZATION
	JRST VHUNG		;HUNG TIME OUT
↑VRNDSP:JRST VRNREL		;RELEASE
	JRST XCLSO		;CLOSE OUTPUT
jrst uuoerr	;no buffered output yet
;;	JRST VOUT		;BUFFERED OUTPUT
	JRST ILLINP		;INPUT ILLEGAL
	JRST CPOPJ1		;ENTER
	JRST CPOPJ1		;LOOKUP
	JRST XDMPO		;DUMP MODE OUTPUT
	JRST ILLINP		;DUMP INPUT
	POPJ P,			;USETO
	POPJ P,			;USETI
	POPJ P,			;UGETF
	JRST CPOPJ1		;RENAME
	POPJ P,			;CLOSE INPUT
	POPJ P,			;UTPCLR
	JRST VMTAPE		;MTAPE

>;IFN FTVRN
;Documentation of XGP MTAPE UUO
COMMENT $

	MTAPE  CHAN,ADR
where CHAN is the channel number on which the  XGP has been opened is
interpreted as follows:
	ADR contains  the operation selector.  The  data at ADR+1 and
following depends on the operation selected.

Operation

0		Return error status.
		ADR+1/	major error code
		ADR+2,3,4/ error data

1		Font selection.
		ADR+1/ Font file name in sixbit
		ADR+2/ Font extension
		ADR+3/ PPN of font file
		ADR+4/ font identification number. (0 to FNTMAX-1)
		(This UUO will skip if there is no error).

		The font named will be read by  the font compiler. It
		will be  assigned the font identification number that
		you supply. The  identification number  is used  only
		by the Font selection operator.

2		Read Margins
		ADR+1/ Top of page margin
		ADR+2/ Page body size
		ADR+3/ Bottom of page margin.
		ADR+4/ Left margin
		ADR+5/ Right side margin
		ADR+6/ Minimum interline space

3		Set Margins
		ADR+1/ Top of page margin 		≤37777
		ADR+2/ Page body size			≤37777
		ADR+3/ Bottom of page margin.		≤37777
		ADR+4/ Left Margin			≤ 3777
		ADR+5/ Right side margin. 		Left ≤ Right ≤ 7777
		ADR+6/ Minimum interline space		≤ 3777

		If the bottom of page margin is set to 0 then the paper
		will not be cut.  If the page body size is set to 0 then
		the paper will be cut only when a form feed is encountered.
		The action of form feed in this case is to space down by the
		amount specified in the bottom of page margin and then cut.

4		Get status
		ADR+1/	XGPIOS is returned
		ADR+2/	-1 if I-level is running, else 0.
		ADR+3/  -1 if the XGP has OK status, else 0.

5		Pseudo Close. 
		Contents of the system buffer are transmitted to the XGP.
		XGP is not marked as CLOSEd, but another CLOSE is nearly
		a no-op.

6		Set Node Counts
		ADR+1/  The number of Text Nodes (currently =16)
		ADR+2/  The number of Vector Nodes (Currently =100)
		Zero in either parameter will use the default.

7		Font selection with partial compilation
		ADR+1/ Font file name in sixbit
		ADR+2/ Font extension
		ADR+3/ PPN of font file
		ADR+4/ font identification number. (0 to FNTMAX-1)
		ADR+5/ Compilation bits for ASCII 000 thru 037, from right to left.
		ADR+6/ Compilation bits for ASCII 040 thru 077, from right to left.
		ADR+7/ Compilation bits for ASCII 100 thru 137, from right to left.
		ADR+10/Compilation bits for ASCII 140 thru 177, from right to left.

		(This UUO will skip if there is no error).

		The font named will be read by  the font compiler. It
		will be  assigned the font identification number that
		you supply. The  identification number  is used  only
		by the Font selection operator.

		Only the characters whose bits are on in words ADR+5 through
		ADR+10 will be compiled.

10		Get and clear number of scanlines used for data.
		ADR+1/ Number of scanlines used is returned here.
		The number returned includes scanlines for top and bottom margins.
		The number is cleared after being read.
$
;XMTAPE XMTTAB XMTTLN XMTP0 XMTP7 XMTP1 XMTP2 XMTP3 XMTP3A XMTP4 XMTP6 XMTP10 XMTP11 VMTAPE VMTTAB VMTTLN VMTP4

IFG XGPNUM,<
XMTAPE:	XCTR XR,[SKIPL TAC,(UUO)] ;N.B. THIS ADDRESS CHECKS BEGINNING OF DATA
	CAIL TAC,XMTTLN
	POPJ P,
	SKIPG XMTTAB(TAC)	;SKIP UNLESS WE NEED A CLOSE FIRST.
	TDNN IOS,[DEVSBB,,IOACT] ;DEVICE MUST NOT BE ACTIVE.
	JRST @XMTTAB(TAC)	;DISPATCH
	PUSH P,UUO
	MOVEI UUO,0		;MAKE THE EFFECTIVE ADDRESS 0 FOR CLOSE.
	PUSHJ P,XCLSO		;FORCE A CLOSE FIRST
	POP P,UUO
	XCTR XR,[MOVE TAC,(UUO)] ;GET DISPATCH AGAIN  (CAN'T BE WRONG)
	JRST @XMTTAB(TAC)

XMTTAB:		XMTP0
	SETZ	XMTP1
		XMTP2
	SETZ	XMTP3
		XMTP4
		XCLSP		;FORCE DATA TRANSMISSION, PSEUDO CLOSE.
	SETZ	XMTP6		;SET NODE COUNTS
	SETZ	XMTP7		;COMPILE SELECTED CHARS IN FONT
		XMTP10		;GET NUMBER OF DATA SCANLINES USED
		XMTP11		;GET NUMBER OF FFS SEEN BY LINE COMPILER
XMTTLN←←.-XMTTAB

XMTP7:	SKIPA TAC,[4]		;FC OP CODE FOR COMPILE SELECTED CHARS
XMTP1:	MOVEI TAC,2		;FC OP CODE FOR COMPILE WHOLE FONT
	MOVEM TAC,XGPNST
	MOVSI TAC,1(UUO)	;RELATIVE FIRST LOC OF SOURCE
	HRRI TAC,XGPNST+1	;DESTINATION
	XCTR XBLTR,[BLT TAC,XGPNST+10] ;PASS 4 CHAR SELECTION WORDS TOO IN CASE
	PUSHJ P,FCREQ
	 POPJ P,		;LOSE ERROR CODE WILL BE SET ALREADY
	MOVE TAC,XGPOST		;GET OLD STATUS
	CAIE TAC,2		;EXPECTED REPLY IS YESSIR
	JRST FCERRX		;OOPS FC REPLIED WRONG.
	MOVE TAC,XGPOST+1	;GET RELATIVE ADDRESS OF FONT TABLE
	MOVE TAC1,XGPNST+4	;GET FONT NUMBER THAT WE TOLD THE FC.
	MOVEM TAC,XFTADR(TAC1)
	JRST CPOPJ1

XMTP2:	MOVEI TAC1,1(UUO)	;RELATIVE DESTINATION
	HRLI TAC1,XGPPS1	;SOURCE
	MOVEI TAC,5(TAC1)	;LAST WORD OF DESTINATION
	XCTR XBLTW,[BLT TAC1,(TAC)]
	POPJ P,

XMTP3:	MOVEI TAC1,0
XMTP3A:	XCTR XR,[MOVE TAC,1(UUO)]
	ANDI TAC,37777
	MOVEM TAC,XGPPS1(TAC1)
	ADDI UUO,1
	CAIGE TAC1,2
	AOJA TAC1,XMTP3A
	XCTR XR,[MOVE TAC,1(UUO)] ;LEFT MARGIN
	ANDI TAC,3777
	MOVEM TAC,XGPLMR
	XCTR XR,[MOVE TAC1,2(UUO)] ;RIGHT MARGIN
	AND TAC1,[400000,,7777]    ;SIGN BIT IS NO-WRAPAROUND FLAG
	CAIL TAC,(TAC1)		   ;RIGHT MARGIN BIGGER THAN LEFT MARGIN?
	HRRI TAC1,7777		   ;NO, USE MAX RIGHT MARGIN
	MOVEM TAC1,XGPRMR
	XCTR XR,[MOVE TAC,3(UUO)]
	ANDI TAC,3777
	MOVEM TAC,XGPILS
	POPJ P,

XMTP4:	MOVE IOS,XGPIOS
	XCTR XW,[MOVEM IOS,1(UUO)]
	MOVE TAC,XGPIGO
	XCTR XW,[MOVEM TAC,2(UUO)]
	HLLE TAC,XGPRDY		;LH IS READY FLAG -- DUPLICATE IN RH
	XCTR XW,[MOVEM TAC,3(UUO)]
	POPJ P,

XMTP6:	XCTR XR,[SKIPG TAC,1(UUO)] ;GET THE TEXT NODE COUNT
	MOVEI TAC,NTNODE
	MOVEM TAC,XNTNOD
	XCTR XR,[SKIPG TAC,2(UUO)]
	MOVEI TAC,NVNODE
	MOVEM TAC,XNVNOD
	POPJ P,

XMTP10:	SKIPA TAC,XSCTOT	;GET TOTAL SCANLINE COUNT
XMTP11:	MOVN TAC,XGPFFS		;GET POSITIVE NUMBER OF FFS OUTPUT BY CH 2
	XCTR XW,[MOVEM TAC,1(UUO)] ;TELL USER HOW MANY
	POPJ P,
>;IFG XGPNUM

XMTP0:	MOVEI TAC1,1(UUO)	;RELATIVE DESTINATION
	HRLI TAC1,XGPERC	;SOURCE
	MOVEI TAC,3(TAC1)
	XCTR XBLTW,[BLT TAC1,(TAC)]
	SETZM XGPERC		;CLEAR ERROR COUNT
	POPJ P,

IFN FTVRN,<
VMTAPE:	XCTR XR,[SKIPL TAC,(UUO)] ;N.B. THIS ADDRESS CHECKS BEGINNING OF DATA
	CAIL TAC,VMTTLN
	POPJ P,
;	SKIPG VMTTAB(TAC)	;SKIP UNLESS WE NEED A CLOSE FIRST.
;	TDNN IOS,[DEVSBB,,IOACT] ;DEVICE MUST NOT BE ACTIVE.
	JRST @VMTTAB(TAC)	;DISPATCH
	PUSH P,UUO
	MOVEI UUO,0		;MAKE THE EFFECTIVE ADDRESS 0 FOR CLOSE.
	PUSHJ P,XCLSO		;FORCE A CLOSE FIRST
	POP P,UUO
	XCTR XR,[MOVE TAC,(UUO)] ;GET DISPATCH AGAIN  (CAN'T BE WRONG)
	JRST @VMTTAB(TAC)

;Only some of the XGP's mtapes are implemented.  The rest are illegal on VRN.
VMTTAB:		XMTP0		;0 RETURN (AND CLEAR) ERROR CODE(S)
	UUOERR			;1   (FONT COMPILE)
	UUOERR			;2
	UUOERR			;3
		VMTP4		;4 GET STATUS
		XCLSP		;5 FORCE DATA TRANSMISSION, PSEUDO CLOSE.
	UUOERR			;6   (SET NODE COUNTS)
	UUOERR			;7   (COMPILE SELECTED CHARS IN FONT)
	UUOERR			;10  (GET NUMBER OF DATA SCANLINES USED)
	UUOERR			;11  (GET NUMBER OF FFS SEEN BY LINE COMPILER)
VMTTLN←←.-VMTTAB

;MTAPE 4 returns status
VMTP4:	MOVE IOS,VRNIOS
	XCTR XW,[MOVEM IOS,1(UUO)]
	SKIPG TAC,VRNWAT	;SEE IF VRN IS SUPPOSED TO BE INTERRUPTING NOW
	TDZA TAC,TAC
	MOVNI TAC,1
	XCTR XW,[MOVEM TAC,2(UUO)]
	MOVE TAC,VRNSTS		;GET VRN STATUS
	ANDI TAC,VNOTOK!VOFFLN!VSUPLO ;Any exceptional condition obtaining?
	SKIPE TAC		;Skip if no error conditions
	MOVNI TAC,1		;RETURN 0 (SIC) FOR MANUAL INTERVENTION NEEDED
	XCTR XW,[SETCAM TAC,3(UUO)]
	POPJ P,
>;IFN FTVRN
;XERR1 XERR2 XERR3 XERR4 XERR5 XERR6 XERR7 XERR10 XERR11 XERR12 XERR13 XERR14 XERR15 XERR16 XERRC XERRCL XGPSET XSYNCX XGPCLR PSYNCX

;SET ERROR CODE ROUTINES.

LOSYS	;SOME ERROR ROUTINES ARE CALLED FROM P2

;This code is duplicated in P2SER.  If you change any code on this page,
;you should probably duplicate the change in P2SER.

XERR1:	JSP TAC,XERRC		;FC LOSSAGE: JOB CAPACITY EXCEEDED
XERR2:	JSP TAC,XERRC		;FC LOSSAGE: NO INITIAL RESPONSE.
XERR3:	JSP TAC,XERRC		;FC LOSSAGE: NO INTERMEDIATE RESPONSE.
XERR4:	JSP TAC,XERRC		;FC LOSSAGE: ILLEGAL RESPONSE.
XERR5:	JSP TAC,XERRC		;I-LEVEL  DATA MISSED. - BUFFERED MODE.
XERR6:	JSP TAC,XERRC		;XGP IS HUNG - HUNG TIMEOUT.
XERR7:	JSP TAC,XERRC		;ILLEGAL MODE.
XERR10:	JSP TAC,XERRC		;LINE COMPILER ERROR. LINE TOO COMPLEX.
XERR11:	JSP TAC,XERRC		;OUT OF ORDER
XERR12:	JSP TAC,XERRC		;I MISSED IT!
XERR13:	JSP TAC,XERRC		;PAGE TOO LONG
XERR14:	JSP TAC,XERRC		;ILLEGAL VECTOR PARAMETERS
XERR15:	JSP TAC,XERRC		;FONT COMPILER DISAPPEARED
XERR16:	JSP TAC,XERRC		;INVALID IOWD (P1 ADDRESS CHECK IN MODE 117)

XERRC:	SKIPE XGPERC		;ONLY LET ONE ERROR THROUGH
	POPJ P,
	SUBI TAC,XERR1
	HRRZM TAC,XGPERC	;SET ERROR CODE FOR USER.
XERRCL:	SETZM XGPERC+1		;AND CLEAR EXTRA ERROR WORDS.
	SETZM XGPERC+2
	SETZM XGPERC+3
	POPJ P,

XGPSET:	PUSHJ P,PSYNCX
	IORB IOS,@DEVSPT(DDB)	;Turn on bits in DEVIOS
XSYNCX:	XSYNC XGPCSC
	POPJ P,

XGPCLR:	PUSHJ P,PSYNCX
	ANDCAB IOS,@DEVSPT(DDB)	;Turn off bits in DEVIOS
	JRST XSYNCX

PSYNCX:	PSYNC XGPCSC
	POPJ P,
;FCERRX XGPINI XGPIN1 XGPREL VRNINI VRNIN1 VRNRE2 VRNREL XGPOPN VRNOPN

HISYS

IFG XGPNUM,<
FCERRX:	PUSHJ P,XERR4			;SET ERROR CODE.
	MOVE TAC,[XGPOST,,XGPERC+1]	;GET FC STATUS
	BLT TAC,XGPERC+3		;STORE FC STATUS AS 3 EXTRA ERROR WORDS.
	POPJ P,
>;IFG XGPNUM

;INITIALIZATION, RELEASE.  XGPINI XGPIN1 XGPREL

XGPINI:	SYNINI XGPCSC		;INITIALIZE XGP SYNCHRONIZATION CELLS.
	SETZM XGPP1F		;MAKE SURE NO GARBAGE IN P2COMM AREA RUNS XGPP1
	SETZM XGPRDY		;AND DEVICE IS ASSUMED UNREADY.
;HERE AT SYSTEM INITIALIZATION AND AT XGP RELEASE TIME
XGPIN1:	SETZM XGPGO		;NO ONE READY TO XFER DATA.
	SETZM XSCTOT		;NO PAPER USED FOR DATA
	SETZM XGPFFS		;NO FFS OUTPUT BY CH 2 YET
	SETZM XGPFFF		;NO PENDING FFS IN CH 4
	SETZM XGPHDW		;ZERO HEADER IOWD
	SETZM XGPAT2
	SETZM XGPMDP		;INITIALIZE DUMP MODE STUFF
	SETZM XGPNXC	
	SETZM XGPBIG
	SETZM XGPIWD
	SETZM XP2BUF		;NO DUMP MODE DATA FOR P2 FOR P2INT
	SETZM XP2IOW		;NO REQUEST FROM P2 FOR P2INT
	MOVNI TAC,2		;NEGATIVE OF MAX NUMBER OF OVERLAPPED MODE OUT UUOS
	MOVEM TAC,XVOCNT	; THAT CAN BE PENDING
	SETZM XGPNIW		;NO IOWD FOR P2
	SETZM XGPNI2		;NO DATA IN P2
	SETZM XDBCNT		;NO BUFFERS COUNTED YET
	SETZM XGPERC		;CLEAR ERROR CODE.
IFG XGPNUM,<
	MOVE TAC,[XMSET,,XGPPS1]
	BLT TAC,XGPICS
>;IFG XGPNUM
	MOVE TAC,XP2BOT
	MOVEM TAC,XP2TKR
	MOVEM TAC,XP2OTK
	MOVEM TAC,XP2PTR
	CONO P2D,P2CLR!P2DCHN	;FLUSH ANY INTERRUPT FROM P2
	JRST XERRCL		;CLEAR MINOR ERROR CODES AND RETURN

IFG XGPNUM,<
XGPREL:	SETOM XGPKIL
	PUSHJ P,FCKILL		;KILL THE FONT COMPILER
	PUSHJ P,PSYNCX
	SETZM XGPBIT		;TELL P2 THAT WE DON'T HAVE ANY MORE.
	MOVE IOS,[XGPERR!IOW!DEVSBB!IOBEG!IOEND,,ERRMSK!IOACT]
	ANDCAM IOS,XGPIOS
	PUSHJ P,XSYNCX		;RELEASE SYNCHRONIZER

	CACHE (CSHXGP)		;PERMIT CACHE

	JRST XGPIN1
>;IFG XGPNUM

IFN FTVRN,<
;SYSTEM INITIALIZATION FOR VRN
VRNINI:
;HERE AT SYSTEM INITIALIZATION AND AT VRN RELEASE TIME
VRNIN1:	SETZM VRNGO		;NO ONE READY TO XFER DATA.
	POPJ P,

VRNREL:	SETOM VRNKIL		;Tell P2 to stop the VRN
	SKIPGE VRNUSE		;Is the VRN still running on P2?
	PUSHJ P,WSYNC		;WAIT UNTIL IOACT IS OFF
	PUSHJ P,PSYNCX
	MOVE IOS,[XGPERR!IOW!DEVSBB!IOBEG!IOEND,,ERRMSK!IOACT]
	ANDCAM IOS,VRNIOS
	PUSHJ P,XSYNCX		;RELEASE SYNCHRONIZER

	CACHE (CSHXGP)		;PERMIT CACHE

	PUSHJ P,XGPIN1		;RE-INITIALIZE DATA SHARED WITH XGP
	JRST VRNIN1

;HERE WHEN USER INITING THE VRN
↑VRNOPN:SETOM VRNUSE		;VRN IS IN USE, NOT XGP
	HRRZM DDB,P2DDB		;KEEP POINTER TO DDB FOR P2 DEVICE IN USE (VRN/XGP)
	MOVE AC1,VP2TOP
	MOVEM AC1,CP2TOP	;SET UP POINTER TO TOP OF DUMPMODE BUFFERS FOR XGP
	POPJ P,

;HERE WHEN USER INITING THE XGP
↑XGPOPN:SETZM VRNUSE		;NOT VRN THAT IS IN USE, BUT XGP
	HRRZM DDB,P2DDB		;KEEP POINTER TO DDB FOR P2 DEVICE IN USE (VRN/XGP)
	MOVE AC1,XP2TOP
	MOVEM AC1,CP2TOP	;SET UP POINTER TO TOP OF DUMPMODE BUFFERS FOR XGP
	POPJ P,
>;IFN FTVRN
;⊗ XDMPHG XDMPO2 XDMPO XCSHOK XDMPO5 XDMPO8 XDMPO1 XDMPXT XDMPFC XGPSIW XGPSI2 XGPSI3 XGPSI9

;DUMP MODE OUTPUT UUO, ENTERS AT XDMPO.

XDMPHG:	MOVEI IOS,IOIMPM	;TELL HIM AN ERROR.
	PUSHJ P,XGPSET		;SET BIT
	PUSHJ P,XERR6		;SET ERROR CODE
	POPJ P,			;GIVE UP UUO

XDMPO2:	TRNE IOS,ERRMSK
	POPJ P,			;DON'T WAIT IF HE'S GOT ERROR BITS ON.
	PUSHJ P,WSYNC		;STOP FOR A WHILE. (SETS IOW)
	TRNE IOS,IOACT		;DON'T LET US RUN AROUND THIS LOOP CONTINUOUSLY
	JRST XDMPO		;OK IF IOACT IS ON
	SKIPGE XVOCNT		;BUT IF IOACT IS OFF AND P2 HASN'T GOBBLED UP
	SKIPE XGPNXC		;ENOUGH DATA TO LET US RUN,
	JRST XDMPHG		;THEN WE'RE IN A HEAP OF TROUBLE (AND OVERLAPPED MODE)
XDMPO:	SKIPGE XVOCNT		;TOO MANY CMD LISTS STILL PENDING?
	SKIPE XGPNXC		;OR ALREADY A 'NEXT' COMMAND?
	JRST XDMPO2		;YES. WAIT UNTIL THERE ISN'T ONE
	PUSHJ P,COMCHK		;CHECK COMMAND. UUO POINTS TO FIRST IOWD.
	 JRST ADRERR		;ADDRESS ERROR IN COMMAND.
	MOVE J,JOB		;J IS CLOBBERED BY COMCHK
	HRRZ TAC,UUO		;GET COMMAND LIST POINTER.
	HRLI TAC,PROG		;MUST HAVE NONZERO VALUE FOR XGPSIW
	XCTR XR,[SKIPN (TAC)]	;SKIP UNLESS COMMAND LIST IS EMPTY
	POPJ P,			;NULL COMMAND LIST. DO NOTHING.
	MOVEM TAC,XGPNXC	;POINTER TO COMMAND SAVED AS 'NEXT COMMAND'
	SKIPE XGPMDP		;IS THERE A CURRENT MAIN POINTER?
	JRST XDMPO5		;YES.
IFKL10,<
	SKIPL JBTCSH(J)		;SKIP IF CACHE IS ON
	JRST XCSHOK

	NOCACHE (CSHXGP)

>;IFKL10
XCSHOK:	SETZM XGPNXC		;XGP IS IDLE, CLEAR NEXT
	MOVEM TAC,XGPMDP	;AND SET MAIN COMMAND POINTER.
XDMPO5:
IFG XGPNUM,<
	PUSHJ P,XDMPFC		;FC MUST BE GONE FROM P2 CORE BEFORE WE PASS P2 DATA
>;IFG XGPNUM
	PUSHJ P,PSYNCX
	MOVE IOS,@DEVSPT(DDB)
	TLZE IOS,IOBEG		;IF IOBEG,
	PUSHJ P,SETXIO		;SET I-LEVEL DATA DISPATCH.
	TRNE IOS,ERRMSK
	JRST XDMPXT		;IN CASE OF ERROR, EXIT
	PUSHJ P,XSYNCX
	SKIPN XGPNIW		;IS THERE ALREADY AN IOWD WAITING FOR P2?
	PUSHJ P,XGPSIW		;SET UP FIRST IOWD FOR P2
	PUSHJ P,XGPSTR		;START THE XGP. (DON'T CLOBBER J)
	PUSHJ P,PSYNCX
	AOS XVOCNT		;COUNT ANOTHER CMD LIST PENDING FOR OVERLAPPED MODE
	MOVE IOS,@DEVSPT(DDB)
	TRNE IOS,ERRMSK
	JRST XDMPXT		;FLUSH ERRORS.
IFE FTP2PAG,<
	MOVE TAC,JBTPAG(J)
	LSH TAC,9
	MOVEM TAC,XGPROG	;SET UP FOR XADV
>;IFE FTP2PAG
	PUSHJ P,SETACT		;SET IOACT, CLEAR IOW UNLESS IOACT WAS ALREADY ON
	PUSHJ P,XSYNCX
IFN FTVRN,<
	SKIPN VRNUSE
>;IFN FTVRN
	SETOM XGPGO		;TELL P2 TO START DOING XGP DATA.
	TRNE IOS,XOVERL		;CONTINUOUS MODE?
	JRST TPOPJ		;AVOID CALLING WSYNC IN UUOCON
XDMPO8:	PUSHJ P,WAIT1		;RETURN WHEN IOACT OFF.
XDMPO1:	SETZM XGPGO
	PUSHJ P,PSYNCX
	SETZM XGPBIT
XDMPXT:	JRST XSYNCX		;IN CASE OF ERROR, DESYNCHRONIZE AND RETURN

IFG XGPNUM,<
XDMPFC:	SKIPN XFCJN1		;IS THERE EITHER VERSION OF FONT COMPILER
	SKIPE XFCJN		; STILL AROUND, MAYBE IN P2 CORE?
	CAIA			;YES, WAIT FOR IT TO DISAPPEAR
	POPJ P,			;NO, ALL OK
	MOVNI TAC,IOWQ		;REQUE UNTIL FONT COMPILER GONE
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,WSCHED
	JRST XDMPFC		;TEST AGAIN TO MAKE SURE REALLY GONE
>;IFG XGPNUM

XGPSIW:	SKIPA TAC,XGPMDP	;MAYBE CALLERS ALREADY DID THIS?
XGPSI2:	SKIPA TAC,TAC1
XGPSI3:	JUMPE TAC,CPOPJ		;JUMP IF CMD LIST PREVIOUSLY FINISHED
	XCTR XR,[SKIPN TAC1,(TAC)]
	JRST XGPSI9		;END OF COMMAND LIST
	TLNN TAC1,-1		;IS IT A JUMP?
	JRST XGPSI2		;JUMP IF JUMP
	ADDI TAC,1		;POINT TO NEXT ITEM OF LIST
	MOVEM TAC,XGPMDP	;SAVE FOR NEXT TIME
	MOVEM TAC1,XGPNIW	;STORE NEXT IOWD OF THIS LIST FOR P2
	POPJ P,

XGPSI9:	MOVEI TAC,0
	EXCH TAC,XGPNXC		;GET NEXT CMD, IF ANY
	MOVEM TAC,XGPMDP
	MOVEI TAC,-1
	MOVEM TAC,XGPNIW	;GIVE P2 A FAKE IOWD MEANING END OF CMD LIST
	POPJ P,
;P2DINT P2DIOK P2DIN1 P2DIVE P2DINE

;Here when P2 interrupts to ask for more user data BLTed in for dump mode.
;P2 puts user-relative IOWD in XP2IOW and P2-relative page number of buffer
;area in XP2BUF before interrupting.  It then checks for zero in XP2IOW as
;a flag meaning we're done with the BLT.

↑P2DINT:JSR P2DSAV		;GET ME SOME ACS
	CONO P2D,P2CLR!P2DCHN	;FLUSH THE INTERRUPT
	MOVE AC2,XP2IOW		;USER-RELATIVE IOWD
	HLRE AC3,AC2		;NEGATIVE WORD COUNT
	JUMPGE AC3,CPOPJ	;ERROR IF NONNEGATIVE WC
	MOVNS AC3		;MAKE IT POSITIVE LENGTH
	MOVE DAT,XP2BUF		;GET P2 BUFFER PAGE NUMBER
IFN FTVRN,<
	SKIPN DDB,P2DDB		;GET POINTER TO XGPDDB OR VRNDDB
	POPJ P,			;NONE!  NEITHER IN USE, EH?  SHOULDN'T HAPPEN
>;IFN FTVRN
IFE FTVRN,<
	MOVEI DDB,XGPDDB	;SET UP USER MAP
>;IFE FTVRN
	LDB J,PJOBN
	JUMPE J,P2DINE		;JUMP IF NO JOB
	MOVE IOS,@DEVSPT(DDB)	;SEE IF THERE HAVE BEEN ANY ERRORS
	TRNE IOS,ERRMSK		;SKIP IF NO ERRORS
	POPJ P,			;ERRORS, FORGET ABOUT DATA TRANSFER
	TRNN IOS,XOVERL		;OVERLAPPED MODE?
	JRST P2DIOK		;NO, USER CAN'T HAVE CHANGED CORE SIZE
	MOVEI TAC1,1(AC2)	;STARTING USER ADDRESS
	PUSHJ P,RELOCA		;MAKE SURE THIS IS (STILL) A VALID USER ADDRESS
	 JRST P2DIVE		;NOPE, MAYBE USER CORED DOWN IN OVERLAPPED MODE
	ADDI TAC1,-1(AC3)	;ENDING USER ADDRESS
	PUSHJ P,RELOCB		;MAKE SURE IN SAME SEGMENT (USES AC1 FROM RELOCA)
	 JRST P2DIVE		;LOSE
P2DIOK:	PUSHJ P,MAPSET
P2DIN1:	MOVEI TAC,(DAT)		;P2 PAGE NUMBER
	ADDI TAC,P2BASE		;ADD OFFSET FOR P2 MEMORY IN OUR PHYS CORE
	MOVEI TAC1,XGPEXP	;VIRTUAL PAGE USED FOR BLT
	PUSHJ P,ADDEMP		;GET IT IN OUR MAP
	MOVSI TAC,1(AC2)	;BLT SOURCE, USER ADDR
	HRRI TAC,XGPEXP⊗9	;BLT DESTINATION, CONSTANT VIRTUAL ADDR
	MOVEI TAC1,(AC3)	;LENGTH DESIRED
	CAILE TAC1,1000		;ONE PAGE LIMIT
	MOVEI TAC1,1000
	XCTR XBLTR,[BLT TAC,<XGPEXP⊗9>-1(TAC1)]
	MOVEI TAC1,XGPEXP
	PUSHJ P,DELEMP		;DONE WITH THIS P2 PAGE
	ADDI DAT,1		;READY FOR NEXT PAGE
	ADDI AC2,1000		;DITTO IN USER SPACE
	SUBI AC3,1000		;AC3 IS LENGTH TO GO
	JUMPG AC3,P2DIN1
	SETZM XP2IOW		;DON'T LET'S DO IT AGAIN, ALSO TELL P2 OK
	CONO P2D,P2INTB!P2DCHN	;INTERRUPT P2 TO SAY WE'RE DONE
	POPJ P,

P2DIVE:	MOVEI IOS,IOIMPM
	PUSHJ P,XGPSET		;SET AN ERROR BIT
	PUSHJ P,XERR16		;GIVE ADDRESS CHECK ERROR
	HRRZM TAC1,XGPERC+1	;REPORT ADDRESS THAT FAILED
	SETOM XGPP1F		;WAKE UP USER
	POPJ P,

P2DINE:	PUSHJ P,DISGST
	PUSHJ P,DISERR
	[ASCIZ/At P2DINT with PJOBN = 0 for P2DDB = /]
	DISARG SIX,<DEVNAM(DDB)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCA
	POPJ P,
;XGPSTR XGSTR2 XGSTR4 VRNST1 XSIOS

;START THE XGP FROM P1.

XGPSTR:
IFN FTVRN,<
	SKIPE VRNUSE
	JRST VRNST1		;STARTING THE VRN, NOT THE XGP
>;IFN FTVRN
IFG XGPNUM,<
	SETZM XGPKIL		;HERE TO START THE XGP
	SETZM XGPAOK
	PUSHJ P,PSYNCX
	SETOM XGPCNY		;IF PAPER IS MOVING, I-LEVEL JUMPS TO PAPOON.
	SETOM XGPBIT		;TELL P2 WE WANT PAPER MOTION.
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT
	MOVE IOS,@DEVSPT(DDB)	;GET CURRENT STATE OF AFFAIRS
	TDNE IOS,[DEVSBB,,IOACT] ;IS THE BEAST RUNNING NOW?
	JRST XGSTR4		;YES. RETURN QUICK
	PUSHJ P,XSIOS		;SET IOS RIGHT.
	PUSHJ P,XSYNCX
XGSTR2:	LDB J,PJOBN
	MOVNI IOS,DIOWQ		;REQUEUE TO DIOW TO ALLOW SYNC.
	MOVEM IOS,JOBQUE(J)
	PUSHJ P,WSCHED		;RESCHEDULE.
	MOVE IOS,@DEVSPT(DDB)
	TLNE IOS,IOW		;DID THE RIGHT GUY BRING ME OUT?
	JRST XGSTR2		;NO. WAIT SOME MORE.
	TRNE IOS,ERRMSK		;ANY ERRORS?
	POPJ P,			;YES. RETURN THEM
	PUSHJ P,PSYNCX
	PUSHJ P,XSIOS		;SET SOME GOOD BITS IN DEVIOS
	JRST XGSTR4
>;IFG XGPNUM

XGSTR4:	TLO IOS,IO!IOW
	TRNE IOS,XOVERL		;OVERLAPPED MODE?
	TLZ IOS,IOW		;YES. THEN NOT REALLY IN IOW.
	MOVEM IOS,@DEVSPT(DDB)
	JRST XSYNCX		;RETURN. PAPER IN MOTION.

IFN FTVRN,<
VRNST1:	SETZM VRNKIL		;START THE VRN, NOT THE XGP!
	SETOM VRNAOK		;PREVENT HUNG DEVICE RIGHT AWAY
	SETOM VRNGO		;REMEMBER THAT VRN GOT STARTED
	SETOM VCVGO		;TELL P2 TO KICK THE CONVERTER GOING
	SETOM VRNUSE		;REMEMBER WE STARTED VRN
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT
	PUSHJ P,PSYNCX		;INTERLOCK FOR IOS
	MOVE IOS,@DEVSPT(DDB)	;GET IOS
	JRST XGSTR4		;SET IO, ESPECIALLY FOR OVERLAPPED MODE
>;IFN FTVRN

XSIOS:	MOVSI IOS,IOW!IO!DEVSBB	;ASSUME BUFFERED MODE
	MOVE TAC,DEVCMR(DDB)
	TLNN TAC,DEVIBF		;SKIP IF REALLY BUFFERED MODE
	TDC IOS,[DEVSBB,,IOACT]	;FLUSH DEVSBB, TURN ON IOACT FOR DUMP MODE.
	IORB IOS,@DEVSPT(DDB)	;SET THOSE BITS.
	POPJ P,
;⊗ SETXIO SETVIE SETXI1 SETVIO XIODSP XCIBEG XDI

;SET I-LEVEL DISPATCH AT FIRST UUO.  SETXIO SETXI1 XIODSP

SETXIO:	LDB TAC,PIOMOD
IFN FTVRN,<
	SKIPE VRNUSE		;Is this device VRN?
	JRST SETVIO		;Yes, tell P2 to start it up
>;IFN FTVRN
IFG XGPNUM,<
	MOVE TAC,XIODSP(TAC)
	TRNE IOS,XOVERL		;SPECIAL MODE?
	MOVS TAC,TAC
	MOVE TAC,XDISP3(TAC)	;GET REAL P2 DISPATCH ADDR FROM P2 MEMORY
	HRRZM TAC,XDISP2
	TRNE TAC,-1		;SKIP IF ZERO DISPATCH
	JRST SETXI1
	JRST SETVIE
>;IFG XGPNUM

SETVIE:	TRO IOS,IOIMPM		;ILLEGAL.
	PUSHJ P,XERR7
SETXI1:	MOVEM IOS,@DEVSPT(DDB)
	LDB TAC,PIOMOD
	MOVE IOS,DEVCMR(DDB)
	CAIL TAC,D
	TLZA IOS,DEVIBF		;NO INTERNAL BUFFER IN DUMP MODE
	TLO IOS,DEVIBF		;INTERNAL BUFFER IN BUFFERED MODE.
	MOVEM IOS,DEVCMR(DDB)
	MOVE IOS,@DEVSPT(DDB)
	POPJ P,

IFN FTVRN,<
SETVIO:	CAIE TAC,17		;Only legal mode on VRN
	JRST SETVIE		;Illegal mode
	SETOM VCVSTR		;Tell P2 to start up converter
	JRST SETXI1		;Store IOS
>;IFN FTVRN

IFG XGPNUM,<
XIODSP:	0,,XCIBEG		;MODE 0
	0,,XCIBEG		;MODE 1
	0			;MODE 2
	0			;MODE 3
	0			;MODE 4
	0			;MODE 5
	0			;MODE 6
	0			;MODE 7
	0			;MODE 10
	0			;MODE 11
	0			;MODE 12
	0,,XCIBEG		;MODE 13 - SAME AS MODE 0
	0			;MODE 14
	0			;MODE 15
	0			;MODE 16
	XDI,,XDI		;MODE 17 

;OFFSETS INTO P2'S INITIAL DISPATCH TABLE (ITSELF SET UP BY P2INI)
XCIBEG←←1
XDI←←2
>;IFG XGPNUM
;XCLSP XCLSO XOUT XOUT1 XOUT2 XOUT2A XOUT3 XOUT4 XOUT5 XBTLRR

;XGP BUFFERED MODE OUTPUT UUO, CLOSE UUO.  XCLSP XCLSO XOUT XOUT1 XOUT2 XOUT2A XOUT3 XOUT4 XOUT5 XBTLRR

XCLSP:	MOVEI UUO,0		;KLUDGE FOR MTAPE 5.
XCLSO:	MOVSI IOS,IOEND		;FLAG CLOSE UUO.
	PUSHJ P,XGPSET
IFN FTVRN,<
	SKIPE VRNUSE
	SETOM VCVGO		;WAKE UP VRN CONVERTER TO SLEW OUT PAPER NOW
>;IFN FTVRN
	LDB TAC,PIOMOD		;GET THE MODE.
	CAIL TAC,SD		;IS THIS A DUMP MODE?
	JRST XDMPO8		;YES. WAIT FOR ALL IO AND STOP XGP
	PUSHJ P,OUT		;DO ONE MORE OUTPUT.
	MOVSI IOS,IOBEG		;NOW, READY TO INITIALIZE AGAIN.
	JRST XGPSET		;SET IOBEG IN DEVIOS AND RETURN.

IFG XGPNUM,<
XOUT:	MOVE IOS,XGPIOS
	TRNE IOS,ERRMSK		;ANY ERRORS? 
	POPJ P,			;YES.  DON'T GO ON
	TLNN IOS,IOBEG		;FIRST OPERATION?
	JRST XOUT1		;NO.
	MOVEI AC1,P2XBPG⊗9	;P2 ADDRESS OF BUFFER
	MOVEM AC1,XTAKE		;TAKE POINTER
	MOVEM AC1,XPUT		;PUT POINTER
	SETZM XBFCNT		;BUFFER COUNT.
	PUSHJ P,NFONT		;IF WE NEED A FONT, GET ONE.
	 JRST F.LOSE		;(N.B. DON'T CLEAR IOBEG!)
	PUSHJ P,PSYNCX
	MOVE IOS,XGPIOS		;ONCE THIS IS SET UP,...
	TLZ IOS,IOBEG		;NOW, NO LONGER THE BEGINNING
	PUSHJ P,SETXIO		;SET P2 INTERRUPT LEVEL DISPATCH ADDRESS
	PUSHJ P,XSYNCX
XOUT1:	MOVE IOS,XGPIOS		;IF ERRORS, REPORT THEM TO USER
	TRNE IOS,ERRMSK		;DON'T TRY TO GO ON.
	POPJ P,
	PUSHJ P,DEVSTU		;SET UP TO PROCESS THIS BUFFER
	 JRST XOUT3		;BUFFER IS ALREADY EMPTY
	CAMLE AC2,XGPBLN	;COULD IT EVER FIT?
	JRST XBTLRR		;NO. FLUSH LOSER.
	JUMPE AC2,XOUT2A	;TAKE 2 GIANT STEPS IF EMPTY BUFFER
	MOVE TAC,XGPBLN
	SUB TAC,XBFCNT		;TAC←SPACE REMAINING.
	CAILE AC2,(TAC)		;IS THERE SPACE ENOUGH?
	JRST XOUT4		;NO ROOM. WE HAVE TO WAIT
	MOVE TAC,XPUT
	CAMGE TAC,XTAKE
	JRST XOUT2		;PUTR LESS THAN TAKR, DATA FITS FROM PUTR TO TAKR
				;WE NEED TO DO ONLY ONE BLT.

	MOVEI TAC1,<P2XBPG+P2XNUM>⊗9 ;POINTER TO THE END OF THE BUFFER+1
	SUBI TAC1,(TAC)		;CALCULATE SPACE TO THE END.
	CAIL TAC1,(AC2)		;COMPARE WITH DATA SIZE...
	JRST XOUT2		;ONE BLT WILL SUFFICE.

	HRLI TAC,(AC3)		;S,,D FOR BLT
	MOVEI AC1,<P2XNUM⊗9>+P2XORG ;END OF THE BLT+1
	ADDI TAC,P2XORG-<P2XBPG⊗9> ;MAKE P1 VIRTUAL ADDRESS
	XCTR XBLTR,[BLT TAC,-1(AC1)] ;FROM USER THRU THE END OF THE BUFFER.
	MOVEI TAC,P2XBPG⊗9	;P2 ADDRESS OF XGP BUFFER
	ADDI AC3,(TAC1)		;MAKE NEW POINTER TO USER.
	SUBI AC2,(TAC1)		;MAKE NEW COUNT.
	PUSHJ P,PSYNCX
	ADDM TAC1,XBFCNT	;INCREMENT THE BUFFER USE COUNT.
	PUSHJ P,XSYNCX
XOUT2:	HRLI TAC,(AC3)		;DATA WILL FIT UPWARDS FROM PUT.
	MOVEI AC1,(TAC)		;S,,D IN TAC.  D IN AC1.
	ADDI AC1,(AC2)		;COMPUTE LAST DESTINATION OF BLT+1
	ADDI TAC,P2XORG-<P2XBPG⊗9> ;MAKE P1 VIRTUAL ADDRESS OF BLT DEST
	XCTR XBLTR,[BLT TAC,P2XORG-<P2XBPG⊗9>-1(AC1)] ;MOVE DATA.
	CAIL AC1,<P2XBPG+P2XNUM>⊗9 ;IS POINTER AT THE END NOW?
	MOVEI AC1,P2XBPG⊗9	;YES. WRAP BACK TO FRONT.
	MOVEM AC1,XPUT		;SAVE THE NEW PUT POINTER.
	PUSHJ P,PSYNCX
	ADDM AC2,XBFCNT		;INCREMENT BUFFER SIZE.
	PUSHJ P,XSYNCX
XOUT2A:	PUSHJ P,ADVBFE		;ADVANCE THE OUTPUT BUFFER
	 JRST XOUT3		;NO MORE DATA THERE.
	JRST XOUT1		;PROCESS NEXT BUFFER FULL.

;HERE IF SYSTEM BUFFER IS NOT FULL.
XOUT3:	TLNE IOS,IOEND		;IS THIS THE LAST UUO?
	SKIPG XBFCNT		;LAST UUO. IS THERE DATA TO SEND?
	POPJ P,			;NO DATA OR NOT LAST (LET USER ADD MORE).
	SETZM XGPWSZ		;ZERO WAITING SIZE MEANS LAST UUO.
				;XGP WILL REDUCE XBFCNT TO 0 BEFORE
				;REACTIVATING P1.
	PUSHJ P,XGPIOW		;YES. START XGP AND WAIT.
	 JRST F.LOSE		;FONT COMPILER LOSES
	 POPJ P,		;HERE WE LOST WITH XGP ERROR.
	MOVSI IOS,IOEND		;NO LONGER LAST UUO.
	PUSHJ P,XGPCLR		;CLEAR BIT.
	JRST XDMPO1		;CLEAR OUT REMAINING BITS AND CELLS.


;HERE IF SYSTEM BUFFER TOO FULL.
XOUT4:	SUB AC2,XGPBLN
	MOVNM AC2,XGPWSZ	;WHEN XBFCNT≤XGPWSZ, P2 REACTIVATES P1.
				;SPACE THAT WE'LL NEED.
	TLNN IOS,IOEND		;LAST UUO?
	PUSHJ P,DEVCR		;NOT LAST. CHECK BUFFER RING USE BIT.
	 JRST XOUT5		;USER HAS NO FREE BUFFERS. OR CLOSE UUO
	POPJ P,			;WAIT UNTIL USER FILLS ALL HIS BUFFERS.
XOUT5:	PUSHJ P,XGPIOW		;USER HAS NO FREE BUFFERS. START XGP. WAIT.
	 JRST F.LOSE		;FONT COMPILER LOSES
	 POPJ P,		;WE LOST WITH XGP HUNG.
	JRST XOUT1		;SYSTEM BUFFER ¬FULL. GOBBLE USER BUFFER.

;HERE IF USER BUFFER IS TOO LARGE -- CAN NEVER FIT INTO SYSTEM BUFFER.
XBTLRR:	SETOM XGPKIL		;STOP THE XGP. GRIND. ARRGH.
	JRST BTLERR		;GIVE USER A MESSAGE.
>;IFG XGPNUM
;XGPIOW XGPIO0 XGPIO1

;START XGP AND WAIT UNTIL IT EMPTIES THE BUFFER.  XGPIOW XGPIO0 XGPIO1

IFG XGPNUM,<
XGPIOW:	SKIPGE XGPBIT		;ARE WE TELLING P2 WE WANT PAPER?
	JRST XGPIO1		;YES. THEN PAPER MUST BE GOING.
	SKIPG XFCJN		;NO.  MUST START XGP.  DOES FC EXIST?
	JRST XGPIO0		;NO.  SO DON'T LOCK IT
	PUSHJ P,FCLOCK
	 POPJ P,
XGPIO0:	PUSHJ P,XGPSTR		;START THE XGP.
	MOVE IOS,XGPIOS
	TRNE IOS,ERRMSK
	JRST CPOPJ1		;ERRORS.  TELL LOSER.
XGPIO1:	MOVSI IOS,IOW!DEVSBB	;IOWAIT, SYSTEM BUFFER BUSY
	PUSHJ P,XGPSET
	SETOM XGPGO		;DATA IS IN CORE (SYSTEM) AND READY.
	MOVNI TAC,DIOWQ		;REQUE TO DEVICE WAIT...
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,WSCHED
	MOVE IOS,XGPIOS
	TLNE IOS,IOW		;REALLY DONE?
	JRST XGPIO1		;NO
	JRST CPOPJ2		;YES
>;IFG XGPNUM
;XGPUUO XGPUU1 XPAUSE XGPUU2

IFG XGPNUM,<
;COMMUNICATE TO/FROM THE FONT COMPILER.
;XGPUUO-CALLED BY CALL AC,['XGPUUO']

;	AC LEFT POINTS TO FC CURRENT STATUS BLOCK. (20 WORDS)
;	AC RIGHT POINTS TO FC NEW STATUS BLOCK.(20 WORDS)
;	IF THERE IS NO NEW STATUS, JOB WILL BE REQUEUED TO WAIT.

↑XGPUUO:MOVE TAC,JBTPRV(J)
	TLNN TAC,XGPPRV
	POPJ P,			;WRONG CREDENTIALS.
	SETZM XGPOST		;ASSUME BY DEFALT, NULL OLD STATUS.
	XCTR XR,[HLLZ TAC,(UCHN)] ;GET THE OLD STATUS ADDRESS.
	JUMPE TAC,XGPUU1	;JUMP IF THERE IS NO OLD STATUS
	HRRI TAC,XGPOST		;ADDRESS OF OLD STATUS BLOCK
	XCTR XBLTR,[BLT TAC,XGPOST+17] ;GOBBLE OLD STATUS
XGPUU1:	PUSHJ P,XWAKE		;WAKE XGP USER.
XPAUSE:	SETOM XGPFC2		;WAITS FOR XGP USER TO CALL FCWAKE
	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,WSCHED		;PUT THE FONT COMPILER IN IOWQ
	MOVE TAC,JBTPRV(J)
	TLNN TAC,XGPPRV		;IS THIS STILL A FONT COMPILER?
	JRST XGPUU2		;NO.  EXIT QUICK.
	SKIPE XGPFC2
	JRST XPAUSE		;FC WAS WOKEN FOR THE WRONG REASON
	XCTR XR,[HRRZ TAC,(UCHN)] ;GET THE NEW STATUS ADDRESS.
	JUMPE TAC,XGPUU2	;JUMP IF NO NEW STATUS BLOCK.
	MOVEI TAC1,17(TAC)	;ENDING ADDRESS FOR BLT
	HRLI TAC,XGPNST		;NEW STATUS BLOCK
	XCTR XBLTW,[BLT TAC,(TAC1)] ;MOVE NEW STATUS FROM SYSTEM TO USER.
XGPUU2:	POPJ P,
>;IFG XGPNUM
;FCREQX FCREQ FCREQ1 FCWAIT FCWAT1 FCRQCK XWAKE XWAKE0 XWAKE1 FCWAKE

IFG XGPNUM,<
;FONT COMPILER ROUTINES.  FCREQX FCREQ FCREQ1 FCWAIT FCWAT1 FCRQCK XWAKE XWAKE0 XWAKE1 FCWAKE
; NEW STATUS FOR XGP HAS TO BE SET UP BEFORE CALL.

FCREQX:	POP P,J
	JRST XERR1		;LOSE BECAUSE OF JOB CAPACITY EXCEEDED

FCREQ:	SKIPE XFCJN		;DOES FC EXIST?
	JRST FCREQ1		;YES. JUST WAKE IT UP.
	PUSH P,J		;CREATE A FONT COMPILER
	PUSHJ P,INIJOB		;ATTEMPT TO GLOM A JOB SLOT
	JRST FCREQX		;NONE AVAILABLE
	JRST FCREQX		;WAIT FOR FREE STORAGE. (CAN'T HAPPEN).
	MOVE AC3,['XGPSYS']	;PPN OF FONT COMPILER.
	MOVEM AC3,PRJPRG(J)
	MOVEM AC3,JOBPPN(J)
	MOVE AC1,[XFCNAM]	;NAME OF FONT COMPILER.
	MOVEM AC1,JOBNAM(J)
IFN FTSTAT,< PUSHJ P,NAMSTT >
	MOVSI AC1,XGPPRV!LUPPRV!REAPRV
	MOVEM AC1,JBTPRV(J)
	MOVEM AC1,JB2PRV(J)	;ALSO PASSIVE ONES
	MOVSI AC1,JNA
	IORM AC1,JBTSTS(J)
	MOVEM J,XFCJN
	LSH J,=12
	ADD J,[$GETBT0,,1]	;PLANT CLOCK REQUEST.
	CLKENQ(J)
	POP P,J			;RESTORE J AND WAIT.
	PUSHJ P,FCWAIT		;AND WAIT FOR IT TO TELL US 'READY'
	JRST XERR2		;OOPS. - TIMEOUT
FCREQ1:	MOVE TAC,PRJPRG(J)
	MOVEM TAC,XGPNST+17	;SET USER PPN AS PART OF NEW STATUS
	MOVEM J,XGPNST+16	;AND USER JOB NUMBER TOO.
	PUSHJ P,FCWAKE		;WAKE THE FONT COMPILER.  GIVE IT NEW STATUS
	PUSHJ P,FCWAIT		;WAIT FOR FC TO RESPOND
	JRST XERR3		;OOPS. - TIMEOUT
	JRST CPOPJ1		;CALLER WILL INSPECT FC STATUS.


;HERE XGPSER WAITS FOR FC (OR TIMEOUT)
FCWAIT:	MOVE TAC,XCLKNM
	LSH TAC,=12
	ADD TAC,[$FCRQCK,,=60*JIFSEC]
	CLKENQ(TAC)		;Plant clock request
	SETOM XGPFC1		;FLAG THAT WE ARE WAITING FOR FC
	SETZM FCRQER		;INITIALLY, NO ERROR.
FCWAT1:	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,WSCHED		;DELAY
	SKIPE XGPFC1		;IS THIS WAKEUP LEGITIMATE?
	JRST FCWAT1		;NO. WAIT MORE.
	SKIPE FCRQER		;CLOCK TIME OUT?
	POPJ P,			;YES. FAILURE. (OOPS)
	AOS TAC,XCLKNM		;CANCEL THE CLOCK REQUEST.
	CAILE TAC,77
	SETZM XCLKNM
	JRST CPOPJ1		;RETURN SUCCESS.

;HERE WHEN THE CLOCK REQUEST TIMES OUT.  IF XGP USER IS WAITING FOR FC
; AND THIS CLOCK REQ. MATCHES THE LAST CLK REQ MADE, THEN FC IS HUNG.
↑FCRQCK:SKIPE XGPFC1		;SKIP IF XGP USER ISN'T WAITING.
	CAME TAC,XCLKNM		;XGP USER WAITING.  IS THIS THE LAST REQ?
	POPJ P,			;NOT LAST REQUEST.
	SETOM FCRQER		;CLOCK ERROR.  FC IS HUNG.
XWAKE:	SETZM XGPFC1		;FC OR FC HUNG WAKES THE XGP USER.
	PUSH P,J
	MOVEI DDB,XGPDDB
	LDB J,PJOBN
XWAKE0:	JUMPLE J,XWAKE1		;JUMP IF THERE'S NO SUCH JOB.
	SKIPL JBTSTS(J)		;DON'T START HIM IF HE CANT RUN
	JRST XWAKE1
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
XWAKE1:	POP P,J
	POPJ P,

;HERE XGPSER WAKES UP THE FC WHO WAITS INSIDE THE XGPUUO
FCWAKE:	PUSH P,J		;WAKE UP FC
	SETZM XGPFC2		;FC NOT WAITING FOR SYSTEM ANY MORE
	MOVE J,XFCJN		;GET JOB NUMBER OF FC
	JRST XWAKE0		;WAKE IT.
>;IFG XGPNUM
;FCLOCK FCKILL $FCKIL XBIDSP NFONT F.LOSE

IFG XGPNUM,<
;MORE ROUTINES FOR FC.

FCLOCK:	MOVEI TAC,3
	MOVEM TAC,XGPNST

IFN FTP2PAG,<
	MOVE TAC,XFCADR		;PLACE WHERE P2 WANTS FC LOADED IN ITS ADDR SPACE
	MOVEM TAC,XGPNST+1
>;IFN FTP2PAG

	PUSHJ P,FCREQ
	 POPJ P,		;TIME OUT.  ERROR CODE IS SET ALREADY
	SKIPE XGPOST		;EXPECTED REPLY IS 'READY'
	JRST FCERRX		;BARF! SET EXTENDED ERRORS
IFKL10,<
;;;	PUSHJ P,SWEEPA	      ;;;SWEEP FC FROM CACHE
	PUSHJ P,VALCOR		;SWEEP THE CACHE VALIDATING CORE ONLY
>;IFKL10

	JRST CPOPJ1

FCKILL:	SETZM XGPNST			;CALLED BY RELEASE CODE.
	SETZM XFTADR			;CLEAR OUT OUR MEMORY OF OLD FONTS
	MOVE TAC,[XFTADR,,XFTADR+1]
	BLT TAC,XFTADR+FNTMAX-1
	SKIPG TAC,XFCJN			;GET OLD JOB NUMBER
	POPJ P,
	MOVSI TAC1,XGPPRV
IFE FTSTAT,<
	TDNE TAC1,JBTPRV(TAC)		;ARE WE SURE THIS IS THE RIGHT JOB?
	SETZM JOBNAM(TAC)		;YES. CLEAR JOB NAME.
>;IFE FTSTAT
IFN FTSTAT,<
	TDNN TAC1,JBTPRV(TAC)
	JRST $FCKIL
	SETZM JOBNAM(TAC)
	PUSH P,J
	MOVE J,TAC
	PUSHJ P,NAMSTT
	POP P,J
$FCKIL:
>;FTSTAT
	ANDCAM TAC1,JBTPRV(TAC)		;CLEAR OUT PRIVILEGES
	PUSHJ P,FCWAKE			;WAKE HIM UP TO DIE.
	SETZM XFCJN		;IFN, IT'LL BE ZEROED BY JOBKL
	POPJ P,

XBIDSP:	4001			;BITS ON FOR MODES THAT NEED FONTS

NFONT:	LDB TAC,PIOMOD		;GET THE MODE AGAIN
	MOVEI TAC1,1
	LSH TAC1,(TAC)
	TDNN TAC1,XBIDSP	;NEEDING A FONT?
	JRST CPOPJ1		;NO.
	MOVEI TAC,1		;ALLOCATE COMMAND
	MOVEM TAC,XGPNST
	MOVE TAC,XNTNOD		;NUMBER OF TEXT NODES
	IMULI TAC,TNSIZE	;TIMES THEIR SIZE
	MOVEM TAC,XGPNST+1	;STORE
	MOVE TAC,XNVNOD		;NUMBER OF VECTOR NODES
	IMULI TAC,VNSIZE	;TIMES THEIR SIZE
	ADDM TAC,XGPNST+1	;ADD TO TEXT NODE SPACE, TOTAL NODE SPACE NEEDED
	PUSHJ P,FCREQ		;REQUEST ALLOCATION FROM FC
	 POPJ P,		;LOSE.
	MOVE TAC,XGPOST
	CAIE TAC,1		;EXPECTED RESPONSE IS 'ALLOCATION MADE'
	JRST FCERRX		;UNEXPECTED RESPONSE.
	MOVE TAC,XGPOST+1
	MOVEM TAC,XFREBA	;SAVE ADDRESS OF THE ALLOCATION.
	SKIPE XFTADR		;YES. WE NEED A FONT. SKIP UNLESS WE HAVE ONE.
	JRST CPOPJ1		;NO. MAKES THINGS EASY.
	SETZM XGPNST+1
	SETZM XGPNST+2
	SETZM XGPNST+3
	SETZM XGPNST+4
	MOVEI TAC,2
	MOVEM TAC,XGPNST
	PUSHJ P,FCREQ
	 POPJ P,		;TIME OUT. ERROR CODE IS SET ALREADY.
	MOVE TAC,XGPOST
	CAIE TAC,2
	JRST FCERRX		;ERROR. UNEXPECTED RESPONSE.  SET EXTENDED ERROR
	MOVE TAC,XGPOST+1
	MOVEM TAC,XFTADR	;STOW FONT ADDRESS
	JRST CPOPJ1

F.LOSE:	MOVEI IOS,IODTER	;USE THIS BIT FOR FC LOSSAGE
	JRST XGPSET		;SET BIT IN IOS AND RETURN TO UUOCON.
>;IFG XGPNUM
;HUNG HUNG1 XGPP1 XGPP1D XGPP1C VHUNG VHUNG1

;CLOCK LEVEL. HUNG TIMEOUT.  HUNG HUNG1 XGPP1 XGPIN2 XGPP2

IFG XGPNUM,<
;HERE ON HUNG TIMEOUT
HUNG:	MOVEI TAC,0
	EXCH TAC,XGPAOK		;GET AND CLEAR FLAG SAYING XGP IS ALL OK
	JUMPE TAC,HUNG1		;DOES P2 REPORT THE XGP IS ALL OK?
	SKIPLE XGPBIT		;YES, BUT HAS THE XGP BEEN OK ALL ALONG?
	JRST HUNG1		;NO, TELL USER XGP IS HUNG (EVEN THO MAYBE OK NOW)
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT		;RESET HUNG TIME.
	JRST CPOPJ1		;THE XGP IS STILL THERE.

HUNG1:	SETOM XGPKIL		;KILL THE XGP
	MOVEI IOS,IOIMPM	;TELL HIM AN ERROR.
	PUSHJ P,XGPSET		;SET BITS
	PUSHJ P,XERR6		;SET ERROR CODE
	TRNE IOS,HNGTRP		;IS USER ENABLED TO HANDLE HUNG XGP?
	AOS (P)			;YES.  DON'T GIVE HIM HUNG DEVICE THEN.
	PUSHJ P,XDMPO1		;SHUT OFF XGPGO, XGPBIT
	MOVE IOS,[DEVSBB,,IOACT]
	PUSHJ P,XGPCLR		;CLEAR IOACT AND KICK P1
>;IFG XGPNUM
↑XGPP1:	SETZM XGPP1F		;P1 HERE AT CLOCK LEVEL. CLEAR REQUEST SET BY P2.
IFN FTVRN,<
	SKIPN DDB,P2DDB		;GET EITHER VRNDDB OR XGPDDB
	POPJ P,			;I HOPE THIS NEVER HAPPENS!
>;IFN FTVRN
IFE FTVRN,<
	MOVEI DDB,XGPDDB	;DDB ADDRESS FOR STTIOD
>;IFE FTVRN
	MOVE IOS,@DEVSPT(DDB)	;SO PIOMOD WILL FIND MODE
	LDB TAC,PIOMOD		;SEE IF THIS IS DUMP MODE
	CAIL TAC,SD		;IS IT DUMP MODE(SD,DR,D)?
	JRST XGPP1C		;YES, GET NEXT IOWD FOR P2
XGPP1D:	PUSHJ P,PSYNCX
	MOVE IOS,@DEVSPT(DDB)
	TLZE IOS,IOW		;WAS HE IN WAIT?
	PUSHJ P,STTIOD		;YES, GET HIM OUT FAST
	MOVEM IOS,@DEVSPT(DDB)
	JRST XSYNCX		;UNSYNCHRONIZE AND POPJ

XGPP1C:	LDB J,PJOBN
	JUMPE J,CPOPJ		;P2 SPAZZED
	TRNN IOS,ERRMSK		;STOP SENDING DATA NOW IF ANY ERRORS
	SKIPE XGPNIW		;HAS HE TAKEN THE LAST IOWD?
	JRST XGPP1D		;NO, MUST BE PAPER JUST STARTED
	SKIPN JBTPAG(J)		;IS USER IN CORE?
	POPJ P,			;MUST HAVE TYPED CALL
	PUSHJ P,MAPSET
	PUSHJ P,XGPSIW		;GIVE NEXT IOWD TO P2
	TRNE IOS,XOVERL		;OVERLAPPED MODE?
	SKIPE XGPNXC		;YES, WAKE UP USER IF NO NEXT COMMAND LIST
	JUMPN TAC,CPOPJ		;JUMP IF WE REALLY FOUND ANOTHER IOWD
	TRNE IOS,XOVERL!ERRMSK	;WAKE UP USER IF OVERLAPPED MODE OR ANY ERRORS
	JRST XGPP1D
IFN FTVRN,<
	SKIPN VRNUSE
>;IFN FTVRN
	SKIPL XGPIGO		;MAKE SURE P2 HAS FINISHED OUTPUT
	JRST XGPP1D		;OUTPUT DONE, WAKE UP USER
	POPJ P,			;P2 STILL DOING OUTPUT

IFN FTVRN,<
;HERE ON HUNG TIMEOUT
VHUNG:	MOVEI TAC,0
	EXCH TAC,VRNAOK		;GET AND CLEAR FLAG SAYING VRN IS ALL OK
	JUMPE TAC,VHUNG1	;DOES P2 REPORT THE VRN IS ALL OK?
	SKIPLE VRNGO		;YES, BUT HAS THE VRN BEEN OK ALL ALONG?
	JRST VHUNG1		;NO, TELL USER VRN IS HUNG (EVEN THO MAYBE OK NOW)
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT		;RESET HUNG TIME.
	JRST CPOPJ1		;THE VRN IS STILL THERE.

VHUNG1:	SETOM VRNKIL		;KILL THE VRN
	MOVEI IOS,IOIMPM	;TELL HIM AN ERROR.
	PUSHJ P,XGPSET		;SET BITS
	PUSHJ P,XERR6		;SET ERROR CODE
	TRNE IOS,HNGTRP		;IS USER ENABLED TO HANDLE HUNG VRN?
	AOS (P)			;YES.  DON'T GIVE HIM HUNG DEVICE THEN.
	SETZM VRNGO
	MOVE IOS,[DEVSBB,,IOACT]
	PUSHJ P,XGPCLR		;CLEAR IOACT AND KICK P1
	JRST XGPP1		;WAKE UP JOB
>;IFN FTVRN
;Documentation of User Programming for the XGP
COMMENT $
	This  document reflects  the  state  of  the software  as  of
system 6.12/N.   Changes may be made without prior notice and without
maintaining compatability with earlier systems.

	The Xerox Graphics  Printer (XGP) provides a means  of making
a hardcopy listing  of virtually any drawing that can be expressed as
a one-bit raster.   The XGP  accepts as data  a bit array  describing
each  scan-line that  is printed.   Each  scan line  is approximately
1700 bits;  scan lines  are spaced at  about 190  per inch along  the
paper.   A picture is  built by sending successive  scan lines to the
XGP.

	There are presently two distinct modes  of operating the XGP,
video mode and character mode.

	Video Mode

	In video mode,  36 bit words  are interpreted as  video data.
Words  are grouped together into  portions of a scan-line  by the use
of a Group Command Word (GCW).  The GCW precedes the data  portion of
the group.  The GCW specifies how  many words of video data are to be
found  in this  group.   Also  the GCW  allows the  video data  to be
positioned anywhere along  the scan  line.  The  exact format of  the
GCW is:

	BYTE (1)MARK (11)LNSKIP (12)COLSKP (6)UNUSED, DWCNT

	The fields of the GCW are interpreted as follows:

	The  paper will  be advanced  by  LNSKIP blank  lines
	before  printing.   LNSKIP =  1  is used  for normal,
	single spacing. LNSKIP  = 0  prevents any advance  to
	the next  scan line  and prints on  the same  line as
	the last group.

	The column register in the XGP  interface will be set
	to COLSKP before transmitting data. 

	DWCNT words following the GCW will  be transmitted to
	the  XGP as  video data  (a bit  = 0  is white,  1 is
	black). If DWCNT = 0 then there are no data words  in
	this group and the next word is another GCW.

	After data is sent,  if the MARK bit is  1, the paper
	will  be marked  for cutting.   Paper cutting  is not
	exact so a MARK  should be preceeded and followed  by
	several blank lines.

	The field  labeled UNUSED  has no  meaning currently.
	It  should be set to zero  to avoid confusion if some
	other meaning is attached to this field.


	
	Modes 17  and 117  are used  for video  data.   All of  these
modes accept the format that is described above.

	In mode 17,  the effective address of the OUT uuo points to a
standard dump  mode command  list.   The command  list specifies  the
data  to send  to the  XGP.   Each  OUT  will wait  until the  entire
command  list is processed before  returning to the  user.  The paper
will be cut at the completion of each command list.  

	Mode 117 is like mode  17 except that the OUT uuo  returns to
the user while data is being  sent to the XGP.  In this mode the user
can overlap the input of one  data block with the output of  another.
Three data blocks are  needed in this mode: one being  emptied by the
XGP, another  pending, and another being filled  by the user program.
The first two  OUT uuos will  return immediately (having  established
the current  and pending output  blocks).   After the user  fills his
third block  and gives an OUT uuo he will be forced to wait until the
current block  is  empty (at  which time  the  pending block  becomes
current and  the  block specified  in this  OUT will  become the  new
pending block).   When the third OUT returns, the first block will be
free to use.  In  video mode the XGP  requires up to 10,000 words  of
data per second.   Care should be exercised in  programming to always
have data ready for the XGP.

	Another requirement  of mode  117 is  that the command  lists
that  point to the  three data blocks  must be disjoint.   The actual
requirement is that  the command list  for each  block must be  valid
while the block is  being output.  In particular, don't  use the same
physical location in your program for more than one command list.

	In mode 117 you must do a CLOSE UUO  after the last OUTPUT to
force  the transmission of  all buffers to  the XGP.   It is possible
that a user  program may not be  able to supply  data fast enough  in
mode 117.  In this event,  the output will  be cut wherever  the data
runs  out.  A status bit, 2000  (IOTEND), is provided which warns the
program that this  has occurred.   This bit is  set only in mode  117
when the data runs out and no CLOSE has been done.

$
;Documentation of Character Mode for the XGP
COMMENT $

	Modes 0 and 13 are the character modes in  the XGP.  In these
modes,  36 bit words are  interpreted as five 7-bit  bytes.  There is
no fixed mapping between byte values and particular  graphic symbols.
The graphic  symbol for any  byte is defined  by the current  font in
use.  Certain  byte  values have  special  meanings  consistient with
ASCII and  one byte  value, octal  177, is  used as  an escape  which
gives the bytes that follow a special meaning.

	Character  mode  permits vectors  and  multiple  active  text
lines.

	Character mode interprets  7-bit bytes taken from  the user's
buffer as follows:

Byte	Usual meaning			Escape significance

0	Null - byte is ignored		Normal
1	Normal				XGP ESCAPE 1
2	Normal				XGP ESCAPE 2
3	Normal				XGP ESCAPE 3
4	Normal				XGP ESCAPE 4
5	Normal				XGP ESCAPE 5
6-10	Normal				Reserved
11	TAB				Normal
12	LF				Normal
13	Normal				Reserved
14	FF				Normal
15	CR				Normal
16-37	Normal				Reserved
40-176	Normal				Normal
177	ESCAPE				Normal

Normal means the definition of this byte in  the current font will be
printed.  If this byte is  undefined in the current  font, it will be
ignored.

ESCAPE causes the next  byte to  have an  alternate meaning  selected
from the column "Escape significance".

TAB produces  a column  select to  the column which  is at  least the
width  of a blank  to the right  of the current  column position, and
some multiple of 8 blank widths to the right of the left margin.

LF activates the current  text line. The current text  will be queued
to printed.   The default Y position of text  will be advanced by the
number of scanlines it  takes to draw this  line, plus the number  of
lines specified  by the  interline space argument  to the  margin set
MTAPE.   This default Y position will be  used for the next text line
(unless changed by a vector command or ESCAPE-3.

FF, like  LF, activates  the text.   In  addition, FF  causes a  page
eject  after the  current text  line is  printed.   FF also  sets the
defalut Y position to the first line below the top of page  margin on
the new page.

CR  causes  a  column  select  to  the  current  left  margin  to  be
generated.

XGP ESCAPE  1 ('177&'001) causes  the next  7 bits  to be  read as  a
special operation code.  The following codes are implemented:

	0-17	Font select.
		The code, 0 to 17 is taken as the font identification
		number of the font to use.

	20-37	Reserved for future use.

	40	XGP Column Selector
		The  next  14  bits  are taken  modulo  4096  as  the
		x-position to print  at next.  (The  intention  is to
		allow arbitrary width spaces for text justification.)

	41	XGP Underscore
		The next byte (in two's complement)  is  the relative
		scan line  on which the underscore is to occur, where
		0  represents  the  baseline  of  the  text, negative
		values   represent   lines  above  the  baseline  and
		positive  values  lines  below  it.  The next 14 bits
		(modulo 4096) specify the length of  the  underscore.
		If the  underscore  command is the first  thing  on a
		line, the baseline will be set to the baseline of the
		current font.  The left end of the underscore  starts
		at the current column; the "current column" after the
		underscore is done will be one column to the right of
		the right end of the underscore (i.e., final column=
		initial column+length of underscore).

	42	Line space.
		This does  a line feed and then takes the byte as the
		number of blank lines to insert before the next line.

	43	Base-line adjust.
		The next  7 bits are taken in two's complement as the
		base-line adjustment  to  the  current  font.     The
		adjustment sticks  until  reset  by  another   adjust
		command or a font select. The intention is to allow a
		font to be  used  for  subscripts  and  superscripts.
		(Increment baseline  for  superscript,  decrement for
		subscript).  

	44	Print the paper page number.
		The paper page number is set to 1 by a form feed.  It
		is  incremented  each  time  the  paper  is cut.  The
		decimal value of this count is printed.

	45	Accept heading text.
		The next  byte  is a  count of bytes to follow. Those
		bytes  will be read into the heading line.  When that
		count is exhausted, the heading line will be printed.
		If a line feed or line space command  is  given  that
		would cause text to be printed below the current text
		area,  a  form  feed  is inserted by the XGP and if a 
		heading is defined, it will be printed.

	46	Start Underline.
		Set the left end of an underline. See Stop Underline.

	47	Stop Underline.
		The  next byte is the scan line on which to write the
		underline (same as XGP Underscore).   The  extent  of
		the underscore is defined by this command  and  Start
		Underline. If this command is not preceded by a Start
		Underline, the results will be unpredictable.  Beware
		of column selects.  No  underline  will  happen until 
		this command is given.

	50	Set Inter-Character Space.
		The next byte is taken as the column increment to add
		after each character.  Note: this takes lots of extra 
		computation in the Stanford implementation.   Use  of
		this  feature  may  produce  documents that cannot be
		listed.

	51	Stop wide (thick) underline.
		The first byte is the line thickness of the underscore.
		Subsequent bytes are like Stop Underline (see 47 above).

	52	Relative base line adjust.
		The  next  byte  is  the  two's  complement base-line
		adjustment relative to the current baseline.  (Incre-
		ment  baseline  for  superscript,  decrement for sub-
		script).

XGP ESCAPE 2  ('177&'002) causes the next 7  bits to be taken  as the
column  increment.    This  quantity  is  signed: 0-77  are  positive
increments 100 to 177 are negative increments (100 → -100, 177 → -1).

XGP ESCAPE 3 ('177&'003) causes  the next 2 bytes to be  taken as the
scan line  number on which to  start this text line.   Scan line 0 is
the first  scan line  on the  page (immediately  following the  cut).
The topmost scanline  of the present text line will  be placed on the
scan  line indicated in this  command.  (If there  is no current text
line, the next text line will be put there.)

XGP ESCAPE 4 ('177&'004).   This escape is used to  specify a vector.
It is followed by 11 bytes describing the vector:

	2 bytes	Y0	Scan line number of first line of vector.
	2 bytes X0	Column  position of left  edge of first  line
			of the vector.
	3 bytes DX	Delta X. 1 bit of sign; 11  bits  of integer;
			9 bits of fraction.
	2 bytes N	The number of scan lines on which this vector
			is visible.
	2 bytes W	The column width of each scan-line.

The  XGP   service  must   be  presented   with  vectors  sorted   by
ascendending  values  of Y0.   If  the  vectors are  not  sorted, the
output will be wrong.

XGP ESCAPE 5 ('177&'005).   This escape selects a font.  The next byte
is the number of the font to select (between 0 and FNTMAX-1).

The escape significance  of codes 6 through  10,  13, and  16 through
37 is not defined at the present time but reserved for future use.

$
;Documentation of internal structure for mode 0
COMMENT $
	The code  to process  text in mode  0 is  broken up into  two
phases.   There is  the 'line assembly'  phase which  occurs once per
text line  and  the 'scan'  phase  which  occurs once  per  generated
scanline.

	The 'scan' phase  is intended to  be quite simple.  The inner
loop for this phase  is at SCANX, and runs in the accumulators on
P2.   The  scan phase  excutes commands  from  a buffer  that  was
generated during  the line  assembly.  The  buffer has  the following
format:

XLINE:
	CAIL AC1,MIN 		;←----(UCHN - MAJOR COMMAND)
	CAIL AC1,MAX
L1:	JRST L2			;JUMP TO NEXT MC
	MOVEI TAC,(AC1)
	SUBI TAC,@.-4
	ROT TAC,-1
	JSP AC2,.+2	
	0,,L8			;POINT TO NEXT MINOR GROUP
				;USED BY JRST @(AC2)

;THIS GROUP MAY BE REPEATED FOR EVERY EXPLICIT COLUMN SELECT.-----⊗
	CONO XGP,140000+COLUMN	;COLUMN SELECT FOR MINOR GROUP	  |
	JSP AC3,SCAN		;CALL ROUTINE TO TRANSMIT DATA	  |	
 	-N,,.+1			;←----(DSER - CURRENT AOBJN)	  |
	BLOCK N			;DATA TO SEND 			  |
;-----------------------------------------------------------------⊗

	JRST @(AC2)
L2:	CAIL AC1,MIN		;SECOND MAJOR COMMAND
	CAIL AC1,MAX
L3:	JRST L6			;JUMP TO NEXT MC
	MOVEI TAC,(AC1)
	SUBI TAC,@.-4
	ROT TAC,-1
	JSP AC2,.+2
	0,,L5			;POINT TO NEXT MINOR GROUP
	CONO XGP,
	JSP AC3,SCAN
	-N,,.+1
	BLOCK N
	JRST @(AC2)
L4:	JSP AC2,.+2
	0,,L1			;POINT TO NEXT MINOR GROUP
	....
	JRST @(AC2)
L5:	JSP AC2,.+2
	0,,L3
	...
	JRST @(AC2)
L6:	CAIL AC1,MIN
	CAIL AC1,MAX
L7:	JRST CPOPJ
	MOVEI TAC,(AC1)
	SUBI TAC,@.-4
	ROT TAC,-1
	JSP AC2,.+2
	0,,L7
	...
	JRST @(AC2)
L8:	JSP AC2,.+2
	0,,L4
	...	
	JRST @(AC2)

[Note: the  following lies  pertaining  to the  above exist.   1.  In
addition to the code  existing as outlined  above, jumps between  the
64-word  text  nodes  also  exist.    They  have  been  omitted   for
simplicity.  2. The label  XLINE no longer exists.  In order to  find
where the code starts, you have to look in the text nodes.]

In  an attempt  to provide  job  security, the  author  made this  so
complicated  that no one else  can understand it.   That he failed is
evident: he never understood it, and he doesn't work here anymore.

Pending Queue and Active Lists.

The line compiler processes  text and compiles text nodes  and vector
nodes.   These nodes  are queued  on a single  list.  The  Scan Phase
processes these queues and  activates nodes at the appropriate  time.
There are 4  kinds of nodes; narrow vectors, wide  vectors, text, and
page mark.  Each of  these node types (except the page  mark node) is
linked  onto a separate  list for  the per-scanline processing.   The
page mark node causes all active nodes to be cancelled.

   Narrow Vector  Wide Vector	Text		Page
	
0  Link		  Link		Link		Link
1  Y0		  Y0		Y0		Y0
2  X0,,n	  X0,,n		-n		0
3  Width	  Width		Link-2		-1
4  DX		  DX		Unspecified	EOFFLG

Y0 in  all  cases denotes  the scan  line  number on  which the  node
becomes active. 'n'  denotes the number of lines on which the node is
active.  The  nodes are  all queued on  a single pending  list.   The
nodes are distinguished  by word 2 (negative means text  node) and by
word  3 (negative means page node,  narrow and wide are distinguished
by the values of Width).

Vector nodes are 5 words.  Text nodes are 64. words.

The first interrupt to  transmit data activates XCIBEG in  channel 2.
This routine arranges  for XCPINI, the compiler initialization, to be
run in  channel  4, and  it actiavates  an  interrupt in  channel  4.
XCIBEG also  initializes the  pending queue and  the active  lists to
empty.

Subsequent  channel 2 interrupts  will inspect the  pending queue and
activate the first  node on that queue  when ready.  Nodes  that have
been activated are  linked onto one of the three active lists. (There
is no list  for page  nodes, since only  one can be  active).   After
activating  any pending  nodes that  have become  active, the  active
lists  are  processed.    As  each  active  node  is  processed,  its
activation  counter is  decremented.    When the  activation  counter
reaches 0,  the node is deactivated  by delinking it  from the active
list and linking it to the appropriate free list.  Whenever additions
to the free lists are made, the compiler is activated.

Page  mark  nodes  are  treated specially.    When  such  a  node  is
activated  the paper is  marked for cutting.   Since  there should be
nothing active across the cut mark, all active nodes  are deactivated
without further processing and returned to free storage.  If the cell
EOFFLG in the page mark node contains  a non-negative quantity,  that
signifies that the  end of text processing has been reached.  Channel
2 will  exit  to the  co-routines that  feed  paper and  prepare  for
another transfer.

The active  vector nodes are  processed quite simply.   X←X+dX.   The
vector is  drawn at the new X position for  the specified width.  The
only peculiarity  about vectors  is the  separation,  by width,  into
narrow and wide  vectors.  This separation is  necessary because wide
vectors  take longer to process  in the XGP  interface and no further
interface commands  may be issued  until the  processing of the  wide
vector stops.

Active text  nodes are  processed by  loading AC1  with the  scanline
number and  executing the subroutine that was  compiled into the text
node.  The  text subroutine is  called with  a PUSHJ P,  instruction.
The first location of the subroutine is the fourth word of the node.

The compiler is initialized at XCPINI.  The  address of XCPINI is set
into X2DISP, the  compiler co-routine restart address, by XCIBEG. The
initialization builds the  free vector  node list and  the free  text
node list.   The initial column  position,  Y position,  and font are
set here.   The compilation of each line is started at XCI.  When the
first printing  character (or  underscore  command) is  compiled,   a
text  node  is taken  from  the free  list  and  initialized.   P2
instructions are compiled  into the  text node.   If  there are  more
instructions than  will fit,  another text  node is  gotten from  the
free list and  linked appropriately to the existing nodes.  If at any
point there are no text nodes free, the compiler sets  an appropriate
co-routine restart  address and dismisses until  activated by channel
2.    When a  vertical  spacing  character is  encountered,  the line
compilation is terminated. The text node is linked to  the end of the
pending  queue.   From  the particular  line  spacing character,  the
vertical position of the  next line is calculated.   (Form feed  will
cause a page mark node to be generated and  queued, as will line feed
off  the bottom of the  page body.) After queuing  the text node, the
compiler starts on the next text line.

$
BEND XGPSER

>;IFN FTP2	;Whole file
