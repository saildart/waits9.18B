COMMENT ⊗   VALID 00123 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00022 00002	Documentation and Caveats
C00027 00003	DATA STRUCTURES AND PARAMETERS
C00030 00004	USRB IRMA TPMON DDTM TTYDTC PTLIP TOIP SYNC KILREQ TTYHLD SNKWAT TTYIOW IOSUPR BKSP NOECHO NOECHB MERTP1 MERTPO
C00033 00005	DISLIN CTYLIN TTYFIL DMLIN DDDLIN PTYLIN SUPER2 TLKRNG XON FULTWX TBXPND FCS ROBTPD SPCBRK PTYUSE PTYWAK IMPBIT ECHARR LGLSET KILMSK MTTYLN FSNCHN KENA KCLEAR KMISSED KREQ BNLFLG DELHBT DELBNO BNPEND GAGTBT GAGTNO GAGBIT GAGBNO CVTBIT CVTBNO PSWBIT PSWBNO GLASSB GLASBN BNCNTL BNCTBN BNMETA FCMBIT
C00039 00006	DEFWID BEEPBL LINE HPOS IDLECH PFITCH PHPOS PTTYWD GAGTPT GAGBPT CVTBPT PSWBPT GLABPT FCMBPT FCMTBP FC2BPT BNBBBP IMARGS ARGBPT DELBPT PTALK CHRESC NUMESC SGNESC PLASTC PCOMIC PLSTLC
C00043 00007	APLINE NYLINE LINBIT MXIRMA TERLIN
C00052 00008	 TTYINI SCN0 ADSILP NOASIN SCNC1 SCNC2 SCNC3 SCN2 SCN6 NOTPTY SCN3
C00063 00009	TTYCOM TTYCM0 TTYCM1 TTYCM3 TTYCM4 TTCM4A TTYCM5 TTYCM6 TTYCM TTYCND TTYCM2
C00071 00010	TTYATI
C00073 00011	TTYSUB TTYSBE TTYSB3 TTYSB2 TTYSB0 TTYSB1 TCOMLP TCMNEQ TCMGOT TCMOK TCMER2 TCMERR TCMDLY TCMRET TCMRE1 TCMPOP TCMXIT TCOMND TCOMLN TCOMDS
C00086 00012	 TTTEST TC100 TTSAIL TTCDCA TTPAD TTPAD3 TTBAUD TTBAU2 TTALTB TTALTE TTALT1 TTBS TTBOLD TTDMST TTALTN TTLFTA TBS XXX TTYADR DTJSP NDTYPS DTNAME DTMISC DTEDPD DTDPYD SETDPY SETDP0 SETDPD SETDPU SETDP1 SETDP2 SETDP3 SETDP4 SETDPX DSETUP DSETU2 DPIMSG SETDPI DPINIT SDMWID SDMWI2 SETDPE TTYNDM TTBEEP FILTTY STOLIN TTECHO TTFULL TTTAB TABCHK TTYARR TTYGLA TTTGAG TTYGAG TTYHAC TTYDEL TTYCVT TTYHA2 SPDCMD SPDCM1 SPDCM2 SPDCM3 BEPHNG HNGCLK QUITCM HNGCLS HNGCMD HNGCMA HNGCMB HNGCM1 CKFONE TTYNOE EDITCM NOEDCM CLRNED NOEDC1 TTNESC TTNES0 TTNES1 TTNES2 TTEESC TTNESR TTNER1 TTNER2 TTEESR HTOGGL
C00133 00013	TTYSWD TTWID0 TTWID1 TTYUPD TTYTIM TTYTI1 TBRK TESC TESC3 POPDTJ TTHIDE
C00138 00014	FTTYW TTYWHO TTWHSY TTWHS1 TTNOJB UWHO PJBWHO FTTYW1 UWHO0 UWHO1A UWHO1 UWHO2A UWHO2 UWHO3 UWHO4 WHOUUO WHOUU1 WHOUU0 WHOUU2
C00144 00015	TTEXS0 TTEXST TTEXS3 TTEXS4 TTUHUH TTEXLS TTEXRE TTEXLL TTEXN TTEXLD TTEXY TTEXLA TTEXLT TTEXLW TTSNB3 TTSENB TTSE98 TTSNB1 TTSNB2 TTSNBA TTSNBB TTSNBT TTSNBU TTSNBV TTSNBW TTSNBZ TTSNBY
C00155 00016	ATTTTY DETTTY DCARUI DCARUN DCARU0 DCARU1 FDETD1 DCARU2 DCARUD
C00161 00017	TTYATT TTYAT2 TTYAT3 TTYAT4
C00165 00018	TTYDET TRESCN TRESC1 TRESCU TRESCB TRESCA
C00170 00019	TLHBYT TBYTEP
C00171 00020	 TTYGET TTYFNU TTYFND TTYDAT TTYFUW TTYFU3 OPNTTY OPNTT1 TTYICK TTYIC2 TTYIC3 TTYIC5 TTIC33 TTYIC4 CLRIMG CLRIM3 CLRIM2
C00178 00021	TTYERP TTYERR TTYER1 TTYDX1
C00180 00022	TTYSET TTYSTC TTYSTR TTYST3 TTYST2 TTYSTF TTYUSR
C00184 00023	TLKTST TTYTLK TLKNPG TLKSTR TLKST1 TLKSIX TLKCHR
C00190 00024	TTYSRC STLNAC
C00193 00025	GETDDB UGTDDB GETDBA GETDB0 GETDB2 LOG2LN SIX2LN LOG2LL SCREW
C00197 00026	STDTBL DDBSRC DDBSR1 DDBSR2 DDBSR4 DDBSR3 SCNIN SCNIN0 SCNINX
C00207 00027	TTYSKL TTYREL TTYRL1 TTYKDT TTYDIE TTYKIL TTYKC2 TTYKL0 TTYKND NOTYPA TTYKL5 CLTDDB TTYKC0 TTYKCL
C00218 00028	 TTYKL2 TTYK6A TTYKL6 TTYKLN TTYK2A TTYK22 TTYKL3 TTYKL8 LINCLR LINCL2 TTYKL1 TTYKL4 DDB TTYKL9 TTYK91 TTYK92 CLRRSP CLRRS2 CLRRS3
C00228 00029	OUTCH6 OUTCHS OUTC1S OUTCHR OUTCH5 TLKOUT OUTC5A OUTCA2 OUTCA1 OUTCA3 OUTCHA OUTC1X OUTCH2
C00233 00030	OUTCH1 OUTC1A OUTC1Y OUTC1Z OUTC1C OUTC1B
C00236 00031	ADJHP QUOTHP ADJHP2 ADJHP1 ARROUT
C00238 00032	PUTCHI PUTCI1 TTIOUT PUTCHO PUTCRX FILNCR PUTNLC PUTCRS PUTCO1
C00243 00033	GETCHR GETCHY
C00245 00034	GETCHA GETCHB GETCO1 GETCO2 GETCO3 GETCHO GETCH2 GETCH1 PUTCI0
C00250 00035	SETBF TSETBF SETBFI SETBFT SETBF4 SETBF3 SETBF2 SETBFO SETBF0 SETBF9 SETBF8
C00254 00036	 SPCHEK SPACTN ALLSPA SPOUT BNQUOT BREAKB SPHPOS FCSBRK ECHSUP SPBKDS LETTER NUMBER ARRBIT BNSPCL BNFRCM BNARGS LNUMBT SPCBTS SUPBTS SUPCCR SUPSCM EMODE BSACT ALLACT SUPERS SUPACT SUPEOL SUPSOM SUPLFE SUPCT SPCMOD SPCACT TTPOP
C00260 00037	SPCTAB SPCRLF
C00266 00038	CTLV1 TTYUUO TTUUOL MCMSKP
C00269 00039	CLRBUF CLRBU3 CLINED CLINE2 INSKIP INSKI2
C00273 00040	INCHS3 INCHSL INCHRS INCHS2 INCHSY INCHW0 INCHWL IWAIT0 IWAIT INCHGT INCHG1 INCHGB RDLINE RDLIN2 RDLIN4 RDLIN5 RDLIN3 RDLIN6
C00281 00041	INCHRW ONEOUT
C00283 00042	GETLIN GETLN1 GETLN2 GETLN5 GETLN4 GETLN3
C00285 00043	SETLIN SETLN1 SYNCHK SYNCH2 SYNCH3 SYNCH1 SYNCH4 SYNCH5 SYNCHA
C00289 00044	SETACT STACT1
C00291 00045	OUTFIV FIVOU2 FIVOU1 FIVOUT FIVOU3 FIVOU4
C00294 00046	NULMES TTYMES NULME1 TTYMS7 TTYMS1 TTYMS0 TTYM00 TTYMSA NULME2 TTYMS3 TTYMS4 TTYMS5 TTYMSD TTYMSW TTYMS8 NULME5 TTYM9A NULME4 TTYMS9 NULME3 DPYMS1 DPYMS2 DPYMS3 DPYNUL DPYNU2
C00305 00047	REQSPW TTREAD TTRED2 TTRED3 MCREAD
C00314 00048	TTYJOB TTYJNO TTYJN1 TTYJN0 PTYJNO PTYJN1
C00316 00049	SNEAKX SNEAKS SNLD1 SNLOAD SNEAKY SNEAKW
C00319 00050	ACTCHR
C00320 00051	DDTIN DDTINA DDTINB DDTIW XFRIN XFRIN1 XFRIN2 UNSUPR XFRIN0 DDTCNC
C00323 00052	DDTOUT DDTWAT OUTSTR DDT3
C00326 00053	SCNDSP TTYIN TTYIN2 TTYIN3 TTYIN1 TTYSKP TTCKUU TWSYNC TWSYN2 TWSYN1 TWSAVE
C00332 00054	MONUS8 MONUSR MONUS1 MONUS9 MONUS2 MONUS3 MONUS5 MONUS6 MONUS7
C00338 00055	TTYOUT - OUTPUT UUO
C00340 00056	USRMON USRMN1 USRMN2 USRMN4 USRMN5 USRMN3 TTOUWS
C00345 00057	KIMINT KIMNOP KIMDKB KIMDSM
C00349 00058	DKBINT DKBBEG DKBCLK TKKBRT DKBSPC DKBSP2 DKBLUZ DKBBYT
C00353 00059	DKBTBL
C00356 00060	SCNINT SCNIN2 SCNIN1 CTYINT CTYOU1 DTXMT1 DTRCV1
C00358 00061	DCASER
C00360 00062	SERDAT DCASTB DCABAU DCABKY DCASPD DCATAC DCALIN
C00362 00063	K10CS K10RTN K10REP K10PIR K10TST K10EN K10IAK K10PI K10CS1 AS.NLB AS.BKO AS.1SB AS.BSO AS.ECH AS.PEN AS.REN AS.RTS AS.DTR AS.NDB AS.SYN AS.ODD AS.RCL AS.XCL AS.DSC AS.DSR AS.CAR AS.FER AS.PER AS.OER AS.RDA AS.THRE ASTWAT
C00366 00064	DLNTAB DLNTYP DCATYP DLNPKU DCAPKU DCAPK1 DLNHNG DCAHNG DCAHN2
C00372 00065	PORTDN DCAINT DCATST ASTIN1 DCARCV DCAERR DCARC2 DCALE2 DCALED DCASPW DCARC1 DILRCV DCAXMT DCAXM1 DCAXM2 DCAXM3 NORPLY NOPORT
C00390 00066	HERE TO HANDLE MODEM CHANGE INTERRUPT (DATA SET INTERRUPT)  ASTDSI ASTDI2 ASTDI9 ASTDI7 TGREET TGREE2 TGREE3 TGREE ASTDIE ASTDID ASTDIU ASTDI1 ASTD11 ASTD13 ASTD14 ASTD15 ASTDIR
C00401 00067	 ASTIN3 ASTIN4 ASTIN5 ASTIN6 ASTIN7 ASTSPD DCASPY ASTSP1 ASTSP3 ASTDTS ASTSP2 ASTSP4 DCASPS DCASPR DCASPX DCAATT DCADET DCACHK DCAIRM
C00412 00068	HIBAUD LS110 LS134 LS150 LS300 LS600 LS1200 LS1800 LS2400 LS4800 LS9600 LS1512 LS55 LS75 LSEXT LS1218 SPDNAM NUMSPD DLSSPD ABRFIN ABRTAB ABRNORM ABRIDL ABRDET AB110A AB110B AB134A AB134B AB300A AB150A AB150B
C00416 00069	DCA.Speeds NDCAGP CR1STD CR1NUL CR1TAB CR2STD CR2NUL K0.EXT K2.EXT CR2TAB
C00422 00070	ASTRD0 ASTWR0 ASTRD2 ASTWR2 ASTRD4 ASTWR4 ASTRD6 ASTWR6 ASTRED ASTWRT ASTPRT KBDCHK KBDCH2
C00427 00071	DCAINI DCAIN1 DCAIN3 DCAIN2 DCA3MN DCA2MN DCA1MN DCANOW DCAHGL DCAHGN
C00432 00072	DLSCLR DLSHLD DLSRST DLSRCF DLSDTR DLSCD DLSRI DLSDLB DLSNOX
C00435 00073	DLSINI DLSII2 DLSSPS DLSINT MCKRCV MCKNOI MCTBLS MCKDWN MCKDTP MCKDNT MCKDMT MCKDNM MCKSPC MCKSP2 NODLSP DLSIN1 DLSMDM DLSTYP
C00447 00074	MCKBYT MCKTBL NMICKS
C00454 00075	SCNBU2 SCNBU4
C00456 00076	 RECINT RECITY RECINC NOESC ESCRET PTYTST
C00459 00077	 INIHOM NOLOCK NOLOK2 RECCHK RECFRE RECI00 RECIN0 RECIN1 RCBXIT
C00467 00078	RECIN8 RECINZ RECIM2 NOTDM
C00470 00079	 BKYCHK NOSPMD BKYOFF BKYOK RECINB NOCALL
C00474 00080	RECIN3 RECIN4 SNKWAK UTYPET TYPTST TYPT2 SNKTST
C00477 00081	 CONVRT RECINY NODELH RTILDE RECIMK RECIM3 RECINN RECIN6 RECIM4
C00481 00082	TYPGO2 TYPGO TYPGO3 RWARN TTINT STXTM3 STXTIM STXTM2 STXTMA
C00485 00083	Escape.bits REGESC SPCESC DBLESC ESCNEG ESCTYP ESCARG ESCFLD ESCNUL LSHESC ESCTYP ESCARG ESCFLD ESCNUL LSHESC ESCMAX ESCOCS ESCOCT
C00488 00084	ESCCAL ESCCA5 ESCCA4 BRKCA3 DDQBEE ESCCCK ESCCC2 ESCCOK BRKCAL BRKCA2 DDUNKI DDUNK4 DDUNK0 DDUNK2 DDUNK3 DMESCC DMESP1 DMESCP
C00498 00085	DMMETA DMESC DMBONG TYPDM DMACON DMAMET DMACMT DMACM2 SETESC SETES2 SETES3 STDESC STDES1 STDES2
C00505 00086	DOESC DOESC1 NOESCN DOESC2 ESCXIT ESCDSP DOESTR DOEPLS DOESCN DOESNT DOEPN DOEPRG DOEPR1 DOEPR2 PRESC0 PRESC PRESC2 PRESC3 PRESCW ESCREP ESCRP0
C00514 00087	 SPESC SPESC2 ESCCLR TAKRSP TAKRS2 BRKCLR BRKCL2 BRKCL3 VDESCM VDESM7 VDESM6 VDESM2 VDESCL VDESL2 VDESL3 VDESL1 VDESM1 VDESM3 VDESCR VDESCG VDESM4 VDESM5 VDESMY VDESY2 VDESMX VDESX2
C00529 00088	 VDESCA TVSTRB TVSTR VDESAD VDESCN VDESCD VDESCS VDESS3 VDESS2 VDESN1 VDESCT VDESTV VDEST0 TVTABL VDESCK VDEKMX VDEKNA VDEKUP VDEKU0 VDEKU2 VDEKU3 VDEKUD VDEKU4 VDEKU5 VDEKU6 VDESKN VDEKN0 VDEKN3 VDEKN2 TUNBAS TUNMUL VDEKM VDEKCL VDEKC2 VDEKMT VDEK00 VDESK2 VDESK3 VDESK4 VDESK8 VDESK7 VDEK10 VDEK11 VDES11 VDESK6 VDEKGO VDESKX VDEK9A VDESK9 VDESK0 VDESK5 TVSRCH TVSRC2 TMTURL TMTUCH TMTURS TMTUMX CLKTUN CLKTON CLKTO3 CLKTO4 CLKTO2 CLKTDO CLKTDL TUNDLY CLKTRS TUNLSH TUNEUP TUNOFF TVCHBP TV1CHN TV2CHN TV3CHN TV4CHN
C00564 00089	VDESET VDEST5 VDEST2 VDEST1 VDEST4
C00567 00090	VDECHK VDVCHK TVSTRX VDVCH2 VDVCH0 VDVCH1
C00569 00091	 ASBRKU ASEBNB ASBKUQ ASJOBP ASHANG ASHGBP ASTEMP ASPAGN ASDBEP ASPPUN ASPPUP ASPBUN ASPBUP ASBPDB ASBPDP ASPGDB ASPGDP ASTMPP ASTMPM ASPRMP ASPRMM ASPAGC ASBEPC ASMIKE ASQUIC ASBPTM ASESC ASESC1 ASSEL ASSCN ASSCNL ASSCN1 ASSCLN ASSCB ASSCB1 ASRVRT ASRVR2 ASRVR3 ASRVR4 ASRVR1 ASSCTO ASSCT1 ASSCT2 ASUNHG ASUNHR BREAKU BRKU1 ESCB ESCB1 CENSOR
C00583 00092	PKINTB PKPAGE PKSET PKCLR PKINT PKINL PKINLB PKINL1 PKINLA PKINP PKINND PKINN0 PKINN4 PKUNPU PKUNPG PKINN2 PKINN1 PKINN3 PKINNP
C00588 00093	ADSMAP ADSPHY ADSMAP ADSPH2 ADSRE1 ADSMP4 ADSMP1 ADSMP2 ADSMP5 ADSMT ADSMT1 ADSMT3 ADSMT6 ADSMT4 ADSMWT ADSMW1 DDIICK DDIIC2 ADSMRD ADSMR2 ADSMR1  ADSMAP ADSPHY ADSMAP ADSMP0 ADSPH2 ADSRE1 ADSMP4 ADSMP1 ADSMP2 ADSMP5 ADSMT ADSMT1 ADSMT3 ADSMT6 ADSMT4 ADSMWT ADSMW1 DDIICK DDIIC2 ADSMRD ADSMR2 ADSMR1
C00601 00094	ADSRES ADSRE2
C00603 00095	BEEP BEEPJB BEEP1 BEEPHY BEEPNV BEEPTX BEEPDX BEEPAW BEEPNP BEEPU BEEPND BEEPN2 BEEPN3 BEEPDM DMBDUN
C00610 00096	TYPX COMSET
C00612 00097	TTED02 TTED03 TTEDIT TTED01 TTED04 TTEDT2 TTED00 TTEDT3 TTEDT0 TTEDT1 TIPACK TTIPUT TTIPT1 TTPT2 DUPLEX DUPLX2 TINSLF INBFUL
C00622 00098	 AOJDPX DUPLX1 DUPIML DUPKIL DUPNVT DUPNV1 DUPNV2 DUPLA DUPLA0
C00625 00099	CONTC CONTC2 CONTZ CONTOB CONTO CONTU CONTU1 ALTMOD CONTS CONTQ TTYUNH
C00630 00100	RUBOUT RUBOU2 WRDRB1 WRDRUB RUBOU1 RUBOU3 RUBOU4 RUBOU5 DELWRD DELWR1 DELWR0 DELWR2 DELWR3 DELWR4 CLKRUB DELBAK DELBK2 DELBK5 DELBK3 DELBK9 CONTK CONTL SIMFF CONTI1 SIMFF1
C00639 00101	 BAKNXT BAKNX1 DOBKNX BNNNUL DOBKNO ECHBEL BNNUMB BNNEG DOQUOT WHOITY WHOIT3 WHOIT2 BNFILE BNWHO FORCEA FORCEC FORCE1 FORCER BNN BND BNC BNM BND1 BND2 BND3 BNL
C00648 00102	CONTI CONTI2
C00650 00103	CRLFEC CHPOPJ CNTLEC CRLF CRLFIP CRLFMM
C00653 00104	CNCTST CNCTS1 CNCMOD
C00655 00105	BSECHO DCPUTR DELETL BNCTLR LINSCN BNCTR1 BNCTR2
C00659 00106	DOTALK TLKDPY TLKBN1 DOTAL1 NOBELL DOTAL3 DOTAL2 TLKBN
C00663 00107	NOTALK NOTAL1 NOTAL2 NOTLKA NOTAL3 NOTLKB NOTLKC CLKBYE CLKBY9 CLKBY8 CLKBY1 CLKB11 CLKB12 CLKBY2 CLKBY0
C00670 00108	XMTINT XMTIN1 NODPY2 XMTI1A DPYST2 DPYST3 DPYSTR DPYDON
C00675 00109	 XMTIN5 XMTIN4 XMTIN6 XMTIN2 LINDON TTYPE WAKTJB
C00679 00110	TYPL TYPDM2 TYPL1 CTYTYP SCNTYP SCNTY1 SCNTY2 PAUCHK PAUCH2 PAUCH3
C00684 00111	 PTYGET PTYGE1 PTCKDM PTOCK PTOCK1 PTINTC POPJJ PTICHK PTCHK2
C00688 00112	TTYRST PTYCL2 PTYCL1 PTYUUO PTYUU3 PTYUU2 PTYUU4 LINMAP PTOCNT PTSTOR PTIFRE
C00693 00113	 PTYREL PTYRL2 PTYRL0 PTYRL4 PTRD1S PTRDS3 PTRD1W PTRD1A PTWAIT
C00697 00114	 PTWR1S PTWR1A PTWR1B PTWR1C PTCALL PTWR1D PTWR1W PTRDS PTRDS0 PTRDS6 PTRDS4 PTRDS5 PTWRS7 PTWRS9 PTWR2
C00705 00115	PTJOBX PTJDIR PTJDIS PTJTAB
C00707 00116	NOTOK PTJHLT HLTOK PTJCON NOCONT PTIWTS PTIWT1
C00709 00117	PTCLRB PTDON PTDOFF PTLOGN PTLGN0 PTLGN1 PHNDET PTDET
C00711 00118	DILDS1 DILDS0 DILBSY DILOK DILDSS DILVMD DILPWR DILCLR DILHUP DILENB DAREA VDI103 NDILIM DILINI DILIN DILINL DILTRL DILTR1
C00714 00119	DILER0 DILER1 DILER2 DILER3 DILER4 DILER5 DILER6 DILER7 DILER8 DILERR DILSTT DIAL DILDIS MXDLCD DILGET DILTTY DILOWN DILSTA DILSTG DILDIL DILDI2 DILDI3 DAREAL DILDI4 DTELEL DILEP5 DILEP7 DILPUT DILHNG DILREL RELDIL DILSLP DILGO DLRTO DLRTO2 DLRTO3 DLRTO4 DLRTOU
C00731 00120	VDITMO VDIOK VDIINT VDIIN2 VDIIN3 VDIIN4 VDIWAK
C00736 00121	DILSTA DILDIL DILWAT DILHNG DILREL RELDIL
C00739 00122	DILINT DILXIT DILKIL DILXT1 DILING DILIN0 DILIN1 DILACT DILERP DILERT DILLUZ DILRUN
C00743 00123	 TTYSET EXPTTY TTYDDL TTYDD0 TTYOPM TTYNDB TTYDD1 TTYDD2 TTYDDE TTYDE2 MINUS1 NODBOK TTYOP LTTYOP TTWID TTESC TTESC2 NOCCR NOCCR0 NOCCR1 NOCCR2 ZERBUF NOCCR4 NOCCR3 GETHP GETHP3 TTYSTO TTYSTN GTLNCH GETHP2 GETWID LINSET LINCLE STIOS CLIOS GTIOS DMDIDL GDPHGT SDPHGT SDPWID GETRSP GETHID GETDMF GTCDPY GETGAG SETGAG GTTGAG STTGAG GETCVT SETCVT GETPSW SETPSW GETGLA SETGLA GETDEL SETDEL SETIMP SETDM SETDPT SETDPL SETDPP SETDPB SETDPN DPMSKM GETDPT SETSPD GETWHO SETWHO GETPAD SETPAD GETBAU SETBAU GTNESC GTNES1 GTNES2 STNESC GTNEDT STNEDT GTHTOG STHTOG GTQMOD STQMOD GTLNBT GTEXST STEXST GTDPDS STDPDS
C00783 ENDMK
C⊗;
;Documentation and Caveats
BEGIN TTYSER - SCANNER, KEYBOARD AND CONSOLE TELETYPE SERVICE ROUTINE
SUBTTL TTYSER - DEC MOD D. POOLE MOD R. HELLIWELL MOD M. FROST MOD B. HARVEY

COMMENT ⊗  (titles below are for E)
Documentation:
and:
Caveats:

Any general rules for programming TTYSER should be listed here.

--The TTY scanner's PI channel should be turned on and off only with the
OFFSCN and ONSCN macros.  This applies to ANY piece of the system, running
in ANY PI channel.  Otherwise, the channel might get left on after exiting
some routine that does its own PI control, even though the scanner's
channel was off upon entering that routine.

--Under FTMONCIP, when a monitor command runs a user program, the cell
MONCIP(DDB) is set with the RH containing the value of TITCTR(DDB) (just
before the command is read) backed up one char and the LH containing -1 if
CLKSER suppressed skipping to the break char (SKPBRK).  This allows us to
preserve the actual monitor command line in the input buffer in case
either the command gets delayed (e.g., no core) or the user program wants
to do a RESCAN to reread the command.  Thus a RESCAN can work even if the
monitor command is longer than the input buffer.  However, in that case,
the RESCAN will not return the proper number of rescanned characters.
Also, multiple RESCANs still will not work.  To make this work,

	EVERY TTY INPUT UUO MUST CALL MCMSKP

to skip over the remaining part of any leftover monitor command before
actually trying to read a character; otherwise the UUO might get
characters left over from the monitor command line.  Also,

	WHENEVER TPMON IS BEING TURNED ON, MCMSKP MUST BE CALLED

to insure skipping the remains of any previous monitor command before
any new monitor command is read.


SETTING TTYIOW

Any routine that sets TTYIOW should call TWSAVE immediately thereafter, in
order to make sure that BREAK . works to restore the TTY to user mode in
the proper wait state.  Calling TWSYNC is sufficient, since it calls
TWSAVE itself.

end of comment ⊗

;SCNSER IS ORGANIZED(?) INTO THE FOLLOWING SECTIONS

;	I.	COMMENTARY ON OPERATION AND DATA STRUCTURES
;      II.	SYSTEM INITIALIZATION ROUTINE - SCNINI
;      III.	COMMAND LEVEL ROUTINES
;			A. TTYATT
;			B. TTYCOM
;			C. TTYDCM
;			D. TTYDET
;			E. TTYFND,TTYFNU
;			F. TTYKIL
;			G. TTYSET
;			H. TTYSRC
;			I. TTYSTR
;			J. TTYTLK
;			K. TTYUSR
;     IV.	UUO LEVEL ROUTINES
;			A. DDTIN
;			B. DDTOUT
;			C. TTYUUO
;			D. TTYIN
;			E. TTYOUT
;	V.	INTERRUPT SERVICE ROUTINES
;			A. CTYINT
;			B. SCNINT
;			C. RECINT - ALL LINES RECEIVER INTERRUPT
;				1. TTEDIT - EDITS AND ECHOS
;			D. XMTINT -  TRANSMIT INTERRUPT
;				1. GETCHR
;				2. TYP
;	VI.	PSUEDO-TELETYPE SERVICE ROUTINES
;			A. PTYGET
;			B. PTYCLR
;			C. PTYUUO
;DATA STRUCTURES AND PARAMETERS

;	DEFINED ON CONFIGURATION TAPE
;		SCNLIN=OCTAL NO. OF SCANNER LINES (0 THRU SCNLIN-1)

;	DEFINED BELOW
;		TRANSLATOR TABLE PARAMETERS
;		TTYLEN=SCNLIN+DPYNUM+1	LENGTH OF TTY TRANSLATOR TABLE (INCLUDING CTY)
;		TTYTAB:	BLOCK TTYLEN	TTY TRANSLATOR TABLE
;			SIGN BIT=1 IF COMMAND JUST TYPED
;			BIT 1 = 1  IF DELAYED COMMAND
;			BITS 5-10 = UNUSED
;			BITS 11-17=TALK RING LINE # (PTALK)
;			BITS 18-35=ADDR. OF DEVICE DATA BLOCK 
;				FOR THIS LINE.
;		DEVOPR:	0	SIXBIT PHYSICAL NAME OF OPERATORS
;				CONSOLE SET BY SCNIN0 TO FIRST
;				ACTIVE TTY.

;	DEFINED BELOW
;		LINE NUMBER PARAMETERS
;		TCONLN=SCNLIN	CTY LINE NUMBER
;		MTTYLN=-TTYLEN	-LENGTH OF TRANSLATOR TABLE
;		FSNCHN=SCNCHN*101	CHANNEL ASSIGNMENT FOR
;				FULL DUPLEX SCANNER
;		TTYLST=TTY0DB	FIRST TTY DEVICE DATA BLOCK

;TTY DEVICE DATA BLOCK FORMAT

;THE FOLLOWING ARE DEFINITIONS OF THE RELATIVE LOCATIONS OF THE
;BUFFER PARAMETER WORDS OF THE DEVICE DATA BLOCK FOR EACH BUFFER, WITH
;TTX'BUF AS THE BASE (DETAILED DESCRIPTIN IN SCNDDB COMMENTS):

	XP BUF,0	;nbr of bytes in buffer,,address of first word of buffer
	XP ↑PUTR,1	;byte pointer to last character placed in buffer
	XP PCTR,2	;number of bytes from PUTR to wraparound point
	XP ↑TAKR,3	;byte pointer to last character removed from buffer
	XP TCTR,4	;number of bytes from TAKR to wraparound point
	XP ↑FCTR,5	;number of free bytes in buffer (between PUTR and TAKR)
	XP TSYNC,6	;number of activated chars in (input) buffer


;		DEVNAM:	PHYSICAL DEVICE NAME SET UP DYNAMICALLY
;			VIA SCNIN0.
;		DEVCHR:	STANDARD DDB DATA
;			BITS 25-35=MONITOR BUFFER SIZE + 1(BYTE POINTER=PDVBLN)
;USRB IRMA TPMON DDTM TTYDTC PTLIP TOIP SYNC KILREQ TTYHLD SNKWAT TTYIOW IOSUPR BKSP NOECHO NOECHB MERTP1 MERTPO

;IOS BITS
;	DEVIOS:	LEFT HALF
;		1,2,4,20,40 ARE STANDARD; 10 IS RESERVED FOR SYSTEM
		↑USRB←←100	;SET TTY TO USER MODE
				;WHEN OUTPUT FINISHES
				;TILL NEXT INPUT OR INIT (↑O).
		↑IRMA←←200	;AWAITING OUTPUT INTERRUPT FOR HUNG CHECKER
		↑TPMON←←400	;TTY IS IN MONITOR COMMAND MODE
		↑DDTM←←1000	;DDT MODE  (*SAME BITS EXISTS ALSO IN TTYBTS*)
		↑↑TTYDTC←←2000	;TTY DDB IS DETACHED FROM LINE
		↑PTLIP←←4000	;PTLOAD IN PROGRESS, BUFFER USER TYPEIN
		↑TOIP←←10000	;TYPE-OUT IN PROGRESS
				;TAKER IS BEHIND PUTR
		SYNC←←20000	;BREAK CHARACTER SEEN
				;SIGNAL TO INCREMENT SYNC COUNT
				;FOR BUFFER INVOLVED
		KILREQ←←40000	;CLK REQ IN FOR TTYKCL TO KILL THIS TTY DDB
		↑TTYHLD←←100000	;TYPEOUT HOLD (BO)
		↑SNKWAT←←200000	;SNEAK PREVIEW WAIT FLAG! (*EXISTS ALSO IN TTYBTS*)
		↑TTYIOW←←400000	;TTY INPUT WAIT BIT (CALL TWSAVE AFTER SETTING THIS)

;	RIGHT HALF BITS (USER MODE)
		↑↑IOSUPR←←1000	;SUPPRESS ALL OUTPUT
		BKSP←←100	;FULL CHARACTER SET. PASS
				;ON ALL CHARACTERS EXCEPT ↑C
				;NO SPECIAL CHARACTER PROCESSING
		NOECHO←←200	;ECHO SUPPRESSION REQ BY PROGRAM
		NOECHB←←400	;SUPPRESS ECHO OF CTRL BITS
		MERTP1←←2000	;DURING ERROR TYPEOUT THIS MEANS
				;THE INPUT BUFFER IS IN USE.
		MERTPO←←IOIMPM	;MONITOR ERROR TYPE-OUT
;	DEVSER:	STANDARD
;	DEVBUF:	STANDARD
;	DEVIAD:	BITS 6-12=HORIZONTAL POSITION (BYTE
;			POINTER = PHPOS).
;		BITS 13-35 ARE STANDARD.
;	DEVOAD:	BITS 0-8=NUMBER OF CHARACTERS TO FIT
;			;INTO OUTPUT BUFFER
;			(POINTER= PFITCH)
;		BITS 13-35 ARE STANDARD
IFNDEF FTDDTM,<FTDDTM←←-1>	;NON-ZERO TO INCLUDE CALLI DDTIN,OUT
;DISLIN CTYLIN TTYFIL DMLIN DDDLIN PTYLIN SUPER2 TLKRNG XON FULTWX TBXPND FCS ROBTPD SPCBRK PTYUSE PTYWAK IMPBIT ECHARR LGLSET KILMSK MTTYLN FSNCHN KENA KCLEAR KMISSED KREQ BNLFLG DELHBT DELBNO BNPEND GAGTBT GAGTNO GAGBIT GAGBNO CVTBIT CVTBNO PSWBIT PSWBNO GLASSB GLASBN BNCNTL BNCTBN BNMETA FCMBIT

;LINE BITS, LINE # DEFS -- DEFINITION OF LINE CHARACTERISTICS TABLE, IMLHAC BITS
;LINTAB MADE BY SYSTEM BUILDER.  FOLLOWING IS FORMAT AS SET UP BY SCNINI:
;	BITS,,LOGICAL LINE#

↑DISLIN←←400000	;THIS LINE IS TO A DISPLAY KEYBOARD
↑CTYLIN←←200000	;THIS "LINE" IS CONSOLE DEVICE "TTY"
↑TTYFIL←←100000	;THIS LINE IS IN "FILL" MODE
↑DMLIN←←40000	;DATAMEDIA DISPLAY ON THIS LINE (Temporarily a permanent bit)
↑DDDLIN←←20000	;DATA DISK DISPLAY LINE
↑PTYLIN←←4000	;PSEUDO-TTY.
;2000		;UNUSED (FORMERLY IMLAC LINE)
	;ABOVE ARE "PERMANENT" CHARACTERISTICS

;The following bit is not in the line characteristics word, but must be
;different from the bits representing display lines.  It is used in DPLED in
;DPYSER to avoid erasing non-initialized line editor under certain conditions.
↑SUPER2←←100000	;Must be different from DISLIN, DMLIN, DDDLIN, IMLIN.

↑TLKRNG←←1	;THIS LINE CURRENTLY IN A TALK RING
XON←←2		;non-dpy: don't insert LFs; dpy: don't echo inserted LFs
↑FULTWX←←4	;ON FOR SELF ECHOING FULL DUPLEX (UNUSUAL)
↑TBXPND←←10	;EXPAND TABS (SOMETIMES PERMANENT SOMTIMES CHANGEABLE)
↑FCS←←20	;FULL CHAR SET MODE
ROBTPD←←40	;RUBOUT TYPED LAST (ECHO \ BEFORE NEXT CHAR.)
SPCBRK←←100	;SPECIAL ACTIVATION MODE... EVERYTHING EXCEPT LETTERS AND NUMBERS IS A  BREAK CHAR.
↑PTYUSE←←200	;PTY LINE IN USE... DO NOT KILL DDB AT TTYKIL.
PTYWAK←←400	;SAYS PTY INPUT WAIT MAY BE TERMINATED BY TTY INPUT.
↑IMPBIT←←1000	;THE GUY ON THE OTHER END OF THIS PTY IS AN IMP
↑ECHARR←←10000	;BH 4/27/75 ECHO UPARROW MUMBLE FOR LESS THAN 40

	;ABOVE ARE TEMPORARY BITS, TURNED ON AND OFF BY VARIOUS MEANS
	;(BY MONITOR, TYPE-IN COMMANDS, OR PROGRAM)

;BITS BELOW (LGLSET) CAN BE SET OR ZEROED BY PROGRAM
LGLSET←←TBXPND!TTYFIL!FCS!XON!SPCBRK!PTYWAK!FULTWX!ECHARR
KILMSK←←ROBTPD!TLKRNG!XON!SPCBRK!PTYLIN!PTYWAK!IMPBIT!TBXPND!TTYFIL!FULTWX ;CLEARED AT TTYKIL

;THESE ARE INSERTED HERE BECAUSE THEY AREN'T DEFINED ANYWHERE ELSE IN THIS SYSTEM.
GLOBAL TTPLEN,HOMEPT	;STUPID FAIL
MTTYLN←←-TTPLEN	;MINUS NUMBER OF TERMINALS, TOTAL
FSNCHN←←SCNCHN*101 ;SCANNER PI CHANNEL ASSIGNMENTS

IFN FTKIM,<
; THESE ARE THE CONO/CONI BITS FOR THE KIM PARALYSER INTERFACE:
; CONO BITS

		; PIA IS LOW ORDER 3 BITS (33-35)
KENA←←10	; ENABLE INTERRUPTS
KCLEAR←←20	; CLEAR "DATA MISSED" FLAG

; CONI BITS

		; PIA IS LOW ORDER 3 BITS (33-35)
;KENA←←10	; ENABLE INTERRUPTS
KMISSED←←20	; DATA MISSED FLAG
KREQ←←40	; INTERRUPT REQUEST
>;IFN FTKIM

;BITS IN IMLHAC WORD IN DDB (ALL BITS NOW IN USE!):
;IMLHAC right half:
BNLFLG←←1	;FLAG TO READ NEXT CHAR FOR ↑←L
↑DELHBT←←2	;FLAG TO INTERCHANGE 010 AND 177 TO ALLOW ASCII BS KEY FOR RUBOUT
DELBNO←←=34	;BIT NUMBER FOR DELHBT, MUST AGREE WITH ABOVE
;0,,001774 BITS ARE TTY WIDTH
BNPEND←←2000	;↑← HAS BEEN TYPED, NEXT CHAR IS SPECIAL COMMAND
GAGTBT←←4000	;TEMPORARY GAG BIT CLEARED BY RESET (TTYRST)
GAGTNO←←=24	;MUST AGREE WITH ABOVE
GAGBIT←←10000	;TTY GAG MODE
GAGBNO←←=23	;MUST AGREE WITH ABOVE
CVTBIT←←20000	;ON TO PREVENT SAIL/ASCII CONVERSION
CVTBNO←←=22	;"
PSWBIT←←40000	;ON TO TELL PK NOT TO DISPLAY PASSWORD IN I/P BUFFER
PSWBNO←←=21	;"
GLASSB←←100000	;ON TO ECHO RUBOUT AS BS SP BS (TTY GLASS)
GLASBN←←=20	;"
BNCNTL←←200000	;TURN ON CONTROL BIT FOR NEXT CHAR
BNCTBN←←=19	;BIT NUMBER
BNMETA←←400000	;TURN ON META BIT FOR NEXT CHARACTER
		;MUST BE ONE TO THE LEFT OF BNCNTL
;IMLHAC left half:
;003777,,0 BITS ARE THE REMEMBERED JOB NUMBER FOR ↑←W
;374000,,0 BITS ARE THE FORCED COMMAND INDEX
FCMBIT←←400000	;FORCED COMMAND IN PROGRESS (MUST BE SIGN BIT)
;DEFWID BEEPBL LINE HPOS IDLECH PFITCH PHPOS PTTYWD GAGTPT GAGBPT CVTBPT PSWBPT GLABPT FCMBPT FCMTBP FC2BPT BNBBBP IMARGS ARGBPT DELBPT PTALK CHRESC NUMESC SGNESC PLASTC PCOMIC PLSTLC

DEFWID←←=80		;Default TTY width
IFN FTGRIN,<
BEEPBL←←3		;Visual beep: Number of times to flash WHO line
>;IFN FTGRIN

	;SPECIAL SYMBOLS

;	SCNON←←1B25!1⊗(7-SCNCHN)
;	SCNOFF←←1B26!1⊗(7-SCNCHN)

	IDLECH←←1		;DELAY CHAR FOR TABS, ETC.
				; SHOULD BE ↑V, BUT FOR 37'S


;BYTE POINTERS

PFITCH:	POINT 9,DEVOAD(DDB),8		;NR OF CHARACTERS TO FIT
↑PHPOS:	POINT 7,DEVIAD(DDB),12		;HORIZONTAL POSITION
↑PTTYWD:POINT 8,IMLHAC(DDB),33		;TTY CARRIAGE WIDTH
GAGTPT:	POINT 1,IMLHAC(DDB),GAGTNO	;TEMPORARY GAG BIT
GAGBPT:	POINT 1,IMLHAC(DDB),GAGBNO	;TTY GAG BIT
CVTBPT:	POINT 1,IMLHAC(DDB),CVTBNO	;SAIL-ASCII NO CONVERSION BIT
PSWBPT:	POINT 1,IMLHAC(DDB),PSWBNO	;TELL PK NOT TO DISPLAY PASSWORD
GLABPT:	POINT 1,IMLHAC(DDB),GLASBN	;TTY GLASS, ECHO RUBOUT AS BS-SP-BS
↑FCMBPT:POINT 6,IMLHAC(DDB),6		;FORCED COMMAND NUMBER
FCMTBP:	POINT 6,IMLHAC(TAC),6		;DITTO BUT FROM TAC
↑FC2BPT:POINT 7,IMLHAC(DDB),6		;FORCED COMMAND NUMBER AND BIT
BNBBBP:	POINT 2,IMLHAC(DDB),BNCTBN	;CONTROL AND META BITS FOR NEXT CHAR
IMARGS←←=11	;Size of argument field below, must hold job number.
↑ARGBPT:POINT IMARGS,IMLHAC(DDB),17	;ARG FOR FORCED CMDS (job number, etc.)
IFG JOBNSZ-IMARGS,<.FATAL Job number field in IMLHAC (forced cmd arg) is too small.>
DELBPT:	POINT 1,IMLHAC(DDB),DELBNO	;TTY-NO-DELETE BIT

↑PTALK:	POINT PUNITS,TTYTAB(LINE),17	;POINTER TO ANOTHER TTY IN TALK RING
					;(SAME SIZE BYTE AS SYS UNIT #)

CHRESC:	PCHRES+LINE,,LSTESC	;LAST ESC CHARACTER (ASCII) FOR PHYSICAL LINE
NUMESC:	PNUMES+LINE,,LSTESC	;LAST (UNSIGNED) ESC ARG FOR SAME
SGNESC:	PSGNES+LINE,,LSTESC	;SIGN BIT OF LAST ESC COMMAND (ON FOR BREAK)

↑PLASTC:
	POINT 7,TTYPTR(DDB),35	; FOR ECHO CHECKING ON HDX LINES
↑PCOMIC:
	POINT 9,TTYPTR(DDB),19	; FOR RESCANNING COMMAND INPUT LINE
				;"COMMAND INPUT COUNTER" SAVES TITCTR
PLSTLC:	POINT 9,TTYPTR(DDB),28	;FOR ↑U DELETION

;TTYPTR CONTAINS THE FOLLOWING BYTES:
;
;	0-10	SPARE
;	11-19	PCOMIC, FOR COMMAND RESCAN
;	20-28	PLSTLC, FOR ↑U
;	29-35	PLASTC, FOR ECHO CHECKING HALF DUPLEX LINES

;APLINE NYLINE LINBIT MXIRMA TERLIN

;		****	****	****
;*** IF LOCALITY OF TTY'S EVER CHANGE, DON'T FORGET TO TELL LOGIN AND ACCESS
;		****	****	****

;For non-DCA TTYs:
DEFINE BITS(X,NAME),<IFDIF<><NAME><↑NAME←←.-LINBIT> X,,0>

;For DCA TTYs:
DEFINE DBITS(X,PORT,NAME),<IFDIF<><NAME><↑NAME←←.-LINBIT> X,,PORT+400000>

;Above args: X is default line characteristics, PORT is DCA port number,
;	     NAME is special name of tty line.

;The pairings of DCA port numbers and TTY line numbers have been set up
;so that, initially, for all TTYs, the TTY line number = the DCA port number.
;However, this need not be maintained; it is just there to make it easier
;to remember the numbers.  The lines below are in order by TTY number,
;with the DCA port number being a parameter of the macros.  At DCATAB in
;CACDAT, the lines are in order by DCA port number, with the TTY number
;being a parameter of the macros.

GLOBAL NPORDM		;GRRRRRR

IFN FTSUAI,<
;Note: Permanent Local DMs' types are defined at DPYDES in CACDAT (DMLIN on here).
↑LINBIT:	
DBITS(FCS!ECHARR,0)			;0 is secret DM split speed (LUCKHAM)
FOR I←1,12 <DBITS(FCS!ECHARR,I)		;1:12 are DM split SPEED
>;FOR
DBITS(FCS!ECHARR,13)			;13 temp for digitized tablet
DBITS(FCS,14,VDILIN)			;14 is Vadic MACS dialer
DBITS(FCS!ECHARR!DMLIN,15)		;15 is LGC leased line
DBITS(FCS,16,APLINE)			;16 is AP (also unresponsible number)
DBITS(FCS,17,NYLINE)			;17 is NYT
DBITS(FCS!ECHARR,20,JMCIML)		;20 was JMC IMLAC
DBITS(FCS!ECHARR,21,RWWIML)		;21 was RWW IMLAC
DBITS(FCS!ECHARR,22)			;22 temp for digitized tablet
DBITS(FCS!ECHARR,23,DIL6TT)		;23 is Racal-Vadic 1200/1200-300/300
DBITS(FCS!ECHARR,24,DIL5TT)		;24 is Racal-Vadic 1200/1200-300/300
DBITS(FCS!ECHARR,25,DIL4TT)		;25 is Racal-Vadic 1200/1200-300/300
DBITS(FCS!ECHARR,26,DIL3TT)		;26 is Racal-Vadic 1200/1200-300/300
DBITS(FCS!ECHARR,27,DIL2TT)		;27 is Racal-Vadic 1200/1200-300/300
DBITS(TBXPND!FCS!ECHARR,30,PNYLIN)	;30 is PONY
DBITS(FCS!ECHARR!DMLIN,31)		;31 is ERL-A, permanent local DM
DBITS(FCS!ECHARR!DMLIN,32)		;32 is ERL-B, permanent local DM
DBITS(FCS!ECHARR,33)			;33 was TI 990 1200
DBITS(FCS!ECHARR!DMLIN,34)		;34 is ERL-C, permanent local DM
DBITS(FCS!ECHARR!DMLIN,35)		;35 is ERL-D, permanent local DM
DBITS(TBXPND!FCS!ECHARR,36,DIL1TT)	;36 is Racal-Vadic 1200/1200-300/300
DBITS(TBXPND!FCS!ECHARR,37,DIL0TT)	;37 is Racal-Vadic 1200/1200-300/300
DBITS(FCS!ECHARR,40)			;40 is "DLN0" (not wired, just software)
DBITS(FCS!ECHARR,41)			;41 is NEC 2400
DBITS(FCS!ECHARR,42)			;42 is NEC 2400
DBITS(FCS,43)				;43 is paper tape punch and reader
DBITS(FCS!ECHARR,44)			;44 is JMC's house
DBITS(FCS!ECHARR,45)			;45 is JMC's house
DBITS(FCS!ECHARR,46)			;46 is JMC's house
DBITS(FCS!ECHARR,47)			;47 is printer at McCarthy's house
DBITS(FCS!ECHARR,50)			;50 is NEC 2400
DBITS(FCS!ECHARR,51)			;51 is NEC 2400
DBITS(FCS!ECHARR,52)			;52 is Frost (030D)
DBITS(FCS!ECHARR,53)			;53 was Robotics 11/45
DBITS(FCS!ECHARR,54)			;54 is N.A. term room (320)
DBITS(FCS!ECHARR,55)			;55 is CTY DM line (alternate CTY)
DBITS(FCS!ECHARR!DMLIN,56)		;56 is Malachi (YM) 2400 TTY in MJH324
DBITS(FCS!ECHARR,57)			;57 is unused (formerly Canon)
REPEAT SCNNUM-<.-LINBIT>,<0>		;REST OF THE UNUSED TTYS (NONE, ACTUALLY)
REPEAT DPYNUM,<DBITS(DISLIN!FCS,DCADP0+.-DPYL0-LINBIT) > ;60:61 ARE III
REPEAT DDNUM,<DBITS(DDDLIN!FCS,DCADP0+.-DPYL0-LINBIT)  > ;62:157 ARE DD
BITS CTYLIN!FCS!TBXPND!ECHARR		;CTY is DEC LA36
REPEAT PTYNUM,<0>			;NOW NEEDED FOR HNGCMD/DPYKIL
;END OF BIT TABLE
;;IFNDEF TERLIN,<↑TERLIN==707070>		;something harmless?
>;IFN FTSUAI

IFN FTCCRMA,<
;Note: Permanent Local DMs' types are defined at DPYDES in CACDAT.
↑LINBIT:	
DBITS(FCS!ECHARR,0)			;00	low speed dialup
DBITS(FCS!ECHARR,1)			;01	1200/150 dialup
DBITS(FCS!ECHARR,2)			;02	1200/150 dialup
;DBITS(DMLIN!FCS!ECHARR,3)		;03	Permanent local DM 2500
DBITS(FCS,3,CANLIN)			;03	is CANON CONNECTION (9600)
REPEAT SCNNUM-<.-LINBIT>,<DBITS(FCS!ECHARR,.-LINBIT)> ;UNUSED TTYS (ife ftgrin)
REPEAT DDNUM,<DBITS(DDDLIN!FCS,.-LINBIT)> ;04-17 (ifn ftgrin) Grinnells
BITS CTYLIN!FCS!TBXPND!ECHARR		;CTY
REPEAT PTYNUM,<0>			;NOW NEEDED FOR HNGCMD/DPYKIL
;END OF BIT TABLE
APLINE←←177	;Irresponsible TTY number for disowned TTYs, unlikely TTY nbr.
>;IFN FTCCRMA

IFN FTLLL,<
;Note: Permanent Local DMs' types are defined at DPYDES in CACDAT.
↑LINBIT:	
DBITS(FCS!ECHARR,0)			;00	Switch Foonly0
DBITS(FCS!ECHARR,1)			;01	Switch Foonly1
DBITS(FCS!ECHARR,2)			;02	Switch Foonly2
DBITS(FCS!ECHARR,3)			;03	Switch Foonly3
DBITS(FCS!ECHARR,4)			;04	Switch Foonly4
DBITS(FCS!ECHARR,5)			;05	Switch Foonly5
DBITS(FCS!ECHARR,6)			;06	Switch Foonly6
DBITS(FCS!ECHARR,7)			;07	Switch Foonly7
DBITS(FCS!ECHARR,10)			;10	GSwitch Foonly10
DBITS(FCS!ECHARR,11)			;11	GSwitch Foonly11
DBITS(FCS!ECHARR,12)			;12	Switch FoonlyX
DBITS(FCS!ECHARR!DMLIN,13)		;13	LRM
DBITS(FCS!ECHARR,14)			;14	Mark I XPATCH
DBITS(FCS!ECHARR,15)			;15	Canon
DBITS(FCS!ECHARR,16)			;16	RT-11 XPATCH
DBITS(FCS!ECHARR,17)			;17	HWL
REPEAT SCNNUM-<.-LINBIT>,<DBITS(FCS!ECHARR,.-LINBIT)> ;UNUSED TTYS
REPEAT DDNUM,<DBITS(DDDLIN!FCS,.-LINBIT)> ;04-17 (ifn ftgrin) Grinnells
BITS CTYLIN!FCS!TBXPND!ECHARR		;CTY
REPEAT PTYNUM,<0>			;NOW NEEDED FOR HNGCMD/DPYKIL
;END OF BIT TABLE
APLINE←←177	;Irresponsible TTY number for disowned TTYs, unlikely TTY nbr.
>;IFN FTLLL

;⊗ TTYINI SCN0 ADSILP NOASIN SCNC1 SCNC2 SCNC3 SCN2 SCN6 NOTPTY SCN3

;TTYINI IS CALLED AT SYSTEM INITIALIZATION TIME FROM SYSINI (IOGO) VIA UUO DISPATCH
;1. CLEARS ALL RECEIVER FLAGS,
;2. CLEARS THE PHYSICAL NAME (DEVNAM) OF ALL UNUSED (TTYUSE=0) TTY DDBS,
;3. SETS DEVIOS TO <TPMON+IOFST,,0> IN ALL TTY DDBS,
;4. SETS TTYUSE=1 IN ALL TTY DDBS IN THE TRANSLATOR TABLE.

↑TTYINI:PUSHJ P,DWPINI		;LET JAM THROW AWAY THE DPY FREE STORAGE
				;BEFORE WE DO OUR BUGEY!
IFE FTLCLDM,<		;Don't clobber permanent DM defaults
	MOVE TAC,DPYDFT		;GET DESCRIPTOR FOR DEFAULT DISPLAY TYPE
	MOVEM TAC,DPYDES
	MOVE TAC,[DPYDES,,DPYDES+1]
	BLT TAC,DPYDES+TTPLEN-1	;INIT ALL LINES TO DEFAULT DPY TYPE
>;IFE FTLCLDM
IFN DILNUM,<PUSHJ P,DILINI>	;INITIALIZE DIALER STUFF
	MOVSI LINE,-TCONLN-1	;REAL TTY'S ONLY
SCN0:	MOVE TAC,LINBIT(LINE)	;GET PERMANENT LINE CHARACTERISTICS
	HRRI TAC,(LINE)		;LINBIT RH USED FOR SOMETHING ELSE NOW
	HRRM TAC,LINTAB(LINE)	;SET LOG. LINE NUMBERS
	IORB TAC,LINTAB(LINE)	;SET SIGNIFICANT BITS
	TLZ TAC,KILMSK		;ZAP INSIGNIFICANT BITS
	IOR TAC,LINBIT(LINE)	;BUT NOT THOSE LINBIT WANTS ON!
	HLLM TAC,LINTAB(LINE)	;LEAVING REST OF BITS AS THEY WERE
	AOBJN LINE,SCN0
REPEAT 0,<
	SETZM DKBBAD		;CLEAR BITS FOR BAD KBD CHARS
	SETZM DKBBAD+1
>;REPEAT 0
IFN FTSUAI,<
	MOVSI TAC,457010	;MAKE BITS TO ENABLE (FROM LEFT) 52,55,57,60,61,62,70
	MOVEI TAC1,0		; WHICH MUST BE BEFORE TTY110
	LSHC TAC,-52		;TTY0 IS WORD 0 BIT 0. MOVE SIGN BIT OF TAC TO TTY52
	DMOVEM TAC,TTYENB	;Alt CTY, Canon, IIIs, KL DD, Tape DD
	MOVSI TAC,400000	;Now enable one more DD, this time beyond 110.
	MOVEI TAC1,0
	LSHC TAC,-120+2*=36	;TTY0 IS WORD 0 BIT 0
	DMOVEM TAC,TTYENB+2	;Enable TTY120 in ME's office
>;IFN FTSUAI
IFN FTCCRMA,<
	MOVSI TAC,400000⊗-5	;Enable TTY5 (Grinnell next to CTY)
	MOVEM TAC,TTYENB
	SETZM TTYENB+1		;Disable the rest
	MOVE TAC,[TTYENB+1,,TTYENB+2]
	BLT TAC,TTYENB+3
>;IFN FTCCRMA
IFN FTLLL,<
	MOVSI TAC,400000⊗-0	;Enable TTY0 (Machine Room DMWAITS)
	MOVEM TAC,TTYENB
	SETZM TTYENB+1		;Disable the rest
	MOVE TAC,[TTYENB+1,,TTYENB+2]
	BLT TAC,TTYENB+3
>;IFN FTLLL
IFN FTKIM,<
	SETZM KIMNHM		; CLEAR ERROR COUNTERS
	SETZM KIMNSM
	CONO KIM,KENA!KCLEAR!KIMCHN ; SET UP THE KIM FOR FIRST OUTPUT
	MOVEI TAC,KREQ		; SET UP CONSZ ALSO
	HRRM TAC,KIMCNI
>;IFN FTKIM

NOKL10,<
	CONO CTY,3600!CTYCHN	;CLEAR CTY, ASSIGN CHANNEL
>;NOKL10
IFKL10,<
	PUSHJ P,DTEINI		;INIT DTE20 FOR MONITOR TTY I/O
>;IFKL10
	PUSHJ P,DCAINI		;INITIALIZE DCA SCANNER
IFN FTDLS,<
	PUSHJ P,DLSINI		;INITIALIZE DLS SCANNER
>;IFN FTDLS
	SETZM TTYTAB
	SETZM COMCNT		;NO COMMANDS TO PROCESS
	MOVE TAC,[XWD TTYTAB,TTYTAB+1]
	BLT TAC,TTYTAB+TTPLEN-1	;CLEAR ALL DDB ADDRESSES
	MOVE TAC,[TCONLN,,TTYLST] ;INIT CTY TO USE MODEL DDB
	MOVEM TAC,TTYTAB+TCONLN
	MOVEI TAC,TCONLN
	DPB TAC,[DDQREQ+TAC,,LSTESC] ;INITIALIZE TTY RESPONSIBILITY FIELD
	DPB TAC,[DDQLNK+TAC,,LSTESC] ;AND PREV RESPONSIBLE TTY
	SETZM PAGNOW
	SETZM ASBTAB		;CLEAR ALL BEEP DURATIONS
	MOVE TAC,[ASBTAB,,ASBTAB+1]
	BLT TAC,ASBTAB+DPYNUM+DDNUM-1
IFN FTF2*FTAS,<
	CONO AS,ASHTAB		;GIVE MICROCODE SOME MEMORY TO PLAY WITH.
>;IFN FTF2*FTAS
	SKIPL TTYLOK
	SKIPE MAINTM
	JRST NOASIN		;DON'T INIT AUDIO SW IF SYS NOT FOR REAL
	SETZM ASTAB
	MOVE TAC,[ASTAB,,ASTAB+1]
 	BLT TAC,ASTAB+DPYNUM+DDNUM-1
IFN FTSUAI,<
;Initialize the TV tuner info
	SETZM TVIBEG		;prepare for clearing BLT
	MOVE AC1,[TVIBEG,,TVIBEG+1]
	BLT AC1,TVIEND		;clear TV tuning arrays, nothing going on/known
	SETOM TUNEIT		;clock level TV tuning routine isn't running
;Now make a temporary audio switch selection for everyone to hear machine room bell
	MOVE AC1,[-<DPYNUM+DDNUM>,,DPYL0] ;aobjn cntr for all DDs and IIIs
ADSILP:	PUSH P,AC1
	MOVE TAC,[0+(765000+ASMIKE),,=80] ;temp sel microphone for 20 secs, no waiting
	PUSHJ P,ADSPHY		;make selection for physical terminal specified
	POP P,AC1
	AOBJN AC1,ADSILP	;loop thru displays with audio
>;IFN FTSUAI
NOASIN:	HRRZS TTYLST+DEVSER	;CLEAR DDB CHAIN
	SETZB IOS,TTYLST+DEVIOS	;SO DDB WILL GET FLUSHED
	MOVEI J,JOBN-1		;REGENERATE DDB'S FOR ALL LIVE JOBS
SCNC1:	MOVE TAC,JBTSTS(J)
	TLNN TAC,JNA		;IS THIS A JOB
	JRST SCNC3		;NO, IGNORE HIM.
	PUSHJ P,BUGTRP
repeat 0,<	;there aren't any jobs yet at SYSINI any more!
	HRRE LINE,JBTLIN(J)	;GET LINE HE IS USING
	JUMPL LINE,SCNC2	;DETACHED LINE
	PUSHJ P,DDBSRC		;GET HIM A DDB
	 JRST SCNC3		;IF NO DDB AVAILABLE OR NO LINE OR DETACHED
	PUSHJ P,TTYATI		;ATTACH JOB
	TLNE LINE,PTYLIN
	SKIPE PTYJOB-PTYL0(LINE) ;IS THIS PTY REALLY ATTACHED TO SOMEONE?
	JRST SCNC3		;YES
	PUSHJ P,TTYDET		;NO, DETACH HIM.
	 JFCL			;TTYDET SOMETIMES SKIPS BUT...
	JRST SCNC3		;NEXT PLEASE

SCNC2:	TLNE TAC,JSEG		;IS IT AN UPPER SEGMENT?
	JRST SCNC3		;YES, NO DDB FOR HIM
	MOVNI LINE,1		;YES, GET A DETACHED LINE
	PUSHJ P,DDBSRC		;GET DDB
	 JRST SCNC3
	DPB J,PJOBN
>;repeat 0
SCNC3:	SOJG J,SCNC1
;GET THE DDB'S FOR THE REST OF THE TTY'S (I.E.,THE ONES NOT ATTATCHED TO JOBS ALREADY).

	MOVSI LINE,-TTPLEN+PTYNUM ;SET DDB USE BITS FROM TRANSLATOR TABLE
SCN2:	MOVSI IOS,600000
	ANDCAM IOS,TTYTAB(LINE)	;NO COMMAND WAITING, NONE DELAYED
	HRRZ TAC,LINE
	CAIGE TAC,PTYL0		;PTY LINE?
	JRST NOTPTY
	PUSHJ P,BUGTRP		;it says we don't do PTYs at SCN2-1!
repeat 0,<
	SKIPN TTYTAB(LINE)	;DOES HE HAVE A DDB
	JRST SCN6
	HRLI TAC,PTYLIN!PTYUSE!XON ;MAGIC PTY BITS
	MOVEM TAC,LINTAB(LINE)	;INITIALIZE THIS PTY
	JRST SCN3		;STUFF IN 0'S

SCN6:	SETZM PTYJOB-PTYL0(LINE)
	SETZM LINTAB(LINE)	;CLEAR PTY BITS
	JRST SCN3
>;repeat 0

NOTPTY:
SCN3:	AOBJN LINE,SCN2
IFE FTF2,<
	MOVEI LINE,PNYLIN	;BH 11/9/78 SPECIAL DEAL FOR PONY TTY
	SKIPN TTYLOK
	SKIPE MAINTM
	CAIA
	PUSHJ P,DDBSRC		;BH
	 JFCL			;BH
>;IFE FTF2
	SETZM LINSAV		;SO INIT. MESSAGE WILL GET TO EVERYONE.
	MOVEI DDB,SCNDDB
	PUSHJ P,DDBSR2		;CLEAN UP THE CTY DDB
	 JFCL			;ALWAYS SKIPS.
	MOVEI TAC,=127
	DPB TAC,PTTYWD		;TTY WIDTH FOR CTY ONLY
	SETOM SCNCNT		;Really init the OFFSCN/ONSCN system
	POPJ P,			;ALL DONE
;TTYCOM TTYCM0 TTYCM1 TTYCM3 TTYCM4 TTCM4A TTYCM5 TTYCM6 TTYCM TTYCND TTYCM2

;ROUTINE TO SETUP AC DDB TO ADDRESS OF TTY WHICH HAS TYPED A COMMAND
;AC DAT TO BYTE POINTER TO OUTPUT BUFFER FOR COMMAND MESSAGES
;AC J TO JOB NUMBER TTY IS ATTACHED TO
;CALL:	PUSHJ P,TTYCOM
;	NONE FOUND
;	AC'S SETUP
;CALLED FROM COMMAND

↑TTYCOM:SETZM FRCFLG		;TURN OFF FORCED COMMAND FLAG
	SKIPGE LINE,LINSAV
	JRST TTYCM1		;GIVE SOMEONE ELSE A CHANCE
	MOVSI LINE,MTTYLN
TTYCM0:	SKIPN TAC,TTYTAB(LINE)
	JRST TTYCM1		;NOBODY HOME
	TRNN TAC,-1		;IS THERE REALLY A DDB?
	JRST TTYCND		;NO! BUG!
	SKIPGE IMLHAC(TAC)	;IS THERE A DELAYED FORCED COMMAND?
	JRST TTYCM4		;YES, DO IT AGAIN
	JUMPL TAC,TTYCM3
	LDB DAT,FCMTBP		;GET FORCED COMMAND NUMBER
	JUMPN DAT,TTCM4A
TTYCM1:	AOBJN LINE,TTYCM0
TTYCM3:	MOVEM LINE,LINSAV
	JUMPG LINE,CPOPJ
	HRRZ DDB,TTYTAB(LINE)
	MOVE DAT,DEVMOD(DDB)
	TLNN DAT,TTYATC		;IS HE ATTACHED TO IT BY JOB?
	TRNN DAT,ASSCON!ASSPRG	;NO, ASSIGNED OR INITED TTY'S CAN'T TYPE COMMANDS
	JRST TTYCM5
	JRST TTYCM2		;(THIS CAN'T HAPPEN (IT SAYS SO IN COMSET))

;HERE WITH DELAYED FORCED COMMAND
TTYCM4:	JUMPGE TAC,TTYCM1	;IGNORE IF COMBIT ISN'T ON -- NOT TIME YET

;At DLYCR2, we delayed this forced command and SOSed COMCNT, with the
;forced command field (and the delayed-forced-command bit) left set; that way
;COMCNT was counted down to zero to avoid needless calls of COMMAND, but that
;made COMCNT disagree with the forced-command field being set, so here
;we need to re-AOS COMCNT for the forced command.  But we would have
;SOSed COMCNT also, since we are clearing COMBIT, so:
;	AOS COMCNT			;For re-activated forced-command
;	SOS COMCNT			;For cleared COMBIT below
;The KILL command, however, has no way of getting the COMBIT turned on
;when the victim is in core, so it wants COMCNT left counted up so COMMAND
;is called every tick; to do that, it avoids calling DLYCR2, which would
;have normally SOSed COMCNT for the forced command.  To get HERE (TTYCM4+1),
;KILL must set the COMBIT or we won't think it's time to retry the delayed
;forced command.  Since here we think we've been to DLYCR2 which SOSes COMCNT,
;KILL must itself SOS COMCNT (although it might also AOS COMCNT if it is
;setting COMBIT to make sure we get here).

	MOVSI TAC,COMBIT	;TURN OFF COMBIT
	ANDCAB TAC,TTYTAB(LINE)
TTCM4A:	MOVEM LINE,LINSAV
	MOVEI DDB,(TAC)
	MOVSI DAT,FCMBIT	;MUST BE 400000
	IORM DAT,IMLHAC(DDB)	;INDICATE FORCED COMMAND IN PROGRESS
	SETOM FRCFLG		;TELL CLKSER THIS IS A FORCED COMMAND
TTYCM5:	MOVEI DAT,TTIBUF(DDB)	;SO GETCHR CAN BE CALLED FROM COMCON
	SKIPE FRCFLG
	JRST TTYCM6		;FORCED CMD -- AVOID CERTAIN THINGS
	MOVE LINE,TITCTR(DDB)
	DPB LINE,PCOMIC		;SAVE COMMAND INPUT COUNTER
IFN FTMONCIP,<
	CAIN LINE,TTICHR	;IS THIS THE FRONT OF THE BUFFER?
	MOVEI LINE,0		;YES, THEN REALLY POINT TO THE BACK
	ADDI LINE,1		;BACKUP TCTR TO PLACE WE DON'T WANT TO PASS
	LDB CHR,PUNIT		;LINE NUMBER
	MOVE CHR,LETAB(CHR)	;SEE IF LINE EDITOR IS WAITING
	TLNE CHR,WTFLAG		;IF NOT, THEN DON'T SET MONCIP
	MOVEM LINE,MONCIP(DDB)	;DON'T LET USER OVERTYPE CMD
>;IFN FTMONCIP
TTYCM6:	LDB LINE,PUNIT		;LINE NO.
	LDB J,PJOBN		;JOB NO. TTY ATTACHED TO
	MOVSI CHR,TTYATC
	TDNN CHR,DEVMOD(DDB)
	MOVEI J,0		;NO JOB ATTACHED TO THIS TTY
	TLNN TAC,DLYBIT!PAUSEB	;IS THIS A DELAYED COMMAND?
	JRST CPOPJ1		;NO, RETURN TO SCAN IT
	MOVSI TAC,DLYBIT!PAUSEB	;INDICATE NO LONGER DELAYED COMMAND
	ANDCAM TAC,TTYTAB(LINE)
	JRST CPOPJ1		;RETURN TO COMMAND SCAN

;HERE FROM DLYCM1 IN CLKSER TO DELAY A COMMAND.  DDB must contain TTY DDB.
↑TTYCM:	SKIPN FRCFLG
	PUSHJ P,TRESCA		;RESCAN TO START OF COMMAND. FIX TISYNC
	SETZM FRCFLG		;SET NOT A FORCED COMMAND
	MOVE LINE,LINSAV	;TRESCN HAS CALLED STLNAC
	JRST TTYCM1		;LOOK FOR OTHER COMMAND TO PROCESS

TTYCND:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /TTYTAB non-zero but no DDB address: TTY /
	MOVE TAC,LINE-17(P)
	PUSHJ P,DISLOC		;PRINT TTY NUMBER
	PUSHJ P,DISMES
	ASCIZ /, TTYTAB = /
	MOVE TAC,LINE-17(P)
	MOVE TAC,TTYTAB(TAC)
	PUSHJ P,DISOCH		;PRINT TTYTAB IN HALF-WORD FORMAT
	PUSHJ P,DISCRLF
	DEBCHECK(POPACS)
	SKIPGE TTYTAB(LINE)
	SOS COMCNT
	SETZM TTYTAB(LINE)	;FIX IT I HOPE
	SYSPIN
	JRST TTYCM1		;LOOK FOR ANOTHER COMMAND

TTYCM2:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /COMBIT on for INITed or ASSIGNed TTY not attached to job.
TTY /
	MOVE TAC,LINE-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /, TTYTAB = /
	MOVE TAC,LINE-17(P)
	MOVE TAC,TTYTAB(TAC)
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /, DEVMOD = /
	MOVE TAC,DAT-17(P)	;GET SAVED DEVMOD
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	MOVSI DDB,COMBIT!DLYBIT!PAUSEB ;CLEAR THESE BITS!
	SKIPGE TTYTAB(LINE)
	SOS COMCNT		;FIX THE COUNT
	ANDCAM DDB,TTYTAB(LINE)
	SYSPIN
	JRST TTYCM1		;LET COMMAND FIGURE OUT THAT COMCNT IS MAYBE NOW ZERO
;TTYATI
;ROUTINE TO ATTACH TTY TO A JOB
;CALL:	MOVE DDB,ADDRESS OF TTY DEVICE DATA BLOCK
;	MOVE J,JOB NUMBER
;	PUSHJ P,TTYATT
;	OK RETURN	;DDB, DAT AND TRANSLATOR TABLE SET

;CALLED FROM COMCON (ATTACH) AND COMCSS (JOBINI).
;ON OK RETURN	1)SETS TTYATC
;		3)PUTS ADDRESS OF ATTACHED DDB INTO DDB.
;		4)SETS PHYSICAL NAME TO SIXBIT /TTY LINE #/
;		  OR SIXBIT /CTY/,
;		5)SETS DEVOPR IF IT IS NON-ZERO.


;COME HERE TO ATTACH TTY IN DDB TO JOB IN J.
↑TTYATI:PUSHJ P,STLNAC		;SETUP LINE
	MOVEM LINE,JBTLIN(J)	;SET LINE # FOR JOB
	DPB J,PJOBN		;SET JOB NUMBER OF OWNER
	MOVSI TAC,SPCBRK
	ANDCAM TAC,LINTAB(LINE)	;TURN OFF NORMAL SPECIAL ACTIVATION MODE BIT
	MOVEI IOS,SPCMOD	;BUT SEE IF SAVED COPY IS ON
	TDNE IOS,ACTMOD(DDB)	;WANT SPECIAL ACTIVATION MODE AFTER ALL?
	IORM TAC,LINTAB(LINE)	;YES, TURN ON NORMAL BIT
	ANDCAM IOS,ACTMOD(DDB)	;TURN OFF SAVED VERSION OF BIT
	MOVSI TAC,TTYATC	;MAKE IT ATTACHED TO JOB
	IORM TAC,DEVMOD(DDB)
	MOVSI IOS,TTYDTC	;MAKE DDB ATTACHED TO TTY
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,
;TTYSUB TTYSBE TTYSB3 TTYSB2 TTYSB0 TTYSB1 TCOMLP TCMNEQ TCMGOT TCMOK TCMER2 TCMERR TCMDLY TCMRET TCMRE1 TCMPOP TCMXIT TCOMND TCOMLN TCOMDS

;"TTY" COMMAND (HERE AT CLOCK LEVEL)

;TTY subcommands are dispatched to with:
; LINE/ target TTY line, set up special by TTY TTYnnn <name> command.
; DDB/ typer's TTY DDB, in case needed for reading more tty input.

↑TTYSUB:HRRZS (P)		;USE STACK AS FLAG.  NO "NO" OR "-" SEEN
	MOVEI AC3,(DDB)		;SAVE OUR TTY DDB AS DEFAULT FOR COMMAND TARGET
	JRST TTYSB1

TTYSBE:	POP P,DDB
	POP P,DAT
	JSP TAC,ERRMES
	ASCIZ /?TTY doesn't exist.
/]				;OOPS, NO SUCH TTY

TTYSB3:	MOVE TAC,TAC1		;THIS IS TTY NAME
	PUSH P,DAT		;GETDDB CALLS TSETBF WHICH SETS DAT
	PUSH P,DDB		;SAVE TYPER'S DDB
	PUSHJ P,UGTDDB		;GET TARGET DDB, SPECIAL LINES OK
	 JRST TTYSBE		;No such TTY
	LDB TAC,PJOBN		;GET OWNER OF THIS TTY
	MOVEI AC3,(DDB)		;SAVE TARGET DDB
	POP P,DDB		;RESTORE TYPER'S DDB
	POP P,DAT
	JUMPE TAC,TTYSB1	;TTY COMMAND OK TO UNUSED TTY
	MOVEI TAC1,(DDB)	;BH 8/5/78 CTY CAN DO ANYTHING
	CAIN TAC1,SCNDDB	;BH
	JRST TTYSB1		;BH
	JUMPE J,TCMER2		;To operate on TTY in use, must be logged
	MOVSI TAC1,DEVPRV	; and either have priv or own the TTY
	CAIE TAC,(J)		;DO WE OWN THIS TTY?
	TDNE TAC1,JB2PRV(J)	;ARE WE PRIVILEGED?
	JRST TTYSB1		;OK, NOW GET THE SUBCOMMAND
	JRST TCMER2		;NO

TTYSB2:	CAIE TEM,"-"		;ALLOW - ALSO
	JRST NOTENF		;NOPE
	PUSHJ P,GETLCCHR	;GOBBLE TO NEXT CHAR SO WE DON'T LOOP
TTYSB0:	HRROS (P)		;FLAG "NO" OR "-" HAS BEEN SEEN.
TTYSB1:	PUSHJ P,CTEXT1		;READ TTY COMMAND
	JUMPE TAC1,TTYSB2
	CAMN TAC1,['NO    ']
	JRST TTYSB0		;FLAG "NO" SEEN
	HLRZ TAC,TAC1		;GET FIRST 3 CHARS TYPED
	CAIN TAC,'TTY'		;IS IT A TTY NAME?
	JRST TTYSB3		;YES, APPLY COMMAND TO THAT TTY IF PRIVILEGED
	MOVE AC1,TAC1		;COPY COMMAND WORD
	MOVNI AC2,1		;SET MASK ALL ONES
	LSH AC2,-6		;CLEAR OUT ONE MORE CHAR.
	LSH AC1,6		;SHIFT 1 COMMAND CHAR OFF
	JUMPN AC1,.-2		;IF NOT END OF COMMAND, GO AROUND
	MOVEI DSER,0		;CLEAR FLAG REGISTER
	MOVSI TAC,-TCOMLN	;SEARCH TTY COMMAND TABLE FOR MATCH
TCOMLP:	CAMN TAC1,TCOMND(TAC)	;EXACT MATCH?
	JRST TCMGOT		;YES, THIS IS IT. (TAC SET WITH INDEX)
	MOVE UUO,TCOMND(TAC)	;GET FULL ENTRY NAME FROM COMMAND TABLE
	TDZ UUO,AC2		;MASK OFF UNSPECIFIED CHARACTERS
	CAME TAC1,UUO		;MATCH UNDER MASK?
	JRST TCMNEQ		;NO. NOT EVEN GOOD MATCH
	TLOE DSER,1		;SKIP IF THIS IS FIRST PARTIAL MATCH.
	TLOA DSER,400000	;DENOTE AMBIGUOUS PARTIAL MATCHES
	HRRI DSER,(TAC)		;DSER ← INDEX OF FIRST MATCH UNDER MASK
TCMNEQ:	AOBJN TAC,TCOMLP	;KEEP LOOKING.
	JUMPLE DSER,TCMERR	;JUMP IF NO MATCHES OR AMBIG. MASKED MATCH
	MOVEI TAC,(DSER)	;GET INDEX TO UNIQUE PARTIAL MATCH
TCMGOT:	PUSHJ P,STLNAC
	TLNN LINE,CTYLIN	;SKIP IF THIS IS CTY.
	SKIPL TCOMDS(TAC)	;NOT CTY.  SKIP IF PRIVILEGED TTY COMMAND
	JRST TCMOK
	JUMPE J,TCMERR		;PRIVILEGED TTY COMMAND REQUIRES LOGIN OR CTY
	MOVSI AC1,DEVPRV
	TDNN AC1,JB2PRV(J)	;ARE WE PRIVILEGED?
	JRST TCMERR		;NO, ERROR
TCMOK:	EXCH DDB,AC3		;GET TARGET DDB
	PUSHJ P,STLNAC		;SET UP LINE FOR TARGET TTY
	PUSH P,DDB		;SAVE FOR POSSIBLE TTYKIL LATER
	MOVE DDB,AC3		;RESTORE DDB (FOR FURTHER COMMAND INPUT)
	PUSH P,DDB		;SAVE TYPER'S DDB TOO, IN CASE ROUTINE CLOBBERS DDB
	PUSH P,[TCMRET]		;PRETEND PUSHJ
	SKIPGE -3(P)		;COPY THE FLAG TO TOP CELL ON PDL
	HRROS (P)
	JRST @TCOMDS(TAC)	;Do it: target line in LINE, typer's ddb in DDB

TCMER2:	SKIPA TAC,[2]		;Error code 2 means type message IN USE
TCMERR:	MOVEI TAC,1		;FLAG TO GO TO COMERA AFTER KILLING DDB
	JRST TCMRE1		;JOIN TCMRET CODE

;TTY subcommand routine should jump here instad of POPJing, in order
;to delay the command until the output buffer has emptied.
;Note that we don't kill the target DDB now (even if not our own) since
;the command should eventually finish and do that then.
TCMDLY:	SUB P,[1,,1]		;Flush return address of TCMRET
	POP P,DDB		;RESTORE TYPER'S DDB
	SUB P,[1,,1]		;FLUSH TARGET DDB FROM STACK
	JRST DLYCM2		;DELAY WHOLE TTY CMD UNTIL OUTPUT BUFFER EMPTY

TCMRET:	TDZA TAC,TAC		;SUCCESS RETURN FROM COMMAND
	MOVEI TAC,1		;FAILURE RETURN, GO TO COMERA LATER
	POP P,DDB		;GET BACK TYPER'S DDB
	POP P,AC3		;DDB TO MAYBE KILL
TCMRE1:	CAIN AC3,(DDB)		;IS IT OUR OWN DDB?
	JRST TCMXIT		;YES, DON'T KILL IT
	PUSH P,DDB		;NO, SAVE OUT TYPER'S DDB
	MOVE DDB,AC3		;MAYBE KILL IT
	LDB AC1,PJOBN		;BUT FIRST SEE IF IT'S IN USE
	JUMPN AC1,TCMPOP	;YES, DON'T KILL IT
	PUSH P,TAC		;SAVE ERROR FLAG
	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,TTYDIE		;KILL QUICKLY A TTY DDB WE MADE
	POP P,TAC
TCMPOP:	POP P,DDB
TCMXIT:	JUMPE TAC,CPOPJ		;EXIT OK IF NO ERRORS
	SOJLE TAC,COMERA	;ERROR CODE 1 MEANS GO TO COMERA
	JRST INUSE		;ELSE GO TO SAY "IN USE"

;DON'T USE "TTY" AS FIRST THREE CHARS OF SUBCOMMAND NAME!

DEFINE TNAMES <
.TMAC ALTBELL,TTALTB		;USE ALTERNATE BELL FORM
.TMAC ALTEMP,TTALTE		;USE ALTERNATE EMPHASIS FORM
.TMAC ALTNEQ,TTALTN		;altmode is at 32 in display's font
.TMAC ALTOTALK,TTATLK		;ALTO TALK PROGRAM DISPLAY
.TMAC AMBASS,TTAMBA		;AMBASSADOR TERMINAL
.TMAC ANSI,TTANSI		;ANSI STANDARD DISPLAY
.TMAC ARROW,TTYARR
.TMAC BEEP,TTBEEP
.TMAC BLINK,TTBOLD		;INVERT LINE EDITOR BLINKINGNESS
.TMAC BOLD,TTBOLD		;  "     "
.TMAC BREAK,TBRK		;DO BREAK COMMAND
.TMAC BRK,TBRK
.TMAC BR,TBRK
.TMAC BS,TTBS			;177 PRINTS ON THIS DM
.TMAC (CHKDCA,1B0+TTCDCA)	;TYPE DCA PORT STATUS, LEGAL ON CTY
.TMAC C1,TC100			;Probably wants C100 display, tell to type more
.TMAC C10,TC100			;Probably wants C100 display, tell to type more
.TMAC C100,TC100		;Probably wants C100 display, tell to type more
.TMAC C100A,TC100A		;CONCEPT 100, TYPE A
.TMAC C100B,TC100B		;CONCEPT 100, TYPE B
.TMAC CONVER,TTYCVT		;ALLOW SAIL-ASCII CONVERSION (DEFAULT)
.TMAC DATAME,TTYDM
.TMAC DELETE,TTYDEL		;DON'T INTERCHANGE ↑H AND 177 (FOR BS)
.TMAC DM,TTYDM
.TMAC DM128,TTYDMX
.TMAC DM2500,TTYDM
.TMAC DM3025,TT3025		;FLAG THIS DM AS A MODEL 3025
.TMAC DM3052,TT3052		;FLAG THIS DM AS A MODEL 3052
.TMAC DMWAITS,TTYDMW		;SPECIAL DM 3025 MODIFIED WITH WAITS KEYBOARD
.TMAC DPTEST,TDTEST		;Set up as a display using patched setup routine
.TMAC ECHO,TTECHO
.TMAC EDIT,EDITCM		;DM HAS AN EDIT KEY
.TMAC (ENABLE,1B0+TTSENB)	;ONLY ON CTY
.TMAC ESCAPE,TESC		;DO ESCAPE COMMAND
.TMAC ESUN,TTESUN		;SUN display with EDIT key
.TMAC EXIST,TTEXS0		;Turn on a formerly dead terminal
.TMAC FILL,FILTTY
.TMAC FULL,TTFULL
.TMAC GAG,TTYGAG
.TMAC GLASS,TTYGLA
.TMAC HANG,HNGCMD		;HANG UP THE PHONE
.TMAC HEATH19,THEATH		;THIS IS A HEATH 19 DISPLAY
.TMAC HIDE,TTHIDE		;HIDE USER TERMINAL
.TMAC HP2648,TT2648		;THIS IS AN HP 2648A DISPLAY
.TMAC HTOGGL,HTOGGL		;NO-EDIT DM SHOULD TOGGLE HOLD
.TMAC INITIALIZE,DPINIT		;RE-INITIALIZE THE DISPLAY
.TMAC LEFTARROW,TTLFTA		;Has left-arrow key
.TMAC NOEDIT,NOEDCM		;NO EDIT KEY DM-TYPE DPY
.TMAC PADBAUD,TTBAUD		;SET BAUD RATE FOR DM PADDING CALCULATIONS
.TMAC PADCHAR,TTPAD		;SET OCTAL CHAR TO USE FOR PADDING DM
.TMAC SAIL,TTSAIL		;Fix DM128 bit (if can display WAITS graphics)
.TMAC SETESC,TTNESC		;SET NOEDIT ESCAPE CHAR
.TMAC SPEED,SPDCMD		;SET SPEED FOR DCA PORT
.TMAC SUN,TTSUN			;SUN DISPLAY without EDIT
.TMAC TABS,TTTAB
.TMAC TELERAY,TTELER		;THIS IS A TELERAY 1000 SERIES DISPLAY
.TMAC TELERB,TTELEB		;TELERAY WITHOUT EDIT KEY
.TMAC TELEVIDEO,TTVDEO		;TELEVIDEO WITHOUT EDIT KEY
.TMAC TEST,TTTEST		;FOR PATCHING NEW COMMANDS
.TMAC TGAG,TTTGAG		;TEMPORARY GAG
.TMAC TIME,TTYTIM
.TMAC UPDATE,TTYUPD
.TMAC VT100,CPOPJ1		;Give error, avoid someone thinking we support VT100
.TMAC VT102,TTV102		;DEC VT102 display
.TMAC W,TTYWHO
.TMAC WAITS,TTSAIL		;Fix DM128 bit (if can display WAITS graphics)
.TMAC WHO,TTYWHO
.TMAC WIDTH,TTYSWD
>

DEFINE .TMAC(A,B)
<	<SIXBIT/A/>
>

TCOMND:	XLIST
	TNAMES
	LIST
TCOMLN←←.-TCOMND

DEFINE .TMAC(A,B)
<	B
>

TCOMDS:	XLIST
	TNAMES
	LIST

	PURGE TNAMES		;RECLAIM SOME SPACE FOR THE ASSEMBLER
;⊗ TTTEST TC100 TTSAIL TTCDCA TTPAD TTPAD3 TTBAUD TTBAU2 TTALTB TTALTE TTALT1 TTBS TTBOLD TTDMST TTALTN TTLFTA TBS XXX TTYADR DTJSP NDTYPS DTNAME DTMISC DTEDPD DTDPYD SETDPY SETDP0 SETDPD SETDPU SETDP1 SETDP2 SETDP3 SETDP4 SETDPX DSETUP DSETU2 DPIMSG SETDPI DPINIT SDMWID SDMWI2 SETDPE TTYNDM TTBEEP FILTTY STOLIN TTECHO TTFULL TTTAB TABCHK TTYARR TTYGLA TTTGAG TTYGAG TTYHAC TTYDEL TTYCVT TTYHA2 SPDCMD SPDCM1 SPDCM2 SPDCM3 BEPHNG HNGCLK QUITCM HNGCLS HNGCMD HNGCMA HNGCMB HNGCM1 CKFONE TTYNOE EDITCM NOEDCM CLRNED NOEDC1 TTNESC TTNES0 TTNES1 TTNES2 TTEESC TTNESR TTNER1 TTNER2 TTEESR HTOGGL

;Patchable routine, called by TTY TEST
TTTEST:	JRST CPOPJ1		;PATCH HERE FOR NEW TTY COMMAND CALLED TEST

;Here if user gave TTY C100 cmd (possibly abbrev.), without specifying type A,B,etc.
TC100:	TLNE LINE,DDDLIN!DISLIN
	JRST CPOPJ1		;DDs and IIIs can't be C100s in any case
	PUSHJ P,INLMES
	 ASCIZ/Must specify TTY C100A or TTY C100B or ...
/
	JRST CPOPJ1

TTSAIL:	TLNE LINE,DMLIN		;GOTTA BE A DISPLAY
	SKIPN LETAB(LINE)	;DPY HDR?
	JRST CPOPJ1		;NOT A DISPLAY
	MOVE AC1,DPYDES(LINE)	;Get display descriptor address
	SKIPN DPC128(AC1)	;Any quotable control chars?
	JRST CPOPJ1		;No, this display can't ever display SAIL graphics
	MOVSI AC1,DM128
	SKIPL (P)		;Skip if TTY NO ...
	IORM AC1,DPYDES(LINE)	;Flag that can display SAIL graphics
	SKIPGE (P)		;Skip unless TTY NO ...
	ANDCAM AC1,DPYDES(LINE)	;Flag that can't display SAIL graphics
	POPJ P,

;TTY CHKDCA nnn makes system type DCA info for port nnn on CTY.
TTCDCA:	PUSHJ P,OCTIN		;GET PORT NUMBER
	 JRST CPOPJ1		;NO ARG IS ILLEGAL
	 JRST CPOPJ1		;ILLEGAL CHAR
	CAIL LINE,DCANUM
	JRST CPOPJ1		;ILLEGAL PORT NUMBER
	MOVEM LINE,CHKDCA	;ASK AUTOMATIC ROUTINE TO TYPE DCA INFO ON CTY
	POPJ P,

TTPAD:	TLNE LINE,DMLIN		;GOTTA ALREADY BE A DM!
	SKIPN LETAB(LINE)	;GET DPY HDR
	JRST CPOPJ1		;ERROR
	MOVE AC2,LINE		;SAVE LINE NUMBER
	PUSHJ P,OCTIN		;GET PADDING CHAR'S OCTAL VALUE
	 JRST CPOPJ1		;NO ARG IS ERROR
	 JRST CPOPJ1		;ILLEGAL CHAR
	EXCH LINE,AC2		;Restore line number to LINE, pad char to AC2
TTPAD3:	CAILE AC2,200		;SHOULD BE ASCII CHAR (allow 200, meaning null)
	JRST CPOPJ1		;Not legal
	JUMPN AC2,.+2		;If want padding char to be null,
	MOVEI AC2,200		; store it as 200 to get it thru pty service
	DPB AC2,[POINT 9,PADCNT(LINE),35] ;STORE AWAY PADDING CHAR
	POPJ P,

TTBAUD:	TLNE LINE,DMLIN		;GOTTA ALREADY BE A DM!
	SKIPN LETAB(LINE)	;GOTTA HAVE DPY HDR
	JRST CPOPJ1		;ERROR
	MOVE AC2,LINE		;SAVE LINE NUMBER
	PUSHJ P,DECIN		;GET BAUD RATE
	 JRST CPOPJ1		;NO ARG IS ERROR
	 JRST CPOPJ1		;ILLEGAL CHAR
	MOVEI TAC,(LINE)	;ARG RETURNED IN LINE
	MOVE LINE,AC2		;RESTORE LINE NUMBER
TTBAU2:	PUSH P,LINE		;TAC+1 IS CLOBBERED BY IDIVI
	IDIVI TAC,BDUNIT	;DIVIDE BY BAUD RATE STORED AS 001
	POP P,LINE
	CAILE TAC,BDMAX		;BIGGER THAN MAX HANDLED BAUD?
	MOVEI TAC,BDMAX		;YES, GIVE HIM MAX BAUD
	DPB TAC,DMBAUD
	POPJ P,

TTALTB:	SKIPA AC1,[ALTBEL]	;TTY ALTBELL makes system use alternate bell ringer
TTALTE:	MOVEI AC1,ALTEMP	;TTY ALTEMP makes system use alternate emphasis
TTALT1:	MOVSI AC2,400000
	XORM AC2,(P)		;"NO" flag is in wrong sense, fix it
	JRST TTDMST

TTBS:	SKIPA AC1,[NO177]	;TTY BS COMMAND
TTBOLD:	MOVEI AC1,NOBOLD	;TTY BOLD COMMAND
TTDMST:	HRLZ AC1,AC1		;These are LH bits
	SKIPGE (P)
	IORM AC1,DPYDES(LINE)	;TTY NO ... -- SET "NO..." FLAG
	SKIPL (P)
	ANDCAM AC1,DPYDES(LINE)	;TTY ... -- CLEAR "NO..." FLAG
	POPJ P,

TTALTN:	SKIPA AC1,[ALTNEQ]	;TTY ALTNEQ means altmode is at 32 in display font
TTLFTA:	MOVEI AC1,LEFTAR	;TTY LEFTARROW turns off left arrow/underscore conversion
	JRST TTALT1

;Macro for defining the various DM-like display types.
;The per-display-type entries are:
;  XX(Name,TTYcmd dispatch address,
;     DTMISC flags,EDITKY LH value,PadBaud value,PadChar,DPYDES LH,DPYDES RH,
;     Default height,Default width).
;(The default height and width here, if nonzero, take precedence over those
;found in the terminal-type table pointed to by the DPYDES RH value.)

;The RH of EDITKY is always zeroed, but the LH of PADCNT is preserved.

;Flags in RH of DTMISC
TBS←←1	;Flag on means terminal has tabs, off means doesn't have them.

;				;Index	Terminal type
DEFINE DPTYPE<
XXX←←.	;mark start of table for calculating its length in macro
XX(DM2500,TTYDM,TBS,0,BDDFT,1,PADID!NOIDCU!LEFTAR,DM2500,0,0)
				;  0	DM 2500 plain
XX(DM128,TTYDMX,TBS,0,BDDFT,1,DM128!PADID!NOIDCU!LEFTAR,DM2500,0,0)
				;  1	DM 2500 w/single-char tape mode mod
XX(DMWAITS,TTYDMW,TBS,0,BDDFT,1,DMWAITS!DM3025!DM128!NO177!ALTNEQ!NOIDCU!LEFTAR,DM2500,0,0)
				;  2	DM 3025 with WAITS keyboard
XX(DM3025,TT3025,TBS,0,0,1,DM3025!NOIDCU,DM2500,0,0)
				;  3	DM 3025 plain
XX(C100A,TC100A,TBS,NOEDFL!NEHTFL,BDDFT,15,ALTNEQ!DM128,C100A,0,0)
				;  4	Concept 100, type A (SAIL chr set, etc.)
XX(C100B,TC100B,TBS,NOEDFL!NEHTFL,BDDFT,15,NO177,C100B,0,0)
				;  5	Concept 100, type B (no SAIL graphics)
XX(HP2648,TT2648,TBS,NOEDFL!NEHTFL,BDDFT,177,NO177,HP2648,0,0)
				;  6	HP 2648A
XX(TELERAY,TTELER,TBS,0,BD9600,177,NO177,TELERAY,0,0)
				;  7	Teleray 1000 (EDIT key)
XX(TELERB,TTELEB,TBS,NOEDFL!NEHTFL,BD9600,177,NO177,TELERAY,0,0)
				; 10	Teleray w/out EDIT key
XX(HEATH19,THEATH,TBS,NOEDFL!NEHTFL,BD9600,200,NO177,HEATH19,0,0)
				; 11	Heath 19
XX(TELEVIDEO,TTVDEO,TBS,NOEDFL!NEHTFL,BD9600,177,NO177,TELEVI,0,0)
				; 12	Televideo 912/920
XX(AMBASSADOR,TTAMBA,TBS,0,BD9600,200,0,AMBASS,0,0)
				; 13	Ann Arbor Ambassador
XX(ALTOTALK,TTATLK,TBS,0,0,200,DM128!NO177!ALTNEQ!LEFTAR,ALTOTA,0,0)
				; 14	Alto TALK program
XX(SUN,TTSUN,TBS,NOEDFL!NEHTFL,0,200,DM128!ALTNEQ,SUNDPY,0,0)
				; 15	SUN display software
XX(ANSI,TTANSI,TBS,NOEDFL!NEHTFL,BD9600,177,NO177,AMBASS,=24,=80)
				; 16	ANSI standard display (more or less)
XX(DM3052,TT3052,TBS,NOEDFL!NEHTFL,BD1200,177,NO177,DM3052,0,0)
				; 17	DM 3052 with standard losing keyboard
XX(ESUN,TTESUN,TBS,0,0,200,DM128!ALTNEQ,SUNDPY,0,0)
				; 20	SUN display software (w/EDIT key)
XX(VT102,TTV102,TBS,NOEDFL!NEHTFL,BD9600,200,NO177,VT102,0,0)
				; 21	DEC VT102
XX(DPTEST,TDTEST,TBS,NOEDFL!NEHTFL,BD9600,177,NO177,DM2500,0,0)
				; N+1	Test type, patch in different setup routine
;  XX(Name,TTYcmd dispatch address,
;     DTMISC flags,EDITKY LH value,PadBaud value,PadChar,DPYDES LH,DPYDES RH,
;     Default height,Default width).
;(The default height and width here, if nonzero, take precedence over those
;found in the terminal-type table pointed to by the DPYDES RH value.)
IFDEF NDTYPS,<IFN .-XXX-NDTYPS,<.FATAL Dpy type tables have different lengths>>
>;DPTYPE

DEFINE XX(NAME,TTYADR,TABS,EDIT,BAUD,PADCH,FLAGS,DESADR,DFTHGT,DFTWID)<
TTYADR:	JSP AC1,SETDPY
>
;Here is the table of JSP instructions determining dpy type index from TTY command.
;TTY xxx commands that set the display type dispatch to cells in this array.
DTJSP:	DPTYPE
NDTYPS←←.-DTJSP		;Number of display types -- This must be first table.

DEFINE XX(NAME,TTYADR,TABS,EDIT,BAUD,PADCH,FLAGS,DESADR,DFTHGT,DFTWID)<
	<SIXBIT /NAME/>
>
;Here is the table of names of the various dpy types, for the TTYSET UUO.
DTNAME:	DPTYPE

DEFINE XX(NAME,TTYADR,TABS,EDIT,BAUD,PADCH,FLAGS,DESADR,DFTHGT,DFTWID)<
	DFTHGT⊗9+DFTWID,,TABS
>
;Here is a table of misc stuff for various dpy types, for the TTYSET UUO.
DTMISC:	DPTYPE

DEFINE XX(NAME,TTYADR,TABS,EDIT,BAUD,PADCH,FLAGS,DESADR,DFTHGT,DFTWID)<
	EDIT,,BAUD⊗9+PADCH
>
;Here is the table of EDIT flags plus padding baud and char
DTEDPD:	DPTYPE

DEFINE XX(NAME,TTYADR,TABS,EDIT,BAUD,PADCH,FLAGS,DESADR,DFTHGT,DFTWID)<
	FLAGS,,DESADR
>
;Here is the table of DPYDES flags and ptr
DTDPYD:	DPTYPE

;TTY xxx commands to set display type do a JSP AC1, to here from DTJSP table.
SETDPY:	TLNE LINE,DISLIN!DDDLIN	;Skip unless is fixed display type already
	JRST CPOPJ1		;Can't change display type.
	SKIPGE (P)		;Skip unless TTY NO ...
	JRST TTYNDM		;Make this TTY a non-display
	MOVEI AC1,-DTJSP-1(AC1)	;Get index of display type requested
	PUSH P,LINE		;Save line number (clobbered by DECIN)
	LDB AC2,[POINT 9,DTMISC(AC1),8] ;get "explicit" default height
	PUSH P,AC2		;Assume no row arg given (will use this default)
	PUSH P,AC1		;Save display index
	LDB AC2,[POINT 9,DTMISC(AC1),17] ;get "explicit" default width
	PUSHJ P,DECIN		;Get number of lines, if given
	 JRST SETDP0		;No arg, use default -- can't be a width either
	 JRST SETDPE		;Illegal arg - error return
	MOVEM LINE,-1(P)	;Save number of row on display
	PUSHJ P,DECIN		;Get number of columns, if given
SETDP0:	 SKIPA LINE,AC2		;No arg, use default
	 JRST SETDPE		;Illegal arg - error return
	EXCH LINE,-2(P)		;Get back line number, save number of cols
	POP P,AC1		;Get back display type index
;Now on the stack, from the top, we have: Rows, Cols, return addr.
;AC1 holds display index, LINE holds line number and characteristic bits
;Must never get here for III or DD line!
SETDPD:	JUMPL AC1,SETDPX	;Make sure valid index
	CAIL AC1,NDTYPS
	JRST SETDPX		;Invalid index (how come?!)
	OFFSCN			;must have scanner off while diddling parameters
	PUSHJ P,DSETUP		;setup display parameters, dpydes value to AC1
SETDPU:	MOVE AC3,DPCSIZ(AC1)	;Get default screen size (while dpydes in AC1)
	EXCH AC1,DPYDES(LINE)	;Store display type info
	CAME AC1,DPYDES(LINE)	;Did it change?
	SKIPN AC2,LETAB(LINE)	;Yes, was there already a dpy hdr?
	JRST SETDP1		;No, don't force re-init
	PUSHJ P,SETDPI		;Force the dpy to be re-inited
SETDP1: SKIPN (P)		;Use any explicit height given
	HRRZM AC3,(P)		;Use def height
	SKIPN -1(P)		;Use any explicit width given
	HLRZM AC3,-1(P)		;Use def width
	HRRZS -2(P)		;Assume not making a new dpy (nor new type)
	CAMN AC1,DPYDES(LINE)	;Did we change dpy type?
	SKIPN LETAB(LINE)	;No, were we already a dpy?
	HRROS -2(P)		;Flag new dpy (or new type), for output of msg later
	MOVSI AC2,DMLIN
	TDNE AC2,LINTAB(LINE)	;Is line already marked as a display?
	JRST SETDP2		;Yes, don't do it again.
	IORM AC2,LINTAB(LINE)	;No, mark it
	PUSHJ P,DPYMAKE		;Make a dpy hdr
	 JFCL			;Failed, but planted a clock req to make one
SETDP2:	POP P,TAC		;Rows on display
	POP P,AC3		;Cols on display
	SKIPN AC2,LETAB(LINE)	;Was dpy hdr made OK?
	JRST SETDP4		;No, can't diddle geometry! (Could try later...)
	PUSHJ P,SDMWID		;Set dpy width from AC3
	SKIPE DDB,TTYTAB(LINE)	;Need DDB for ESCWT
	SKIPE WHOTAB(AC2)	;Do we have a wholine up?
	JRST SETDP3		;Yes (or no DDB), don't change job number in wholine
	PUSHACS
	MOVE J,AC2		;Dpy hdr for LINED
	MOVE DAT,LINTAB(LINE)	;LINED want line bits here
	CONSZ PI,77400		;If UUO level, don't start wholine (program can)
	PUSHJ P,ESCWT		;Start wholine for attached job, if any
	POPACS
SETDP3:	CAIG TAC,MAXLIN		;Is height too big?
	CAIGE TAC,MINLIN	;Or too small?
	JRST SETDP4		;Yes, keep current height
	MOVEM TAC,DPYHGT(AC2)	;Accept specified height. (Note: takes PP reset to
				; actually cause height to affect Page Printer)
SETDP4:	MOVEI TAC,(LINE)	;Line number
	PUSHJ P,TPTINT		;Generate INTTTC interrupt for job and owner
	SKIPN DDB,TTYTAB(LINE)	;Get affected DDB in order to start output
	JRST SCNONJ		;No DDB!
REPEAT 0,< ;No message for now
	SKIPGE (P)		;Is this a new dpy (or new type)?
	PUSHJ P,DPIMSG		;Yes, output any special message it needs
>;REPEAT 0
	PUSHJ P,TYPGO2		;Start output
	JRST SCNONJ

SETDPX:	SUB P,[2,,2]		;Flush row and col count from stack
	POPJ P,

;Routine to setup display parameters from dpy type tables.  Scanner channel
;must be off when calling here.  Call with AC1 containing dpy type index.
;Return with AC1 containing DPYDES word for given dpy type.
DSETUP:	MOVE AC2,DTNAME(AC1)
	MOVEM AC2,DPYNAM(LINE)	;Remember terminal type by specified name
	MOVSI AC2,TBXPND
	ANDCAM AC2,LINTAB(LINE)	;assume terminal has tabs
	MOVE AC2,DTMISC(AC1)	;get tabs flag
	TRNE AC2,TBS		;skip unless has tabs
	JRST DSETU2		;has tabs, don't turn on tab-expand bit
	MOVSI AC2,TBXPND	;no tabs, turn this bit on
	IORM AC2,LINTAB(LINE)	;no tabs after all
DSETU2:	MOVE AC2,DTEDPD(AC1)	;get edit/pad info
	HLLZM AC2,EDITKY(LINE)	;set EDIT-key info
	HRRM AC2,PADCNT(LINE)	;set padding info
	MOVE AC1,DTDPYD(AC1)	;get DPYDES word
;;	PUSHJ P,@DTDISP(AC1)	;Set up display type, returns DPYDES value in AC1
	POPJ P,

REPEAT 0,<
DPIMSG:	SKIPE AC1,DPYDES(LINE)	;Get pointer to dpy descriptor table
	SKIPN TAC,DPCIMS(AC1)	;Get pointer to initial message, if any
	POPJ P,			;Forget it
	PUSHJ P,CONMES		;Output the message
	MOVEI TAC,[ASCIZ\ w/EDIT key\]
	SKIPL EDITKY(LINE)	;Skip if no EDIT key flag set
	PUSHJ P,CONMES		;Output more message
	JRST TYCRLF		;And output a CRLF for good measure
>;REPEAT 0

SETDPI:	MOVEI TAC,INIDUN!TBSSET	;Clear these bits to force a
	ANDCAM TAC,DMFLAG(AC2)	; re-init of the dpy
	HRLI AC2,RFPCS		;And plant a clk req to to a BRK P for new dpy
	JRST AC2CLK		;Plant clk req

;Here for TTY INITIALIZE command to force the dpy to be re-initialized.
DPINIT:	TLNN LINE,DISLIN!DDDLIN	;Forget it if a fixed local display
	SKIPN AC2,LETAB(LINE)	;Get dpy hdr
	JRST CPOPJ1		;Not a "DM"
	OFFSCN
	PUSHJ P,SETDPI		;Force the dpy to be re-inited
	HRROS (P)		;Force initialization message
	JRST SETDP4

;HERE TO SET WIDTH OF DM DISPLAY.  FIXES DPY HDR AND ALL PIECES OF PAPER.
;COME HERE WITH DPY HDR IN AC2, NEW WIDTH REQUESTED IN AC3.
SDMWID:	TRZ AC3,7		;FORCE WIDTH TO BE A MULTIPLE OF 8 (FOR NOW)
	CAIG AC3,MAXCOL		;MAXIMUM WIDTH FOR DM
	CAIGE AC3,MINCOL	;MINIMUM WIDTH
	POPJ P,			;NOT IN RANGE, KEEP OLD WIDTH
	MOVEM AC3,DPYWID(AC2)	;STORE DM WIDTH IN DPY HDR
	HLRZ AC1,PPCALL(AC2)	;POINTER TO FIRST PP
SDMWI2:	JUMPE AC1,CPOPJ		;RETURN IF NO MORE PP'S
	EXCH AC3,LNLNGT(AC1)	;FIX PP'S WIDTH
	SUB AC3,LNLNGT(AC1)	;FIGURE NEGATIVE AMOUNT OF ADDED WIDTH
	ADDM AC3,DPHPOS(AC1)	;THAT'S HOW MUCH MORE ROOM ON CURRENT LINE
	MOVE AC3,LNLNGT(AC1)	;GET BACK NEW WIDTH
	HRRZ AC1,PPLINK(AC1)	;GET POINTER TO NEXT PP
	JRST SDMWI2		;AND LOOP THROUGH ALL PP'S

SETDPE:	SUB P,[3,,3]		;FIX STACK
	JRST CPOPJ1		;ERROR RETURN

;Here for TTY NO DM command to make TTY into a non-display.
;Clobbers TAC,AC1,AC2,AC3.
TTYNDM:	TLNE LINE,DMLIN		;Maybe already not a DM
	SKIPN AC1,LETAB(LINE)	; or maybe it doesn't have a dpy hdr
	JRST CPOPJ1		; which makes this illegal command
	SETZM LEACT(AC1)	;Clear line-editor-active flag, for quick dpy kill
	MOVSI AC2,KILDPY	;This bit tells DPYKIL not to kill the DDB
	OFFSCN			;Make sure TTY DDB doesn't go away in CH5 now
	TDNE AC2,TTYTAB(LINE)	;Already trying to do NO DM cmd?
	SKIPN LECLIN(AC1)	;Yes, already have clock request in?
	SKIPN TTYTAB(LINE)	;No, plant clk req, unless no DDB there at all!
	JRST SCNONJ		;Already working on it, or no DDB!
	IORM AC2,TTYTAB(LINE)	;Flag to kill dpy hdr but not DDB
	MOVEI TAC,(LINE)	;Line number (dpy hdr is still in AC1)
	PUSHJ P,DPYKI7		;Plant clk req to kill dpy hdr in one tick
	JRST SCNONJ


TTBEEP:	MOVE AC1,(P)		;GET PROPER SENSE OF FLAG
	JRST ESCZ		;LET LINED DO THE WORK

FILTTY:	SKIPGE (P)		;'NO' TYPED?
	TLZA LINE,TTYFIL	;YES, DO NOFILL
	TLO LINE,TTYFIL		;FILL CR'S
STOLIN:	HLLM LINE,LINTAB(LINE)
	POPJ P,

TTECHO:	SKIPGE (P)		;'NO' TYPED?
	TLOA LINE,FULTWX	;YES, SET AS SELF ECHOING FULL DUPLEX
	TLZ LINE,FULTWX		;CLEAR SELF-ECHO.  (I.E., WE ECHO)
IFE FTIP,<JRST STOLIN>
IFN FTIP,<
	HLLM LINE,LINTAB(LINE)	;Store new line word
	HRRZ TAC,LINE		;Get line number
	CAIL TAC,PTYL0		;Skip if not a PTY
	SKIPN TAC,PTYIMP-PTYL0(TAC) ;Skip if an ITY
	POPJ P,			;Not an ITY
	JRST ITYECH↑		;Special echo handling for ITYs
>;IFN FTIP

TTFULL:	SKIPGE (P)
	TLZA LINE,FCS
	TLO LINE,FCS
	JRST STOLIN

TTTAB:	SKIPGE (P)
	TLOA LINE,TBXPND	;EXPAND
	TLZ LINE,TBXPND		;DON'T EXPAND
	HLLM LINE,LINTAB(LINE)	;Store new state of bit
TABCHK:	PUSH P,J		;ENTER HERE FROM SETLIN WHEN TBXPND CHANGES
	TLNE LINE,DMLIN
	SKIPN J,LETAB(LINE)
	JRST POPJJ		;Not DM or no dpy hdr, restore J and return
	PUSH P,[POPJJ]		;Restore J when returning
	OFFSCN
	TLNN LINE,TBXPND
	JRST LEPDM3		;Now has tabs, set them
	MOVEI AC2,TBSSET
	ANDCAM AC2,DMFLAG(J)	;Don't let us send any more tabs
	JRST SCNONJ

TTYARR:	SKIPGE (P)
	TLZA LINE,ECHARR
	TLO LINE,ECHARR
	JRST STOLIN

TTYGLA:	MOVEI AC2,GLASSB	;TTY GLASS COMMAND
	JRST TTYHAC

TTTGAG:	SKIPA AC2,[GAGTBT]	;TTY TGAG COMMAND
TTYGAG:	MOVEI AC2,GAGBIT	;TTY GAG COMMAND
TTYHAC:	SKIPN TAC,TTYTAB(LINE)	;GET DDB
	POPJ P,			;CAN'T HAPPEN, I THINK
	IORM AC2,IMLHAC(TAC)	;TTY GAG SETS BIT
	SKIPGE (P)
	ANDCAM AC2,IMLHAC(TAC)	;TTY NO GAG CLEARS IT
	POPJ P,

TTYDEL:	SKIPA AC2,[DELHBT]	;TTY DELETE COMMAND
TTYCVT:	MOVEI AC2,CVTBIT
TTYHA2:	SKIPN TAC,TTYTAB(LINE)	;TTY CONVERT COMMAND
	POPJ P,			;CAN'T HAPPEN, I THINK
	ANDCAM AC2,IMLHAC(TAC)	;TTY CONVERT CLEARS BIT
	SKIPGE (P)
	IORM AC2,IMLHAC(TAC)	;TTY NO CONVERT SETS IT
	POPJ P,

SPDCMD:	PUSH P,LINE		;SAVE TARGET LINE NUMBER
	PUSHJ P,CTEXT1		;READ SPEED NAME
	MOVSI CHR,-NUMSPD	;FIND IT IN TABLE INSIDE DCASER
SPDCM1:	CAME TAC1,SPDNAM(CHR)
	AOBJN CHR,SPDCM1
	POP P,LINE		;RESTORE TARGET LINE NUMBER
	JUMPGE CHR,CPOPJ1	;ERROR, UNRECOGNIZED SPEED
	HRRZ TAC,LINBIT(LINE)	;IS THIS A DCA PORT?
	JUMPE TAC,CPOPJ1	;NO, DO NOTHING
	MOVEI LINE,-400000(TAC)	;YES, GET PORT NUMBER INTO LINE
repeat 0,<	;let anybody try any speed the DCA can do
	MOVEI AC3,(DDB)		;BH 8/5/78 CTY CAN DO ANYTHING
	CAIN AC3,SCNDDB		;BH
	JRST SPDCM3		;BH
	MOVE AC3,DCATAB(LINE)	;If this is not a phone line, anyone can diddle
	TRNE AC3,DCAPRM		;Skip if has a modem
	JRST SPDCM3		;Try whatever speed is requested
	JUMPE J,SPDCM2
	MOVSI AC3,DEVPRV	;CHECK FOR PRIVILEGED COMMANDER
	TDNE AC3,JB2PRV(J)
	JRST SPDCM3		;YES, SKIP LEGITIMACY CHECKS
SPDCM2:	MOVE AC3,DCATAB(LINE)	;GET FLAGS
	TRNN AC3,DCABDB		;IS THIS A BAUD DETECT LINE?
	JRST CPOPJ1		;NO, DO NOTHING
	MOVEI CHR,(CHR)		;SPEED INDEX WITHOUT AOBJN COUNT
	CAIE CHR,LS110		;ONLY ALLOW LEGAL SPEEDS
	CAIN CHR,LS150
	JRST SPDCM3		;TELL DCASER TO SET THE SPEED
	CAIN CHR,LS300
SPDCM3:
>;repeat 0
	PUSHJ P,DCASPX
	 JRST CPOPJ1		;SPEED IS ILLEGAL
	POPJ P,

;Here from clock request after TTYTAB zeroed, with line number in RH DAT.
BEPHNG:	HRRZ TAC,LINBIT(DAT)	;Get DCA port number
	SKIPN TTYTAB(DAT)	;Don't hang up if TTY in use again already
	TRZN TAC,400000		;Don't beep or hang up if not on DCA
	POPJ P,			;Not on DCA or TTYTAB non-zero
	HRLI DAT,HNGCLK		;Routine to hang up phone
	SYSPIFF
	IDPB DAT,CLKQ		;Plant clk req to hang up phone in one tick
	SYSPIN
	MOVEI LINE,(DAT)	;Line number, no bits
;;	JRST DMBONG		;Clear ESC and META flag bits and send the DM a beep
	MOVEI AC3,0		;Don't beep any more, just clear ESC and META bits
	DPB AC3,[ESCFLD,,PRGESC(LINE)]
	POPJ P,

↑HNGCLK:MOVEI LINE,(DAT)	;HERE WITH CLOCK REQUEST TO HANG UP DM PHONE
	PUSHJ P,HNGCMD
	 POPJ P,		;SKIPS IF NOT phone line NOR PTY
	POPJ P,

;Here from QUIT command to close network connection.
↑QUITCM:PUSHJ P,STLNAC		;get our line number into LINE, and bits in LH
	PUSHJ P,HNGCLS		;close network connection
	 POPJ P,		;PTY
	JRST COMERA		;not PTY

;Here from QUITCM above, and from TTYDDL.  Check for PTY to close connection.
HNGCLS:	TLNN LINE,PTYLIN	;are we a PTY?
	JRST CPOPJ1		;no, skip return to indicate not PTY
IFN FTIP,<
	SKIPE PTYIMP-PTYL0(LINE);Is this an IMP line?
	JRST QTCLOS		;Yes, go close the connection
>;IFN FTIP
	MOVEI AC1,INTQUIT	;now generate this interrupt
	PUSHJ P,PTINTC		; if enabled by PTY owner
	POPJ P,			;success return

;Here to hang up a TTY from TTY HANG.
↑HNGCMD:HRRZ TAC,LINBIT(LINE)	;TTY HANG COMMAND, GET DCA PORT NUMBER
	JUMPE TAC,CPOPJ1	;ERROR IF NOT DCA PORT
	PUSH P,TAC		;SAVE IT FOR DCASPR
	PUSHJ P,DCAHNG		;HANG IT UP
	 JRST TPOPJ1		;CAN'T HANG UP, IT'S A PERMANENT LINE, NO MODEM
	HLL LINE,LINTAB(LINE)	;Make sure have characteristics for NDM routine
	PUSHJ P,TTYNDM		;Make TTY a Non-Display-Medium
	 JFCL			;Ignore skip return of failure
	MOVE TAC,(P)		;DCA port+400000
	PUSHJ P,DCASPR		;*** RESET SPEED TO DEFAULT VALUE
	 JFCL			;Skips on success, shouldn't ever fail
	POP P,TAC		;DCA port+400000
	HRRZ CHR,TTYTAB(LINE)	;get tty ddb for line
	JUMPE CHR,HNGCMA	;if no ddb, then clear dial bit
	MOVE CHR,DEVMOD(CHR)	;see if tty is inited
	TRNE CHR,ASSPRG		;skip if not inited
	JRST HNGCMB		;still in use, don't clear bit
HNGCMA:	MOVSI CHR,DCADIL	;turn off dial bit, since no one has tty inited
	ANDCAM CHR,DCATAB-400000(TAC) ;clear dial bit in DCATAB
HNGCMB:	MOVEI LINE,(LINE)	;FLUSH LH STUFF
	LSH LINE,=12		;POSITION LINE NUMBER IN ARGUMENT FIELD
	TLO LINE,$HNGCM1	;Go to HNGCM1 in a few secs
	TRO LINE,5*JIFSEC	;WAIT FIVE SECONDS
	CLKENQ(LINE)		;Plant clk req
	POPJ P,			;DONE

↑HNGCM1:HRRZ TAC,LINBIT(TAC)	;GET DCA PORT NUMBER
	JUMPE TAC,CPOPJ		;HUH?
	JRST DCAPKU		;RESTORE DATA TERMINAL READY

;HERE ONCE A MINUTE, to maybe hang up some phone line not in use, in order
;to avoid leaving lines off-hook for long periods of time.
↑CKFONE:AOSL LINE,FONTTY	;Get next TTY to check
	CAIL LINE,SCNNUM	;In range?
	SETZB LINE,FONTTY	;No, wrap around
	SKIPE TTYTAB(LINE)	;Don't hang up any TTY that's in use
	POPJ P,			;Leave TTY alone
	HRRZ TAC,LINBIT(LINE)	;See if TTY is on the DCA scanner
	TRZE TAC,400000		;Skip if not on DCA
	SKIPL TAC,DCATAB(TAC)	;Get DCA status, forget it if already hung up
	POPJ P,			;Don't do anything
;Don't hang up TTYs that are:
; glitching carrier, OH at SYSINI, non-phone, or down
	TDNN TAC,[DCACDN!DCASYI,,DCAPRM!DCADWN]
	PUSHJ P,HNGCMD		;Hang up this guy, for good measure
	 POPJ P,		;Success
	POPJ P,			;No modem -- can't happen!

;Here from special monitor commands to indicate that display has no EDIT key.
↑TTYNOE:PUSHJ P,STLNAC		;Set up line number and bits
	SKIPE LETAB(LINE)	;Must be a dpy already, else will do no good
	TLNE LINE,DISLIN!DDDLIN	;And mustn't be fixed-type display
	JRST COMERA
	MOVSI AC1,NOEDFL!NEHTFL	;No-edit flag, holding-toggle flag
	MOVEM AC1,EDITKY(LINE)	;Make us a no-edit-key terminal
	POPJ P,

EDITCM:	MOVSI TAC,400000
	XORM TAC,(P)		;EDIT is opposite of NOEDIT
;Enter here from TTYSET UUO and DMMODE (ESC ') and TTY NOEDIT (sic).
NOEDCM:	TLNE LINE,DMLIN		;GOTTA ALREADY BE A DM!
	SKIPN AC2,LETAB(LINE)	;GET DPY HDR
	JRST CPOPJ1		;ERROR
	OFFSCN			;NO FAIR CHANGING NOEDIT BITS
	SKIPL TAC,EDITKY(LINE)	;GET PREVIOUS NOEDIT WORD
	MOVSI TAC,NOEDFL!NEHTFL	;WASN'T NOEDIT, MAKE VIRGIN WORD
	SKIPGE (P)
	MOVEI TAC,0		;TTY EDIT CLEARS NOEDIT WORD
	EXCH TAC,EDITKY(LINE)
	SKIPGE EDITKY(LINE)
	JRST SCNONJ		;DONE IF NOEDIT NOW SET
	JUMPGE TAC,SCNONJ	;DONE UNLESS CLEARING NOEDIT
;Enter here from DPYKIL (DPYKFS) with SCNOFF and dpy hdr in AC2
↑CLRNED:MOVEI AC2,NEVECT(AC2)	;ELSE WE MUST CLEAR CHAR MACROS
	HRLI AC2,-VECTNM	;NUMBER OF VECTOR WORDS
	MOVSI TAC,400000	;VALUE TO CLEAR FIRST WORD TO
NOEDC1:	MOVE AC1,(AC2)		;GET OLD MACRO VECTOR WORD
	TRNE AC1,-1		;IF THERE IS A MACRO THERE,
	PUSHJ P,FSGIVE		; GIVE IT BACK
	MOVEM TAC,(AC2)		;RESET TO DEFAULT VALUE
	MOVEI TAC,0		;ALL BUT THE FIRST HAVE THIS DEFAULT
	AOBJN AC2,NOEDC1	;LOOP THROUGH ALL VECTOR WORDS
	JRST SCNONJ

TTNESC:	SKIPN AC2,LETAB(LINE)
	JRST CPOPJ1		;NOT A DPY
	PUSH P,LINE		;SAVE LINE NUMBER
	PUSHJ P,OCTIN		;GET OCTAL CODE OF NEW ESCAPE CHAR
	 JRST TTNESR		;NO ARG IS READ ESC CHARS
	 JRST TPOPJ1		;ILLEGAL CHAR
	EXCH LINE,(P)
	POP P,CHR		;THINGS IN RIGHT ACS
;Enter here from TTYSET UUO with AC2 and CHR set up.
TTNES0:	CAILE CHR,177
	JRST CPOPJ1		;MUST BE 7-BIT CHAR
	SKIPL EDITKY(LINE)
	JRST TTEESC		;BH 9/18/82  Set ESC for EDIT-KEY dpy.
	LDB CHR,NECVBP		;GET VECTOR INDEX
	JUMPE CHR,CPOPJ1	;THIS CHAR CAN'T BECOME ESCAPE
	ADDI AC2,-1(CHR)	;AC2 IS POINTER TO VECTOR WORD
	SKIPGE AC1,NEVECT(AC2)	;SKIP IF SIGN BIT OFF
	POPJ P,			;CHAR IS ALREADY AN ESCAPE CHAR
	JUMPE AC1,TTNES1	;JUMP IF NO PREVIOUS MACRO DEF
	SETZM NEVECT(AC2)	;MAKE SURE USER DOESN'T TYPE IT AND LOSE
	PUSHJ P,FSGIVE		;GIVE BACK PREVIOUS MACRO DEF
TTNES1:	SOJN CHR,TTNES2		;JUMP UNLESS TTY SETESC 0
	MOVSI CHR,400000	;THIS IS EASY BECAUSE 0 IS THE DEFAULT
	MOVEM CHR,NEVECT(AC2)	; SO WE JUST FLAG THE NORMAL CASE
	POPJ P,

TTNES2:	MOVEI AC3,1		;WE NEED ONE WORD OF FS TO HOLD MACRO
	PUSHJ P,FSGET
	 JRST CPOPJ1		;FAILED
	MOVSI CHR,404200	;CODE FOR ESCAPE
	MOVEM CHR,(AC1)		;SAVE IN FS BLOCK
	HRLI AC1,400001		;MAKE ESC-FLAGGED MACRO POINTER
	MOVEM AC1,NEVECT(AC2)	;SET UP THE MACRO
	POPJ P,

TTEESC:	LDB AC2,NECVBP		;GET VECTOR INDEX
	JUMPE AC2,CPOPJ1	;THIS CHAR CAN'T BECOME ESCAPE
	DPB CHR,EKESCC		; Only one ESC for EDIT-KEY dpy.
	POPJ P,

TTNESR:	POP P,LINE		;POP LINE NUMBER OFF STACK
	SKIPL EDITKY(LINE)
	JRST TTEESR		;BH 9/18/82  Get ESC for EDIT-KEY dpy.
	HRLI AC2,-VECTNM	;AOBJN POINTER TO ESCAPE CANDIDATES
	MOVE AC3,[POINT 7,[ASCII /@HIJKL[\]↑←/]]
TTNER1:	ILDB AC1,AC3		;GET NEXT CANDIDATE NAME
	SKIPL NEVECT(AC2)	;IS IT AN ESCAPE?
	JRST TTNER2		;NO
	PUSH P,AC3
	PUSH P,AC1
	PUSHJ P,INLMES		;YES
	 ASCIZ / ↑/
	HRRZ CHR,(P)
	XCT TYO
	PUSHJ P,INLMES
	 ASCIZ / ('/
	POP P,TAC
	SUBI TAC,100
	PUSHJ P,OCTPNT
	PUSHJ P,INLMES
	 ASCIZ /) /
	POP P,AC3
TTNER2:	AOBJN AC2,TTNER1
	JRST TYCRLF

TTEESR:	MOVEI CHR,"↑"
	XCT TYO
	LDB CHR,EKESCC		;Get EDIT-KEY ESC char
	ADDI CHR,100
	XCT TYO
	PUSHJ P,INLMES
	 ASCIZ / ('/
	LDB TAC,EKESCC		;get back to print octal
	PUSHJ P,OCTPNT		;print octal for esc char
	MOVEI CHR,")"
	XCT TYO
	JRST TYCRLF

HTOGGL:	SKIPE AC2,LETAB(LINE)
	SKIPL EDITKY(LINE)
	JRST CPOPJ1		;NOT A DPY OR NOT TTY NOEDIT
	MOVSI TAC,NEHTFL	;HTOGGLE FLAG
	ANDCAM TAC,EDITKY(LINE)	;TURN FLAG OFF
	SKIPL (P)		;IF NOT "NO HTOGGLE",
	IORM TAC,EDITKY(LINE)	; THEN TURN IT BACK ON
	POPJ P,
;TTYSWD TTWID0 TTWID1 TTYUPD TTYTIM TTYTI1 TBRK TESC TESC3 POPDTJ TTHIDE

TTYSWD:	PUSHJ P,DECIN		;TTY WIDTH COMMAND.   REG 11/75
TTWID0:	SKIPA TAC1,[=72]	;NO ARG, USE OLD DEFAULT
	JRST CPOPJ1		;LOSE
TTWID1:	CAIGE TAC1,=256
	CAIG TAC1,=16		;SOME VALUES ARE NOT REASONABLE.
	MOVEI TAC1,DEFWID	;Use default TTY width
	DPB TAC1,PTTYWD
	POPJ P,

TTYUPD:	JUMPE J,CPOPJ		;IF NO JOB, NO XTIME
	MOVSI TAC,NOXRST	;THIS IS THE NO-UPDATE BIT IN JBTMSC
	SKIPGE TAC1,(P)		;'NO' TYPED?
	IORM TAC,JBTMSC(J)	;YES.  SET NO-UPDATE BIT.
	JUMPL TAC1,.+2		;'NO' TYPED?
	ANDCAM TAC,JBTMSC(J)	;NO.  CLEAR NO-UPDATE BIT.
	POPJ P,

TTYTIM:	JUMPE J,CPOPJ		;NO JOB, NO XTIME
	MOVSI TAC,NOXRST	;THE NO-UPDATE BIT IN JBTMSC
	IORM TAC,JBTMSC(J)
	SETZM XTIME(J)
IFN FTMTRACT,<
	MOVE AC3,J
	LSH AC3,1
	SETZM MTRXTIME(AC3)
	SETZM MTRXTIME+1(AC3)
>;IFN FTMTRACT
	MOVE TAC,TTIME(J)	;TTY TIME, INCR TIME←0, SET NO UPDATE
	SKIPL TAC1,(P)		;'NO' TYPED?
	MOVEM TAC,XTIME(J)	;TTY NO TIME, INCR TIME←TOTAL,SET NO UPD
IFN FTMTRACT,<
	DMOVE AC1,MTRTTIME(AC3)
	SKIPL TAC1
	DMOVEM AC1,MTRXTIME(AC3)
>;IFN FTMTRACT
	HRRZS DSKOPS(J)		;MAKE ALL DISK OPERATIONS "RECENT"
	SETZ TAC,		;ASSUME NO WAIT TIME
	JUMPL TAC1,TTYTI1	;'NO' TYPED?
	HRLS DSKOPS(J)		;NO.  MAKE NO DISK OPS RECENT
	SKIPGE TAC,JBTWAT(J)	;GET WAIT TIME
	ADD TAC,UPTIME		;MAKE IT HONEST
TTYTI1:	MOVEM TAC,JB2WAT(J)	;SAVE CURRENT WAIT TIME
	POPJ P,

TBRK:	SETCM TAC,(P)		;TTY BREAK COMMAND
	HLLM TAC,(P)		;CHANGE SIGN AND FALL INTO ESCAPE COMMAND
TESC:	PUSH P,TAC1
	PUSHJ P,DECIN		;TTY ESCAPE COMMAND.  GET DECIMAL ARG
	 JFCL			;NO ARG
	 TDZA AC2,AC2		;"ILLEGAL CHAR"--Flag no arg given
	SETO AC2,		;Definitely have an arg
	SKIPL AC1,TAC1
	JRST TESC3
	MOVM AC1,AC1
	SETCM TAC,-1(P)		;Negative arg, change sense of ESC/BRK flag
	HLLM TAC,-1(P)
TESC3:	CAILE AC1,ESCMAX
	MOVEI AC1,ESCMAX	;MAX ALLOWABLE ARG
	SKIPGE -1(P)		;Is it really BREAK?
	HRLI AC1,400000		;Yes, flag it
	PUSHJ P,SKIPSJ		;Skip any blanks after number
	POP P,TAC1		;Get back our line number
	LDB CHR,TAKR(DAT)	;Get back the break char
	LDB DSER,[POINT 7,CHR,35] ;Get char without bits
	CAIE DSER,15
	CAIN DSER,12
	JRST CPOPJ1
	CAIN DSER,175
	JRST CPOPJ1
	PUSH P,J
	PUSH P,DAT
	MOVEI DAT,-1		;Set into ESCDIF to convert arg but not store
	PUSHJ P,TTESC2		;Call the TTYSET routine to do the work
POPDTJ:	POP P,DAT
	JRST POPJJ		;Restore J and return

TTHIDE:	MOVE AC1,(P)		;get flag: sign bit on means NO HIDE
	PUSH P,J
	PUSH P,DAT
	MOVE DAT,LINE		;line number where LINED wants it
	OFFSCN			;don't let escape cmd come change things under us
	MOVE J,LETAB(LINE)	;dpy hdr for LINED to check for DD chan
	PUSHJ P,ESCH		;call LINED routine to hide or unhide
	ONSCN
	JRST POPDTJ		;restore DAT and J and return
;FTTYW TTYWHO TTWHSY TTWHS1 TTNOJB UWHO PJBWHO FTTYW1 UWHO0 UWHO1A UWHO1 UWHO2A UWHO2 UWHO3 UWHO4 WHOUUO WHOUU1 WHOUU0 WHOUU2

↑FTTYW:	LDB TAC1,ARGBPT		;GET REMEMBERED JOB NUMBER
	JUMPE TAC1,TTWHSY	;0 MEANS SYSTEM WHO LINE
	JRST FTTYW1		;ELSE SOME JOB'S WHO LINE

TTYWHO:	SKIPL (P)		;'NO' TYPED?
	JRST UWHO		;NO NO.
TTWHSY:	MOVEI AC3,COMWHO	;TYPE OUT SYSTEM WHO LINE
	JRST UWHO1A

TTWHS1:	CAIE TEM,"-"		;HERE IF ARG IS ZERO
	JRST TTWHSY		;MEANS SYS WHO LINE UNLESS IT'S -N
	PUSHJ P,OCTINS		; IN WHICH CASE GIVE WHO LINE FOR TTYN
	 JRST TTWHSY		;NO ARG AFTER -
	 JRST CPOPJ1		;BAD CHAR
	CAIGE TAC1,TTPLEN	;Illegal tty number?
	SKIPN TAC1,TTYTAB(TAC1)	;or no DDB?
	JRST TTNOJB		;YES, NO-OP
	LDB TAC1,[POINT JOBNSZ,DEVJBN(TAC1),JOBNPS] ;Get job number of tty's owner
	JUMPN TAC1,UWHO0	;Any job there?
TTNOJB:	JSP TAC,ERRMES
	ASCIZ /Not in use.
/

UWHO:	PUSHJ P,DECIN
	SKIPA TAC1,J		;NO ARG, USE OUR JOB #
	JRST CPOPJ1		;LOSE
	JUMPE TAC1,TTWHS1	;0 ARG, OR NO ARG & NOT LOGGED IN
↑PJBWHO:			;ENTRY FROM PJOB COMMAND
FTTYW1:	CAIL TAC1,JOBN		;TOO BIG?
	JRST NOTLOG		;YES
UWHO0:	MOVE TAC,JBTSTS(TAC1)
	TLNN TAC,JNA		;IS IT A JOB?
	JRST NOTLOG		;NO
	PUSH P,J		;SAVE J
	PUSH P,DDB		;AND DDB ON STACK
	MOVE J,TAC1
	MOVEI AC1,TITLE		;USE WHO LINE MODEL
	SETZ DDB,		;FLAG THAT IT IS TTY CALLING
	PUSHJ P,WHOTTY		;CALCULATE THE WHOLINE
	POP P,DDB		;RESTORE DDB
	POP P,J			;AND J
	MOVEI AC3,WTTYS		;START HERE
UWHO1A:	PUSH P,[0]		;NUMBER OF SPACES SEEN
UWHO1:	SKIPN AC2,(AC3)		;PICKUP WORD AND CHECK FOR END
	JRST TPOPJ		;DONE, FLUSH SPACE COUNTER FROM STACK AND RETURN
	TRZN AC2,1		;TEXT WORD?
	AOJA AC3,UWHO1		;NO
	SKIPA AC1,[POINT 7,AC2]	;YES, MAKE BYTE POINTER
UWHO2A:	AOS (P)			;COUNT ANOTHER SPACE SEEN
UWHO2:	TLNN AC1,760000
	AOJA AC3,UWHO1		;END OF TEXT WORD, GET NEXT WORD
	ILDB TEM,AC1		;UNPACK THE CHARACTERS
	CAIN TEM,40
	JRST UWHO2A		;DON'T OUTPUT SPACES UNTIL NON-BLANK CHAR SEEN
	JUMPE TEM,UWHO2
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	CAIN TEM,15
	SETZM -3(P)		;FLUSH SPACES AHEAD OF CR
	SKIPG -3(P)		;HAVE WE BEEN HOLDING BACK SOME SPACES?
	JRST UWHO4		;NO
	PUSH P,TEM		;YES, SAVE THIS NON-BLANK CHAR
UWHO3:	MOVEI TEM,40
	XCT TYO			;OUTPUT A SPACE
	SOSLE -4(P)		;ANY MORE SPACES NEEDED?
	JRST UWHO3		;YES
	POP P,TEM		;RESTORE NON-BLANK CHAR
UWHO4:	XCT TYO			;OUTPUT THE CHAR.
	POP P,AC3
	POP P,AC2
	POP P,AC1
	JRST UWHO2

↑WHOUUO:XCTR XR,[HRRZ UUO,(UCHN)] ;POINTER TO WHERE USER WANTS STRING
	CAIG UUO,JOBPFI		;MAKE SURE IO DOESN'T CLOBBER JOB VARIABLES
	JRST UADRER		;ADDRESS ERROR. OTHER SAFETY INSURED BY XCTR
	HRLI UUO,(<POINT 7,0>)	;MAKE IT BYTE POINTER
	MOVEI AC3,COMWHO	;SKIP SOME SPACES
	XCTR XR,[HLRE TAC,(UCHN)] ;GET JOB NUMBER FIELD
	JUMPL TAC,WHOUU1	;IF -, JUST REPORT SYSTEM WHO LINE
	JUMPE TAC,.+2
	CAIL TAC,JOBN
	MOVE TAC,J		;ZERO OR GREATER THAN JOBN IS US
	HLLZ AC2,JBTSTS(TAC)
	TLNN AC2,JNA		;JOB THERE?
	JRST WHOUU2		;NO, ZERO STRING
	PUSH P,J
	MOVE J,TAC
	MOVEI AC1,TITLE		;USE PROTOTYPE
	SETZ DDB,		;FLAG WHOSER NO TTY HERE
	PUSHJ P,WHOTTY
	POP P,J
	MOVEI AC3,WTTYS		;WHERE TO PICKUP STRING FROM
WHOUU1:	SKIPN AC2,(AC3)
	JRST WHOUU2		;FINISH OUT WORD WITH NULLS
	TRZN AC2,1		;TEXT WORD?
	AOJA AC3,WHOUU1		;NO, CHECK NEXT WORD
	MOVE AC1,[POINT 7,AC2]
WHOUU0:	TLNN AC1,760000
	AOJA AC3,WHOUU1
	ILDB TEM,AC1
	JUMPE TEM,WHOUU0
	XCTR XDB,[IDPB TEM,UUO]
	JRST WHOUU0

WHOUU2:	XCTR XDB,[IDPB AC2,UUO]
	TLNE UUO,760000
	JRST WHOUU2
	POPJ P,
;TTEXS0 TTEXST TTEXS3 TTEXS4 TTUHUH TTEXLS TTEXRE TTEXLL TTEXN TTEXLD TTEXY TTEXLA TTEXLT TTEXLW TTSNB3 TTSENB TTSE98 TTSNB1 TTSNB2 TTSNBA TTSNBB TTSNBT TTSNBU TTSNBV TTSNBW TTSNBZ TTSNBY

;TTY EXIST nnn re-enables TTYnnn and re-sets its speed, NO EXIST disables TTY.
;DCADWN bit mark TTY down if on DCA.
;Multiple TTYs can be diddled by separating TTY numbers with commas,
;as in TTY EXIST 0,1,2,3,4,105,44
;With no arg (or if last arg followed by comma), types out list of
;TTYs that exist (or that don't exist, if NO used).  The CTY and PTYs are
;never in the list typed out.  TTYs that are not defined (LINBIT holds zero)
;are listed as non-ex.
TTEXS0:	LDB AC3,PUNIT		;Get line number of typer
	CAIE AC3,(LINE)		;Did user specify TTY TTYnn EXIST cmd?
	JRST TTUHUH		;Yes -- that ain't the right form!
TTEXST:	SKIPE TAC,SAVDDB(DDB)	;See if resuming a delayed cmd
	JRST TTEXRE		;Yes, pickup where we left off
	PUSHJ P,OCTIN
	 JRST TTEXLS		;NO ARG, list (non)existent TTYs.
	 JRST CPOPJ1		;NOT A NUMBER, ERROR
	CAIL TAC1,TTPLEN	;Legal TTY number?
	JRST CPOPJ1		;No, error
	HRRZ TAC,LINBIT(TAC1)	;Get DCA port number, if any
	JUMPE TAC,TTEXS4	;Jump if not on DCA, do nothing
	PUSH P,TEM		;Preserve delimiter in command
	SKIPGE -1(P)		;Skip unless TTY NO EXIST
	JRST [	PUSHJ P,DCADET	;Mark this TTY down
		JRST TTEXS3]
	PUSH P,TAC		;Preserve port number (+400000)
	PUSHJ P,DCAATT		;Mark this TTY up
	POP P,TAC
	PUSHJ P,DCASPR		;And set speed to default
	 JFCL			;Should never lose
TTEXS3:	POP P,TEM
TTEXS4:	CAIE TEM,","		;Another number coming?
	POPJ P,
	XCT CONTYI		;Get next character
	JRST TTEXST		;Yes

;He said TTY TTYnn <cmd.name>, which isn't right form.
TTUHUH:	SETZM SAVDDB(DDB)	;Make sure don't try to continue delayed cmd
	PUSHJ P,INLMES
	 ASCIZ/Wrong syntax.  Follow cmd with list of TTY numbers separated by commas./
	POPJ P,

;Here to list all TTYs that (don't) exist.
TTEXLS:	MOVSI TAC,-<DDL0+DDNUM>	;Chk all TTYs but CTY and PTYs
	TDZA AC3,AC3		;Flag that we haven't printed any numbers yet
;Here to resume delayed cmd now that output buffer is empty.
TTEXRE:	MOVEI AC3,","		;Flag that we've already printed some numbers
	SETZM SAVDDB(DDB)	;Don't come back here again
	MOVEI AC1,(TAC)		;Get first TTY number to check
	CAIL AC1,TTPLEN		;Make sure valid (maybe bad from SAVDDB)
	POPJ P,			;Should never happen, but if does, avoid typeout
	HLRZ AC1,TAC		;Get negative count of TTYs to do
	SUBI AC1,(TAC)		;Minus first TTY number
	CAIE AC1,-<DDL0+DDNUM>	;Should equal initial aobjn count
	POPJ P,			;Garbage from SAVDDB, avoid all typeout
	MOVE AC1,[PUSHJ P,TTEXLT] ;Instruction to type TTY number
	MOVE AC2,[JFCL]
	SKIPGE (P)		;Skip if TTY EXIST
	EXCH AC1,AC2		;AC1 now holds instruction to execute if TTY exists
	PUSH P,AC3		;Flag whether we've printed any numbers yet
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,TAC		;Aobjn for TTY numbers
TTEXLL:	HRRZ TAC,(P)		;Get line number
	HRRZ AC1,LINBIT(TAC)	;See if is on DCA
	TRZE AC1,400000		;Skip if not on DCA
	JRST TTEXLD		;On DCA
TTEXN:	XCT -1(P)		;Take action for non-ex TTY (not on DCA → non ex)
	JRST TTEXLA

TTEXLD:	MOVE AC2,DCATAB(AC1)	;Get status for TTY's port
	TRNE AC2,DCADWN		;Skip if up
	JRST TTEXN		;Down
TTEXY:	XCT -2(P)		;Take action for existing TTY
TTEXLA:	MOVE AC1,[1,,1]
	ADDB AC1,(P)		;Next TTY, if any
	JUMPL AC1,TTEXLL
	MOVEI TAC,[ASCIZ/None/]
	SKIPN -3(P)		;Did we print any numbers
	PUSHJ P,CONMES		;No, emphasize that fact
	SUB P,[4,,4]		;Flush data from stack
	POPJ P,

TTEXLT:	MOVEI TEM,4+4		;4 bytes needed to print TTY nbr (plus crlf ".")
	CAML TEM,TOFCTR(DDB)	;SEE IF WE HAVE ENOUGH ROOM IN OUTPUT BUFFER
	JRST TTEXLW		;NOT ENOUGH ROOM IN BUFFER, DELAY CMD NOW
	SKIPE TEM,-4(P)		;SKIP IF WE TYPED ANYTHING YET
	XCT TYO
	MOVEI TEM,","
	MOVEM TEM,-4(P)
	JRST OCTPNT		;OUTPUT LINE NUMBER IN TAC

TTEXLW:	MOVE TAC,-1(P)		;Get aobjn cnt of TTY numbers
	MOVEM TAC,SAVDDB(DDB)	;Remember where to resume cmd
	SUB P,[5,,5]		;Flush ret addr from TTEXLT and 4 data wds
	JRST TCMDLY		;Delay the TTY command

;"TTY ENB" CMD
;FORMS ARE:  TTY  {-}ENB <NUMLIST>|ALL|NONE|ε
;<NUMLIST>→NUM|NUM,<NUMLIST>

TTSNB3:	XCT CONTYI		;FLUSH THE COMMA
TTSENB:	PUSHJ P,OCTIN		;TTY SET ENABLES FOR TTYLOK
	JRST TTSNBT		;NO ARG.
	JRST TTSNBA		;NOT A NUMBER.
	CAIL TAC1,TTPLEN
	JRST TTSNB2		;IGNORE ILLEGAL NUMBER TOO HIGH
	MOVE TAC,TAC1
	IDIVI TAC,=36
	MOVN TAC1,TAC1		;NEGATE FOR USE IN SHIFTING
	MOVSI AC2,400000
	LSH AC2,(TAC1)
	SKIPGE (P)		;SKIP UNLESS -ENB
	JRST TTSNB1
	IORM AC2,TTYENB(TAC)	;TURN ON BITS IN TTY ENABLES
	JRST TTSNB2

TTSE98:	MOVEI TAC1,(TAC1)
	CAIL TAC1,TTPLEN
	POPJ P,			;IGNORE ILLEGAL NUMBER TOO HIGH
	PUSHACS
	MOVE TAC,TAC1
	IDIVI TAC,=36
	MOVN TAC1,TAC1		;NEGATE FOR USE IN SHIFTING
	MOVSI AC2,400000
	LSH AC2,(TAC1)
	IORM AC2,TTYENB(TAC)	;TURN ON BITS IN TTY ENABLES
	PUSHJ P,DISGST		;PRINT TIME ON CTY
	PUSHJ P,DISERR
	 [ASCIZ/TT EN /]
	 DISARG LOC,<TAC1-20(P)>
	 -1
	PUSHJ P,DISCRL
	POPACS
	POPJ P,

TTSNB1:	ANDCAM AC2,TTYENB(TAC)
TTSNB2:	CAIN TEM,","		;WAS OCTAL NUMBER TERMINATED BY COMMA?
	JRST TTSNB3		;YES.  LOOK FOR ANOTHER NUMBER
	JRST TTSNBT		;NOW OUTPUT RESULTS

TTSNBA:	PUSHJ P,CTEXT1
	MOVE AC3,[SETZM TTYLOK]	;"TTY ENB ALL" CLEARS TTY LOK
	CAMN TAC1,['ALL   ']
	JRST TTSNBB
	CAME TAC1,['NONE  ']	;"TTY ENB NONE" SETS TTYLOK
	JRST CPOPJ1
	TLC AC3,(<SETZM>≠<SETOM>) ;SO AC3←"SETOM TTYLOK"
TTSNBB:	SKIPGE (P)		;SKIP UNLESS "TTY -ENB ALL"
	TLC AC3,(<SETZM>≠<SETOM>)
	XCT AC3
	SETZM TTYENB		;IN ANY CASE, FORGET WHO WAS ENABLED
	SETZM TTYENB+1
	SETZM TTYENB+2
	SETZM TTYENB+3
	JRST TTSNB2		;LOOK FOR OTHER ARGUMENTS

TTSNBT:	SKIPE TTYLOK		;TTYLOK SET?
	JRST TTSNBU		;YES
	PUSHJ P,INLMES
	ASCIZ /All,/
TTSNBU:	SKIPN TTYENB
	SKIPE TTYENB+1
	JRST TTSNBV		;SOME ARE ENABLED
	SKIPN TTYENB+2
	SKIPE TTYENB+3
	JRST TTSNBV
	JSP TAC,CONMES
	ASCIZ /None
/

TTSNBV:	MOVEI TAC,0		;INITIAL LINE NUMBER
	PUSH P,TAC		;FLAG NO OUTPUT YET
	SKIPE AC2,TTYENB
	PUSHJ P,TTSNBW
	MOVEI TAC,=36
	SKIPE AC2,TTYENB+1
	PUSHJ P,TTSNBW
	MOVEI TAC,=36*2
	SKIPE AC2,TTYENB+2
	PUSHJ P,TTSNBW
	MOVEI TAC,=36*3
	SKIPE AC2,TTYENB+3
	PUSHJ P,TTSNBW
	SUB P,[1,,1]
	JSP TAC,CONMES
	ASCIZ /
/

TTSNBW:	JUMPG AC2,TTSNBY
	TLZ AC2,400000
	PUSH P,TAC
	PUSH P,AC2
	SKIPE TEM,-3(P)		;SKIP IF WE TYPED ANYTHING YET
	XCT TYO
	MOVEI TEM,","
	MOVEM TEM,-3(P)
	PUSHJ P,OCTPNT		;OUTPUT LINE NUMBER IN TAC
	SKIPE (P)		;SKIP IF NO BITS ARE LEFT
	JRST TTSNBZ		;THERE'S MORE TO PRINT
	SUB P,[2,,2]
	POPJ P,

TTSNBZ:	POP P,AC2
	POP P,TAC
TTSNBY:	LSH AC2,1
	AOJA TAC,TTSNBW
;ATTTTY DETTTY DCARUI DCARUN DCARU0 DCARU1 FDETD1 DCARU2 DCARUD

;HERE FROM CLKSER ON ATTACH TTY OR DETACH TTY COMMANDS

↑ATTTTY:PUSHJ P,STLNAC		;ENTER WITH DDB SET UP
	HRRZ TAC,LINBIT(LINE)	;DCA LINE?
	JUMPE TAC,CPOPJ		;NOPE, SORRY
	JRST DCAATT		;YES, TURN DTR ON

↑DETTTY:PUSHJ P,STLNAC		;ENTER WITH DDB SET UP
	HRRZ TAC,LINBIT(LINE)	;DCA LINE?
	JUMPE TAC,CPOPJ		;NOPE, SORRY
	JRST DCADET		;YES, TURN DTR OFF

repeat 0,<	;caller in DEVCHK also is commented out.
;Here at clock level from DEVCHK after too many IRMAs from this port
;during the last minute.  Report disabling on the CTY.
↑DCARUI:HRROS (P)		;Flag IRMA entry point, from DEVCHK in CH7
	JRST DCARU0
>;repeat 0

;HERE AT CLOCK LEVEL FROM CH3 REQUEST IF HIGH-SPEED PORT FLOODS US
;Detaches job from TTY if appropriate.  TTY has already been turned off at DCA.
;Notifies CTY as needed.
↑DCARUN:HRRZS (P)		;Flag entry point for too many interrupts
DCARU0:	MOVE TAC,DCATAB(DAT)	;See if Microswitch port
IFE FTF2,<	;I want these logged at CCRMA  --TVR
	TRNE TAC,DCADPB		;Don't say anything for DD/III kbds
	POPJ P,			;And don't det job from TTY
>;IFE FTF2
	MOVEI LINE,(DAT)	;GET DATUM FROM CLKQ INTO LINE
	LDB LINE,DCALIN		;GET TTYSER LINE NUMBER
	PUSH P,LINE		;SAVE NUMBERS FOR MESSAGE
	PUSH P,TAC		;THIS TELLS LATER WHETHER TTY OR DLN
	PUSH P,DAT
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /DEVICE/
	MOVEI AC1,[ASCIZ /Turning off runaway DCA port /]
	SKIPGE -3(P)
	MOVEI AC1,[ASCIZ /Turning off IRMA'd DCA port /]
	PUSHJ P,DISSTR
	POP P,TAC
	PUSHJ P,DISLOC
	POP P,TAC		;GET DCATAB ENTRY
	TRNE TAC,DCADLB		;DIALNET PORT?
	JRST DCARUD		;YES
	PUSHJ P,DISMES
	ASCIZ /, TTY/
	MOVE TAC,(P)		;GET BACK TTY LINE NUMBER
	PUSHJ P,DISLOC
	PUSHJ P,DISCRL
	POP P,LINE		;POP TTY LINE NUMBER AS ARG
IFN FTF2∧FTGRIN,<
	CAIGE LINE,DPYL0	;Don't detach displays even though we log them.
>;IFN FTF2∧FTGRIN
IFE FTF2∧FTGRIN,<
	CAIGE LINE,TTPLEN	;Make sure it's a valid TTY number
>;IFE FTF2∧FTGRIN
	SKIPN DDB,TTYTAB(LINE)	;GET DDB
	 POPJ P,		;NO DDB, SO NO JOB TO DETACH TTY FROM
	MOVE TAC,DEVMOD(DDB)	;See if TTY is a job's attached terminal
	TLNE TAC,TTYATC		;Skip if TTY not attached to job
	PUSHJ P,TTYDET		;DETACH TTY FROM JOB IF IT HAS ONE
	 POPJ P,		;DIDN'T HAVE A JOB
	POPJ P,
REPEAT 0,<
	SKIPN DDB,TTYTAB(LINE)	;IS THERE A DDB?
	JRST DCARU1		;NO, OK TO DETACH
	LDB TAC,PJOBN		;YES, WHOSE IS IT?
	JUMPN TAC,DCARU1	;SOME JOB, OK TO DETACH
	MOVE TAC,DEVMOD(DDB)	;JOB 0, MAYBE ALREADY DETACHED
	TRNE TAC,ASSCON		;TEST THE BIT FOR DETACHED FROM SYSTEM
	JRST DCARU2		;ALREADY DETACHED BUT STILL LOSING, HELP!!
DCARU1:	MOVEI J,0		;SIMULATE FORCED COMMAND ON CTY
	PUSH P,TAC1		;SAVE LINE NUMBER
	PUSHJ P,GETDBA		;FIND OR MAKE A DDB
	 JRST TPOPJ		;SORRY
	PUSHJ P,TTYDET		;DETACH TTY FROM JOB IF IT HAS ONE
	 JRST FDETD1		;DIDN'T HAVE A JOB
	MOVE TAC1,(P)		;GET LINE NUMBER
	PUSHJ P,GETDBA		;MAKE A BRAND NEW DDB
	 JRST TPOPJ		;SAY WHAT?
FDETD1:	POP P,TAC1		;RESTORE PDL
	POPJ P,

;continuing REPEAT 0
DCARU2:
IFN FTP2,<
	SETOM KABELL		;WAKE SOMEONE UP
>;IFN FTP2
IFN FTDCHK,<
	HRRZ TAC,LINBIT(LINE)
	TRZ TAC,400000		;DCA PORT NUMBER
	MOVEM TAC,CHKDCA	;LET BH KNOW WHAT'S GOING ON
>;IFN FTDCHK
	PUSHJ P,DISMES
	ASCIZ /It was already turned off!!  I need help.  Please unplug the cable
from the DCA scanner.  If you need help, call a wizard.
Then type $P and write a log note including the port number above.
/
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCAL
	SETOM FRCFLG		;YES, COULD BE BUMMED, I'M BEING PARANOID
	JRST FLUSH0
>;REPEAT 0

;Here if dialnet port got shut off.
DCARUD:	PUSHJ P,DISMES
	ASCIZ /, DLN/
	POP P,TAC
	PUSHJ P,DISLOC
;CAN YOU DETACH A DLN?  NOTE, F.DEVD ASSUMES IT'S A TTY! (EG CALLS FLUSH0)
	JRST DISCRL
;TTYATT TTYAT2 TTYAT3 TTYAT4

;ATTACH TTY (I.E., LINE) TO THE DDB THAT THE JOB IS ALREADY ATTACHED TO.
;THEN, FLUSH THE LINE'S OLD DDB IF NECESSARY.

↑TTYATT:PUSHJ P,STLNAC		; GET LINE CHARACTERISTICS
	SKIPA DDB,[TTYLST]	;SEARCH FOR DDB THAT IS ATTACHED
TTYAT2:	HLRZ DDB,DEVSER(DDB)
	JUMPE DDB,CPOPJ		;HAVE ALL TTY DDB'S BEEN LOOKED AT?
	LDB TAC,PJOBN		;NO, GET JOB NUMBER.
	HLL TAC,DEVMOD(DDB)	;ATTACH AND USE BITS
	TLNN TAC,DVTTY		;IS THIS STILL A TTY DDB?
	JRST TTYAT2		;NO, THIS MUST BE IJOB.
	MOVE IOS,DEVIOS(DDB)
	CAIN J,(TAC)		;JOB NUMBER THE ONE TO ATTACH?
	TLNN TAC,TTYATC		;YES, IS DDB ATTACHED TO JOB?
	JRST TTYAT2		;NO, KEEP LOOKING.
	TLNN IOS,TTYDTC		;YES.  IS DDB DETACHED FROM LINE?
	POPJ P,			;NO - DDB SET FOR ERROR (TTYn ALREADY ATT.)
	PUSH P,DDB		;SAVE ADDRESS OF THE DDB BELONGING TO JOB.
	MOVE DDB,TTYTAB(LINE)	;DDB OF LINE THAT TYPED ATT COMMAND.
	LDB TAC,PJOBN		;GET JOB # OF OLD DDB
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSH P,DEVIOS(DDB)	;SAVE TOIP OF DDB BEING DETACHED FROM LINE
	JUMPN TAC,TTYAT3	;IF NON-ZERO, OLD JOB IS BEING DETACHED.
	MOVSI TAC,IO!TOIP!IRMA	;NO JOB THERE.  CLEAR THESE BITS
	ANDCAM TAC,DEVIOS(DDB)	;SO DDB GETS KILLED BY TTYDET
TTYAT3:	SETOM RSPLOK		;DON'T CLEAR RESPONSIBLE TTY
	PUSHJ P,TTYDET		;DETACH OLD DDB FROM TTY
	 PUSHJ P,TTYKDT		;NO JOB ATTACHED TO DDB, KILL OLD DDB
	SETZM RSPLOK
	POP P,IOS		;FROM OLD DDB
	POP P,DDB		;GET BACK NEW GUY
	MOVSI TAC,IO!TOIP!IRMA
	ANDCAM TAC,DEVIOS(DDB)	;TURN OFF OLD BITS IN OLD DDB
	AND IOS,TAC		;GET NEW BITS FROM OTHER DDB
	HLL LINE,LINTAB(LINE)
	TLNN LINE,DISLIN!DDDLIN!PTYLIN
	IORM IOS,DEVIOS(DDB)	;COPY IO!TOIP TO NEW DDB (ONLY IF REAL TTY)
	MOVEM DDB,TTYTAB(LINE)	;TTYDET CLOBBERS THIS.
	DPB LINE,PUNIT		;SET THIS LINE IN DDB
	PUSHJ P,TTYATI		;SET UP NEW DDB
				;NOW, GO TO INTERUPT LEVEL TO SET DAT
				;AND CHECK IF TYPING NEEDS TO BE STARTED.
	PUSH P,J		;SAVE THIS
	PUSHJ P,TYPT2		;START TYPING IF NEEDED
	ONSCN
	POP P,J
	DPB LINE,PUNIT		;SET LINE NUMBER (UNIT NO.) IN DDB.
	DPB LINE,PTALK		;TALK RING TO CONTAINS ONLY THIS TTY
	MOVEI TAC,0
	ANDI LINE,-1
TTYAT4:	ROTC TAC,-3		;LOW 3-BITS OF LINE INTO 3 HIGH BITS OF TAC
	HRRI TAC,2		;CONVERT TO SIXBIT
	ROT TAC,-3		;BY SHIFTING +20 INTO TAC
	JUMPN LINE,TTYAT4	;LOOP WHILE THERE'S ANYTHING LEFT.
	HRRI TAC,'TTY'
	MOVSM TAC,DEVNAM(DDB)
	PUSHJ P,STLNAC
	MOVSI TAC,'CTY'
	TLNE LINE,CTYLIN	;IS THIS CONSOLE TTY?
	MOVEM TAC,DEVNAM(DDB)	;YES, CHANGE NAME TO CTY.
	JRST CPOPJ1		;SUCCESSFUL RETURN.
;TTYDET TRESCN TRESC1 TRESCU TRESCB TRESCA

;ROUTINE TO DETACH TTY FROM JOB
;CALL:	MOVE DDB,ADDRESS OF TTY DDB TO BE DETACHED
;	PUSHJ P,TTYDET
;	<RETURN IF WAS ALREADY DETACHED OR NOT ATTACHED TO JOB>
;	<RETURN HERE IF WE REALLY ZEROED TTYTAB>

;CALLED FROM TTYATT AND COMCON (DETACH).  CLEARS TTYATC AND TTYTAB.
;SETS TTYDTC IN DEVIOS(DDB)
↑TTYDET:LDB TAC,PJOBN		;GET JOB NO.
	SETOM JBTLIN(TAC)	;FLAG JOB AS DETACHED.
	MOVE TAC,DEVMOD(DDB)	;SET TTY DETACHED BIT
	MOVE AC1,DEVIOS(DDB)	;GET OLD IOS
	TLNE TAC,TTYATC		;WAS TTY NOT REALLY ATTACHED TO JOB?
	TLNE AC1,TTYDTC		;OR WAS IT REALLY DETACHED FROM TTY?
	POPJ P,			;YES TO ONE, GIVE ERROR RETURN
	MOVSI IOS,TTYDTC
	IORB IOS,DEVIOS(DDB)	;MARK DDB AS DETACHED NOW
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,WAKTJB		;wake up job, if waiting for tty output
	PUSHJ P,TTYSKL		;PLANT CLK REQ TO KILL DPY HDR, SET UP LINE
	MOVEI TAC,SPCMOD
	ANDCAM TAC,ACTMOD(DDB)	;TURN OFF SAVED COPY OF SPECIAL ACTIVATION MODE BIT
	MOVE AC1,LINTAB(LINE)	;GET LINE CHARACTERISTICS
	TLNE AC1,SPCBRK		;SPECIAL ACTIVATION MODE ON?
	IORM TAC,ACTMOD(DDB)	;YES, TURN IT ON IN DETACHED TTY DDB
	PUSHJ P,TTYKL1		;GO CLEAR TRANSLATOR TABLE
	AOS (P)			;SKIP MEANS WE REALLY FLUSHED TTYTAB
	JRST SCNONJ		;TURN ON SCANNER CHANNEL

;ROUTINE TO RESET COUNTS AND BYTE POINTERS TO RESCAN THE LAST COMMAND LINE
↑TRESCN:LDB TAC,PCOMIC		;GET OLD TITCTR
	MOVEM TAC,TITCTR(DDB)	;RESTORE IT
	PUSHJ P,TBYTEP
	MOVEM TAC,TITAKR(DDB)
IFN FTMONCIP,<
	SETZM MONCIP(DDB)	;NO MONITOR COMMAND NOW NEEDING PROTECTION IN BUFFER
>;IFN FTMONCIP
TRESC1:	MOVE TAC,TIPCTR(DDB)	;CALLED HERE FROM ↑U CODE
	OFFSCN			;TURN OFF SCANNER CHANNEL
	SUB TAC,TITCTR(DDB)	;THIS IS NOW THE NEW CHR. COUNT TO END OF BUFFER
	SKIPG TAC
	ADDI TAC,TTICHR
	MOVEM TAC,TIFCTR(DDB)
	ONSCN			;TURN ON SCANNER CHANNEL
	JRST STLNAC

;UUO ROUTINE TO RESCAN LAST COMMAND LINE.
↑TRESCU:TLNE IOS,TPMON		;MONITOR MODE?
	POPJ P,			;OH WELL, LOSERS LOSE
	TRNN UUO,-1
	JRST TRESCA
	LDB TAC,PCOMIC
	SUB TAC,TITCTR(DDB)
	SKIPG TAC
	ADDI TAC,TTICHR
IFN FTMONCIP,<
	SKIPL MONCIP(DDB)	;SKIP IF CALL TO SKPBRK WAS SUPPRESSED BY MON CMD
	JRST TRESCB		;NO ADJUSTMENT NECESSARY FOR RESCANNED CHAR COUNT
	ADD TAC,TISYNC(DDB)	;INCLUDE ACTIVATED CHARS NOT YET READ FROM TTY BUF
	SKIPE AC1,LETAB(LINE)	;SEE IF THERE ARE CHARS WAITING IN THE LINE EDITOR
	TLNN AC1,WTFLAG		;SKIP IF SO (THERE OUGHTA BE SOME)
	JRST TRESCB		;NOT DPY OR NOT WAITING
	ADD TAC,NTABCT(AC1)	;INCLUDE ACTIVATED CHARS WAITING IN LE IN RESCAN CNT
>;IFN FTMONCIP
TRESCB:	XCTR XW,[MOVEM TAC,(UUO)]
TRESCA:	PUSHJ P,TRESCN		;RESCAN LINE
	JRST SYNCHK		;RE-CALCULATE ACTIVATED CHAR. COUNT.
;TLHBYT TBYTEP

; ROUTINE TO MAKE A POINTER TO THE BUFFER OUT OF A COUNT OF CHARACTERS
; FROM THE START OF THE BUFFER.

	XWD 441100,0
TLHBYT:	XWD 331100,0
	XWD 221100,0
	XWD 111100,0
	XWD 001100,0

TBYTEP:	PUSH P,LINE		;SAVE LINE
	MOVNS TAC
	ADDI TAC,TTICHR
	IDIVI TAC,4
	ADD TAC,TTIBUF(DDB)
	HLL TAC,TLHBYT(LINE)
	POP P,LINE		;RESTORE LINE
	AOJA TAC,CPOPJ
;⊗ TTYGET TTYFNU TTYFND TTYDAT TTYFUW TTYFU3 OPNTTY OPNTT1 TTYICK TTYIC2 TTYIC3 TTYIC5 TTIC33 TTYIC4 CLRIMG CLRIM3 CLRIM2
;ROUTINE TO FIND TTY FOR A JOB
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,TTYFND
;	RETURN WITH DDB SET TO ADR OF DDB
;	AND DAT SET TO BYTE POINTER TO MONITOR OUTPUT BUFFER

TTYGET:		
↑TTYFNU:MOVE J,JOB
↑TTYFND:PUSHJ P,TTYSRC
↑TTYDAT:MOVEI DAT,TTOBUF(DDB)
	POPJ P,


;PUT JOB IN IO WAIT IF TTY BUFFER NOT EMPTY
;CALLED BY NON ERROR MESSAGE ROUTINES AT UUO LEVEL

↑TTYFUW:PUSHJ P,TTYFNU
	LDB TAC,PJOBN		;GET JOB # OF DDB
	CAME TAC,JOB		;IS THIS OURS?
	POPJ P,			;NO, FORGET IT.
TTYFU3:	MOVE TAC,TOPUTR(DDB)
	CAMN TAC,TOTAKR(DDB)
	POPJ P,
	MOVEI IOS,IOACT		;DDB HAS SOME OUTPUT ALREADY
	IORB IOS,DEVIOS(DDB)
	PUSHJ P,WSYNC
	JRST TTYFU3

;HERE FROM OPEN AND INIT UUOS
↑OPNTTY:
	PUSH P,UUO
	PUSH P,AC3
	PUSHJ P,STLNAC
	HRRZ TAC,LINBIT(LINE)	;GET DCA PORT NUMBER
	JUMPE TAC,OPNTT1	;no speed setting if not DCA port
	MOVEI UUO,LS300		;SET DEFAULT SPEED TO 300 BAUD
	MOVSI AC3,DCADIL	;GET DIALING BIT
	OFFSCN
	IORB AC3,DCATAB-400000(TAC) ;turn on bit to avoid auto baud detect
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,TTYATC		;don't set speed if line in use as job's TTY
	TRNN AC3,DCABDB		;skip if this is an auto baud line
	CAIA			;don't set speed
	PUSHJ P,SETSPD		;set speed of TTY's DCA port to 300
	 JFCL			;Skips on error
	ONSCN
OPNTT1:	POP P,AC3
	POP P,UUO
	;JRST TTYICK	;FALLS INTO TTYICK

;HERE WHEN TTY IOS CHANGES, SEE IF ENTERING OR LEAVING IMAGE MODE (10,11)
↑TTYICK:MOVE IOS,DEVIOS(DDB)
	TRNE IOS,10
	TRNE IOS,6		;WERE WE ALREADY IN IMAGE MODE?
	JRST TTYIC2		;NO
	TRNE UUO,10		;YES
	TRNE UUO,6		;WILL WE STILL BE IN IMAGE MODE?
	JRST [	PUSH P,LINE	;NO, WAIT FOR OUTPUT BUFFER TO EMPTY
		JRST TTYIC3]
	POPJ P,

;HERE IF WE MIGHT BE ENTERING IMAGE MODE
TTYIC2:	TRNE UUO,10		;NOT ALREADY IN IMAGE MODE
	TRNE UUO,6		;ARE WE GOING INTO IMAGE MODE?
	POPJ P,			;NO
	PUSH P,LINE
	PUSHJ P,STLNAC
	TLNE LINE,DDDLIN!DISLIN	;LOCAL DISPLAY?
	TRZ UUO,11		;YES, CAN'T GO INTO IMAGE MODE
	TLNN LINE,DMLIN		;DM?
	JRST TTYIC3
	SKIPE LINE,LETAB(LINE)	;GET DPY HDR
	SETOM DMXY(LINE)	;WE DON'T KNOW WHERE CURSOR WILL BE
TTYIC3:
IFE FTF2,<
	LDB LINE,PUNIT		;GET LINE NUMBER, NO BITS
	CAIE LINE,APLINE	;ASSOCIATED PRESS WIRE?
	CAIN LINE,NYLINE	;OR NEW YORK TIMES?
	JRST TTYIC5		;YES, DON'T WAIT FOR OUTPUT -- NO XMTR CARDS
>;IFE FTF2
	POP P,LINE
	PUSHJ P,TTYFU3		;YES, WAIT FOR OUTPUT BUFFER TO EMPTY
	PUSH P,LINE
TTYIC5:	LDB LINE,PUNIT		;GET LINE NUMBER
IFE FTIP,<
	CAIL LINE,PTYL0		;IS IT A PTY?
	SKIPN LINE,PTYJOB-PTYL0(LINE)
	JRST TTYIC4		;NOT A PTY OR NO CONTROLLING JOB
>;IFE FTIP
IFN FTIP,<
	CAIGE LINE,PTYL0	;Is it a PTY?
	JRST TTYIC4		;No
	SKIPE PTYIMP-PTYL0(LINE) ;Is it an IMP PTY?
	PUSHJ P,TTICMP		;Yes, go tell IMPSER
	SKIPN LINE,PTYJOB-PTYL0(LINE)
	JRST TTYIC4		;No controlling job
>;IFN FTIP
	PUSH P,TAC		;GET AN AC
	MOVSI TAC,INTTTC	;INTERRUPT BIT FOR PTY STATUS CHANGE
	TDNN TAC,JBTIEN(LINE)
	JRST TTIC33
	IORM TAC,JBTIRQ(LINE)
	TDNE TAC,JBTMSK(LINE)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, RUN INTERRUPTS
TTIC33:	POP P,TAC
TTYIC4:	POP P,LINE
	POPJ P,

;HERE TO CLEAR TTY IMAGE MODE FOR JOB IN J.
↑CLRIMG:PUSH P,DDB
	HRRE DDB,JBTLIN(J)	;GET JOB'S LINE NUMBER
	JUMPL DDB,CLRIM2	;JUMP IF DETACHED
	SKIPN DDB,TTYTAB(DDB)	;GET TTY DDB
	JRST CLRIM2		;NO DDB, CAN'T BE IMAGE MODE
	PUSH P,IOS
	MOVE IOS,DEVIOS(DDB)	;GET IOS
	TRNE IOS,10
	TRNE IOS,6
	JRST CLRIM3		;NOT IMAGE MODE
	MOVEI IOS,11		;IMAGE MODE NOW, BUT NOT IN A MOMENT
	ANDCAB IOS,DEVIOS(DDB)	;CLEAR IMAGE MODE
	TLNE IOS,TTYDTC		;IS THIS A DETACHED TTY DDB?
	JRST CLRIM3		;YES, NO DM QUEUES TO FLUSH
	PUSHACS
	PUSHJ P,STLNAC		;GET LINE NUMBER AND CHARACTERISTICS
	TLNE LINE,DMLIN		;DATAMEDIA?
	SKIPN DAT,LETAB(LINE)	;ANY DPY HDR?
	JRST .+2		;NO, NO QUEUES
	PUSHJ P,LEPDM1		;YES, FLUSH ALL THE DM QUEUES
	POPACS
CLRIM3:	POP P,IOS
CLRIM2:	POP P,DDB
	POPJ P,
;TTYERP TTYERR TTYER1 TTYDX1

;ROUTINE TO INDICATE MONITOR ERROR MESSAGE TO BE FORCED OUT
;WHEN NO MORE ROOM IN TTO BUFFER, TTI BUFFER WILL BE USED


LOSYS

;HERE TO START ERROR TYPEOUT AND CLEAR INPUT
↑TTYERP:PUSH P,[SETBFI]		;RETURN VIA SETBFI
;HERE IF YOU NEED SPACE BUT DON'T NECESSARILY NEED TO FLUSH INPUT
↑TTYERR:PUSHJ P,TTYSRC		;FIND TTY DDB
	MOVEI IOS,MERTPO	;SET MONITOR ERROR PRINT OUT BIT
	IORB IOS,DEVIOS(DDB)
	TLNE IOS,TTYDTC		;LEAVE IF DETACHED LINE
	POPJ P,
	PUSHJ P,STLNAC
	TLNN LINE,DISLIN!DDDLIN!DMLIN
	POPJ P,
	PUSHACS
	HRRZ DDB,LETAB(LINE)	;GET THE RIGHT SIDE ONLY
	JUMPE DDB,TTYDX1	;NO DPY HEADER
	HLRZ DAT,PPCALL(DDB)
	HLL DDB,LINE		;SET DISPLAY-TYPE BIT
	HLL DAT,DDB		;AND COPY IT HERE
	PUSHJ P,PPCLR
TTYDX1:	POPACS
	POPJ P,
;TTYSET TTYSTC TTYSTR TTYST3 TTYST2 TTYSTF TTYUSR

;SET TTY INTO USER MODE NOW. (CALLED FROM RUNCSS - USTART/MSTAR2)
;CLEARS DDTM,IOSUPR,USRB,TTYIOW AND IOW
;CALL:	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,TTYSET

↑TTYSET:MOVE IOS,[DDTM+USRB+TTYIOW+IOW,,IOSUPR]
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

;START TTY OUTPUT
;CALL:	MOVE DAT,BYTE POINTER TO LAST OUTPUT ITEM
;	MOVE DDB,ADDRESS OF TTY DDB
;	MOVE J,JOB NUMBER	;(MUST BE PRESERVED)
;	PUSHJ P,TTYSTR

;CALLED FROM COMINI (LOTS OF PLACES)
;INITIALIZES TTY FOR MONITOR OUTPUT AND STARTS OUTPUT


;TTYSTC - SAME AS TTYSTR, BUT CLEARS USRB FIRST.
↑TTYSTC:MOVSI TAC,USRB		;START TTY OUTPUT AFTER CLEARING USRB
	ANDCAM TAC,DEVIOS(DDB)
↑TTYSTR:MOVE IOS,[DDTM!IOBEG!IO!TPMON,,IOSUPR!IOBKTL!IOACT]
	ANDCAB IOS,DEVIOS(DDB)
	TLNE IOS,TTYDTC		;DON'T START DETACHED LINES
	POPJ P,
	PUSH P,J		;preserve J in case DDB is SCNDDB and J is phantom
	PUSH P,[POPJJ]		;make us return to place that restores J
	MOVSI TAC,IO!TPMON
IFE FTMONCIP,<
	TLNE IOS,USRB		;GOING OUT OF MONITOR MODE?
	TLZ TAC,TPMON		;YES, DON'T DIDLE THESE
>;IFE FTMONCIP
IFN FTMONCIP,<
	TLNE IOS,USRB		;GOING OUT OF MONITOR MODE?
	TLZA TAC,TPMON		;YES, DON'T DIDLE THIS BIT
	PUSHJ P,MCMSKP		;NO, SKIP TO END OF ANY REMAINING MONITOR CMD
>;IFN FTMONCIP
	IORM TAC,DEVIOS(DDB)
	MOVSI TAC,USRB+TPMON
	TLNE IOS,USRB
	ANDCAM TAC,DEVIOS(DDB)
↑TTYST3:MOVE IOS,DEVIOS(DDB)	;GET CORRECT IOS
TTYST2:	PUSHJ P,STLNAC		;GET LINE CHARACTERISTICS
	SKIPLE TISYNC(DDB)	;ANY TYPE AHEAD?
	PUSHJ P,COMSET		;YES.
	JRST UTYPET		;GO TYPE FIRST CHAR.

↑TTYSTF:MOVSI IOS,IO		;SET THIS BIT TO CAUSE TTYKIL TO BE CALLED WHEN
	IORB IOS,DEVIOS(DDB)	;OUTPUT DONE, PROVIDED PJOBN OF DDB IS ZERO
	JRST TTYST2

;SET SCANNER TO START UP JOB WHEN OUTPUT FINISHES
;CALL:	MOVE DDB,TTY DDB ADR.
;	PUSHJ P,TTYUSR
;	TTY WILL GO TO USER MODE WHEN TYPING OUT STOPS

↑TTYUSR:MOVSI IOS,USRB		;SET BIT TO SWITCH TTY TO USER MODE
	IORM IOS,DEVIOS(DDB)	;WHEN MONITOR OUTPUT FINISHES
	JRST SETRUN		;GO FLAG JOB AS RUNABLE IMMEDIATELY
;TLKTST TTYTLK TLKNPG TLKSTR TLKST1 TLKSIX TLKCHR

;ROUTINE TO ADD TTY TO TALK RING
;CALL:	ADR. OF DDB TO BE ADDED TO RING AT -3(P)
;	MOVE TAC,SIXBIT /TTYN/
;	PUSHJ P,TTYTLK
;	TTY IS BUSY RETURN OR NOT A TTY OR TOO BIG A LINE NO.
;	OK RETURN, TTY ADDED TO TALK RING

↑TLKTST:PUSHJ P,GETDDB		; IN CASE NOT SET UP
	 POPJ P,		;NONE AVAIL. GIVE UP
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVTTY
	POPJ P,
	MOVE IOS,DEVIOS(DDB)	;IS TTY IN MONITOR MODE AND LEFT HAND MARGIN?
	TRNE IOS,10
	TRNE IOS,6		;TEST MODES 10 AND 11
	SKIPA TAC,IMLHAC(DDB)	;TTY GAG PREVENTS TALKING
	POPJ P,			;IMAGE MODE (10 OR 11), NO TALK
	TRNN TAC,GAGBIT!GAGTBT	;BH NO MATTER HOW PRIVELEGED S/HE IS
	TLNE IOS,TTYHLD		;EVIL THINGS MIGHT HAPPEN IF WE TRY TALKING
	POPJ P,			;TO A LINE THAT'S HOLDING.
	LDB LINE,PUNIT		;TTY LINE NUMBER OF TARGET
	PUSHJ P,PPLNCT		;ASK DPYSER FOR SIZE OF CURRENT PP
	CAIGE TAC,=15		;MUST BE THIS MANY LINES OR WE REFUSE THE TALK
	JUMPN TAC,CPOPJ		;(TAC=0 IF NOT A DPY, -1 IF PP NOT ACTIVATED)
	LDB LINE,PUNIT		;BH LINE IS SOMEBODY IN THE RING
	SKIPE TAC,LETAB(LINE)	;IS THIS A DPY?
	SKIPN DPHOLD(TAC)	;YES, IS IT HOLDING?
	AOS (P)			;NOT DPY OR NOT HOLDING
	POPJ P,			;CAN'T TALK TO HOLDER

↑TTYTLK:PUSHJ P,TLKTST		;CHECK IF ALLOWED TO TALK
	 POPJ P,		;NO, BUSY
	MOVE LINE,-3(P)		;TTY GIVING TALK COMMAND
	MOVE LINE,DEVNAM(LINE)	;ITS NAME
	MOVE TAC,DEVNAM(DDB)	;OPR IS NEVER TOO BUSY...
	CAMN LINE,TAC		;IF THE SAME,
	POPJ P,			;  NO SOAP
	LDB LINE,PUNIT
	MOVEI TAC,[ASCIZ /;; Link from /]
	PUSHJ P,TLKSTR		;BH 1/5/78 LET THEM KNOW
	EXCH DDB,-3(P)		;BH CALLER INTO DDB
	LDB TAC,PJOBN		;BH CALLER'S JOB NUMBER
	EXCH DDB,-3(P)		;BH GET BACK TALKEE'S DDB
	JUMPE TAC,TLKNPG	;JUMP IF NO JOB, THUS NO PRG
	HRLZ TAC,PRJPRG(TAC)	;BH JOB EXISTS, GET PROGRAMMER NAME
	PUSHJ P,TLKSIX		;BH PASS AROUND THE NAME
	MOVEI TAC,[ASCIZ / at /];5/27/78 BH.  MARTY WANTS BOTH PRG AND TTY
	PUSHJ P,TLKSTR
TLKNPG:	MOVE TAC,-3(P)
	MOVE TAC,DEVNAM(TAC)
	PUSHJ P,TLKSIX
	MOVEI CHR,40		;BH SPACE
	PUSHJ P,TLKCHR		;BH
	OFFSCN			;TURN OFF SCANNER CHANNEL
	LDB LINE,PUNIT		;LINE NUMBER IN RING.
	MOVSI TAC,TLKRNG
	LDB CHR,PTALK
	TDNN TAC,LINTAB(LINE)
	HRRZ CHR,LINE
	IORM TAC,LINTAB(LINE)
	EXCH DDB,-3(P)		;GET DDB OF TALKER
	LDB LINE,PUNIT		;LINE NO. OF TALKER
	DPB CHR,PTALK		;SET TO POINT INTO RING
	MOVSI TAC,TLKRNG
	IORM TAC,LINTAB(LINE)
	MOVEM LINE,TAC		;SAVE LINE NO. OF TALKER
	EXCH DDB,-3(P)		;RESTORE
	LDB LINE,PUNIT		;LINE NO. IN RING AGAIN
	DPB TAC,PTALK		;MAKE IT POINT TO TALKER
	MOVE DDB,-3(P)		;BH GET GIVER OF COMMAND
	LDB LINE,PUNIT		;BH TALKER'S LINE NUMBER
	MOVEI CHR,7		;BH GET A BEEP
	PUSHJ P,DOTALK		;BH BEEP ALL BUT TALKER
	ONSCN			;TURN ON SCANNER CHANNEL
	PUSHJ P,INLMES		;NOTIFY OUR GUY
	ASCIZ /OK /
	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,TYPTST
	JRST CPOPJ1		;OK RETURN


TLKSTR:	HRLI TAC,440700
TLKST1:	ILDB CHR,TAC		;BH 1/5/78 TYPE STRING IN TAC TO RING IN LINE
	JUMPE CHR,CPOPJ
	PUSHJ P,TLKCHR
	JRST TLKST1

TLKSIX:	JUMPE TAC,CPOPJ		;BH 1/5/78 TYPE SIXBIT NAME TO TALK RING
	LDB CHR,[POINT 6,TAC,5]
	LSH TAC,6
	JUMPE CHR,TLKSIX
	ADDI CHR,40		;ASCIIFY
	PUSHJ P,TLKCHR
	JRST TLKSIX

TLKCHR:	PUSH P,TAC
	OFFSCN
	PUSHJ P,DOTALK
	ONSCN
	JRST TPOPJ
;TTYSRC STLNAC
;ROUTINE TO SEARCH TRANSLATOR TABLE FOR TTY
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,TTYSRC
;	RETURN WITH ADDRESS OF DEVICE DATA BLOCK IN DDB.

↑↑TTYSRC:
	JUMPE J,TTYF1		;SEARCH FOR OPER. TTY IF JOB NO. 0
	MOVSI LINE,TTYATC
	HRRE TAC,JBTLIN(J)	;FIRST TRY THE EASY WAY
	JUMPL TAC,TTYFX		;JUMP IF LINE IS DETACHED
	CAIL TAC,TTPLEN		;COMPARE WITH MAX TTY NUMBER
	JRST TTYFX		;JBTLIN HAS SHIT
	HRRZ DDB,TTYTAB(TAC)	;GET THE DDB ADDRESS
	JUMPE DDB,TTYFX		;JUMP IF NOBODY HOME
	LDB TAC,PJOBN		;TEST CREDENTIALS
	TDNE LINE,DEVMOD(DDB)
	CAIE TAC,(J)		;SAME AS THE ONE WE WANT?
	JRST TTYFX		;NO.
	JRST TTYF9

TTYFX:	MOVEI DDB,TTYLST	;TTYDDBS START HERE
TTYSRA:	LDB TAC,PJOBN		;JOB ATTACHED TO THIS DDB
	CAIE TAC,(J)		;IS THIS THE ONE
	JRST TTYF0
	TDNE LINE,DEVMOD(DDB)	;IS HE ATTACHED TO IT?
	JRST TTYF9		;YES.
TTYF0:	HLRZ DDB,DEVSER(DDB)	;FOLLOW CHAIN
	JUMPN DDB,TTYSRA	;TO ITS END
TTYF1:	SKIPE TAC,DEVOPR
	JRST TTYF3
	MOVEI LINE,TCONLN	;NO USE CTY.
	SKIPE DDB,TTYTAB(LINE)	;DOES IT HAVE A DDB?
	JRST TTYF9
	MOVSI TAC,'CTY'		;NO
TTYF3:	PUSHJ P,GETDDB		;GET A DDB FOR DEVOPR
	JRST SCREW		;OH BOY HERE WE GO
TTYF9:	MOVE IOS,DEVIOS(DDB)	;SET UP IOS
	SETZ LINE,
	TLNE IOS,TTYDTC
	POPJ P,
↑STLNAC:LDB LINE,PUNIT		;GET UNIT # FROM DDB
	HLL LINE,LINTAB(LINE)	;AND LINE BITS
	POPJ P,			;RETURN
;GETDDB UGTDDB GETDBA GETDB0 GETDB2 LOG2LN SIX2LN LOG2LL SCREW

;FIND A DDB FOR A TTY (BY ITS SIXBIT NAME), MAKES ONE IF NEEDED.
;CALL:	MOVE TAC,[SIXBIT /TTYn/]
;	PUSHJ P,GETDDB
;	<NONE AVAILABLE OR DEVICE NAMED IS NOT A TTY OR CTY>
;	<LINE AND DDB SETUP>

↑GETDDB:TDZA LINE,LINE		;MONITOR REQUEST, NO SPECIAL LINES
↑UGTDDB:MOVNI LINE,1		;USER ASSIGN OR INIT or TTY cmd, SPECIAL LINE OK
	PUSH P,LINE		;SAVE THE FLAG
	PUSHJ P,LOG2LN		;CONVERT LOGICAL NAME TO LINE NUMBER
	 JRST TPOPJ		;ILLEGAL LOGICAL NAME
	POP P,TAC		;GET SPECIAL-TTY-OK FLAG BACK
	JRST GETDB0

↑GETDBA:MOVEI TAC,0		;SPECIAL (EG TIP) LINE CAN'T GET DDB THIS WAY
GETDB0:	CAIL LINE,TTPLEN	;LEGAL LINE NUMBER?
	POPJ P,			;NO
	SKIPE DDB,TTYTAB(LINE)	;DOES THIS LINE ALREADY HAVE A DDB?
	JRST CPOPJ1		;YES
repeat 0,<
IFE FTF2,<
	JUMPN TAC,GETDB2	;JUMP IF SPECIAL LINES OK
	CAIE LINE,TERLIN
	CAIN LINE,CANLIN	;IS THIS THE Canon PORT?
	POPJ P,			;YES, FLUSH
GETDB2:
>;IFE FTF2
>;repeat 0
	MOVE TAC,LINTAB(LINE)	;NO, WHAT KIND OF TTY?
	TLNE TAC,DDDLIN
	POPJ P,			;DON'T CREATE DISOWNED DDS
	CAIGE LINE,PTYL0	;IF THIS IS A PTY DON'T CALL DDBSRC
	PUSHJ P,DDBSRC		;MAKE A DDB FOR THIS TTY.
	 POPJ P,		;NONE AVAILABLE
	MOVE TAC,DEVNAM(DDB)	;RETURNS THE DEVICE NAME
	HLLZM IOS,DEVIOS(DDB)	;DDBSRC SETS IOS.  THIS CLEARS IOACT.
	JRST CPOPJ1

↑LOG2LN:MOVS TAC,TAC
	MOVEI LINE,TCONLN
	CAIN TAC,'CTY'
	JRST CPOPJ1
	TRC TAC,'TTY'
	TRNE TAC,-1
	POPJ P,			;NOT TTY#
↑SIX2LN:JUMPE TAC,CPOPJ		;JUST TTY
	MOVEI LINE,
LOG2LL:	ROT TAC,3
	TRZE TAC,2
	TRNE TAC,5
	POPJ P,			;NOT DIGIT
	ROTC TAC,3		;DIGIT → LINE
	JUMPN TAC,LOG2LL	;MORE?
	CAIGE LINE,TTPLEN	;NO, CHECK LEGALITY
	AOS (P)
	POPJ P,

SCREW:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /GETDDB FAILED TO MAKE A NEW TTY DDB.
/]
	POPACS
	CONSZ PI,77400		;WHERE ARE WE
	POPJ P,			;CROSS FINGERS AND PRAY
	JSP DAT,UERROR		;UUO LEVEL, A WAY OUT.
;STDTBL DDBSRC DDBSR1 DDBSR2 DDBSR4 DDBSR3 SCNIN SCNIN0 SCNINX

;DEFAULT SPECIAL ACTIVATION MODE BREAK TABLE - BREAK ON ALL BUT LETTER OR NUMBER
STDTBL:	777777777777
	777700037600
	000000374000
	000007600000


;MAKE A NEW TTY DDB FOR A GIVEN LINE

;CALL:	MOVE LINE,<TTY LINE NO.>
;	PUSHJ P,DDBSRC
;	<NO FREE STORAGE, OR ILLEGAL LINE NUMBER, or TTY is down or unassigned>
;	RETURN DDB,LINE AND DEVNAM SET AND BITS TPMON,IOFST,IOACT SET.
;	IF CALLED WITH LINE = -1, A DETACHED DDB IS CREATED AND GIVEN TO JOB IN J.
;	"Unassigned" means low numbered TTY not on DCA (RH LINBIT zero).
;	"Down" means DCADWN is on in DCATAB.

↑DDBSRC:HRRE TAC,LINE		;NUMBER OF LINE ONLY
IFG DILNUM,<
IFN FTVDIL,<
	CAIE TAC,VDILIN		;no one can INIT the Vadic dialer/adapter
>;IFN FTVDIL
>;IFG DILNUM
DDBSRV:	CAIL TAC,TTPLEN		;IS LINE NO. TOO BIG
	POPJ P,			;YES.
	JUMPL TAC,DDBSR0	;JUMP IF DETACHED DDB REQUESTED
	CAIL TAC,SCNNUM
	JRST DDBSR0		;JUMP IF DISPLAY, CTY, OR PTY REQUESTED
	HRRZ DDB,LINBIT(TAC)	;Get DCA port number, if any
	TRZN DDB,400000		;Skip if on DCA
	POPJ P,			;Not on DCA, can't be used (less than SCNNUM)
	MOVE DDB,DCATAB(DDB)	;See if this port is down
	TRNE DDB,DCADWN		;Skip unless this port not available
	POPJ P,			;Error return, TTY is down
DDBSR0:	HLL LINE,LINTAB(LINE)	;(NOTE LINTAB-1 EXISTS AND IS ZERO)
IFE FTF2,<
	TLNE LINE,DDDLIN	;SKIP IF THIS IS NOT A DATA DISK
	SKIPN DDOFF		;IS DD.  SKIP IF DD IS SHUT OFF.
	JRST DDBSR1	
	POPJ P,			;SORRY - NO DATA DISKS TODAY

DDBSR1:
>;IFE FTF2
	MOVEI AC3,TTYFS
	PUSHJ P,SFSGET
	 POPJ P,		;ARGH.
	MOVEI DDB,DDBSKW(AC1)
	HRLI AC1,TTYLST-DDBSKW
	BLT AC1,TTYPTR(DDB)	;COPY PART OF A REAL DDB INTO OUR NEW BLOCK
	SETZM DEVNAM(DDB)
DDBSR2:	SETZM DEVIOS(DDB)	;ENTER HERE TO INITIALIZE SCNDDB
	SETZM TTYBTS(DDB)
	MOVEI AC1,DEVIOS(DDB)
	MOVEM AC1,DEVSPT(DDB)
	SETZM DEVLOG(DDB)
	SETZM DEVBUF(DDB)
	SETZM PTYPTR(DDB)
	SETZM SAVDDB(DDB)
IFN FTMONCIP,<
	SETZM MONCIP(DDB)	;NO MONITOR COMMAND IN PROGRESS
>;IFN FTMONCIP
	MOVSI AC1,TTICHR
	HRRI AC1,TIBF-1(DDB)
	MOVEM AC1,TTIBUF(DDB)
	MOVSI AC1,TTOCHR
	HRRI AC1,TOBF-1(DDB)
	MOVEM AC1,TTOBUF(DDB)
	PUSHJ P,SETBF		;INIT THE INPUT AND OUTPUT BUFFERS
	SETZM IMLHAC(DDB)	;CLEAR THIS EXCEPT FOR TTY WIDTH
	MOVEI TAC,DEFWID	;Set default TTY width
	DPB TAC,PTTYWD		;TTY WIDTH
IFN FTDTTYBUG,<
	MOVE TAC,TIMDAT		;RECORD CREATION TIME IN DDB
	CAIN LINE,-1		;ARE WE CREATING DETACHED DDB?
	TLO TAC,200000		;YES, REMEMBER THAT FOR DEBUGGING
	MOVEM TAC,CRETIM(DDB)
	MOVEM LINE,CRELIN(DDB)	;REMEMBER LINE WE CREATED DDB FOR
	HRLZ TAC,(P)		;ADDRESS OF OUR CALLER
	HRR TAC,-1(P)		;PREVIOUS ADDRESS ON STACK
	MOVEM TAC,CREADR(DDB)	;REMEMBER TWO CALLERS
	HRLZ TAC,-2(P)		;NEXT STACK ADDR
	HRR TAC,-3(P)		;AND NEXT
	MOVEM TAC,CREAD2(DDB)	;REMEMBER TWO MORE CALLERS
>;IFN FTDTTYBUG
	MOVSI TAC,STDTBL
	HRRI TAC,ACTBTS(DDB)
	BLT TAC,ACTMOD(DDB)
	MOVE TAC,[TTYATC,,ASSCON!ASSPRG]
	ANDCAM TAC,DEVMOD(DDB)
	SETZM DEVIAD(DDB)	;CLEARS PHPOS
	SETZM DEVOAD(DDB)	;CLEARS PFITCH
	MOVE IOS,[TPMON+IOFST,,IOACT]
	MOVEM IOS,DEVIOS(DDB)	;MAKE SURE IT LOOKS VIRGIN.
	CAIN DDB,SCNDDB		;SPECIAL FOR CTYDDB=SCNDDB=TTYLST
	JRST CPOPJ1		;ALL DONE FOR CTYDDB
	MOVEI TAC,0		;INITIALIZE DATA BLOCK.
	DPB TAC,PJOBN		;CLEAR JOB NUMBER
	DPB TAC,PUNIT		;UNIT NUMBER TOO
	MOVSI AC1,(DDB)
	HRR AC1,DEVSER(DDB)
	OFFSCN			;TURN OFF SCANNER CHANNEL
	EXCH AC1,TTYLST+DEVSER
	MOVEM AC1,DEVSER(DDB)
	ONSCN			;TURN ON SCANNER CHANNEL
	CAIE LINE,-1		;IS SOME ONE GETTING A DETACHED DDB?
	JRST DDBSR3
	TLO TAC,TTYATC		;YES.  ATTACH JOB TO DDB
	IORM TAC,DEVMOD(DDB)
	SETOM JBTLIN(J)		;YES, FLAG AS DETACHED
	DPB J,PJOBN		;MAKE IT HIS;
	MOVSI IOS,TTYDTC	;FLAG AS DETACHED FROM LINE
	IORB IOS,DEVIOS(DDB)
	JRST CPOPJ1		;SKIP RETURN

DDBSR4:	MOVSI IOS,TTYDTC	;MAKE TTYKIL NOT WAIT FOR DPY HDR TO BE KILLED
	IORB IOS,DEVIOS(DDB)
	OFFSCN			;TURN OFF SCANNER CHANNEL
IFN FTLCLDM,<
	MOVSI AC1,DMLIN
	SKIPN LETAB(LINE)	;Skip if CH5 snuck in and made a dpy hdr
	ANDCAM AC1,LINTAB(LINE)	;Don't leave DM bit on for available TTY
>;IFN FTLCLDM
	JRST TTYKL5

DDBSR3:	TLNE LINE,DDDLIN!DISLIN!DMLIN ;NOT DETACHED.  IS THIS A DPY?
	JRST DDBSDP		;Yes, make a dpy hdr
IFN FTLCLDM,<
	MOVSI AC1,DMLIN		;Copy this bit from LINBIT to LINTAB
	TDNN AC1,LINBIT(LINE)	;Is this a permanent DM-type display?
>;IFN FTLCLDM
	JRST SCNIN		;NO, FINISH UP AND LEAVE
IFN FTLCLDM,<
	IORM AC1,LINTAB(LINE)	;Yes, make this an active DM
	TLO LINE,DMLIN		;Make us a DM, with same parameters as before
>;IFN FTLCLDM
DDBSDP:	PUSHJ P,DPYMAKE		;MAKE UP A DPY HEADER
	 JRST DDBSR4		;LOSE - RELEASE THE DDB & LEAVE
SCNIN:	DPB LINE,PUNIT		;SET LINE NUMBER (UNIT NO.) IN DDB.
	DPB LINE,PTALK		;TALK RING TO CONTAINS ONLY THIS TTY
	ANDI LINE,-1
IFE FTF2,<
PRINTX Imlacs get CVTBIT turned on in DDBSRC for free.
	MOVEI TAC,CVTBIT	;*** TTY CONVERT BIT
	CAIE LINE,JMCIML	;***
	CAIN LINE,RWWIML	;*** THIS IS A KLUDGE, LET'S DO IT RIGHT
	IORM TAC,IMLHAC(DDB)	;***
>;IFE FTF2
	MOVEI TAC,0
SCNIN0:	ROTC TAC,-3		;LOW 3-BITS OF LINE INTO 3 HIGH BITS OF TAC
	HRRI TAC,2		;CONVERT TO SIXBIT
	ROT TAC,-3		;BY SHIFTING +20 INTO TAC
	JUMPN LINE,SCNIN0	;LOOP WHILE THERE'S ANYTHING LEFT.
	HRRI TAC,'TTY'
	MOVS TAC,TAC
	PUSH P,TAC
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,STLNAC
	HRRZ TAC,TTYTAB(LINE)	;DID SOMEONE SNEAK ANOTHER DDB IN HERE?
	JUMPN TAC,SCNINX	;JUMP IF THERE'S ANOTHER DDB THERE ALREADY.
	POP P,DEVNAM(DDB)	;SET DEVICE NAME IN DDB
	HRRM DDB,TTYTAB(LINE)	;AND SET DDB ADDRESS IN TTYTAB
	SKIPN RSPLOK		;MAYBE DON'T WANT TO SET RESONSIBLE TTY
	DPB LINE,[DDQREQ+LINE,,LSTESC] ;INITIALIZE TTY RESPONSIBILITY FIELD
	SKIPN RSPLOK		;MAYBE DON'T WANT TO SET RESONSIBLE TTY
	DPB LINE,[DDQLNK+LINE,,LSTESC] ;AND PREVIOUS RESPONSIBILE TTY
	MOVSI TAC,'CTY'
	TLNE LINE,CTYLIN	;IS THIS CONSOLE TTY?
	MOVEM TAC,DEVNAM(DDB)	;YES, CHANGE NAME TO CTY.
	ONSCN			;TURN ON SCANNER CHANNEL
	JRST CPOPJ1		;SUCCESSFUL RETURN.

;THIS FAILURE HAPPENS AT A LOWER PRIORITY THAN THE SCANNER.
SCNINX:	ADJSP P,-1		;ADJUST STACK  (TTYKL5 WANTS SCNOFF)
	MOVSI IOS,TTYDTC	;MAKE TTYKL5 NOT clear LINTAB and TTYTAB
	IORB IOS,DEVIOS(DDB)
	JRST TTYKL5		;RETURN THIS DDB TO FREE STORAGE. FAILURE.
;TTYSKL TTYREL TTYRL1 TTYKDT TTYDIE TTYKIL TTYKC2 TTYKL0 TTYKND NOTYPA TTYKL5 CLTDDB TTYKC0 TTYKCL

;CALL TO MAKE REQUEST TO DPYKIL.
;CONO PI,SCNOFF MUST HAVE BEEN DONE BEFORE THIS ROUTINE IS CALLED.
TTYSKL:	PUSHJ P,STLNAC		;GET LINE CHARACTERISTICS.
	TLNE LINE,DDDLIN!DISLIN!DMLIN
	SKIPN AC1,LETAB(LINE)
	POPJ P,			;NOT A DISPLAY, OR NO DPY HEADER
	MOVEI TAC,(LINE)
	PUSHJ P,DPYK9		;PLANT CLOCK REQUEST TO CALL DPYKIL
	JUMPL AC2,CPOPJ		;JUMP IF REQ WAS ALREADY PLANTED
	SETZM LEACT(AC1)	;CLEAR ACTIVE FLAG (WE JUST PLANTED REQ)
	POPJ P,

↑TTYREL:
IFN DILNUM,<
	LDB LINE,PUNIT		;SETUP LINE
	PUSHJ P,DILTRL		;CHECK FOR DIALER RELEASE
>;DILNUM
	PUSHJ P,STLNAC
	HRRZ TAC,LINBIT(LINE)	;GET DCA PORT NUMBER
	JUMPE TAC,TTYRL1	;no DCA bit to clear if not a DCA port
	MOVSI UUO,DCADIL	;GET DIALING BIT
	ANDCAM UUO,DCATAB-400000(TAC)	;TURN IT OFF
	SETZM DCAINN-400000(TAC) ;clear int count, avoid shutdown after release
TTYRL1:	MOVEI UUO,0		;FAKE NEW IOS BITS FOR NOT IMAGE MODE
	PUSHJ P,TTYICK		;MAYBE WAIT FOR O/P BUFFER TO EMPTY
	HLLZS DEVIOS(DDB)	;CLEAR INITTED BITS IN IOS.
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,TTYATC		;THAT'S ALL IF IT'S HIS CONSOLE
	POPJ P,
	MOVSI IOS,TPMON		;NO, PUT HIM BACK IN MONITOR MODE
	IORB IOS,DEVIOS(DDB)
IFN FTMONCIP,<
	PUSHJ P,MCMSKP		;SKIP REST OF ANY MONITOR CMD LEFT IN BUFFER
>;IFN FTMONCIP
	TRNE TAC,ASSCON		;DON'T KILL IF ASSIGNED BY CONSOLE
	POPJ P,
printx TTY killed too soon here if open on more than one channel!
	JRST TTYKIL		;Kill the DDB

;ROUTINE TO SET SCNSER TO RETURN TTY TO VIRGIN STATE
;CALL:	MOVE DDB, ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,TTYKIL

;CALLED FROM COMCSS (JOBKIL).
;IF NOT OPERATOR CONSOLE, THEN
; 1)CLEAR PHYSICAL AND LOGICAL NAMES,
; 2)CLEAR JOB NUMBER ASSIGNMENT
;	3)CLEAR TYUSE,TTYATC,ASSCON,ASSPRG,
;	4)CLEAR ENTRY IN TRANSLATOR TABLE.

TTYKDT:	MOVSI IOS,TTYDTC	;Enter here to flush this now unused tty ddb
	IORB IOS,DEVIOS(DDB)	;Mark as detached, for quick kill
↑TTYDIE:HRROS (P)		;Set flag saying don't wait to kill tty ddb
	JRST .+2
↑TTYKIL:HRRZS (P)		;Wait 15 secs before killing, unless detached
	LDB TAC,PJOBN
	MOVE AC1,DEVMOD(DDB)
	TRNE AC1,ASSCON		;ASSIGNED BY CONSOLE
	JUMPE TAC,CPOPJ		; BY JOB 0 MEANS DETACHED FROM SYS, KEEP DDB
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE IOS,DEVIOS(DDB)	;GET LATEST VERSION OF KILREQ BIT
	TLNE IOS,TTYDTC
	JRST TTYKL5		;TAKE 3 GIANT STEPS IF YOU'RE DETACHED.
	LDB LINE,PUNIT		;GET LINE NUMBER
	CAIGE LINE,PTYL0	;Skip if PTY
	SKIPE LETAB(LINE)	;Skip if non-display
	JRST TTYKL0		;Let dpy or PTY thru TTYKIL a little further
	SKIPGE (P)		;Want a quick kill for this TTY DDB? (TTYDIE?)
	JRST TTYKL0		;Yes, let it go right through TTYKIL now
	SKIPN DDB,TTYTAB(LINE)	;DID SOMEONE ELSE KILL IT?
	JRST SCNONJ		;YES.
	TRNN DDB,-1		;IS THERE REALLY ONE HERE?
	JRST TTYKND		;NO!
	PUSHJ P,CLTDDB		;Clear out job number and TTY IOS, etc.
	TLNE IOS,KILREQ		;Skip unless clk req already in
	JRST SCNONJ		;Let clk req already planted do the work
TTYKC2:	MOVSI TAC,KILTTY
	IORM TAC,TTYTAB(LINE)	;Tell TTYKCL that the DDB can be flushed
	JRST TTYKLN		;Plant clk req for 15 secs later to kill DDB

;Clk requests to kill non-dpy TTY DDB jump back in here
TTYKL0:	PUSHJ P,TTYSKL		;PLANT CLK REQ FOR DPYKIL (SETS LINE)
	SKIPN DDB,TTYTAB(LINE)	;DID SOMEONE ELSE KILL IT?
	JRST SCNONJ		;YES.
	TRNN DDB,-1		;IS THERE REALLY ONE HERE?
	JRST TTYKND		;NO!
	PUSHJ P,CLTDDB		;CLEAR OUT STUFF FROM TTY DDB
	LDB TAC,FC2BPT		;SEE IF FORCED COMMAND IS WAITING
	JUMPN TAC,SCNONJ	;IF SO, LEAVE NOW
	SKIPG TTYTAB(LINE)	;COMMAND IN ALREADY?
	JRST SCNONJ		;YES, LEAVE NOW!
	MOVE TAC,TITCTR(DDB)	;TAKR COUNT
	CAME TAC,TIPCTR(DDB)	;COMPARE WITH PUTR
	SKIPG TISYNC(DDB)	;ANY LINES TO TELL MONITOR ABOUT?
	JRST NOTYPA		;NO LINES TYPED AHEAD
	PUSHJ P,COMSET		;WAKE COMMAND DECODER
	JRST SCNONJ

;HERE WHEN TTYTAB IS NON-ZERO, BUT RH IS ZERO (NO DDB ADDRESS)
TTYKND:
IFN FTCMDBUG,<
	PUSHJ P,BUGTRP		;THIS ISN'T REALLY SUPPOSED TO HAPPEN!
>;FTCMDBUG
	PUSHJ P,TTYKL9		;NO DDB, NO NOTHING!
	JRST SCNONJ		;AND THEY'RE OFF

NOTYPA:	TLNN LINE,PTYUSE	;DON'T KILL DDB FOR USED PTY'S.
	TLOE IOS,IO+TOIP	;IS IT OUTPUTTING?
	JRST TTYKL6		;YES, DON'T KILL NOW, TRY AGAIN WHEN OUTPUT DONE
	MOVSI AC1,KILTTY
	IORM AC1,TTYTAB(LINE)	;Tell DPYKIL and TTYKCL that the DDB can be flushed
	SKIPE LETAB(LINE)
	JRST SCNONJ		;Let DPYKIL do the dirty work
↑TTYKL5:MOVEI TAC,TTYLST	;DON'T KILL THE CTY DDB (DPYKIL ENTERS HERE)
	CAIE TAC,(DDB)		;IS THIS THE FIRST DDB?
	JRST TTYKL2		;NO, BLAST THE MOTHER
	HLLZS DEVIOS(DDB)	;CLEAR INITTED STUFF IN IOS
	PUSHJ P,LINCLR		;CLEAR LINE TABLE.
	SETZM DEVLOG(DDB)	;CLEAR LOGICAL NAME
	JRST SCNONJ		;ON CLYDE.

CLTDDB:	MOVSI IOS,TTYIOW!IOW!TTYDTC!DDTM ;CLEAR TTY INPUT AND OUTPUT
	ANDCAM IOS,DEVIOS(DDB)	;WAIT BITS SO TTY WILL BE KILLED
				;PROPERLY AT INTER. LEVEL IF STILL OUTPUTING
	MOVEI TAC,GAGBIT!GAGTBT	;UNGAG IT
	ANDCAM TAC,IMLHAC(DDB)
	MOVE TAC,[TTYATC,,ASSCON!ASSPRG]
	ANDCAM TAC,DEVMOD(DDB)	;TTY IS NO LONGER A JOB'S CONSOLE.
	MOVSI IOS,TPMON		;CLEAR JOB NUMBER
	DPB IOS,PJOBN
	IORB IOS,DEVIOS(DDB)	;TURN TPMON ON IN CASE TTY IS STILL OUTPUTTING
IFN FTMONCIP,<
	PUSHJ P,MCMSKP		;SKIP REST OF ANY MONITOR CMD LEFT IN BUFFER
>;IFN FTMONCIP
	POPJ P,

;;;WE NEED TO MAKE SURE ONLY ONE CLK REQ FOR THIS ROUTINE IS PLANTED PER DDB.
;Here at clk level to kill DDB if still appropriate
;Enter here after 15 sec delay.
↑TTYKC0:HRRZ DAT,TTYTAB(TAC)	;Get DDB
	JUMPE DAT,CPOPJ		;You tell Me what happened to the DDB!
;Enter here after 1 tick delay, for detached DDBs only, I think.
↑TTYKCL:HRRZ DDB,DAT		;SET UP DDB ADDRESS
	MOVSI IOS,KILREQ
	OFFSCN			;TURN OFF SCANNER CHANNEL
	ANDCAB IOS,DEVIOS(DDB)	;NO MORE CLK REQ WAITING TO KILL DDB
	LDB TAC,PJOBN
	MOVE AC1,DEVMOD(DDB)
	TRNE AC1,ASSCON		;ASSIGNED BY CONSOLE
	JUMPE TAC,SCNONJ	; BY JOB 0 MEANS DETACHED FROM SYS, KEEP DDB
	TLNE IOS,TTYDTC		;NO LINE NUMBER IF DETACHED DDB
	JRST TTYKL5
	JUMPN TAC,SCNONJ	;KEEP THE DDB IF IN USE BY JOB
	PUSHJ P,STLNAC		;SET UP LINE NUMBER AND BITS
	SKIPE LETAB(LINE)	;If terminal became a display, let DPYKILL run
	JRST TTYKL0
	MOVE AC1,TTYTAB(LINE)
	TLNN AC1,KILTTY		;ANYTHING TYPED IN LATELY?
	JRST TTYKC2		;Yes, wait another 15 secs
	MOVE AC1,TIPCTR(DDB)	;No, see if input buffer is empty
	CAMN AC1,TITCTR(DDB)	;Skip if non-empty input buffer
	JRST TTYKL0		;OK, folks, we waited long enough -- kill DDB
	PUSHJ P,SETBFI		;Clear the input buffer
	MOVEI CHR,"U"-100	;Type out a ↑U
	PUSHJ P,DUPKIL
	PUSHJ P,TYCRLF		;Output a CRLF, storing new horiz pos
	PUSHJ P,TTYKC2		;Plant clk req to come back again in 15 secs
	JRST TYPT2		;Start output for the ↑U CRLF
;⊗ TTYKL2 TTYK6A TTYKL6 TTYKLN TTYK2A TTYK22 TTYKL3 TTYKL8 LINCLR LINCL2 TTYKL1 TTYKL4 DDB TTYKL9 TTYK91 TTYK92 CLRRSP CLRRS2 CLRRS3

;THIS RETURNS A DDB TO FREE STORAGE.

TTYKL2:	TLNE IOS,KILREQ		;Is there already a clock request in to kill us?
	JRST SCNONJ		;Yes, don't kill DDB before clk req comes up
	CONSO PI,77000		;Skip if in CH 1-6
	JRST TTYK2A		;OK to kill DDB in CH7 or UUO level
	TLNN IOS,TTYDTC		;If detached, need DDB address for clk req
	JRST TTYKLN		;Otherwise, kill by line number in a while
	MOVE AC1,DDB
	HRLI AC1,TTYKCL
	PUSHJ P,AC1CLK		;Plant clk req to kill TTY DDB
TTYK6A:	MOVSI IOS,KILREQ	;This bit flags clock request in to kill DDB
TTYKL6:	TLZ IOS,TOIP		;Don't hang output by accidentally setting this bit
	IORB IOS,DEVIOS(DDB)	;Make sure new bits get turned on (IO or KILREQ)
	JRST SCNONJ

TTYKLN:	LDB AC1,PUNIT		;Get line number in case we don't have it
	LSH AC1,=12		;Position into data field for clk req
	TLO AC1,$TTYKC0		;Go to TTYKC0 in a few secs
	IORI AC1,=15*=60	;Wait 15 seconds before killing DDB
	CLKENQ(AC1)		;Plant clk req
	JRST TTYK6A		;Set flag saying clk req is in

; Here is an attempt to make device waits win.
TTYK2A:	PUSHACS			;Necessary?
	MOVEI DAT,DVWSCAN	;Do it the official wrong way
	JSP UUO,QSCAN
	 JRST TTYK22		;Not found.  Go flush the DDB
	MOVE TAC,DEVNAM(DDB)
	CAME TAC,JBTDVW(J)
	JRST (AC1)		;No match, try next
	MOVEI AC1,RUNQ 		;Wake up this waiter
	MOVNM AC1,JOBQUE(J)
	PUSHJ P,REQUE
TTYK22:	POPACS
; End of this device wait kludge
	MOVEI AC1,TTYLST	;SEARCH CHAIN FOR POINTER TO DDB.
TTYKL3:	MOVE TAC,AC1
	HLRZ AC1,DEVSER(AC1)	;LINK
	CAIE AC1,(DDB)		;IS THIS THE GUY THAT POINTS TO OURS
	JUMPN AC1,TTYKL3
	JUMPE AC1,TTYKL4
	MOVE AC1,DEVSER(DDB)
	MOVEM AC1,DEVSER(TAC)	;LINK HIM OUT
TTYKL8:	PUSHJ P,LINCLR		;CLEAR LINTAB BITS
	TLNN IOS,TTYDTC
	PUSHJ P,TTYKL9
	ONSCN			;TURN ON SCANNER CHANNEL
	MOVEI AC1,-DDBSKW(DDB)
	PUSHJ P,SFSGIV		;BACK TO TTY SPARE LIST (FOR FSCCNT)
	 TTYFS			;ARG TO ROUTINE
	MOVEI DDB,0
	POPJ P,

LINCLR:	TLNE IOS,TTYDTC		;NO LINE IF DETACHED
	POPJ P,
;Here from ITYREL in IMPSER to finally clear PTYLIN.
↑LINCL2:TLZ LINE,KILMSK		;CLEAR BITS IN LINE TABLE
	PUSH P,TAC
	HRRZ TAC,LINE		;SAVE LINE NUMBER (SINCE IOR BELOW CLOBRS 400000)
	IOR LINE,LINBIT(LINE)	;OR IN INITIALIZE BITS
	TLZ LINE,DMLIN		;KEEP THIS BIT OFF IN LINTAB WHEN NO DDB/DPY HDR
	HRR LINE,TAC		;PUT LINE NUMBER BACK
	HLLM LINE,LINTAB(LINE)	;store cleaned up bits (PTYLIN is off)
	MOVE TAC,LINBIT(LINE)
	TLNE TAC,DMLIN		;skip unless this is a permanent DM
	JRST TPOPJ		;don't clear LEFTARROW on permanent DM
	MOVSI TAC,LEFTAR
	ANDCAM TAC,DPYDES(LINE)	;normalize leftarrow flag
	JRST TPOPJ

;HERE FROM TTYDET WHEN DETACHING A DDB FROM LINE
TTYKL1:	LDB LINE,PUNIT		;LINE NO.
	SKIPGE TTYTAB(LINE)
	SOS COMCNT
	PUSHJ P,TTYKL9		;CLEAR TRANSLATOR TABLE
	SETZM DEVNAM(DDB)
	MOVE TAC,LETAB(LINE)	;IF LINE EDITOR IS WAITING, MUST FLUSH IT
	TLNE TAC,WTFLAG		;SKIP UNLESS LE WAITING FOR ROOM IN INPUT BUFFER
	HRRZS LETAB(LINE)	;CLEAR LE FLAGS, ESPECIALLY WTFLAG
	JRST SETBF		;CLEAR INPUT & OUTPUT BUFFERS, NOT LINE EDITOR

TTYKL4:	PUSHACS
	PUSH P,TAC
	PUSH P,DDB
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /πππDDB NOT FOUND IN LIST AT TTYKIL
DDB=/
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /
LAST LINK=/
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /
/
	POPACS
	JRST TTYKL8		;GIVE IT BACK ANYWAY

;ALL THE "PUSHJ P,TTYKL9"S ABOVE USED TO BE "SETZM TTYTAB(LINE)"
;IF LH OF TTYTAB ENTRY ≠ LINE THEN WE WERE IN A TALK RING AND
;THIS ROUTINE PATCHES THE RING UP TO LEAVE US OUT

TTYKL9:	MOVSI AC2,BEPHNG	;Clock routine to beep and hang up TTY if phone
	HRRI AC2,(LINE)		;TTY line number is arg
	PUSHJ P,AC2CLK		;Plant clock req from AC2
	LDB AC2,PTALK		;MY TALK-RING POINTER
	MOVEI AC3,0
	EXCH AC3,TTYTAB(LINE)	;DON'T NEED TTYTAB ANYMORE
	JUMPE AC3,CPOPJ		;GRUMBLE, SOMEBODY CLOBBERED IT ALREADY
	PUSHJ P,CLRRS2		;CLEAR RESPONSIBLE TTY AND HIDDEN BIT
	CAIN AC2,(LINE)		;POINTS TO ME?
	POPJ P,			;YES, NO PROBLEM
	PUSH P,AC2		;SAVE NEXT GUY
	MOVE AC3,LINE		;MY LINE NUMBER
TTYK91:	MOVE LINE,AC2		;LOOP THROUGH TILL YOU FIND ME
	LDB AC2,PTALK
	CAIE AC2,(AC3)
	JRST TTYK91		;NOT ME YET
	POP P,AC2		;RETRIEVE MY POINTEE
	DPB AC2,PTALK		;MAKE PREV POINT TO NEXT
	CAIE AC2,(LINE)
	JRST TTYK92
	MOVSI AC2,TLKRNG
	ANDCAM AC2,LINTAB(LINE)	;TURN OFF THE FLAG IF ONLY ONE LEFT
TTYK92:	MOVSI AC2,CLKBYE	;ADDR OF CLOCK LVL ROUTINE TO SAY BYE
	DPB AC3,[POINT PUNITS,AC2,35] ;SAVE TTY WHICH CALLED OUT
	DPB LINE,[POINT PUNITS,AC2,35-PUNITS] ;SAVE ANOTHER TTY IN THE LOOP
	SYSPIFF
	IDPB AC2,CLKQ		;USE DPYSER'S CLOCK QUEUE
	SYSPIN
	MOVE LINE,AC3		;FIX LINE
	POPJ P,

;HERE FROM FORK OR DETACH THAT COULDN'T GET A NEW DDB. MUST CLEAR RESP TTY.
↑CLRRSP:SETZM RSPLOK		;HERE FROM CLKSER -- FORCE CLEARING RESP TTY
	AOS NCLRSP		;COUNT NUMBER OF TIMES WE HAD TO DO THIS
;Enter here when TTY goes available and TTYTAB entry is being zeroed.
CLRRS2:	SKIPE AC3,RSPLOK	;CAN WE CLEAR RESPONSIBLE TTY?
	POPJ P,			;NO
	PUSH P,AC1
	PUSH P,AC2
	MOVE AC1,LINTAB(LINE)	;Get bits to see if this is DD going available
	LDB AC2,[DDQREQ+LINE,,LSTESC] ;Save final responsible TTY, arg for FINDDD
	DPB AC3,[DDQREQ+LINE,,LSTESC] ;CLEAR TTY RESPONSIBILITY FIELD
	DPB AC3,[DDQLNK+LINE,,LSTESC] ;AND PREV RESPONSIBLE TTY
	DPB AC3,[PHIDDN+LINE,,LSTESC] ;AND HIDDEN BIT
IFE FTF2,<
	TLNN AC1,DDDLIN		;If not DD, then flush any macros storage
	JRST CLRRS3
	PUSH P,AC2		;Save physical line
	PUSHJ P,FINDDD		;Find a DD we're responsible for, or a free one
	POP P,AC2
	SKIPN LETAB(AC1)	;Skip if found us a responsive DD
>;IFE FTF2
CLRRS3:	PUSHJ P,CLCRMC		;Release ESC # CR macro free storage for line in AC2
	POP P,AC2
	POP P,AC1
	POPJ P,
;OUTCH6 OUTCHS OUTC1S OUTCHR OUTCH5 TLKOUT OUTC5A OUTCA2 OUTCA1 OUTCA3 OUTCHA OUTC1X OUTCH2
;MORE CHARACTER AND BUFFER HANDLING ROUTINES

;OUTCHR CALLED AT UUO LEVEL TO OUTPUT A CHARACTER
;DAT AND DDB MUST BE SET UP
;CHECK IS MADE FOR WHETHER SPECIAL ECHO IS REQUIRED
;RIGHT THINGS ARE DONE WITH PHPOS & HPOS(NEEDNT BE SET)
;CALL:	MOVE CHR,CHAR TO BE OUTPUT
;	PUSHJ P,OUTCHR
;	ONLY RETURN, WITH CHAR. OR ITS SPECIAL ECHO PLACED IN OUT BUFFER

LOSYS

↑OUTCH6:ADDI CHR,40		;TYPE OUT SIXBIT.

↑OUTCHS:PUSH P,TAC
	PUSH P,HPOS		;CALL OUTCHR ROUTINE (SAVE J≡HPOS AND TAC)
	PUSH	P,DDB
	HRRZ	DDB,DDB
	CAIN	DDB,SCNDDB	;special for CTY
	JRST	[PUSHJ P,DISTYO	;note also change to DISOUT to call OUTCH5...
		JRST OUTCH0]
	PUSHJ	P,OUTCH5
OUTCH0:	POP	P,DDB
	POP P,HPOS
	JRST TPOPJ

↑OUTCHR:MOVE TAC,DEVIOS(DDB)	;GET IOS
	TLNE TAC,TTYDTC
	POPJ P,
	JUMPE CHR,OUTC5A	;BH 1/5/78 FLUSH NULLS UNLESS 400 BIT SET BY CALLER
	ANDI TAC,16
	CAIN TAC,10		;MODE 10 OR 11?
	JRST OUTCH2		;YES, NO CONVERSION
	MOVEI AC3,20		;CHECK FREE SPACE
	CAML AC3,TOFCTR(DDB)	; FOR EXPANDING CHARS
	JRST GETCH1		;NOT ENOUGH ROOM
↑OUTCH5:MOVE TAC,DEVIOS(DDB)	;(enter from DISOUT)
	TLNE TAC,TTYDTC		;NO OUTPUT IF DETACHED
	POPJ P,
	ANDI TAC,16
	CAIN TAC,10		;MODE 10 OR 11?
	JRST OUTCH2		;YES, NO CONVERSION
TLKOUT:	ANDI CHR,177		;MASK ANY JUNK
	JUMPE CHR,OUTC5A	;BH 1/5/78 FLUSH NULLS UNLESS 400 BIT SET BY CALLER
	PUSH P,LINE
	PUSHJ P,STLNAC		;SET UP LINE
	LDB HPOS,PHPOS		;GET HORIZONTAL POSITION
	JRST OUTCA1

OUTC5A:	AOJA CHR,CPOPJ		;MAKE CHR NONZERO TO NOT FLAG FULL O/P BUFFER

OUTCA2:	PUSH P,CHR		;LINE OVERFLOW AND TTY. SAVE CHR
	MOVEI CHR,15		;INSERT CRLF
	PUSHJ P,OUTCH2		;(REG) DON'T CALL CRLFEC - IT DOESN'T
	MOVEI CHR,12		;  CONO PI,SCNOFF BEFORE CALLING PUTCHO
	PUSHJ P,OUTCH2
	POP P,CHR
	MOVEI HPOS,0		;RESET HORIZONTAL POSITION.  RECOMPUTE HPOS.
OUTCA1:	MOVE AC3,HPOS		;SAVE FOR TAB (OUTCH1)
	PUSHJ P,ADJHP		;NEW HPOS AFTER CHAR OUTPUT.  SET UP TAC.
	 JFCL
	MOVEM TAC,1(P)		;SAVE TAC.  BEWARE!
	LDB TAC,PTTYWD		;GET THE WIDTH
	CAIL TAC,=16
	JRST OUTCA3
	MOVEI TAC,DEFWID	;Default TTY width
	DPB TAC,PTTYWD		;AVOID NASTY LOOPS!
OUTCA3:	TLNN LINE,DMLIN!DISLIN!DDDLIN ;SKIP IF A DISPLAY
	CAIG HPOS,(TAC)		;IS TTY CARRIAGE TOO FAR RIGHT?
	JRST OUTCHA		;NO OVERFLOW ON DISPLAYS
	TLNN LINE,IMPBIT	;ARPA-PTYS AND REAL TTYS GET THIS
	TLNN LINE,PTYLIN
	JRST OUTCA2		;ARPA OR TTY. (OLD TAC IRRELEVANT)
OUTCHA:	MOVE TAC,1(P)		;RESTORE TAC.
	DPB HPOS,PHPOS		;UPDATE IN CORE
	PUSHJ P,DUPNVT		;IF ARPA PTY, CONVERT SAIL TO ASCII
	TLNE TAC,ARRBIT		;BH 4/27/75
	TLNN LINE,ECHARR	;IF THIS IS AN UPARROW CHAR
	JRST .+2		;  AND WE'RE IN THE RIGHT MODE,
	JRST ARROUT		;  GO DO IT
	TLNN TAC,SPOUT		;VT,FF,HT?
	JRST OUTC1X		;NO.
	TLNE LINE,PTYLIN	;IS THIS A PTY?
	TLNE LINE,IMPBIT!DMLIN	;YES. IS IT AN IMP OR A DM?
	JRST OUTCH1		;NOT A PTY, OR AN ARPA-PTY. - EXPAND TABS, ETC.
OUTC1X:	POP P,LINE
OUTCH2:	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,PUTCHO		;PUT OUT THE CHAR.
	JRST SCNONJ
;OUTCH1 OUTC1A OUTC1Y OUTC1Z OUTC1C OUTC1B
;HERE ON UUO OUTPUT OF HT,FF,VT

OUTCH1:	MOVE HPOS,AC3		;POS BEFORE THE TAB
	MOVE TAC,CHR		;COPY THE CHARACTER
	TLNN LINE,DISLIN!DDDLIN!DMLIN ;DON'T EVER EXPAND TABS ON DISPLAYS
	TLNN LINE,TBXPND	;YES. SHOULD WE EXPAND TABS?
	CAIE CHR,11		;NO, EXPAND IF IT ISN'T A TAB
	JRST OUTC1Y		;EXPAND FF,VT, OR HT IF TBXPND IS SET.
	TLNE LINE,PTYLIN!DISLIN!DDDLIN!DMLIN ;NEED IDLE CHARS.?
	JRST OUTC1X		;NO
OUTC1A:	POP P,LINE		;HERE ON OUTPUT OF TAB TO SMART TTY
	ANDI HPOS,7		;JUST LOW PART FOR INDEX
	XCT (HPOS)[	MOVEI HPOS,6	;8 SPACES-2 IDLES
			MOVEI HPOS,6	;7 SPACES-2 IDLES
			MOVEI HPOS,6	;6 SPACES-2 IDLES
			MOVEI HPOS,7	;5 SPACES-1 IDLE
			MOVEI HPOS,7	;4 SPACES-1 IDLE
			MOVEI HPOS,7	;3 SPACES-1 IDLE
			JRST OUTCH2	;2 SPACES-0 IDLES
			JRST OUTC1Z]	;1 SPACE -CONVERT TO SPACE (OR CTY WILL MISS TAB STOP)
	PUSHJ P,OUTCH2		;SEND THE REAL CHAR
	MOVEI CHR,IDLECH	;A DELAY CHARACTER
	JRST OUTC1C		;OUTPUT SLUFFS. COUNT WILL BE MODIFIED ON VT,FF

OUTC1Y:	POP P,LINE		;HERE TO EXPAND CHARACTER.
OUTC1Z:	MOVEI CHR,40		;HERE FOR A STUPID TTY.  CHANGE TAB TO SPACE
	CAIE TAC,11		;H TAB?
	MOVEI CHR,12		;BUT IT WASN'T A TAB.  CHANGE IT TO LF.
OUTC1C:	CAIN TAC,14		;FF?
	MOVEI HPOS,0		;YES. 8 LF'S.
	CAIN TAC,13		;VT?
	MOVEI HPOS,4		;YES. 4 LF'S.
OUTC1B:	PUSHJ P,OUTCH2		;OUTPUT THE PHONY CHAR
	ADDI HPOS,1		;COUNT THE OUTPUTS
	TRNE HPOS,7		;ENOUGH?
	JRST OUTC1B		;NO. MORE.
	POPJ P,			;NO MORE
;ADJHP QUOTHP ADJHP2 ADJHP1 ARROUT

;CALLED AT UUO AND INT LEVEL TO ADJUST HPOS FOR OUTPUT OF CHR
;SKIPS IF SPCHECK SAYS SPECIAL CHAR.

ADJHP:	PUSHJ P,SPCHEK		;GET BITS FROM SPCTAB
	AOJA HPOS,CPOPJ		;ORDINARY CHAR.
QUOTHP:	TLNE TAC,ARRBIT		;BH 4/27/75
	TLNN LINE,ECHARR	;IF THIS IS AN UPARROW CHAR
	JRST ADJHP2		;  AND WE'RE IN THAT MODE,
	AOJA HPOS,ADJHP1	;  IT TAKES 2 SLOTS

ADJHP2:	CAIL CHR,40		;WHICH SPECIALS?
	JRST CPOPJ1		;HIGH ONES
	CAIN CHR,15		;CARRIAGE RETURN?
	MOVEI HPOS,0		;YES.
	CAIE CHR,11		;TAB?
	JRST CPOPJ1		;NO. NO HP MOD
	TRO HPOS,7		;TAB. TO NEXT 8
ADJHP1:	AOJA HPOS,CPOPJ1

ARROUT:	PUSH P,CHR		;OUTPUT UPARROW MUMBLE
	MOVEI CHR,"↑"
	PUSHJ P,OUTCH2
	POP P,CHR
	ADDI CHR,100		;TURN INTO DECENT CHARACTER
	JRST OUTC1X
;PUTCHI PUTCI1 TTIOUT PUTCHO PUTCRX FILNCR PUTNLC PUTCRS PUTCO1

;ROUTINE TO PUT A CHARACTER INTO A BUFFER (FOR INPUT,MERTPO, AND ONCE)
;CALL:	MOVEI DAT,TTXBUF(DDB)		;TO SPECIFY BUFFER
;	PUSHJ P,PUTCHI
;	 ERROR RETURN, BUFFER "FULL"
;	SUCCESSFUL RETURN

PUTCHI:	SOSG FCTR(DAT)		; ANY FREE SPACES LEFT?
	JRST PUTCI0		;NO
	SOSLE PCTR(DAT)		;LAST BYTE IN BUFFER FILLED?
	JRST PUTCI1		;NO. GO AHEAD
	PUSH P,TAC
	MOVE TAC,BUF(DAT)	;GET ADR AND SIZE OF BUFFER
	HLRZM TAC,PCTR(DAT)	;INITIAL COUNTER
	HRRM TAC,PUTR(DAT)	;BYTE POINTER.
	POP P,TAC		;RESTORE TAC
PUTCI1:	IDPB CHR,PUTR(DAT)
	JRST CPOPJ1

;ROUTINE TO STUFF MONITOR ERROR MESSAGE IN TTI BUFFER
;CALLED IN LINE FROM PUTCHO

TTIOUT:	MOVE IOS,DEVIOS(DDB)
	AOS TOFCTR(DDB)		;RE-ADJUST FREE CHAR COUNT
	TRNN IOS,MERTPO		;MONITOR ERROR MESSAGE?
	JRST GETCH1		;NO.  CHR←0 TO INDICATE
	TRON IOS,MERTP1		;TEST FLAG AND SET IF NOT ON
	PUSHJ P,SETBFI		;CLEAR INPUT
IFN FTESCCBUG,< SCPICK >	;CHECK PI STATUS
	MOVEM IOS,DEVIOS(DDB)	;AND MAKE SURE FLAG GETS ON
	MOVEI DAT,TTIBUF(DDB)	;YES, PUT REST IN TTI BUFFER
	PUSHJ P,PUTCHI
	 POPJ P,		;ERROR RETURN
	POPJ P,

;ROUTINE TO PLACE A CHARACTER INTO THE OUTPUT BUFFER
;CALLED AT INTERRUPT LEVEL  (OR WITH THE SCANNER OFF)
;CALL:	MOVE CHR,CHARACTER TO PLACE INTO BUFFER
;	PUSHJ P,PUTCHO
;	ONLY RETURN, WHETHER OR NOT CHARACTER WAS PLACED

PUTCHO:	PUSH P,TAC
	LDB TAC,PIOMOD		;GET IO MODE
	CAIE TAC,10
	CAIN TAC,11
	JRST PUTNLC		;DON'T OR CONVERT IN IMAGE MODE.
	LDB TAC,PUNIT
	HLL TAC,LINTAB(TAC)
	TLC TAC,TTYFIL		;MAKE OFF MEAN FILLING
	CAIN CHR,15		;IS THIS A CR?
	TLNE TAC,TTYFIL!DMLIN!DDDLIN!DISLIN ;YES, ARE WE FILLING ON A NON-DISPLAY?
	JRST FILNCR		;NOT CR OR NOT FILLING OR ON DISPLAY
	MOVEI TAC,10
	EXCH TAC,(P)		;(RESTORE OLD TAC)
PUTCRX:	PUSHJ P,PUTCRS
	SOSLE (P)		;DONE YET?
	JUMPN CHR,PUTCRX	;NO.  JUMP UNLESS BUFFER FULL (CHR=0)
	SUB P,[1,,1]
	POPJ P,

FILNCR:	TLNE TAC,FCS!DMLIN!DDDLIN!DISLIN ;WANT TO CONVERT LOWER TO UPPER CASE?
	JRST PUTNLC		;No.  (FCS on or is a display.)
	CAIL CHR,"a"		;NOT FULL CHAR SET - CONVERT LOWER TO UPPER
	CAILE CHR,"z"
	JRST PUTNLC
	ANDCMI CHR,40		;CONVERT TO UPPER CASE
PUTNLC:	POP P,TAC
↑PUTCRS:SOSG TOFCTR(DDB)	;RETURN IMMEDIATELY IF NO ROOM
	JRST TTIOUT		;UNLESS MONITOR ERROR MESSAGE
	SOSLE TOPCTR(DDB)	;LAST BYTE IN BUFFER?
	JRST PUTCO1		;NO. GO ON.
	PUSH P,TAC		;SAVE AN AC
	MOVE TAC,TTOBUF(DDB)	;GET COUNT AND ADDRESS
	HLRZM TAC,TOPCTR(DDB)	;INITIAL COUNTER
	HRRM TAC,TOPUTR(DDB)	;INITIAL POINTER
	POP P,TAC		;RESTORE AC
PUTCO1:	IDPB CHR,TOPUTR(DDB)	;PUT CHARACTER INTO BUFFER
	POPJ P,
;GETCHR GETCHY
;CHARACTER AND BUFFER HANDLING ROUTINES

;ROUTINE TO PICK UP A CHARACTER FROM ANY BUFFER
;[No, it must be from the input buffer -- see bugtrap at GETCHY below.]
;[In fact, I think we only get to GETCHR for monitor command reading.]
;[It is also called from LOOKUP NEEDED, PLEASE TYPE FILE NAME.  (TVR-Jan81)]
;CALL:	MOVEI DAT,TTXBUF(DDB)	;TO SPECIFY BUFFER
;	PUSHJ P,GETCHR
;	ONLY RETURN		;CHARACTER OR ZERO IN CHR
;				;ZERO INDICATES BUFFER "EMPTY"(TAKR=PUTR)

↑GETCHR:PUSHJ P,GETCHY
	ANDI CHR,177		;THROW OUT CONTROL BITS.
	PUSH P,LINE
	PUSH P,TAC
	PUSH P,AC1		;Preserve the ACs, maybe not necessary, but....
	PUSH P,DDB
	PUSH P,J
	MOVEI DDB,-TTIBUF(DAT)	;Why aren't the right ACs setup when you need them?
	PUSHJ P,PTICHK		;Wake up any PTY waiters
	POP P,J
	POP P,DDB
	POP P,AC1
	POP P,TAC
	POP P,LINE
	POPJ P,

GETCHY:	HLRZ CHR,BUF(DAT)	;CHARS IN BUFFER (THIS IS A BUG TRAP!!)
	CAIN CHR,TTICHR		;TTICHR FOR INPUT.
	JRST GETCHA
	PUSHACS
	PUSH P,LINE
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /TTY/
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / AT GETCHY FOR OUTPUT
/
	DEBCHECK(POPACS)	;CALL DDT IF DEBUGGING
	JRST GETCHO
;GETCHA GETCHB GETCO1 GETCO2 GETCO3 GETCHO GETCH2 GETCH1 PUTCI0

;ROUTINE TO GET valid CHARACTER from input buffer
GETCHA:	PUSHJ P,GETCHB		;get a char
	 JRST GETCHA		;user not allowed to have this 400, try again
	POPJ P,

;Get character out of input buffer, skip unless an invalid 400.
GETCHB:	PUSHJ P,GETCO1		;GET A CHAR FROM INPUT BUFFER
	 POPJ P,		;CAN'T RETURN THIS 400, error return
	AOS (P)			;valid char, take skip return
	PUSH P,TAC
	LDB TAC,[POINT PUNITS,-TTIBUF+DEVUNI(DAT),35-PUNITP] ;GET LINE NUMBER
	MOVE TAC,LETAB(TAC)	;GET LINE EDITOR FLAGS FOR THIS TTY
IFN FTMONCIP,<
	SKIPE TSYNC(DAT)	;If nothing left activated, bring chars from LE
	SKIPN MONCIP-TTIBUF(DAT) ;If monitor command still going, don't wake LE
>;IFN FTMONCIP
	TLNN TAC,WTFLAG		;IF LINED IS NOT WAITING,
	JRST TPOPJ		; THEN JUST LEAVE WITH THE GOODS
	PUSHACS
	LDB DAT,[POINT PUNITS,-TTIBUF+DEVUNI(DAT),35-PUNITP] ;LINE NUMBER
	OFFSCN			;Scanner must be off when we get to RECIN3/4
	PUSHJ P,ACTIV3		;CALL LINED TO XFER CHARS TO INPUT BUF
	ONSCN
	POPACS
	JRST TPOPJ

GETCO1:	SOSGE TSYNC(DAT)	;ALWAYS COME HERE FOR INPUT.
	SETZM TSYNC(DAT)	;DON'T LET IT GET NEGATIVE
	LDB CHR,PLSTLC		;BH 7/7/75 FIXING BUG WHEREBY INCHRS OF RUBOUT
	CAMN CHR,TCTR(DAT)	;WHERE CHARS HAVE BEEN TYPED AND EATEN SINCE
	CAMN CHR,PCTR(DAT)	;   (DON'T DO IT IF NOT GOBBLING ANYTHING NOW)
	JRST GETCO2		;LAST ACTIVATOR TRIES TO DELETE ALREADY EATEN
	SOSG CHR		;CHAR BECAUSE PLSTLC IS ONLY UPDATED AT ACTIVATOR
	HLRZ CHR,BUF(DAT)
	DPB CHR,PLSTLC
GETCO2:	PUSHJ P,GETCHO
	JUMPE CHR,CPOPJ1	;BH 1/12/78 DON'T TURN ON 1000 BIT IF BUF EMPTY
	PUSH P,TAC		;BH 1/8/78 TEST FOR IMAGE MODE
	MOVE TAC,DEVIOS-TTIBUF(DAT)	;BH (WHAT A CROCK!)
	TRNE TAC,10		;BH MODE 10 OR 11?
	TDNE TAC,[TPMON,,6]	;BH  AND ALSO NOT MONITOR MODE?
	JRST GETCO3		;BH NO, REGULAR CHARACTER HANDLING
	TRO CHR,1000		;BH FLAG IMAGE MODE (400 ALREADY SET BUT THAT
	JRST TPOPJ1		;BH  COULD MEAN META OR CALL)

GETCO3:	POP P,TAC		;BH
	CAIE CHR,400		;SPECIAL TESTS FOR 400 IN INPUT BUFFER
	JRST CPOPJ1		;SUCCESS RETURN
	MOVSI CHR,TPMON		;MUST BE USER MODE
	TDNE CHR,DEVIOS-TTIBUF(DAT)
	POPJ P,			;FAILURE RETURN (CAN'T HAVE THIS 400)
	MOVEI CHR,EMODE		;MUST BE IN EMODE
	TDNN CHR,ACTMOD-TTIBUF(DAT)
	POPJ P,			;SORRY, YOU CAN'T HAVE IT--GET ANOTHER.
	MOVEI CHR,400
	JRST CPOPJ1		;SUCCESS, RETURN THE 400

↑GETCHO:MOVE CHR,TCTR(DAT)	;GET TAKR BUFFER
	CAMN CHR,PCTR(DAT)	;IS IT SAME AS PUTR(BUFFER EMPTY)?
	JRST GETCH1		;YES, LOAD CHR WITH ZERO AND EXIT
	SOSLE TCTR(DAT)		;NO, ARE WE AT END OF BUFFER?
	JRST GETCH2		;NO. GO ON.
	MOVE CHR,BUF(DAT)	;YES. START AT TOP AGAIN
	HLRZM CHR,TCTR(DAT)	;INITIAL COUNTER
	HRRM CHR,TAKR(DAT)	;INITIAL POINTER
GETCH2:	ILDB CHR,TAKR(DAT)	;GET CHARACTER
	AOS FCTR(DAT)		;INCREMENT FREE CHAR. COUNT
	JUMPE CHR,GETCHO	;SKIP NULLS
	POPJ P,

GETCH1:	TDZA CHR,CHR		;RETURN 0 INDICATING END OF BUFFER
PUTCI0:	AOS FCTR(DAT)		;FIX FREE COUNTER
	POPJ P,
;SETBF TSETBF SETBFI SETBFT SETBF4 SETBF3 SETBF2 SETBFO SETBF0 SETBF9 SETBF8
;ROUTINES TO SET UP BUFFERS

;Here from DDBSRC or TTYKL1 to clear TTY input and output buffers, without
;touching the line editor.
SETBF:	PUSHJ P,SETBF2		;CLEAR TTY OUTPUT BUFFER
	JRST SETBFT		;CLEAR TTY INPUT BUFFER, BUT NOT LINE EDITOR

;Clear input and output buffers and line editor.
↑TSETBF:PUSHJ P,SETBF2		;INIT TTO BUFFER
↑SETBFI:PUSH P,[CLRBU3]		;RETURN BY CLEARING ANY LINE EDITOR FOR THIS TTY
SETBFT:	MOVE DAT,J		;SAVE J
	LDB J,PJOBN		;GET JOB #
	JUMPE J,SETBF4
	CONSZ PI,77000		;IN CH 1-6?
	JRST SETBF9		;YES, CAN'T CLRSIN NOW
	MOVSI TAC,COMSNB
	PUSHJ P,CLRSIN		;CLEAR FROM SWAPIN LIST FOR COMMAND
SETBF4:	MOVE J,DAT		;RESTORE J
	MOVEI DAT,1
	DPB DAT,PCOMIC
	DPB DAT,PLSTLC
	MOVEI DAT,TTIBUF(DDB)	;SPECIFY USER MODE INPUT BUFFER
	SETZM TISYNC(DDB)	;NO LINES IN BUFFER
	HRLI TAC,1100		;9 BIT BYTES IN INPUT BUFFER !!
IFN FTMONCIP,<
	SETZM MONCIP(DDB)	;NO MONITOR COMMAND NEEDING PROTECTION IN BUFFER NOW
>;IFN FTMONCIP
	JRST SETBF0		;INIT BUFFER

↑SETBF3:PUSHJ P,XMTIN5		;MAKE SURE GUY ISN'T HUNG ON OUTPUT.
↑SETBF2:MOVEI DAT,TTOBUF(DDB)	;SPECIFY OUTPUT BUFFER
↑SETBFO:HRLI TAC,OBYTSZ*100	;BH 1/5/78 WAS 700
SETBF0:	HRR TAC,BUF(DAT)
	MOVEM TAC,TAKR(DAT)
	MOVEM TAC,PUTR(DAT)
	MOVEI TAC,1
	MOVEM TAC,TCTR(DAT)	;SO FIRST SOSG DOESNT SKIP
	MOVEM TAC,PCTR(DAT)
	HLRZ TAC,BUF(DAT)	;CHARACTER COUNT
	MOVEM TAC,FCTR(DAT)	;UPDATE FREE CHARACTER COUNT
	POPJ P,

SETBF9:	MOVSI TAC,STBUFC	;MAYBE ALREADY A REQUEST TO DO THAT FOR THIS JOB
	TDNE TAC,JBTMSC(J)	;REQUEST ALREADY IN?
	JRST SETBF4		;YUP, DON'T PLANT ANOTHER
	IORM TAC,JBTMSC(J)	;NO, BUT WILL BE SOON (OK IF ONE IN PER PI CHANNEL)
	HRLI J,SETBF8		;SET UP CLOCK RQ TO CALL CLRSIN
	SYSPIFF
	IDPB J,CLKQ
	SYSPIN
	JRST SETBF4

SETBF8:	HRRZ J,DAT
	MOVSI TAC,STBUFC
	ANDCAM TAC,JBTMSC(J)	;CLEAR FLAG THAT SAID CLOCK REQ FOR US WAS IN
	MOVSI TAC,COMSNB
	JRST CLRSIN
;⊗ SPCHEK SPACTN ALLSPA SPOUT BNQUOT BREAKB SPHPOS FCSBRK ECHSUP SPBKDS LETTER NUMBER ARRBIT BNSPCL BNFRCM BNARGS LNUMBT SPCBTS SUPBTS SUPCCR SUPSCM EMODE BSACT ALLACT SUPERS SUPACT SUPEOL SUPSOM SUPLFE SUPCT SPCMOD SPCACT TTPOP

;ROUTINE TO CHECK IF A CHARACTER IS SPECIAL(ASCII 0-37, 175-177)
;CALL:	MOVE CHR,CHAR. TO BE CHECKED
;	PUSHJ P,SPCHEK
;	RETURN1 IF REGULAR ASCII CHAR (40-174), C(TAC)=0
;	RETURN2 IF SPECIAL CHAR., TAC LOADED WITH WORD FROM SPCTAB

↑SPCHEK:LDB TAC,[POINT 7,CHR,35] ;GET CODE WITHOUT CTRL BITS.
	SKIPN TAC,SPCTAB(TAC)
	POPJ P,
	TLNE LINE,DISLIN!DDDLIN!DMLIN
	TLZ TAC,ARRBIT		;NO UPARROWS ON DPYS
	TRZE CHR,RTILDE		;IS THIS REALLY A (NETWORK) TILDE?
	TDZA TAC,TAC		;YES, IT'S NOT EOF AFTER ALL
	TLNN TAC,SPCBTS		;MAYBE A SPECIAL
	POPJ P,			;NOT SPECIAL, AFTER ALL.
	JRST CPOPJ1

;SPECIAL CHARACTER TABLE FORMAT:
;	BITS+CHAR,,ADDRESS OF ROUTINE
;HIGH ORDER BITS IN LH:

SPACTN←←400000		;SPECIAL ACTION TO BE TAKEN (MUST BE SIGN BIT)
ALLSPA←←200000		;ALWAYS CONTROL FUNCTIONS, NEVER BREAK CHARACTERS.
SPOUT←←100000		;SPECIAL HANDLING ON UUO OUTPUT
BNQUOT←←40000		;SPCL CHAR QUOTED BY ↑←
↑BREAKB←←20000		;BREAK CHARACTER
SPHPOS←←10000		;CHARACTER AFFECTS HORIZONTAL POSITION
FCSBRK←←4000		;BREAK CHARACTER IN FCS(100) MODE
ECHSUP←←2000		;SUPPRESS ECHO OF CHAR ITSELF
SPBKDS←←1000		;PERFORM SPECIAL ACTION EVEN WITH CTRL. BITS.
LETTER←←400
NUMBER←←200
ARRBIT←←100		;CHAR ECHOES AS UPARROW MUMBLE IF LINTAB BIT SET
BNSPCL←←40		;CHAR IS A SPECIAL COMMAND FOLLOWING ↑←
BNFRCM←←20		;CHAR CAUSES A FORCED COMMAND FOLLOWING ↑←
BNARGS←←10		;SET UP ACS WITH LINED-STYLE ARGS BEFORE DOING IT
LNUMBT←←LETTER!NUMBER	;A LETTER OR DIGIT.

SPCBTS←←SPACTN!SPOUT!BREAKB!SPHPOS!FCSBRK

DEFINE SPC(U,L,X){FOR Z←U,L {X
			      }
		  }

;BITS FROM LOW-ORDER PART OF FOURTH WORD OF SPECIAL ACTIVATION TABLE
SUPBTS←←1	;SUPPRESS ACTIVATION ON CONTROL BITS.
SUPCCR←←2	;SUPPRESS EFFECT OF CONTROL CR TO LINE EDITOR
SUPSCM←←4	;SUPPRESS SUPBTS (ACTIVATE ANYWAY) IF CTRL-META
↑EMODE←←10	;INSERT 400 AFTER LAST CHARACTER ACTIVATED
↑BSACT←←20	;ACTIVATE ON BS WHEN LINE IS EMPTY
↑ALLACT←←40	;ACTIVATE ON ANYTHING W/ BUCKY BITS, OR BS, UNLESS REEDITING
↑SUPERS←←100	;SUPPRESS ERASURE OF NON-INITED LINE EDITOR WHEN LEYPOS GIVEN
↑SUPACT←←200	;SUPPRESS BUCKY BITS EXCEPT FOR LINE EDITOR COMMANDS
↑SUPEOL←←400	;SUPPRESS ACTIVATION BY LINE EDITOR COMMANDS GIVEN AT END OF LINE
↑SUPSOM←←1000	;SUPPRESS BUCKY BITS ON CHARS NOT IN SPECIAL ACTIVATION TABLE
↑SUPLFE←←2000	;SUPPRESS ECHOING OF LF INSERTED AFTER CR
↑SUPCT←←40000	;SUPPRESS LINE EDITOR COMMANDS CTRL-T, -L, -B
↑SPCMOD←←100000	;SPECIAL ACTIVATION MODE IS ENABLED:
		; THIS BIT CANNOT BE SET BY THE USER (EXCEPT IMPLICITLY) AND
		; IS ONLY MEANINGFUL WHILE THE TTY DDB IS A DETACHED DDB (FOR
		; A DETACHED JOB).  THE SPCBRK BIT IS COPIED HERE UPON DETACH
		; AND BACK UPON ATTACH.

SPCACT:	LDB TAC,[POINT 7,CHR,35]
	JUMPE TAC,CPOPJ		;ALWAYS ACTIVATE ON ↑C
	PUSH P,LINE
	IDIVI TAC,=36		;FIND CORRESPONDING WORD OF SPCL ACT TABLE FOR CHAR
	ADDI TAC,(DDB)
	MOVE TAC,ACTBTS(TAC)
	LSH TAC,(LINE)		;FIND CORRESPONDING BIT IN SPCL ACT TABLE
	TLNE TAC,400000
	JRST TTPOP		;BIT ON IN TABLE--ACTIVATE ON THIS CHAR
	MOVE LINE,ACTMOD(DDB)	;GET SPECIAL BITS IN FOURTH WORD
	TRNE LINE,SUPSCM
	CAIE UCHN,3
	TRNN LINE,SUPBTS
	JUMPG UCHN,TTPOP
	AOS -1(P)		;DON'T ACTIVATE ON THIS CHAR
TTPOP:	POP P,LINE
	POPJ P,
;SPCTAB SPCRLF

DEFINE LTRS<
SPC ("A","B",<XWD LETTER,0>)
	XWD LETTER+BNSPCL,BNC		;↑←C ADDS CONTROL TO NEXT CHAR
	XWD LETTER+BNSPCL,BND		;↑←D ADDS DOUBLE BUCKY TO NEXT CHAR
	XWD LETTER,0			;E
	XWD LETTER+BNSPCL+BNARGS,ESCF	;↑←F DOES TTY ESC F
	XWD LETTER,0			;G
	XWD LETTER+BNSPCL+BNARGS,ESCH	;↑←H DOES TTY ESC H
	XWD LETTER+BNSPCL+BNARGS,ESCI	;↑←I DOES TTY ESC I
SPC ("J","K",<XWD LETTER,0>)
	XWD LETTER+BNSPCL,BNL		;↑←L DELETES BACK TO NEXT CHAR TYPED
	XWD LETTER+BNSPCL,BNM		;↑←M ADDS META TO NEXT CHAR
	XWD LETTER+BNSPCL,BNN		;↑←N FLUSHES BUCKIES, # ARG
SPC ("O","Q",<XWD LETTER,0>)
	XWD LETTER+BNSPCL,BNCTLR	;↑←R REDRAWS INPUT LINE
	XWD LETTER,0			;S
SPC ("T","U",<XWD LETTER,0>)
	XWD LETTER+BNSPCL+BNARGS,BNFILE	;↑←V FORCES FILES COMMAND
	XWD LETTER+BNSPCL+BNARGS,BNWHO	;↑←W FORCES TTY WHO COMMAND
	XWD LETTER+BNSPCL+BNARGS,ESCX	;↑←X DOES TTY ESC X
	XWD LETTER,0			;Y
	XWD LETTER+BNSPCL+BNARGS,ESCZ	;↑←Z DOES TTY ESC Z
>;DEFINE LTRS

SPCTAB:	XWD ALLSPA+SPACTN+ECHSUP+BREAKB+SPBKDS,CONTC	;↑C
	XWD SPHPOS+ARRBIT,0				;↑A
	XWD SPHPOS+ARRBIT,0				;↑B
	XWD SPHPOS+ARRBIT+BNQUOT,0			; β
	XWD SPHPOS+ARRBIT,0				;↑D EOT
	XWD SPHPOS+ARRBIT,0				;↑E WRU
	XWD SPHPOS+ARRBIT,0				;↑F
	XWD SPHPOS,0					;↑G (BELL)
	XWD SPHPOS+ARRBIT,0				;↑H OR BACKSPACE KEY
	XWD ALLSPA+SPACTN+SPHPOS+SPOUT+SPBKDS,CONTI	;↑I OR TAB
	XWD BREAKB+SPBKDS,0				;↑J OR LINE FEED
	XWD ALLSPA+SPACTN+SPOUT,CONTK			;↑K OR VERT TAB
	XWD ALLSPA+SPACTN+SPOUT,CONTL			;↑L OR FORM FEED
SPCRLF::XWD ALLSPA+SPACTN+SPHPOS+SPBKDS!BNARGS,CRLF	;↑M OR CARRIAGE RETURN
	XWD SPHPOS+ARRBIT,0				;↑N
	XWD SPACTN+SPHPOS+ARRBIT+BNQUOT,CONTO		;↑O SUPP OUTPUT
	XWD SPHPOS+ARRBIT,0				;↑P
	XWD ALLSPA+SPACTN+ECHSUP+ARRBIT+BNQUOT,CONTQ	;↑Q unhold
	XWD SPHPOS+ARRBIT,0				;↑R
	XWD ALLSPA+SPACTN+ECHSUP+ARRBIT+BNQUOT,CONTS	;↑S hold
	XWD SPHPOS+ARRBIT,0				;↑T
	XWD SPACTN+ARRBIT+BNQUOT,CONTU			;↑U DELETE LINE
	XWD SPHPOS+ARRBIT,0				;↑V
	XWD SPHPOS+ARRBIT+BNSPCL,DELWRD			;↑←↑W DELETES WORD
	XWD SPHPOS+ARRBIT,0				;↑X
	XWD SPHPOS+ARRBIT,0				;↑Y
	XWD ALLSPA+SPACTN+ECHSUP+ARRBIT+BNQUOT,CONTZ	;↑Z TTY EOF
	XWD SPHPOS+ARRBIT,0				;ASCII 33 (OLD ALT-MODE)
	XWD SPHPOS+ARRBIT,0				;ASCII 34
	XWD SPHPOS+ARRBIT,0				;ASCII 35
	XWD SPHPOS+ARRBIT,0				;ASCII 36
	XWD ALLSPA+SPACTN+SPHPOS+ARRBIT+BNQUOT,BAKNXT	;↑← ASCII 37

SPC (" ",<",">,0)
	XWD BNSPCL,BNNEG				;- FLIPS ARG SIGN FOR ↑←
	XWD BNSPCL!BNARGS,ESCDOT			;↑←. diddles TPMON
SPC ("/","0"-1,0)
SPC ("0","9",<XWD NUMBER+BNSPCL+BNARGS,BNNUMB>)
SPC ("9"+1,"A"-1,0)

LTRS

SPC ("Z"+1,"a"-1,0)

LTRS

SPC ("z"+1,174,0)

	XWD ALLSPA+SPACTN+BREAKB+ECHSUP,ALTMOD		;OLD DEC ALTMODE 175
	0						;CLOSE CURLY BRACKET
	XWD SPACTN+ECHSUP+FCSBRK+SPBKDS,RUBOUT		;177 RUBOUT

;LIST OF ↑← COMMANDS:	(* - not yet implemented)
;↑B send an alpha (↑B) to input buffer
;↑C send a beta (↑C) to input buffer
;↑O send a partial (↑O) to input buffer
;↑U send a there-exists (↑U) to input buffer
;↑W delete the last word on the input line
;↑Z send a not-equal to input buffer
;↑← send an or-sign (↑←) to input buffer
;- negate arg
;. diddles TPMON, clears input buffer
;0-9 decimal arg
;C add control (200) bit to the next character
;D add double-bucky (600) bits to the next character
;F full character set
;H hide
;I interrupt program
;L kill backwards like lined
;M add meta (400) bit to the next character
;N no-operation.  useful to undo a partially typed command.
;R redraw the current input line
;T talk *
;V force a FILES command
;W force a TTY WHO command
;X like dpys
;Z auto beep
;lower case letters are the same as upper case
;CTLV1 TTYUUO TTUUOL MCMSKP

↑CTLV1:	PUSHJ P,TTYFNU		;HERE FOR THE CTLV UUO.  COMPLEMENT ECHO
	MOVEI IOS,NOECHO
	XORM IOS,DEVIOS(DDB)
	POPJ P,


;TTYUUO - THE AC FIELD DETERMINES THE ACTION OF THE UUO

↑TTYUUO:CAIL UCHN,TTUUOL	;TOO HIGH AC FIELD?
	POPJ P,			;YES, NO-OP
	PUSHJ P,TTYFNU
	HLRZ TAC,TTUUOT(UCHN)	;GET BITS
IFN FTMONCIP,<
	TRNE TAC,400000		;INPUT TYPE UUO?
	PUSHJ P,MCMSKP		;YES, SKIP ANY MONITOR COMMAND LEFT OVER IN BUFFER
>;IFN FTMONCIP
	TLNE IOS,TTYDTC
	TRNE TAC,200000		;DO WE CALL ROUTINE IF DETACHED?
	CAIA			;YES
	POPJ P,			;QUIT NOW
	SKIPG TTUUOT(UCHN)	;IS IT AN INPUT TYPE ?
	PUSHJ P,UNSUPR		;YES. TURN OFF CTRL. O.
	JRST @TTUUOT(UCHN)	;DISPATCH TO UUO ROUTINES

DEFINE UUOS{FOR X IN(<INCHRW,600000>,<OUTCHR,,ONEOUT>,<INCHRS,600000>,<OUTSTR>
,<INCHWL,600000>,<INCHSL,600000>,<GETLIN,200000>,<SETLIN>
,<RESCAN,,TRESCU>,<CLRBFI,,CLRBUF>,<CLRBFO,,SETBF3>,<INSKIP,600000>
,<INWAIT,600000,IWAIT>,SETACT,<TTREAD,200000>,OUTFIV)}

PSHSYS
LOSYS

UUOMAC TTUUOT,TTYUUO
TTUUOL←←UUOCNT

POPSYS

IFN FTMONCIP,<
;HERE WHEN ANY USER PROGRAM (UUO) TRIES TO READ A CHAR FROM THE TTY.
;CLOBBERS CHR, MAY SET UP DAT TO TTIBUF(DDB), AND MAY SET LINE WITH STLNAC.
MCMSKP:	SKIPN MONCIP(DDB)	;ANY LEFTOVER MONITOR COMMAND IN BUFFER?
	POPJ P,			;NOPE
	PUSH P,TAC
	MOVEI TAC,0
	EXCH TAC,MONCIP(DDB)	;NO MONITOR COMMAND THERE ANY MORE
	JUMPGE TAC,TPOPJ	;JUMP UNLESS WE NEED TO SKIP OVER MONITOR CMD
	PUSHJ P,COMR2A		;SKIP TO BREAK CHARACTER AT END OF MON CMD
	JRST TPOPJ
>;IFN FTMONCIP
;CLRBUF CLRBU3 CLINED CLINE2 INSKIP INSKI2

CLRBUF:	TLNE IOS,TPMON		;NOT ALLOWED IN MONITOR MODE!
	POPJ P,			;JUST RETURN
	PUSHJ P,SETBFT		;CLEAR INPUT BUFFER
CLRBU3:	MOVE TAC,DEVIOS(DDB)	;DON'T DO ANYTHING IF THIS IS A DETACHED DDB
	TLNE TAC,TTYDTC		;(IOS ISN'T SET UP BY ALL CLRBU3 CALLERS)
	POPJ P,			;DETACHED DDB, FORGET IT
	PUSHJ P,STLNAC		;SET UP AC LINE
CLINED:	TLNE LINE,DDDLIN!DISLIN!DMLIN ;THAT'S ALL FOR TTY'S
	SKIPL TAC,LETAB(LINE)	;DOES HE HAVE A LINE EDITOR?
	JRST CLINE2		;NO, JUST CLEAR FLAGS IN CASE WTFLAG IS ON
	PUSHACS			;PROTECT ACS OF CALLER OF SETBFI!
	MOVEI CHR,10044		;GET A CLEAR
	SETZ UCHN,		;WITH NO BITS
	PUSHJ P,PTWR1C		;AND SEND IT DOWN THE TUBES -- CLEAR LINE EDITOR
	POPACS
	POPJ P,

CLINE2:	HRRZS LETAB(LINE)	;CLEAR LE FLAGS, ESPECIALLY WTFLAG
	POPJ P,

INSKIP:	TRNE UUO,1
	SKIPLE TISYNC(DDB)	;INSKIP 1 WAITS FOR A WHOLE LINE
	TLNE IOS,TTYDTC!TPMON
	POPJ P,
	MOVE TAC,TITAKR(DDB)	;ANY CHARS. IN INPUT BUFFER ?
	CAME TAC,TIPUTR(DDB)
	JRST INSKI2		;YES, but don't count 400s if not in EMODE
	TLNN LINE,DDDLIN!DISLIN!DMLIN ;THAT'S ALL UNLESS HE'S A DPY
	POPJ P,
	SKIPGE TAC,LETAB(LINE)	;ANYTHING IN LINE EDITOR?
	SKIPG FCPOS(TAC)	;NON-ZERO CHAR COUNT?
	POPJ P,			;NO
	JRST CPOPJ1		;YES, SKIP RETURN

INSKI2:	MOVE AC2,ACTMOD(DDB)	;get special mode bits in RH
	TRNE AC2,EMODE		;skip if not in EMODE, can't have 400s
	JRST CPOPJ1		;400s allowed, no special check necessary
	TRNE IOS,10		;Image mode 10 or 11?
	TRNE IOS,6
	SKIPA AC2,TITCTR(DDB)	;No, prepare to check Takr for wrapping around
	JRST CPOPJ1		;Yes, allowed to read 400s in image mode
	CAIG AC2,1		;wrapping around?
	HRR TAC,TTIBUF+BUF(DDB)	;Yes, wrap around to beginning of buffer
	ILDB CHR,TAC		;sneak look at next char to be read
	CAIE CHR,400		;if a 400, then throw it away and start over
	JRST CPOPJ1		;not a 400, skip return means char ready to read
	MOVEI DAT,TTIBUF(DDB)	;GET A CHARACTER
	PUSHJ P,GETCHB		;FROM TTI BUFFER
	 JRST INSKIP		;OK, got expected invalid 400, now start UUO over
	PUSHACS
	PUSHJ P,DISGST		;print time of error on CTY
	PUSHJ P,DISMES
	 ASCIZ/GETCHB didn't skip at INSKI2 (for expected 400).  DDB is set up.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCAL
	JRST INSKIP		;try again anyway, discarding the non-400
;INCHS3 INCHSL INCHRS INCHS2 INCHSY INCHW0 INCHWL IWAIT0 IWAIT INCHGT INCHG1 INCHGB RDLINE RDLIN2 RDLIN4 RDLIN5 RDLIN3 RDLIN6

INCHS3:	TLNE IOS,TTYDTC		;IS THIS DDB DETACHED?
	POPJ P,			;YES, FORGET ABOUT DOING INPUT
	SKIPGE TAC,LETAB(LINE)	;LINE EDITOR INITIALIZED?
	SKIPG FCPOS(TAC)	;YES, ANYTHING IN IT?
	POPJ P,			;NO
	PUSHJ P,INCHG1		;ACTIVATE ONE CHAR FROM LINE EDITOR
	JRST INCHS2		;NOW SEE IF WE CAN READ IT

;INPUT A CHARACTER AND SKIP---IF NONE TYPED, DON'T SKIP
INCHSL:	SKIPLE TISYNC(DDB)	;ANY LINES IN BUFFER?
INCHRS:	TLNE IOS,TPMON
	POPJ P,			;NOTHING TO SPEAK OF
	PUSHJ P,INCHGT		;MAYBE GET A CHR FROM LINE EDITOR.
INCHS2:	MOVEI DAT,TTIBUF(DDB)	;GET A CHARACTER
	PUSHJ P,GETCHY		;FROM TTI BUFFER
	PUSHJ P,PTICHK		;WAKE UP PTY WAITERS, IF ANY.
	JUMPE CHR,INCHS3	;JUMP IF EMPTY BUFFER
	CAIE CHR,600
	JRST INCHSY		;NOT ↑C
	MOVE CHR,DEVMOD(DDB)
	TLNN CHR,TTYATC		;IF ATTACHED TO JOB
	TRNN CHR,ASSCON!ASSPRG	;OR NOT ASSIGNED OR INITED
	JRST MONUS6		;THEN PROCESS ↑C
INCHSY:	ANDI CHR,777		;BH 1/8/78 DON'T STORE 1000 BIT (IMAGE)
	XCTR XW,[MOVEM CHR,(UUO)] ;MOVE INTO LOC. SPECIFIED BY UUO
	JRST CPOPJ1		;AND SKIP RETURN

;INPUT CHARACTER AND WAIT, LINE MODE
INCHW0:	MOVE IOS,[TTYIOW,,IOACT] ;NONE. WAIT FOR IT
	IORM IOS,DEVIOS(DDB)	;TTY TO IOW STATE
	MOVSI IOS,DDTM		;JUST IN CASE
	ANDCAB IOS,DEVIOS(DDB)	;CLEAR DDTMODE BREAK FLAG
	PUSHJ P,TWSYNC		;WAIT FOR CHAR (INTPTI IF APPROPRIATE).
INCHWL:	PUSHJ P,INCHSL		;SEE IF ANY CHARS.
	 JRST INCHW0		;NO, WAIT FOR ONE
	POPJ P,			;YES. GIVE IT TO USER

IWAIT0:	MOVE IOS,[TTYIOW,,IOACT]
	IORM IOS,DEVIOS(DDB)
	MOVSI IOS,DDTM
	ANDCAB IOS,DEVIOS(DDB)
	PUSHJ P,TWSYNC
IWAIT:	LDB CHR,PLASTC		;GET LENGTH OF LAST RE-EDITED LINE.
	TRNE UUO,-1		;IS ADDRESS OF IWAIT 0 ?
	XCTR XW,[MOVMM CHR,(UUO)] ;NO. USER WANTS GOOD NUMBER.
	SKIPLE TISYNC(DDB)	;IS THERE A LINE PRESENT ?
	TLNE IOS,TPMON		;NOTHING IN MONITOR MODE
	JRST IWAIT0
	POPJ P,

INCHGT:	TLNN LINE,DISLIN!DDDLIN!DMLIN ;ONLY DPY'S
	POPJ P,
	MOVE TAC,TITAKR(DDB)	;WILL HE GET A CHAR WITHOUT
	CAME TAC,TIPUTR(DDB)	; ACTIVATING THE LINE EDITOR?
	POPJ P,			;YES
INCHG1:	MOVEI TAC,1		;NUMBER OF CHARS TO ACTIVATE
INCHGB:	OFFSCN			;LINED WANTS SCANNER OFF IF PTLIP NOT SET
	PUSHJ P,LACTIV		;WILL TRANSFER SOME RIGHT NOW
	JRST SCNONJ		;IF THERE ARE ANY!

;UUO TO READ A LINE FROM TTY (ESPECIALLY FROM A DISPLAY IN EMODE).
;	MOVE AC,[BBCCCC,,ADDR]	;ADDR IS ADDRESS FOR RETURNED 9-BIT STRING
;	RDLINE AC,
;WHERE BB IS INITIAL BYTE POSITION (TO BE IDPBed),
;AND CCCC IS MAXIMUM NUMBER OF CHARACTERS TO BE READ BY THIS UUO.
;IF CCCC=0, THEN MAX IS 50 (OCTAL) WORDS.
;A ZERO BYTE MARKS THE END OF THE STRING OF 9-BIT CHARACTERS RETURNED.
;THE BYTE POINTER TO THIS ZERO BYTE IS RETURNED IN THE AC.
;IF ON DISPLAY IN EMODE, RETURNS CHARS UNTIL SEES 400 OR END OF COUNT.
;OTHERWISE, GIVES USER EVERYTHING UP TO FIRST ACTIVATOR OR END OF COUNT.
;ACTIVATOR IS DEFINED AS USUAL (EG, FOR INCHWL).
;	NOTE----THE FOLLOWING CALL WILL RETURN THE STRING STARTING AT THE
;		HIGH-ORDER BYTE OF LOCATION XYZ (BECAUSE THE BYTE POSITION
;		(00 HERE) IS INCREMENTED BEFORE THE FIRST DEPOSIT):
;	MOVEI AC,XYZ-1
;	RDLINE AC,

↑RDLINE:PUSHJ P,TTYFNU
IFN FTMONCIP,<
	PUSHJ P,MCMSKP		;SKIP ANY MONITOR COMMAND LEFT OVER IN BUFFER
>;IFN FTMONCIP
	XCTR XR,[MOVE TAC,(UUO)] ;PICK UP CONTENTS OF USER AC
	LDB AC1,[POINT 12,TAC,17] ;MAX NUMBER OF CHARS HE WANTS
	JUMPN AC1,.+2		
	MOVEI AC1,50*4-1	;HE DIDN'T SAY HOW MANY, USE THIS MAX (=159)
	XCTR XW,[MOVEM AC1,JOBTM1]
	TLZ TAC,7777
	TLO TAC,1100		;GOTTA BE 9-BIT BYTES
	PUSH P,TAC
RDLIN2:	PUSHJ P,INCHWL		;GET A CHARACTER IN LINE MODE
	POP P,TAC		;NOTE THAT THE INCHWL RETURNS THE CHAR IN AC
	XCTR XDB,[IDPB CHR,TAC]	;GIVE IT TO USER
	CAIE CHR,400		;IS THIS EMODE MARKING END OF LINE?
	XCTR XRW,[SOSG JOBTM1]	;OR HAVE WE RUN OUR CHAR COUNT OUT?
	JRST RDLIN3		;YES, QUIT NOW MARKING END WITH ZERO BYTE
	TRNE CHR,1000		;BH 1/8/78 QUIT ON IMAGE MODE CHARACTER
	JRST RDLIN3		;BH  BECAUSE CAN'T REALLY WIN WITH INCHWL
	PUSH P,TAC
	MOVE TAC,ACTMOD(DDB)	;GET SPECIAL BITS
	TLNE LINE,DISLIN!DDDLIN!DMLIN ;IS THIS A DISPLAY?
	TRNN TAC,EMODE		;YES, IS IT LOOKING FOR 400?
	CAIA			;NO
	JRST RDLIN2		;YES, KEEP LOOKING
	TLNN LINE,SPCBRK	;ARE WE IN SPECIAL ACTIVATION MODE?
	JRST RDLIN6		;NO
	LDB UCHN,[POINT 2,CHR,28] ;CONTROL BITS
	PUSHJ P,SPCACT
	 JRST RDLIN5		;ACTIVATOR
RDLIN4:	LDB TAC,[POINT 7,CHR,35]
	MOVE TAC,SPCTAB(TAC)
	TLNN TAC,BREAKB!FCSBRK	;BREAK CHARACTER?
	JRST RDLIN2		;NO, GET MORE
RDLIN5:	POP P,TAC
RDLIN3:	SETZ CHR,
	XCTR XDB,[IDPB CHR,TAC]
	JRST STOTAC		;RETURN FINAL BYTE POINTER IN AC

RDLIN6:	TRNN CHR,600		;ANY CONTROL BITS?
	JRST RDLIN4		;NO
	JRST RDLIN5		;YES, ACTIVATOR ENDS INPUT LINE
;INCHRW ONEOUT
;MORE ROUTINES CALLED BY TTY UUO DISPATCHER

;INCHRW GOES INTO I/O WAIT IF NO CHARACTER HAS BEEN TYPED--NO SKIPS

INCHRW:	PUSHJ P,INCHRS		;GET A CHAR IF ONE IS THERE
	JRST .+2		;NONE THERE
	POPJ P,			;CHAR PICKED UP AND STORED
	MOVE IOS,[TTYIOW+DDTM,,IOACT] ;SETUP FOR IOWAITM
	IORB IOS,DEVIOS(DDB)	;SPECIFICALLY FOR INPUT WAIT
	PUSHJ P,TWSYNC		;WAIT FOR CHAR TO BE TYPED
	JRST INCHRW		;GO GET IT

;ONEOUT OUTPUTS ONE CHARACTER

ONEOUT:	XCTR XR,[MOVE CHR,(UUO)] ;PICK UP CHAR FROM USER
	TRNE IOS,IOSUPR		;IF ↑O MODE
	POPJ P,			;RETURN
	ANDI CHR,377		;MASK ANY JUNK (BH WAS 177)
	TRNE IOS,10		;BH 1/8/78 MODE 10 OR 11?
	TRNE IOS,6		;BH IF SO, WE SET THE 400 BIT
	JRST .+2		;BH JUMP IF NOT IMAGE MODE
	TRO CHR,400		;BH OUTCHR WANTS US TO SET THE BIT
	PUSHJ P,OUTCHR		;PLACE IT IN TTO BUFFER
	JUMPN CHR,TYPGO		;IF IT STORED, RETURN
	PUSHJ P,TTOUWS		;BUFFER WAS FULL. TRY AGAIN LATER
	JRST ONEOUT
;GETLIN GETLN1 GETLN2 GETLN5 GETLN4 GETLN3

;GETLIN PUTS LINE CHARACTERISTICS WORD INTO ADR. IN UUO ADR. FIELD

GETLIN:	TLNE IOS,TTYDTC		;Are we detached?
	SETO LINE,		;Yes, then use -1 for own line nbr and charact.
	XCTR XR,[SKIPGE TAC,(UUO)] ;DOES USER WANT OWN LINE CHAR WD.?
	JRST GETLN1		;YES
	SETO LINE,		;NO, CHECK SIZE OF NUMBER
	CAIL TAC,TTPLEN		;TOO HIGH?
	JRST GETLN3		;Yes, illegal line number, return -1
	MOVE LINE,LINTAB(TAC)	;NO, GET IT
	HRRI LINE,(TAC)
GETLN1:	MOVE TAC,LINE		;START WITH THIS LINE
	JRST GETLN5		;JUMP IN

GETLN2:	TLNE TAC,PTYLIN		;IS THIS A REAL PTY?
	TLNE TAC,DISLIN!DDDLIN!DMLIN!IMPBIT ;DON'T FOLLOW CHAIN IF ALREADY AT DISPLAY
	JRST GETLN4		;END OF CHAIN
	MOVE TAC,PTYJOB-PTYL0(TAC) ;OWNER OF THIS PTY
	MOVE TAC,JBTLIN(TAC)	;HIS LINE CHARACTERISTICS
GETLN5:	CAMN TAC,[-1]		;THAT'S ALL IF WE FIND A DETACHED LINE
	JRST GETLN3
	HLL TAC,LINTAB(TAC)	;GET REAL BITS (WHICH CAN CHANGE)
	JRST GETLN2		;DOWN THE CHAIN

GETLN4:	AND TAC,[XWD DISLIN!DDDLIN!DMLIN,0] ;COPY THESE BITS INTO
	TDO LINE,TAC		; LINE BITS, IN CASE WE ARE A PTY
GETLN3:	XCTR XW,[MOVEM LINE,(UUO)] ;GIVE BITS TO USER
	POPJ P,
;SETLIN SETLN1 SYNCHK SYNCH2 SYNCH3 SYNCH1 SYNCH4 SYNCH5 SYNCHA

;ROUTINE TO SET LINE CHARACTERISTICS THAT ARE SETABLE

SETLIN:	MOVSI TAC,LGLSET	;MASK FOR ALL SETTABLE BITS
	TLNE LINE,IMPBIT!DMLIN	;IS THIS AN IMP OR DM?
	JRST SETLN1		;YES, TBXPND MAY BE SET.
	TLNE LINE,DISLIN!DDDLIN!PTYLIN
	TLZ TAC,TBXPND		;DISALLOW DIDDLING TAB EXPANSION BIT
SETLN1:	PUSH P,LINTAB(LINE)	;SAVE OLD BITS TO SEE IF DM TAB BIT CHANGES
	ANDCAM TAC,LINTAB(LINE)	;SHUT OFF ALL SETABLE BITS
	XCTR XR,[AND TAC,(UUO)]	;SET ONLY THOSE BITS USER WANTS SET
	OFFSCN			;DON'T LET SCANNER GET IN IF BECOMING DM
	IORB TAC,LINTAB(LINE)	;SET RESULTANT
	HLL LINE,TAC		;NEW BITS TO LINE
	POP P,AC1		;OLD BITS
	XOR AC1,LINE		;CHANGED BITS
	TLNE AC1,TBXPND		;TAB EXPANSION MODE CHANGED?
	PUSHJ P,TABCHK		;YES, IF DM, NEEDS SPECIAL ACTION
SETLN2:	ONSCN
SYNCHK:	MOVEI AC3,1		;ONE FOR FIRST CHAR
IFN FTMONCIP,<
	LDB AC2,PUNIT
	TLNN IOS,TTYDTC		;IF THIS IS DETACHED DDB, LEAVE LH AC2 ZERO
	MOVE AC2,LETAB(AC2)	;SEE IF LINE EDITOR IS WAITING
	TLNE AC2,WTFLAG
	HRLI AC3,400000		;LE WAITING, MAKE ALL IN TTY INPUT ACTIVATED
>;IFN FTMONCIP
	MOVE AC1,TITCTR(DDB)	;PREPARE TO SIMULATE GETCHY
	MOVE AC2,TITAKR(DDB)	
	SETZM TISYNC(DDB)	;IN CASE BUFFER EMPTY
SYNCH2:	CAMN AC1,TIPCTR(DDB)	;IS THIS THE END?
	POPJ P,			;YES, LEAVE
	SOJG AC1,SYNCH3		;TEST FOR WRAP AROUND
	HRR AC2,TTIBUF(DDB)	;RESET BYTE POINTER
	HLRZ AC1,TTIBUF(DDB)	;AND TAKR COUNTER
SYNCH3:	ILDB CHR,AC2		;PICK UP CHAR!
IFN FTMONCIP,<
	JUMPL AC3,SYNCH4	;EVERYTHING ACTIVATES IF LINE EDITOR WAITING
>;IFN FTMONCIP
	TLNE IOS,TPMON		;MONITOR DOESN'T GET ANY OF THIS
	JRST SYNCH5
	TLNN LINE,SPCBRK	;ARE WE SPECIALLY ACTIVATING
	JRST SYNCH1		;NO
	LDB UCHN,[POINT 2,CHR,28]
	PUSHJ P,SPCACT		;IS THIS AN ACTIVATOR?
	 JRST SYNCH4		;YES
	JRST SYNCH5		;BIT ISN'T ON, BUT MAYBE IT'S ALWAYS AN ACTIVATOR

SYNCH1:	TRNE CHR,600		;CONTROL BITS?
	JRST SYNCH4		;YES, ACTIVATE THESE SO FAR
SYNCH5:	PUSHJ P,SPCHEK
	 AOJA AC3,SYNCH2	;NOT SPECIAL CHAR
	TLNE TAC,BREAKB!FCSBRK	;BREAK CHARACTER?
SYNCH4:	HRRZM AC3,TISYNC(DDB)	;UPDATE TISYNC WITH # OF CHARS SCANNED SO FAR
	AOJA AC3,SYNCH2

;Here from RECIN4 upon activation char, to activate everything in input buffer.
SYNCHA:	MOVN AC1,FCTR(DAT)	;UNUSED SPACE IN BUFFER.
	ADDI AC1,TTICHR		;SIZE OF BUFFER
	MOVEM AC1,TSYNC(DAT)	;SET TISYNC
	POPJ P,
;SETACT STACT1

;SETACT		SET A BREAK TABLE
;CALL:	TTYUUO 15,ADDR
;RIGHT HALF CONTAINS ADDRESS OF TABLE TO BE BLT'ED IN (NO NEW TABLE IF 0)
;LEFT HALF CONTAINS ADDRESS OF WHERE TO STORE COPY OF OLD TABLE (NO STORE IF 0)

SETACT:	XCTR XR,[MOVS TAC,(UUO)]	;GET POINTER WORD
	TRNN TAC,-1
	JRST STACT1			;HE DOESN'T WANT TO KNOW WHAT HE HAD
	MOVE TAC1,ACTBTS(DDB)		;GIVE HIM A COPY OF THE TABLE
	XCTR XW,[MOVEM TAC1,(TAC)]
	MOVE TAC1,ACTBTS+1(DDB)
	XCTR XW,[MOVEM TAC1,1(TAC)]
	MOVE TAC1,ACTBTS+2(DDB)
	XCTR XW,[MOVEM TAC1,2(TAC)]
	MOVE TAC1,ACTMOD(DDB)
	XCTR XW,[MOVEM TAC1,3(TAC)]
STACT1:	HLRZ TAC1,TAC
	JUMPE TAC1,CPOPJ
	XCTR XR,[MOVE TAC,(TAC1)]	;GET HIS NEW TABLE
	MOVEM TAC,ACTBTS(DDB)
	XCTR XR,[MOVE TAC,1(TAC1)]
	MOVEM TAC,ACTBTS+1(DDB)
	XCTR XR,[MOVE TAC,2(TAC1)]
	MOVEM TAC,ACTBTS+2(DDB)
	XCTR XR,[MOVE TAC,3(TAC1)]
	MOVE TAC1,ACTMOD(DDB)		;GET OLD SPCMOD BIT IN CASE JOB IS DETACHED
	ANDI TAC1,SPCMOD		;OTHER BITS COME FROM USER
	TRZ TAC,SPCMOD			;DON'T LET USER DIDDLE THIS BIT!
	IOR TAC,TAC1
	MOVEM TAC,ACTMOD(DDB)
	POPJ P,
;OUTFIV FIVOU2 FIVOU1 FIVOUT FIVOU3 FIVOU4

;OUTFIV UUO
;	TTYUUO 17,ADR
;ADR: 5 LEFT-JUSTIFIED ASCII CHARACTERS.
;PUTS THESE CHARACTERS, UP TO THE FIRST NULL, INTO THE OUTPUT BUFFER.
;IF BIT 35 IS A ONE, PREFIXES THESE CHARS WITH A RUBOUT.
;GUARANTEES THAT THESE CHARS WILL BE SENT AS AN INDIVISIBLE BLOCK.

OUTFIV:	XCTR XR,[MOVE CHR,(UUO)] ;TTYUUO 17 comes here,
	PUSHJ P,FIVOUT		;other places in TTYSER go there.
	POPJ P,

FIVOU2:	ONSCN			;TURN ON SCANNER CHANNEL
FIVOU1:	PUSHJ P,TTOUWS		;Not enough room in buffer, so wait.
	CAIA
FIVOUT:	PUSH P,CHR		;Make a temp cell for the data.
	MOVEI AC3,6		;Check for enough buffer space.
	CAML AC3,TOFCTR(DDB)
	JRST FIVOU1
	OFFSCN			;TURN OFF SCANNER CHANNEL
	TLNE IOS,TTYDTC		;Detached output gets flushed...
	JRST SCNONJ		;...Ch. 5 back on.
	CAML AC3,TOFCTR(DDB)	;Check again for room, this time with
	JRST FIVOU2		;the interrupt disabled.
	PUSHJ P,UNSUPR		;You can't ↑O a command by God!
	MOVSI TAC,(<POINT 7,(P),-1>) ;Byte pointer into data.
	TRNN CHR,1		;If bit 35 is on,
	JRST FIVOU3
	MOVEI CHR,177		;give out with a rubout.
	PUSHJ P,PUTCHO
FIVOU3:	ILDB CHR,TAC		;Fetch next char,
	JUMPE CHR,FIVOU4	;terminate on a null.
	PUSHJ P,PUTCHO		;Stuff into buff.
	TLNE TAC,760000		;5th chr in wrd?
	JRST FIVOU3		;No.  Do it again.
FIVOU4:	ONSCN			;TURN ON SCANNER CHANNEL
	POP P,(P)		;Chan. 5 is back, so is the stack.
	JRST TYPGO
;NULMES TTYMES NULME1 TTYMS7 TTYMS1 TTYMS0 TTYM00 TTYMSA NULME2 TTYMS3 TTYMS4 TTYMS5 TTYMSD TTYMSW TTYMS8 NULME5 TTYM9A NULME4 TTYMS9 NULME3 DPYMS1 DPYMS2 DPYMS3 DPYNUL DPYNU2

;A UUO TO SEND A MESSAGE TO ANOTHER TTY
;NULMES VERSION ALLOWS NULLS EMBEDDED IN MESSAGE TEXT
;  COUNT MUST BE NONZERO AND INCLUDES SKIPPED ZERO BYTES
;  NULMES ALSO SETS AC TO THE UNUSED COUNT IN CASE OF FAILURE

↑NULMES:XCTR XW,[SETOM JOBTM3]	;BH 3/12/75 NULMES UUO
	XCTR XW,[SETOM JOBTM2]	;THIS RETURNS ZERO ON EARLY ERROR
	XCTR XW,[MOVEM UUO,JOBTM4] ;SAVE WHICH AC, FOR RESULT
	JRST NULME1		;JOBTM3 IS FLAG FOR WHICH UUO

↑TTYMES:XCTR XW,[SETZM JOBTM3]
NULME1:	MOVE UUO,TAC		;SAVE POINTER
	XCTR XR,[MOVE TAC,(UUO)] ;PICK UP TTYNN OR LINE NUMBER
	CAIGE TAC,TTPLEN	;IS IT REASONABLE LINE NUMBER?
	JUMPGE TAC,TTYMS1	;YES, UNLESS NEGATIVE
	CAMN TAC,['TTY   ']	;GETTING HIS OWN?
	JRST TTYMS7		;YES
	PUSHJ P,GETDDB		;FIND DDB FOR IT BY SIXBIT TTY NAME
	 JRST NULME5		;EARLY LOSSAGE EXIT
	JRST TTYMS0

TTYMS7:	PUSHJ P,TTYFND		;GET HIS TTY
	MOVE IOS,DEVIOS(DDB)
	TDNE IOS,[TTYDTC,,IOSUPR] ;EASY IF DETACHED OR SUPPRESSING OUTPUT
	JRST CPOPJ1		;TELL HIM HE WON
	MOVNI AC2,1		;FLAG TYPEOUT TO 'TTY' (DON'T USE DTYO)
	JRST TTYMSA

TTYMS1:	MOVE LINE,TAC		;FOR GETDBA
	PUSHJ P,GETDBA		;FIND DDB BY TTY LINE NUMBER
	 JRST NULME5		;NO DDB OR ERROR
TTYMS0:	LDB TAC,PJOBN		;GOT A DDB, CHECK FOR DETACHED FROM SYS
	JUMPN TAC,TTYM00	;OWNED BY SOME JOB, CAN'T BE DETACHED
	MOVE TAC,DEVMOD(DDB)	;JOB 0, MAYBE DETACHED
	TRNE TAC,ASSCON		;TEST THE BIT FOR DETACHED FROM SYSTEM
	JRST NULME5		;FLUSH THE UUO IF DETACHED
	LDB TAC,PUNIT		;LINE NUMBER
	CAIL TAC,SCNNUM		;MAYBE THIS TTY IS DISABLED
	JRST TTYM00		;Don't care
	HRRZ TAC,LINBIT(TAC)	;Get DCA port, if any
	TRZN TAC,400000		;Skip if on DCA
	JRST NULME5		;Not assigned!
	MOVE TAC,DCATAB(TAC)	;See if port down
	TRNE TAC,DCADWN		;Skip unless down
	JRST NULME5		;Don't allow TTYMES to down TTY, even one w/DDB
TTYM00:	MOVEI AC2,0		;FLAG TYPEOUT TO EXPLICIT TTY
	MOVE TAC,IMLHAC(DDB)	;DON'T DO IT IF GAGGED
	TRNE TAC,GAGBIT!GAGTBT	;
	JRST NULME5		;
TTYMSA:	XCTR XR,[MOVE UUO,1(UUO)] ;PICK UP POINTER
	TLNN UUO,770000		;ALREADY GOT P FIELD?
	TLO UUO,440000		;NO, MAKE IT PICK UP FIRST BYTE OF WORD
	HLRZ TAC,UUO
	ANDI TAC,7777		;GET COUNT FIELD
	TLZ UUO,7777
	TLO UUO,700		;SET TO 7 BIT BYTES
	JUMPN TAC,NULME2	;IS THERE A COUNT?
	XCTR XR,[SKIPE JOBTM3]	;(BH 3/12/75 NULMES MUST HAVE COUNT)
	JRST UUOERR
	MOVEI TAC,777777	;NO, USE LARGE COUNT
NULME2:	XCTR XW,[MOVEM TAC,JOBTM2] ;SAVE COUNT IN USER CORE
	MOVEI DAT,TTOBUF(DDB)	;SET-UP DAT
	MOVE IOS,DEVIOS(DDB)	;MAKE SURE IOS IS SET UP.
	AOS (P)			;SKIP RETURN FROM HERE
	PUSHJ P,STLNAC		;GET LINE CHARACTERISTICS. REG 7/20/73
	TLNE LINE,CTYLIN	;IS THIS THE CTY THAT WE'RE TYPING ON?
	JRST TTYM9A		;YES.  USE DISASTER SERVICE FOR CTY.
	XCTR XW,[MOVEM AC2,JOBTM5] ;REMEMBER IF DOING TTYMES TO SELF ('TTY')
	JUMPN AC2,TTYMS3	;DON'T USE DTYO FOR TYPEOUT TO 'TTY' (SELF)
	SKIPE AC1,LETAB(LINE)	;;FIND DPY HEADER FOR THIS LINE (IF ANY)
	JRST DPYMS1		;;DETERMINE IF P. OF P. 0 IS CURRENT
TTYMS3:	XCTR XRW,[SOSL CHR,JOBTM2] ;COUNT OUT YET?
	XCTR XLB,[ILDB CHR,UUO]	;NO. GET A CHAR.
	JUMPLE CHR,NULME3	;QUIT ON NULL, OR COUNT EXHAUSTED.
	MOVNI TAC,10		;TRY THIS MANY TIMES ON EACH CHAR.
	XCTR XW,[MOVEM TAC,JOBTM1]
TTYMS4:	MOVE IOS,DEVIOS(DDB)	;GET IOS
	XCTR XR,[SKIPN JOBTM5]	;SKIP IF TTYMES IS TO SELF
	JRST TTYMS5		;OTHER GUY CAN'T SUPPRESS OUR TTYMES TO HIM
	TDNE IOS,[XWD TTYDTC,IOSUPR] ;DID SOMETHING HAPPEN?
	POPJ P,			;YES, FLUSH THE REST!
TTYMS5:	PUSHJ P,OUTCHR		;OUTPUT A CHAR (NO-OP IF TTYDTC ON)
	JUMPN CHR,TTYMS3	;LOOP IF CHAR PLACED
	XCTR XRW,[AOSLE JOBTM1]	;COUNT DOWN LOSSAGE
	JRST TTYMS8		;COUNT OUT, LOSE ON THIS CHAR
	LDB TAC,PJOBN		;PICK UP JOB NUMBER
	CAMN TAC,JOB		;DIFFERENT?
	JRST TTYMSW		;WAITING FOR OURSELVES IS SIMPLE
	PUSHJ P,TYPTST		;TRY TO GET HIM GOING
	MOVE J,JOB		;NEED THIS FOR SLEEP
	PUSH P,LINE
	MOVEI TAC,20
	PUSHJ P,SLEEPT		;SLEEP 20 TIC'S
	POP P,LINE
	SKIPN DDB,TTYTAB(LINE)
	JRST TTYMS8		;SOMEBODY DELETED OUR TTY
TTYMSD:	PUSHJ P,STLNAC		;SLEEP CLOBBERS THIS
	XCTR XLB,[LDB CHR,UUO]	;GET CHAR. BACK
	JRST TTYMS4		;TRY AGAIN

TTYMSW:	MOVE IOS,[IOW,,IOACT]	;SET DEVICE ACTIVE (TTY), waiting for output
	IORB IOS,DEVIOS(DDB)	;(TTYIOW is presumably off)
	PUSHJ P,TYPTST		;TRY TO GET US GOING
	MOVE J,JOB		;get our job number back
	PUSHJ P,DDTWAT		;Wait for output, skip if DDB goes away
	 JRST TTYMSD
TTYMS8:	SOS (P)			;HUNG TTY, GIVE LOSSAGE RETURN
NULME5:	XCTR XR,[SKIPN JOBTM3]	;ENTER HERE FOR ERROR BEFORE AOS (P)
	POPJ P,			;RETURN UNLESS NULMES
	XCTR XRW,[AOS TAC,JOBTM2] ;GET UNUSED COUNT
	XCTR XR,[MOVE UUO,JOBTM4] ;GET AC POINTER
	JRST STOTAC		;TELL THE USER HOW BADLY HE LOST

;AT TTYM9A FOR SPECIAL CASE OF TYPING ON CTY.
TTYM9A:	JUMPE AC2,.+2		;If really outputting to TTY,
	SETZM CTYMAR		; don't indent
	JUMPN AC2,TTYMS9	; and don't print time either
	PUSHJ P,DISUSJ		;PRINT TIME AND NAME OF JOB ON CTY
	JRST TTYMS9

NULME4:	JUMPL CHR,CPOPJ		;SAME AS NULME3 BUT FOR CTY OUTPUT
	XCTR XR,[SKIPN JOBTM3]	;NULL BYTE, WHICH UUO?
	POPJ P,			;TTYMES, QUIT
TTYMS9:	XCTR XRW,[SOSL CHR,JOBTM2] ;COUNT OUT YET?
	XCTR XLB,[ILDB CHR,UUO]	;NO. GET A CHAR.
	JUMPLE CHR,NULME4	;QUIT ON NULL, OR NEGATIVE COUNT.
	PUSHJ P,DISTYO		;SEND CHARACTERS VIA DISASTER SERVICE
	JRST TTYMS9

NULME3:	JUMPL CHR,TYPGO2	;BH 3/12/75 ALWAYS QUIT WHEN COUNT DONE
	XCTR XR,[SKIPN JOBTM3]	;NULL BYTE, WHICH UUO?
	JRST TYPGO2		;TTYMES, QUIT
	JRST TTYMS3		;NULMES, SKIP THE BYTE

DPYMS1:	MOVE AC2,CURPP(AC1)	;;GET POINTER TO CURRENT P. OF P.
	SKIPN PPNO(AC2)		;;IF CURRENT P. OF P. IS 0
	JRST TTYMS3		;THEN GO THRU OUTPUT BUFFER
	HLL AC2,PPDPY(AC2)	;PICK UP DISPLAY-TYPE BIT
	SKIPE DPHOLD(AC1)	;IF HOLDING, DON'T DO OUTPUT TO CURRENT PP
	SETZ AC2,		;FLAG NO OUTPUT TO CURRENT PP
	PUSH P,AC2		;SAVE POINTER TO CURRENT PP
	MOVS DAT,PPCALL(AC1)	;GET POINTER TO P. OF P. 0
	HLL DAT,PPDPY(DAT)	;PICK UP DISPLAY-TYPE BIT
	PUSH P,DDB
	MOVE DDB,AC1		;DTYO WANTS POINTER TO DPY HEADER IN DDB
	HLL DDB,DAT		;PICK UP DISPLAY-TYPE BIT
DPYMS2:	XCTR XRW,[SOSL CHR,JOBTM2] ;COUNT OUT YET?
	XCTR XLB,[ILDB CHR,UUO]	;GET A CHAR
	JUMPLE CHR,DPYNUL	;QUIT ON NULL OR COUNT EXHAUSTED
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,DTYO		;OUTPUT CHR TO P. OF P. 0
	ONSCN			;TURN ON SCANNER CHANNEL
	EXCH DAT,-1(P)
	JUMPE DAT,DPYMS3	;NO OUTPUT TO CURRENT PP IF HOLDING
	XCTR XLB,[LDB CHR,UUO]	;GET CHARACTER AGAIN (DTYO CLOBBERS IT)
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,DTYO		;OUTPUT CHR TO CURRENT P. OF P.
	ONSCN			;TURN ON SCANNER CHANNEL
DPYMS3:	EXCH DAT,-1(P)
	JRST DPYMS2		;LOOP FOR ANOTHER CHR

DPYNUL:	JUMPL CHR,DPYNU2	;ALWAYS QUIT WHEN COUNT DONE
	XCTR XR,[SKIPE JOBTM3]	;NULL BYTE, WHICH UUO?
	JRST DPYMS2		;NULMES, SKIP THE BYTE
DPYNU2:	POP P,DDB		;RESTORE DDB POINTER
	POP P,TAC		;CURRENT PP OR ZERO
	JUMPN TAC,TYPGO2	;UPDATE CURRENT PP DISPLAY IF NECESSARY
	POPJ P,
;REQSPW TTREAD TTRED2 TTRED3 MCREAD

IFN FTSPWT,<
;Routine to send a 177 to a serialized kbd to have it send back two bytes
;indicating what chars are being held down.  Theoretically, we should have
;to use a TOIP-like bit for these lines, but we can avoid that because we
;use another bit which stays on even longer, remaining on until both chars
;have come back from the kbd.  Since the kbd runs at same xmit and rcv baud
;rates, we're in good shape.
REQSPW:	MOVE TAC,DCATAB(LINE)	;Don't talk to kbd that is marked down
	TRNE TAC,DCADWN		;Skip if up
	POPJ P,			;Kbd is down
	MOVSI TAC,SPWREQ	;First, set flag that we're expecting SPW char
	IORM TAC,KBDCHR(LINE)
	MOVEI TAC,400000(LINE)	;Get port number plus 400000 for next routine
	MOVEI CHR,177		;Get SPW REQ char for serialized keyboard
	JRST DCATYP		;Send out the character
>;IFN FTSPWT

;READ MICROSWITCH KEYBOARD USING SPCWAR MODE FEATURE
;CALL:	TTYUUO 16,ADDR
;WHERE ADDR CONTAINS LINE NUMBER YOU WISH TO READ
;IF LINE IS ILLEGAL YOURS IS USED
;IF IT IS NOT ON THE KEYBOARD SCANNER THIS IS A NO-OP
TTREAD:
IFN FTF2,<
	POPJ P,			;NOOP ON F2
>;IFN FTF2
IFE FTF2,<
IFN FTSPWT,<	;New code for serialized microswitch keyboards
	XCTR XR,[SKIPL TAC,(UUO)] ;PICK UP LINE HE WANTS
	CAIL TAC,TTPLEN		;HIGHER THAN HIGHEST?
	LDB TAC,[DDQREQ+LINE,,LSTESC] ;Get responsible TTY
	CAIL TAC,DPYL0		;Make sure it's a microswitch kbd line
	CAIL TAC,DPYL0+DPYNUM+DDNUM
	POPJ P,			;Not a microswitch keyboard
	HRRZ LINE,LINBIT(TAC)	;Get DCA port number
	TRZN LINE,400000	;Skip if really a DCA line
	POPJ P,			;Oh, well.
	LDB AC1,[POINT PUNITS,LINTAB(LINE),35] ;Get line this kbd is mapped to
	SKIPN DDB,TTYTAB(AC1)	;Is it in use?
	JRST TTRED2		;No, forget password chk
	LDB AC1,PSWBPT		;Get password bit
	JUMPE AC1,TTRED2	;If doing password, return bits of inactive state
	MOVE AC1,TIME		;Get some good bits
	ANDI AC1,77		;Just the data bits
	IORI AC1,21700		;Bits for kbd not in use
	JRST TTRED3

TTRED2:	SKIPL KBDCHR(LINE)	;Is there a SPW request pending from this KBD?
	PUSHJ P,REQSPW		;No SPW req in, make one
	LDB AC1,SERDAT		;Get last char seen: SHIFT bit and 6 data bits
	ANDI AC1,177		;Flush the extra bits
	LDB AC2,DCABKY		;Get bucky bits seen last time
	DPB AC2,[POINT 3,AC1,28] ;Here we assemble a keyboard-scanner-like word
	TRC AC1,1700		;Make it compatible with kbd scanner level
	TRNE AC2,SERSPW		;SPW bit on?
	IORI AC1,20000		;Yes, simulate kbd scanner
TTRED3:	LDB AC2,DCALIN		;Get TTY line number
	SUBI AC2,DPYL0		;Make microswitch kbd index
	HRLI AC1,(AC2)		;Combine like kbd scanner used to do
	XCTR XW,[MOVEM AC1,(UUO)] ;STORE RESULT
>;IFN FTSPWT
	POPJ P,
>;IFE FTF2

REPEAT 0,<	;I know it's an old crock, but keep this stupid FTKIM stuff around
		;for awhile longer.  TVR/May81
	XCTR XR,[SKIPL TAC,(UUO)] ;PICK UP LINE HE WANTS
	CAIL TAC,TTPLEN		;HIGHER THAN HIGHEST?
	HRRZ TAC,LINE		;Yes, use own line
	SUBI TAC,DPYL0		;NORMALIZE IT
	JUMPL TAC,CPOPJ
	CAIL TAC,DPYNUM+DDNUM	;*** THIS NEEDS TO CHECK FOR KIM KEYBOARD
	POPJ P,			;Not a microswitch keyboard
	PUSHJ P,TTRED0		;PEEK AT KEYBOARD
	 XCTR XW,[MOVEM AC1,(UUO)] ;STORE RESULT
	POPJ P,

;Routine to peek at keyboard.  Skips on illegal keyboard line given in TAC.
TTRED0:	JUMPL TAC,CPOPJ1	;NO-OP IF NOT ON KBD SCANNER
	CAIL TAC,DPYNUM+DDNUM
	JRST CPOPJ1
	MOVEI AC2,7		; SCAN FOR KIM PARALYZER KBD
KIMCLP:	HLRE AC3,KIMTAB(AC2)	; PICK UP TTY NUMBER-DPYL0 OF THIS KBD
	CAIN AC3,(TAC)		; IS THIS IT? (AC3=-1 FOR NOT CONNECTED)
	JRST KIMTRD		; YES, READ FROM SPECIAL PLACE
	SOJLE AC2,KIMCLP	; LOOP BACK
	POPJ P,			; NOT FOUND, MUST BE ON REGULAR SCANNER. FORGET IT

KIMTRD:	MOVE AC1,KIMTAB(AC2)	; PICK UP DATUM AND NORMALIZED TTY NUMBER
	ORI AC1,1B22		; AND SPW BIT
	POPJ P,			; RETURN IT TO LUSER
>;REPEAT 0 (formerly IFN FTKIM)

IFN FTCCRMA,<
COMMENT ⊗

MCREAD UUO
--------------------------------------------------
        MOVE AC,[LINNUM,,ADR]
        MCREAD AC,
	<error return>
	<success>

;ADR:    <3 word block to receive data>


The MCREAD UUO reads in the entire state of a "new style" microswitch
keyboard.  The state of each key is returned as a single bit in the three
word block specfied in the call.  The LSB of ADR+0 corresponds to the
upper left hand key.  Working up through more signifigant bits through
ADR+0,+1, and +2 corresponds to moving left to right, top to bottom on the
keys.

The routine takes the non-skip return if the line number specified is not
a new-style microswitch keyboard.

⊗

↑MCREAD:HLRZ AC1,TAC			; get line number
	HRRZ TAC,TAC			; flush some bits
	LDB AC1,[DDQREQ+AC1,,LSTESC]	; convert to fetch physical line
	CAIL AC1,DDL0			; Make sure it's a microswitch kbd line
	CAIL AC1,DDL0+DDNUM
	POPJ P,				; Not a microswitch keyboard
	HRRZ LINE,LINBIT(AC1)		; Get DCA port number
	TRZN LINE,400000		; Skip if really a DCA line
	POPJ P,				; Oh, well.
	MOVE AC2,MCWD0-DDL0(AC1)	; Get first 36 bits
	XCTR XW,[MOVEM AC2,0(TAC)]	; Store result in user's place
	MOVE AC2,MCWD1-DDL0(AC1)	; Get next 36 bits
	XCTR XW,[MOVEM AC2,1(TAC)]	; Store them
	MOVE AC2,MCWD2-DDL0(AC1)	; Get last 36 bits
	XCTR XW,[MOVEM AC2,2(TAC)]	; Store them too
	JRST CPOPJ1			; and take skip (success) return
>;IFN FTCCRMA
;TTYJOB TTYJNO TTYJN1 TTYJN0 PTYJNO PTYJN1

;TTYJOB
;CALL:
;	MOVEI AC,<LINE #>
;	TTYJOB AC,
;	<# OF JOB OWNING TTY IN AC>
;IF LINE # IS negative TTY LINE, RETURN JOB CONTROLLING IF PTY
↑TTYJNO:XCTR XR,[MOVE LINE,(UCHN)] ;GET ARG
	JUMPL LINE,PTYJNO
	CAIGE LINE,TTPLEN	;LEGAL TTY LINE #?
	SKIPN DDB,TTYTAB(LINE)	;GET DDB POINTER
	JRST TTYJN1		;NONE
	LDB TAC,PJOBN		;GET JOB NUMBER
	JUMPE TAC,TTYJN0	;JUMP IF TTY NOT IN USE
	MOVE AC1,DEVMOD(DDB)	;CHECK IF CONTROLLING JOB
	TLNN AC1,TTYATC		;JOBS CONSOLE?
	TLO TAC,400000		;NO, SET BIT TO INDICATE JUST OWNED
	CAIA
TTYJN1:	SETZ TAC,		;FLAG NO JOB
TTYJN0:	XCTR XW,[MOVEM TAC,(UCHN)] ;STORE ANSWER
	POPJ P,

PTYJNO:	MOVM LINE,LINE
	CAIGE LINE,TTPLEN
	CAIGE LINE,PTYL0
	JRST .+2
	JRST PTYJN1
	HRRE LINE,JBTLIN(J)	;JOBS TTY
	JUMPL LINE,TTYJN1	;RETURN 0 IF NONE
PTYJN1:	HLL LINE,LINTAB(LINE)	;GET LINE CHARACTERISTICS
	TLNN LINE,PTYLIN	;IS IT A PTY?
	JRST TTYJN1		;NO, NO CONTROLLING JOB
	MOVE TAC,PTYJOB-PTYL0(LINE) ;CONTROLLING JOB
	JRST TTYJN0
;SNEAKX SNEAKS SNLD1 SNLOAD SNEAKY SNEAKW

;TWO UUO'S TO SEE THE NEXT CHAR. YOU WILL INPUT.
;ONE (SNEAKS) WHICH SKIPS IF A CHAR IS WAITING
;THE OTHER (SNEAKW) WAITS FOR A CHAR.
;BOTH RETURN THE CHAR. IN THE AC.

;ENTER AT SNEAKS

SNEAKX:	PUSHJ P,WSCHED		;WAIT ONE TIC
↑SNEAKS:PUSHJ P,TTYFNU		;FIND USERS TTY
	TLNE IOS,TPMON!TTYDTC	;DETACHED?
	POPJ P,			;CAN'T GET ANYTHING IF DETACHED
	MOVE AC2,TITAKR(DDB)
	CAME AC2,TIPUTR(DDB)	;ANYTHING IN TTY BUFFER
	JRST SNLOAD		;YES, RETURN IT
	TLNE LINE,DISLIN!DDDLIN!DMLIN
	SKIPL AC1,LETAB(LINE)
	POPJ P,			;NOT DISPLAY, OR NOT ACTIVE
	TLNE AC1,WTFLAG		;IF TRANSFER IN PROGRESS, LOSE
	JRST SNEAKX		; BUT TRY AGAIN
	SKIPG FCPOS(AC1)	;NON-ZERO CHAR COUNT?
	POPJ P,			;NO
	MOVE AC2,[POINT 7,LEBUF]
	ADDI AC2,(AC1)		;POINT TO BEGINNING OF USER EDITOR BUFFER
	ILDB TAC,AC2
	JUMPE TAC,.-1		;LOOP FOR CHAR.
SNLD1:	XCTR XW,[MOVEM TAC,(UCHN)] ;STORE RESULT
	JRST CPOPJ1		;RETURN

SNLOAD:	MOVE TAC,TITCTR(DDB)
	CAIG TAC,1
	HRR AC2,TTIBUF+BUF(DDB)	;WRAP AROUND BUFFER
	ILDB TAC,AC2
	JRST SNLD1

;SNEAK WAIT - ENTER AT SNEAKW

SNEAKY:	MOVE IOS,[TTYIOW!SNKWAT,,IOACT]
	IORM IOS,DEVIOS(DDB)
	MOVSI IOS,DDTM
	ANDCAB IOS,DEVIOS(DDB)
	PUSHJ P,TWSYNC		;WAIT FOR CHAR.
	PUSHJ P,STXTM3		;CLEAR INTERACTION RUN TIME
↑SNEAKW:PUSHJ P,SNEAKS
	 JRST SNEAKY		;WAIT FOR TYPEIN AND TRY AGAIN
	POPJ P,			;SUCCESS
;ACTCHR

;WAITS FOR ACTIVATION AND RETURNS THE CHAR WHICH ACTIVATED IT BUT
;ONLY ON RE-EDITED LINES

↑ACTCHR:PUSHJ P,TTYFNU		;FIND USER'S TTY
	CAME LINE,[-1]		;DETACHED?
	TLNN LINE,DDDLIN!DISLIN!DMLIN ;ONLY DPY'S HAVE ACT. CHAR.
	JRST RTZERO		;RETURN 0 (UUO NOT CLOBBERED YET)
	MOVEI UUO,0		;RPH & FW'S FAULT (NO STORE IN IWAIT)
	PUSHJ P,IWAIT		;WAIT FOR A LINE
	MOVE CHR,LETAB(LINE)
	LDB CHR,[POINT 9,GWORD(CHR),35]
	XCTR XW,[MOVEM CHR,(UCHN)]
	POPJ P,
;DDTIN DDTINA DDTINB DDTIW XFRIN XFRIN1 XFRIN2 UNSUPR XFRIN0 DDTCNC
IFN FTDDTM,<
;CALL AC,[SIXBIT /DDTIN/]	AC CONTAINS POINTER TO BUFFER AREA
;BUFFER AREA MUST BE 21 WORDS LONG

↑DDTIN:	PUSHJ P,TTYFNU		; SET UP DDB,LINE
DDTINA:	MOVE IOS,[TTYIOW+DDTM,,IOACT]
	IORB IOS,DEVIOS(DDB)	;PUT INTO I/O WAIT
	TLNN IOS,TPMON		;NOTHING THERE IF TTY IS IN MONITOR MODE.
	JRST DDTINB
	PUSHJ P,TWSYNC		;WAIT FOR SOMETHING
	JRST DDTINA

DDTINB:
IFN FTMONCIP,<
	PUSHJ P,MCMSKP		;SKIP ANY MONITOR COMMAND LEFT OVER IN BUFFER
>;IFN FTMONCIP
	MOVEI TAC,-1		;ASK INCHGB FOR LOTS OF CHARS FROM LINE ED
	TLNE LINE,DDDLIN!DISLIN!DMLIN
	PUSHJ P,INCHGB		;ACTIVATE LINE EDITOR, THEN WAIT ONE TIC IF NECESSARY.
	PUSHJ P,PTICHK		;CHECK FOR PTY LINKAGE.
	MOVE TAC,TIPUTR(DDB)
	CAMN TAC,TITAKR(DDB)	;ANYTHING IN BUFFER?
	PUSHJ P,TWSYNC		;NO, WAIT FOR SOME
DDTIW:	MOVE IOS,[TTYIOW+DDTM,,IOACT]
	ANDCAB IOS,DEVIOS(DDB)
	MOVSI TAC,IOFST
	IORM TAC,DEVIOS(DDB)	;STOP ALL IO
	MOVSI AC2,440700
	XCTR XR,[HRR AC2,(UUO)]	;GET CONTENTS OF USER AC = RELATIVE ADDR
	MOVE LINE,TIPUTR(DDB)
	MOVEI DAT,TTIBUF(DDB)
	MOVEI AC1,<21*5>-1	;NUMBER OF CHARACTERS ALLOWED
XFRIN:	PUSHJ P,GETCHY		;TRANSFER INTO USER'S AREA
XFRIN1:	CAIN CHR,600		;PRESTORED CONTROL C?
	JRST XFRIN0		;YES, GO INTO MONITOR MODE
	XCTR XDB,[IDPB CHR,AC2]
	CAME LINE,TITAKR(DDB)	;PICKED UP ALL CHARACTERS YET?
	SOJG AC1,XFRIN		;LOOP TILL DONE
XFRIN2:	MOVEI CHR,0		;TERMINATE STRING
	XCTR XDB,[IDPB CHR,AC2]
UNSUPR:	MOVEI IOS,IOSUPR	;MAKE SURE IO NO LONGER SUPR.
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

XFRIN0:	MOVE CHR,DEVMOD(DDB)	;GET SOME GOOD BITS
	TLNN CHR,TTYATC
	TRNN CHR,ASSCON!ASSPRG	;THESE GUYS CAN'T TYPE COMMANDS
	JRST DDTCNC
	JRST XFRIN

DDTCNC:	PUSHJ P,STLNAC		;GET LINE CHARACTERISTICS
	PUSHJ P,XFRIN2
	JRST MONUS6		;GO PROCESS ↑C
>;FTDDTM
;DDTOUT DDTWAT OUTSTR DDT3

IFN FTDDTM,<

;OUTPUT FROM DDT
;CALL AC,[SIXBIT /DDTOUT/]	;AC HAS POINTER TO DDT OUTPUT BUFFER

↑DDTOUT:PUSHJ P,TTYFNU
	XCTR XR,[MOVE UUO,(UUO)] ;UUO←CONTENTS OF USER'S AC=BUFFER ADDR.

>;IFN FTDDTM

OUTSTR:	HRLI UUO,440700
DDT3:	MOVE IOS,DEVIOS(DDB)	;GET IOS
	TDNE IOS,[TTYDTC,,IOSUPR] ;DID SOMETHING HAPPEN?
	POPJ P,			;YES, FLUSH THE REST!
	XCTR XLB,[ILDB CHR,UUO]
	JUMPE CHR,TYPGO		;DONE, START OUTPUT
	PUSHJ P,OUTCHR		;PLACE CHAR IN OUTPUT BUFFER
	JUMPN CHR,DDT3		;LOOP IF CHARACTER WAS PLACED
	ADD UUO,[070000,,0]	;BACK UP POINTER
	MOVE IOS,[IOW,,IOACT]	;SET DEVICE ACTIVE (TTY), waiting for output
	IORB IOS,DEVIOS(DDB)	;(TTYIOW is presumably off)
	PUSHJ P,TYPGO		;start output
	PUSHJ P,DDTWAT		;Wait for output, skip if DDB goes away
	 JRST DDT3
	POPJ P,			;Probably detached now

;Wait for tty output buffer to empty.
;Takes SKIP RETURN if DDB ptr not valid on wakeup; DIRECT RETURN if all normal!
↑DDTWAT:MOVE TAC,DEVIOS(DDB)	;GET IOS
	TLNE TAC,TTYDTC		;If detached TTY DDB,
	JRST CPOPJ1		; then take error return immediately
	LDB TAC,PUNIT		;get line number
	PUSH P,TAC		;save it for after wakeup
	MOVEI TAC,TTOCHR	;SPECIFY TO WAIT TILL BUFFER IS EMPTY
	DPB TAC,PFITCH		;IF DDT TYPE-OUT IS TOO LONG
	MOVSI TAC,TTYIOW
	ANDCAM TAC,DEVIOS(DDB)	;MAKE US LOOK LIKE WE'RE IN OUTPUT WAIT
;;	MOVEI IOS,IOACT		;WAIT UNTIL MONITOR BUFFER EMPTY
;;	IORB IOS,DEVIOS(DDB)
	TLNE IOS,IOW		;skip if output happened already
	PUSHJ P,WSYNC		;Wait until ready
	MOVE IOS,[IOW,,IOACT]	;not waiting for output now
	ANDCAB IOS,DEVIOS(DDB)	;make sure these bits are clear now
	POP P,TAC		;Get back line number
	HRRZ TAC,TTYTAB(TAC)	;Get line's current DDB (if any)
	CAIE TAC,(DDB)		;Skip if same DDB as before
	AOS (P)			;Skip return means DDB ptr is no longer valid
	POPJ P,
;SCNDSP TTYIN TTYIN2 TTYIN3 TTYIN1 TTYSKP TTCKUU TWSYNC TWSYN2 TWSYN1 TWSAVE

;DEVICE DEPENDENT PART OF IO UUOS.

;DISPATCH TABLE

	JRST TTYICK		;IOS CHANGING, CHECK FOR IMAGE MODE
	POPJ P,
	POPJ P,
	JRST TTYINI		;INITIALIZATION
	JRST CPOPJ1		;HUNG TIMEOUT - DO NOTHING.
↑SCNDSP:JRST TTYREL		;RELEASE
	JRST OUT		;CLOSE
	JRST TTYOUT		;OUTPUT
TTYIN:	MOVE IOS,[TTYIOW,,IOACT] ;INPUT UUO - INDICATE INPUT WAIT
	IORB IOS,DEVIOS(DDB)
	TLNE IOS,TTYDTC
	JRST TTYIN2		;TTY IS DETACHED.  WAIT FOR INPUT
	MOVSI TAC,TTYATC
	TDNE TAC,DEVMOD(DDB)	;SKIP IF TTY CONTROLLING A JOB
	TLNN IOS,TPMON		;TTY ATTACHED TO JOB. SKIP IF MONITOR MODE
	JRST TTYIN3
TTYIN2:	PUSHJ P,TWSYNC
	JRST TTYIN

TTYIN3:
IFN FTMONCIP,<
	PUSHJ P,MCMSKP		;SKIP ANY MONITOR COMMAND LEFT OVER IN BUFFER
>;IFN FTMONCIP
	PUSHJ P,PTICHK		;CHECK PTY WAITERS.
	MOVSI IOS,DDTM+TPMON
	ANDCAB IOS,DEVIOS(DDB)
	PUSHJ P,STLNAC		;GET LINE CHARACTERISTICS
TTYIN1:	PUSHJ P,TWSAVE		;SAVE TTY WAIT BITS
	SKIPG TISYNC(DDB)	;SKIP IF THERE'S INPUT READY
	PUSHJ P,TWSYN2		;WAIT FOR INPUT
	PUSHJ P,MONUSR		;MOVE DATA FROM TTY BUFFER TO USER
	MOVE IOS,[TTYIOW!DDTM,,IOSUPR!MERTPO!MERTP1!IOACT]
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

;TTYSKP, SKIPS IF NEXT INPUT ON CHN WON'T HANG (MUST BE TTY)
;CALL:	CALL CHAN,['TTYSKP']
;	<DEVICE ON CHANNEL ISN'T A TTY OR HASN'T ANY INPUT>
;	<NEXT INPUT WON'T HANG>

↑TTYSKP:CAMG UCHN,USRHCU	;SKIP IF CHANNEL SPECIFIED IS OUT OF RANGE
	SKIPN DDB,USRJDA(UCHN)	;IN RANGE.  SKIP IF THERE'S A DDB
	JRST IOIERR		;IO TO UNASSIGNED CHANNEL
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVTTY		;IS IT A TTY?
	POPJ P,			;NO, GIVE HANG RETURN
	PUSHJ P,TTCKUU		;FIRST SEE IF UUOCON WILL EVEN CALL TTYSER
	 JRST CPOPJ1		;NO, THERE IS ALREADY A BUFFER WAITING FOR USER
	TLNN IOS,TTYDTC		;IF DETACHED, IT WILL HANG.
	SKIPG TISYNC(DDB)	;SKIP IF THERE'S SOMETING IN THE BUFFER
	POPJ P,			;WILL HANG
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,TTYATC		;IF NOT USER CONSOLE,
	TLNN IOS,TPMON		;OR NOT IN MONITOR MODE
	AOS (P)			;WON'T HANG
	POPJ P,

;Routine to skip if INPUT UUO for TTY in DDB will have to call device input routine.
;Sets up IOS.  (This code mostly copied from UUOCON INPUT UUO code at IN1.)
TTCKUU:	HRR JBUF,DEVBUF(DDB)		;GET ADDRESS OF BUFFER HEADER
	MOVSI TAC,IOUSE			;BUFFER IN USE BIT
	MOVE IOS,@DEVSPT(DDB)
;BUFFER HEADER (JBUF) WILL BE 0 IF VIRGIN, OR NEGATIVE IF INBUF WAS DONE.
	XCTR XR,[HRRZ TAC1,(JBUF)]	;GET ADDRESS OF CURRENT BUFFER, IF ANY
	JUMPE TAC1,CPOPJ1		;No user buffer ever has been filled yet
	XCTR XR,[TDNN TAC,(TAC1)]	;SKIP IF BUFFER HAD BEEN BUSY.
	JRST CPOPJ1			;MUST BE VIRGIN BUFFER.
	XCTR XRW,[HRRZ TAC,(TAC1)]	;GET POINTER TO NEXT BUFFER
	CAIE TAC,(TAC1)			;If only one buffer, must call dev routine
	XCTR XR,[SKIPL (TAC)]		;SKIP IF THE USE BIT IS SET
	AOS (P)				;Will call device routine for more data
	POPJ P,

;TWSYNC IS CALLED FOR INPUT IO WAIT

TWSYNC:	PUSHJ P,TWSAVE		;REMEMBER MODE OF WAITING
TWSYN2:	TLNN LINE,PTYLIN	;IS IT A PTY?
	JRST TWSYN1		;NO, JUST GO INTO WAIT
	PUSH P,J
	MOVE J,PTYJOB-PTYL0(LINE)
	MOVSI AC1,INTPTI
	TDNE AC1,JBTIEN(J)
	PUSHJ P,TTINT
	POP P,J
	MOVE CHR,DEVIOS(DDB)
	TLNE CHR,TTYIOW		;DON'T WAIT IF SOMETHING TYPED AT I-LEVEL
TWSYN1:	PUSHJ P,WSYNC		;WAIT FOR INPUT
	MOVE IOS,[TTYIOW+DDTM,,IOACT]
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

TWSAVE:	MOVSI AC1,DDTM!SNKWAT
	ANDCAM AC1,TTYBTS(DDB)
	AND AC1,IOS
	IORM AC1,TTYBTS(DDB)	;REMEMBER MODE OF WAITING, DESPITE MONITOR MODE
	POPJ P,
;MONUS8 MONUSR MONUS1 MONUS9 MONUS2 MONUS3 MONUS5 MONUS6 MONUS7
;ROUTINE TO MOVE A LINE OR STRING FROM TTY INPUT BUFFER TO USER'S INPUT BUFFER
;CALLED ONLY FROM UUO LEVEL,FROM INPUT UUO ONLY

MONUS8:	TLNE IOS,IOEND		;ROOM FOR ANOTHER BUFFER. ↑Z SEEN?
	POPJ P,			;↑Z SEEN.
MONUSR:	HRRZ TAC,DEVIAD(DDB)	;ADDRESS OF BUFFER IN USER AREA
	PUSHJ P,BUFCLR		;CLEAR BUFFER. (MAY CALL UADRER)
	PUSHJ P,STLNAC		;SETUP LINE
	HRRZ AC1,DEVIAD(DDB)	;BH 1/8/78 ADDRESS OF 2ND BUFFER WORD
	XCTR XLB,[LDB AC2,[POINT 17,(AC1),17]] ;BH Get buffer wd count plus one!
	SUBI AC2,1		;Make it number of data words in buffer
	ADDI AC1,1		;BH 1/5/78 MAKE ADDR HALF OF BPT
	HRR TAC,DEVBUF(DDB)	;BH GET INPUT BUFFER HEADER
	XCTR XR,[MOVE TAC,1(TAC)] ;BH GET USER BYTE POINTER
	LDB CHR,[POINT 6,TAC,11] ;BH CHR IS USER BYTE SIZE
	DPB CHR,[POINT 6,AC1,11] ;BH WE USE THE SAME SIZE AS THE USER DID
	PUSH P,TAC+1		;BH STUPID DIVIDE INSTRUCTION
	PUSH P,TAC		;BH
	MOVEI TAC,44		;BH BITS/WORD
	IDIVI TAC,(CHR)		;BH BYTES/WORD
	IMULI AC2,(TAC)		;BH AC2 IS NUMBER OF BYTES IN THIS BUFFER
	POP P,TAC		;BH
	POP P,TAC+1		;BH
	MOVEI DAT,TTIBUF(DDB)	;SPECIFY USER MODE INPUT BUFFER
MONUS1:	PUSHJ P,GETCHY		;GET A CHAR. FROM IT
	LDB TAC,[POINT 7,CHR,35] ;NO CTRL BITS
	MOVE TAC,SPCTAB(TAC)	;GET GOOD BITS
	JUMPE CHR,MONUS3	;ZERO IMPLIES EMPTY BUFFER
	CAIE CHR,612		;END OF FILE? CONTROL-META-LF (OR ↑Z)
	JRST MONUS9		;NOT EOF.
	MOVSI IOS,IOEND		;SIGNIFY EOF.
	IORB IOS,DEVIOS(DDB)
	JRST MONUS3

MONUS9:	XCTR XDB,[IDPB CHR,AC1]	;PLACE CHAR. IN USER BUFFER
	TLNN TAC,FCSBRK!BREAKB	;IS IT A SYNC CHAR. ?
MONUS2:	SOJG AC2,MONUS1		;NO, USER BUFFER FULL?
	CAIE CHR,600		;STORED CONTROL C?
	JRST MONUS3		;NO.
	MOVE TAC,DEVMOD(DDB)	;HANDLE ↑C. 
	TLNN TAC,TTYATC		;SKIP IF THIS TTY CONTROLS A JOB
	TRNN TAC,ASSCON!ASSPRG	;TTYS USED AS IO DEVICE CAN'T ↑C
	JRST MONUS7		;THIS IS REAL ↑C
MONUS3:	HRRZ TAC,DEVIAD(DDB)	;BREAK CHAR OR COUNTED OUT, INPUT UUO DONE
	SUBI AC1,1(TAC)		;CALCULATE NUMBER OF WORDS
	XCTR XRW,[HRRM AC1,1(TAC)] ;STORE IN COUNT WORD OF BUFFER.
	PUSHJ P,ADVBFF		;INPUT UUO DONE,NEXT BUFFER FULL?
	JRST MONUS5		;YES, INPUT REALLY IS DONE
	TRNN CHR,1000		;BH Skip JUMPG in image mode.  see below.
	JUMPG AC2,MONUS5	;IF WE GAVE HIM A WHOLE LINE THEN WE ARE DONE.
;BH 1/12/78 The above instruction, which I commented out in 8.69/V, turns out
;to be necssary because FORTRAN seems to depend on only getting one line of text
;per INPUT UUO.  Someone should fix FORTRAN someday and flush the JUMPG.
	SKIPLE TISYNC(DDB)	;NO, DO WE HAVE MORE LINES FOR IT?
	JRST MONUS8		;YES, GIVE USER NEXT LINE, TOO
MONUS5:	MOVSI IOS,IOFST
	IORB IOS,DEVIOS(DDB)
	TLZE IOS,TTYIOW		;TTY IN INPUT WAIT?
	PUSHJ P,SETIOD		;YES, TAKE IT OUT OF IT
	POPJ P,

MONUS6:	PUSHJ P,CNCMOD		;CONTROL C MODE
	MOVSI TAC,110000	;DECREMENT TAKR POINTER
	ADDM TAC,TITAKR(DDB)	;SO NEXT ILDB WILL GET ↑C
	AOS TITCTR(DDB)		;ADJUST COUNTER
	SOS TIFCTR(DDB)		;ADJUST FREE CHAR. COUNT
	PUSHJ P,SYNCHK		;FIX UP ACTIVATED COUNT
	PUSHJ P,COMSET		;WAKE UP COMMAND DECODER
	JRST WSYNC		;AND WAIT FOR INTERPRETATION

MONUS7:	MOVE IOS,[TTYIOW,,IOACT] ;THIS IS A ↑C
	IORB IOS,DEVIOS(DDB)	;PUT JOB BACK IN IOWAIT
	PUSHJ P,TWSAVE		;SAVE TTY WAIT BITS IN TTYBTS(DDB)
	PUSHJ P,MONUS6
	JRST TTYIN		;RESTART INPUT UUO
;TTYOUT - OUTPUT UUO

TTYOUT:	MOVSI IOS,IOBEG
	TDNE IOS,DEVIOS(DDB)
	TRO IOS,IOSUPR		;KILL ↑O ON FIRST OUTPUT
	IOR IOS,[DDTM,,MERTPO!MERTP1!IOACT]
	ANDCAM IOS,DEVIOS(DDB)
	MOVSI IOS,IO+IOFST
	IORB IOS,DEVIOS(DDB)
	TLNN IOS,TTYDTC
	PUSHJ P,STLNAC		;GET LINE CHARACTERISTICS
	PUSH P,LINE		;SAVE INFO
	TDNN IOS,[TTYDTC,,IOSUPR] ;SKIP IF ↑O OR DETACHED
	PUSHJ P,USRMON		;NO, MOVE USER'S BUFFER TO TTO BUFFER
	PUSHJ P,ADVBFE		;ADVANCE USER'S HEADERS
	SKIPA
	TDZA IOS,IOS		;MORE BUFFERS. DON'T CLEAR IOACT.
	MOVEI IOS,IOACT		;NO MORE BUFFERS
	ANDCAB IOS,DEVIOS(DDB)	;CLEAR ACTIVE IN IOS
	POP P,LINE		;RESTORE LINE INFO
	PUSHJ P,TYPGO		;START OUTPUT, IF NECESSARY.
	TRNE IOS,IOACT		;ARE WE DONE ?
	JRST TTYOUT		;NO.  DO SOME MORE. 
	POPJ P,
;USRMON USRMN1 USRMN2 USRMN4 USRMN5 USRMN3 TTOUWS

;MOVE USER OUTPUT BUFFER TO MONITOR BUUFER IN TTY DDB
;CALLED ONLY AT UUO LEVEL,BY OUTPUT UUO

USRMON:	HRRZ AC2,DEVOAD(DDB)	;ADDRESS OF 2ND BUFFER WORD
	XCTR XR,[HRRZ AC2,1(AC2)] ;NUMBER OF WORDS TO OUTPUT
	HRRZ AC1,DEVOAD(DDB)	;ADDRESS OF BUFFER
	ADDI AC1,1		;BH 1/5/78 MAKE ADDR HALF OF BPT
	HLR TAC,DEVBUF(DDB)	;BH GET OUTPUT BUFFER HEADER
	XCTR XR,[MOVE TAC,1(TAC)] ;BH GET USER BYTE POINTER
	LDB CHR,[POINT 6,TAC,11] ;BH CHR IS USER BYTE SIZE
	JUMPE CHR,ADRERR	;ME - BYTE SIZE CAN'T BE ZERO!!
	DPB CHR,[POINT 6,AC1,11] ;BH WE USE THE SAME SIZE AS THE USER DID
	PUSH P,TAC+1		;BH STUPID DIVIDE INSTRUCTION
	PUSH P,TAC		;BH
	MOVEI TAC,44		;BH BITS/WORD
	IDIVI TAC,(CHR)		;BH BYTES/WORD
	IMULI AC2,(TAC)		;BH AC2 IS NUMBER OF BYTES IN THIS BUFFER
	POP P,TAC		;BH
	MOVE IOS,DEVIOS(DDB)	;BH
	TRNE IOS,IOWC		;BH DOES USER WANT US TO USE THE WD COUNT?
	JRST USRMN1		;BH YES, DON'T BELIEVE THE BYTE POINTER
	LDB TAC,[POINT 6,TAC,5]	;BH TAC IS BYTE POSITION FIELD
	IDIVI TAC,(CHR)		;BH TAC IS NOW THE NUMBER OF UNUSED BYTES
	SUBI AC2,(TAC)		;BH MAKE AC2 THE EXACT RIGHT NUMBER
USRMN1:	POP P,TAC+1		;BH
	JUMPE AC2,USRMN6	;BH 11/7/78 OUTPUT OF ZERO BYTES DOES NOTHING
USRMN2:	XCTR XLB,[ILDB CHR,AC1]	;PICK UP CHARACTER
USRMN4:	TLNE AC1,7000		;BH 1/8/78 BYTE SIZE 9 OR MORE?
	TLNN AC1,6700
	JRST .+2		;NO
	TRO CHR,400		;BH YES, SET IMAGE BIT (NO PARITY ADDED)
	PUSHJ P,OUTCHR		;PLACE IN OUTPUT BUFFER
	JUMPE CHR,USRMN3	;IF NO MORE ROOM IN MON. BUFFER
USRMN5:	SOJG AC2,USRMN2		;LOOP AS LONG AS THERE ARE CHAR'S.
USRMN6:	DPB AC2,PFITCH		;NO CHARACTERS TO FIT
	POPJ P,			;DONE

USRMN3:	PUSH P,AC2		;HERE WE RAN OUT OF ROOM IN DDB.
	CAILE AC2,777		;GREATER THAN MAX? (9 BIT FIELD)
	MOVEI AC2,777		;YES, USE MAX
	DPB AC2,PFITCH		;NUMBER OF CHARACTERS TO GO
	PUSH P,AC1		;SAVE RELOCATABLE POINTER
	MOVE LINE,-3(P)		;GET SAVED LINE CHAR WORD
	PUSHJ P,TTOUWS		;WAIT FOR IO
	POP P,AC1		;RESTORE POINTER
	POP P,AC2		;GET BACK CHR COUNT
	MOVE IOS,DEVIOS(DDB)	;RESTORE IOS
	XCTR XLB,[LDB CHR,AC1]	;GET LAST CHARACTER
	TRNN IOS,IOSUPR		;USER TYPED ↑O?
	JRST USRMN4		;RETURN TO OUT LOOP
	POPJ P,			;YES, CONSIDER BUFFER MOVED

TTOUWS:	MOVE IOS,[IOW,,IOACT]	;SET DEVICE ACTIVE (TTY), waiting for output
	IORB IOS,DEVIOS(DDB)	;(TTYIOW is presumably off)
	PUSHJ P,TYPGO		;START TYPING IF NEEDED
	TLNE IOS,IOW		;did output all get done?
	JRST WSYNC		;no, WAIT TILL ROOM IN BUFFER
	TRNE IOS,IOACT		;this should be off too by now
	PUSHJ P,BUGTRP		;IOW clear but not IOACT
	POPJ P,			;yes, keep going
;KIMINT KIMNOP KIMDKB KIMDSM
IFN FTKIM,<
; KIMINT - KIM PARALYSER INTERRUPT SERVICE
; WE GET BACK A 24-BIT DATUM FROM THE KIM THAT LOOKS LIKE THIS:
; (N.B. - THIS IS SETTABLE BY CHANGING THE KIM PROGRAM)

; BIT 12 - DATA MISSED BIT		; 40,,0
; BITS 13-19 - OPCODE, 0 OR 1		; 37,,600000
;	    0 = STROBED (INTERRUPT DRIVEN) DATA,
;	    1 = SCANNED (SPW) DATA
; BITS 20-22 - TTY NUMBER, 0 TO 7	; 160000
; BIT 23 - STROBE	; 10000
; BIT 24 - 0		; 4000
; BIT 25 - 1		; 2000
; BIT 26 - META		; 1000
; BIT 27 - CONTROL	; 400
; BIT 28 - TOP		; 200
; BIT 29 - SHIFT	; 100
; BIT 30 - B6		; 40
; BIT 31 - B5		; 20
; BIT 32 - B4		; 10
; BIT 33 - B3		; 4
; BIT 34 - B2		; 2
; BIT 35 - B1		; 1

DMBIT←←40

↑KIMINT:MOVEM TAC,KIMSVA
	MOVEM TAC1,KIMSV1
	CONSZ KIM,KMISSED
	AOS KIMNHM			; NOTE ANOTHER DATA MISSED
	CONO KIM,KENA!KCLEAR!KIMCHN
	DATAI KIM,TAC
	TLZE TAC,DMBIT
	AOS KIMNSM			; NOTE ONE MORE SOFTWARE DATA MISSED
	LDB TAC1,[POINT 7,TAC,19]	; PICK UP OPCODE FROM KIM
	JUMPE TAC1,KIMDKB		; IS REAL STROBBED CHARACTER
	CAIE TAC1,1			; OPCODE=1 MEANS SPW (SCANNED) DATA
	JRST KIMNOP			; OTHER OPCODES UNDEFINED (ERROR?)
	LDB TAC1,[POINT 3,TAC,22]	; PICK UP KBD NUMBER
	HRRM TAC,KIMTAB(TAC1)		; PUT DATA BYTE IN RH
KIMNOP:	MOVE TAC1,KIMSV1		; RESTORE TAC1
	JRST KIMDSM			; RESTORE TAC, RE-ENABLE CHANNEL

KIMDKB:	LDB TAC1,[POINT 3,TAC,22]	; PICK UP KBD NUMBER
	HRRM TAC,KIMTAB(TAC1)		; PUT DATA BYTE IN RH
	HLL TAC,KIMTAB(TAC1)		; PICK UP TTY LINE NUMBER
	MOVE TAC1,KIMSV1		; RESTORE TAC1
	JUMPL TAC,KIMDSM		; IF TTY IS UNUSED, FORGET IT
	ANDCMI TAC,600000		; CLEAR SPW AND UNUSED BIT
	MOVEM TAC,DKBCHR		; PUT IT HERE JUST LIKE A SCANNER CHR
	MOVE TAC,KIMSVA			; RESTORE TAC ALSO
	JRST DKBBEG			; JOIN WITH DKBINT AT AC SAVE TIME

KIMDSM:	MOVE TAC,KIMSVA
IFN FTXADR,<
	XJEN KIMCHL			; DISMIS INTERRUPT
>;IFN FTXADR
IFE FTXADR,<
	JEN @KIMCHL			; DISMIS INTERRUPT
>;IFE FTXADR
>;IFN FTKIM
;DKBINT DKBBEG DKBCLK TKKBRT DKBSPC DKBSP2 DKBLUZ DKBBYT
;MICROSWITCH KEYBOARD SCANNER INTERRUPT SERVICE.

IFE FTF2,<	;Whole page
REPEAT 0,<; Code for parallel kbd scanner, RIP.
↑DKBINT:MOVEM CHR,DKBCHR	;SAVE ONE AC WHILE WE THINK ABOUT THIS CHAR
	DATAI DKB,CHR
	TRNE CHR,1B23		;INVALID?
	TRNE CHR,1B22		;SPW?
	JRST DKBLUZ		;IGNORE
	EXCH CHR,DKBCHR		;STORE CHARACTER WHERE WE'LL SEE IT LATER
>;REPEAT 0
IFN FTKIM,<	;Damn thing ain't dead yet.  I hope i don't have to use this,
		;but for now...  -- TVR/May81
DKBBEG:	JSR SCNSAV		;KIM ENTERS HERE WITH CHR IN DKBCHR
IFN FTHG,<
	PUSHJ P,HG		;IN LOWCOR
>;IFN FTHG
DKBCLK:	MOVE CHR,DKBCHR		;GET BACK CHAR -- CLKRPT (LINED) ENTERS HERE
	HLRZ LINE,CHR
	CAIL LINE,DPYNUM+DDNUM
	POPJ P,			;IMPOSSIBLE LINE NUMBER
	ADDI LINE,DPYL0		;OFFSET TO ORIGIN OF DPYS AND DDS
	ANDI CHR,1777		;MASK UNWANTED BITS
	TRC CHR,1700		;MAKE SENSE OF THESE BITS RIGHT
>;IFN FTKIM
TKKBRT:	MOVEI AC2,(CHR)		
	LDB TAC,[POINT 2,CHR,29] ;TOP-SHIFT
	LDB UCHN,[POINT 2,CHR,27] ;META-CTRL
	ANDI CHR,77		;JUST THESE FOR INDEX
	SKIPN DSER,DKBTBL(CHR)	;IS THIS A SPECIAL CHAR?
	JRST DKBSP2		;SPECIAL OR UNDEFINED CHAR
	LDB DAT,DKBBYT(TAC)
	ANDCMI TAC,1		;TOP ONLY
	LDB DSER,DKBBYT(TAC)	;UNSHIFTED CHAR.
	MOVEI CHR,(DAT)		;GET BACK SAVED CHAR.
	CAIE CHR,600		;EXCEPT FOR ↑C
	DPB UCHN,[POINT 2,CHR,28] ;GET BACK CONTROL BITS
	TRZA DSER,600		;NO CONTROL BITS HERE
DKBSPC:	TRO CHR,10000		;MAKE IT SPECIAL
	HRROM LINE,PHYLIN	;Save physical line number for LINED
	JRST RECINC

;SEE WHETHER WE HAVE A SPECIAL CHAR OR AN UNDEFINED ONE -- HERE WITH DSER ZEROED
DKBSP2:	CAIE CHR,41		;BREAK?
	CAIN CHR,44		;CLEAR?
	JRST DKBSPC		;YES
	CAIN CHR,42		;ESCAPE?
	JRST DKBSPC		;YES
	POPJ P,

DKBLUZ:	EXCH CHR,DKBCHR		;RESTORE CHR, LEAVE CHARACTER WHERE WE CAN SEE IT
NOKL10,<DATAO PI,DKBCHR >	;DISPLAY LOSING LINE NUMBER (AND CHAR) IN LITES
IFN FTXADR,<
	XJEN CH5		;DISMISS INTERRUPT
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH5		;DISMISS INTERRUPT
>;IFE FTXADR

DKBBYT:	POINT 9,DSER,8
	POINT 9,DSER,17
	POINT 9,DSER,26
	POINT 9,DSER,35

>;IFE FTF2
;DKBTBL

IFE FTF2,<	;Whole page

DEFINE DKBCH(A,B)<
BYTE(9)<"A">+40,<"A">,<"B">,<"B">
>


;FORMAT IS:  BYTE(9)CHAR	SHIFT CHAR	TOP CHAR	TOP SHIFT CHAR

DKBTBL:	0
	DKBCH A,≤
	DKBCH B,π
	DKBCH C,ε
	BYTE(9) "d","D",74,74
	BYTE(9) "e","E",100,100
	BYTE(9) "f","F",76,76
	DKBCH G,≠
	DKBCH H,=
	DKBCH I,'
	BYTE(9) "j","J",137,137
	DKBCH K,<→>
	DKBCH L,<↔>
	DKBCH M,∃
	DKBCH N,∀
	BYTE(9) "o","O",173,173
	BYTE(9) "p","P",176,176
	DKBCH Q,∧
	DKBCH R,#
	DKBCH S,≥
	DKBCH T,&
	BYTE(9) "u","U",140,140
	DKBCH V,λ
	DKBCH W,∨
	DKBCH X,β
	BYTE(9) <"y">,<"Y">,42,42
	DKBCH Z,α

DEFINE DKBCH(A,B)<
BYTE(9)<"A">,<"A">,<"B">,<"B">
>

	BYTE(9) 15,15,15,15
	DKBCH <\>,∞
	BYTE(9) 12,12,12,12
	0					;36
	0					;37 PROG SEL
	BYTE(9) 40,40,40,40			;40
	0					;41 BREAK
	0					;42 ESC
	BYTE(9) 600,600,600,600			;43 ↑C
	0					;44 CLEAR
	BYTE(9) 11,11,11,11
	BYTE(9) 14,14,14,14
	BYTE(9) 13,13,13,13
	DKBCH <(>,[
	DKBCH <)>,<]>
	DKBCH *,⊗
	DKBCH +,|
	DKBCH <,>,!
	DKBCH -,¬
	DKBCH .,?
	DKBCH /,∂
	DKBCH 0,0
	DKBCH 1,≡
	DKBCH 2,∩
	DKBCH 3,∪
	DKBCH 4,⊂
	DKBCH 5,⊃
	DKBCH 6,$
	DKBCH 7,%
	BYTE(9) <"8">,<"8">,32,32
	BYTE(9) <"9">,<"9">,30,30
	DKBCH :,↓
	DKBCH <;>,↑
	BYTE(9) 177,177,177,177
	BYTE(9) 175,175,175,175
	0
	0

>;IFE FTF2
;SCNINT SCNIN2 SCNIN1 CTYINT CTYOU1 DTXMT1 DTRCV1

NOKL10,<
↑CTYINT:JSR SCNSAV		;CTY INTERRUPT SERVICE.  SAVE ACS
	MOVEI LINE,TCONLN	;LOAD LINE WITH PROPER
	CONSO CTY,40		;TTI FLAG?
	JRST CTYOU1		;NO.
IFN FTHG,<
	PUSHJ P,HG		;IN LOWCOR, clobbers TAC, collects system stats
>;IFN FTHG
	DATAI CTY,CHR
	JRST RECINT		;RECEIVER INTERRUPT HANDLER

CTYOU1:	CONO CTY,200+SCNCHN	; CLEAR TTO FLAG
	JRST XMTINT		;COMMON TRANSMIT INTERRUPT HANDLER
>;NOKL10

IFKL10,<
↑DTXMT1:MOVEI LINE,TCONLN	;HERE FROM DTESER WITH XMIT DONE
	JRST XMTINT

↑DTRCV1:MOVE CHR,TAC		;FROM DTESER WITH RECEIVED CHAR IN TAC
	MOVEI LINE,TCONLN
	JRST RECINT
>;IFKL10
;DCASER

BEGIN DCASER

COMMENT ⊗
This is the hardware service routine for the DCA scanner.  It is entered
at DCAINT from the CH5 CONSZ chain, at DCAINI from TTYINI, and at DCATYP
from XMTINT.  Except for DCATYP, all code here assumes that either it is
running in channel 5 or channel 5 is turned off; DCATYP has OFFSCN/ONSCN
macro calls.  The following data structures are used:

DCATAB, in ALLDAT, indexed by DCA port number.  Format described on next
page of this file.

LINBIT, in TTYSER, indexed by TTYSER line number.   LH is used by TTYSER
for the initial LINTAB bits.  We use RH to contain 0 for a non-DCA line,
or 400000+port number for a DCA line.

ABRTAB, here, is a constant table used to drive the finite-state-machine
automatic baud recognition program.

CR1TAB and CR2TAB, here, are constant tables which describe the mappings
of speeds to control register bits for each port group.

Here is how this code uses ACs:

LINE	DCA port number
DDB	DCATAB entry for this port, usually
AC1	DCA port number in a funny format needed for CONO
CHR	status flags and character read

TAC,DAT,AC2	temporaries

⊗;END OF COMMENT
;SERDAT DCASTB DCABAU DCABKY DCASPD DCATAC DCALIN

;Byte pointers into DCATAB and KBDCHR, etc.

↑SERDAT:POINT SERSIZ,KBDCHR(TAC1),10 ;777600,,0 BITS -- 7 data bits of 2nd kbd byte,
			;plus SPWREQ, POLTMO, POLTM2, LEDSPW bits. Used for TTREAD.

;Pointers into DCATAB.  For more bit defs, see OUTER.
↑DCASTB:POINT 2,DCATAB(TAC1),2		;BPT FOR DCADSR AND DCACAR STATUS BITS
↑DCABAU:POINT 6,DCATAB(TAC1),8		;77000,,0 AUTO BAUD DETECT STATE
↑DCABKY:POINT 5,DCATAB(TAC1),17		;BUCKY BITS (7,,0) AND FLAG (10,,0) and SPW
↑DCASPD:POINT 4,DCATAB(TAC1),28		;0,,3600 BITS ARE INITIAL SPEED INDEX
↑DCATAC:POINT 7,DCATAB(TAC),35		;0,,177 BITS BUT INDEXED WITH TAC
↑↑DCALIN:POINT 7,DCATAB(TAC1),35	;0,,177 BITS ARE TTYSER LINE #
;K10CS K10RTN K10REP K10PIR K10TST K10EN K10IAK K10PI K10CS1 AS.NLB AS.BKO AS.1SB AS.BSO AS.ECH AS.PEN AS.REN AS.RTS AS.DTR AS.NDB AS.SYN AS.ODD AS.RCL AS.XCL AS.DSC AS.DSR AS.CAR AS.FER AS.PER AS.OER AS.RDA AS.THRE ASTWAT
;ASTRA-K10 CONTROLLER - HARDWARE BITS AND PARAMETERS

;CONI BITS (AND CONTROL CONO)

	↑↑K10CS←←4000		;CHIP SELECT
	↑↑K10RTN←←2000		;IACK RETURN (FROM TERMINATOR PLUG)
	↑↑K10REP←←1000		;REPLY (FROM CS SEQUENCE OR IACK)
	↑↑K10PIR←←400		;CBUS PIR (PROGRAM INTERRUPT REQUEST)
	↑↑K10TST←←40		;CBUS TEST BIT
	↑↑K10EN←←20		;ENABLE = NOT(CBUS MASTER RESET)
	↑↑K10IAK←←10		;CBUS IACK (INTERRUPT ACKNOWLEDGE)
	↑↑K10PI←←7		;PI CHANNEL MASK

;CONO BITS (SELECT CONO)

	↑↑K10CS1←←200		;BIT WHICH MUST BE ON DURING SELECT SEQUENCE
;	↑↑K10CFM←←3400		;MASK TO CARD-FILE #
;	↑↑K10PRT←←170		;MASK TO PORT WITHIN CARD-FILE
;	↑↑K10REG←←7		;MASK TO REGISTER WITHIN PORT

;ASTRA-AS PORT MODULE - DEFINITIONS

;CR1 - CONTROL REGISTER 1 (REG0)

	↑↑AS.NLB←←200		;NO LOOP-BACK (OFF FOR LOOPBACK)
	↑↑AS.BKO←←100		;BREAK-OUT
	↑↑AS.1SB←←40		;ONE STOP BIT (TWO IF OFF)
	↑↑AS.BSO←←40		;BUSY OUT (IF XMTR DISABLED)
				;NOTE!! AS.1SB & AS.BSO ARE SAME BIT!
	↑↑AS.ECH←←20		;AUTO-ECHO MODE
	↑↑AS.PEN←←10		;PARITY ENABLE
	↑↑AS.REN←←4		;RECEIVER ENABLE
	↑↑AS.RTS←←2		;REQUEST TO SEND (ALSO TRANSMITTER ENABLE)
	↑↑AS.DTR←←1		;DATA TERMINAL READY

;CR2 - CONTROL REGISTER 2 (REG2)

	↑↑AS.NDB←←300		;FIELD HAS 0,1,2,3 FOR 8,7,6,5 DATA BITS.
DEFINE ASNDB(NBITS)<<<8-NBITS>⊗6>>
	↑↑AS.SYN←←40		;SYNC MODE
	↑↑AS.ODD←←20		;ODD PARITY (IF PARITY ENABLED)
	↑↑AS.RCL←←10		;RECEIVER CLOCK SAME AS TRANSMITTER (CLK0 IF OFF)
	↑↑AS.XCL←←7		;TRANSMITTER CLOCK RATE (MASK)

;STATUS REGISTER (REG4)

	↑↑AS.DSC←←200		;DATA SET CHANGE (CHANGE IN AS.CAR OR AS.DSR)
	↑↑AS.DSR←←100		;DATA SET READY
	↑↑AS.CAR←←40		;CARRIER
	↑↑AS.FER←←20		;FRAMING ERROR
	↑↑AS.PER←←10		;PARITY ERROR
	↑↑AS.OER←←4		;OVERRUN ERROR
	↑↑AS.RDA←←2		;RECEIVER DATA AVAILABLE
	↑↑AS.THRE←←1		;TRANSMITTER HOLDING REGISTER EMPTY

;SYNC/FILL REGISTER (REG4)

;	<NONE>

;DATA REGISTER (REG6)

;	<NONE>

↑↑ASTWAT←←1000			;NUMBER OF TIMES TO LOOP WAITING FOR IACK.
				;THE SEQUENCE "MOVEI ASTWAT/SOJG ." MUST BE
				;SLOWER THAN 32 MICROSECONDS ON ALL CPUS.
;DLNTAB DLNTYP DCATYP DLNPKU DCAPKU DCAPK1 DLNHNG DCAHNG DCAHN2

;HERE FROM XMTINT WITH 400000+PORT NUMBER IN TAC, CHARACTER IN CHR

IFN DLNNUM,<
↑↑DLNTAB:			;REFERENCED IN DLPINT IN DLNSER
IFE FTF2,<
	400000+40		;DIALUP
>;IFE FTF2
IFN FTF2,<
	400000+3		;DIALUP
>;IFN FTF2
IFN .-DLNTAB-DLNNUM,<.FATAL DLNTAB LOSES>

↑↑DLNTYP:			;ENTRY FROM DIALNET
	SKIPL TAC		;MAKE SURE MRC IS WINNING
	 CAIL TAC,DLNNUM
	  JSP TAC1,BADDLU	;MRC HAS A CONVENIENT BUG TRAP FOR THIS
	MOVE TAC,DLNTAB(TAC)	;CONVERT DIALNET UNIT NUMBER TO PORT+400000
>;IFN DLNNUM
↑DCATYP:PUSH P,LINE		;SAVE LINE NUMBER
	PUSH P,AC1		;THESE ARE CLOBBERED TOO
	PUSH P,AC2
	MOVEI LINE,-400000(TAC)	;GET PORT NUMBER FROM TTYSER INTO AC LINE
	PUSHJ P,ASTPRT		;GET PORT NUMBER IN CHIP SELECT FORMAT IN AC1
	OFFSCN			;TURN OFF PI CHANNEL
	PUSHJ P,ASTWR6		;WRITE THE DATA
	ONSCN
	POP P,AC2
	POP P,AC1
	POP P,LINE
	POPJ P,

;HERE WITH 400000+PORT NUMBER IN TAC TO ENABLE ANSWERING THE PHONE OR CALLING OUT
;NOT NECESSARY UNLESS SOMEONE HAS CALLED DCAHNG

IFN DLNNUM,<
↑↑DLNPKU:			;ENTRY FROM DIALNET
	SKIPL TAC		;MAKE SURE MRC IS WINNING
	 CAIL TAC,DLNNUM
	  JSP TAC1,BADDLU	;MRC HAS A CONVENIENT BUG TRAP FOR THIS
	MOVE TAC,DLNTAB(TAC)	;CONVERT DIALNET UNIT NUMBER TO PORT+400000
>;IFN DLNNUM
↑DCAPKU:PUSH P,LINE		;SAVE LINE NUMBER
	MOVEI LINE,-400000(TAC)	;GET PORT NUMBER FROM TTYSER INTO AC LINE
	SKIPGE DCATAB(LINE)	;ARE WE ALREADY READY?
	JRST DCAPK1		;YES, NOTHING TO DO
	PUSH P,AC1		;THESE ARE CLOBBERED TOO
	PUSH P,AC2
	PUSH P,CHR
	PUSHJ P,ASTPRT		;GET PORT NUMBER IN CHIP SELECT FORMAT IN AC1
	OFFSCN			;TURN OFF PI CHANNEL
	PUSHJ P,ASTRD0		;READ CR1
	TRO CHR,AS.RTS		;THIS MAY HAVE BEEN TURNED OFF BUT NOT ALONE
	TRC CHR,AS.DTR!AS.REN	;DLN PORT CAN HAVE HAD AS.REN TURNED OFF AT DCAINI
	TROE CHR,AS.DTR!AS.REN	;HERE'S THE HARDWARE BITS
	PUSHJ P,ASTWR0		;WRITE IT ONLY IF NECESSARY
	MOVSI CHR,DCADTR	;FLAG THAT WE THINK DTR IS UP
	IORM CHR,DCATAB(LINE)	;IN CORE TOO
	ONSCN
	POP P,CHR
	POP P,AC2
	POP P,AC1
DCAPK1:	POP P,LINE
	POPJ P,

;HERE WITH 400000+PORT NUMBER IN TAC TO HANG UP A LINE (DROP DTR)
;THIS IS NOT NORMALLY DONE FOR INCOMING TTY LINES

IFN DLNNUM,<
↑↑DLNHNG:			;ENTRY FROM DIALNET
	SKIPL TAC		;MAKE SURE MRC IS WINNING
	 CAIL TAC,DLNNUM
	  JSP TAC1,BADDLU	;MRC HAS A CONVENIENT BUG TRAP FOR THIS
	MOVE TAC,DLNTAB(TAC)	;CONVERT DIALNET UNIT NUMBER TO PORT+400000
	PUSHJ P,DCAHNG		;HANG UP THE PHONE
	 POPJ P,		;PERMANENT LINE, CAN'T HANG UP, NO PHONE/MODEM
	POPJ P,
>;IFN DLNNUM

;HANG UP DCA PORT.  SKIP RETURN ON SUCCESS, DIRECT RETURN IF NO PHONE TO HANG UP
↑↑DCAHNG:
	PUSH P,LINE		;SAVE LINE NUMBER
	PUSH P,AC1		;THESE ARE CLOBBERED TOO
	PUSH P,AC2
	PUSH P,CHR		;MIGHT AS WELL SAVE THIS SINCE IT'S NOT AN ARG
	MOVEI LINE,-400000(TAC)	;GET PORT NUMBER FROM TTYSER INTO AC LINE
	MOVE AC1,DCATAB(LINE)	;IF THIS IS A PERMANENT LINE, IT CAN'T HANG UP
	TRNE AC1,DCAPRM		;SKIP UNLESS PERMANENT LINE
	JRST DCAHN2		;FORGET THE WHOLE THING!  TAKE ERROR RETURN
	PUSHJ P,ASTPRT		;GET PORT NUMBER IN CHIP SELECT FORMAT IN AC1
	OFFSCN			;TURN OFF PI CHANNEL
	PUSHJ P,ASTRD0		;READ CR1 TO GET DTR BIT AND FRIENDS
	TRZE CHR,AS.DTR		;ZERO THE BIT TO HANG UP THE MODEM
	PUSHJ P,ASTWR0		;WRITE IT ONLY IF CHANGED
	PUSHJ P,ASTRD2		;READ CR2 *** THIS IS A BUG TRAP
	TRZE CHR,AS.SYN		;SYNC ON? ***
	PUSHJ P,ASTWR2		;YES, FOO ***
	MOVSI CHR,DCADTR!DCADSR!DCACAR	;REMIND OURSELF THAT WE'VE HUNG IT UP
	ANDCAM CHR,DCATAB(LINE)	;(** ALSO TURN OFF DSR AND CAR FLAGS **)
	ONSCN
	AOS -4(P)		;SUCCESS RETURN
DCAHN2:	POP P,CHR
	POP P,AC2
	POP P,AC1
	POP P,LINE
	POPJ P,
;PORTDN DCAINT DCATST ASTIN1 DCARCV DCAERR DCARC2 DCALE2 DCALED DCASPW DCARC1 DILRCV DCAXMT DCAXM1 DCAXM2 DCAXM3 NORPLY NOPORT

↑PORTDN:AOS NPORTD		;Count total ints on down ports
	AOS DCAINN(TAC)		;COUNT INTERRUPT FOR SURE--SHOULDN'T HAVE HAPPENED
	POPJ P,			;PATCH HERE TO INTERCEPT A PARTICULAR PORT

IFE FTDLS,<	;Rest of page
↑↑DCAINT:
	AOS NDCAIN		;COUNT TOTAL DCA INTERRUPTS
	CONSZ DCA,K10TST	;RUNNING DIAGNOSTICS?
↑↑DCATST:
IFN FTXADR,<
	XJEN CH5		;PATCH THIS CELL TO HANDLE THESE INTERRUPTS
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH5		;PATCH THIS CELL TO HANDLE THESE INTERRUPTS
>;IFE FTXADR
	JSR SCNSAV		;YES, GET SOME AC'S
	CONO DCA,K10IAK+K10EN+SCNCHN	;TURN ON INTERRUPT ACKNOWLEDGE
	MOVEI DDB,ASTWAT	;(PROCESSOR DEPENDENT VALUE)
	CONSO DCA,K10REP+K10RTN	;REPLY OR IACK RETURN
	SOJG DDB,.-1		;NO, WAIT (FOR A WHILE). [MAX SPEC.= 32 US.]
	CONSO DCA,K10REP	;DID WE GET OUT WITH A REPLY?
	 JRST NORPLY		;I NEARLY DIED, WHEN YOU WALKED HAND IN HAND, ETC.
	DATAI DCA,TAC		;READ INTERRUPT RESPONSE DATA
	CONO DCA,K10EN+SCNCHN	;RESET IACK
	MOVEI AC1,(TAC)		;KEEP PORT NUMBER IN CHIP SELECT FORMAT
	ANDI AC1,7770		;NO GARBAGE PLEASE (EXCEPT "NO ADDR")
	IORI AC1,K10CS!K10CS1	;ADD MAGIC BITS
	LSHC TAC,-7		;DO BIT FLIPPING ALGORITHM
	LSH TAC,-1		;SQUEEZE OUT CONSTANT 1 BIT
	LSHC TAC,4		;TAC = PORT #, TAC1(0:2) = FLAGS
	CAIL TAC,DCANUM		;A PORT WE KNOW ABOUT? (OR "NOADR" BIT ON?)
	 JRST NOPORT		;NO, HOPE IT'S NOT BROKEN!
	AOS DCAPIN(TAC)		;Count all interrupts per port, debugging info only
;;;	AOS DCAINN(TAC)		;Do it here to count all ints including XMT
	MOVSI DDB,DCASYI	;NO LONGER IN SYSINI PENDING MODE
	ANDCAB DDB,DCATAB(TAC)	;GET OUR FLAG WORD
	TRNE DDB,DCADWN		;HAS SOMEONE FLAGGED THIS GUY DOWN?
	JRST PORTDN		;YES, JUST COUNT DCAINN AND GO AWAY
	JUMPGE TAC1,DCAXMT	;JUMP IF XMT INTERRUPT
	AOS DCAINN(TAC)		;Do it here to count RCV and MODEM ints
	MOVE LINE,TAC		;LINE NOW CONTAINS DCA PORT NUMBER
	PUSHJ P,ASTRD4		;READ THE STATUS REGISTER (FLAGS) TO CHR.
	HRLZ CHR,CHR		;I WANT TO CARRY THEM AROUND IN CHR<LH>.
	TLNN CHR,AS.RDA		;RECEIVED DATA INTERRUPT?
	JRST ASTIN1		;NO, MUST BE JUST MODEM.
	PUSH P,CHR		;SAVE FLAGS (INCLUDING POSSIBLE MODEM INT.)
	PUSHJ P,ASTRD6		;READ DATA REG TO CHR
	POP P,TAC		;GET FLAGS BACK
	HLL CHR,TAC		;IN SAME PLACE AS BEFORE.
ASTIN1:	TLNE CHR,AS.DSC		;MODEM INTERRUPT?
	PUSHJ P,ASTDSI		;YES, HANDLE IT (UPDATE DCATAB, DDB)
IFN FTF2,<
	TLNN CHR,AS.RDA!AS.OER	;DATA INTERRUPT?
	POPJ P,			;NO, JUST MODEM (OR SPURIOUS)
>;IFN FTF2
IFE FTF2,<
;Supposedly AS.OER can be on at SAIL at least at sys init time without AS.RDA,
;and that seems to crash the system by getting us to SCNTYP with DDB set from
;DCATAB(port) somehow instead of from TTYTAB.
	TLNN CHR,AS.RDA		;DATA INTERRUPT?
	POPJ P,			;NO, JUST MODEM (OR SPURIOUS)
>;IFE FTF2
;;;	AOS DCAINN(LINE)	;Do it here to count RCV ints only
	TLNN DDB,DCADIL		;DIALING OUT, SO ABR DISABLED?
	TRNN DDB,DCABDB		;NO, IS THIS A BAUD DETECT LINE?
	JRST DCARCV		;NO, PREPARE FOR TTYSER
	LDB TAC,DCABAU		;YES, GET BAUD DETECT STATUS
	TRNE TAC,-2		;IS THE ABR STATE EITHER "NORMAL" OR "IDLE"?
				;(NOTE: DEPENDS ON "NORMAL"=0, "IDLE"=1)
	JRST ASTIN3		;NO, INTERCEPT DATA FOR BAUD DETECTION
DCARCV:
REPEAT 0,<			;JBR DOESN'T LIKE THIS IDEA
	TLNE CHR,AS.FER		;FRAMING ERROR?
	JRST SCNRC1		;YES, PROBABLY <BREAK>.
>;REPEAT 0
	TLNE CHR,AS.OER		;OVERRUN ERROR DOESN'T INVALIDATE THIS CHAR
	AOS DCAOER(LINE)	;COUNT OVERRUN ERRORS PER PORT
	TLNE CHR,AS.FER!AS.PER	;ERROR?
	JRST DCAERR		;YES, IGNORE
IFN DLNNUM,<
	TRNE DDB,DCADLB		;IS THIS A DIALNET PORT?
	JRST DILRCV		;YES, GO TO DLNSER NOT TTYSER
>;IFN DLNNUM
IFN FTSUAI!FTCCRMA,<
	TRNN DDB,DCADPB		;IS THIS A BUCKY BIT TERMINAL?
>;IFN FTSUAI!FTCCRMA
	JRST DCARC1		;NO
	;We have a character from a microswitch keyboard.  Convert it into
	;SAIL character with bucky bits and other good things.  There are
	;two kinds of microswitch keyboard, depending on the site.  At
	;SAIL, the parallel 11 bits of keyboard output which is encoded and
	;serialized at the terminal is decoded here.  At CCRMA, the LLL
	;type microswitch keyboards send key number and a bits meaning key
	;up or down, and we keep track of the state of each key, including
	;two each CONTROL/META/TOP/SHIFT.
IFN FTCCRMA,<; LLL style microswitch keyboard
	JRST MCKRCV		;Code is in DLS stuff.  (Move it here someday?)
>;IFN FTCCRMA (LLL style microswitch keyboard)
IFN FTSUAI,<;	SAIL style microswitch keyboard
	TRNN CHR,200		;YES, IS THIS A BUCKY BIT SETTING CHARACTER?
	JRST DCARC2		;NO, BUT WE SHOULD APPEND BUCKIES TO THIS CHR
	TRNN CHR,SERSPW!SERSTR	;SPW char or KBD strobe?
	POPJ P,			;Nope, ignore invalid char (next invalid char = 0)
	TRO CHR,SERSTR		;FLAG BITS RECEIVED
	DPB CHR,DCABKY		;SAVE FOR NEXT TIME
	POPJ P,			;GOODBYE

DCARC2:
IFN FTHG,<
	PUSHJ P,HG		;IN LOWCOR, clobbers TAC, collects system stats
>;IFN FTHG
	LDB TAC,DCABKY		;GET BUCKY BITS FROM PREVIOUS BYTE, IF ANY
	TLZ DDB,SERSTR		;TURN OFF BUCKY FLAG IN CORE
	MOVEM DDB,DCATAB(LINE)
	TRC CHR,77		;Get right form of data bits from serializer
IFN FTSPWT,<
	HLL TAC,KBDCHR(LINE)	;Get old copy of SPWREQ and LEDSPW bits
	TRZ CHR,SERCLR		;Prepare to clear some SPW bits in core
	DPB CHR,SERDAT		;Save data for TTREAD, and clear 4 SPW bits too
>;IFN FTSPWT
	TRNE TAC,SERSTR		;Was the 2-byte flag on?
	DPB TAC,[POINT 3,CHR,28] ;Yes, install bucky bits from first byte
IFN FTSPWT,<
	TRNE TAC,SERSPW		;Is this char in response to a SPW request?
	JRST DCALED		;Yes, maybe the line editor wants it
;Next two instructions are needed if TTREAD is ever made to wait for char to return
	;TLNE TAC,SPWREQ	;Were we expecting a SPW char?
DCALE2: ;PUSHJ P,DCASPW		;Yes, process this char as SPW char and normal char
>;IFN FTSPWT
	LDB LINE,DCALIN		;GET TTYSER PHYSICAL (DD) LINE NUMBER
	JRST TKKBRT		;CONVERT CHARACTER TO DD FORMAT
;; note, should fix RECINT wrt DM/DPY/TTY business.
;; right now, this route only works for DD/III kbds, certainly not for DMs.

IFN FTSPWT,<
DCALED:	TLNN TAC,LEDSPW		;Skip if line editor asked for a SPW char from kbd
	JRST DCASPW		;Nope, maybe wake up TTREAD waiter
	ANDI CHR,1477		;Flush garbage bits, and ignore TOP and SHIFT
	CAIE CHR,1474		;Is this CONTROL-META BS?
	CAIN CHR,1440		;Or CONTROL-META-SPACE?
	SKIPA AC2,[LEDSPW,,0]	;Yes, go send this char on through
	JRST DCASPW		;Nope, end of repeating command, look for waiter
	IORM AC2,KBDCHR(LINE)	;Turn the line-editor-repeating flag back on
	JRST DCALE2		;Send char on toward LINED

DCASPW:
Repeat 0,< ;This routine needed if TTREAD is ever made to wait for char to return.
;Here to process SPW char.  Must preserve certain crutial ACs since we may be
;going back to process this char as normal char too.  Preserve: LINE (port) and CHR.
	PUSH P,LINE		;Preserve port
	PUSH P,CHR		; and character
;Here we should wake up whatever job(s) are waiting to TTREAD this kbd.
	POP P,CHR
	POP P,LINE
>;Repeat 0	;Don't flush unless TTREAD will never change
	POPJ P,
>;IFN FTSPWT
>;IFN FTSUAI (SAIL style microswitch keyboard)

DCAERR:	AOS NDCAER		;Count total framing/parity errors
	AOSN DCABER(LINE)	;COUNT FRAMING/PARITY ERRORS PER PORT
	TRNN DDB,DCADPB		;Error count hit limit, microswitch kbd?
	POPJ P,
	MOVEI TAC,400000(LINE)	;Yes, set up BH-format port number
	JRST DCADET		;Too many framing errors, turn off port

DCARC1:
IFG DILNUM,<
IFN FTVDIL,<
	CAIN LINE,VDILIN	;is this the Vadic dialer?
	JRST VDIINT		;yes, not really a tty, service this character
>;IFN FTVDIL
>;IFG DILNUM
IFN FTSCTY,<
	CAMN LINE,SCNCTY	;If from scanner CTY line,
	SKIPA LINE,[TCONLN]	; then use CTY's line number
>;IFN FTSCTY
	LDB LINE,DCALIN		;GET TTYSER LINE NUMBER
IFN FTHG,<
	PUSHJ P,HG		;IN LOWCOR, clobbers TAC, collects system stats
>;IFN FTHG
	JRST RECINT		;FIRE UP TTYSER

IFN DLNNUM,<
DILRCV:	LDB TAC,DCALIN		;GET DIALNET LINE NUMBER
	JRST DLIINT		;GO TO DLNSER
>;IFN DLNNUM

DCAXMT:
IFE FTF2,<
IFN FTSCTY,<
	CAMN TAC,SCNCTY		;is this scanner line being the CTY?
	SKIPA LINE,[TCONLN]	;yes, get CTY's line number
>;IFN FTSCTY
>;IFE FTF2
	LDB LINE,DCATAC		;GET TTYSER LINE NBR FROM PORT NBR IN TAC
;Begin BH attempt to catch runaway output but not real output
IFN DLNNUM,<
	TRNE DDB,DCADLB		;DIALNET PORT?
	JRST DCAXM3		;YES, DON'T COUNT XMT INTS HERE
>;IFN DLNNUM
	SKIPN DDB,TTYTAB(LINE)	;IS THERE A DDB?
	JRST DCAXM1		;IF NOT, LOG CHAR FOR SURE
	LDB CHR,PJOBN		;GET JOB NUMBER OF DDB'S USER
	MOVE CHR,JBTSTS(CHR)	;SEE IF THIS JOB IS ACTUALLY LOGGED IN
	TLNE CHR,JLOG
	JRST DCAXM2		;LOGGED IN, DON'T LOG XMT INT
	MOVEI CHR,ASSPRG	;DON'T LOG IF INITED BY PROGRAM
	TDNN CHR,DEVMOD(DDB)
DCAXM1:	AOS DCAINN(TAC)		;Don't do this if already counting all XMT ints
DCAXM2:	MOVE DDB,DCATAB(TAC)	;RESTORE DCATAB TO DDB
DCAXM3:
;End BH attempt to catch runaway output but not real output
IFN FTF2*FTSCTY,<
	CAMN LINE,SCNCTY	;Is a diagnostic dialup?
	JRST DCAXM4		;  Yes, special checks needed
>;IFN FTF2*FTSCTY
IFN DLNNUM,<
	TRNN DDB,DCADLB		;DIALNET PORT?
>;IFN DLNNUM
	JRST XMTINT		;NOTHING MORE FOR US TO DO
IFN DLNNUM,<
	MOVEI TAC,(LINE)
	JRST DLOINT		;YES, GO TO DLNSER
>;IFN DLNNUM

printx How come the F2 seems to need this, but the KL doesn't?
IFN FTF2*FTSCTY,<
DCAXM4:	SKIPN SUPCTY		;Output to CTY as well?
	  POPJ P,		;  Yes, let its interrupt drive scanner channel
	HLL LINE,LINTAB(LINE)	;Is this needed?
	MOVEI DDB,SCNDDB	;Get DDB for CTY
	JRST XMTIN1		;Join normal code
>;IFN FTF2*FTSCTY

;OFTEN GET HERE WHEN DCA RACK IS POWERED DOWN, sometimes when it is just bumped.
NORPLY:
IFE FTF2,<
	AOS TAC,NNOREP		;Count number of times this has happened
	TRNE TAC,777		;Have we had a lot of these?
	POPJ P,			;Not yet, be quiet
>;IFE FTF2
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT/DCA/
	PUSHJ P,DISMES
IFE FTF2,<
	ASCIZ /(512 x) DCA interrupt without IACK bit.  DATAI = /
>;IFE FTF2
IFN FTF2,<
	ASCIZ /DCA interrupt without IACK bit.  DATAI = /
>;IFN FTF2
	DATAI DCA,TAC		;READ INTERRUPT RESPONSE DATA
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	DEBCHECK(NOPOPACS)	;ACs weren't pushed
	CONO DCA,K10EN+SCNCHN	;RESET IACK
	POPJ P,			;Don't ever do a JRST WDDTCALL

NOPORT:	PUSH P,TAC
IFE FTF2,<
	AOS TAC,NNOPOR		;Count number of times this has happened
	TRNE TAC,777		;Have we had a lot of these?
	JRST TPOPJ		;Not yet, be quiet
>;IFE FTF2
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /DCA/
	PUSHJ P,DISMES
IFE FTF2,<
	ASCIZ /(512 x) DCA interrupt with Invalid Port Number = /
>;IFE FTF2
IFN FTF2,<
	ASCIZ /DCA interrupt with Invalid Port Number = /
>;IFN FTF2
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	DEBCHECK(NOPOPACS)
	POPJ P,			;Don't ever do a JRST WDDTCALL
>;IFE FTDLS
;HERE TO HANDLE MODEM CHANGE INTERRUPT (DATA SET INTERRUPT) ;⊗ ASTDSI ASTDI2 ASTDI9 ASTDI7 TGREET TGREE2 TGREE3 TGREE ASTDIE ASTDID ASTDIU ASTDI1 ASTD11 ASTD13 ASTD14 ASTD15 ASTDIR

;MUST PRESERVE LINE, CHR, DDB, OR AT LEAST RECONSTRUCT THEM.

;The only modem interrupt which is used for anything here is the carrier
;detect change interrupt.  If the carrier comes up, and the line is
;enabled for baud detect, then some initialization is done for the baud
;detect logic.  If the carrier goes down, any job attached to the terminal
;will have a DETACH command forced for it (provided that there is no other
;pending forced command).  Also, an auto baud detect line will be switched
;to 600 baud at this time.  The other possible interrupts which come here
;are for ring signal, and data set ready.  The hardware gives ring interrupts
;only if Data Terminal Ready is down, but we always leave DTR up for all
;lines.  We could control whether or not to answer the phone by leaving
;DTR down and providing code here.  Data Set Ready is remembered in a status
;bit in DCATAB but is not otherwise used.

ASTDSI:	LDB TAC,[POINT 2,CHR,12];COPY NEW FLAGS INTO TABLE
	DPB TAC,DCASTB		;  LEAVING OLD ONES IN DDB
	AOS DCAMIN(LINE)	;Count modem interrupts per port
	JUMPGE DDB,ASTDIR	;IF NOT DTR, CAN ONLY BE RING INTERRUPT
	XOR DDB,DCATAB(LINE)	;FLAG BITS IN DDB = WHICH CHANGED
	TLNN DDB,DCACAR		;SKIP IF CARRIER JUST CHANGED (UP OR DOWN)
	JRST ASTDI9		;DSR CHANGED OR NOTHING CHANGED
	MOVE DDB,DCATAB(LINE)	;GET FLAGS
	TLNN CHR,AS.CAR		;DID CARRIER JUST GO UP?
	JRST ASTDI1		;JUST WENT DOWN
	TLNE DDB,DCACDN		;JUST CAME UP, DID IT GO DOWN WITHIN 1/2 SEC?
	POPJ P,			;YES, THIS WAS A GLITCH, DO NOTHING
IFN DLNNUM,<
	TRNE DDB,DCADLB		;DIALNET PORT?
	JRST ASTDIU		;YES, GO TO DLNSER
>;IFN DLNNUM
	MOVEI AC2,ABRDET	;FLAG ABR "DETECT" STATE
ASTDI2:	MOVE TAC,DCATAB(LINE)	;GET FLAGS
	TLNE TAC,DCADIL		;SKIP unless DIALING OUT, SO NO AUTO BAUD
	JRST ASTDI9		;dialing out, no greeting, no autobaud
	TRNN TAC,DCABDB		;DOES THIS LINE WANT AUTO BAUD DETECT?
	JRST ASTDI7		;no, give him a greeting now
	PUSH P,CHR		;YES, SET SPEED TO 600
	MOVEI CHR,LS600
	MOVE DDB,DCATAB(LINE)	;SET UP DTR BIT FOR ASTSPD
	PUSHJ P,ASTSPD
	POP P,CHR
	DPB AC2,DCABAU
ASTDI9:	MOVE DDB,DCATAB(LINE)	;SET DDB BACK UP, CALLER(S) EXPECT IT.
	POPJ P,

;Here if non-auto-baud line -- constant speed, greet the caller.
ASTDI7:	PUSHJ P,TGREET		;force a HELLO command on this TTY, for greeting
	JRST ASTDI9

;Here for newly dialed up line.  Clear input buffer, type out greeting.
TGREET:	PUSHACS			;PRESERVE everything (esp. J,DAT,DDB,ETC.)
	LDB TAC,DCALIN		;GET TTYSER LINE NUMBER
	SKIPE DDB,TTYTAB(TAC)
	JRST TGREE2		;already has a DDB (unusual)
	PUSHJ P,DDBSRC		;make a DDB
	 JRST TGREE3		;CAN'T!
TGREE2:	PUSHJ P,SETBFI		;CLEAR OUT INPUT BUFFER (in case old DDB)
	MOVE TAC,[$TGREE,,JIFSEC/2] ;COME BACK IN HALF A SECOND
	LDB TAC1,PUNIT		;get line number
	DPB TAC1,[POINT 15,TAC,23] ;set 15 bit data item -- line number
	CLKENQ(TAC)		;Plant clock request
TGREE3:	POPACS
	POPJ P,

;Here from clock request (delay) to greet a newly dialed up line.  Line nbr in TAC.
↑↑TGREE:SKIPN DDB,TTYTAB(TAC)	;get DDB addr
	POPJ P,			;none?  forget greeting
	MOVEI TAC,F.HELL
	JRST FORCEC		;plant forced HELLO command (clobbers CHR), return

;I'M ASSUMING THAT THERE ARE NO ABR DLN LINES.  IF THAT CHANGES, THIS MUST TOO.

IFN DLNNUM,<
;Carrier has been down for 1/2 second on Dialnet port.
ASTDIE:	LDB TAC,DCALIN		;GET DIALNET LINE NUMBER
	PUSHJ P,DLHINT		;CALL DLNSER ROUTINE FOR CARRIER DOWN
	JRST SCNONJ

REPEAT 0,<
;Carrier just went down on Dialnet port.
ASTDID:	PUSH P,CHR
	PUSH P,LINE
	PUSH P,AC1
	PUSHJ P,DLHINT		;CALL DLNSER
	POP P,AC1
	POP P,LINE
	POP P,CHR
	JRST ASTDI9
>;REPEAT 0

;Here when carrier just came up on Dialnet port.
ASTDIU:	LDB TAC,DCALIN		;GET DIALNET LINE NUMBER
	PUSH P,CHR
	PUSH P,LINE
	PUSH P,AC1
	PUSHJ P,DLPINT		;DITTO
	POP P,AC1
	POP P,LINE
	POP P,CHR
	JRST ASTDI9
>;IFN DLNNUM

ASTDI1:
;	LDB TAC,DCALIN		;GET DIALNET LINE NUMBER
;	TRNE DDB,DCADLB		;DIALNET PORT?
;	JRST ASTDID		;YES, GO TO DLNSER
	TLOE DDB,DCACDN		;HAS IT ALREADY GONE DOWN WITHIN 1/2 SEC?
	POPJ P,			;YES, NOTHING TO DO
	MOVEM DDB,DCATAB(LINE)	;NO, INDICATE THAT IT HAS NOW
	PUSH P,LINE		;CARRIER DOWN
	MOVEI LINE,(LINE)	;FLUSH LH STUFF
	LSH LINE,=12		;POSITION PORT NUMBER IN ARGUMENT FIELD
	TLO LINE,$ASTD11	;Go to to ASTD11 shortly to detach job
	TRO LINE,JIFSEC/2	;WAIT 1/2 SECOND BEFORE BELIEVING CARRIER DOWN
	CLKENQ(LINE)		;Plant clk req
	POP P,LINE
	JRST ASTDI9		;DONE

;Here from clock request 1/2 second after carrier went down.
↑↑ASTD11:MOVSI DDB,DCACDN	;PREPARE TO INDICATE 1/2 SEC PAST SINCE CAR DOWN
	OFFSCN
	ANDCAB DDB,DCATAB(TAC)	;TURN OFF GLITCH-IN-PROGRESS BIT
	TLNE DDB,DCACAR		;TEST BIT FOR CARRIER ON
	JRST SCNONJ		;ON, IT MUST HAVE BEEN JUST A GLITCH
	MOVE LINE,TAC		;PORT NUMBER IN LINE
IFN DLNNUM,<
	TRNE DDB,DCADLB		;DIALNET PORT?
	JRST ASTDIE		;YES, GO TO DLNSER
>;IFN DLNNUM
	PUSH P,TAC		;SAVE DCA PORT NUMBER
	TRNE DDB,DCAPRM		;PERMANENT LINES DON'T HANG UP, SO DON'T DETACH JOB
	JRST ASTD13		;NO FORCED DETACH HERE
	LDB LINE,DCALIN		;GET TTYSER LINE NUMBER
	MOVE DDB,TTYTAB(LINE)	;GET DDB
	HLL LINE,LINTAB(LINE)	;GET BITS
	PUSHJ P,TTYNDM		;MAKE THIS LINE INTO A NON-DISPLAY
	 JFCL			;SKIPS ON FAILURE (if not DM)
	PUSHJ P,ASTD15		;ENTER FORCED DETACH COMMAND, IF NECESSARY
ASTD13:	POP P,LINE		;GET BACK DCA PORT NUMBER
	PUSHJ P,ASTPRT		;SET UP CONO BITS IN AC1
	MOVEI AC2,ABRIDL	;FLAG ABR "IDLE" STATE
	PUSHJ P,ASTDI2		; AND SET SPEED TO 600 IF AUTO BAUD-DETECT LINE
	JRST SCNONJ

;HERE FROM CLOCK REQUEST TO RETRY PLANTING FORCED DETACH COMMAND FOR HUNG UP TTY.
ASTD14:	MOVEI DDB,(DAT)		;GET TTY DDB ADDRESS WHERE WE NEED IT
ASTD15:	MOVE TAC,DEVIOS(DDB)
	MOVSI LINE,TTYATC
	TDNE LINE,DEVMOD(DDB)	;SKIP IF THIS TTY ISN'T CONTROLLING A JOB
	TLNE TAC,TTYDTC		;SKIP UNLESS THIS IS ALREADY A DETACHED TTY DDB
	POPJ P,			;FORGET IT, NOTHING TO DO
	MOVEI TAC,F.DET		;FORCED DETACH COMMAND INDEX
	PUSHJ P,FORCEC		;DETACH THE JOB
	JUMPE CHR,CPOPJ		;JUMP IF SUCCESSFULLY PLANTED FORCED DETACH CMD
	HRLI DDB,ASTD14		;PLANT CLK REQ TO RETRY PLANTING DETACH CMD!
	SYSPIFF
	IDPB DDB,CLKQ
	SYSPIN
	AOS NREDET		;COUNT NUMBER OF TIMES WE HAD TO RETRY
	POPJ P,

ASTDIR:	PUSH P,CHR		;RING INTERRUPT, SOMEONE DROPPED DTR
	PUSH P,DDB
	PUSHJ P,ASTRD0		;SO WE'LL PUT IT BACK ON
	TRO CHR,AS.RTS
	TRC CHR,AS.DTR!AS.REN	;DLN PORT CAN HAVE HAD AS.REN TURNED OFF AT DCAINI
	TROE CHR,AS.DTR!AS.REN	;HERE'S THE HARDWARE BITS
	PUSHJ P,ASTWR0		;WRITE IT ONLY IF NECESSARY
	MOVSI DDB,DCADTR	;FLAG THAT WE THINK DTR IS UP
	IORM DDB,DCATAB(LINE)	;IN CORE TOO
	POP P,DDB		;GET BACK OLD MODEM STATUS
	TLO DDB,DCADTR		;BUT WITH DTR ON
	POP P,CHR		;NOW THE MODEM WILL ANSWER THE PHONE
	POPJ P,
;⊗ ASTIN3 ASTIN4 ASTIN5 ASTIN6 ASTIN7 ASTSPD DCASPY ASTSP1 ASTSP3 ASTDTS ASTSP2 ASTSP4 DCASPS DCASPR DCASPX DCAATT DCADET DCACHK DCAIRM

;HERE ON RECEIVED DATA WHILE PORT IN BAUD DETECT STATE

;! LINE := PORT #; CHR := FLAGS,,DATA; TAC := BAUD STATE #;

;BAUD DETECTION STATE-TRANSITION PATTERN-MATCHING TABLE LAYOUT. ENTRIES ARE
;OF THREE FORMS:
;				 0 1            17 18             35 
;1. LAST MATCH CHARACTER:	!-!---------------!-----------------!
;				!1!   4-BIT SPEED !   PATTERN CHAR  !
;				!-!---------------!-----------------!
;
;2. NOT LAST MATCH CHAR:	!-!---------------!-----------------!
;				!0!  NEXT STATE # !   PATTERN CHAR  !
;				!-!---------------!-----------------!
;
;3. END OF PATTERN SUB-TREE:	!-----------------------------------!
;				!                 0                 !
;				!-----------------------------------!

ASTIN3:	ANDI CHR,377		;STRIP TO 8 BITS TO AID COMPARES

ASTIN4:	SKIPN DAT,ABRTAB(TAC)	;GET (NEXT) MATCH CHARACTER, IF ANY.
	JRST ASTIN6		;NONE. ABR FAILED! START AGAIN FROM FIRST STATE.
	CAIE CHR,(DAT)		;RECEIVED CHAR SAME AS CURRENT MATCH CHAR?
	AOJA TAC,ASTIN4		;NO, TRY NEXT MATCH CHAR.
	JUMPL DAT,ASTIN7	;FINAL FLAG ON? IF SO, GO FINISH UP.
ASTIN5:	HLRZ DAT,DAT
	DPB DAT,DCABAU		;NO, JUST STORE NEW STATE FOR NEXT INTERRUPT.
	POPJ P,			;AND DISMISS.

;HERE IF ABR FAILED. RESET TO INITIAL DETECT STATE AND KEEP TRYING.

ASTIN6:	MOVSI DAT,ABRDET	;INITIAL DETECT STATE.
	JRST ASTIN5		;RESET PORT'S STATE

;HERE ON SUCCESSFUL DETECTION. "NEXT STATE" FIELD HAS 4-BIT SPEED (+400000)

ASTIN7:	TRNN DDB,DCADLB		;skip if this is a DIALNET port
	PUSHJ P,TGREET		;clear input, force HELLO cmd to greet this TTY
	MOVEI TAC,ABRNORM
	DPB TAC,DCABAU		;SET STATE TO "NORMAL" (I.E., DETECTION DONE)
	HLRZ CHR,DAT		;SET FINAL SPEED. (ASTSPD WILL IGNORE FINAL FLAG)
ASTSPD:	PUSHJ P,ASTSP1		;CALL ROUTINE WHICH TESTS LEGALITY AND SETS
	 PUSHJ P,DCASPY		;ERROR, SHOULDN'T HAPPEN AT THIS ENTRY POINT
	POPJ P,			;OK

↑DCASPY:PUSHACS			;BUG TRAP
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /DCATAB-CR2TAB INCONSISTENCY AT ASTSPD
/
	PUSHJ P,DISFLUSH	;DON'T FORGET TO OUTPUT IT
	POPACS
	PUSHJ P,WDDTCA
	POPJ P,

ASTSP1:	ANDI CHR,17		;JUST TRANSMITTER SPEED
	PUSH P,CHR		;SAVE AROUND FIRST WRITE
	LDB TAC,[POINT 3,LINE,31];GET GROUP NUMBER, SINCE SPEEDS VARY
IFN FTF2,<
	CAIL TAC,NDCAGP		;Make sure we didn't add new problems.
	  PUSHJ P,BUGTRP
>;IFN FTF2
	CAIN CHR,LSEXT		;IS THIS REQUEST FOR EXTERNAL CLOCK?
	JRST ASTSP2		;YES, DIFFERENT CHECK
	ADD CHR,CR2TAB(TAC)	;POINT INTO PROPER TABLE
	MOVE CHR,(CHR)		;TRANSLATE SPEED TO CR2 CONTENTS
	TRNN CHR,AS.XCL		;WAS THERE A SPEED?
	JRST ASTSP4		;NO, ERROR
ASTSP3:	PUSHJ P,ASTWR2		;WRITE TO HARDWARE
	POP P,CHR		;GET IT BACK
	AOSA (P)		;SUCCESS RETURN
ASTDTS:	LDB CHR,DCASPD		;ENTER HERE TO SET DTR IN HARDWARE FROM DDB
	MOVE CHR,CR1TAB(CHR)	;TRANSLATE SPEED TO CR1 CONTENTS
	JUMPL DDB,ASTWR0	;JUMP IF WE THINK DTR SHOULD BE SET
	TRZ CHR,AS.DTR		;NO, KILL IT.
	TRNE DDB,DCADWN		;Skip unless this port is really down now
	TRZ CHR,AS.REN!AS.RTS	;Down, turn off xmtr and rcvr enables
	JRST ASTWR0		;WRITE CR1

ASTSP2:	MOVE TAC,CR2TAB(TAC)	;POINT TO SPEED TABLE FOR THIS GROUP
	SKIPE CHR,LSEXT(TAC)	;DOES THIS GROUP ALLOW EXTERNAL CLOCK?
	JRST ASTSP3		;YES, PROCEED
ASTSP4:	POP P,CHR		;NO, ERROR RETURN
	POPJ P,

;HERE FROM TTYSER TO SET SPEED FOR COMMAND OR UUO.  TAC=400000+PORT NUMBER,
;CHR=SPEED INDEX (e.g., LS110).

↑DCASPS:PUSHJ P,DCASPX		;DO THE THING
	 JRST DCASPY		;OOPS, UUO SHOULDN'T HAVE ALLOWED THIS
	POPJ P,

;Routine to set DCA port's speed, from index in CHR.  Skips on success.
;Clobbers TAC and CHR.
↑DCASPR:TLOA CHR,-1		;ENTRY TO RESET SPEED TO DCATAB VALUE
↑DCASPX:TLZ CHR,-1		;Flag entry with specific speed
	PUSH P,DDB		;ASTSPD NEEDS FLAGS IN DDB
	PUSH P,LINE		;SAVE LINE NUMBER
	PUSH P,AC1		;THESE ARE CLOBBERED TOO
	PUSH P,AC2
	MOVEI LINE,-400000(TAC)	;GET PORT NUMBER FROM TTYSER INTO AC LINE
	TLZE CHR,-1		;SKIP IF DCASPX ENTRY
	LDB CHR,DCASPD		;DCASPR, GET DEFAULT SPEED FROM DCATAB
IFE FTDLS,<
	MOVE DDB,DCATAB(LINE)
	PUSHJ P,ASTPRT		;GET PORT NUMBER IN CHIP SELECT FORMAT IN AC1
	AOS -4(P)		;ASSUME SUCCESS
	OFFSCN			;TURN OFF PI CHANNEL
	PUSHJ P,ASTSP1		;SET THE SPEED
	 SOS -4(P)		;DIDN'T WIN
	ONSCN
>;IFE FTDLS
IFN FTDLS,<
	AOS -4(P)		;ASSUME SUCCESS
	PUSHJ P,DLSSPS		;SET SPEED OF DC-10 PORT
	 SOS -4(P)		;DIDN'T WIN
>;IFN FTDLS
	POP P,AC2
	POP P,AC1
	POP P,LINE
	POP P,DDB
	POPJ P,

; HERE FROM TTYSER FOR ATTACH/DETACH TTY
;CLOBBERS CHR,TAC.
↑DCAATT:SKIPA CHR,[TLO DDB,DCADTR]
↑↑DCADET:MOVE CHR,[TLZ DDB,DCADTR]
	PUSH P,DDB		;ASTSPD NEEDS FLAGS IN DDB
	PUSH P,LINE		;SAVE LINE NUMBER
	PUSH P,AC1		;THESE ARE CLOBBERED TOO
	PUSH P,AC2
	MOVEI LINE,-400000(TAC)	;GET PORT NUMBER FROM TTYSER INTO AC LINE
	OFFSCN			;TURN OFF PI CHANNEL
	MOVE DDB,DCATAB(LINE)
	XCT CHR			;SET DTR ON OR OFF IN DCATAB
	TLNN DDB,DCADTR
	TROA DDB,DCADWN		;SET DOWN BIT TO COMPLEMENT OF DTR
	TRZ DDB,DCADWN
	MOVEM DDB,DCATAB(LINE)
	PUSHJ P,ASTPRT		;GET PORT NUMBER IN CHIP SELECT FORMAT IN AC1
	PUSHJ P,ASTDTS		;SET DTR ON OR OFF IN HARDWARE
	TLNN DDB,DCADTR
	SETZM DCAINN(LINE)	;CLEAR INTERRUPT COUNT SINCE PORT NOW OFF
	ONSCN
	POP P,AC2
	POP P,AC1
	POP P,LINE
	POP P,DDB
	POPJ P,

IFN FTDCHK,<

; Called by wizard request for debugging info.  To call, set CHKDCA to the
; port number you want checked; results will appear on CTY.
; Also called by DEVCHK (at DCAIRM) when an IRMA is detected on some DCA TTY.

↑↑DCACHK:
	MOVNI LINE,1		;CALLED BY CLKSER WHEN CHKDCA NONNEGATIVE
	EXCH LINE,CHKDCA	;DON'T CALL IT TWICE
	CAIL LINE,DCANUM
	POPJ P,			;NOT A WIZARD, A SORCERER'S APPRENTICE!
	PUSH P,LINE
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /CHKDCA/
	POP P,LINE
↑↑DCAIRM:
	PUSHJ P,ASTPRT		;GET CONO FORMAT PORT NUMBER IN AC1
	OFFSCN
	PUSHJ P,ASTRD4		;STATUS
	PUSH P,CHR
	PUSHJ P,ASTRD2		;CR2
	PUSH P,CHR
	PUSHJ P,ASTRD0		;CR1
	PUSH P,CHR
	PUSH P,DCATAB(LINE)	;GET A CONSISTENT DCATAB
	ONSCN
	PUSH P,LINE
	PUSHJ P,DISMES
	ASCIZ /Port /
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /, DCATAB /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ / CR1:/
	POP P,TAC
	ANDI TAC,377
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / CR2:/
	POP P,TAC
	ANDI TAC,377
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / STATUS:/
	POP P,TAC
	ANDI TAC,377
	PUSHJ P,DISLOC
	JRST DISCRL

>;IFN FTDCHK
;HIBAUD LS110 LS134 LS150 LS300 LS600 LS1200 LS1800 LS2400 LS4800 LS9600 LS1512 LS55 LS75 LSEXT LS1218 SPDNAM NUMSPD DLSSPD ABRFIN ABRTAB ABRNORM ABRIDL ABRDET AB110A AB110B AB134A AB134B AB300A AB150A AB150B
;BAUD DETECTION STATE-TRANSITION TABLE.

HIBAUD←←-1	;NONZERO TO DETECT SPEEDS OTHER THAN 110, 150, 300 (namely 600,1200)

;THE FOLLOWING SYMBOLS ARE NAMES OF SPEEDS, STORED IN DCATAB AND USED TO
;INDEX INTO THE TABLES OF CONTROL BITS.  MAX NUMBER OF SPEEDS IS 17.
;THESE DEFINITIONS MUST AGREE WITH THE ONES IN CACDAT!

↑LS110←←0
LS134←←1
↑LS150←←2
↑LS300←←3
LS600←←4
LS1200←←5
LS1800←←6
LS2400←←7
LS4800←←10
LS9600←←11
LS1512←←12		;INDEX FOR 150/1200 SPLIT SPEED
LS55←←13		;55 BAUD
LS75←←14		;75 BAUD
LSEXT←←15		;INDEX FOR "EXTERNAL" SPEED
LS1218←←16		;1800/1200 FOR IMLACS

↑SPDNAM:'110   '
	'134   '
	'150   '
	'300   '
	'600   '
	'1200  '
	'1800  '
	'2400  '
	'4800  '
	'9600  '
	'1512  '
	'55    '
	'75    '
	'EXT   '
	'1218  '
↑NUMSPD←←.-SPDNAM

IFN FTDLS,<
;This table must parallel the above speed name table.
↑DLSSPD:0	;	(110)	Doesn't really exist, "Borrowed for 1200/150"
	0	;	(134)	Doesn't really exist
	31	;150
	32	;300
	0	;	(600)	Doesn't really exist
	37	;1200
	0	;	(1800)	Doesn't really exist
	36	;2400
	35	;4800
	34	;9600
	23	;1200/150
	0	;	(55)	Doesn't really exist
	0	;	(75)	Doesn't really exist
	30	;EXT
	0	;	(1800/1200) Doesn't really exist
>;IFN FTDLS

	ABRFIN←←400000

ABRTAB:	PHASE 0
ABRNORM:0
ABRIDL::0
ABRDET::XWD AB110A,340
	XWD AB110A,360
	XWD AB134A,0	;NEED THIS ONE EVEN IF NO 2741'S (FOR <BREAK> CATCHER)
	XWD AB150A,160
	XWD AB150A,170
	XWD AB300A,304
	XWD AB300A,306
	XWD AB300A,344
	XWD AB300A,346
IFN HIBAUD,<
	XWD ABRFIN+LS600,215
	XWD ABRFIN+LS600,15
	XWD ABRFIN+LS1200,370
	XWD ABRFIN+LS1200,371
	XWD ABRFIN+LS1200,372	;parity bit on
	XWD ABRFIN+LS1200,360
	XWD ABRFIN+LS1200,361
	XWD ABRFIN+LS1200,362	;parity bit off
	XWD ABRFIN+LS1200,375
	XWD ABRFIN+LS1200,376
>;IFN HIBAUD
	0

AB110A::XWD AB110B,340
	XWD AB110B,360
	0
AB110B::XWD ABRFIN+LS110,0
	0

AB134A::XWD AB134B,360
	XWD ABRFIN+LS110,0	;SO WE GET OUT OF ABR IF STREAM OF <BREAK>'S
	0
AB134B::
IFN HIBAUD,<
	XWD ABRFIN+LS134,360
>;IFN HIBAUD
	0

AB300A::XWD ABRFIN+LS300,300
	XWD ABRFIN+LS300,340
	XWD ABRFIN+LS300,200	;BH WRONG PARITY OK
	0

AB150A::XWD AB150B,374
	XWD AB150B,376
	0
AB150B::XWD ABRFIN+LS150,0
	0

	DEPHASE
;DCA.Speeds NDCAGP CR1STD CR1NUL CR1TAB CR2STD CR2NUL K0.EXT K2.EXT CR2TAB

RADIX 5+5

DEFINE XSPD(GRP,S1,S2,S3,S4)<
	XSPD1(GRP,S1,S2,S3,S4,\S4/2,\S4/4,\S4/8)>
DEFINE XSPD1'(GRP,S1,S2,S3,S4,S5,S6,S7)<
	K'GRP'.EXT←←0
	.XXX ←← 1
	FOR @" SPD IN (S1,S2,S3,S4,S5,S6,S7)<
	K'GRP'."SPD←←.XXX
	.XXX ←← .XXX+1>
	FOR @" SPD IN (110,134,150,300,600,1200,1800,2400,4800,9600,55,75)<
	IFNDEF K'GRP'."SPD,<K'GRP'."SPD←←0>>>

COMMENT ⊗
DCA.Speeds: (FOR NDFAIL)

FOR SAIL:

GROUP	SPEED SELECTION
	0	1	2	3	4	5	6	7
0	EXT	150	55	75	1200	600	300	150
1	EXT	1200	1800	110	1200	600	300	150
2	EXT	300	150	110	9600	4800	2400	1200
3	EXT	300	150	110	9600	4800	2400	1200
4	EXT	300	150	110	9600	4800	2400	1200
5	EXT	300	150	110	9600	4800	2400	1200
6	EXT	300	150	110	9600	4800	2400	1200
7	NOT IMPLEMENTED.

FOR CCRMA:

GROUP	SPEED SELECTION
	0	1	2	3	4	5	6	7
0	EXT	300	150	1200	9600	4800	2400	1200
1	NOT IMPLEMENTED.

FOR LLL:

GROUP	SPEED SELECTION
	0	1	2	3	4	5	6	7
0	EXT	300	150	110	9600	4800	2400	1200
1:n-1	same as above

⊗

IFE FTF2,< NDCAGP←←=8		;Number of Groups
>;IFE FTF2
IFN FTF2,<
NDCAGP←←(SCNNUM+=15)/=16	;16 TTYs per group means this many groups
>;IFN FTF2

;; HERE IS THE TABLE OF CLOCK SPEEDS!!

IFE FTF2,<
XSPD (0,150,55,75,1200)
XSPD (1,1200,1800,110,1200)
XSPD (2,300,150,110,9600)
XSPD (3,300,150,110,9600)
XSPD (4,300,150,110,9600)
XSPD (5,300,150,110,9600)
XSPD (6,300,150,110,9600)
XSPD (7,300,150,110,9600)
>;IFE FTF2
IFN FTF2,<
IFN FTCCRMA,<
;We can have at most two TTY cards on an F2 at the present time.
;;;XSPD (0,150,300,110,9600)	;Split speed hardware bugs still not fixed.
XSPD (0,150,300,1200,9600)
XSPD (1,150,300,1200,9600)
printx	No 110 baud as split speed still broken.
K0.1200←←3	;Chose flavor of 1200 baud which works for split speed!
K1.1200←←3
>;IFN FTCCRMA
IFN FTLLL,<
FOR I←0,NDCAGP-1 <XSPD (I,150,300,110,9600)
>;FOR		;All groups have same speeds possible
>;IFN FTLLL
>;IFN FTF2

;TABLE OF CR1 (CONTROL REGISTER 1) CONTENTS INDEXED BY SPEED NUMBER

	CR1STD←←AS.NLB!AS.1SB!AS.REN!AS.RTS!AS.DTR	;STANDARD FORMAT
	CR1NUL←←AS.NLB!AS.BSO	;FORMAT FOR UNKNOWN SPEEDS

CR1TAB:
	CR1STD-AS.1SB		;110
	CR1NUL			;134.5
	CR1STD			;150
	CR1STD			;300
	CR1STD			;600
	CR1STD			;1200
	CR1STD			;1800
	CR1STD			;2400
	CR1STD			;4800
	CR1STD			;9600
	CR1STD			;1200/150 SPLIT SPEED
	CR1STD			;55
	CR1STD			;75
	CR1STD			;EXT
	CR1STD			;1800/1200 SPLIT SPEED

;TABLE OF CR2 VALUES INDEXED BY SPEED NUMBER (LDPSPD)

	CR2STD←←AS.RCL		;STANDARD SETTINGS (8 DATA BITS, NO PARITY)
	CR2NUL←←AS.RCL		;FOR LACK OF BETTER DEFAULT

; DEFINE Kn.EXT←←CR2STD FOR EACH GROUP FOR WHICH EXTERNAL CLOCK IS ALLOWED
K0.EXT←←CR2STD
K2.EXT←←CR2STD

FOR @' I←0,NDCAGP-1 <
CR2TB'I:
	CR2STD+K'I'.110		;110
	CR2NUL			;134.5
	CR2STD+K'I'.150		;150
	CR2STD+K'I'.300		;300
	CR2STD+K'I'.600		;600
	CR2STD+K'I'.1200	;1200
	CR2STD+K'I'.1800	;1800
	CR2STD+K'I'.2400	;2400
	CR2STD+K'I'.4800	;4800
	CR2STD+K'I'.9600	;9600
	K'I'.1200		;1200/150 SPLIT SPEED
	CR2STD+ASNDB(6)+K'I'.55	;55
	CR2STD+ASNDB(6)+K'I'.75	;75
	K'I'.EXT		;EXT
	K'I'.1800		;1800/1200 SPLIT SPEED
>;END FOR

CR2TAB:
IFE FTF2,<
	CR2TB0
	CR2TB1
	CR2TB2
	CR2TB3
	CR2TB4
	CR2TB5
	CR2TB6
	CR2TB7
>;IFE FTF2
IFN FTF2,<	;This should work for both, but i don't like to take chances.
FOR @' I←0,NDCAGP-1 <
	CR2TB'I
>;FOR
>;IFN FTF2

RADIX 4+4
;ASTRD0 ASTWR0 ASTRD2 ASTWR2 ASTRD4 ASTWR4 ASTRD6 ASTWR6 ASTRED ASTWRT ASTPRT KBDCHK KBDCH2

;NOTE THAT THESE ROUTINES MUST BE ENTERED IN SCNCHN OR WITH SCNOFF IN EFFECT.
ASTRD0:	JSP TAC,ASTRED		;READ REG0 (CONTROL REG 1)
ASTWR0:	JSP TAC,ASTWRT		;WRITE REG0
ASTRD2:	JSP TAC,ASTRED		;READ REG2 (CONTROL REG 2)
ASTWR2:	JSP TAC,ASTWRT		;WRITE REG2
ASTRD4:	JSP TAC,ASTRED		;READ REG4 (STATUS REG)
ASTWR4:	JSP TAC,ASTWRT		;WRITE REG4
ASTRD6:	JSP TAC,ASTRED		;READ REG6 (DATA)
ASTWR6:	JSP TAC,ASTWRT		;WRITE REG6

ASTRED:	SUBI TAC,ASTRD0+1	;REGISTER NUMBER IN TAC
	ADDI TAC,(AC1)		;ADD CHIP ADDR TO REGISTER NUMBER
IFE FTDLS,<
	CONO DCA,(TAC)		;LATCH THE ADDRESS TO THE BUS
	DATAI DCA,CHR		;READ THE POOP
>;IFE FTDLS
	POPJ P,

ASTWRT:	SUBI TAC,ASTWR0+1	;REGISTER NUMBER IN TAC
	ADDI TAC,(AC1)		;ADD CHIP ADDR TO REGISTER NUMBER
IFE FTDLS,<
	CONO DCA,(TAC)		;LATCH THE ADDRESS TO THE BUS
	DATAO DCA,CHR		;WRITE THE POOP
>;IFE FTDLS
	POPJ P,

;CALL ASTPRT WITH A PORT NUMBER IN LINE, RETURNS WITH CHIP SELECT FORMAT IN AC1

ASTPRT:	MOVEI AC1,(LINE)	;GET PORT NUMBER INTO AC1
	LSHC AC1,-4		;MOVE PORT NUMBER INTO AC2 (WHICH IS CLOBBERED)
	LSH AC1,1		;EXTRA BIT BETWEEN GROUP AND PORT
	LSHC AC1,4		;GET PORT BACK
	LSH AC1,3		;LEAVE ROOM FOR REGISTER
	ADDI AC1,K10CS+K10CS1	;ADD IN THE NECESSARY MAGIC BITS
	POPJ P,

IFE FTDLS,<
;Here at clock level once or twice per second to check another microswitch
;keyboard in case it has been plugged in recently and is now working.  Thus, we
;re-enable every down kbd once per KBDNUM (=64) seconds.  If the kbd we're
;checking here is down, then we enable it, first setting its framing error
;count to a small negative number (MAXBER).  If the framing error count
;reaches zero in CH5, then CH5 will turn the kbd off.  Maybe certain kbds,
;known to be permanently down forever, shouldn't get turned on once a
;minute, but we need another diddleable flag to indicate that state.  For
;now, we'll see how this works.  HGMAC(25) says how long here.  12/16/79 ME
↑↑KBDCHK:
	AOSL TAC1,KBDNXT	;Get number of next microswitch kbd to check
IFE FTF2,<
	CAIL TAC1,KBDNUM	;Off end?
>;IFE FTF2
IFN FTF2,<
	CAIL TAC1,DDNUM		;Off end?
>;IFN FTF2
	SETZB TAC1,KBDNXT	;Yes, start over
	ADDI TAC1,DCADP0	;Convert to DCA port number
	MOVE DDB,DCATAB(TAC1)	;Get DCA status
	TRNE DDB,DCADWN		;Kbd marked down?
	JRST KBDCH2		;Yes
	SKIPGE DCABER(TAC1)	;Have we recently turned this port on?
	SETZM DCABER(TAC1)	;Yes, assume OK now, after KBDNUM secs OK
	POPJ P,

KBDCH2:	MOVNI TAC,MAXBER	;Get max framing error count for disabling kbd
	MOVEM TAC,DCABER(TAC1)	; so that CH5 will turn off port after errors
	MOVEI TAC,400000(TAC1)	;Get BH-format port number
	PUSH P,TAC		;And save for second routine too
	PUSHJ P,DCAATT		;Re-enable this kbd
	POP P,TAC		;Get funny format port number again
	PUSHJ P,DCASPR		;Reset speed to default
	 JFCL			;Lost, huh?
	POPJ P,
>;IFE FTDLS
;DCAINI DCAIN1 DCAIN3 DCAIN2 DCA3MN DCA2MN DCA1MN DCANOW DCAHGL DCAHGN

↑↑DCAINI:
IFN FTDCHK,<
	SETOM CHKDCA		;NOT TYPING DEBUGGING INFO FOR ANYBODY NOW
>;IFN FTDCHK
IFN FTIRMA,<
	MOVEI TAC,IRMANO
	MOVEM TAC,IRMCNT	;INITIALIZE IRMA COUNT
	MOVE TAC,[IRMCNT,,IRMCNT+1]
	BLT TAC,IRMCNT+TTPLEN-1	;  FOR ALL TTYS
>;IFN FTIRMA
	SETZM DCABEG
	MOVE TAC,[DCABEG,,DCABEG+1]
	BLT TAC,DCAEND		;ZERO SOME DCA DATA
IFN FTDLS,<
	POPJ P,
>;IFN FTDLS
IFE FTDLS,<
	PUSH P,DDB
IFE FTDSYI,<
	CONO DCA,0		;RESET THE DCA SCANNER
	MOVEI TAC,ASTWAT	;WAIT A WHILE
	SOJG TAC,.
>;IFE FTDSYI
	CONO DCA,K10EN		;NOW TURN IT BACK ON
	MOVEI TAC,ASTWAT	;AND WAIT AGAIN
	SOJG TAC,.
	MOVSI LINE,-DCANUM	;AOBJN POINTER TO DCA TTY LINES
DCAIN1:	MOVE DDB,DCATAB(LINE)	;GET DCATAB ENTRY
	PUSHJ P,ASTPRT		;PORT NUMBER IN CHIP SELECT FORMAT IN AC1
	TRNE DDB,DCADWN		;IS THIS PORT DOWN IN INITIAL TABLE?
	JRST DCAIND		;YES, DON'T TRY TO SET SPEED
IFN FTDSYI,<
	TRNE DDB,DCADLB!DCAPRM	;EXEMPT FROM HANGUP PROTOCOL (dialnet or perm)?
	JRST DCAIN3		;YES, JUST SET ITS SPEED, HANG UP IF DTR OFF
	JUMPGE DDB,DCAIN3	;JUMP IF DTR OFF IN INITIAL TABLE -- HANG 'EM UP
	PUSHJ P,ASTRD4		;GET PORT'S STATUS
	TRNN CHR,AS.CAR!AS.DSR	;DOES IT THINK IT'S UP?
	JRST DCAIN3		;NO, SET INITIAL SPEED
	TRNE CHR,AS.CAR		;UPDATE OUR BITS
	TLO DDB,DCACAR!DCASYI	; AND INDICATE THIS CONDITION
	TRNE CHR,AS.DSR
	TLO DDB,DCADSR!DCASYI
	TLZ DDB,DBAUDM		;DON'T TRY TO BAUD DETECT
	MOVEM DDB,DCATAB(LINE)
	JRST DCAIN2		;DON'T SCREW UP SPEED
>;IFN FTDSYI - ELSE FALLS THROUGH

DCAIN3:	LDB CHR,DCASPD		;GET THE SPEED FOR THIS LINE
	PUSHJ P,ASTSPD		;SET SPEED IN HARDWARE
	MOVEI TAC,ABRIDL	;IDLE STATE FOR BAUD DETECT
	DPB TAC,DCABAU
DCAIN2:	AOBJN LINE,DCAIN1
	CONO DCA,K10EN!SCNCHN	;GIVE IT ITS PIA NOW
	POP P,DDB
IFN FTDSYI,<
	MOVSI TAC,$DCA2MN	;TWO MINUTES TO GO ROUTINE
DCA3MN:	TRO TAC,=60*JIFSEC	;WAIT A MINUTE (JUST BARELY FITS)
	CLKENQ(TAC)		;Plant clk req
>;IFN FTDSYI
	POPJ P,

DCAIND:	MOVEI CHR,0
	PUSHJ P,ASTWR0		;DAMMIT, STAY DOWN!
	JRST DCAIN2

IFN FTDSYI,<
↑↑DCA2MN:MOVSI LINE,-DCANUM	;LOOP THROUGH ALL DCA PORTS
DCA2ML:	SKIPL AC1,DCATAB(LINE)	;SKIP IF WE HAVE DTR ON
	TRNE AC1,DCADWN		;NO DTR, DO WE WANT THIS PORT DOWN?
DCA2MX:	AOBJN LINE,DCA2ML	;DTR ON OR FLAGGED DOWN, DO NOTHING
	JUMPGE LINE,DCA2MD	;JUMP IF ALL LOOPED OUT
	MOVEI TAC,400000(LINE)	;PRETEND TO BE TTYSER
	PUSHJ P,DCAPKU		;PICK UP DTR
	JRST DCA2MX

DCA2MD:	MOVSI TAC,$DCA1MN	;TWO MINS TO GO, WAIT FOR 1 MIN
	JRST DCA3MN

↑↑DCA1MN:MOVSI TAC,$DCANOW	;ONE MIN TO GO, WAIT FOR M-MINUTE
	JRST DCA3MN

↑↑DCANOW:MOVSI LINE,-DCANUM	;LOOP THROUGH ALL DCA PORTS
	MOVSI AC1,DCASYI	;BIT TO TEST
DCAHGL:	TDNN AC1,DCATAB(LINE)	;BIT SET?
DCAHGN:	AOBJN LINE,DCAHGL	;NO
	JUMPGE LINE,CPOPJ	;DONE WHEN NO MORE LINES
	MOVEI TAC,400000(LINE)	;PRETEND TO BE TTYSER
	PUSHJ P,DCAHNG		;HANG UP
	 JFCL			;CAN'T HANG UP THIS LINE, NO PHONE
	ANDCAM AC1,DCATAB(LINE)	;WE'VE DONE IT!
	JRST DCAHGN
>;IFN FTDSYI
>;IFE FTDLS

BEND DCASER
;DLSCLR DLSHLD DLSRST DLSRCF DLSDTR DLSCD DLSRI DLSDLB DLSNOX

IFN FTDLS,<	;Whole page

;DLS is a simulated DC-10 type scanner
;FTDLSM should be on to enable modem control from the CPU, if the microcode is ready.

;CONI bits (not used) (RH)
;DLSDTD←←1B30		;DTR Distend (Simulated as always on on F2)
;DLSRNT←←1B31		;Transmit interrupt (used in CONSZ chain)
;DLSXNT←←1B32		;Receive interrupt (used in CONSZ chain)
;Bits 33:35 are PI channel

;CONO bits (RH)
DLSCLR←←1B20		;Clear Scanner (as in IO Bus Reset)
DLSHLD←←1B21		;Ready Hold (ignored on F2)
DLSRST←←1B22		;Restart Scanner
;Bits 33:35 are PI channel

;DATAI bits (RH)
DLSRCF←←1B27		;DLS RECEIVER FLAG, DATAI WORD
;Caution, F2 doesn't set bit 30 in 5 bit mode, it uses bit 27 for everything

;DATAI - Modem Control Line (DC10E) instead of character
;*** Not yet implemented in F2 microcode as of Apr80
DLSDTR←←1B29		;Data Terminal Ready
DLSCD←←1B33		;Carrier Detect
DLSRI←←1B34		;Ring Indicator

;DATAO bits (half word bits)
DLSDLB←←1B11⊗-=18	;LH: Directed Line Bit (use line number in bits 12:17)
DC10E←←1B12⊗-=18	;LH: DATAO is to affect modem control of line in 12:17
DLSNOX←←1B27		;RH: Turn off Xmitter
;Caution, F2 doesn't check bit 30 in 5 bit mode, it uses bit 27 for everything

>;IFN FTDLS
;DLSINI DLSII2 DLSSPS DLSINT MCKRCV MCKNOI MCTBLS MCKDWN MCKDTP MCKDNT MCKDMT MCKDNM MCKSPC MCKSP2 NODLSP DLSIN1 DLSMDM DLSTYP

IFN FTF2,<	;Whole page
IFN FTDLS,<

;SERVICE ROUTINES FOR DC10 TYPE SCANNER ON F2

;Initialize DC10 type scanner (emulated on F2)
DLSINI:	CONO DLS,DLSCLR		;Clear the Scanner, just for grins
	MOVSI LINE,-DLSNUM	;Do this for each line
DLSII2:
IFN FTDLSM,<
	MOVSI TAC,DC10E!DLSDLB(LINE)
				;Setup corresponding DLS Line # and directed bit
	HRRI TAC,DLSDTR		;Activate (Data Terminal Ready)
	MOVEI CHR,(LINE)
	CAIGE CHR,NDC10E	;Is there modem control on this line?
	DATAO DLS,TAC		;Yes, set DTR
>;IFN FTDLSM
	LDB CHR,DCASPD		;Get speed index
	PUSHJ P,DLSSPS		;Set speed
	 PUSHJ P,DCASPY		;Lost
	AOBJN LINE,DLSII2	;Repeat for each line
	CONO DLS,SCNCHN!DLSRST	;Enable interrupts and restart scanner
	POPJ P,			;We're done!

;Here to set speed from index in CHR for port in LINE.
DLSSPS:	MOVSI TAC,(LINE)	;Port number in left half for baud set
	HRR TAC,DLSSPD(CHR)	;Get baud rate code
	TRNN TAC,-1		;This speed available?
	POPJ P,			;No, give error return
;Baud rate setting crock in F2
	CONI XDLS,TAC		;Not really a CONI!!! Set CR2 in ASTRO (??)
	JRST CPOPJ1

↑DLSINT:JSR SCNSAV
	DATAI DLS,CHR		;Try getting a character
	HLRZ LINE,CHR		;Extract line number
	CAIL LINE,DCANUM	;A PORT WE KNOW ABOUT?
	 JRST NODLSP		;NO, HOPE IT'S NOT BROKEN!
;;;	AOS DCAINN(LINE)	;Do it here to count all ints including XMT
	MOVSI DDB,DCASYI	;NO LONGER IN SYSINI PENDING MODE
	ANDCAB DDB,DCATAB(LINE)	;GET OUR FLAG WORD
	TRNE DDB,DCADWN		;HAS SOMEONE FLAGGED THIS GUY DOWN?
	JRST PORTDN		;YES, JUST COUNT DCAINN AND GO AWAY
	TRNN CHR,DLSRCF		;Was it a received character?
				;(Note, this will not work in 5 bit mode on DEC)
	JRST DLSIN1		;No, Xmitter flag
	CAIL LINE,DLSNUM	;Is it a reasonable number?
	JRST DLSMDM		;Maybe this is a modem interrupt
IFN DLNNUM,<
	TRNE DDB,DCADLB		;IS THIS A DIALNET PORT?
	JRST DILRCV		;YES, GO TO DLNSER NOT TTYSER
>;IFN DLNNUM
	LDB LINE,DCALIN		;Get TTY line number
IFN FTHG,<
	PUSHJ P,HG		;IN LOWCOR, clobbers TAC, collects system stats
>;IFN FTHG
IFE FTGRIN,<
	JRST RECINT		;Now process this normal char
>;IFE FTGRIN
>;IFN FTDLS
IFN FTGRIN,<
;	\ /
;Decode LLL Microswitch keyboard
MCKRCV:
IFE FTDLS,<
IFN FTHG,<
	PUSHJ P,HG		;IN LOWCOR, clobbers TAC, collects system stats
	LDB LINE,DCALIN		;Get line number corresponding actual terminal
				;(Actually a no-op on an F2, but we don't want
				;any suprises later.)
>;IFN FTHG
>;IFE FTDLS
IFN FTDLS,<
	HLL LINE,LINTAB(LINE)	;Get characteristics
	TLNN LINE,DDDLIN	;Is this a Microswitch kbd for Grinnell?
	  JRST RECINT		;No
>;IFN FTDLS
	MOVE AC1,CHR
	ANDI AC1,177		;Just data bits, flush rest, incl. up/down bit
	CAIL AC1,NMICKS		;Reasonable key number?
	  POPJ P,			;No, ignore for now

	HRRZ DDB,TTYTAB(LINE)	; PICK UP DDB ADR, IF ANY
	JUMPE DDB,MCKNOI	; NONE, FORGET IT
	LDB J,PJOBN		; PICK UP JOB NUMBER
	JUMPE J,MCKNOI		; NONE, SKIP INTERRUPT CHECK
	MOVEI AC2,INTKCH	; PLANT FUNNY KBD INTERRUPT IF NEEDED
	TDNN AC2,JBTIEN(J)	; IS HE ENABLED FOR IT?
	 JRST MCKNOI		; NO, EXIT NOW
	IORM AC2,JBTIRQ(J)	; YES, PLANT INTERRUPT
	TDNE AC2,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, RUN INTERRUPTS

MCKNOI:	IDIVI AC1,MCKBBW	;Turn key number into bit number in specific word
	MOVEI AC3,1		;A bit to shift to proper mask position
	LSH AC3,(AC2)		;This gives us bit in AC3, word index in AC1
	TRNN CHR,200		;Was this a down stroke?
	JRST MCKDWN		;Yes
	ANDCAM AC3,@MCTBLS(AC1)	;No, up.  Turn bit off for this key now up.
	POPJ P,			;That's all we do!

;Indirect table to separate arrays for individual words of microswitch kbd
;bits indicating keys that are currently held down.
MCTBLS:	LINE,,MCWD0-DDL0	;Ptr to table of first key group per microswitch kbd
	LINE,,MCWD1-DDL0	;            ... second ...
	LINE,,MCWD2-DDL0	;            ... third ...

;Here on downstroke from Microswitch kbd for Grinnell
MCKDWN:	IORM AC3,@MCTBLS(AC1)	;Turn on a bit somewhere for this key now down
;;If this isn't just a shifting key, then generate a character.
;;Generate character of this key (key number still in CHR) and add in various
;;shifting keys' values (CONTROL-META-TOP-SHIFT) to generate normal bucky char.
	ANDI CHR,177		;Flush up/down bit and any other non-key info
	SKIPN DAT,MCKTBL(CHR)	;Get key's translation table entry
	POPJ P,			;Unused or shifting key, no char to generate
	LDB TAC,MCSHF1		;Get current value of first shift key
	LDB DAT,MCSHF2		;Get current value of second shift key
	IORI TAC,(DAT)		;OR the shift keys together
	LDB DAT,MCCAPS		;Get current Caps-Lock value
	XORI TAC,(DAT)		;Complement shift value if Caps-Lock is down
	LDB DAT,MCTOP1		;Get current value of first top key
	JUMPN DAT,MCKDTP	;Jump if down
	LDB DAT,MCTOP2		;Get current value of second top key
	JUMPE DAT,MCKDNT	;Jump if up
MCKDTP:	IORI TAC,2		;Turn on the TOP bit
MCKDNT:	LDB UCHN,MCCTL1		;Get current value of first control key
	LDB DAT,MCCTL2		;Get current value of second control key
	IORI UCHN,(DAT)		;OR the meta keys together
	LDB DAT,MCMET1		;Get current value of first meta key
	JUMPN DAT,MCKDMT	;Jump if down
	LDB DAT,MCMET2		;Get current value of second meta key
	JUMPE DAT,MCKDNM	;Jump if up
MCKDMT:	IORI UCHN,2		;Turn on the META bit
;	\ /
;Now we have TOP-SHIFT in TAC (low order two bits) and META-CTRL in UCHN.
MCKDNM:	LDB DSER,MCKBYT		;IS THIS A SPECIAL CHAR?
	JUMPE DSER,MCKSP2	;JUMP IF SPECIAL CHAR
	LDB DAT,MCKBYT(TAC)
	ANDCMI TAC,1		;TOP ONLY
	LDB DSER,MCKBYT(TAC)	;UNSHIFTED CHAR.
	MOVEI CHR,(DAT)		;GET BACK SAVED CHAR.
	CAIE CHR,600		;EXCEPT FOR ↑C
	DPB UCHN,[POINT 2,CHR,28] ;GET BACK CONTROL BITS
	TRZA DSER,600		;NO CONTROL BITS HERE
MCKSPC:	  TRO CHR,10000		;MAKE IT SPECIAL
	LDB AC2,[POINT 6,CHR,35] ;Make AC2 look like SAIL microswitch keyboard
	DPB TAC,[POINT 2,AC2,29] ;TOP-SHIFT
	DPB UCHN,[POINT 2,AC2,27] ;META-CTRL
	HRROM LINE,PHYLIN	;Save physical line number for LINED
	JRST RECINC

;SEE WHETHER WE HAVE A SPECIAL CHAR OR AN UNDEFINED ONE -- HERE WITH DSER ZEROED
MCKSP2:	LDB CHR,MCKBYT+1	;Get converted character code (2nd byte for spcls)
	CAILE CHR,24		;Is it a macro key?
	  JRST MCKSPC		;  No, just turn on special bit
	MOVE AC1,CHR		;Key number from table is macro number
	JRST DOCRMC		;Do character macro (in VDPSER)
;Perhaps this should be done by setting special bit and decoding at SETES2+4
;but i'm not sure how that would interrupt with stuff entering from a PTY.
>;IFN FTGRIN

IFN FTDLS,<
NODLSP:	AOS NNODLS		;COUNT THESE INVALID PORT INTS
	POPJ P,

;Transmit interrupt.  Turn it off and let XMTINT worry about what to do
DLSIN1:	HRRI CHR,DLSNOX		;Set flags meaning turn off fool thing
	DATAO DLS,CHR		;Actually turn it off
	LDB LINE,DCALIN		;Get TTY line number
IFN DLNNUM,<
	TRNN DDB,DCADLB		;DIALNET PORT?
>;IFN DLNNUM
	JRST XMTINT		;NOTHING MORE FOR US TO DO
IFN DLNNUM,<
	MOVEI TAC,(LINE)
	JRST DLOINT		;YES, GO TO DLNSER
>;IFN DLNNUM

DLSMDM:	
IFN FTDLSM,<
	CAIL LINE,DC10E		;Modem control line?
	CAIL LINE,DC10E+NDC10E-1
	POPJ P,			;No, forget it
PRINTX DC10E interrupts are being ignored.
	POPJ P,			;**** Throw it away for now!!!
>;IFN FTDLSM

DLSTYP:	MOVSI TAC,DLSDLB(TAC)	;Port number and command bit for DLS
	HRRI TAC,(CHR)		;Character to type out
	DATAO DLS,TAC		;Output char, no offscn needed
	POPJ P,
>;IFN FTDLS
>;IFN FTF2
;MCKBYT MCKTBL NMICKS

IFN FTGRIN,<	;Whole page

MCKBYT:	POINT 9,MCKTBL(CHR),8
	POINT 9,MCKTBL(CHR),17
	POINT 9,MCKTBL(CHR),26
	POINT 9,MCKTBL(CHR),35

;Macro for letters
DEFINE MCKLT(A,B)<
BYTE(9)<"A">+40,<"A">,<"B">,<"B">
>

;Macro for non-letters
DEFINE MCKCH(A,B)<
BYTE(9)<"A">,<"A">,<"B">,<"B">
>

;Special chars (ESCAPE,CLEAR,BREAK) use second byte to hold internal WAITS rep.
;First byte zero means is special char.
DEFINE MCKSP(A)<
BYTE(9)0,A
>


;Table to map from Microswitch keyboard codes (allocated consecutively to
;consecutive keys, left to right, top to bottom) to Stanford ASCII.
;A zero entry means the key is used or is a shifting key (position recorded
;in MCWD0,1,2(LINE) or an unused key -- in any case zero means a key that
;does not generate a character for a program to read).  An entry with a
;leading zero byte is for a special key that gets the 10000 bit added to
;flag it as an out-of-band escape character (ESCAPE,BREAK,CLEAR); in this
;case, the second byte has the 9-bit value to which the 10000 bit is added.
;All other entries have the form:
;  BYTE(9)CHAR, SHIFT-CHAR, TOP-CHAR, TOP-SHIFT-CHAR
MCKTBL:	MCKSP(1)		;000	First of top row undefined keys (over 1)
	MCKSP(2)		;001
	MCKSP(3)		;002
	MCKSP(4)		;003
	MCKSP(5)		;004
	MCKSP(6)		;005
	MCKSP(7)		;006
	MCKSP(8.)		;007
	MCKSP(9.)		;010
	MCKSP(10.)		;011
	MCKSP(11.)		;012
	MCKSP(12.)		;013
	0			;014	Last of top row keys on main pad
	0			;015	First of three keys on pad at right
	0			;016	Middle key on pad at right
	MCKSP(41)		;017	Break
	MCKSP(42)		;020	Escape
	MCKCH(1,≡)		;021
	MCKCH(2,∩)		;022
	MCKCH(3,∪)		;023
	MCKCH(4,⊂)		;024
	MCKCH(5,⊃)		;025
	MCKCH(6,$)		;026
	MCKCH(7,%)		;027
	BYTE(9) <"8">,<"8">,32,32 ;030
	BYTE(9) <"9">,<"9">,30,30 ;031
	MCKCH(0,0)		;032
	MCKCH(+,|)		;033
	MCKCH(-,¬)		;034
	MCKCH(*,⊗)		;035
	BYTE(9) 600,600,600,600	;036	Call
	0			;037	First of three keys on pad at right
	0			;040	Middle of three keys on pad at right
	0			;041	Third of three keys on pad at right
	MCKSP(44)		;042	Clear
	BYTE(9) 175,175,175,175	;043	Altmode near upper left
	BYTE(9) 11,11,11,11	;044	Tab
	MCKLT(Q,∧)		;045
	MCKLT(W,∨)		;046
	BYTE(9) "e","E",100,100	;047
	MCKLT(R,#)		;050
	MCKLT(T,&)		;051
	BYTE(9) <"y">,<"Y">,42,42 ;052
	BYTE(9) "u","U",140,140	;053
	MCKLT(I,')		;054
	BYTE(9) "o","O",173,173	;055
	BYTE(9) "p","P",176,176	;056
	MCKCH(<(>,[)		;057
	MCKCH(<)>,<]>)		;060
	MCKCH(/,∂)		;061
	MCKCH(<\>,∞)		;062
	0			;063	First of three keys on pad at right
	0			;064	Middle of three keys on pad at right
	0			;065	Third of three keys on pad at right
	BYTE(9) 14,14,14,14	;066	FF
	BYTE(9) 13,13,13,13	;067	VT
	BYTE(9) 177,177,177,177	;070	BS
	MCKLT(A,≤)		;071
	MCKLT(S,≥)		;072
	BYTE(9) "d","D",74,74	;073
	BYTE(9) "f","F",76,76	;074
	MCKLT(G,≠)		;075
	MCKLT(H,=)		;076
	BYTE(9) "j","J",137,137	;077
	MCKLT(K,<→>)		;100
	MCKLT(L,<↔>)		;101
	MCKCH(<;>,↑)		;102
	MCKCH(:,↓)		;103
	BYTE(9) 15,15,15,15	;104	CR
	BYTE(9) 12,12,12,12	;105	LF
	0			;106	First of three keys on pad at right
	0			;107	Middle of three keys on pad at right
	0			;110	Third of three keys on pad at right
	0			;111	SHIFT key on left
	0			;112	TOP key on left
	MCKLT(Z,α)		;113
	MCKLT(X,β)		;114
	MCKLT(C,ε)		;115
	MCKLT(V,λ)		;116
	MCKLT(B,π)		;117
	MCKLT(N,∀)		;120
	MCKLT(M,∃)		;121
	MCKCH(<,>,!)		;122
	MCKCH(.,?)		;123
	0			;124	TOP key on right
	0			;125	SHIFT key on right
	BYTE(9) 175,175,175,175	;126	Altmode at lower right
	0			;127	First of three keys on pad at right
	0			;130	Middle of three keys on pad at right
	0			;131	Third of three keys on pad at right
	0			;132	CAPS LOCK
	0			;133	META key on left
	0			;134	CONTROL key on left
	BYTE(9) 40,40,40,40	;135	Space
	0			;136	CONTROL key on right
	0			;137	META key on right
	0			;140	REPEAT key
NMICKS←←.-MCKTBL	;Size of table

>;IFN FTGRIN
;SCNBU2 SCNBU4

↑SCNBU2:SYSPIFF
	EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /
SCNCNT WAS -2 OR LESS.  CALLER = /]
	DISARG LOC,SCNBUG
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	SETZM SCNCNT		;FIX IT I HOPE
	EXCH P,APRPDL
	SYSPIN
	JRST 2,@SCNBUG

↑SCNBU4:EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /
SCNCNT WAS ABOUT TO BECOME -2 OR LESS.  CALLER = /]
	DISARG LOC,SCNBU3
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	SETZM SCNCNT		;FIX IT I HOPE
	EXCH P,APRPDL
	JRST 2,@SCNBU3
;⊗ RECINT RECITY RECINC NOESC ESCRET PTYTST

;COMMON RECEIVER INTERRUPT FOR ALL KEYBOARD DEVICES

↑RECINT:HRROM LINE,PHYLIN	;Save physical line number for LINED
;Here from RECIMP for ITY, w/PHYLIN zeroed.
↑RECITY:ANDI CHR,377		;7 bits plus parity (EDIT bit on DMs)
	PUSHJ P,RECDM		;If we are a DM, do preprocessing
	 POPJ P,		;This DM char needs no more handling
	 MOVEI UCHN,0		;NO CONTROL BITS FROM MOST KEYBOARDS.
;Here from ESCCAL or RECNM1 or DKBINT or MCKSPC.
RECINC:	HLL LINE,LINTAB(LINE)	;Get line characteristics
	MOVE TAC,LINTAB(LINE)	;Get line mapped to
	HLL TAC,PRGESC(LINE)	;Get escape bits
	TRNE CHR,10000
	JRST SETESC		;ESCAPE TYPED.
;Here from SETESC, or from PTWR1C for PTY written to by owner.
NOESC:	TLNE TAC,REGESC+SPCESC
	JRST DOESC		;NON-ESCAPE AFTER ESCAPE SEEN.
↑ESCRET:HLL LINE,LINTAB(LINE)	;TEST TO SEE IF TTYS ARE LOCKED OUT
	SKIPE TTYLOK		;ARE WE IN LOCKOUT MODE?
	TLNE LINE,CTYLIN	;ALWAYS LET CTY BY
	JRST NOLOCK		;NO
	PUSHJ P,PTYTST		;IS IT ENABLED?
	 JRST NOLOCK		;YES
	POPJ P,			;NO

↑PTYTST:PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	MOVEI AC2,(LINE)
	IDIVI AC2,=36
	MOVN AC3,AC3		;NEGATE FOR USE IN SHIFTING
	MOVSI AC1,400000
	LSH AC1,(AC3)
	TDNN AC1,TTYENB(AC2)	;SKIP IF TTY IS ENABLED
	AOS -3(P)		;TAKE SKIP RETURN IF NOT ENABLED
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POPJ P,			;THIS TTY ISN'T ENABLED
;⊗ INIHOM NOLOCK NOLOK2 RECCHK RECFRE RECI00 RECIN0 RECIN1 RCBXIT

;HERE TO MAKE SURE PHYSICAL LINE NUMBER IN AC3 HAS A HOME.
INIHOM:	SKIPE AC3,PHYLIN	;RETURN IF NO PHYS TERMINAL TYPED THIS CHAR
	TLNN LINE,DDDLIN	;RETURN QUICK IF LOGICAL LINE ISN'T DD
	POPJ P,
	HLL AC3,LINTAB(AC3)	;GET BITS FOR PHYSICAL TERMINAL
	TLNN AC3,DDDLIN		;SKIP IF PHYS TERMINAL IS REALLY A DD
	POPJ P,			;NOT A DD
	LDB AC1,[HOMEPT(AC3)]	;SEE IF PHYS TERMINAL ALREADY HAS A HOME
	HLL AC1,LINTAB(AC1)	;CAN'T BE OUR HOME IF IT ISN'T A DD
	TLNN AC1,DDDLIN
	DPB LINE,[HOMEPT(AC3)]	;MAKE LOGICAL DD OUR HOME
	POPJ P,

NOLOCK:	LDB LINE,[POINT PUNITS,TAC,35] ;LINE←MAPPED LINE NUMBER.
NOLOK2:	MOVSI DDB,KILTTY	;PTYUUO output enters here for non-PTY
	ANDCAB DDB,TTYTAB(LINE)	;Don't let DDB be killed for now
	JUMPN DDB,RECIN1	;IS THERE A DDB FOR THIS LINE?
IFE FTF2,<
	CAIE LINE,APLINE	;FLUSH AP LINE IF NO DDB
	CAIN LINE,NYLINE	;FLUSH NY LINE TOO IF NO DDB.
	POPJ P,
;;	CAIE LINE,CANLIN	;Flush Canon TTY if not owned
	CAIN LINE,VDILIN	;Vadic dialer
	POPJ P,
>;IFE FTF2
	PUSH P,AC1		;AC1 MAY CONTAIN ARG FOR LINED
	PUSH P,AC2
	SKIPE AC2,PHYLIN	;NOW VIRTUALIZE IF THIS IS A DD!!
	SKIPE LETAB(LINE)	;UNLESS IT'S ALREADY IN USE
	JRST RECIN0		;DON'T REMAP THIS GUY
	HLL AC2,LINTAB(AC2)
	HLL LINE,LINTAB(LINE)	;BH 1/2/78 DON'T VIRTUALIZE IF DD MAPPED
IFE FTF2,<
	TLNE LINE,DDDLIN	;BH 1/2/78  TO NON-DD
	TLNN AC2,DDDLIN
	JRST RECIN0		;NOT A DD
	PUSHJ P,FINDDF		;GET NUMBER OF A FREE DD INTO AC1
RECCHK:	LDB AC3,[DDQREQ+AC1,,LSTESC] ;IS THIS LOGICAL DD ACTUALLY IN DD QUEUE?
	JUMPE AC3,RECFRE	;YES
	PUSHJ P,FINDDN		;NO, CAN'T USE THAT DD, FIND NEXT FREE ONE
	CAIGE AC1,DDL0+DDNUM	;DID WE REALLY FIND ONE?
	JRST RECCHK		;YES, MAKE SURE IT ISN'T IN THE DD QUEUE
	POP P,AC2		;NO!!  CAN'T FIND A FREE DD THAT ISN'T
	SUB P,[1,,1]		; IN THE QUEUE.  GIVE UP.
	AOS RECLUZ		;COUNT NUMBER OF TIMES WE HAVE LOST HERE!
	POPJ P,

RECFRE:	LDB AC3,[POINT PUNITS,LINTAB(AC2),35] ;GET LINE THAT THE KBD IS MAPPED TO
	HLL AC3,LINTAB(AC3)	;IS PHYS KBD MAPPED TO A FREE DD LINE?
	TLNE AC3,DDDLIN		;SKIP IF NOT DD LINE
	SKIPE LETAB(AC3)	;IS LINE MAPPED TO REALLY FREE?
	JRST RECI00		;NO
	DPB AC1,[POINT PUNITS,LINTAB(AC2),35] ;YES, MAP HIM TO NEW FREE DD
	MOVEM AC1,VDTIE-DDL0(AC2) ;TIE HIM THERE TOO
RECI00:	MOVEI LINE,(AC1)	;NOW GET DDB FOR FRESH DD LINE
>;IFE FTF2
RECIN0:	POP P,AC2
	PUSHJ P,DDBSRC		;FIND A DDB
	 JRST TYPX		;CAN'T
	HLL LINE,LINTAB(LINE)	;IF THIS IS A DD,
	PUSHJ P,INIHOM		; THEN MAKE SURE IT HAS A HOME
	POP P,AC1		;RESTORE POSSIBLE ESCAPE ARGUMENT
	SKIPA AC3,[APLINE]	;NO PREVIOUS RESPONSIBLE TTY
RECIN1:	LDB AC3,[DDQREQ+LINE,,LSTESC] ;SEE WHO WAS RESPONSIBLE
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,MERTP1		;TYPING ERROR MSG INTO INPUT BUFFER?
	POPJ P,			;YES, NO INPUT ALLOWED
	PUSHJ P,TAKRS2		;SET UP LINE BITS, TAKE RESPONSIBILITY

IFN FTPJOBN,<
;**REG BUG TRAP.  OCCASIONALLY A DDB WINDS UP WITH THE WRONG JOB NUMBER.
;**HERE WE LOOK FOR THAT AND HALT IF WE'RE LOSING.
	PUSH P,J
	MOVE J,DEVMOD(DDB)	;GET MODE BITS
	TLNN J,TTYATC
	JRST RCBXIT		;NOT IN USE AS A CONSOLE.
	LDB J,PJOBN		;GET JOB NUMBER OF THIS DDB
	JUMPE J,RCBXIT		;IF NONE, WE'RE OK.
	HRRZ J,JBTLIN(J)	;GET SUPPOSED LINE NUMBER FOR THIS JOB.
	CAIN J,(LINE)		;SHOULD MATCH
	JRST RCBXIT
	LDB J,PJOBN		;SUPPOSED JOB ON THIS TTY
	PUSHACS
	MOVE DAT,JBTLIN(J)	;LINE THAT JOB CLAIMS TO BE ON
	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /TPJOBN/
	PUSHJ P,DISERR
	[ASCIZ /AT RECIN1 WITH INCONSISTENT PJOBN OF TTY/]
	DISARG LOC,<LINE-20(P)>
	[ASCIZ /   PJOBN = /]
	DISARG DCP,<J-20(P)>
	[ASCIZ /   JBTLIN(PJOBN) = /]
	DISARG OCH,DAT
	-1
	PUSHJ P,DISCRL
	DEBCHECK(POPACS)	;CALL DDT IF DEBMOD SET
;hang up the phone, since dial tone seems to cause all the trouble
	HRRZ TAC,LINBIT(LINE)	;get DCA port + 400000 bit
	SKIPE TAC		;skip if not on DCA
	PUSHJ P,DCAHNG		;hang up that port
	 JFCL			;failed, not a phone
;now fix the mismatch
	MOVEI J,0		;AND THIS IS HOW WE FIX IT.
	DPB J,PJOBN		;WILL THE CURE BE WORSE THAN THE DISEASE?
RCBXIT:	POP P,J
;**END REG BUG TRAP
>;IFN FTPJOBN
	;FALL THRU TO NEXT PAGE
;RECIN8 RECINZ RECIM2 NOTDM

;FELL THRU FROM PREVIOUS PAGE
RECIN8:	TRNE CHR,10000		;BH 1/19/78 ALLOW ESCAPE COMMANDS
	JRST RECINZ
	TLNE LINE,TLKRNG	;IN A TALK RING?
	JRST DOTALK		;YES, GO TALK
RECINZ:	MOVE IOS,DEVIOS(DDB)	;SET UP IOS
	TLNE LINE,DDDLIN!DISLIN
	JRST KBDEDP		; IF A DPY, GO TO SMART EDITOR UNLESS PTLIP SET
	TRNE IOS,10
	TRNE IOS,6		;CHECK FOR MODES 10 OR 11
	TLNN LINE,DMLIN		;NOT IMAGE MODE, IS IT A DM?
	JRST .+2		;IMAGE MODE, OR NOT A DM
	JRST KBDEDP		;DM AND NOT IMAGE MODE, GO TO LINED
	TLNN LINE,PTYLIN	;Don't try so hard to kill PTYs
	TLNE IOS,KILREQ		;Skip unless clk req already in for TTYKIL
	JRST .+2
	PUSH P,[KBDKIL]		;Make POPJ consider TTYKIL
	TRNE CHR,10000
	POPJ P,			;DISCARD ESC COMMANDS ON NON-DISPLAYS
;*** BEGIN RPH HACK TO RUN DATAPHONES AS DATA DEVICES
	TLNE IOS,TPMON		;MONITOR HEAL THY SELF
	JRST NOSPMD		;NO SPECIAL MODE (IN CASE THIS IS HIS CONSOLE)
	LDB TAC,PIOMOD		;PICK UP IO MODE
	CAIE TAC,10		;SPECIAL "IMAGE" MODE?
	CAIN TAC,11		;ANOTHER SPECIAL MODE FOR AP WIRE
	JRST .+2
	JRST NOSPMD		;NOT AN IMAGE MODE.
	TLNE IOS,TTYHLD
	PUSHJ P,TTYUNH		;ALSO DON'T ALLOW HOLDING.
	MOVEI DAT,TTIBUF(DDB)
	TRO CHR,400		;BH 1/8/78 ENSURE NO NULLS IN INPUT BUFFER
	PUSHJ P,PUTCHI		;PUT CHARACTER DIRECTLY INTO INPUT BUFFER
	 JFCL			;IGNORE FAILURE
	MOVE DAT,FCTR(DAT)
	CAIE TAC,10		;INTERRUPT EVERY CHAR?
	CAIG DAT,TTICHR/2	;NO, HALF FULL YET?
	TLOA IOS,DDTM		;YES, ACTIVATE IT NOW
	JRST SNKTST		;DON'T ACTIVATE YET
	JRST RECIN4		;ACTIVATE, BUT NOT COMMAND DECODER
;⊗ BKYCHK NOSPMD BKYOFF BKYOK RECINB NOCALL

BKYCHK:	SKIPN PHYLIN		;If real line (funny map), then buckies OK
	TLNN LINE,PTYLIN	;Make sure real PTY (already know IMPBIT on)
	JRST BKYOK
	MOVE TAC,JOB		;Must be uuo, see who
IFN FTIP,<
	CONSO PI,77400		;Skip if any PI in progress - must be ITY "server"
>;IFN FTIP
	CAMN TAC,PTYJOB-PTYL0(LINE) ;OK to write buckies if not actual owner
	JRST BKYOFF		;Server can't write buckies (directly)
	JRST BKYOK		;Not server program (e.g., DO), allow buckies

NOSPMD:	JUMPE CHR,CPOPJ		;BH 1/8/78 NOT IMAGE, FLUSH NULLS
;*** END RPH HACK TO RUN DATAPHONES (SEE PREVIOUS PAGE)
	ANDI CHR,777		;NO EXTRANEOUS BITS EVER
	TLNE LINE,IMPBIT	;IF IMP PTY, THEN CAN'T WRITE BUCKIES
	JRST BKYCHK		; unless we're not the real owner (e.g., DO)
	SKIPE PHYLIN		;PTY WRITE CAN WRITE BUCKIES
BKYOFF:	TDZA UCHN,UCHN		;really no parity bit!
	JRST BKYOK		;let bucky bits stay
	ANDI CHR,177		;BH FLUSH PARITY BIT
BKYOK:
repeat 0,<
	MOVE TAC,IMLHAC(DDB)	;↑C ISN'T CALL IF ↑← PENDING
	TRNN TAC,DELHBT		;INTERCHANGING 010 AND 177?
	JRST NODELH		;NO
	TLNN LINE,IMPBIT
	TLNN LINE,PTYLIN
	JRST .+2
	JRST NODELH		;NON-ARPA PTYS ARE NOT AFFECTED BY NO DELETE
	CAIE CHR,177		;YES, DO WE HAVE ONE OF THESE BSes?
	CAIN CHR,010		;EITHER ONE? (BUT MUST NOT HAVE BUCKY BITS!)
	TRC CHR,177≠010		;YES, CONVERT TO OTHER TYPE!!
;NODELH:
>;repeat 0
	TRNE TAC,BNPEND!BNCNTL!BNMETA ;NOR IF BUCKY BITS PENDING
	JRST NOCALL		;YES, QUOTE FOLLOWING CALL
	TRNE CHR,177
	CAIN CHR,3		;CONTROL C?
RECINB:	PUSHJ P,CNCTST		;yes, see if 2nd control-C (LINED/LECCN enters here)
NOCALL:	PUSHJ P,CONVRT		;CONVERT SOME CHARACTERS DEPENDING ON POM
	LDB HPOS,PHPOS		;PICK UP HORIZONTAL POSITION OF OUTPUT CHAR.
	MOVEI DAT,TTIBUF(DDB)	;USER MODE INPUT BUFFER
	PUSHJ P,TTEDIT		;GO EDIT (AND ECHO) CHARACTER
	 JRST TYPTST		;JUST START OUTPUT FOR ↑← CMD, holding, etc.
	TRNN IOS,NOECHO		;IF WE ECHOED IT,
	DPB HPOS,PHPOS		;STORE HORIZONTAL POSITION
	TLNE IOS,TTYHLD		;IF TYPEOUT IS HOLDING
	PUSHJ P,TTYUNH		;THEN UNHOLD (any input char unholds)
	HLLM LINE,LINTAB(LINE)	;UPDATE LINE TABLE
	MOVE TAC,TIFCTR(DDB)	;FREE SPACES LEFT
	CAIG TAC,2		;if only one space left, activate everything
	JRST [	TLO IOS,SYNC	;activate now
		MOVEM IOS,DEVIOS(DDB) ;what poor design to have to store bits
		JRST RECIN3]	; everytime you change them
	TLNN IOS,SYNC!DDTM	;WAS A BREAK CHARACTER TYPED?
	JRST SNKTST		;NO, GO SEE IF ECHO NEED BE TYPED
	TLNN IOS,SYNC		;DON'T CRANK UP CH7 UNLESS SYNC CHAR.
	JRST RECIN4
;RECIN3 RECIN4 SNKWAK UTYPET TYPTST TYPT2 SNKTST

RECIN3:	MOVSI TAC,COMBIT	;IS IT IN COMMAND WAIT NOW?
	TDNN TAC,TTYTAB(LINE)	;..
	PUSHJ P,COMSET		;NO, WAKE UP COMMAND DECODER NOW
RECIN4:	MOVEI DAT,TTIBUF(DDB)	;SET FOR SYNCHA
	TLZE IOS,SYNC!DDTM	;ACTIVATION CHAR.?
	PUSHJ P,SYNCHA		;UPDATE ACTIVATED CHAR. COUNT
				;CLEAR SYNC IN CORE
IFN FTESCCBUG,< SCPICK >	;CHECK PI STATUS
	MOVEM IOS,DEVIOS(DDB)	; ..
	MOVE TAC,TIPCTR(DDB)	;UPDATE COUNTER FOR ↑U
	DPB TAC,PLSTLC
	TLNE IOS,TPMON		;NO INTERRUPTS IN MONITOR MODE.
	JRST TYPTST
	LDB J,PJOBN		;PICK UP JOB NUMBER
	MOVSI AC1,INTTTY	;GIVE HIM A TTY INTERRUPT IF DESIRED
	TDNE AC1,JBTIEN(J)	;IS HE ENABLED FOR IT?
	PUSHJ P,TTINT		;YES, DO IT.
	TLZN IOS,TTYIOW		;IN TELETYPE INPUT WAIT?
	JRST TYPTST		;NO, GO ECHO
SNKWAK:	PUSHJ P,STTIOD		;YES, SET IO DONE (OUT OF TTY IOW)
	PUSHJ P,STXTIM		;UPDATE INTERACTION RUN TIME (XTIME)
	MOVSI IOS,IOW!TTYIOW!SNKWAT
	ANDCAB IOS,DEVIOS(DDB)	;CLEAR WAIT BITS
↑UTYPET:
TYPTST:	TLNE IOS,TTYDTC
	POPJ P,			;FLUSH IF DETACHED
	PUSHJ P,STLNAC		;CLOBBERED BY STTIOD
↑TYPT2:	TLNE LINE,DMLIN
	PUSHJ P,DPYST2		;Plant clock req for DPYTYP unless holding
	TLNE LINE,PTYLIN	;IS THIS A PTY
	JRST PTOCK		;YES, JUST GO CHECK PTY STUFF
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TOIP		;TYPE OUT HAPPENING?
	JRST SCNONJ
	MOVSI IOS,TOIP
	IORB IOS,DEVIOS(DDB)	;NO, BUT THERE IS NOW
	ONSCN			;TURN ON SCANNER CHANNEL
	TLNN IOS,TTYDTC		;DON'T TYPE IF HE'S DETACHED...
	JRST XMTIN1		;START OUTPUT
	POPJ P,

SNKTST:	TLNN IOS,TPMON		;DON'T WAKE USER FOR SNK IF TTY IN MONITOR MODE
	TLNN IOS,SNKWAT		;IS USER IN SNEAK WAIT?
	JRST TYPTST		;NO, PROCEED NORMALLY
	JRST SNKWAK
;⊗ CONVRT RECINY NODELH RTILDE RECIMK RECIM3 RECINN RECIN6 RECIM4

;CALL CONVRT TO DO INPUT ASCII-SAIL CONVERSION AS APPROPRIATE FOR TERMINAL
;TYPE AND USER OPTIONS

;Here from NOCALL and DOTALK.
CONVRT:	SKIPN HPOS,PHYLIN	;GET PHYSICAL TYPER
	JRST RECIMK		;NONE.  DON'T DEASCIIFY UNLESS IMP PTY
	HLL HPOS,LINTAB(HPOS)	;GET TYPER'S BITS
	TLNE HPOS,DDDLIN!DISLIN!DMLIN ;A DISPLAY?
	JRST RECIM3		;YES, THE CHARS ARE ALREADY SAILIFIED
RECINY:	MOVE HPOS,IMLHAC(DDB)	;NOT TYPED BY A DPY. USER WANT CONVERSION?
	TRNE HPOS,CVTBIT	;BIT MUST BE ON TO AVOID CONVERSION
	JRST RECINN		;NO
	TRNN HPOS,DELHBT	;INTERCHANGING 010 AND 177?
	JRST NODELH		;NO
	TLNE LINE,PTYLIN
	TLNE LINE,IMPBIT
	JRST .+2
	JRST NODELH		;NON-ARPA PTYS ARE NOT AFFECTED BY NO DELETE
	CAIE CHR,177		;YES, DO WE HAVE ONE OF THESE BSes?
	CAIN CHR,010		;EITHER ONE? (BUT MUST NOT HAVE BUCKY BITS!)
	TRC CHR,177≠010		;YES, CONVERT TO OTHER TYPE!!
NODELH:	CAIN CHR,176		;TELNET SERVER CONVERSION FOR IMP PTYS
RTILDE←←400000			;FLAG FOR SPCHEK THAT THIS IS REAL TILDE
	MOVEI CHR,RTILDE!32	;TILDE (FLAG NOT EOF (↑Z))
	CAIN CHR,175
	MOVEI CHR,176		;RIGHT BRACE
	CAIE CHR,30
	CAIN CHR,137
	SKIPA HPOS,DPYDES(LINE)
	JRST RECIN6		;TEST FOR ALTMODE
	TLNN HPOS,LEFTAR	;Does this terminal display left arrow?
	TRC CHR,30≠137		;No, interchange left arrow and underscore
	POPJ P,

RECIMK:	TLNE LINE,PTYLIN	;IS IT an IMP PTY?
	TLNN LINE,IMPBIT	;skip if IMP PTY
	JRST RECIM3		;NO, NO CONVERSION
	MOVE HPOS,JOB		;WHO IS WRITING THIS PTY STUFF?
IFN FTIP,<
	CONSO PI,77400		;Skip if any PI in progress - must be ITY "server"
>;IFN FTIP
	CAMN HPOS,PTYJOB-PTYL0(LINE) ;YES, IS WRITER THE PTY'S OWNER?
	JRST RECINY
RECIM3:	CAIN CHR,32		;PTY WRITE NOT BY TELNET SERVER
	MOVEI CHR,RTILDE!32	;SO 32 IS A TILDE, NOT AN EOF
	JRST RECIM4

RECINN:
repeat 0,< ;Whose altmodes are 176 these days, anyway? -- ME 1/21/87
	MOVE HPOS,IMLHAC(DDB)	;GET CONV BIT
	TRNN HPOS,CVTBIT
	JRST RECIN6		;NO CONV, LEAVE ALTMODES ALONE
	TLNN LINE,PTYLIN	;PTY'S WILL BE SENDING RIGHT CURLY BRACKET
	CAIE CHR,176
>;repeat 0
RECIN6:	CAIN CHR,33		;CONVERT OLD LOSING ALTMODES INTO NEW.
	MOVEI CHR,175
RECIM4:	CAIN CHR,612		;IS THIS AN EOF COMING THROUGH A PTY?
	MOVEI CHR,32		;YES, TURN IT INTO A CONTROL-Z FOR TTEDIT
	CAIN CHR,1175		;IS THIS AN ALTMODE GENERATED BY CNCTST?
	MOVEI CHR,175		;YES, CLEAR THE FLAG BIT
	POPJ P,			;END OF INPUT CHARACTER CONVERSION
;TYPGO2 TYPGO TYPGO3 RWARN TTINT STXTM3 STXTIM STXTM2 STXTMA

TYPGO2:	MOVE IOS,DEVIOS(DDB)	;HERE FROM TTYMES TO ALWAYS START OUTPUT
	TLNN IOS,TTYDTC
	JRST TYPGO3		;EVEN IF DESTINATION TTY "SUPPRESSING" OUTPUT
	POPJ P,

↑TYPGO:	MOVE IOS,DEVIOS(DDB)
	TDNE IOS,[TTYDTC,,IOSUPR]
	POPJ P,			;FLUSH OUTPUT
TYPGO3:	PUSHJ P,STLNAC
	MOVSI IOS,IO
	OFFSCN			;TURN OFF SCANNER CHANNEL
	IORB IOS,DEVIOS(DDB)
	PUSHJ P,TYPTST
	JRST SCNONJ

REPEAT 0,< ;Obsolete feature flushed 12/2/79. Setting DDTM is disasterous in TPMON,
	   ;especially for PTYs.  If you bring it back, fix it for PTYs, please.
;HERE WHEN ONLY A LITTLE SPACE LEFT IN INPUT BUFFER
RWARN:	TLO IOS,DDTM		;ACTIVATE EVERYTHING SO FAR
	TLNE LINE,FULTWX!PTYLIN!DISLIN!DMLIN!DDDLIN ;CAN LINE BE STOPPED?
	JRST RECIN4		;NO. WAKE JOB AND CROSS FINGERS.
	MOVEI CHR,23		;YES. SEND AN XOFF.
	PUSHJ P,PUTCHO
	MOVEI CHR,IDLECH	;AND AN IDLE FOR TTY TO THINK ON.
	PUSHJ P,PUTCHO		;OUTPUT IT.
	JRST RECIN4		;GO WAKE JOB.
>;REPEAT 0

↑TTINT:	IORM AC1,JBTIRQ(J)	;(ALSO CALLED FROM ELFSER AND WHOSER)
	TDNN AC1,JBTMSK(J)	;ANY BIT MASKED ON?
	POPJ P,
	SETOM INTREQ		;YES, RUN INTERRUPTS
	HLLOS CLKFLG
	CONO PI,4000!1⊗(7-CLKCHN)
	CONO PI,0
	POPJ P,

STXTM3:	SKIPA J,JOB		;ENTER HERE FROM SNEAKW
STXTIM:	LDB J,PJOBN		;GET JOB NUMBER
;Entry point from run-job code (MSTART) and INTR14
↑STXTM2:JUMPE J,CPOPJ		;IF NO JOB, NO XTIME
IFN FT2LVL,<
IFN FTMTRACT,<
	SKIPL MTRBKG		;SKIP IF METER IN ACCOUNTING MODE
	JRST STXTMA
	LSH J,1
	PUSH P,TAC1
	DMOVE TAC,MTRTTIME(J)
	PUSHJ P,MTRCVT		;CONVERT TO TICKS IN TAC
	POP P,TAC1
	LSH J,-1
	CAIA
STXTMA:
>;IFN FTMTRACT
	MOVE TAC,TTIME(J)
	MOVEM TAC,LXRTIM(J)	;STORE RUN TIME AT LAST INTERACTION
>;IFN FT2LVL
	MOVSI TAC,NOXRST
	TDNE TAC,JBTMSC(J)	;IS NO-UPDATE BIT ON?
	POPJ P,			;YES.  DONT DO ANYTHING!
	MOVE TAC,TTIME(J)	;PICK UP CURRENT RUN TIME
	MOVEM TAC,XTIME(J)	;UPDATE INTERACTION RUN TIME
IFN FTMTRACT,<
	LSH J,1
	MOVE TAC,MTRTTIME(J)
	MOVEM TAC,MTRXTIME(J)
	MOVE TAC,MTRTTIME+1(J)
	MOVEM TAC,MTRXTIME+1(J)
	LSH J,-1
>;IFN FTMTRACT
	SKIPGE TAC,JBTWAT(J)	;PICK UP WAIT TIME
	ADD TAC,UPTIME		;MAKE IT HONEST
	MOVEM TAC,JB2WAT(J)	;AND SAVE IT
	HRLS DSKOPS(J)		;SAVE CURRENT NUMBER OF DISK OPERATIONS
	POPJ P,
;Escape.bits REGESC SPCESC DBLESC ESCNEG ESCTYP ESCARG ESCFLD ESCNUL LSHESC ESCTYP ESCARG ESCFLD ESCNUL LSHESC ESCMAX ESCOCS ESCOCT

COMMENT ⊗
Escape.bits: ⊗

;DEFINITIONS FOR ESCAPE PROCESSOR
;ALL THIS STUFF GOES IN LH(PRGESC)

REGESC←←400000	;NORMAL ESCAPE TYPED
SPCESC←←200000	;SPECIAL--"Add META bit to next char" if DM
DBLESC←←REGESC!SPCESC ;BOTH ESCAPE BITS ON MEANS WE ARE COLLECTING PPN
ESCNEG←←100000	;NEGATION FLAG (BREAK, ETC.)

;Macro to obtain left half of byte pointer as an expression (<POINT A,B,C>) does
;not do the right thing in FAIL
	DEFINE HPOINT(A,B,C) <<<POINT A,B,C>/1B17>&777777>
ESCTYP←←HPOINT 2,0,1		;BYTE PNTR FOR TYPE BITS (now in left half)
ESCARG←←HPOINT 15,0,17		;EVERYTHING ELSE IS ARG
ESCFLD←←HPOINT 18,0,17		;WHOLE ESCAPE FLD
↑ESCNUL←←40000			;SPECIAL VAL USED FOR NULL (ZERO SOMETIMES LEGAL)
LSHESC←←0			;Number of bits to right of esc field in half wd
ESCMAX←←ESCNUL-1		;MAX LEGAL VALUE

;REMEMBER THAT ARG WE READ IN IN DECIMAL? WELL, WE REALLY WANTED
;TO READ IT IN OCTAL, SEE, SO . . .

ESCOCS:	AOS (P)
↑ESCOCT:SKIPGE ESCDIF		;Arg already in proper radix?
	POPJ P,			;Yes, must be repeated command
	IDIVI AC1,=100
	IDIVI AC2,=10
	LSH AC2,3
	ADD AC2,AC3
	LSH AC1,6
	ADD AC1,AC2
	SKIPN ESCDIF		;Maybe don't want to diddle repeated arg
	DPB AC1,NUMESC		;Save arg in proper radix for this LINE
	POPJ P,
;ESCCAL ESCCA5 ESCCA4 BRKCA3 DDQBEE ESCCCK ESCCC2 ESCCOK BRKCAL BRKCA2 DDUNKI DDUNK4 DDUNK0 DDUNK2 DDUNK3 DMESCC DMESP1 DMESCP

;DD CHANNEL QUEUEING--USES QUEUE IN LSTESC TABLE
;DDQLNK FIELD OF LSTESC WORD -1 IS USED AS THE QUEUE HEADER,
;  ALWAYS AT THE FRONT OF THE QUEUE
;ANY TTY THAT DOESN'T HAVE A DDB MUST HAVE ZERO IN ITS DDQLNK FIELD!

ESCCAL:	HLL LINE,LINTAB(LINE)
	TLNE LINE,DMLIN
	JRST DMESCC		;DM ESC CALL IS DEFERRED CALL
IFN FTF2,<
	POPJ P,
>;IFN FTF2
IFE FTF2,<
	TLNN LINE,DDDLIN
	POPJ P,			;NOT ON DD - FORGET IT
	SKIPN PHYLIN
	POPJ P,			;DON'T LET PTYUUO ENTER US IN DD QUEUE
IFN FTESCCBUG,< SCPICK >	;CHECK PI STATUS
	JUMPL AC1,BRKCAL	;IT WAS BREAK CALL - GO PROCESS IT
	PUSHJ P,ESCCCK		;ESC CALL -- SEE IF ALREADY IN LIST
	 JRST DDQBEE		;ALREADY IN LIST, JUST BEEP TO SAY OK
;Here with ESC CALL when not already in list.  Enter us in list.
	PUSHJ P,FINDDF		;FIND A FREE DD
	DPB AC1,[POINT PUNITS,LINTAB(LINE),35] ;AND MAP US TO FREE DD
	MOVEM AC1,VDTIE-DDL0(LINE) ;ALSO TIE US THERE
	HRREI TAC,-DDL0(LINE)	;ARG FOR VDOUT
	PUSHJ P,VDOUT		;CHANGE HIS SCREEN
	MOVE AC2,DDFLST
	CAIE AC2,DDELNK		;SKIP IF THERE ARE NO CHANNELS AVAILABLE
	JRST RECINC		;CHAN AVAIL - NO NEED TO QUEUE - DO "CALL"
ESCCA5:	LDB AC3,[DDQREQ+AC1,,LSTESC] ;IS THIS SLOT ALREADY USED IN QUEUE?
	JUMPE AC3,ESCCA4	;NO, USE IT NOW
	CAIGE AC1,DDL0+DDNUM-1	;YES, FIND ANOTHER
	AOJA AC1,ESCCA5
	POPJ P,			;NO MORE SLOTS LEFT, SORRY CAN'T QUEUE YOU

ESCCA4:	MOVE AC2,DDQTAI
	DPB AC1,[DDQLNK+AC2,,LSTESC] ;POINT OLD TAIL TO NEW Q ENTRY
	HRRZM AC1,DDQTAI	;POINT TAIL POINTER TO NEW TAIL
	DPB LINE,[DDQREQ+AC1,,LSTESC] ;MOVE IN REQUESTING KBD
	AOS AC2,DDQSIZ		;KEEP COUNT OF SIZE OF QUEUE
BRKCA3:	CAIG AC2,LWHDDQ+1	;Will this change length of displayed queue?
	SETOM WHOKLU		;Yes, force updating of displayed queue
DDQBEE:	HRRZ TAC,LINE		;WHO TO BEEP (REQUESTOR)
	JRST BEEPAW		;GO BEEP AND RETURN

;Routine to find our entry, if any, in DD wait queue. Skips if not in list.
ESCCCK:	SETO AC1,		;POINT TO DD QUEUE HEADER
IFN FTESCCBUG,<
	MOVE TAC,DDQSIZ		;SIZE OF QUEUE
>
ESCCC2:	MOVE AC3,AC1
	LDB AC1,[DDQLNK+AC3,,LSTESC] ;GET POINTER TO NEXT DD IN QUEUE
	JUMPE AC1,CPOPJ1	;END OF LIST--WE HAVEN'T ASKED FOR A DD
IFN FTESCCBUG,<
	JUMPG TAC,ESCCOK
	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/DD Channel Wait Queue inconsistent with claimed size.
DDQSIZ = /]
	DISARG DCP,DDQSIZ
	[ASCIZ/
LSTESC-1 = /]
	DISARG OCH,<LSTESC-1>
	-1
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	SOSGE DDQSIZ		;Random guess that it is too big,
	SETZM DDQSIZ		;But don't let it be negative
	MOVEI AC1,0		; 'cause someone made us point to self!
	DPB AC1,[DDQLNK+AC3,,LSTESC] ;Zero the last link, maybe that'll fix it
	SYSPIN
	JRST CPOPJ1		;Take error return
ESCCOK:
>
	LDB AC2,[DDQREQ+AC1,,LSTESC] ;GET REQUESTING DD
	CAIE AC2,(LINE)		;IS IT US?
IFN FTESCCBUG,<
	SOJA TAC,ESCCC2
>
IFE FTESCCBUG,<
	JRST ESCCC2		;NO, KEEP LOOKING
>
	POPJ P,			;RETURN WITH OUR ENTRY IN AC1, PREV IN AC3

;BREAK CALL here to remove us from DD wait queue.
BRKCAL:	PUSHJ P,ESCCCK		;Find our entry, if any, in DD queue
	 JRST BRKCA2		;Got it, now flush it
	POPJ P,			;Not in list
	
BRKCA2:	LDB AC2,[DDQLNK+AC1,,LSTESC] ;GET NEXT LINK
	DPB AC2,[DDQLNK+AC3,,LSTESC] ;LINK AROUND DELETED ENTRY
	JUMPN AC2,.+2
	HRRZM AC3,DDQTAI	;SET NEW TAIL POINTER, IF DELETED TAIL
	MOVEI AC2,0
	DPB AC2,[DDQLNK+AC1,,LSTESC] ;ZERO QUEUE LINK FIELD
	DPB AC2,[DDQREQ+AC1,,LSTESC] ;ZERO QUEUE REQ. FIELD
	SOS DDQSIZ
	LDB TAC,[POINT PUNITS,LINTAB(LINE),35] ;GET LINE MAPPED TO -- CLEAR SPCESC
	MOVE AC2,VDTIE-DDL0(LINE) ;GET LINE TIED TO
	CAIN TAC,(AC2)		;NO FREE ESC M IF NOT TIED WHERE MAPPED
	SKIPE LETAB(TAC)	;NOR IF MAPPED TO LINE NOT AVAILABLE
	JRST .+2
	PUSHJ P,VDESM1		;DO A FREE ESC M COMMAND
	MOVE AC2,DDQSIZ
	AOJA AC2,BRKCA3		;Update queue display and beep this guy

;ESC n ! gets you DD channel n, iff it was previously hard detached or free.
;ESC ! gets you the highest numbered hard-detached DD channel, if any.
;must be on a DD terminal.
;Either of these, if successful, maps you to the DD line that gets the DD channel.
↑DDUNKI:HLL LINE,LINTAB(LINE)	;get bits
	SKIPE PHYLIN		;only allowed from physical DD terminal
	TLNN LINE,DDDLIN	;skip if DD terminal
	POPJ P,			;forget it
	CAIN AC1,ESCNUL
	JRST DDUNK0		;no arg, look for a det channel
	JUMPL AC1,CPOPJ		;jump if BREAK (undefined cmd)
	PUSHJ P,ESCOCT		;convert argument to octal (was read as decimal)
	CAIL AC1,40		;asking for particular channel
	POPJ P,			;no such chan
	MOVEI TAC,(AC1)		;get chan nbr
	LDB AC1,[DDUSR+<(TAC)>]	;get use code for specified chan
	CAIN AC1,DDDETU		;detached?
	JRST DDUNK3		;yup, get it the hard way
	JUMPN AC1,CPOPJ		;jump (i.e., give up) if channel in use
	HRROM TAC,DDSPCH	;set this as channel to use next in DPYMAK
DDUNK4:	PUSHJ P,FINDDF		;find a free virtual DD
	DPB AC1,[POINT PUNITS,LINTAB(LINE),35] ;map us to free DD
	MOVEM AC1,VDTIE-DDL0(LINE) ;also tie us there
	MOVEI CHR,177		;Give him a backspace
	MOVEI DSER,177		;Unshifted char
	MOVEI UCHN,0		;No bucky bits
	JRST RECINC		;pretend he just typed char, claim spcl channel

;here only to deal with a hard detached channel.
;there may or may not be a DD wait queue.
DDUNK0:	MOVEI TAC,40-1		;look thru DD table backwards for first hard det chan
DDUNK2:	LDB AC1,[DDUSR+<(TAC)>]	;get use code
	CAIE AC1,DDDETU		;detached?
	SOJGE TAC,DDUNK2	;nope
	JUMPL TAC,CPOPJ		;no det channels to use
;now the bad DD chan we want is in TAC
DDUNK3:	MOVEI AC1,DDKILL	;clear auto-detach bit on this channel
	ANDCAM AC1,DDTAB(TAC)	;  so DDREL doesn't just re-detach it now
	HRROM TAC,DDSPCH	;make sure we get the channel (for DDREL,DPYMAK)
	HRLI TAC,DDDETU		;use code for detached channel
	PUSHJ P,DDREL		;go release channel, thus undetaching it
	MOVEI AC1,DDKILL	;plant auto-detach bit on this channel
	IORM AC1,DDTAB(TAC)	;  so that it goes away again later
	JRST DDUNK4		;go claim the newly available channel
>;IFE FTF2

DMESCC:	MOVEI CHR,600		;ESC CALL on DM, fake a CONTROL-CALL
DMESP1:	MOVEI UCHN,1
	JRST ESCRET

DMESCP:	HLL LINE,LINTAB(LINE)	;ESC PI on DM is unhold
	TLNN LINE,DMLIN
	POPJ P,			;But just on DM!
	MOVEI CHR,10044		;Control-clear
	JRST DMESP1
;DMMETA DMESC DMBONG TYPDM DMACON DMAMET DMACMT DMACM2 SETESC SETES2 SETES3 STDESC STDES1 STDES2

;HERE ON <ESC>,<BREAK>, OR <CLEAR> (ALSO FUNNY CHARS FROM PTYS)
;ESCAPE CODE BITS ARE SET UP FOR NEXT TIME

DMMETA:	SKIPA AC3,[SPCESC⊗-LSHESC+ESCNUL]
DMESC:	MOVEI AC3,REGESC⊗-LSHESC+ESCNUL		;<ESC>
	MOVEI AC1,0
	DPB AC1,NEBBPT		;clear the bucky bit prefix
	SKIPN AC1,LETAB(LINE)	;Gotta have dpy header to type ESC or META on DM
↑DMBONG:TDZA AC3,AC3
	SETOM LEACT(AC1)	;But if you got one, we'll let you keep it a while
	DPB AC3,[ESCFLD,,PRGESC(LINE)]
	JUMPN AC3,CPOPJ
	MOVEI CHR,7		;Output a bell to tell user bye
	SETZ DDB,
	HLL LINE,LINTAB(LINE)	;Get line characteristics
TYPDM:	TLNN LINE,PTYLIN	;Don't output if pty
	JRST TYPDM2
	POPJ P,

;Here from escape commands that want to set up particular bucky bits for next char.
;Only meaningful on individual displays (EDIT or NOEDIT).
;On NOEDIT display, also causes next char to be quoted.
DMACON:	MOVEI AC1,1		;CONTROL bit to be added
	JRST DMACM2

DMAMET:	SKIPA AC1,[2]		;META bit to be added
DMACMT:	MOVEI AC1,3		;CONTROL and META bits to be added to next char
DMACM2:	DPB AC1,NEBBPT		;store bits for next char
	POPJ P,

SETESC:	CAIN CHR,10044
	JRST NOESC		;<CLEAR> ISN'T REALLY AN ESC CHR
	MOVEI AC3,0
	CAIN CHR,10042
	MOVEI AC3,REGESC⊗-LSHESC+ESCNUL		;<ESC>
	CAIN CHR,10041
	JRST [	CAIN UCHN,1	;WATCH OUT FOR CTRL-BRK
		TROA DSER,400000 ;Make sure DSER doesn't match any ESC char below
		MOVEI AC3,<REGESC+ESCNEG>⊗-LSHESC+ESCNUL ;BREAK
		JRST .+1]
	CAIN AC2,1641
	MOVEI AC3,SPCESC⊗-LSHESC+ESCNUL
SETES2:	DPB AC3,[ESCFLD,,PRGESC(LINE)] ;DOEPPN COMES HERE TO SET BOTH ESC BITS
	JUMPN AC3,CPOPJ		;EXIT IF ESC CHR
IFN FTFBI,<
	PUSHJ P,FBI		;I don't think you're supposed to be able to get
	 JFCL 5			;  here any more, but if someone does, record it
>;IFN FTFBI
	HLRE AC1,CHR
	JUMPLE AC1,SETES3
	CAILE AC1,ESCMAX
	MOVEI AC1,ESCMAX
;** Of course, if the arg is negative, then it fails to get range checked
SETES3:	JUMPN AC1,.+2
	MOVEI AC1,ESCNUL	;ELSE MAP 10XXX→<ESC>XXX, 14XXX→<BRK>XXX
	TRNE CHR,4000		;(EASIER FORM FOR PTYUUO'S)
	MOVN AC1,AC1
	SETZM GOTARG		;PTYUUOS CAN'T DISTINGUISH BETWEEN 0 AND NULL ARG
STDESC:	CAIN CHR,600
	JRST ESCCAL		;ESC/BRK CALL -- DD CHAN QUEUEING
IFE FTF2,<
	CAIN CHR,10044
	JRST ESCCLR		;ESC/BRK CLEAR -- SET OR CLEAR HOME AND RESP
>;IFE FTF2
	CAIN DSER,177
	POPJ P,			;ESC BS IS A NO-OP
	SETZM ESCDIF		;No incremented/decremented esc arg
STDES1:
IFN FTGRIN,<
	printx	ESC A,D,S,T probably should not be excluded for F2
	;;;;;;	They could do the III function of turning off/on POGs
>;IFN FTGRIN
IFE FTF2,<
	CAIN DSER,"a"
	JRST VDESCA		;ADD CHANNEL
	CAIN DSER,"d"
	JRST VDESCD		;DELETE CHANNEL
	CAIN DSER,"s"
	JRST VDESCS		;SELECT CHANNEL
	CAIN DSER,"t"
	JRST VDESCT		;SELECT TEMPORARY CHANNEL
	CAIN DSER,"k"
	JRST VDESCK		;select given broadcast TV channel (video/audio)
	CAIN DSER,"u"
	JRST ASESC		;AUDIO SWITCH CHANNEL SELECT
	CAIN DSER,"b"
	JRST ESCB		;AUDIO SWITCH UNBEEPER
	CAIN DSER,"m"
	JRST VDESCM		;DD LINE MAPPING
	CAIN DSER,"!"
	JRST DDUNKI		;UNKILL A DD CHANNEL, OR CLAIM PARTICULAR CHAN
>;IFE FTF2
	CAIN DSER,"↑"
	JRST DMACON		;DM add-CONTROL-bit cmd
	CAIE DSER,176		;ASCII tilde
	CAIN DSER,32		;SAIL tilde
	JRST DMAMET		;DM add-META-bit cmd
	CAIN DSER,"%"
	JRST DMACMT		;DM add-CONTROL-META-bits cmd
	CAIN DSER,"'"
	JRST DMMODE		;SET DM QUOTE/EDIT MODE
	CAIN DSER,"β"
	JRST DMESCC		;DM QUOTE MODE DEFERRED CALL
	CAIN DSER,"π"
	JRST DMESCP		;DM QUOTE MODE UNHOLD
	CAIN DSER,15		;ESC # CR is a macro call
	JRST DOCRMC		;Expand macro, if arg within range (in VDPSER)
IFE FTF2,<
	TLNN TAC,SPCESC		;SPECIAL BREAK IS ALWAYS FOR US
	JUMPGE AC1,STDES2	;ESC L,G,R are FOR LINE EDITOR TO DO,
	CAIN DSER,"l"		;  BUT BREAK L IS FOR US
	JRST VDESCL		;  AND SETS VDTIE
	CAIN DSER,"g"		;BREAK G IS FOR US (ESC G IS FOR LINED)
	JRST VDESCG		;TIE TO NEXT DD OF SAME PROGRAMMER
	CAIN DSER,"r"		;BREAK R IS FOR US (ESC R IS FOR LINED)
	JRST VDESCR		;MOVE TO NEXT DD WE'RE RESPONSIBLE FOR
>;IFE FTF2
STDES2:	TRO CHR,10000		;PASS IT ON TO LINED W/ARG IN SIGN-MAGNITUDE
	MOVE AC2,GOTARG
	SETOM GOTARG		;Assume we have a non-null argument
	CAIN AC1,ESCNUL
	SETZB AC1,GOTARG	;Null arg
	SKIPN AC2		;skip if BREAK (GOTARG set to 1 by DOESC2)
	JUMPGE AC1,ESCRET
	MOVN AC1,AC1
	CAIN AC1,ESCNUL
	SETZB AC1,GOTARG	;Null arg
	HRLI AC1,400000		;Set sign indicating BREAK cmd
	JRST ESCRET
;DOESC DOESC1 NOESCN DOESC2 ESCXIT ESCDSP DOESTR DOEPLS DOESCN DOESNT DOEPN DOEPRG DOEPR1 DOEPR2 PRESC0 PRESC PRESC2 PRESC3 PRESCW ESCREP ESCRP0

;HERE ON NEXT CHAR AFTER ESCAPE. ANY ARG IS ACCUMULATED LEAVING ESC BITS SET.
;OTHER CHARS CLEAR BITS (LEAVING ESCAPE MODE) AND DISPATCH TO APPROP HANDLER

DOESC:	LDB AC1,[ESCARG,,TAC]	;GET PREVIOUS ARGUMENT GIVEN (DECIMAL)
	LDB AC2,[ESCTYP,,TAC]	;AND TYPE OF ESCAPE
	CAIN AC2,3		;ARE WE READING A PROGRAMMER NAME?
	JRST DOEPRG		;YES, THIS MAY BE PART OF IT OR MAY END IT
	CAIL DSER,"0"		;PART OF A NUMERIC ARG?
	CAILE DSER,"9"
	JRST DOESC1		;NO
	CAIN AC1,ESCNUL		;YES
	TDZA AC1,AC1		;NO PREVIOUS ARG--ADD TO ZERO
	IMULI AC1,12		;SHIFT PREV ARG LEFT ONE DECIMAL DIGIT
	ADDI AC1,-"0"(DSER)	;ADD NEW DIGIT
	CAILE AC1,ESCMAX	;TOO BIG?
	MOVEI AC1,ESCMAX	;YES, CLIP TO MAX
	DPB AC1,[ESCARG,,PRGESC(LINE)] ;REMEMBER ARGUMENT
	POPJ P,

DOESC1:	CAIN DSER,"-"
	JRST DOESCN		;INVERT SIGN--CHANGE ESC TO BRK, OR BRK TO ESC
NOESCN:	CAIN DSER,"*"
	JRST DOESTR		;Wants to repeat previous ESC cmd
	CAIN DSER,"+"
	JRST DOEPLS		;Wants to incr/decr arg and repeat prev ESC cmd
	CAIN DSER,"["
	JRST DOEPN		;Want to specify Programmer Name to map to
	CAIN DSER,177		;ESC/BRK BS is a noop--don't remember for repeating
	JRST ESCXIT	
	CAIN DSER,'"'+40
	JRST DMQESC		;DM QUOTE-ESCAPE MESS
	MOVEI AC3,0		;Assume ESCAPE
	TLNE TAC,ESCNEG		;Really BREAK?
	MOVEI AC3,1		;Yes
	CAIE AC1,ESCNUL		;If no numeric arg, don't remember command
	SKIPLE MACROC		;Don't remember arg if coming from macro either
	JRST DOESC2		;No arg or macro, don't remember for ESC */+
	DPB AC1,NUMESC		;Remember arg for repeating
	DPB DSER,CHRESC		;Remember ESC char for repeating
	DPB AC3,SGNESC		;Remember sign bit for repeating
DOESC2:	TLNE TAC,ESCNEG		;BREAK cmd?
	MOVN AC1,AC1		;Yes, make argument negative
	MOVEM AC3,GOTARG	;Allow STDES2 to distinguish explicit BREAK 0 cmd
ESCXIT:	ANDI TAC,1⊗PUNITS-1	;Leave just line mapped to in TAC
	HRRZS PRGESC(LINE)	;CLEAR THE ESCAPE BITS AND ARG
	JRST @ESCDSP(AC2)	;NOTE AC2 IS NON-ZERO OR WE WOULDN'T BE HERE


	ESCREP			;Repeating escape command, maybe incr/decr
ESCDSP:	ESCRET			;Shouldn't ever dispatch thru here
	SPESC			;Magic escape
	STDESC			;Standard escape
	PRESC			;Programmer name escape
	PRESC0			;Magic programmer name escape


DOESTR:	HRLOI AC2,0		;"Increment" previous arg by 0
	TLNN TAC,ESCNEG		;BREAK?
	JRST ESCXIT
	LDB AC3,SGNESC		;Yes
	TRC AC3,1		;Change sign for repeat
	DPB AC3,SGNESC
	JRST ESCXIT

DOEPLS:	HRLOI AC2,1		;Increment previous arg by 1
	TLNE TAC,ESCNEG
	HRLOI AC2,-1		;"Increment" previous arg by -1
	JRST ESCXIT

DOESCN:	JUMPN UCHN,NOESCN	;If bucky bits on "-", then this is HOLD cmd (DM).
DOESNT:	MOVSI TAC,ESCNEG
	XORM TAC,PRGESC(LINE)
	POPJ P,

DOEPN:	HLLZS PRGESC(LINE)	;Clear half-word where programmer name is collected
	MOVEI AC3,DBLESC⊗-LSHESC+ESCNUL ;Set both escape bits
	CAIN AC2,1		;Magic?
	ADDI AC3,ESCNEG⊗-LSHESC	;Yes, flag that for later
	JRST SETES2

;Here with character typed after ESC [.
DOEPRG:	TLNE TAC,ESCNEG		;Magic?
	ADDI AC2,1		;Yes, remember that by changing dispatch
	JUMPN UCHN,ESCXIT	;Bucky bits terminate programmer name
	CAIL DSER,"0"
	CAILE DSER,"9"
	JRST DOEPR1		;Not digit
	JRST DOEPR2		;A digit

DOEPR1:	CAIL DSER,"a"
	CAILE DSER,"z"
	JRST ESCXIT		;Not digit or letter, must be terminator
	SUBI DSER,40		;Make upper case to enable conversion to sixbit
DOEPR2:	HRRZ AC2,PRGESC(LINE)	;Get previous part of programmer name
	LSH AC2,6
	ADDI AC2,-40(DSER)	;Add in new char
	HRRM AC2,PRGESC(LINE)	;And remember it
	POPJ P,

;Here with character terminating programmer name of ESC [ command.
PRESC0:	TLO TAC,SPCESC		;Flag magic command!
PRESC:	HRRZ AC2,PRGESC(LINE)	;Get (right justified already) programmer name
	MOVEI AC1,0		;Starting job number to look beyond
	MOVEI AC3,1		;Job number increment
PRESC2:	PUSH P,TAC		;Preserve status of magic bit
	PUSHJ P,ESCQX		;Find a job of this programmer name (no wraparound)
	 SKIPA CHR,JBTLIN(AC1)	;Get job's line number
	JRST TPOPJ		;No such job
	POP P,TAC
	CAIN DSER,"w"
	JRST PRESCW		;Get wholine for programmer's job
IFE FTF2,<
	PUSHJ P,VDESMY		;See if job is on a DD not hidden from us
	 SKIPA AC2,LINTAB(LINE)	;Ok, get typer's line bits
	JRST PRESC2		;Sorry, hidden from us or not a DD, look again
	TLNN AC2,DDDLIN		;These programmer name escapes only for DDs
	POPJ P,
	CAIE DSER,"]"
PRESC3:	CAIN DSER,"m"		;Enter here from VDESM5
	JRST VDESM2		;Map to programmer's DD
	CAIE DSER,"g"
	CAIN DSER,"l"
	JRST VDESL3		;Tie to programmer's DD
>;IFE FTF2
	POPJ P,			;Undefined termination char

PRESCW:	MOVEI CHR,10000+"w"	;Pass ESC # W to LINED
	SETOM GOTARG		;Use explicit argument
	JRST ESCRET

ESCREP:	HLRE AC2,AC2		;Make fullword value of argument increment
	LDB AC1,NUMESC		;Get previous argument (8 bits, unsigned)
	JUMPE AC2,ESCRP0	;Preserve condition of no argument if no increment
	CAIN AC1,ESCNUL
	SETZ AC1,		;Pretend his previous null arg was actually zero
	ADD AC1,AC2		;Form new arg value
	JUMPGE AC1,.+2
	SETZ AC1,		;Don't allow going down from zero
	DPB AC1,NUMESC		;Store new arg
ESCRP0:	LDB AC2,SGNESC		;Get previous sign bit
	SETZM GOTARG
	CAIE AC1,ESCNUL
	MOVEM AC2,GOTARG	;Allow STDES2 to distinguish explicit BREAK 0 cmd
	JUMPE AC2,.+2
	MOVN AC1,AC1
	SETOM ESCDIF		;Flag arg as not needing radix conversion
	LDB DSER,CHRESC		;Get last command,
	JUMPN DSER,STDES1	;and process it, if there is any.
	POPJ P,			;No old command, do nothing
;⊗ SPESC SPESC2 ESCCLR TAKRSP TAKRS2 BRKCLR BRKCL2 BRKCL3 VDESCM VDESM7 VDESM6 VDESM2 VDESCL VDESL2 VDESL3 VDESL1 VDESM1 VDESM3 VDESCR VDESCG VDESM4 VDESM5 VDESMY VDESY2 VDESMX VDESX2

SPESC:	TLO TAC,SPCESC
IFN FTDDT,<
	CAIN CHR,600
	CAIE UCHN,3
	JRST SPESC2
	CAIN AC1,=98
	SKIPN AC2,PHYLIN	;No PTYs please
	POPJ P,
	HLL AC2,LINTAB(AC2)
	TLNN AC2,DISLIN!DDDLIN	;DDs and IIIs only
	POPJ P,
	PUSHJ P,DISGST
	PUSHJ P,DISERR
	 [ASCIZ/Quick stop. Phys line = /]
	 DISARG LOC,PHYLIN
	 [ASCIZ/  /]
	 -1
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	POPJ P,			;DON'T YOU DARE OPTIMIZE THIS BY JRST DDTCAL

SPESC2:
>;FTDDT
	CAIE CHR,600+"P"
	JRST STDESC
	MOVEI AC2,0
	DPB AC2,CHRESC
	CAIN AC1,=98
	JRST TTSE98
	SETZM ESCDIF		;Force radix conversion to octal
	PUSHJ P,ESCOCT
	CAIL AC1,TTPLEN
	MOVEI AC1,(LINE)
	DPB AC1,[POINT PUNITS,LINTAB(LINE),35]
	HRRZS PRGESC(LINE)	;Clear escape bits and arg
	POPJ P,

IFE FTF2,<
;ESCAPE CLEAR makes the DD you are mapped to your home terminal.
ESCCLR:
repeat 0,<
	SKIPN AC3,PHYLIN	;WHO TYPED THIS REALLY?
	POPJ P,			;NO ONE
	HLL AC3,LINTAB(AC3)
	TLNN AC3,DDDLIN		;Skip if typed from DD
	POPJ P,			;Don't let IIIs do this (DM's can't type it)
	JUMPL AC1,BRKCLR
>;repeat 0
repeat 1,<
	SKIPE AC3,PHYLIN	;WHO TYPED THIS REALLY?
	HLL AC3,LINTAB(AC3)	;get line bits if physical terminal
	JUMPL AC1,BRKCLR	;allow Break Clear from any terminal
	TLNN AC3,DDDLIN		;Skip if typed from DD
	POPJ P,			;Don't let IIIs do this (DM's can't type it)
>;repeat 1
	SKIPN LETAB(TAC)	;Look at mapped-to line
	POPJ P,			;Can't be home, since not in use
	MOVE AC1,LINTAB(TAC)	;Make sure it's a DD
	TLNN AC1,DDDLIN
	POPJ P,
	DPB TAC,[HOMEPT(LINE)]	;Make this our home, then take responsibility
	MOVE LINE,TAC		;Mapped-to line number
>;IFE FTF2
;Routine to give current typer responsibility for currently mapped-to line.
;Call with logical line in LINE, typer's line in PHYLIN.
TAKRSP:	LDB AC3,[DDQREQ+LINE,,LSTESC]	;SEE WHO WAS RESPONSIBLE
TAKRS2:	HLL LINE,LINTAB(LINE)		;SET UP LINE CHARACTERISTICS
	HRRO AC3,AC3			;DUPLICATE LH OF PHYLIN IF REAL PHY TTY
	SKIPE PHYLIN			;GET PHYSICAL LINE NUMBER OF TYPIST
	CAMN AC3,PHYLIN
	POPJ P,				;NO CHANGE TO RESPONSIBLE TTY
	PUSH P,AC1
	DPB AC3,[DDQLNK+LINE,,LSTESC]	;REMEMBER PREVIOUS RESPONSIBLE TTY
	PUSHJ P,INIHOM			;SET AC3 TO PHYLIN -- ENSURE IT HAS A HOME
	DPB AC3,[DDQREQ+LINE,,LSTESC]	;REMEMBER NEW RESPONSIBLE TTY
	POP P,AC1
	POPJ P,

IFE FTF2,<
;BREAK CLEAR -- disavow responsibility and map to home.
; If mapped to a non-DD, resets the responsibility of the non-DD to itself.
; If mapped from a non-DD, maps the mapped line back to itself.
; If mapped from a DD to a DD, makes mapped DD not responsible for the DD it was
;TIED to and also makes that DD not the home, then does ESC M to map to home.
>;repeat 1
BRKCLR:
repeat 1,<
	LDB AC2,[POINT PUNITS,LINTAB(LINE),35] ;get line mapped to
	HLL AC2,LINTAB(AC2)	     ;see if mapped to a DD
	TLNN AC2,DDDLIN		     ;skip if mapped to DD
	DPB AC2,[DDQREQ+AC2,,LSTESC] ;make non-DD mappee line responsible for itself
	TLNE AC3,DDDLIN		     ;Skip if typed from non-DD
	JRST BRKCL3		     ;BRK CLR from a DD
	DPB LINE,[POINT PUNITS,LINTAB(LINE),35] ;map non-DD back to itself
	POPJ P,

;Here for DD that's mapped to non-DD.
BRKCL2:	MOVEI AC1,(TAC)		     ;map DD to line it was tied to
	JRST VDESM2		     ;change map

;Here if BREAK CLR typed on DD.
BRKCL3:
>;repeat 1
	SKIPE TAC,VDTIE-DDL0(AC3)    ;Get line number where terminal is tied
	SKIPN LETAB(TAC)	     ;He can't be responsible if line not in use
	JRST VDESM3		     ;Just do an ESC M
repeat 1,<
	TLNN AC2,DDDLIN		     ;skip if mapped to DD
	JRST BRKCL2		     ;not mapped to DD, don't change screen
>;repeat 1
	LDB AC2,[DDQLNK+TAC,,LSTESC] ;GET PREVIOUS USER KBD FOR THIS LINE
	CAIN AC2,(AC3)		     ;IS TYPER THE PREVIOUS USER?
	MOVEI AC2,APLINE	     ;YES, MAYBE MAKE NO ONE RESPONSIBLE
	DPB AC2,[DDQLNK+TAC,,LSTESC] ;Don't even let user be previously responsible
	LDB AC1,[DDQREQ+TAC,,LSTESC] ;GET CURRENT USER KBD FOR THIS LINE
	CAIN AC1,(AC3)		     ;IS TYPER RESPONSIBLE?
	DPB AC2,[DDQREQ+TAC,,LSTESC] ;YES, MAKE PREV USER RESPONSIBLE AGAIN
	LDB AC2,[HOMEPT(AC3)]	     ;GET KBD'S HOME TTY
	MOVEI AC1,0		     ;This depends on TTY0 not being a DD
	CAIN AC2,(TAC)		     ;IS HOME THE ONE HE'S DISAVOWING RESP FOR?
	DPB AC1,[HOMEPT(AC3)]	     ;YES, DISAVOW HOMENESS HERE TOO
	JRST VDESM3		     ;NOW DO ESC M TO MAP TO (POSSIBLY) NEW HOME

VDESCM:	HLL LINE,LINTAB(LINE)	;BH 12/4/74 USER KBD MAP COMMAND
	CAIN AC1,ESCNUL
	JRST VDESM1		;ESC M--MAP BACK TO HOME TERMINAL
	TLNN LINE,DDDLIN	;OTHER MAPPING ONLY ALLOWED FROM DD TERMINAL
	POPJ P,
	JUMPGE AC1,VDESM7	;JUMP IF ESCAPE
	MOVM AC1,AC1		;BREAK -- GET POSITIVE ARGUMENT
	CAIN AC1,ESCNUL		;NULL ARGUMENT?
	JRST VDESM4		;YES, BREAK M MEANS FIND NEXT JOB SAME PRG - BH
VDESM7:	PUSHJ P,ESCOCT		;CONVERT ARG (LINE NUMBER) TO OCTAL
	CAIL AC1,DDL0		;ONLY CAN MAP TO DD LINES
	CAIL AC1,DDL0+DDNUM
	POPJ P,			;NOT DD LINE
VDESM6:	PUSHJ P,VDESMX		;CHECK IF ALLOWED
	 POPJ P,
VDESM2:	DPB AC1,[POINT PUNITS,LINTAB(LINE),35] ;OK, MAP HIM WHERE HE ASKED
	HRRZS PRGESC(LINE)	;Clear esc bits and arg
	MOVEI AC1,ESCNUL	;12/8/74 NOW SWITCH HIS SCREEN TOO
VDESCL:	MOVM AC1,AC1		;BREAK N L LOOKS AT LINE N
	CAIN AC1,ESCNUL
	JRST VDESL1		;  OR THE ONE YOU'RE MAPPED TO
	PUSHJ P,ESCOCT		;CONVERT ARG (LINE NUMBER) TO OCTAL
VDESL2:	CAIL AC1,DDL0		;CHECK ARG FOR RANGE
	CAIL AC1,DDL0+DDNUM
	POPJ P,			;CAN'T TIE TO A NON-DD LINE
	PUSHJ P,VDESMX		;SEE IF LINE IS HIDDEN
	 POPJ P,
VDESL3:	MOVEI TAC,-DDL0(LINE)	;ALSO CHECK WHO IS GIVING THE COMMAND
	JUMPL TAC,CPOPJ
	CAIL TAC,DDNUM
	POPJ P,			;CAN'T TIE FROM A NON-DD LINE
	MOVEM AC1,VDTIE(TAC)	;WIN, TIE HIM TO THE ARGUMENT
	JRST VDOUT		;REALLY DO IT

VDESL1:	LDB AC1,[POINT PUNITS,LINTAB(LINE),35] ;GET LINE MAPPED TO
	TLO TAC,SPCESC		;LET HIM TIE WHEREVER ALREADY MAPPED (IF DD)
	JRST VDESL2

;ESCAPE M here to map us to home DD.
VDESM1:	MOVEI AC1,(LINE)	;Use own line
	TLNN LINE,DDDLIN	;If he's not on a DD,
	JRST VDESM2		; then always let him map to himself
VDESM3:	LDB AC1,[HOMEPT(LINE)]	;Get home DD
	HLL AC1,LINTAB(AC1)
	TLNE AC1,DDDLIN		;Make sure it's really a DD
	JRST VDESM2		;Ok, map there
	HRROI AC2,(LINE)	;Keyboard to find some DD responsible to
	PUSHJ P,FINDDD		;Find DD, ignoring DDs in wait queue
	SKIPE LETAB(AC1)	;Did we find a real one in use?
	DPB AC1,[HOMEPT(LINE)]	;Yes, make it our home
	JRST VDESM2		;Map there anyway

;BREAK R here to map us to next DD we're responsible for, if any, else to free DD.
VDESCR:	HLL LINE,LINTAB(LINE)
	TLNN LINE,DDDLIN
	POPJ P,			;NOT ON DD, IGNORE CMD
	MOVE AC2,LINTAB(TAC)
	TLNN AC2,DDDLIN		;If we're not mapped to a DD,
	SKIPA AC1,[DDL0-1]	; then start looking from first DD
	MOVEI AC1,(TAC)		;Look starting from where we're mapped now
	MOVEI AC2,(LINE)	;Look for DD responsible to our phys line
	SKIPN LETAB(TAC)	;If mapped to not-in-use line (prob DD),
	HRLI AC2,400000		;  then avoid lines in DD queue in FINDD1
	PUSHJ P,FINDD1		;Find nearest DD responsible to us
	JRST VDESM2		;Now map and tie us there

;BREAK G HERE TO TIE TO NEXT DD OF SAME PROGRAMMER.
;BREAK M ENTERS AT VDESM4 TO MAP TO NEXT DD OF SAME PROGRAMMER.
VDESCG:	MOVM AC1,AC1
	CAIE AC1,ESCNUL
	JRST VDESCL		;NON NULL ARG--DO BREAK # L INSTEAD
	HLL LINE,LINTAB(LINE)	
	TLNE LINE,DDDLIN	;CAN ONLY DO THIS FROM DD
	SKIPN AC1,VDTIE-DDL0(LINE) ;AND ONLY IF WE ARE TIED NOW
	POPJ P,
	HRR TAC,AC1		;PRESERVE SPCESC BIT IN LH OF TAC
VDESM4:	HRRZ DDB,TTYTAB(TAC)	;BREAK M GETS NEXT JOB OF SAME PRG
	JUMPE DDB,CPOPJ		;NO-OP IF TTY NOT IN USE
	MOVE AC1,LINTAB(TAC)
	TLNN AC1,DDDLIN		;YOU'D THINK SOMEONE WHO KNOWS HOW TO GET INTO
	POPJ P,			;  THIS STATE WOULD KNOW NOT TO DO THIS...
	LDB AC1,PJOBN		;GET JOB NUMBER USING TTY
	JUMPE AC1,CPOPJ		;NO JOB, DO NOTHING
	MOVE AC3,JBTSTS(AC1)
	TLNN AC3,JNA
	POPJ P,			;JOB ISN'T LOGGED IN
	HRRZ AC2,PRJPRG(AC1)	;PROGRAMMER NAME TOO
	MOVEI AC3,1		;SET DIRECTION FOR ESCQY
;AC2←PRG NAME. AC3←DIRECTION (1). AC1←STARTING JOB NUMBER.
VDESM5:	PUSHJ P,ESCQY		;FIND JOB NUMBER WITH SAME PRG--WRAPS AROUND
	 POPJ P,		;NONE THERE - NO-OP - CAN'T HAPPEN!!
	MOVE CHR,JBTLIN(AC1)	;JOB OK, NOW CHECK ON TTY
	PUSHJ P,VDESMY		;SEE IF IT'S A DD NOT HIDDEN FROM US
	 JRST PRESC3		;NOW MAP OR TIE US THERE
	LDB CHR,PJOBN		;HIDDEN FROM US OR NOT A DD
	CAIE CHR,(AC1)		;SIGH...DON'T LET US LOOP FOREVER
	JRST VDESM5		;IF WE DON'T FIND STARTING JOB, WE'LL LOOP ANYWAY!
	POPJ P,

VDESMY:	TLNN CHR,PTYLIN		;THIS CATCHES DETACHED JOBS
	TLNN CHR,DDDLIN		;MUST BE AT A DD
	JRST CPOPJ1		;NOT A DD, DON'T ALLOW MAPPING THERE
	PUSH P,AC1		;SAVE CURRENT JOB NUMBER
	PUSH P,AC2		;AND PROGRAMMER NAME
	MOVEI AC1,(CHR)		;GET LINE NUMBER TO CHECK
	PUSHJ P,VDESMX		;CAN WE SEE IT?
	 JRST VDESY2		;NOPE
	SUB P,[2,,2]		;FLUSH DATA
	POPJ P,			;SUCCESS

VDESY2:	POP P,AC2
	POP P,AC1
	JRST CPOPJ1		;FAILURE RETURN

VDESMX:	LDB AC2,[PHIDDN+AC1,,LSTESC] ;GET HIDDEN BIT
	JUMPE AC2,CPOPJ1	;OK IF NOT HIDDEN (FREE TTYS CAN'T BE HIDDEN)
VDESX2:	LDB AC2,[DDQREQ+AC1,,LSTESC] ;GET RESPONSIBLE TTY
	CAIE AC2,(LINE)		;ALSO OK IF HE IS RESPONSIBLE FOR THIS TTY
	TLNE TAC,SPCESC		;OR WITH MAGIC BIT
	AOS (P)			;LET HIM IN
	POPJ P,

>;IFE FTF2
;⊗ VDESCA TVSTRB TVSTR VDESAD VDESCN VDESCD VDESCS VDESS3 VDESS2 VDESN1 VDESCT VDESTV VDEST0 TVTABL VDESCK VDEKMX VDEKNA VDEKUP VDEKU0 VDEKU2 VDEKU3 VDEKUD VDEKU4 VDEKU5 VDEKU6 VDESKN VDEKN0 VDEKN3 VDEKN2 TUNBAS TUNMUL VDEKM VDEKCL VDEKC2 VDEKMT VDEK00 VDESK2 VDESK3 VDESK4 VDESK8 VDESK7 VDEK10 VDEK11 VDES11 VDESK6 VDEKGO VDESKX VDEK9A VDESK9 VDESK0 VDESK5 TVSRCH TVSRC2 TMTURL TMTUCH TMTURS TMTUMX CLKTUN CLKTON CLKTO3 CLKTO4 CLKTO2 CLKTDO CLKTDL TUNDLY CLKTRS TUNLSH TUNEUP TUNOFF TVCHBP TV1CHN TV2CHN TV3CHN TV4CHN

IFE FTF2,<	;Whole page

;ADD CHANNEL TO MAPPING
VDESCA:	PUSHJ P,VDESTV
	PUSHJ P,VDECHK
	PUSHJ P,VDVCHK
	 DPB AC1,[400,,VDTMP(AC2)]
	PUSHJ P,TVSTRB
	 IORM AC3,VDTMP(AC2)
	POPJ P,

TVSTRB:	PUSHJ P,VDBIT
TVSTR:	JUMPGE TAC,TVSTRX
	TLNE AC1,-1			;THIS IS FOR IIIS
	HLLZ AC3,AC1			;PICK UP BITS PASSED, IF ANY
	SKIPN AC2,LETAB+DDL0(TAC)
	JRST CPOPJ1
	HRLI AC2,VPGACT↑
	SYSPIFF
	IDPB AC2,CLKQ			;SET TO DO PGACT AT CLK LEVEL
	SYSPIN
	SETOM LEACT(AC2)		;SO HEADER STAYS AROUND
	MOVEI AC2,PRGACT-VDTMP(AC2)	;MAKE PNTR TO PGACT BITS
	SKIPL @(P)			;IS DIDDLING INSTR BOOLEAN?
	HRR AC3,VDTMP(AC2)		;NO, COPY RH SO IT WON'T GET CLOBBERED
	XCT @(P)
	JRST CPOPJ1

;COPY EXISTING MAP FROM DPY HEADER IF NEEDED FOR ESC A OR D
↑VDESAD:JUMPL TAC,CPOPJ			;NOT FOR III
	HRRZ AC2,VDTIE(TAC)
	JUMPE AC2,CPOPJ
	PUSH P,AC3
	SKIPE AC3,LETAB(AC2)
	SKIPA AC2,VDTMP(AC3)
	MOVE AC2,VDPRM(AC2)
	MOVEM AC2,VDMAP(TAC)
	SETZM VDTIE(TAC)
	POP P,AC3
	POPJ P,

;NORMALIZE SWITCH FOR THIS CHANNEL
VDESCN:	HRREI TAC,-DDL0(LINE)	;WHEN WE GET HERE, LINE HAS BEEN MAPPED ALREADY
	JUMPL TAC,CPOPJ
	CAIL TAC,DDNUM
	POPJ P,
	JRST VDNORM

;DELETE CHANNEL FROM MAPPING
VDESCD:	PUSHJ P,VDESET
	POPJ P,
	PUSHJ P,VDBIT
	CAIL AC1,40
	MOVEI AC3,17		;ANY HIGH # CLEARS ANALOG SELECT
	PUSHJ P,TVSTR
	 ANDCAM AC3,VDTMP(AC2)
	POPJ P,

;ESCAPE S -- SELECT SINGLE CHANNEL INTO MAPPING.
VDESCS:	PUSHJ P,VDESTV		;Check for BREAK n S command to view TV
	CAIE AC1,ESCNUL
	JRST VDESS3
	MOVEI AC2,-DDL0(LINE)
	JUMPL AC2,VDESS3	;jump if not DD
	CAIGE AC2,DDNUM
	JRST VDESN1		;is DD, go normalize map
VDESS3:	PUSHJ P,VDECHK		;Set up args and check privacy and terminal
	SETZM VDTIE(TAC)
VDESS2:	PUSHJ P,VDVCHK
	 MOVEM AC1,VDTMP(AC2)
	PUSHJ P,TVSTRB
	 MOVEM AC3,VDTMP(AC2)
	POPJ P,

VDESN1:	LDB AC3,[POINT PUNITS,LINTAB(LINE),35] ;get line mapped to
	CAIL AC3,DDL0		;make sure it's a DD
	CAIL AC3,DDL0+DDNUM
	POPJ P,			;mapped to non-DD, ignore ESC S
	MOVEM AC3,VDTIE(AC2)	;IS TAC STILL SET? COULD SKIP LDB
	MOVEI TAC,-DDL0(AC3)
	JRST VDNORM

;SELECT SINGLE CHANNEL TEMPORARILY
VDESCT:	PUSHJ P,VDESTV		;check for BRK n S select of TV tuner
	PUSHJ P,VDECHK		;Set up args and check privacy
	MOVSI AC3,400000
	MOVEM AC3,VDTIE(TAC)	;untie us temporarily
	JRST VDESS2

;<BRK> N [S|T|A] where N is in the range 1:TVMAX gets VIDEO chan
;and AUDIO chan indicated in TVTABL below.
VDESTV:	JUMPG AC1,CPOPJ		;<ESC>S OR <ESC>T OR <ESC>A
	SKIPE GOTARG		;skip if not BRK
	CAMGE AC1,[-TVMAX]
	POPJ P,			;ARGUMENT NOT IN TV RECEIVER RANGE
	MOVNS AC1		;make arg positive (or zero)
	SETOM ESCDIF		;Flag arg is already in right radix
VDEST0:	PUSH P,AC1
	PUSH P,TAC
	HLRZ AC1,TVTABL-1(AC1)	;get audio channel for this TV
	PUSHJ P,ASESC		;SIMULATE ESC # U
	POP P,TAC
	POP P,AC1
	HRRZ AC1,TVTABL-1(AC1)	;get video analog channel number
	POPJ P,

;LH = Audio chans for given TV
;RH = Video analog channel numbers for given TV
	0,,ESCNUL	;for use in BRK 0 S, which does ESC S and selects audio 0
TVTABL:	11,,41
	12,,42
	13,,44
	14,,45
IFN .-TVTABL-TVMAX,<.FATAL TVTABL is wrong length, must agree with TVMAX>

;ESC n K -- watch TV, channel n.
;      Select given broadcast TV channel (2-83) and map its video and audio.
;      May have to change channels on a free TV.
;BRK n K -- watch TV, channel n, without mapping audio (maps only video).
;BRK 0 K match audio to video or vice versa.
;ESC 0 K, or ESC n K with chan n not available, turn off TV/audio (see BRK 0 S).
;ESC K (no arg) tune to next available higher channel.
;BRK K (no arg) tune to next available lower channel.
;MAGIC K (no arg) tune to next available higher channel, but without audio.
;MAGIC - K (no arg) tune to next available lower channel, but without audio.
;MAGIC -n K tune some tuner to channel K without mapping video or audio.
;MAGIC n K -- if tuner(s) "tuned to channel n", forget it and re-tune to chan n.
;MAGIC n K, where n=100+(TV-1)*20+t, tune given TV a total of t times.
VDESCK:	HLLM AC1,(P)		;remember sign of arg to distinguish ESC and BRK
	MOVM AC2,AC1		;put positive arg in good place
	SKIPE GOTARG		;skip unless BREAK
	JUMPE AC1,VDESKN	;BRK 0 K, match audio to video or vice versa
	SETOM GOTARG		;enable VDESTV's chan conversion for all variations
	CAIN AC2,ESCNUL		;ESC K with no arg?
	JRST VDEKUP		;yes, tune to next higher or lower channel
	TLNE TAC,SPCESC		;MAGIC n K?
	JRST VDEKM		;yes
;MAGIC n K returns here to do tuning/mapping.
VDEKMX:	JUMPE AC1,VDESCS	;jump if ESC 0 K, turn off TV like BRK 0 S
;ESC n K -- watch TV, channel n.
;BRK n K -- watch TV, channel n, without mapping audio (maps only video).
;ESC 0 K, or ESC n K with chan n not available, turn off TV/audio (see BRK 0 S).
	PUSHJ P,VDEK00		;find tuner (AC1) to watch (AC2) on
	SKIPL (P)		;skip for BRK n K
	JRST VDESCS		;select video and audio by jumping to BRK n S code
;Enter here from MAGIC K to tune to next higher TV without audio
VDEKNA:	MOVM AC1,AC1		;get positive TV tuner number (or zero)
	HRRZ AC1,TVTABL-1(AC1)	;get video analog channel number
	SETZM GOTARG		;prevent VDESTV from doing anything (no audio pls)
	SETOM ESCDIF		;Flag arg is already in right radix
	JRST VDESCS		;select video but not audio

;ESC K (no arg) tune to next available higher channel.
;BRK K (no arg) tune to next available lower channel.
;MAGIC K (no arg) tune to next available higher channel, but without audio.
;MAGIC - K (no arg) tune to next available lower channel, but without audio.
;First we figure out what channel we're watching (or listening to).
;Then we scan the channel tables of all the TV tuners to find the
;next higher or lower channel number (wrapping through "0" -- no TV --
;from either highest or lowest TV channel number).  Then we call VDEK00
;to see if we can watch that channel (unless it's 0, in which case we
;just map the TV off immediately).  If we can watch the channel, we do.
;Else we loop looking for the next higher or lower channel, looping until
;either we have an available TV channel or we get to channel "0".
;(In the worst case, we'll loop about 14 times, if all the tuners are in use
;on the four lowest stations, since there are about 14+4 different stations.)
VDEKUP:	PUSHJ P,VDEKN0		;get -TV tuner number we're watching in AC1
	MOVM DAT,AC1		;get positive TV nbr
	SKIPE DAT		;skip if neither watching nor listening to TV
	MOVE DAT,TVCHAN-1(DAT)	;get channel we were watching
	JUMPN DAT,VDEKU0	;jump if watching known channel
	SKIPGE (P)		;skip unless BRK
	MOVSI DAT,1		;pretend was watching very high numbered chan
VDEKU0:	MOVSI AC2,1		;initial best next channel higher (assuming ESC)
	SKIPGE (P)		;skip if ESC K -- goes up
	MOVEI AC2,0		;initial best next channel lower (BRK goes down)
	MOVEI AC1,TVMAX		;scan through all tuners' channel tables
VDEKU2:	MOVE UUO,TVCHBP-1(AC1)	;get byte ptr to possible channels for this TV
	SKIPGE (P)		;skip if ESC K -- goes up
	JRST VDEKUD		;BRK K goes down
;Search tuner table of TV (AC1) for channels between (DAT) and (AC2)
VDEKU3:	ILDB CHR,UUO		;get next possible channel
	JUMPE CHR,VDEKU4	;zero is end of list
	CAIGE DAT,(CHR)		;this channel beyond current channel?
	CAIG AC2,(CHR)		;yes, is it closer to current than prev best?
	JRST VDEKU3		;no, loop to end of channel list
	MOVE AC2,CHR		;new best channel
	JRST VDEKU3		;loop to end of channel list

;Search tuner table of TV (AC1) for channels between (AC2) and (DAT) 
VDEKUD:	ILDB CHR,UUO		;get next possible channel
	JUMPE CHR,VDEKU4	;zero is end of list
	CAILE DAT,(CHR)		;this channel beyond current channel?
	CAIL AC2,(CHR)		;yes, is it closer to current than prev best?
	JRST VDEKUD		;no, loop to end of channel list
	MOVE AC2,CHR		;new best channel
	JRST VDEKUD		;loop to end of channel list

VDEKU4:	SOJG AC1,VDEKU2		;go on to next tuner, if any
;Finished scanning the tables, and the channel we want is now in AC2.
	TRNN AC2,-1		;skip if found real channel
	JRST VDEKU5		;want TV off (end of line, everybody off)
	PUSHJ P,VDEK00		;see if we can watch that channel (sets AC1)
	JUMPL AC1,VDEKU6	;go map TV audio and video if found a tuner
	MOVE DAT,AC2		;continue scan from station we wanted this time
	JRST VDEKU0		;can't tune station in, search for next channel

VDEKU5:	MOVEI AC1,0		;simulate BRK 0 S
	JRST VDESCS		;turn off TV audio and video

;Here if ready to map available channel
VDEKU6:	TLNN TAC,SPCESC		;skip if magic
	JRST VDESCS		;map video and audio
	JRST VDEKNA		;map video but not audio

;BRK 0 K -- map video to TV channel user is listening to.
;If not listening to TV, turn on audio for TV video user is watching, if any.
;Checks only permanent audio and TV maps, and switches both audio and TV
;(in case had temporarily turned off one or both).
VDESKN:	MOVE AC3,LINTAB(LINE)	;make sure we're coming from a DD
	TLNN AC3,DDDLIN		;skip if DD
	POPJ P,			;not a DD -- don't try anything funny
	PUSHJ P,VDEKN0		;set AC1 to -TV number of TV we're using
	JUMPL AC1,VDESCS	;go select that TV (audio AND video)
	POPJ P,			;not using any TV, do nothing

;Figure out which TV we're watching or listening to.
;Return AC1 with zero or negative TV number.
;First, see if watching a TV's video.
VDEKN0:	SKIPLE AC2,VDTIE-DDL0(LINE) ;skip if untied
	SKIPA AC2,VDPRM-DDL0(AC2) ;get permanent map of line he's tied to
	MOVE AC2,VDMAP-DDL0(LINE) ;get untied map
	MOVEI AC1,TVMAX
VDEKN3:	HRRZ AC3,TVTABL-1(AC1)	;get a TV's video chan
	XOR AC3,AC2		;compare with our map
	ANDI AC3,7		;only bits of interest
	JUMPE AC3,VDESKX	;jump if match, return negative TV number
	SOJG AC1,VDEKN3		;loop through possible TVs
;Not watching TV's video; see if listening to a TV.
	LDB AC2,[ASPRMP+LINE,,ASTAB-SCNNUM] ;get permanent audio channel
	MOVEI AC1,TVMAX		;see if this audio belongs to some TV (neg for BRK)
VDEKN2:	HLRZ AC3,TVTABL-1(AC1)	;get a TV's audio chan
	CAIN AC3,(AC2)		;is that what he's listening to?
	JRST VDESKX		;yup, that's the one, return negative TV number
	SOJG AC1,VDEKN2		;loop through possible TVs
;Not listening to TV's audio.  Returns 0 in AC1.
	POPJ P,			;wasn't watching or listening (permanently) to TV

TUNBAS←←=100	;special argument base for tuning specific tuner given amt
TUNMUL←←=20	;multiplier per tuner for special tuning arg
;MAGIC variations.
;MAGIC -n K tunes some tuner to channel K without mapping video or audio.
;MAGIC n K -- if tuner(s) "tuned to channel n", forget it and re-tune to chan n.
;MAGIC n K, where n=100+(TV-1)*20+t, tunes given TV a total of t times.
VDEKM:	JUMPL AC1,VDEK00	;jump if MAGIC -n K, tune tuner but no mapping
	CAIL AC2,TUNBAS		;special tuning arg?
	JRST VDEKMT		;yes, go tune as requested
	PUSHJ P,VDEKCL		;clear knowledge of position of any tuner on chan n
	JRST VDEKMX		;then go back and try to tune and map to chan n

;MAGIC n K -- if any tuner(s) thought to be tuned to channel n, forget that.
VDEKCL:	MOVEI AC1,TVMAX		;scan whole TV tuner table
VDEKC2:	CAMN AC2,TVCHAN-1(AC1)	;this tuner supposedly on that channel?
	SETZM TVCHAN-1(AC1)	;yes, user seems to think it isn't really, forget it
	SOJG AC1,VDEKC2		;loop through table
	POPJ P,

;MAGIC n K, where n=100+(TV-1)*20+t, tunes given TV a total of t times.
VDEKMT:	SUBI AC2,TUNBAS		;make arg be (TV-1)*20+t
	IDIVI AC2,TUNMUL	;TV-1 into AC2, t into AC3
	MOVEM AC3,TVTUNE(AC2)	;(note AC2 is one less than TV nbr this time)
	SETZM TVCHAN(AC2)	;forget where this tuner is (don't calculate it)
	JRST VDEKGO		;start the clock level routine to do tuning

;Routine to look for a TV tuner to watch channel (AC2) on.
;Returns AC1 containing either zero or a negative TV tuner number, -1:-TVMAX.
VDEK00:	MOVEI AC1,TVMAX		;see if any TV already tuned here
VDESK2:	CAMN AC2,TVCHAN-1(AC1)	;is this tuner on station we want?
	JRST VDESKX		;yes, just go select it
	SOJG AC1,VDESK2		;check all TV tuners
;No TV tuner is tuned to desired station, have to change channel on a free TV.
;So first we look for a TV which has the desired station on one of its
;tuner positions (according to our table).
	MOVEI AC1,TVMAX		;look through all TV tuners
VDESK3:	PUSHJ P,TVSRCH		;search TV (AC1) for chan (AC2), return index (AC3)
	 JRST VDESK0		;chan not on this tuner, try next tuner
;Here's a possible tuner, see if anyone's watching its current channel.
	HRRZ DSER,TVTABL-1(AC1)	;get video channel for this TV
	ANDI DSER,7		;just offset within analog channels
	MOVEI CHR,DDNUM-1	;check all physical DDs (but NOT the SHADOW lines)
VDESK4:	HRRZ UCHN,VDTIE(CHR)	;this DD terminal untied?
	JUMPN UCHN,VDESK5	;jump if tied
	MOVE UUO,VDMAP(CHR)	;see what this DD is looking at
VDESK8:	ANDI UUO,7		;just check for our analog video line
	CAIN UUO,(DSER)		;is it watching TV tuner we might use?
	JRST VDESK9		;yes, can't change channel (unless it's us)
VDESK7:	SOJGE CHR,VDESK4	;loop if any more DDs to check
;No one's watching this TV, see if anyone is listening to it.
	HLRZ UCHN,TVTABL-1(AC1)	;get audio chan for this TV
	MOVEI CHR,DDNUM+DPYNUM-1 ;check all audio stations for a listener
VDEK10:	LDB UUO,[ASPRMP+CHR,,ASTAB] ;get permanent map of this station
	CAIN UUO,(UCHN)		;listening to this TV?
	JRST VDEK9A		;yes, can't change channel (unless it's us)
	LDB UUO,[ASTMPP+CHR,,ASTAB] ;get temporary map of this station
	CAIN UUO,(UCHN)		;listening to this TV?
	JRST VDEK9A		;yes, can't change channel (unless it's us)
VDEK11:	SOJGE CHR,VDEK10	;loop through audio stations (DDs and IIIs)
;Aha, we've found a free TV tuner (AC1), and we know how much
;to tune it by (AC3) relative to reset tuning position.
	MOVNI DAT,1(AC3)	;remember desired tuning position (+1, negated)
	EXCH AC2,TVCHAN-1(AC1)	;get currently tuned-in station, remember new one
	SKIPN TVTUNE-1(AC1)	;skip if was changing channels, force reset of it
	PUSHJ P,TVSRCH		;see where it is in tuning order
	 JRST VDESK6		;don't know where tuned, reset and tune new station
	ADD AC3,DAT		;find negative amt of tuning up (-1)
	JUMPL AC3,VDES11	;jump if don't need to wrap around
;We wrap around instead of resetting--use MAGIC n K to force reset of TV on n.
;To reset instead of wrapping around, change following SUBI to JRST VDESK6.
	SUBI AC3,=12		;tune to lower position by wrapping around
VDES11:	SETCM DAT,AC3		;set DAT with positive amt to tune up by
VDESK6:	MOVEM DAT,TVTUNE-1(AC1)	;store tuning adjustment
;Now we have tuning amount in TVTUNE, where a positive number means just tune
;that many times, a negative number -(n+1) means first reset and then tune n times.
;Zero can't happen (else we'd have just mapped earlier to this tuner).
VDEKGO:	MOVSI DAT,CLKTUN	;clock level TV-tuning routine to start up
	AOSG TUNEIT		;skip if tuner routine already running
	PUSHJ P,DPYTIM		;plant clock request for routine to do CAR CONOs
VDESKX:	MOVNI AC1,(AC1)		;set up -<TV number>
	POPJ P,			;and return it, in case will make selection

;Here if currently checked tuner's audio isn't free.
VDEK9A:	CAIN CHR,-DPYL0(LINE)	;someone's listening to this tuner.  is it us?
	JRST VDEK11		;yes, that's OK, check for other listeners
Printx TVs 64 through 67 are assumed not to have audio (in Cedar Hall).
	CAIG CHR,7		;these DDs don't have audio, don't care
	CAIGE CHR,4		; if we change audio out from under them
	JRST VDESK0		;this tuner is busy, try next
	JRST VDEK11		;ignore listener who doesn't have audio

;Here if currently checked tuner's video isn't free.
VDESK9:	CAIN CHR,-DDL0(LINE)	;someone's watching this tuner.  is it us?
	JRST VDESK7		;yes, that's OK, check for other watchers
;Enter here if currently checked tuner doesn't have desired channel, or audio busy.
VDESK0:	SOJG AC1,VDESK3		;try next tuner, if any
;There is no free tuner with the desired channel.  Shut off any TV or audio.
	MOVEI AC1,0		;signal failure, need this to simulate BRK 0 S
	POPJ P,

;Here to test a DD terminal that is tied to a DD line.
;The tied-to line might have this TV tuner in its perm or temp map.
VDESK5:	MOVE UUO,VDPRM-DDL0(UCHN) ;get permanent map for this tied-to line
	ANDI UUO,7		;just check for our analog video line
	CAIN UUO,(DSER)		;perm map include TV tuner we might use?
	JRST VDESK9		;yes, can't change channel (unless it's us)
	SKIPN UUO,LETAB(UCHN)	;get dpy hdr of tied-to line
	JRST VDESK7		;not in use, no conflict here (no temp map)
	MOVE UUO,VDTMP(UUO)	;get temp map for this DD line
	JRST VDESK8		;and check it for including TV tuner being checked

;Search tuner table of TV (AC1) for chan (AC2); skip returns with index (AC3).
TVSRCH:	MOVE UUO,TVCHBP-1(AC1)	;get byte ptr to possible channels for this TV
	MOVEI AC3,0		;initial index
TVSRC2:	ILDB CHR,UUO		;get next possible channel
	JUMPE CHR,CPOPJ		;direct return if chan not found
	CAIN CHR,(AC2)		;desired channel?
	JRST CPOPJ1		;yes, skip return with index in AC3
	AOJA AC3,TVSRC2		;get next index, and loop

TMTURL←←2	;ticks to wait after turning on any relay (relay settling closed)
TMTUCH←←2	;ticks to wait after turning off channel-changing relay
TMTURS←←10	;ticks to wait after turning off reset relay (capacitor recharging)
TMTUMX←←1000	;max number of ticks we'll wait for anything (safety) (power of 2)

;Here at clock level to think about tuning some TV tuner.
;The table TVTUNE indicates what needs to be done.
CLKTUN:	SUBI DAT,2		;count one tick passed (sic! Makes 1 and 0 neg.)
	TRNN DAT,-TMTUMX	;skip if count went negative (or too big)--action!
	AOJA DAT,DPYTIM		;wait another tick (undoes half of SUBI DAT,2!)
	MOVE DAT,TVWAIT		;if relay on, get ticks to wait after turning off
	JUMPLE DAT,CLKTON	;jump if relays were off
;Relay has been on long enough, turn it off and wait some more.
;Assumes code 0 in bits 27:31 causes decoder to turn off all relays.
	CONO CAR,400000!TUNOFF	;turn off relevent CAR bits (code 0 clears relays)
	SETZM TVWAIT		;relays are now off
	HRLI DAT,CLKTUN		;clk req,,nbr of ticks to wait with relay off
	JRST DPYTIM		;plant clk req to come back after relay off a while

;Here if it's time to turn some relay on to tune a TV.
;We search the TVTUNE table from the last place we were at in it, so that
;a new tuning request won't interrupt an older one.
CLKTON:	HLRZ AC1,TUNEIT		;get tuner that was being tuned
	JUMPLE AC1,CLKTO3	;jump if illegal tuner number
	CAILE AC1,TVMAX		;make sure tuner number is in range
CLKTO3:	MOVEI AC1,TVMAX		;illegal tuner number, start from top
;once around the loop from HERE to BOTTOM, without stopping scanner channel
CLKTO4:	SKIPE CHR,TVTUNE-1(AC1)	;any diddling needed for this TV?
	JRST CLKTDL		;yes, go do it
	SOJG AC1,CLKTO4		;check all tuners
	MOVEI AC1,TVMAX		;number of tuners to consider
;now once around the loop from TOP to BOTTOM, with scanner off
	OFFSCN			;no more tuning requests while we check for any
CLKTO2:	SKIPE CHR,TVTUNE-1(AC1)	;any diddling needed for this TV?
	JRST CLKTDO		;yes, go do it
	SOJG AC1,CLKTO2		;check all tuners
	SETOM TUNEIT		;clock TV-tuning routine is now idle
	JRST SCNONJ		;restore scanner channel

;Here to diddle some TV tuner (AC1).
;TVTUNE being positive means we have to reset that TV's channel before tuning up.
CLKTDO:	ONSCN			;restore scanner channel
CLKTDL:	HRLM AC1,TUNEIT		;remember which tuner we're working on
	JUMPL CHR,CLKTRS	;jump if need to reset channel
;The scanner's on, but that's OK unless the guy changes his mind about which chan
;to watch TWICE, once before this SOSGE and once between the SOSGE and the AOS!
	SOSGE TVTUNE-1(AC1)	;count a tuning done, should skip
	AOS TVTUNE-1(AC1)	;hmm, must have just decided to reset, try to fix it
	HRRZ CHR,TUNEUP-1(AC1)	;get encoded value to cause upward tuning
	CONO CAR,(CHR)		;tell it to change channels (engage relay)
	MOVEI DAT,TMTUCH	;nbr of ticks to wait AFTER relay gets released
TUNDLY:	MOVEM DAT,TVWAIT	;remember delay after relay off
	MOVE DAT,[CLKTUN,,TMTURL] ;clk req addr,,nbr of ticks for relay to settle
	JRST DPYTIM		;plant clk req to come back after relay settles

;Here to reset a TV tuner to its reset channel.
CLKTRS:	SETCMM TVTUNE-1(AC1)	;will no longer need reset for this TV, just tuning
	HLRZ CHR,TUNEUP-1(AC1)	;get encoded value to cause tuning reset
	CONO CAR,(CHR)		;tell it to reset channel setting (engage relay)
	MOVEI DAT,TMTURS	;nbr of ticks to wait after releasing relay
	JRST TUNDLY		;plant clk req to come back after relay settles

;Table of encodings to use on CART interface bits to reset or tune each TV
;LH has reset encoding, RH has tune-upwards encoding.
;(Note that the CONO at about CLKTUN+5 assumes code 0 turns all relays off.)
;We use CAR CONO bits 27,28,29,31 (we don't use bit 30, which is stuck).
TUNLSH←←4  ;number of low order CAR bits after those we're using.
	;RH CAR CONO bits for: reset,,tune upwards
TUNEUP:	31⊗TUNLSH,,30⊗TUNLSH	;within 4 bits of interest: 15,,14
	25⊗TUNLSH,,24⊗TUNLSH	; bit on means		    13,,12
	21⊗TUNLSH,,20⊗TUNLSH	; CART bit is grounded	    11,,10
	15⊗TUNLSH,,14⊗TUNLSH	;			     7,,6
TUNOFF←←35⊗TUNLSH		;all the CAR bits we're using for tuning the TVs

;Byte pointers to channel lists for different TV tuners.
TVCHBP:	POINT 7,TV1CHN
	POINT 7,TV2CHN
	POINT 7,TV3CHN
	POINT 7,TV4CHN

;Ordered lists of channels set up on the different TV tuners.
;There are twelve tuning positions on each SHARP TV tuner.
RADIX 5+5	;Decimal broadcast TV channel numbers.
TV1CHN:	BYTE (7)2,20,4,5,40,7,36,9,48,11,44,60,0
;TV2CHN:	BYTE (7)2,20,4,5,26,7,36,9,54,48,38,60,0
TV2CHN:	BYTE (7)3,0,0,0,0,0,0,0,0,0,0,0,0 ; for broadband/Russian TV
TV3CHN:	BYTE (7)2,20,4,5,26,7,36,9,54,11,44,60,0
TV4CHN:	BYTE (7)2,20,4,5,26,7,36,9,54,11,44,48,0
RADIX 4+4	;Back to normal octal radix

>;IFE FTF2
;VDESET VDEST5 VDEST2 VDEST1 VDEST4

IFE FTF2,<	;Whole page

;SET UP ARGS FOR VD CMDS, SKIP IF LEGAL.
;NO ARG means MY CHAN.  + ARG means DD CHAN #.  - ARG means CHAN FOR TTY #.
;Returns (DD) channel number in AC1 (if legal tty).
VDESET:	HRRI TAC,-DDL0(LINE)
	MOVE AC2,LINTAB+DDL0(TAC)
	TLNN AC2,DDDLIN
	JRST VDEST4
	JUMPGE AC1,VDEST5	;JUMP IF ESCAPE, NOT BREAK
	MOVM AC1,AC1		;GET TTY NUMBER
	CAIN AC1,ESCNUL
	JRST VDEST1		;STILL NECESSARY FOR BRK D ALTHOUGH NOT S,A,T
	PUSHJ P,ESCOCT
	SUBI AC1,DDL0
	CAIGE AC1,DDNUM
	JUMPGE AC1,VDEST2
	POPJ P,			;NOT A DD LINE, ERROR RETURN

VDEST5:	CAIE AC1,ESCNUL
	JRST ESCOCS
	LDB AC1,[POINT PUNITS,LINTAB(LINE),35] ;Get line we're mapped to
	MOVEI AC1,-DDL0(AC1)	;Make first DD line be zero
	TLO TAC,SPCESC		;LET HIM DIDDLE VIDEO OF LINE HE'S MAPPED TO
VDEST2:	SKIPN AC2,LETAB+DDL0(AC1)
	SKIPA AC1,AVLCHN
	HLRZ AC1,PRGNUM(AC2)
	JRST CPOPJ1

VDEST1:	MOVE AC1,AVLCHN		;<BRK> WITH NO ARG IS ALWAYS AVAILABLE CHANNEL
	JRST CPOPJ1

VDEST4:	TLNE AC2,DISLIN		;NOT DD, SEE IF III
	SKIPN LETAB+DDL0(TAC)
	POPJ P,			;NOT III OR NO DPY HEADER MEANS ILLEGAL
	JUMPL AC1,CPOPJ
	HRROI TAC,(TAC)		;SET SIGN FOR VDSTRI AND SPCESC FOR VDECHK
	CAIN AC1,ESCNUL
	SKIPA AC1,[-4,,]	;NULL ARG MEANS ALL P OF G'S
	PUSHJ P,ESCOCT
	TRNN AC1,-20
	AOS (P)			;SKIP IF LEGAL P OF G #
	POPJ P,

>;IFE FTF2
;VDECHK VDVCHK TVSTRX VDVCH2 VDVCH0 VDVCH1

IFE FTF2,<	;Whole page

;SET UP ARGS & CHECK PRIVACY. RETURNS UPLEVEL ON LOSSAGE
VDECHK:	PUSHJ P,VDESET		;Get channel number into AC1 and skip if legal tty
	 JRST TPOPJ
	TLNE TAC,SPCESC
	POPJ P,
	CAIGE AC1,40		;IF NOT DD CHAN, IS OK TO LOOK AT
	SKIPL DDTAB(AC1)	;SKIP IF DD CHAN IS HIDDEN
	POPJ P,
	MOVEI J,0		;No job is requesting this mapping
	MOVSI DSER,VDABSO	;TAC contains absolute TV number
	PUSHJ P,VDCCHK		;See if we have access to this hidden DD channel
	 SUB P,[1,,1]		;No, return up a level
	POPJ P,

;CHECK IF CHANNEL IS REALLY ANALOG, AND HANDLE SPECIALLY
VDVCHK:	TRZN AC1,-40
	JRST CPOPJ1
	ANDI AC1,7
	IOR AC1,VDSYNC(AC1)
TVSTRX:	HRRZ TEM,VDTIE(TAC)
	JUMPE TEM,VDVCH1
	LDB AC2,[POINT PUNITS,LINTAB(TAC),35]
	CAIN AC2,(TEM)
	SKIPN AC2,LETAB(TEM)
	JRST VDVCH0
	XCT @(P)
	SKIPGE LETBPT(AC2)
	JRST VDVCH2
	MOVEI AC2,VDPRM-VDTMP-DDL0(TEM)
	XCT @(P)
VDVCH2:	SUB P,[1,,1]
	MOVEI TAC,-DDL0(TEM)
	JRST VDOUTP↑

VDVCH0:	PUSHJ P,VDESAD		;ADDING TO AVAILABLE LINE, UNTIE HIM
VDVCH1:	MOVEI AC2,VDMAP-VDTMP(TAC)
	XCT @(P)
	SUB P,[1,,1]
	JRST VDOUT

>;IFE FTF2
;⊗ ASBRKU ASEBNB ASBKUQ ASJOBP ASHANG ASHGBP ASTEMP ASPAGN ASDBEP ASPPUN ASPPUP ASPBUN ASPBUP ASBPDB ASBPDP ASPGDB ASPGDP ASTMPP ASTMPM ASPRMP ASPRMM ASPAGC ASBEPC ASMIKE ASQUIC ASBPTM ASESC ASESC1 ASSEL ASSCN ASSCNL ASSCN1 ASSCLN ASSCB ASSCB1 ASRVRT ASRVR2 ASRVR3 ASRVR4 ASRVR1 ASSCTO ASSCT1 ASSCT2 ASUNHG ASUNHR BREAKU BRKU1 ESCB ESCB1 CENSOR

IFN FTAS,<	;Whole page

;ASBTAB RH HAS DURATION OF BEEP IN 1/4 SEC UNITS
;IF NON-ZERO, INDICATES BEEP IS HAPPENING
;SIGN BIT MUST BE OFF, OTHER LH BITS USABLE AS FLAGS
;Note: the bits in ASBTAB LH are not routinely cleared at reset, etc., but
;must be cleared explicitly.  They should be used for things which should
;survive an audio switch reset.
ASBRKU←←200000		;BIT 1 MEANS BREAK U (FLUSH THIS PAGE) PENDING
ASEBNB←←100000		;BIT 2 MEANS ESC/BRK n B (TEMP SILENCE) PENDING
ASBKUQ←←40000		;BIT 3 MEANS BRK U HAS DONE TEMP SEL OF ASQUIC
;If you add bits, fix the IFG "+" field below to number of high bits used.
IFG JOBNSZ+4-=18,<.FATAL JOBNSZ is too big for available byte in ASBTAB>
;BITS (17-JOBNSZ+1) TO 17 ARE JOB NUMBER TO UNHANG AFTER TEMP
ASJOBP←←<(<POINT JOBNSZ,0,17>)> ;BYTE POINTER TO BITS (17-JOBNSZ+1) TO 17

;ASTAB BITS
;RH HAS TIME REMAINING IN TEMP SELECTION IN 1/4 SEC UNITS
;	ZERO MEANS INFINITE
;BITS	  FUNCTION
;0     means UUO IS HANGING UNTIL TEMPORARY SELECTION TIMES OUT
	ASHANG←←400000
	ASHGBP←←430100
;1     means CURRENT SELECTION IS TEMPORARY
	ASTEMP←←200000
;2     means PAGING NOW
	ASPAGN←←100000
;3     means BEEP WHEN TEMPORARY SELECTION TIMES OUT
	ASDBEP←←40000
;4     means PERMANENT CHANNEL NOT PAGE INTERRUPTIBLE
	ASPPUN←←20000
	ASPPUP←←370100
;5     means PERMANENT CHANNEL NOT BEEP INTERRUPTIBLE
	ASPBUN←←10000
	ASPBUP←←360100
;6-7   is TEMPORARY CHANNEL BEEPING DISPOSITION
	ASBPDB←←6000
	ASBPDP←←340200
;8-9   is TEMPORARY CHANNEL PAGING DISPOSTION
	ASPGDB←←1400
	ASPGDP←←320200
;10-13 is TEMPORARY CHANNEL NUMBER
	ASTMPP←←260400
	ASTMPM←←360
;14-17 is PERMANENT CHANNEL NUMBER
	ASPRMP←←220400
	ASPRMM←←17	;MASK

;DISPOSITION CODES
	;0: INTERRUPTIBLE
	;1: NON-INTERRUPTIBLE
	;2: INTERRUPTIBLE, BUT EXTEND DURATION OF TEMP CH
	;3: POSTPONE BEEP UNTIL TEMP SELECTION TIMES OUT

;NOTE: 3 IS APPLICABLE ONLY TO BEEP DISPOSITION

ASPAGC←←0			;AUDIO SWITCH PAGING CHANNEL
ASBEPC←←17			;AUDIO SWITCH BEEP CHANNEL
ASMIKE←←16			;audio switch machine room microphone near bell
;As long as we don't have any actual paging on ASPAGC, we don't need a different
;channel for "quiet" (to select quiet during paging or for ESC n B). -- ME 1984
ASQUIC←←ASPAGC			;AUDIO SWITCH QUIET CHANNEL
ASBPTM←←2			;2/4 SEC FOR BEEP

;AUDIO SWITCH CHANNEL PERMANENT SELECTION
ASESC:	HRREI TAC,-DPYL0(LINE)
	JUMPL TAC,CPOPJ
	CAIL TAC,DPYNUM+DDNUM
	POPJ P,			;NEITHER A III NOR A DD
	MOVEI DSER,0
	JUMPGE AC1,ASESC1	;JUMP IF PAGE INTERRUPTIBLE PERM SELECTION ESC U
	MOVN AC1,AC1		;BRK#U MAKE PAGE UNINT.PERMANENT SELECTION
	CAIN AC1,ESCNUL		;BRK U WITH NO NUMBER MEANS FLUSH CURRENT PAGING
	JRST BREAKU		; INTERRUPTION IF ANY, ELSE RESET TEMP SELECTION
	MOVEI DSER,ASPPUN	;PERM PAGE UNINTERRUPTIBLE
ASESC1:	CAIN AC1,ESCNUL
	SKIPA AC1,[ASPAGC]	;Select paging channel (0)
	PUSHJ P,ESCOCT		;ASSUME TYPEIN WAS OCTAL
ASSEL:	LDB AC3,[ASHGBP,,ASTAB(TAC)]	;UUO HANG BIT
	IORI AC1,(DSER)		;PERM SELECTION AND MAYBE PPUN BIT
	HRLZM AC1,ASTAB(TAC)	;CLEAR ALL OTHER BITS
	HLLZS ASBTAB(TAC)	;CLEAR BEEP DURATION
	HRLI AC1,(TAC)
	DATAO AS,AC1		;DO SELECTION NOW
	MOVSI AC1,ASEBNB!ASBKUQ	;CLEAR TEMP-SILENCE-PENDING BIT
	ANDCAM AC1,ASBTAB(TAC)	; AND BREAK-U-SELECTED-ASQUIC BIT
	JUMPN AC3,ASUNHG	;UNHANG POOR UUO
	POPJ P,

;CALLED FROM CLKSER EVERY 1/4 SEC
↑ASSCN:
IFN PKNUM,<
	CONO PK,0		;MAKE SURE WE DON'T RUN PAGING INT CODE
>;IFN PKNUM
	MOVSI TAC,-<DPYNUM+DDNUM>
	MOVEI TAC1,-1
ASSCNL:	TDNE TAC1,ASBTAB(TAC)	;CHECK FOR BEEPING GOING ON
	JRST ASSCB
	TDNN TAC1,ASTAB(TAC)	;SKIP IF NON-INFINITE TEMP SELECTION
	JRST ASSCLN
	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASPGDP,,AC1]	;TEMP PAGE DISPOSITION
	TLNN AC1,ASPAGN
	JRST ASSCN1		;NOT PAGING NOW
	CAIN AC2,2
	JRST ASSCLN		;PAGING AND EXTEND, SO DON'T COUNT TEMP DURATION
ASSCN1:	SOS AC1,ASTAB(TAC)	;DECREASE ITS COUNT
	TRNN AC1,-1		;SKIP IF NOT TIME YET
	JRST ASSCTO		;TIMED OUT, SET BACK TO PERMANENT
ASSCLN:	AOBJN TAC,ASSCNL
IFN PKNUM,<
	CONO PK,PKCHN		;OK to have paging interrupts now
>;IFN PKNUM
	POPJ P,

;IN MIDDLE OF BEEP (CAN'T BE IN A PAGE -- SEE PKINT)
ASSCB:	SOS AC1,ASBTAB(TAC)	;DECREMENT BEEP DURATION
	MOVE AC2,ASTAB(TAC)
	TLNN AC2,ASTEMP		;SKIP IF BEEP INTERRUPTED TEMP SEL
	JRST ASSCB1		;BEEP IS DURING PERM SEL
	LDB AC2,[ASBPDP,,AC2]	;TEMP BEEP DISPOSITION
	TDNE TAC1,ASTAB(TAC)	;IF TEMP SEL IS INFINITE OR ...
	CAIN AC2,2
	JRST ASSCB1		;IF EXTEND, THEN DON'T COUNT TEMP DURATION
	SOS AC2,ASTAB(TAC)
	TRNN AC2,-1		;IF TEMP RUNS OUT DURING BEEP, ...
	TLZ AC2,ASTEMP		;MAKE IT LOOK LIKE INTERRUPTED PERM
	MOVEM AC2,ASTAB(TAC)
	HRLI AC2,ASEBNB		;ESC/BRK n B IN PROGRESS BIT
	TRNN AC2,-1		;IF TEMP RAN OUT,
	ANDCAM AC2,ASBTAB(TAC)	; THEN IT'S NO LONGER IN PROGRESS
ASSCB1:	TRNE AC1,-1
	JRST ASSCLN		;BEEP NOT DONE, CONTINUE SCAN
ASRVRT:	MOVE AC1,ASTAB(TAC)
	TLZE AC1,ASDBEP
	JRST ASRVR1		;GO AND BEEP
	TLNE AC1,ASTEMP		;SKIP IF GOING BACK TO PERM
	JRST ASRVR3		;GOING BACK TO TEMP
	TLNE AC1,ASHANG		;SKIP IF UUO NOT HUNG
	PUSHJ P,ASUNHG		;UNHANG UUO
	LDB AC2,[ASPRMP,,AC1]	;PERM SEL
ASRVR2:	HRLI AC2,(TAC)
	DATAO AS,AC2
	JRST ASSCLN		;CONTINUE SCAN

ASRVR3:	TRNE AC1,-1		;BACK TO TEMP SEL, SKIP IF INFINITE
	JRST ASRVR4
	TLNE AC1,ASHANG
	PUSHJ P,ASUNHG
ASRVR4:	LDB AC2,[ASTMPP,,AC1]	;TEMP SEL
	JRST ASRVR2

ASRVR1:	MOVEM AC1,ASTAB(TAC)	;STORE BACK WITH BEEP BIT OFF
	MOVEI AC2,ASBPTM
	HRRM AC2,ASBTAB(TAC)	;SET UP BEEP DURATION
	MOVEI AC2,ASBEPC
	JRST ASRVR2		;SELECT BEEP CHANNEL AND CONTINUE SCAN

ASSCTO:	TLZ AC1,ASTEMP		;TEMP SEL TIMED OUT, CLEAR TEMP BIT
	MOVSI AC2,ASEBNB	;ESC/BRK n B IN PROGRESS BIT
	ANDCAM AC2,ASBTAB(TAC)	;FLUSH IT!
	TLNE AC1,ASPAGN
	JRST ASSCT2		;PAGING NOW
	TLZE AC1,ASDBEP
	JRST ASRVR1		;DO DELAYED BEEP
	MOVEM AC1,ASTAB(TAC)
	TLNE AC1,ASHANG
	PUSHJ P,ASUNHG		;UNHANG UUO
ASSCT1:	LDB AC2,[ASPRMP,,AC1]
	JRST ASRVR2		;SELECT PERM AND CONTINUE SCAN

ASSCT2:	MOVEM AC1,ASTAB(TAC)	;JUST CLEAR TEMP BIT AND
	JRST ASSCLN		;CONTINUE SCAN

;UNHANG UUO THAT WAS WAITING FOR TEMP SEL TO FINISH
ASUNHG:	PUSH P,DDB
	PUSH P,J
	MOVSI J,ASHANG
	ANDCAM J,ASTAB(TAC)	;CLEAR UUO HANG BIT
	LDB J,[ASJOBP+TAC,,ASBTAB] ;JOB NUMBER TO UNHANG
	MOVM DDB,JOBQUE(J)
	CAIE DDB,IOWQ
	JRST ASUNHR		;NOT IN IOWQ NOW
	MOVEI DDB,RUNQ		;GRONK INTO RUNQ
	MOVNM DDB,JOBQUE(J)
	PUSHJ P,REQUE
ASUNHR:	POP P,J
	POP P,DDB
	POPJ P,

BREAKU:	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASTMPP,,AC1]	;TEMPORARY CHANNEL
	TLNN AC1,ASTEMP		;TEMP SELECTION IN EFFECT?
	LDB AC2,[ASPRMP,,AC1]	;NO, USE PERMANENT CHANNEL
	CAIN AC2,ASPAGC		;SKIP IF NOT LISTENING TO PAGING CHANNEL
	SKIPN PAGNOW		;SKIP IF PAGE IN PROGRESS
	JRST BRKU1		;NOT SELECTED TO PAGE IN PROGRESS
	PUSH P,TAC
	LDB AC2,[ASBPDP,,AC1]	;GET TEMP BEEP DISP
	TLNN AC1,ASTEMP		;SKIP IF TEMP
	LDB AC2,[ASPBUP,,AC1]	;PERM BEEP DISP
	MOVEI AC1,DPYL0(TAC)	;GET TTY NUMBER
	MOVSI TAC,764000+ASQUIC	;YES. MUST TEMPORARILY SELECT AWAY FROM IT
	DPB AC2,[POINT 2,TAC,8]	;MAKE NEW BEEP DISP SAME AS OLD
	PUSHJ P,ADSPHY		;DIDDLE AUDIO SWITCH
	POP P,TAC
	MOVSI AC1,ASBKUQ!ASBRKU	;FLAG THIS STATE TO SURVUVE RESETS
	IORM AC1,ASBTAB(TAC)
	POPJ P,

BRKU1:
IFN PKNUM,<
	TLZE AC1,ASPAGN		;SKIP IF NOT INTERRUPTED FOR PAGING
	JRST PKUNPU		;ROUTINE TO UNPAGE
>;IFN PKNUM
	MOVEI AC1,(TAC)		;ELSE SET UP AC1 FOR ADSMAP CODE
	JRST ADSRE2		;AND DO ADSMAP RESET

ESCB:	HRREI AC2,-DPYL0(LINE)
	JUMPL AC2,CPOPJ
	CAIL AC2,DDNUM+DPYNUM
	POPJ P,			;NEITHER A III NOR A DD
	MOVM TAC,AC1		;GET MAGNITUDE OF ARGUMENT
	CAIE TAC,ESCNUL		;NUMERIC ARG GIVEN?
	JRST CENSOR		;YES, TEMPORARY SILENCE
	MOVSI TAC,ASPBUN!ASBPDB	;BOTH TEMPORARY AND PERMANENT
	JUMPL AC1,ESCB1
	ANDCAM TAC,ASTAB(AC2)	;ESC B MAKES YOU BEEP INTERRUPTIBLE
	POPJ P,

ESCB1:	IORM TAC,ASTAB(AC2)	;BRK B MAKES YOU BEEP UNINTERRUPTIBLE
	POPJ P,

CENSOR:	IMULI TAC,4*=60		;CONVERT ARG FROM MINS TO 1/4 SECS
	HRLI TAC,760000+ASQUIC	;SET TEMPORARY, NO WAITING
	JUMPGE AC1,.+2		;SKIP IF ESC#B
	TLO TAC,4000		;BRK#B, NO PAGES ALLOWED
	MOVE AC1,ASTAB(AC2)	;GET AS INFO FROM BEFORE THIS COMMAND
	LDB AC2,[ASBPDP,,AC1]	;GET TEMP BEEP DISP
	TLNN AC1,ASTEMP		;SKIP IF TEMP
	LDB AC2,[ASPBUP,,AC1]	;PERM BEEP DISP
	DPB AC2,[POINT 2,TAC,8]	;MAKE NEW BEEP DISP SAME AS OLD
	MOVEI AC1,(LINE)	;TTY # IN AC1 FOR ADSMAP UUO CODE
	PUSHJ P,ADSPHY		;ENTRY FOR DIDDLING PHYSICAL TTY
	MOVSI TAC,ASEBNB	;BIT TO FLAG ESC/BRK n B
	IORM TAC,ASBTAB(AC1)	; USED TO AVOID PROGRAM RESET
	POPJ P,

>;IFN FTAS
;PKINTB PKPAGE PKSET PKCLR PKINT PKINL PKINLB PKINL1 PKINLA PKINP PKINND PKINN0 PKINN4 PKUNPU PKUNPG PKINN2 PKINN1 PKINN3 PKINNP
;PAGING INTERRUPT SERVICE ROUTINE

IFN PKNUM,<

↑PKINTB←←10			;INTERRUPT BIT IN CONI
↑PKPAGE←←20			;PAGING BIT IN CONI
↑PKSET←←10
↑PKCLR←←20

↑PKINT:	JSR PKSAV		;SAVES ACS AND PUSHJS TO .+1
	CONO PK,PKCLR!PKCHN
	MOVSI TAC,-<DPYNUM+DDNUM>
	CONSO PK,PKPAGE		;SKIP IF PAGING JUST BEGINNING
	JRST PKINND		;PAGING FINISHED
	SETOM PAGNOW		;INDICATE PAGING NOW IN PROGRESS
	MOVEI TAC1,-1
PKINL:	MOVEI DSER,0		;-1 means BEEPING
	TDNE TAC1,ASBTAB(TAC)
	MOVNI DSER,1		;BEEPING NOW
	MOVE AC1,ASTAB(TAC)
	TLNN AC1,ASTEMP		;SKIP IF TEMP SELECTION NOW IN FORCE
	JRST PKINP		;PERM
	LDB AC2,[ASPGDP,,AC1]
	CAIN AC2,1
	JRST PKINLA		;NOT PAGE INTERRUPTIBLE
PKINLB:	JUMPE DSER,PKINL1	;NOT BEEPING, JUST DO IT
	HLLZS ASBTAB(TAC)	;FLUSH BEEP
	TLO AC1,ASDBEP		;SET DELAYED BEEP BIT
PKINL1:	TLO AC1,ASPAGN		;PAGING NOW
	MOVEM AC1,ASTAB(TAC)
	MOVEI AC2,ASPAGC
	HRLI AC2,(TAC)
	DATAO AS,AC2
PKINLA:	AOBJN TAC,PKINL
	POPJ P,

;PERMANENT SELECTION IS NOW IN FORCE
PKINP:	TLNE AC1,ASPPUN		;SKIP IF PAGE INTERRUPTIBLE
	JRST PKINLA		;CONTINUE SCAN
	JRST PKINLB

;HERE IF PAGING INTERRUPT BUT PAGING BIT IS OFF
PKINND:	SETZM PAGNOW
PKINN0:	MOVE AC1,ASTAB(TAC)
	TLZE AC1,ASPAGN		;SKIP IF NOT INTERRUPTED FOR PAGING
	PUSHJ P,PKUNPG		;SUBROUTINE TO UNPAGE
	MOVSI AC2,ASBRKU
	ANDCAB AC2,ASBTAB(TAC)	;RESET BREAK U FLAG
	TLZN AC2,ASBKUQ		;HAD WE SELECTED ASQUIC TO AVOID THE PAGE?
	JRST PKINN4		;NO
	MOVEM AC2,ASBTAB(TAC)	;YES, CLEAR THE BIT
	PUSH P,TAC
	MOVEI AC1,(TAC)		;ADSRE2 WANTS DPY NUMBER HERE
	PUSHJ P,ADSRE2		;RESET TO PERMANENT SELECTION (WHICH'LL BE ASPAGC)
	POP P,TAC
PKINN4:	AOBJN TAC,PKINN0
	POPJ P,

;HERE WITH DPY NUMBER IN TAC AND ASTAB ENTRY IN AC1 TO UNDO PAGING INT FOR A DPY
PKUNPU:	MOVSI AC2,ASBRKU	;ENTRY FOR BREAK U, REMEMBER IT
	IORM AC2,ASBTAB(TAC)	; SO THAT IT'LL SURVIVE AUDIO RESET
PKUNPG:	TLZN AC1,ASDBEP		;SKIP IF HAVE TO DO BEEP NOW
	JRST PKINN1
	MOVEI AC2,ASBPTM
	HRRM AC2,ASBTAB(TAC)	;SET UP BEEP DURATION
	MOVEI AC2,ASBEPC	;SELECT BEEP CHANNEL AND CONTINUE SCAN
PKINN2:	MOVEM AC1,ASTAB(TAC)
	HRLI AC2,(TAC)
	DATAO AS,AC2
	POPJ P,

;DELAYED BEEP BIT WAS OFF
PKINN1:	TLNN AC1,ASTEMP		;SKIP IF GOING BACK TO TEMP SEL
	JRST PKINNP
	TRNE AC1,-1		;SKIP IF RETURNING TO INFINITE TEMP SEL
	JRST PKINN3
	TLNE AC1,ASHANG
	PUSHJ P,ASUNHG
PKINN3:	LDB AC2,[ASTMPP,,AC1]	;TEMP CHANNEL SELECTION
	JRST PKINN2

;GOING BACK TO PERMANENT SELECTION
PKINNP:	TLNE AC1,ASHANG		;SKIP IF UUO NOT HANGING
	PUSHJ P,ASUNHG		;UNHANG THE UUO
	LDB AC2,[ASPRMP,,AC1]	;PERMANENT CHANNEL SELECTION
	JRST PKINN2

>;IFN PKNUM
;ADSMAP ADSPHY ADSMAP ADSPH2 ADSRE1 ADSMP4 ADSMP1 ADSMP2 ADSMP5 ADSMT ADSMT1 ADSMT3 ADSMT6 ADSMT4 ADSMWT ADSMW1 DDIICK DDIIC2 ADSMRD ADSMR2 ADSMR1 ;⊗ ADSMAP ADSPHY ADSMAP ADSMP0 ADSPH2 ADSRE1 ADSMP4 ADSMP1 ADSMP2 ADSMP5 ADSMT ADSMT1 ADSMT3 ADSMT6 ADSMT4 ADSMWT ADSMW1 DDIICK DDIIC2 ADSMRD ADSMR2 ADSMR1

IFE FTAS,<
↑ADSMAP:POPJ P,	;No-op for non-DD, non-III TTYs
>;IFE FTAS
IFN FTAS,<	;Whole page

;ADSMAP AC, (EFFECTIVE ONLY FROM A JOB THAT IS ATTACHED TO ITS CONSOLE)
;AC BITS
;0	1 means TEMPORARY, 0 means PERMANENT
;1	1 means SET SELECTION, 0 means READ
;2	1 means MAKE THE SELECTION IMMEDIATELY (IF TEMP SEL)
;3	1 means DON'T HANG UNTIL PREVIOUS TEMP SEL IS COMPLETE
;4	1 means DON'T HANG UNTIL THIS TEMP SEL IS COMPLETE
;5-6	PAGING DISPOSITION
;7-8	BEEPING DISPOSITION
;13	set selection for physical line in RH (bit 1 must be on also)
;14-17	NEW SELECTION (AS CHANNEL NUMBER)
;RH	DURATION FOR TEMP SEL IN 1/4 SEC UNITS (phys line, if bit 13 is on)

;THE FOLLOWING ADDITIONAL BITS ARE RETURNED ON A READ STATUS:
;9	1 means THERE IS AN ACTIVE TEMP MAP FOR THIS LINE
;10	1 means THERE IS A PAGE IN PROGRESS (WHETHER OR NOT ON THIS LINE)
;11	1 means THERE IS A PAGE IN PROGRESS AND ENABLED ON THIS LINE
;12	1 means THERE IS A BEEP IN PROGRESS ON THIS LINE
;13	1 means THERE IS A DELAYED BEEP PENDING FOR THIS LINE

;IF THE AC CONTAINS -1, THE MAP IS RESET TO ITS PERMANENT STATUS

;IF TRYING TO MAKE A TEMP SEL WITHOUT WAITING FOR THE PREVIOUS TEMP
;SEL TO FINISH, THE UUO WILL BE IGNORED IF THE PREV TEMP SEL HAS NOT
;COMPLETED AND BIT 2 IS ZERO

;IF PERMANENT THEN ONLY LOW BIT OF DISPOSITION FIELD IS LOOKED AT

;DISPOSITIONS
;0	INTERRUPTIBLE
;1	NON-INTERRUPTIBLE
;2	INTERRUPTIBLE, BUT EXTEND DURATION OF TEMP CH
;3	POSTPONE BEEP UNTIL TEMP SELECTION TIMES OUT

;NOTE: 3 IS APPLICABLE ONLY TO BEEP DISPOSITION

;HERE FOR ADSMAP UUO
↑ADSMAP:JUMPL TAC,ADSMP0	;jump if temp request or reset, priv'd set not legal
	TLNE TAC,200000		;skip if only reading selection, not setting
	TLZN TAC,20		;skip if want to set someone else's audio
	JRST ADSMP0		;not privileged
	MOVE AC2,JBTPRV(J)	;priv'd request, check priv
	TLNN AC2,UPGPRV		;easy priv
	POPJ P,			;not enabled
	MOVEI AC1,(TAC)		;line number from temp duration field
	TRZ TAC,-1		;no temp duration now, fall into physical select
;ENTRY FROM ESC#B FOR PHYSICAL TTY (BETTER NOT WAIT)
ADSPHY:	PUSHJ P,DDIIC2		;MAKE SURE WE'RE ON A DD/III, adjust number in AC1
	 POPJ P,		;NOT DD OR III
	JRST ADSPH2

ADSMP0:	PUSHJ P,DDIICK		;See if on physical DD/III, get number into AC1
	 POPJ P,		;Nope, forget it
ADSPH2:	MOVE AC2,TAC
	AOJE AC2,ADSRE2		;TAC=-1 MEANS RESET TO PERM
	TLNN TAC,200000		;SKIP IF SETTING SELECTION
	JRST ADSMRD		;READ SELECTION
	OFFSCN			;TURN OFF SCANNER CHANNEL
	TLNN TAC,140000		;SKIP IF DON'T HAVE TO WAIT FOR PREV TEMP SEL
	PUSHJ P,ADSMWT		;WAIT FOR PREV
	 CAIA			;OK
	JRST SCNONJ		;JOB NOT ON DD/III ANY MORE (MAYBE DETACHED)
	MOVSI AC2,ASEBNB!ASBKUQ	;IF WE MAKE ANY SORT OF SELECTION,
	ANDCAM AC2,ASBTAB(AC1)	; ESC/BRK n B NO LONGER IN PROGRESS
	JUMPL TAC,ADSMT		;MAKE TEMP SEL
ADSRE1:	HLRZ TAC,TAC		;GET NEW CH # IN LOW 4 BITS
	MOVEI AC2,0
	DPB TAC,[ASPRMP,,AC2]	;PERM CH #
	MOVSI AC3,ASDBEP
	TDNE AC3,ASTAB(AC1)
	IOR AC2,AC3		;SET DELAYED BEEP BIT IF ALREADY SET
	LDB AC3,[000400,,TAC]	;CHANNEL TO SELECT TO
	TRNN TAC,4000		;SKIP IF PAGE UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP1
		JRST .+2]
	TLO AC2,ASPPUN		;SET PERM PAGE UNINTERRUPTIBLE BIT
	TRNN TAC,1000		;SKIP IF BEEP UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP2
		JRST ADSMP4]
	TLO AC2,ASPBUN		;SET PERM BEEP UNINTERRUPTIBLE BIT
	TLZ AC2,ASDBEP		;CLEAR DELAYED BEEP BIT IF NOT INTERRUPTIBLE
	HLLZS ASBTAB(AC1)	;FLUSH BEEPS
ADSMP4:	MOVEM AC2,ASTAB(AC1)
	HRLI AC3,(AC1)
	DATAO AS,AC3		;MAKE SELECTION NOW
	TRNN TAC,400000
	JRST SCNONJ		;MAKING PERM SEL, SO DON'T WAIT
	TRNN TAC,20000
	PUSHJ P,ADSMWT		;WAIT FOR TEMP SEL TO FINISH
	 JRST SCNONJ		;NORMAL RETURN
	JRST SCNONJ		;JOB NOT ON DD/III ANY MORE (MAYBE DETACHED)

;PAGE INTERRUPTIBLE, SO CHECK FOR PAGING GOING ON
ADSMP1:	SKIPN PAGNOW
	POPJ P,
	TLO AC2,ASPAGN		;SET PAGING NOW BIT
	MOVE DSER,ASBTAB(AC1)	;GET BEEP STATUS AND BREAK-U FLAG
	TLNN DSER,ASBRKU	;DON'T SELECT PAGING CHANNEL IF BREAK U IN PROGRESS
	MOVEI AC3,ASPAGC	;SELECT PAGING CHANNEL
	TRNN DSER,-1		;BEEP LENGTH NONZERO?
	POPJ P,			;NOT BEEP IN PROGRESS
	TLO AC2,ASDBEP		;SET DELAYED BEEP BIT
	HLLZS ASBTAB(AC1)	;FLUSH BEEP
	POPJ P,

;BEEP INTERRUPTIBLE, SO CHECK FOR DELAYED BEEP OR BEEP IN PROGRESS
ADSMP2:	TLNE AC2,ASDBEP		;SKIP IF NO DELAYED BEEP
	JRST ADSMP5
	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,CPOPJ	;NO BEEP IN PROGRESS EITHER
	MOVEI AC3,ASBEPC	;CONTINUE WITH BEEP
	POPJ P,

ADSMP5:	TLNE AC2,ASPAGN
	POPJ P,			;PAGING TAKES PRECEDENCE
	TLZ AC2,ASDBEP		;CLEAR DELAYED BEEP BIT
	MOVEI AC3,ASBPTM
	HRRM AC3,ASBTAB(AC1)	;START UP BEEP
	MOVEI AC3,ASBEPC
	POPJ P,

;MAKE TEMP SEL (SCNOFF)
ADSMT:	MOVE AC2,ASTAB(AC1)
	TRNE AC2,-1		;SKIP IF NO TEMP SEL IN PROGRESS OR INF TEMP SEL IS
	TLNE TAC,100000		;SKIP IF GRONK IS OFF
	JRST ADSMT1		;OK TO MAKE NEW TEMP SEL NOW
	JRST SCNONJ		;TEMP SEL IN PROGRESS, DON'T GRONK, DON'T WAIT--NOOP

ADSMT1:	MOVS TAC,TAC		;NEW CH # IN LOW 4 BITS, DURATION IN LH
	LDB AC3,[000400,,TAC]	;NEW CHAN SELECTION
	DPB AC3,[ASTMPP,,AC2]
	LDB TAC1,[130200,,TAC]	;NEW PAGING DISPOSITION
	CAIN TAC1,3
	MOVEI TAC1,1		;CHANGE 3 INTO 1
	DPB TAC1,[ASPGDP,,AC2]	;SET PAGE DISP
	LDB TAC1,[110200,,TAC]	;NEW BEEP DISPOSITION
	DPB TAC1,[ASBPDP,,AC2]	;SET BEEP DISP
	TLZ AC2,ASPAGN		;CLEAR PAGING NOW, ADSMP1 WILL SET IT IF INTERRUPTIBLE
	TRNN TAC,4000		;SKIP IF NOT PAGE INTERRUPTIBLE
	PUSHJ P,ADSMP1
ADSMT3:	CAIN TAC1,3
	JRST ADSMT4		;DELAY BEEP
	CAIE TAC1,1		;SKIP IF BEEP UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP2
		JRST ADSMT6]
	TLZ AC2,ASDBEP
	HLLZS ASBTAB(AC1)
ADSMT6:	HLR AC2,TAC		;DURATION
	TLO AC2,ASTEMP		;SET TEMP SEL BIT
	JRST ADSMP4

;DELAY BEEP MODE
ADSMT4:	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,ADSMT6
	TLO AC2,ASDBEP		;SET DELAYED BEEP BIT
	HLLZS ASBTAB(AC1)	;FLUSH BEEP NOW
	JRST ADSMT6

;WAIT UNTIL TEMP SELECTION IS DONE
ADSMWT:	MOVE AC2,ASTAB(AC1)
	TLNE AC2,ASHANG
	JRST ADSMW1
	MOVEI AC3,-1
	TDNN AC3,ASBTAB(AC1)	;SKIP IF BEEPING NOW
	TLNE AC2,ASPAGN		;SKIP IF NOT PAGING NOW
	JRST ADSMW1		;BEEP OR TEMP SEL - WAIT
	TRNN AC2,-1		;NOT BEEPING OR PAGING,TEST FOR TEMP SEL TO WAIT FOR
	POPJ P,			;NOTHING TO WAIT FOR
ADSMW1:	TLO AC2,ASHANG
	MOVEM AC2,ASTAB(AC1)
	DPB J,[ASJOBP+AC1,,ASBTAB] ;SAVE JOB NUMBER TO UNHANG LATER
	MOVEI AC2,IOWQ
	MOVNM AC2,JOBQUE(J)
	ONSCN			;TURN ON SCANNER CHANNEL
	PUSHJ P,WSCHED		;GO INTO IOWQ
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,DDIICK		;See if we're still on a physical DD/III
	 JRST CPOPJ1		;NOT DD OR III
	JRST ADSMWT		;LOOK AGAIN TO SEE IF TEMP SELECT IS DONE

;See if we're on a DD/III.  Skip if so.
DDIICK:	HRRE AC1,JBTLIN(J)	;See if we're on a DD/III
	JUMPL AC1,CPOPJ		;DETACHED
	CAIL AC1,TTPLEN
	POPJ P,			;ILLEGAL LINE NUMBER
	LDB AC1,[DDQREQ+AC1,,LSTESC] ;GET RESPONSIBLE TTY--WE DIDDLE HIS AUDIO
DDIIC2:	HRREI AC1,-DPYL0(AC1)	;ENTRY FROM ESC#B FOR PHYSICAL TTY
	JUMPL AC1,CPOPJ		;NOT DD OR III
	CAIL AC1,DPYNUM+DDNUM
	POPJ P,			;NOT DD OR III
	JRST CPOPJ1		;SUCCESS, REAL PHYSICAL DD/III

;READ AS STATUS INTO AC
ADSMRD:	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE AC2,PAGNOW
	HRRZ AC3,ASBTAB(AC1)
	MOVE TAC1,ASTAB(AC1)
	ONSCN			;TURN ON SCANNER CHANNEL
	HRR TAC,TAC1		;READ BACK DURATION
	TLZ TAC,177777
	TLNE TAC1,ASTEMP
	TLO TAC,400		;TEMP MAP IN EFFECT NOW
	JUMPE AC2,.+2
	TLO TAC,200		;THERE'S A PAGE GOING ON
	TLNE TAC1,ASPAGN
	TLO TAC,100		;WE'RE PAGING ON THIS LINE
	JUMPE AC3,.+2
	TLO TAC,40		;WE'RE BEEPING THIS LINE NOW
	TLNE TAC1,ASDBEP
	TLO TAC,20		;WE'RE GOING TO BEEP IT LATER
	JUMPGE TAC,ADSMR1	;JUMP IF READING PERM
	LDB AC2,[ASTMPP,,TAC1]	;TEMP CHAN SEL
	LDB AC3,[ASBPDP,,TAC1]	;TEMP BEEP DISP
	LDB TAC1,[ASPGDP,,TAC1]	;TEMP PAGE DISP
ADSMR2:	LSH TAC1,2
	IOR TAC1,AC3
	LSH TAC1,9
	IORI TAC1,200000(AC2)
	TSO TAC,TAC1
	JRST STOTAC

ADSMR1:	LDB AC2,[ASPRMP,,TAC1]	;PERM CHAN SEL
	LDB AC3,[ASPBUP,,TAC1]	;PERM BEEP UNINTERRUPTIBLE BIT
	LDB TAC1,[ASPPUP,,TAC1]	;PERM PAGE UNINTERRUPTIBLE BIT
	JRST ADSMR2

>;IFN FTAS
;ADSRES ADSRE2

IFN FTAS,<	;Whole page

;RESET AUDIO SWITCH MAP TO PERMANENT SETTING
;CALLED BY ADSMAP WITH AC=-1 AND BY RESET
↑ADSRES:HRRE AC1,JBTLIN(J)		;RESET JOB TO PERMANENT ADS MAP
	JUMPL AC1,CPOPJ			;DETACHED
	CAIL AC1,TTPLEN
	POPJ P,				;ILLEGAL LINE NUMBER
	LDB AC1,[DDQREQ+AC1,,LSTESC]	;GET RESPONSIBLE TTY--WE DIDDLE HIS AUDIO
	SUBI AC1,DPYL0
	JUMPL AC1,CPOPJ			;NOT DD OR DPY
	CAIL AC1,DPYNUM+DDNUM
	POPJ P,				;NOT DD OR DPY
	MOVSI TAC,ASEBNB		;GET ESC/BRK n B FLAG BIT
	TDNE TAC,ASBTAB(AC1)		; WHICH SHOULD SURVIVE PROGRAM RESET
	POPJ P,				; SO DON'T DO AUDIO RESET NOW
ADSRE2:	MOVEI TAC,0
	OFFSCN				;TURN OFF SCANNER CHANNEL
	MOVSI AC2,ASEBNB!ASBKUQ
	ANDCAM AC2,ASBTAB(AC1)		;EXPLICIT AUDIO RESET, NO MORE ESC/BRK n B
	LDB AC2,[ASPPUP,,ASTAB(AC1)]
	DPB AC2,[POINT 1,TAC,6]
	LDB AC2,[ASPBUP,,ASTAB(AC1)]
	DPB AC2,[POINT 1,TAC,8]
	LDB AC2,[ASPRMP,,ASTAB(AC1)]
	DPB AC2,[POINT 4,TAC,17]
	TLO TAC,360000
	JRST ADSRE1

>;IFN FTAS
;BEEP BEEPJB BEEP1 BEEPHY BEEPNV BEEPTX BEEPDX BEEPAW BEEPNP BEEPU BEEPND BEEPN2 BEEPN3 BEEPDM DMBDUN

;BEEP AC,
;AC HAS TTY NUMBER TO BEEP OR -1 FOR YOURSELF
↑BEEP:	JUMPGE TAC,BEEP1
↑BEEPJB:HRRZ TAC,JBTLIN(J)	;QXFER ENTERS HERE WHEN TIME TO TELL USER WE IS DONE
↑BEEP1:	CAIL TAC,TTPLEN
	POPJ P,			;ILLEGAL LINE NUMBER (MAYBE DETACHED JOB)
	SKIPE TTYTAB(TAC)	;NO ONE RESPONSIBLE IF NO DDB
	LDB TAC,[DDQREQ+TAC,,LSTESC] ;GET RESPONSIBLE TTY
↑BEEPHY:SUBI TAC,DPYL0		;COME HERE TO BEEP PHYSICAL TTY (FROM CTY BEEP CMD)
	JUMPL TAC,BEEPND	;NOT A DPY, TRY ↑G
	CAIL TAC,DPYNUM+DDNUM
	JRST BEEPND
IFN FTVBEEP,<
	SKIPN J,LETAB+DPYL0(TAC)	;Get structure for WHO line
	  JRST BEEPNV		;  Sorry, no beep on unused console
	MOVEI AC1,2*BEEPBL	;Number of times to complement who line
	EXCH AC1,VBEEP(J)
	JUMPN AC1,BEEPNV	;Don't bother with clock request if already active
	MOVEI AC1,DPYL0(TAC)	;Get real line number
	LSH AC1,=12		;SHIFT LINE NUMBER OVER TO DATA POSITION
	ADD AC1,[$WHORPT,,1]	;Wait one tick and update who line
	CLKENQ(AC1)		;Plant clk req
BEEPNV:	
>;IFN FTVBEEP
IFE FTAS,<
	POPJ P,
>;IFE FTAS
IFN FTAS,<
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASBPDP,,AC1]	;GET TEMP BEEP DISP
	TLNN AC1,ASTEMP		;SKIP IF TEMP
	LDB AC2,[ASPBUP,,AC1]	;PERM BEEP DISP
	TRNE AC2,1		;SKIP IF INTERRUPTIBLE
	JRST BEEPU
BEEPTX:	TLNN AC1,ASPAGN		;SKIP IF PAGING NOW
	JRST BEEPNP
BEEPDX:	TLO AC1,ASDBEP		;SET DELAYED BEEP
	MOVEM AC1,ASTAB(TAC)
	JRST SCNONJ

;ENTER HERE TO BEEP ALWAYS (EVEN IF HE DOESN'T WANT IT)
↑BEEPAW:SUBI TAC,DPYL0		;Make relative
	OFFSCN
	MOVE AC1,ASTAB(TAC)
	JRST BEEPTX

BEEPNP:	MOVEI AC2,ASBPTM
	HRRM AC2,ASBTAB(TAC)
	MOVEI AC3,ASBEPC
	HRLI AC3,(TAC)
	DATAO AS,AC3
	JRST SCNONJ

BEEPU:	TLNE AC1,ASTEMP		;SKIP IF PERM
	CAIN AC2,1
	JRST SCNONJ		;NOT INTERRUPTIBLE, SORRY
	JRST BEEPDX		;TEMP SEL (INF OR OTHERWISE), SET DELAYED BEEP
>;IFN FTAS

BEEPND:	MOVEI LINE,DPYL0(TAC)	;BEEP ADDRESSED TO NON-DPY
	PUSHJ P,GETDBA		;FIND OR CREATE DDB (DOESN'T CREATE IF PTY)
	 POPJ P,		;NO SUCH TTY OR NO DDBS AVAILABLE
	HLL LINE,LINTAB(LINE)	;Get bits
	TLNE LINE,DMLIN
	JRST BEEPDM
BEEPN2:	MOVEI TAC,GAGBIT!GAGTBT
	TLNE LINE,PTYLIN	;DON'T ALLOW BEEPING OF GAGGED PTYS
	TDNN TAC,IMLHAC(DDB)
	JRST BEEPN3
	SKIPN LINE,PTYJOB-PTYL0(LINE) ;GAGGED PTY--GET OWNER JOB
	POPJ P,			;no owner, can't beep anyone
	HRRZ TAC,JBTLIN(LINE)	;AND GET HIS TTY LINE
	JRST BEEP1		;AND TRY TO BEEP THAT TTY INSTEAD

BEEPN3:	MOVE CHR,DEVIOS(DDB)	;GET MODE
	TRNE CHR,10		;IMAGE? (10 OR 11)
	TRNE CHR,6
	JRST .+2
	POPJ P,			;YES, DON'T DO IT
	MOVEI CHR,7		;GOBBLE A BELL
	PUSHJ P,OUTCHR		;SOCK IT TO HIM!
	JRST TYPGO		;START UP OUTPUT

;Here when trying to beep a DM.  We queue up the beep in the special queue.
;Note that if the DM is in image mode, the queues don't get output so
;the beep will be suppressed as on plain TTYs in image mode.
BEEPDM:	SKIPN DAT,LETAB(LINE)	;Better have a dpy header
	JRST BEEPN2		;Can't happen
	OFFSCN
	MOVE AC2,DMFLAG(DAT)
	TROE AC2,DMBPND		;Is there already a beep pending on this DM?
	JRST SCNONJ		;Yes, discard this new beep
	MOVEM AC2,DMFLAG(DAT)	;No, but there will be in a moment
	ONSCN
	PUSHJ P,GETQ
	HRLI DAT,DMQUOT!DMATXY!DMXCAL ;Quote the bell and don't care where cursor is
	MOVSM DAT,QFLAGS(AC1)
	MOVE AC2,[POINT 7,[ASCII /π/]]
	MOVEM AC2,QTAKR(AC1)
	MOVEI AC2,1		;Send one bell
	MOVEM AC2,QDMCNT(AC1)
	MOVEI AC2,DMXY(DAT)
	MOVEM AC2,QXYLOC(AC1)	;Use actual XY position to mean don't care
	MOVSI AC2,DMBDUN	;Routine to call when beep done
	MOVEM AC2,QFREE(AC1)
	SETZM QCOUNT(AC1)	;Don't wake anyone
	MOVEI AC2,DMSPPT-QLINK(DAT)
	PUSHJ P,QDM		;Queue the beep in special queue
	JRST STRTDM

;Here when above queue entry for beep has been output.
DMBDUN:	MOVEI DAT,DMBPND
	ANDCAM DAT,DMFLAG(J)	;Flag that this beep finished
	POPJ P,
;TYPX COMSET
;ROUTINE TO TYPE X IF LINE CANNOT GET INTO SYSTEM

TYPX:	SUB P,[1,,1]
	ANDI CHR,177
	CAIN CHR,"X"		;CHAR. RECEIVED AN "X"
	POPJ P,			;YES, MAY BE ECHO, DISMISS INT.
	MOVEI CHR,"X"
	MOVEI DDB,0		;We didn't find a DDB, so let TYPL know it
	JRST TYPL		;TYPE OUT "X"

;ROUTINE TO WAKE UP COMMAND DECODER IF TPMON IS SET

↑COMSET:TLNN IOS,TTYDTC		;DETACHED GUYS CAN'T SAY ANYTHING!
	TLNN IOS,TPMON		;MONITOR MODE?
	POPJ P,			;NO, NOT MONITOR COMMAND
	MOVE TAC,DEVMOD(DDB)	;GET SOME GOOD BITS
	TLNN TAC,TTYATC		;IF NOT A CONSOLE
	TRNN TAC,ASSCON!ASSPRG	;AND ASSIGNED BY PROGRAM OR CONSOLE
	JRST .+2
	POPJ P,			;THEN HE CAN'T TYPE COMMANDS
	MOVSI IOS,IOFST
	IORB IOS,DEVIOS(DDB)
	MOVSI TAC,COMBIT	;SET SIGN BIT
	OFFSCN
	TDNN TAC,TTYTAB(LINE)	;SKIP IF COMMAND BIT IS ON
	AOS COMCNT		;COUNT ANOTHER COMMAND WE HAVE
	IORM TAC,TTYTAB(LINE)	;IN TTY TRANSLATOR TABLE
	JRST SCNONJ
;TTED02 TTED03 TTEDIT TTED01 TTED04 TTEDT2 TTED00 TTEDT3 TTEDT0 TTEDT1 TIPACK TTIPUT TTIPT1 TTPT2 DUPLEX DUPLX2 TINSLF INBFUL

;TTY KEYBOARD EDITOR ROUTINE
;UPON RECEIPT OF A CHARACTER, THIS ROUTINE DETERMINES WHAT TO DO
;WITH IT: WHETHER IT'S A SPECIAL CHARACTER NEEDING SPECIAL ECHOING,
;WHETHER SOME OTHER CHARACTER IS TO BE STORED IN ITS PLACE, WHETHER
;IT IS A BREAK CHARACTER (LINE TERMINATOR), OR WHETHER THE CHARACTER
;TYPED IS A SIGNAL TO UNDERTAKE SOME SPECIAL ACTION.
;IN ANY CASE, ALL SPECIAL ACTION, INCLUDING DUPLEXING TAKES PLACE ON
;THE LEVEL OF THIS ROUTINE.
;	THIS ROUTINE CALLS SPCHEK, WHICH MAKES USE OF THE  SPECIAL
;CHARACTER TABLE, SPCTAB. TO MAKE ANY CHANGES IN THE ACTION GENERATED
;BY SPECIFIC CHARACTERS MAKE THE ALTERATIONS REQUIRED BY THE
;COMMENTS DESCRIBING SPCTAB.  NOTE THAT IF A CHARACTER IS TO DISPATCH
;TO A "SPECIAL ACTION ROUTINE" OR A SPECIAL ECHO ROUTINE, THE LEFT
;HALF OF THE CORRESPONDING CHARACTER-WORD MUST HAVE SPACTN
;SET  AND THE ADDRESS OF THE SPECIAL ROUTINE MUST BE
;ASSEMBLED INTO THE RIGHT HALF OF THE WORD.
;CALL:	HAVE 7-BIT ASCII CHARACTER IN CHR
;	LDB HPOS,PHPOS
;	MOVEI DAT,TTIBUF(DDB)
;	PUSHJ P,TTEDIT
;	 RETURN HERE IF ↑← CMD THAT DOESN'T PUT ANYTHING IN INPUT BUFFER
;	RETURN WITH ACTION DONE, SYNC (LH IOS) SET IF BREAK CHAR. STORED

TTED02:	PUSHJ P,SPCHEK		;GET BITS FROM SPCTAB
	 AOJA HPOS,TTED03
	TLNE TAC,BNQUOT		;IS THIS SPECIAL VERY SPECIAL?
	TLZ TAC,ALLSPA+SPACTN+ECHSUP	;NO SPECIAL ACTION FOR THIS CHARACTER
	PUSHJ P,QUOTHP		;DO ADJHP WITH MODIFIED BITS
	 JFCL
TTED03:	LDB UCHN,[POINT 2,CHR,28]
	JRST TTED00

TTEDIT:	AOS (P)			;ASSUME SKIP RETURN
	SKIPE PHYLIN
	JRST TTED01		;JUMP IF CHAR WAS PHYSICALLY TYPED
	MOVE TAC,JOB		;WHO IS WRITING THIS PTY STUFF?
IFN FTIP,<
	TLNN LINE,PTYLIN	;Is it really a PTY?
	JRST TTED02		;PTY write to real TTY
	SKIPE PTYIMP-PTYL0(LINE) ;Is it an IMP PTY?
	JRST TTED01		;Yes, no problem
>;IFN FTIP
IFE FTIP,<
	TLNE LINE,PTYLIN	;IS IT REALLY A PTY (DRD)?
>;IFE FTIP
	CAME TAC,PTYJOB-PTYL0(LINE)	;YES, IS WRITER THE PTY'S OWNER?
	JRST TTED02		;PTY WRITE TO REAL TTY OR NOT BY OWNER, NO ↑←
TTED01:	TRNE CHR,RTILDE		;IF CHAR IS A MAGIC NETWORK TILDE,
	TDZA TAC,TAC		; WE CAN'T CALL SPCHEK WHICH KILLS FLAG BIT
	PUSHJ P,SPCHEK		;GET CHAR'S MAGIC BITS IN TAC LH
	 JFCL
	HRR TAC,IMLHAC(DDB)	;RH GETS PENDING BAKNXT STATUS
	CAIN CHR,37		;IF THIS CHAR IS ↑←
	JRST TTED04		; THEN BUCKIFICATION DOESN'T QUOTE IT
	TRNE TAC,BNCNTL!BNMETA	;IF ANY BUCKY BITS WERE SET,
	TLNN TAC,BNQUOT		; THEN QUOTE QUOTABLE CHAR
TTED04:	TRNE TAC,BNPEND		;WAS PREVIOUS CHAR ↑← ?
	JRST DOBKNX		;YES, PROCESS SPECIAL COMMAND
	PUSHJ P,ADJHP		;ADJUST HP AND CHECK SPECIAL
	 JFCL
	CAIN CHR,37		;DON'T DIDDLE BUCKIES FOR ↑←
	JRST TTED00		;REPLACE THIS KLUDGE WITH A BIT!
TTEDT2:	TLNN LINE,DDDLIN!DISLIN!DMLIN	;DPYS COME HERE FOR CALL, W/UCHN SET!
	TRNE UCHN,-1		;DON'T CLOBBER PTYJOB-USER-TYPED BITS
	JRST .+2
	LDB UCHN,BNBBBP		;GET BUCKY BITS FROM ↑←C ↑←M OR ↑←D
	HRLZI UCHN,(UCHN)	;GET A ZERO
	DPB UCHN,BNBBBP		;CLEAR THOSE BITS IN IMLHAC
	HLRZ UCHN,UCHN		;PUT BACK UCHN
TTED00:	PUSH P,DAT		;PUTCHI NEEDS DAT
	PUSH P,TAC		;CKBITS MAY CALL SPCACT, WHICH CLOBBERS TAC
	MOVE DAT,LINE		;CKBITS IS IN LINED, HAS FUNNY ACS
	TRNE CHR,177		;CAN'T SUPPRESS CALL
	PUSHJ P,CKBITS		;ASK LINED TO CHECK OUT THE BUCKY BIT SITUATION
	POP P,TAC
	POP P,DAT
	MOVE AC1,ACTMOD(DDB)	;GET SPECIAL ACTIVATION MODES
	CAIN UCHN,3
	TRNN AC1,SUPSCM		;SUPPRESS SUPPRESSION OF CONTROL-META-CHAR
	TRNN AC1,SUPBTS		;SUPPRESS ACTIVATION OF BUCKY BITS
	JUMPN UCHN,TTEDT3	;BUCKY BITS, EITHER ACTIVATOR OR FUNNY CALL
	TLNE LINE,SPCBRK	;SPECIAL ACTIVATION MODE?
	TLNE IOS,TPMON
	JRST TTEDT0
	PUSH P,TAC
	PUSHJ P,SPCACT
	 TLO IOS,SYNC
	POP P,TAC
	TLNN TAC,ALLSPA
	TLNN IOS,SYNC
	CAIA
	TLZ TAC,SPACTN		;INHIBIT ANY SPECIAL ACTION IF A BREAK
	JRST TTEDT0

TTEDT3:	TLNN TAC,ALLSPA		;BUCKY BITS, TURN OFF SPECIALNESS
	TLZ TAC,SPACTN		; UNLESS ALLSPA
	CAIA			;IT'S A BREAK
TTEDT0:	TLNE TAC,BREAKB!FCSBRK
	TLO IOS,SYNC		;IT'S A BREAK CHAR.
TTEDT1:	MOVEM IOS,DEVIOS(DDB)	;SET SYNC
IFN FTESCCBUG,< SCPICK >	;CHECK PI STATUS
	JUMPL TAC,(TAC)		;JUMP IF CHARACTER HAS SPECIAL DISPATCH
TIPACK:	ANDI CHR,177
	CAIG CHR,"Z"+40
	CAIGE CHR,"A"+40	;LOWER CASE LETTER?
	JRST TTIPUT		;NO
	TLNN LINE,FCS		;LOWERCASE.  FULL CHARACTER SET TTY?
	TRZ CHR,40		;NO. MAKE CHAR UPPER CASE
TTIPUT:	TLZE LINE,ROBTPD	;HAVE WE BEEN DELETING?
	PUSHJ P,BSECHO		;YES. OUTPUT A BACKSLASH
TTIPT1:	DPB UCHN,[POINT 2,CHR,28] ;PUT IN CTRL. BITS.
TTPT2:
IFN FTMONCIP,<
	HRRZ AC1,MONCIP(DDB)	;GET POSITION OF PROTECTED MON CMD IN BUFFER, IF ANY
	CAME AC1,TIPCTR(DDB)	;DON'T LET INPUT CLOBBER MONITOR COMMAND IN PROGRESS
>;IFN FTMONCIP
	PUSHJ P,PUTCHI		;PUT CHAR IN INPUT BUFFER
	 JRST INBFUL		;IT DIDNT FIT
	TLNN TAC,ECHSUP		;SHOULD THIS CHAR BE ECHOED?
DUPLEX:	TLNE LINE,FULTWX	;IS THIS LINE ECHOING ITSELF?
	JUMPE UCHN,CPOPJ	;YES, DON'T ECHO UNLESS CTRL BITS ON.
DUPLX2:	TLNN IOS,TPMON		;SHOULD ECHO IF IN MONITOR MODE
	TRNN IOS,NOECHO		;AND UNLESS USER SAYS NO, IN USER MODE
	JRST DUPIML		;SO ECHO IT.
	POPJ P,			;DONT ECHO IF REQUESTED NOT TO BY USER

;Here to insert LF after CR without echoing it.
TINSLF:	DPB UCHN,[POINT 2,CHR,28] ;PUT IN CTRL. BITS.
IFN FTMONCIP,<
	HRRZ AC1,MONCIP(DDB)	;GET POSITION OF PROTECTED MON CMD IN BUFFER, IF ANY
	CAME AC1,TIPCTR(DDB)	;DON'T LET INPUT CLOBBER MONITOR COMMAND IN PROGRESS
>;IFN FTMONCIP
	PUSHJ P,PUTCHI		;PUT CHAR IN INPUT BUFFER
	 JRST INBFUL		;IT DIDNT FIT
	POPJ P,

INBFUL:	CAIN CHR,600		;CHAR WONT FIT. WAS IT ↑C?
	JRST CNCTS1		;YES. PANIC OUT OF THIS BIND
;;	MOVEI CHR,7		;NO. JUST ECHO BELL TO SHOW LOSS
;;	JRST PUTCHO		;OUTPUT BELL, IF NOT  DPY.
;;	TLO IOS,SYNC		;BUFFER FULL, ACTIVATE ALL PREVIOUS CHARS
;;	MOVEM IOS,DEVIOS(DDB)	;SET SYNC
;;NOCALL takes care of buffer full, or buffer almost full.
	POPJ P,
;⊗ AOJDPX DUPLX1 DUPIML DUPKIL DUPNVT DUPNV1 DUPNV2 DUPLA DUPLA0

;Here from various places when echoing a character.
AOJDPX:	ADDI HPOS,1
DUPLX1:	PUSH P,TAC
	MOVEI TAC,0		;NO UPARROW STUFF FROM THIS ENTRY
	PUSHJ P,DUPLX2
	POP P,TAC
	POPJ P,

;Here from TTEDIT to echo character on non-display.
DUPIML:	PUSHJ P,DUPNVT		;IF NVT (ARPA PTY) CHANGE CHRS TO ASCII
	TLNE TAC,ARRBIT		;BH 4/27/75
	TLNN LINE,ECHARR	;IF AN UPARROW CHARACTER
	JRST PUTCHO		;AND IN THE RIGHT MODE,
DUPKIL:	PUSH P,CHR		;DO IT! (ENTER HERE FROM TTYKCL W/↑U)
	MOVEI CHR,"↑"
	PUSHJ P,PUTCHO
	POP P,CHR
	ADDI CHR,100
	JRST PUTCHO

;Here from OUTCHA for output and from DUPIML above for echoing.
DUPNVT:	TLNE LINE,DDDLIN!DISLIN!DMLIN
	POPJ P,			;NO SPECIAL WORK FOR DISPLAYS
	TLNE LINE,PTYLIN	;SKIP IF REAL TTY
	JRST DUPNV1
	PUSH P,TAC
	MOVE TAC,IMLHAC(DDB)	;DOES USER WANT CONVERSION?
	TRNE TAC,CVTBIT		;BIT MUST BE ON TO AVOID CONVERSION
	JRST TPOPJ		;BIT ON, RESTORE TAC AND LEAVE
	POP P,TAC
	JRST DUPNV2

;HERE IF PTY
DUPNV1:	TLNN LINE,IMPBIT	;OF PTYS, ONLY ARPA PTYS GET CONVERSION
	POPJ P,
DUPNV2:	ANDI CHR,177		;NO MORE BUCKY BITS!  BETTER NOT NEED 'EM ANYMORE.
	CAIN CHR,175		;NVT ECHO
	MOVEI CHR,33		;ALT
	CAIN CHR,176
	MOVEI CHR,175		;RIGHT BRACE
	CAIE CHR,30
	CAIN CHR,137
	JRST DUPLA
	CAIE CHR,32
	POPJ P,
	MOVEI CHR,176		;TILDE
	TLZ TAC,ARRBIT		;NOT AN UPARROW CHARACTER NOW
	POPJ P,

DUPLA:	HLL CHR,DPYDES(LINE)	;check left arrow bit
	TLNE CHR,LEFTAR		;Does this terminal display left arrow?
	JRST DUPLA0
	TRC CHR,30≠137		;No, interchange left arrow and underscore
	TLC TAC,ARRBIT		;exactly one of 30 and 137 is an arrow character
DUPLA0:	MOVEI CHR,(CHR)		;flush left half DPYDES flags
	POPJ P,
;CONTC CONTC2 CONTZ CONTOB CONTO CONTU CONTU1 ALTMOD CONTS CONTQ TTYUNH
;CALLED WITH A JUMPL TAC,(TAC), WHERE TAC IS LOADED FROM SPCTAB
;SPECIAL CHARACTER HANDLING ROUTINES


CONTC:	PUSHJ P,DELETL		;SINCE PEOPLE WANT FREE ↑U
	TLNN LINE,DDDLIN!DISLIN!DMLIN ;IF THIS IS A DPY
	JRST CONTC2
	JUMPG UCHN,CONTC2	;AND IF NO CTRL BITS ARE ON,
	PUSHJ P,CNCTS1		;PROCESS CONTROL C IMMEDIATELY.
CONTC2:	MOVEI UCHN,0		;BH 1/13/78 PREVENT ECHO OF 600 BY TTPT2
	MOVE TAC,SPCTAB		;SINCE DELETL CLOBBERS TAC
	PUSHJ P,TTPT2		;PLACE IN BUFFER.
	MOVEI CHR,3
	PUSHJ P,CNTLEC
	JRST CRLFEC

CONTZ:	TLZE LINE,ROBTPD	;HAVE WE BEEN DELETING?
	PUSHJ P,BSECHO		;YES. OUTPUT A BACKSLASH
	PUSHJ P,CNTLEC		;OUTPUT ↑C OR ↑Z
	PUSHJ P,CRLFEC		;OUTPUT A CRLF
	MOVEI CHR,3B28!12	;CHANGE TO INTERNAL CODE.
	TLO IOS,SYNC
	JRST TTPT2		;ACTIVATE BUT DON'T STORE (THIS COMMENT IS A LIE)

CONTOB:	MOVEI CHR,"O"-100	;INVENT A ↑O.  HERE FROM LINED
CONTO:	PUSHJ P,SETBF2		;CLEAR THE OUTPUT BUFFER
	MOVEI IOS,IOSUPR	;SET TO JUNK FURTHER OUTPUT
	XORB IOS,DEVIOS(DDB)
	TRNE IOS,IOSUPR		;DID WE JUST CLEAR THE BIT?
	TLNN LINE,PTYLIN	;YES, IS THIS A PTY?
	JRST CONTU1		;NO, GO ECHO, ETC.
	MOVSI AC1,INTFOP	;INTERRUPT FOR FLUSHING OUTPUT
	TLNN LINE,DMLIN		;SORRY CAN'T FLUSH STUFF ON DM, NOT FROM OUTPUT BUF
	PUSHJ P,PTINTC		;REQUEST INTERRUPT IF ENABLED
	JRST CONTU1		;NOW GO ECHO, ETC

CONTU:	TLNE IOS,DDTM		;IN DDTMODE,
	JRST TTIPUT		; PASS THIS CHARACTER
	PUSHJ P,DELETL		;↑U DELETES INPUT LINE
CONTU1:	PUSHJ P,CNTLEC		;ECHO ↑O OR ↑U
	JRST CRLFEC		;OUTPUT A CRLF AND RETURN WITHOUT
				; STORING THE ↑O OR ↑U

ALTMOD:	HRRI TAC,(CHR)		;SAVE WHICH KIND OF ALTMOD
	MOVEI CHR,44		;ECHO A DOLLAR SIGN
	PUSHJ P,AOJDPX
	MOVEI CHR,(TAC)		;RESTORE THE CHARACTER
	JRST TTIPUT		;STORE THE CHARACTER

;here from TTEDIT via dispatch in SPCTAB.
;↑S start holding
CONTS:	TLZA IOS,TTYHLD		;Turn off the hold flag so the TLCE will turn it on
;↑Q stop holding
CONTQ:	TLO IOS,TTYHLD		;Turn on the hold flag so the TLCE will turn if off
;Note: IOS doesn't get stored by our caller, in case we don't really want to hold.
	SOS (P)			;don't let TTEDIT skip return, no input generated
	TLNE LINE,TLKRNG	;DON'T ALLOW HOLDING IF TALKING.
	POPJ P,			;TALKING
IFN FTF2,<
	TLNN LINE,CTYLIN	;SPECIAL DDT KLUDGE FOR F2 TO GET INTO DDT
	JRST TTYUNH
	PUSHACS			;Now use ↑Q or ↑S to go to EDDT on F2.
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,DDTCAL
	POPJ P,

>;IFN FTF2
TTYUNH:	TLCE IOS,TTYHLD		;Toggle the hold flag.
	TLNE LINE,PTYLIN	;BH
	JRST .+2		;BH
	TLZ IOS,TOIP!IRMA	;If it was on, turn off TOIP.  The
	MOVEM IOS,DEVIOS(DDB)	;STO IOS BACK
	POPJ P,			;next call to TYPTST will restart the output
;RUBOUT RUBOU2 WRDRB1 WRDRUB RUBOU1 RUBOU3 RUBOU4 RUBOU5 DELWRD DELWR1 DELWR0 DELWR2 DELWR3 DELWR4 CLKRUB DELBAK DELBK2 DELBK5 DELBK3 DELBK9 CONTK CONTL SIMFF CONTI1 SIMFF1

RUBOUT:	TLNE IOS,TPMON		;IN MONITOR MODE, NOT A BREAK CHAR
	JRST RUBOU2		; AND IGNORE BSACT
	TDNE IOS,[DDTM,,BKSP]
	JRST TTIPT1		;STORE RUBOUT IF DDT OR FCS
	MOVEI IOS,BSACT		;DOES HE WANT TO GET BS FROM
	TDNN IOS,ACTMOD(DDB)	; BEGINNING OF LINE?
	JRST RUBOU2		;NOPE
	LDB IOS,PLSTLC		;YES
	CAME IOS,PCTR(DAT)	;IS THIS THE BEGINNING OF THE LINE?
	JRST RUBOU2		;NO
	MOVE IOS,DEVIOS(DDB)	;YES, RESTORE IOS AND
	JRST TTIPUT		; NOW GO STUFF THE BS UP HIS BUFFER

RUBOU2:	MOVSI IOS,SYNC		;THIS RO IS NOT A BREAK, IT IS A DELETE.
	ANDCAB IOS,DEVIOS(DDB)
	LDB CHR,PUTR(DAT)	;GET LAST CHAR IN
WRDRB1:	PUSHJ P,DCPUTR		;BACK UP TIPUTR
	 JRST RUBOU1		;IT'S EMPTY ALREADY
WRDRUB:	MOVEI TAC,GLASSB	;TTY GLASS?
	TDNE TAC,IMLHAC(DDB)
	JRST RUBOU3		;YES
	TLON LINE,ROBTPD	;MARK IN RUBOUT SEQUENCE
	PUSHJ P,BSECHO		;AND OUTPUT BACKSLASH IF FIRST
	PUSHJ P,ADJHP		;ADJUST HPOS FOR THIS CHR
	 JFCL			;IGNORE SKIP RETURN
	JRST DUPLX2		;DUPLEX (POSSIBLY WITH UPARROW)

RUBOU1:	TLZE LINE,ROBTPD	;END OF INPUT STREAM REACHED
	PUSHJ P,BSECHO		;OUTPUT A BACKSLASH
	JRST CRLFEC		;AND A CR LF

RUBOU3:	PUSHJ P,SPCHEK		;IS THIS AN UPARROW CHARACTER?
	 JFCL
	TLNE TAC,ARRBIT
	TLNN LINE,ECHARR	;IF THIS IS AN UPARROW CHAR
	JRST RUBOU4		;  AND WE'RE IN THE RIGHT MODE,
	CAIE CHR,32		;  (SPECIAL CHECK FOR TILDE, SPCTAB THINKS IT'S EOF)
	PUSHJ P,RUBOU4		;  BACK UP TWICE
RUBOU4:	MOVE CHR,TOFCTR(DDB)	;GET FREE CHARACTER COUNT
	CAIGE CHR,4		;ROOM FOR 3 CHARS?
	JRST RUBOU5		;NO, COUNT THE NUMBER OF LOSSES
	MOVEI CHR,10		;TTY GLASS, ECHO AS BS-SP-BS
	PUSHJ P,DUPLX1
	MOVEI CHR,40
	PUSHJ P,DUPLX1
	MOVEI CHR,10
	SOJA HPOS,DUPLX1	;BACK UP HPOS ALSO

RUBOU5:	AOS RUBLUZ		;COUNT UNECHOED RUBOUTS
	POPJ P,

;ROUTINE TO DELETE AN ENTIRE WORD, CALLED BY ↑←W

DELWRD:	MOVE AC1,PRGESC(LINE)	;GET ESCAPE PARAMETERS (ARG AND SIGN)
	LDB AC1,[ESCARG,,AC1]	;GET NUMERIC VALUE
	CAIN AC1,ESCNUL		;DO THIS STUPID KLUDGE
	MOVEI AC1,1
	SETZM RUBLUZ		;COUNT OF UNECHOABLE RUBOUTS
	JRST DELWR0

DELWR1:	PUSHJ P,WRDRUB		;RUB OUT THIS CHAR
DELWR0:	LDB CHR,PUTR(DAT)	;GET LAST CHAR IN
	PUSHJ P,DCPUTR		;BACK UP TIPUTR
	 JRST DELWR4		;IT'S EMPTY ALREADY
	PUSHJ P,SPCHEK		;WHAT DID WE GET?
	 TLNN TAC,LNUMBT	;NOT SPECIAL, SKIP IF ALPHAMERIC
	JRST DELWR1		;SPECIAL OR NOT ALPHAMERIC, KEEP BACKING UP
	PUSHJ P,WRDRUB		;REACHED FIRST LETTER, TELL USER IT'S GONE
DELWR2:	LDB CHR,PUTR(DAT)	;NOW FIND FIRST NON-LETTER
	LDB TAC,PLSTLC		; CHECK FOR NONE TO DELETE
	CAMN TAC,PCTR(DAT)
	JRST DELWR4		;IT'S EMPTY ALREADY
	PUSHJ P,SPCHEK		;WHAT DID WE GET?
	 TLNN TAC,LNUMBT	;NOT SPECIAL, SKIP IF ALPHAMERIC
	JRST DELWR3		;SPECIAL OR NOT ALPHAMERIC, TIME TO FINISH UP
	PUSHJ P,WRDRB1		;ALPHAMERIC, FLUSH IT
	JRST DELWR2

DELWR3:	SOJG AC1,DELWR0		;JUMP IF SOME ARG LEFT
DELWR4:	DPB HPOS,PHPOS		;STORE NEW HORIZ POSITION
	SKIPN TAC,RUBLUZ	;SKIP IF SOME UNECHOED GLASS RUBOUTS
	JRST STOLIN		;ELSE DONE
	DPB LINE,[POINT PUNITS,TAC,17+PUNITS]
	HRLI TAC,CLKRUB		;CLK LVL ROUTINE TO FIX IT UP
	SYSPIFF
	IDPB TAC,CLKQ
	SYSPIN
	JRST STOLIN

;CLOCK LEVEL ROUTINE.  ENTER WITH DAT BITS 18:17+PUNITS = TTY LINE NUMBER,
;18+PUNITS:35 = NUMBER OF BS-SP-BS SEQUENCES REQUIRED

CLKRUB:	LDB LINE,[POINT PUNITS,DAT,17+PUNITS]
	LDB UUO,[POINT 18-PUNITS,DAT,35]
	SKIPN DDB,TTYTAB(LINE)	;FIND THE TTY
	POPJ P,			;GONE, FORGET IT
	PUSHJ P,STLNAC
	OFFSCN
	MOVE IOS,DEVIOS(DDB)
	LDB HPOS,PHPOS
	SETZM RUBLUZ
	PUSHJ P,RUBOU4		;ECHO ONE RUBOUT
	SOJG UUO,.-1		;LOOP UNTIL DONE
	PUSHJ P,DELWR4		;MAYBE WE STILL HAVE SOME WHICH FAILED
	JRST SCNONJ

;ROUTINE TO DELETE BACK TO SPECIFIED CHAR, FOR ↑←L

DELBAK:	MOVEI TAC,BNLFLG	;TURN OFF ↑←L FLAG
	ANDCAM TAC,IMLHAC(DDB)
	MOVEI AC3,(CHR)		;SAVE TARGET CHAR IN A SAFE AC
	MOVE AC1,PRGESC(LINE)	;GET ESCAPE PARAMETERS (ARG AND SIGN)
	LDB AC1,[ESCARG,,AC1]	;GET NUMERIC VALUE
	CAIN AC1,ESCNUL		;DO THIS STUPID KLUDGE
	MOVEI AC1,1
	SETZM RUBLUZ		;NO UNECHOED RUBOUTS SO FAR
DELBK2:	PUSH P,AC1		;SAVE ARG
	PUSHJ P,LINSCN		;SCAN ENTIRE LINE FOR IT
	 CAIE AC3,(CHR)		;TEST INSTRUCTION, XCTED FOR EACH CHAR
	 JRST DELBK9		;RETURN HERE IF NO MATCH FOUND
	CAMN AC1,TIPCTR(DDB)	;IS COUNT EXHAUSTED?
	JRST DELBK9		;YES, THE ONLY ONE FOUND WAS THE LAST CHAR
	POP P,AC1
DELBK5:	PUSHJ P,WRDRB1		;DELETE ONE CHAR FOR SURE
	LDB CHR,PUTR(DAT)	;NOW FIND TARGET
	LDB TAC,PLSTLC		; CHECK FOR NONE TO DELETE
	CAMN TAC,PCTR(DAT)
	JRST DELWR4		;IT'S EMPTY ALREADY
	CAIN AC3,(CHR)
	JRST DELBK3		;FOUND OUR MATCH, TIME TO GO
	JRST DELBK5

DELBK3:	SOJLE AC1,DELWR4	;JUMP IF NO ARG LEFT
	JRST DELBK2		;HIT ME AGAIN

DELBK9:	POP P,AC1
	JRST DELWR4		;FINISH UP SAME AS ↑←↑W

CONTK:	HRRI TAC,4		;HERE ON V TAB
	SKIPA
CONTL:	HRRI TAC,10		;HERE ON FORMFEED
	TLNE LINE,PTYLIN	;THIS TTY HAVE VERT MECHANICS?
	TLNE LINE,IMPBIT	;NOT IF IT IS AN ARPA PTY
	JRST SIMFF		;NO, TURN INTO LINEFEEDS
	JRST TTIPUT		;YES, PUT CHAR IN BUFFER AND ECHO IT

SIMFF:	TLO TAC,ECHSUP		;DON'T OUTPUT FF OR VT TO A 33
	PUSHJ P,TTIPUT		;PUT IT IN BUFFER
	MOVEI CHR,12		;SIMULATE WITH LF'S
	JRST SIMFF1

CONTI1:	MOVEI CHR,1		;SYNCHRONOUS IDLE CHARACTERS
SIMFF1:	PUSHJ P,DUPLX1		;OUTPUT ECHO OF LF OR IDL
	TRNE TAC,17		;DONE YET?
	SOJA TAC,SIMFF1		;NO. OUTPUT MORE
	POPJ P,			;DONE
;⊗ BAKNXT BAKNX1 DOBKNX BNNNUL DOBKNO ECHBEL BNNUMB BNNEG DOQUOT WHOITY WHOIT3 WHOIT2 BNFILE BNWHO FORCEA FORCEC FORCE1 FORCER BNN BND BNC BNM BND1 BND2 BND3 BNL

BAKNXT:	MOVSI IOS,SYNC		;Don't let special activation mode make this
	ANDCAB IOS,DEVIOS(DDB)	; escape character activate previous chars
REPEAT 0,<
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,TTYATC		;IS HE ATTACHED TO IT BY JOB?
	JRST ECHBEL		;NO, ERROR
>;END REPEAT 0
	LDB HPOS,PHPOS		;SINCE NOT ECHOING, UNDO ADJHP
	MOVEI TAC,ESCNUL	;CLEAR OUT ESCAPE ARG
	DPB TAC,[ESCFLD+LINE,,PRGESC]
BAKNX1:	MOVEI TAC,BNPEND	;SET ↑← PENDING
	IORM TAC,IMLHAC(DDB)
	POPJ P,			;NO ECHO

DOBKNX:	MOVEI TAC,BNPEND	;EXECUTE ↑← COMMAND
	ANDCAB TAC,IMLHAC(DDB)	;NO LONGER PENDING
	TRNE TAC,BNLFLG		;IS THIS THE CHAR AFTER A ↑←L ?
	JRST DELBAK		;YES, DO IT
	PUSHJ P,SPCHEK		;HERE FOR CHAR AFTER ↑←
	 JFCL
	TLNE TAC,BNQUOT
	JRST DOQUOT		;JUMP IF THIS CHAR SHOULD BE QUOTED FOR INPUT
	SOS (P)			;DON'T SKIP RETURN FROM TTEDIT -- NO INPUT ADDED
	TLNE TAC,BNFRCM
	JRST FORCEC		;JUMP IF THIS CHAR REQUESTS A FORCED COMMAND
	TLNN TAC,BNARGS		;DOES THIS COMMAND WANT ARGUMENTS IN ACS?
	JRST DOBKNO		;NO
	MOVE DAT,PRGESC(LINE)	;GET ESCAPE PARAMETERS (ARG AND SIGN)
	LDB AC1,[ESCARG,,DAT]	;GET NUMERIC VALUE
	SETOM GOTARG
	CAIE AC1,ESCNUL		;DO THIS STUPID KLUDGE
	JRST BNNNUL
	MOVEI AC1,0
	SETZM GOTARG
BNNNUL:	TLNE DAT,ESCNEG		;SET THE SIGN BIT
	TLO AC1,400000
	MOVE DAT,LINE		;LINED NEEDS LINE NUMBER AND BITS
	SETZB J,ESCDIF		;NOT A DPY (J≡HPOS←0), ALLOW ESCOCT TO CONVERT RADIX
DOBKNO:	CAMN TAC,SPCRLF		;Is this ↑←#<cr>?
	JRST BKCRMC		;Yes, this is a macro call
	TLNE TAC,BNSPCL
	JRST (TAC)		;JUMP IF SPECIAL COMMAND
ECHBEL:	MOVEI CHR,7		;UNRECOGNIZED ↑← COMMAND,
	JRST PUTCRS		; ECHO A BELL

BNNUMB:	MOVEI AC1,(AC1)		;FLUSH SIGN BIT
	IMULI AC1,=10		;SHIFT OVER
	ADDI AC1,-"0"(CHR)	;ADD IN NEW DIGIT
	DPB AC1,[ESCARG+LINE,,PRGESC]
	JRST BAKNX1		;SET STILL PENDING

BNNEG:	PUSHJ P,DOESNT		;SET NEGATIVE ESCAPE
	JRST BAKNX1

DOQUOT:	TLZ TAC,ALLSPA+SPACTN+ECHSUP	;NO SPECIAL ACTION FOR THIS CHARACTER
	CAIN CHR,"Z"-100
	MOVEI CHR,33
	PUSHJ P,QUOTHP		;DO ADJHP WITH MODIFIED BITS
	 JFCL
	JRST TTEDT2		;BACK TO MAINSTREAM

IFN FTIP,<
;Here from IMPSER for TCP are-you-there cmd.  Make a wholine go out.
;LINE must be set up.
↑WHOITY:SKIPN J,LETAB(LINE)	;skip if a display
	JRST WHOIT2		;non-display
	HRRZ AC1,WHOTAB(J)	;any wholine going?
	JUMPN AC1,WHOIT3	;yes, just refresh it
	SKIPN DDB,TTYTAB(LINE)	;no, get job number
	JRST WHOIT2		;no DDB (?), force tty who
	LDB AC1,PJOBN		;get job number
	JUMPE AC1,WHOIT2	;jump if no job
WHOIT3:	MOVEI DAT,(LINE)
	HLL DAT,LINTAB(DAT)	;line bits and number for LINED
	OFFSCN
	SETOM GOTARG		;flag explicit arg for LINED
	PUSHJ P,ESCW		;do ESC n W
	JRST SCNONJ

WHOIT2:	MOVEI TAC,F.WHO		;FORCE A TTY WHO COMMAND
	SKIPN DDB,TTYTAB(LINE)	;no, get job number
	TDZA AC1,AC1		;no DDB (?), force tty who for system wholine
	LDB AC1,PJOBN		;get job number as arg of TTY WHO
	JRST FORCEA		;force TTY WHO command
>;IFN FTIP

BNFILE:	SKIPA TAC,[F.FILE]	;FORCE A FILES COMMAND
BNWHO:	MOVEI TAC,F.WHO		;FORCE A TTY WHO COMMAND
	PUSHJ P,ESCW		;MAYBE CONVERT TTY NUMBER TO JOB NUMBER
	JUMPL AC1,CPOPJ		;↑← - W OR V DOES NOTHING
↑FORCEA:OFFSCN
	LDB CHR,FC2BPT		;IS THERE A FORCED COMMAND ALREADY?
	JUMPN CHR,SCNONJ
	DPB AC1,ARGBPT		;SAVE JOB NUMBER
	JRST FORCE1

;Plant forced command for TTY specified by DDB.
;Returns w/zero in CHR iff successful.
↑FORCEC:OFFSCN
	LDB CHR,FC2BPT		;IS THERE ONE ALREADY?
	JUMPN CHR,SCNONJ	;PTDET DEPENDS ON CHR INDICATING SUCCESS/FAILURE
FORCE1:	DPB TAC,FCMBPT		;FORCE THE COMMAND
	AOS COMCNT		;count another cmd waiting
	JRST SCNONJ

;Plant forced cmd with arg in J for TTY specified by DDB.  From PTYREL or ITYREL.
;Forced command is in TAC (F.KILL or F.DET).
↑FORCER:PUSH P,AC1
	OFFSCN
	LDB AC1,FC2BPT		;see if any forced cmd there
	JUMPN AC1,.+2		;if so, then don't change COMCNT
	AOS COMCNT		;count another cmd waiting
	DPB TAC,FCMBPT		;  important) previously planted forced cmd!!
	DPB J,ARGBPT		;store job number for forced KILL command
	ONSCN
	JRST POPAJ		;restore AC1 and return

BNN:	LDB TAC,BNBBBP		;BUCKY BITS SET?
	JUMPE TAC,CPOPJ		;NO, NOTHING TO DO (ARG WAS CLEARED AUTOMAGICALLY)
	MOVEI TAC,0		;CLEAR BUCKY BITS
	DPB TAC,BNBBBP
	JRST BND3		;ECHO [N]

BND:	MOVEI TAC,BNCNTL!BNMETA	;TURN ON DOUBLE BUCKY
	JRST BND1

BNC:	SKIPA TAC,[BNCNTL]	;TURN ON CONTROL BIT
BNM:	MOVEI TAC,BNMETA	;TURN ON META BIT
BND1:	HLRZ HPOS,TTYTAB(LINE)	;Pick up COMBIT and DLYBIT
	TRNE HPOS,COMBIT!DLYBIT	;If either is on, assume user mode
	JRST BND2
	MOVE HPOS,ACTMOD(DDB)
	TRNN HPOS,SUPACT	;PROGRAM SUPPRESSING BUCKY BITS?
	TLNE IOS,TPMON		;OR MONITOR MODE?
	POPJ P,			;YES, NO BUCKIFICATION
BND2:	IORM TAC,IMLHAC(DDB)
BND3:	LDB HPOS,PHPOS
	TLZE LINE,ROBTPD	;JUST DID RUBOUT?
	PUSHJ P,BSECHO		;YES, OUTPUT A BACKSLASH
	HLLM LINE,LINTAB(LINE)
	ADDI HPOS,3
	DPB HPOS,PHPOS
	PUSH P,CHR		;ECHO SOMETHING
	MOVEI CHR,"["
	PUSHJ P,DUPLX1
	POP P,CHR
	PUSHJ P,DUPLX1
	MOVEI CHR,"]"
	JRST DUPLX1

BNL:	MOVEI TAC,BNPEND!BNLFLG	;↑←L COMMAND, SET TO READ NEXT CHAR
	IORM TAC,IMLHAC(DDB)
	POPJ P,			;DO NOTHING SUBSTANTIVE NOW
;CONTI CONTI2

CONTI:	TLNE LINE,DISLIN!DDDLIN!DMLIN
	JRST TTIPUT		;ECHO AND RETURN FOR DISPLAYS
	TLNE LINE,PTYLIN
	TLNE LINE,IMPBIT
	CAIA			;NOT A PTY, OR AN IMP-PTY
	JRST TTIPUT		;ECHO AND RETURN FOR LOCAL PTYS
	LDB HPOS,PHPOS
	ANDI HPOS,7
	CAIE HPOS,7		;IF ONLY 1, WE WILL CONVERT TO SPACE
	TLNE LINE,TBXPND	;FORCING TAB EXPANSION?
	TLO TAC,ECHSUP		;YES. DON'T OUTPUT TAB TO 33
	PUSHJ P,TTIPUT		;PUT IN BUFFER AND MAYBE ECHO
	TLNE LINE,TBXPND	;EXPANDING TABS?
	JRST CONTI2		;YES
	LDB CHR,PHPOS		;WHERE WAS TTY BEFORE TAB
	MOVEI HPOS,(CHR)	;UPDATE HPOS FOR LATER STORE
	IORI HPOS,7		;..
	ADDI HPOS,1		;..
	ANDI CHR,7		;JUST LOW PART FOR INDEX
	MOVEI TAC,0		;ASSUME 1 (BH: CONTI1 DOES C(TAC)+1 CHARS!)
	XCT (CHR)[
		AOJA TAC,CONTI1	;8 SPACES-2 IDLES
		JRST CONTI1	;7 SPACES-1 IDLE
		JRST CONTI1	;6 SPACES-1 IDLE
		JRST CONTI1	;5 SPACES-1 IDLE
		JRST CONTI1	;4 SPACES-1 IDLE
		POPJ P,		;3 SPACES-0 IDLES
		POPJ P,		;2 SPACES-0 IDLES
		JFCL	]	;1 SPACE -CONVERT TO SPACE (OR CTY WILL MISS TAB STOP)
CONTI2:	MOVEI CHR,40		;SPACES FOR THE 33'S
	LDB HPOS,PHPOS		;WHERE WAS I BEFORE TAB?
	PUSHJ P,AOJDPX		;OUTPUT A SPACE
	TRNE HPOS,7		;AT A TAB STOP?
	JRST .-2		;NO. MORE SPACES.
	POPJ P,			;RETURN FROM TTEDIT
;CRLFEC CHPOPJ CNTLEC CRLF CRLFIP CRLFMM

CRLFEC:	MOVEI HPOS,0		;ECHO A CR LF, SAVING CHR
	PUSH P,CHR
	MOVEI CHR,15		;CARRIAGE RETURN
	PUSHJ P,DUPLX1		;OUTPUT IT
	MOVEI CHR,12		;LINE FEED
	PUSHJ P,DUPLX1		;OUTPUT THAT TOO
CHPOPJ:	POP P,CHR		;RESTORE CHR
	POPJ P,

CNTLEC:	HRRI TAC,100(CHR)	;SAVE UN-CNTL CHARACTER
	MOVEI CHR,"↑"
	PUSHJ P,AOJDPX
	MOVEI CHR,(TAC)		;TYPE ↑ CHAR
	PUSHJ P,AOJDPX
	TRZ CHR,100		;RESTORE IT TO A CNTL CHAR
	POPJ P,

CRLF:	MOVEI HPOS,0		;HERE ON INPUT OF A CARRIAGE RETURN
	TLNE LINE,PTYLIN	; IS THIS A PTY
	JRST CRLFIP		; YES, TEST XON ALWAYS
	TLNE IOS,TPMON		; ALWAYS GIVE LF AFTER CR IN MON. MODE
	JRST CRLFMM
CRLFIP:	TLNE LINE,XON		;IF PAPER TAPE, NO FREE LF
	JRST TTIPUT		;JUST STORE THE CR
CRLFMM:	PUSH P,UCHN		;REMEMBER BUCKY BITS
	SETZ UCHN,		;NO BITS FOR CR
	PUSHJ P,TTIPUT		;ORDINARILY, STORE AND GO ON HERE
	POP P,UCHN		;GET BITS BACK FOR THE LF
	MOVEI CHR,12		;INSERT LF AFTER CR
	MOVSI IOS,SYNC		;WHICH IS AN ACTIVATOR
	IORB IOS,DEVIOS(DDB)
	MOVE AC1,ACTMOD(DDB)	;see if user program is suppressing inserted LF echo
	TRNE AC1,SUPLFE		;skip if not suppressing inserted LF echo
	TLNE IOS,TPMON		;can't suppress LF echo in monitor mode
	CAIA			;echo LF after all
	JRST TINSLF		;insert LF in buffer without echoing it
	TLNE LINE,FULTWX	;IF NOT SELF ECHOING,
	TLNE LINE,IMPBIT	;  (JJW 2/84: FULTWX IMP PTYs shouldn't echo LF)
	JRST TTIPUT		;THIS WILL GIVE LF ECHO
	PUSHJ P,TTIPUT		;OTHERWISE, THIS WONT
	JRST DUPLX1		;BUT THIS WILL
;CNCTST CNCTS1 CNCMOD

CNCTST:	MOVE TAC,DEVMOD(DDB)	;BH 10/23/74
	TLNN TAC,TTYATC		;IF THIS TTY IS NOT USED AS A CONSOLE
	TRNN TAC,ASSCON+ASSPRG	;(I.E., ASSIGNED AS A DEVICE AND NO TTYATC)
	JRST .+2
	POPJ P,			;LEAVE IT AS A 3
	MOVEI CHR,600		;INVENT INTERNAL CODE FOR ↑C.
	LDB TAC,PJOBN
	MOVE TAC,JBTSTS(TAC)
	TLNE TAC,JACCT		;REG 11/26/73 NO REASON TO LET PTYS THROUGH
	MOVEI CHR,1175		;SEND ALTMODE INSTEAD (FLAGGED TO AVOID CONVERSION)
	LDB TAC,TIPUTR(DDB)
	CAIE TAC,600
	POPJ P,
CNCTS1:	PUSHJ P,SETBFT		;CLEAR INPUT BUFFER (AVOID LINE EDITOR)
CNCMOD:	PUSH P,AC2
	MOVEI IOS,NOINTR
	SKIPE AC2,LETAB(LINE)
	ANDCAM IOS,DMFLAG(AC2)	;TURN OFF FREEZE MODE ON DM IF HE TYPES CALL
	POP P,AC2
	MOVE IOS,DEVIOS(DDB)
	PUSH P,DAT		;SAVE POINTER TO INPUT BUFFER
	TRNE IOS,IOSUPR		;SUPPRESSING OUTPUT?
	PUSHJ P,SETBF2		;YES, CLEAR OUTPUT BUFFER
	POP P,DAT		;RESTORE BUFFER POINTER
	MOVE IOS,[XWD DDTM!IO!USRB,IOSUPR!MERTPO!MERTP1]
	ANDCAM IOS,DEVIOS(DDB)
	MOVSI IOS,TPMON+IOFST
	IORB IOS,DEVIOS(DDB)
IFN FTMONCIP,<
	PUSH P,CHR		;SAVE CHARACTER (CALL OR ALTMODE)
	PUSHJ P,MCMSKP		;SKIP ANY MONITOR COMMAND LEFT OVER IN BUFFER
	POP P,CHR
>;IFN FTMONCIP
	POPJ P,
;BSECHO DCPUTR DELETL BNCTLR LINSCN BNCTR1 BNCTR2
;ROUTINE TO ECHO BACK-SLASH

BSECHO:	PUSH P,CHR		;*
	MOVEI CHR,"\"
	PUSHJ P,AOJDPX
	JRST CHPOPJ

;ROUTINE TO DECREMENT PUTR

↑DCPUTR:LDB TAC,PLSTLC		; CHECK FOR NONE TO DELETE
	CAMN TAC,PCTR(DAT)
	POPJ P,

	MOVSI TAC,110000
	ADD TAC,PUTR(DAT)	;*
	TLNE TAC,400000
	ADD TAC,[XWD 337777,-1]
	MOVEM TAC,PUTR(DAT)
	AOS FCTR(DAT)
	AOS TAC,PCTR(DAT)
	CAIG TAC,TTICHR		;*
	JRST CPOPJ1		;*
	SUBI TAC,TTICHR		;*
	MOVEM TAC,PCTR(DAT)
	MOVEI TAC,STTIBF
	ADDM TAC,PUTR(DAT)	;*
	JRST CPOPJ1

;ROUTINE TO DELETE CURRENT LINE (↑U)

DELETL:	LDB TAC,PLSTLC		;WHERE WAS LAST BREAK?
	MOVEM TAC,TIPCTR(DDB)	;STORE COUNT
	PUSHJ P,TBYTEP		;CONVERT TO A BYTE POINTER
	MOVEM TAC,TIPUTR(DDB)	;SAVE POINTER
	LDB LINE,PUNIT		;MAKE SURE WE HAVE LINE NUMBER
	MOVSI TAC,ROBTPD	;NO MORE BACKSLASH
	ANDCAM TAC,LINTAB(LINE)
	JRST TRESC1		;GO COMPUTE TIFCTR

;ROUTINE TO REDRAW THE CURRENT INPUT LINE, CALLED BY ↑←R

BNCTLR:	PUSHJ P,CRLFEC		;FIRST ECHO A CRLF
	DPB HPOS,PHPOS
	TLZ LINE,ROBTPD		;NO LONGER RUBBING OUT
	HLLM LINE,LINTAB(LINE)
	PUSHJ P,LINSCN		;SCAN ENTIRE CURRENT INPUT LINE
	 PUSHJ P,TLKOUT		;INSTRUCTION TO XCT FOR EACH CHAR
	POPJ P,

;ROUTINE TO EXECUTE AN INSTRUCTION FO R EACH CHAR IN CURRENT INPUT LINE.
;CALL:	PUSHJ P,LINSCN
;	 <INSTRUCTION TO XCT WITH CHAR IN CHR>
;	<NORMAL RETURN AFTER ALL CHARS SCANNED>
;	<IMMEDIATE DOUBLE SKIP RETURN IF CALL+1 SKIPS>
;CLOBBERS AC1, AC2, TAC

LINSCN:	LDB TAC,PLSTLC		;GET CHAR COUNT FOR START OF LINE
	MOVE AC1,TAC		;PUT COUNT IN A SAFE AC
	PUSHJ P,TBYTEP		;CONVERT TO BYTE POINTER
	MOVE AC2,TAC		;PUT BPT IN A SAFE AC
BNCTR1:	CAMN AC1,TIPCTR(DDB)	;IS COUNT EXHAUSTED?
	JRST CPOPJ1		;YES, WE'RE DONE
	SOJG AC1,BNCTR2		;JUMP IF NOT AT END OF BUFFER
	HLRZ AC1,TTIBUF(DDB)	;AT END, RESTART AT THE TOP
	HRR AC2,TTIBUF(DDB)	;INIT BPT ALSO
BNCTR2:	ILDB CHR,AC2		;GET CHARACTER
	JUMPE CHR,BNCTR1	;SKIP NULLS
	XCT @(P)		;XCT CALLER'S INSTRUCTION
	JRST BNCTR1
	JRST CPOPJ2		;IF HE SKIP RETURNS, SO DO WE
;DOTALK TLKDPY TLKBN1 DOTAL1 NOBELL DOTAL3 DOTAL2 TLKBN

DOTALK:	JUMPE CHR,CPOPJ		;BH 1/8/78 NO NULLS HERE (CALL, 600, GETS THRU)
	ANDI CHR,177
	SKIPN DDB,TTYTAB(LINE)
	POPJ P,
	PUSHJ P,CONVRT		;CONVERT ASCII-SAIL MAYBE
	TLNE LINE,DDDLIN!DISLIN!DMLIN
	JRST TLKDPY		;JUMP IF IT'S A DPY
	CAIN CHR,37
	JRST BAKNXT		;PREPARE FOR ↑← COMMAND FROM NON-DPY
	MOVE TAC,IMLHAC(DDB)
	TRNE TAC,BNPEND		;IS THIS THE CHAR AFTER A ↑← ?
	JRST TLKBN		;YES, SPECIAL DEAL
	CAIE CHR,3
TLKDPY:	CAIN CHR,0
	JRST NOTALK
TLKBN1:	MOVE UUO,LINTAB(LINE)	;SAVE TALKER'S XON BIT
	TLZ LINE,-1		;NO BITS PLEASE
	PUSH P,LINE
DOTAL1:	LDB LINE,PTALK
	HRRZ DDB,TTYTAB(LINE)
	MOVE IOS,DEVIOS(DDB)	;GET IOS
	TLNE IOS,TTYHLD
	PUSHJ P,TTYUNH		;DON'T ALLOW HOLDING (MAY HAVE TYPED CTL-BRK)
	CAIE CHR,7		;Is this a bell (pi)?
	JRST NOBELL		;No
	LDB TAC,[DDQREQ+LINE,,LSTESC] ;GET RESPONSIBLE TTY THAT WILL GET THE BEEP
	HLL TAC,LINTAB(TAC)	;Get line characteristics
	TLNN TAC,DISLIN!DDDLIN!DMLIN ;Do we need to send both a bell and a pi?
	JRST NOBELL		;Nope, either one will do
	MOVEI TAC,(LINE)	;Yes, line number for beeper
	PUSHACS			;STRTDM may clobbers some critical ACs
	PUSHJ P,BEEP1		;WE NOW BEEP EVERYONE AND NEVER PI ANYONE
	POPACS
	CAMN LINE,(P)		;WAS THIS US?
	JRST TPOPJ		;YES, DONE
	JRST DOTAL1		;NO, CONTINUE

NOBELL:	CAMN LINE,(P)		;BACK TO OURSELVES YET?
	JRST DOTAL2		;YES, WE ARE SPECIAL
	JUMPE DDB,DOTAL1	;SKIP GUYS WITHOUT DDBS
	PUSH P,CHR
	PUSHJ P,TLKOUT
	MOVE CHR,(P)		;GET CHAR
	TLNN UUO,XON		;IF TALKER HAS XON OR
	CAIE CHR,15		;IF NOT CR,
	JRST DOTAL3		;THEN NO LF
	MOVEI CHR,12
	PUSHJ P,TLKOUT		;YES, SEND IT
DOTAL3:	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,TYPTST
	POP P,CHR
	JRST DOTAL1

DOTAL2:	HLL LINE,LINTAB(LINE)	;GET OUR CHARACTERISTICS
	MOVEM CHR,(P)		;REPLACE SAVED LINE WITH CHR
	TLNN LINE,FULTWX
	PUSHJ P,TLKOUT
	POP P,CHR
	CAIN CHR,15		;NEED LF?
	TLNE LINE,XON		;MAYBE
	JRST TYPTST		;NO
	MOVEI CHR,12
	PUSHJ P,TLKOUT
	JRST TYPTST

TLKBN:	PUSHJ P,SPCHEK		;CHECK OUT THE CHAR FOLLOWING THE ↑←
	 JFCL
	TLNE TAC,BNSPCL!BNFRCM	;SPECIAL COMMAND OTHER THAN QUOTING?
	JRST RECINZ		;YES, LET TTEDIT HANDLE IT
	MOVEI UUO,BNPEND
	ANDCAM UUO,IMLHAC(DDB)	;ELSE WE HANDLE IT HERE
	TLNE TAC,BNQUOT		;QUOTED CHAR?
	JRST TLKBN1
	PUSHJ P,ECHBEL		;NO, DO A BELL
	JRST TYPTST
;NOTALK NOTAL1 NOTAL2 NOTLKA NOTAL3 NOTLKB NOTLKC CLKBYE CLKBY9 CLKBY8 CLKBY1 CLKB11 CLKB12 CLKBY2 CLKBY0

;IF I TYPE A ↑C IN TALK RING, THEN (1) ASSUME NEXT←ME←PREV AND (2) SET NEXT←PREV.
;IF NEXT=PREV, CLEAR ITS TLKRNG BIT
;SET ME←ME AND CLEAR TLKRNG BIT IN LINTAB(ME)
NOTALK:	MOVEI HPOS,0(LINE)	;ME
	TLNE LINE,CTYLIN	;CTY?
	JRST NOTLKB		;YES, CLEAR EVERYONE IN THIS RING
	LDB CHR,PTALK		;NEXT
	MOVSI UUO,CLKBYE	;ADDR OF CLOCK LVL ROUTINE TO SAY BYE
	DPB HPOS,[POINT PUNITS,UUO,35] ;SAVE TTY WHICH CALLED OUT
	DPB CHR,[POINT PUNITS,UUO,35-PUNITS] ;SAVE ANOTHER TTY IN THE LOOP
	SYSPIFF
	IDPB UUO,CLKQ		;USE DPYSER'S CLOCK QUEUE
	SYSPIN
NOTAL1:	LDB UUO,PTALK
	CAMN UUO,HPOS		;ME←?
	JRST NOTAL2		;YES. LINE=PREV
	MOVE LINE,UUO		;NO. FIND PREV
	JRST NOTAL1

NOTAL2:	DPB CHR,PTALK		;MAKE NEXT←PREV
	CAIE CHR,(HPOS)		;NO ↑←N BREAKING SOLITAIRE TALK
	CAIE CHR,(LINE)		;RING NOW EMPTY?
	JRST NOTAL3		;NO
NOTLKA:	MOVSI CHR,TLKRNG	;YES. CLR HIS BIT
	ANDCAM CHR,LINTAB(LINE)
	MOVE DDB,TTYTAB(LINE)	;AND TELL HIM ABOUT IT BY GOLLY!!!
	MOVE DDB,TTYTAB(HPOS)	;RESTORE DDB
	MOVE LINE,UUO
	CAIE LINE,(HPOS)	;IN WHICH CASE IT HAS NEXT IN RING
	JRST NOTLKC		;WHICH MAY BE ME ANYWAY
NOTAL3:	MOVSI CHR,TLKRNG
	MOVE LINE,HPOS		;ME
	DPB HPOS,PTALK		;ME←ME
	ANDCAM CHR,LINTAB(LINE)	;CLR MY BIT
	MOVEI CHR,600		;GET A ↑C AGAIN
	DPB CHR,TIPUTR(DDB)	;LOOK LIKE 2 OF THEM
	HLL LINE,LINTAB(LINE)	;GET GOOD BITS!
	TLNN LINE,DDDLIN!DISLIN!DMLIN ;FOR THESE GUYS, LEAVE IT AS CTRL-META-NULL
	MOVEI CHR,3		;EVERYBODY ELSE GETS THIS
	JRST RECINZ		;AND PROCESS IT

NOTLKB:	LDB LINE,PTALK		;CTY -- GET NEXT GUY
	CAIN LINE,(HPOS)	;IF ONLY ME,
	JRST NOTAL3		;  JUST CLEAR ME QUIETLY
NOTLKC:	MOVSI UUO,CLKBYE	;ADDR OF CLOCK LVL ROUTINE TO SAY BYE
	DPB HPOS,[POINT PUNITS,UUO,35] ;SAVE TTY WHICH CALLED OUT
	DPB LINE,[POINT PUNITS,UUO,35-PUNITS] ;SAVE ANOTHER TTY IN THE LOOP
	SYSPIFF
	IDPB UUO,CLKQ		;USE DPYSER'S CLOCK QUEUE
	SYSPIN
	LDB UUO,PTALK		;SAVE HIS NEXT
	DPB LINE,PTALK		;CLEAR HIM OUT
	JRST NOTLKA		;AND TELL HIM

CLKBYE:	LDB LINE,[POINT PUNITS,DAT,35-PUNITS] ;GET THE GUY TO SEND TO
	MOVE AC3,LINE		;SAVE FOR END TEST
	HLL LINE,LINTAB(LINE)	;GET HIS BITS
	TLNN LINE,TLKRNG	;STILL IN TALK RING?
	JRST CLKBY0		;NO, DON'T CARE ABOUT OTHER GUY
	LDB AC1,[POINT PUNITS,DAT,35] ;GET THE GUY WHO TYPED CALL
	SKIPN DDB,TTYTAB(AC1)	;HIS DDB
	JRST CLKBY1		;NO DDB, CAN'T GET POOP FROM IT
	LDB TAC,PJOBN		;FIND CALLER'S JOB #
	JUMPE TAC,CLKBY2	;USE TTY NAME IF NO JOB
	HRLZ AC1,PRJPRG(TAC)	;IF JOB, USE ITS PRG NAME
CLKBY9:	SKIPN DDB,TTYTAB(LINE)	;GET OUTPUT GUY'S DDB
	JRST CLKBY8		;NONE, GET NEXT GUY IN LOOP
	PUSH P,AC1		;SAVE PROGRAMMER NAME OR TTY NAME
	PUSH P,AC3		;SAVE LINE NUMBERS FOR END TEST
	PUSH P,LINE		; LINE IS TAC1 !!!
	PUSHJ P,INLMES
	ASCIZ /;; Bye from /
	MOVE TAC1,AC1		;GET PRG OR TTY NAME
	PUSHJ P,PRNAME		;TYPE IT
	PUSHJ P,TYCRLF
	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,TYPTST
	POP P,LINE
	POP P,AC3
	POP P,AC1
CLKBY8:	LDB TAC,PTALK		;GET NEXT GUY IN TALK RING
	CAIN TAC,(AC3)		;DONE?
	POPJ P,
	MOVE LINE,TAC		;NO, TELL SOMEBODY ELSE
	JRST CLKBY9

CLKBY1:	MOVEI AC1,(AC1)		;NUMBER W/O BITS
	MOVEI TAC,3		;DIGIT COUNT
	MOVEI AC2,0
CLKB11:	LSHC AC1,-3		;FIRST CONVERT TO BINARY-CODED-OCTAL
	LSH AC2,-3
	TLO AC2,'0  '
	JUMPE AC1,CLKB12
	SOJG TAC,CLKB11
CLKB12:	HLRZ AC1,AC2		;GET NUMBER IN POSITION IN AC1
	HRLI AC1,'TTY'		;IN CASE YOU WERE WONDERING,
	JRST CLKBY9		; THE CTY CAN'T NOT HAVE A DDB.

CLKBY2:	MOVE AC1,DEVNAM(DDB)	;NO JOB, USE TTY NAME
	JRST CLKBY9

CLKBY0:	SKIPN DDB,TTYTAB(LINE)
	POPJ P,
	PUSHJ P,INLMES
	ASCIZ /;; Link broken
/
	MOVE IOS,DEVIOS(DDB)	;SEE IF IN MONITOR MODE
	TLNE IOS,TPMON
	PUSHJ P,PRPER		;YES, GIVE A DOT
	PUSHJ P,TYPTST		;START UP OUTPUT
	LDB TAC,PJOBN		;IS TTY IN USE BY A JOB?
	JUMPN TAC,CPOPJ		;YES, THAT'S IT
	JRST TTYKIL		;NO, FLUSH THE DDB
;XMTINT XMTIN1 NODPY2 XMTI1A DPYST2 DPYST3 DPYSTR DPYDON

;COMMON TRANSMITTER INTERRUPT FOR SCANNER AND CTY(TTY)

↑XMTINT:HLL LINE,LINTAB(LINE)	; GET LINE CHAR.
	TLNN LINE,DISLIN!DDDLIN	;Skip if just SPW req output done.  bye bye.
	SKIPN DDB,TTYTAB(LINE)	;GET DDB ADDRESS
	POPJ P,			;IF NONE, X BEING TYPED (or beep)
XMTIN1:	MOVEI CHR,0		;CTL-B HOLDING ON PTY NEEDS THIS
	MOVSI IOS,IRMA
	ANDCAB IOS,DEVIOS(DDB)	;WE GOT AN INTERRUPT, NO LONGER NEED ONE
	LDB DAT,PDVTIM		;RESET HUNG COUNT
	DPB DAT,PDVCNT
	MOVEI DAT,TTOBUF(DDB)	;GET PTR. FOR OUTPUT BUFFER.
	TLNE LINE,DISLIN!DDDLIN
	JRST DPYSTR		;IF A DISPLAY, GO TO OUR OWN STARTUP ROUTINE
	TRNE IOS,10
	TRNE IOS,6
	JRST .+2
	JRST NODPY2		;NEVER GO TO DMXMT IF MODE 10 OR 11
	TLNE LINE,DMLIN
	JRST DMXMT		;TRANSMITTER ROUTINE FOR DATAMEDIAS
;Fall thru or return from DMXMT here if tty has no dpy hdr
NODPY2:	OFFSCN			;TURN OFF SCANNER CHANNEL
XMTI1A:	MOVE TAC,TAKR(DAT)	;IS OUTPUT BUFFER EMPTY?
	CAME TAC,PUTR(DAT)	;(I.E., HAS TAKR CAUGHT UP WITH PUTR?)
	JRST XMTIN2		;NO, TYPING STILL IN PROGRESS
	TRNE IOS,MERTP1		;MONITOR ERROR MESSAGE?
	CAIE DAT,TTOBUF(DDB)	;OUTPUT BUFFER?
	JRST XMTIN4		;NO, MUST REALLY BE DONE
	MOVEI DAT,TTIBUF(DDB)	;YES, NOW EMPTY OUT TTI BUFFER
	JRST XMTI1A

;DPYSTR--INITIATE TYPEOUT ON A DISPLAY CONSOLE.  Requires line number in RH of LINE.
;DPYST2--Initiate dpy typeout on a Datamedia.  Called from TYPT2.
DPYST2:	SKIPN DAT,LETAB(LINE)	;Gotta have a dpy hdr
	POPJ P,			;Forget it
	PUSH P,TAC		;I DON'T KNOW WHAT'S INTACT
	MOVE TAC,DEVIOS(DDB)
	TRNE TAC,10
	TRNE TAC,6
	JRST .+2
	JRST TPOPJ		;DON'T DO THIS STUFF IN IMAGE MODE 10 OR 11
	SKIPN TAC,DPHOLD(DAT)
	JRST DPYST3		;Not holding
	TRNE TAC,-1		;May need to output holding message
	JRST TPOPJ		;HOLDING message has already been displayed
	MOVE TAC,TOTAKR(DDB)
	CAMN TAC,TOPUTR(DDB)	;IS THERE ANYTHING IN OUTPUT BUF?
	JRST TPOPJ		;Nope, nothing is being held
DPYST3:	SETO TAC,
	EXCH TAC,DPTYCL(DAT)
	JUMPN TAC,TPOPJ		;Already in
	POP P,TAC
DPYSTR:	MOVSI DAT,DPYTYP	;MAKE INTO CLOCK REQUEST ON DPYTYP (DPYSER)
	JRST DPYTLN		;AND ENTER IN DPY CLOCK QUEUE.

;HERE FROM DPYTLX WITH SCANNER OFF
↑DPYDON:MOVE IOS,DEVIOS(DSER)	;HERE FROM DPYTYP (IN DPYSER) WHEN OUTPUT BUFFER EMPTY.
	HRRZ DDB,DSER		; DPYSER SAVES DDB ADDRESS IN DSER
	PUSHJ P,STLNAC		;SET UP AC LINE.
	TRNE IOS,MERTP1		;ERROR MESSAGE TYPEOUT ?
	CAIE DSER,-TTOBUF(DAT)	;YES. MUST WE STILL TYPE OUT THE INPUT BUFFER ?
	JRST XMTIN4		; NO, GO FINISH UP
	PUSHJ P,DPYERT		;YES. GO TYPE REST OF ERROR MESSAGE FROM INPUT BUFFER.
	JRST SCNONJ
;⊗ XMTIN5 XMTIN4 XMTIN6 XMTIN2 LINDON TTYPE WAKTJB

;Here from CLRBFO UUO and PTYREL
XMTIN5:	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVEI IOS,MERTPO!MERTP1
	JRST XMTIN6		;Don't turn off TOIP

XMTIN4:	MOVE IOS,[TOIP!IRMA,,MERTPO!MERTP1] ;HERE WHEN OUTPUT BUFFER(S) EMPTIED.
	MOVE CHR,DEVIOS(DDB)	;KLUDGE!
	TRNE CHR,10
	TRNE CHR,6		;IMAGE MODE (10 OR 11)?
	JRST .+2
	JRST XMTIN6		;YES, PRETEND NOT TO BE A DM
	TLNE LINE,DMLIN
	TLZ IOS,TOIP!IRMA	;DM isn't done until queues are empty.
XMTIN6:	ANDCAB IOS,DEVIOS(DDB)
	PUSHJ P,PAUCHK		;CHECK PAUSEB and CLEAR CHR
	ONSCN			;TURN ON SCANNER CHANNEL
	TLNE IOS,TOIP		;Type out finished?
	JRST LINDON		;No, must be DM
	LDB HPOS,PJOBN		;JOB NUMBER DDB IS ATTACHED TO
	TLNN IOS,IO
	JRST LINDON
	MOVSI IOS,IO
	ANDCAB IOS,DEVIOS(DDB)
	TLNN LINE,TLKRNG	;KEEP DDB IF TALKING
	JUMPE HPOS,TTYKIL	;ELSE KILL IF NO JOB
	JRST LINDON		;KEEP IT

XMTIN2:	ONSCN			;TURN ON SCANNER CHANNEL
	TLNE IOS,TTYHLD		;IF HOLDING OUTPUT, RETURN.
	POPJ P,
	PUSHJ P,GETCHO		;NO, GET NEXT CHAR. IN BUFFER
	JUMPE CHR,XMTIN1	;IGNORE NULLS
	JUMPL IOS,TTYPE		;KEEP TYPING IF INPUT I/O WAIT
	TRNN IOS,IOACT		;ARE WE IN I/O WAIT?
	JRST TTYPE		;NOT IN IO WAIT
PRINTX HERE'S A PLACE TO OPTIMIZE TYPEOUT FOR HIGH SPEED LINES
;FOR HIGH SPEED LINES THE PARAMETER (NOW TTOCHR/2) BELOW SHOULD BE MADE SMALLER
;TO WAKE THE JOB EARLIER (SINCE THE BUFFER EMPTIES SOONER)
	LDB HPOS,PFITCH		;YES, CHECK TO FIT INTO TTO BUFFER 
	CAIL HPOS,TTOCHR/2
	MOVEI HPOS,TTOCHR/2	;CLIP PFITCH TO HALF A BUFFER FULL
	CAML HPOS,FCTR(DAT)	;IS THERE ROOM ENOUGH TO ADD SOME MORE?
	JRST TTYPE		;NO, KEEP TYPING
LINDON:	PUSHJ P,WAKTJB		;wake up TTY's job, if waiting for output
TTYPE:	TLNN LINE,PTYLIN!DISLIN!DDDLIN ;DON'T TYPE IF THIS IS A PTY, DD or III
	JUMPN CHR,TYPL		;IS TYPING STILL TO BE IN PROGRESS?
	POPJ P,			;NO.

WAKTJB:	TLNE IOS,IOW		;IN IO WAIT?
	TLNE IOS,TTYIOW		;YES, TTY INPUT WAIT?
	POPJ P,			;NO
	PUSH P,LINE		;SAVE LINE (unnecessary?  not clobbered!)
	PUSHJ P,SETIOD		;YES, SET IO DONE (OUT OF WSYNC)
	POP P,LINE		;RESTORE LINE
	MOVE IOS,[IOW,,IOACT]	;INDICATE NO IO ACTIVE OR WAIT
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,
;TYPL TYPDM2 TYPL1 CTYTYP SCNTYP SCNTY1 SCNTY2 PAUCHK PAUCH2 PAUCH3

;ROUTINE TO TYPE CHAR - SCANNER LEVEL OR UUO LEVEL
;CALL:	MOVE LINE,<LINE NUMBER>
;	MOVE CHR,<CHARACTER>
;	PUSHJ P,TYP

↑TYPL:	TLNE LINE,DISLIN!DDDLIN
	POPJ P,			;DON'T DO THIS ON DPYS (MAINLY TYPX)
	TRNE IOS,10
	TRNE IOS,6		;CHECK FOR MODES 10 OR 11.
	TLNN LINE,DMLIN		;NOT IMAGE.  DM?
	JRST TYPDM2		;IMAGE OR NOT DM.  FORGE AHEAD.
	POPJ P,			;DM AND NOT IMAGE.  DMXMT WILL XMT.

TYPDM2:	TRZE CHR,400		;BH 1/5/78 IMAGE BIT SET?
	JRST TYPL1		;BH YES, DON'T DIDDLE PARITY
	MOVE TAC,CHR		;GENERATE EVEN PARITY BIT (MODEL 37)
	IMULI TAC,200401	;SEE PDP-10 SYSTEM REFERENCE MANUAL.
	AND TAC,[ 11111111]	;FORM 8 COPIES OF ORIGINAL BITS
	IMUL TAC,[ 11111111]	;ADD 8 BITS TOGETHER
	TLNE TAC,10		;TEST PARITY OF SUM
	TRO CHR,200		;PARITY IS ODD,  MAKE IT EVEN
TYPL1:	TLNN LINE,CTYLIN	;CONSOLE TTY?
	JRST SCNTYP		;NO. TYPE CHAR VIA DCA SCANNER
	DPB CHR,PLASTC
IFN FTSCTY,<
	SKIPL SCNCTY		;Skip if no alternate CTY on scanner
	SKIPN SUPCTY		;Skip if suppressing duplicate output thru DTE
	CAIA
	JRST CTYTYP		;Just type on alternate CTY
>;IFN FTSCTY
IFE PRCONF,<
	DATAO CTY,CHR		;KA10 TYPEOUT
>;IFE PRCONF
IFG PRCONF,<
	HRLI CHR,DTETYP		;KL10 TYPEOUT
	SYSPIFF
	IDPB CHR,CLKQ		;CALL DTEXX AT CH7 OR UUO LEVEL ONLY
	SYSPIN
>;IFG PRCONF
IFN FTSCTY,<
	ANDI CHR,377
	SKIPL SCNCTY		;Skip if no alternate CTY on scanner
	JRST CTYTYP		;Type on alternate now that have typed on real CTY
>;IFN FTSCTY
	POPJ P,

IFN FTSCTY,<
CTYTYP:	MOVE TAC,SCNCTY		;Get scanner CTY's port number
	TROA TAC,400000		;Make it look like from LINBIT RH
>;IFN FTSCTY
SCNTYP:	HRRZ TAC,LINBIT(LINE)	;GET LINE TO DCA PORT CONVERSION HALFWORD
	JUMPE TAC,SCNTY1	;JUMP IF NOT ON DCA SCANNER
IFE FTDLS,<
	PUSHJ P,DCATYP		;ON DCA, CALL ITS TYPER-OUTER
>;IFE FTDLS
IFN FTDLS,<
	PUSHJ P,DLSTYP		;ON DLS, CALL ITS TYPER-OUTER
>;IFN FTDLS
SCNTY1:	TLNN LINE,DMLIN
	SKIPN DDB
	POPJ P,
	DPB CHR,PLASTC		;SAVE CHAR FOR FULL DUPLEX
	POPJ P,

;HERE WHEN OUTPUT BUFFER IS EMPTY. TURN PAUSEB TO COMBIT. CONO PI,SCNON. CLEAR CHR.
PAUCHK:	MOVSI CHR,PAUSEB
	TDNN CHR,TTYTAB(LINE)	;COMMAND WAITING FOR OUTPUT BUFFER TO EMPTY?
	JRST PAUCH3		;NO
	ANDCAM CHR,TTYTAB(LINE)	;OFF WITH THE BAD BIT (PAUSEB)
	MOVSI CHR,COMBIT	;ON WITH THE GOOD BIT (COMBIT)
	OFFSCN			;TURN OFF SCANNER CHANNEL
	SKIPGE TTYTAB(LINE)	;SKIP UNLESS COMBIT ALREADY SET
	JRST PAUCH2
	IORM CHR,TTYTAB(LINE)	;SET IT NOW
	AOS COMCNT		;COUNT A COMMAND
PAUCH2:	ONSCN			;TURN ON SCANNER CHANNEL
PAUCH3:	SETZ CHR,
	POPJ P,
;⊗ PTYGET PTYGE1 PTCKDM PTOCK PTOCK1 PTINTC POPJJ PTICHK PTCHK2

PTYGET:	MOVSI LINE,-PTYNUM		;HOW MANY ARE AVAIABLE?
	MOVSI TAC,PTYLIN
	TDNE TAC,LINTAB+PTYL0(LINE)
PTYGE1:	AOBJN LINE,.-1
	JUMPG LINE,CPOPJ
	PUSH P,LINE			;Save aobjn cnt in case of retry
	ADDI LINE,PTYL0
	SKIPE TTYLOK
	PUSHJ P,PTYTST			;Skip if this PTY not enabled
	 PUSHJ P,DDBSRC			;GET A DDB
	  JRST [POP P,LINE		;NOT AVAILABLE, try another
		MOVSI TAC,PTYLIN	;TAC has been clobbered by now
		JRST PTYGE1]		;next PTY please
	ADJSP P,-1			;flush aobjn cnt
	HRLI LINE,PTYLIN!PTYUSE!XON!FCS	;DON'T INVENT LF'S (XON).
					;ALSO FULL CHARACTER SET MODE
	MOVEM LINE,LINTAB(LINE)
	MOVEI TAC,GAGBIT
	IORM TAC,IMLHAC(DDB)		;PTYS ARE INITIALLY GAGGED
	MOVEM J,PTYJOB-PTYL0(LINE)	;RECORD WHICH JOB OWNS THIS PTY.
	XCTR XW,[MOVEM LINE,(UUO)]	;RETURN PTY LINE NUMBER TO USER
	JRST CPOPJ1			;GIVE SKIP RETURN

PTCKDM:	TLNE LINE,PTYUSE		;Is this DM PTY in use?
	JRST PTOCK1			;Yes, assume some queued output
	SKIPN DAT,LETAB(LINE)		;No, flush its output queues
	JRST SETBF3			;No dpy hdr (?), flush output buffer
	PUSH P,J
	PUSHJ P,LEPDM1			;Flush output queues
	PUSHJ P,SETBF3			;Flush output buffer
	JRST POPJJ

;COME HERE WHEN A PTY OUTPUTS ANYTHING, TO WAKE UP JOBS WAITING FOR IT.
PTOCK:	TLNE LINE,DMLIN			;Don't check output buffer for DM PTYs
	JRST PTCKDM
	MOVE AC1,TOTAKR(DDB)
	CAME AC1,TOPUTR(DDB)		;IS THERE ANYTHING IN PTY'S OUTPUT BUF?
	TLNN LINE,PTYUSE		;IS PTY STILL IN USE ?
	JRST SETBF3			;NO. FLUSH THE OUTPUT BUFFER.
PTOCK1:
IFN FTIP,<
	SKIPE TAC,PTYIMP-PTYL0(LINE)	;Is this an IMP line?
	PUSHJ P,IMPTYW			;Yes, send output to the IMP
>;IFN FTIP
	SKIPLE TAC,PTYPTR(DDB)		;IS SOMEONE WAITING FOR OUR OUTPUT ?
	JRST PTCHK2			;YES, WAKE HIM UP
	MOVSI AC1,INTPTO		;GIVE PTY OUTPUT INTERRUPT
↑PTINTC:PUSH P,J			;NO
	MOVE J,PTYJOB-PTYL0(LINE)
	TDNE AC1,JBTIEN(J)
	PUSHJ P,TTINT
↑POPJJ:	POP P,J
	POPJ P,

;Clobbers TAC and AC1.  "Restores" J.  Sets up LINE.
PTICHK:	SKIPL TAC,PTYPTR(DDB)
	POPJ P,
PTCHK2:	SETZM PTYPTR(DDB)
	EXCH TAC,DDB
	PUSHJ P,SETIOD
	MOVSI AC1,IOW+TTYIOW
	ANDCAM AC1,DEVIOS(DDB)
	EXCH TAC,DDB
	PUSHJ P,STLNAC
	LDB J,PJOBN			;CLOBBERED BY STTIOD.  UUOCON MAY CARE
	POPJ P,
;TTYRST PTYCL2 PTYCL1 PTYUUO PTYUU3 PTYUU2 PTYUU4 LINMAP PTOCNT PTSTOR PTIFRE

↑TTYRST:HRRE LINE,JBTLIN(J)
	JUMPL LINE,PTYCL2
	MOVSI TAC,SPCBRK!XON
	HLL LINE,LINTAB(LINE)	;GET LINE BITS BACK
	TLNE LINE,PTYLIN	;IS THIS A PTY?
	TLZ TAC,XON		;YES, GIVE HIM BACK HIS LFS
	ANDCAM TAC,LINTAB(LINE)
	ANDCAM TAC,JBTLIN(J)
	PUSHJ P,TTYSRC		;FIND HIS TTY DDB
	MOVSI TAC,STDTBL	;AND SET HIS BREAK TABLE TO STANDARD.
	DPB TAC,PSWBPT		;CLEAR THE PASSWORD HIDE BIT
	HRRI TAC,ACTBTS(DDB)
	BLT TAC,ACTMOD(DDB)
	MOVEI TAC,GAGTBT
	ANDCAM TAC,IMLHAC(DDB)	;CLEAR THE TEMPORARY GAG BIT
	MOVEI TAC,NOECHO!NOECHB
	ANDCAM TAC,DEVIOS(DDB)	;TURN ECHOING BACK ON!
PTYCL2:	MOVEI LINE,PTYL0	;PREPARE TO SEARCH ALL PTY'S.
PTYCL1:	CAIL LINE,PTYL0+PTYNUM	;DONE?
	JRST CLRIMG		;YEAH, NOW CLEAR TTY IMAGE MODE
	PUSH P,LINE
	PUSH P,J
	PUSHJ P,PTYRL2		;YES. RELEASE IT FOR HIM.
	POP P,J
	POP P,LINE
	AOJA LINE,PTYCL1

↑PTYUUO:JUMPE UCHN,PTYGET
	XCTR XR,[HRRZ TAC,(UUO)]
	TRZE TAC,400000		;USE THIS TO MAP REAL LINES
	JRST LINMAP
	CAIGE TAC,TTPLEN
	CAILE UCHN,PTYXNO
	JRST UUOERR
	JUMPN TAC,PTYUU3
	HRRE TAC,JBTLIN(J)	;IF HE ASKS FOR LINE 0,
	JUMPL TAC,CPOPJ		;NOT IF DETACHED.
	JRST PTYUU2		;GIVE HIM HIS OWN TTY.

PTYUU3:	CAIL TAC,PTYL0		;IS IT A PTY ?
	CAME J,PTYJOB-PTYL0(TAC) ;YES. DOES HE OWN IT ?
	CAIN UCHN,PTRLCD	;NO. AN ERROR UNLESS HE'S RELEASING IT.
PTYUU2:	SKIPA LINE,LINTAB(TAC)
	JRST UUOERR		;THE LINE YOU REQUESTED ISN'T YOURS
	HRRI LINE,(TAC)
	ADDI UUO,1
	HRLI UUO,(<POINT 36,0,35>) ;MAKE FULL-WORD BYTE PTR. IN UUO.
	SKIPE DDB,TTYTAB(LINE)	;GET LOC. OF HIS DDB.
	JRST PTYUU4
	PUSHJ P,DDBSRC		;NO DDB, SO GET HIM ONE.
	 JRST UUOERR		;NONE AVAILABLE.
PTYUU4:	SKIPG PTYDIS(UCHN)	;LEGAL FOR TTY'S?
	TLNE LINE,PTYLIN	;NO.  IS THIS A PTY?
	JRST @PTYDIS(UCHN)
	JRST UUOERR		;PTY UUO THAT'S NOT LEGAL ON A TTY

LINMAP:	CAIL TAC,TTPLEN
	JRST UUOERR
	MOVE AC1,JBTPRV(J)
	TLNE AC1,MESPRV
	JRST PTYUU2		;ALL OK NOW
	SKIPN DDB,TTYTAB(TAC)
	JRST UUOERR
	LDB AC1,PJOBN
	CAMN AC1,J
	JRST PTYUU2
	JRST UUOERR

DEFINE UUOS{FOR X IN(PTYGET,<PTYREL,PTRLCD←←.-PTYDIS>,PTIFRE,<PTOCNT>
,<PTRD1S,400000>,<PTRD1W,400000>,PTWR1S,<PTWR1W>
,<PTRDS,400000>,PTWRS7,PTWRS9,<PTGETL,,GETLN1>
,<PTSETL,,SETLIN>,<PTLOAD,,PTLLED>,PTJOBX,PTL7W9)}

PSHSYS
LOSYS

UUOMAC PTYDIS,PTYUUO
PTYXNO←←UUOCNT-1

POPSYS

PTOCNT:	MOVN CHR,TOFCTR(DDB)	;-(AMOUNT OF ROOM LEFT IN BUFFER)
	ADDI CHR,TTOCHR		;+(TOTAL NUMBER OF CHARS BUFFER WILL HOLD)
	JUMPN CHR,PTSTOR	;=(NUMBER OF CHARS IN OUTPUT BUFFER)
	PUSHJ P,PAUCHK		;CHECK PAUSEB AND LEAVE CHR ZERO
PTSTOR:	XCTR XW,[MOVMM CHR,(UUO)]
	POPJ P,

PTIFRE:	MOVE CHR,TIFCTR(DDB)	;AMOUNT OF ROOM LEFT IN INPUT BUFFER
	SOJA CHR,PTSTOR		;COUNT CAN ONLY GO TO 1 NOT 0.
;⊗ PTYREL PTYRL2 PTYRL0 PTYRL4 PTRD1S PTRDS3 PTRD1W PTRD1A PTWAIT

PTYREL:	TLNE LINE,PTYLIN	;RELEASE THE PTY, IF IT REALLY IS ONE.
PTYRL2:	CAME J,PTYJOB-PTYL0(LINE) ;DOES THIS JOB OWN THIS PTY?
	POPJ P,
	PUSHJ P,PTYRL0		;Finish up stuff for this PTY, free PTY number
	LDB J,PJOBN		;GET JOB ON THIS PTY
	JUMPE J,TTYKIL		;IF none, no job to kill, just kill TTY
	PUSHJ P,INTKILL		;NOW KEEP HIM FROM FUTZING AROUND
	PUSHJ P,CLRIMG		;GET HIM OUT OF IMAGE MODE
	MOVEI TAC,F.KILL	;plant forced KILL cmd for job J
	JRST FORCER		;replace any already planted forced cmd!

;Here from ITYREL in IMPSER as well as from above.
↑PTYRL0:SKIPN DDB,TTYTAB(LINE)	;THIS IS NEEDED IF WE CAME FROM TTYRST
	JRST LINCL2		;CLEAR LINE BITS AND RETURN.
	PUSHJ P,XMTIN5		;FINISH OUTPUT.
	PUSHJ P,TSETBF		;CLEAR BOTH ITS BUFFERS.
	HRRZS LETAB(LINE)	;CLEAR LINE EDITOR FLAGS IN CASE WTFLAG ON
	SETZM PTYJOB-PTYL0(LINE) ;CLEAR OWNERSHIP FLAG.
	MOVSI TAC,PTYUSE	;MARK PTY AS NO LONGER USED, SO DDB WILL
	ANDCAB TAC,LINTAB(LINE)	;  BE KILLED BY TTYKIL.
	TLNE TAC,DMLIN
	SKIPN DAT,LETAB(LINE)
	POPJ P,			;NOT A DM, OR AT LEAST NO DPY HDR
	PUSHJ P,LEPDM1		;FLUSH ANY QUEUED DM XFERS
	SETZM DMQKCT(DAT)	;Also flush the abort sequence LEPDM0 puts out
	POPJ P,

repeat 0,<
PTYRL4:	MOVE UUO,[BYTE(9)600,600,"K",12]
	XCTR XW,[MOVEM UUO,JOBTM1] ;PUT IT IN USER CORE.
	XCTR XW,[SETZM JOBTM1+1]   ;Make sure PTWRS9 stops
	MOVE UUO,[POINT 9,JOBTM1]  ;THIS WILL BE RELOCATED.
	PUSHJ P,PTWR2		;SEND JOB ↑C ↑C K<LF>.
	POPJ P,
>;repeat 0

PTRD1S:	PUSHJ P,XMTIN1
PTRDS3:	XCTR XDB,[DPB CHR,UUO]	;GIVE CHARACTER TO USER
	JUMPE CHR,CPOPJ
	JRST CPOPJ1

PTRD1W:	PUSHJ P,PTRD1S
	 SKIPA UCHN,DDB
	POPJ P,
	PUSHJ P,TTYGET
	HRRZM DDB,PTYPTR(UCHN)
	MOVSI IOS,IOW!TTYIOW!DDTM
	TLNN LINE,PTYWAK	;DO WE WANT TO HEAR TTY INPUT ?
	JRST PTRD1A		;NO
	IORM IOS,DEVIOS(DDB)
	PUSH P,AC1		;WE PROBABLY DON'T NEED TO PRESERVE THIS AC...
	PUSHJ P,TWSAVE		;SAVE TTY WAIT BITS IN TTYBTS(DDB)
	POP P,AC1
PTRD1A:	PUSHJ P,PTWAIT
	SETZM PTYPTR(DDB)
	PUSHJ P,PTRD1S
	 POPJ P,		;Must have gotten TTY input, not PTY
	POPJ P,

PTWAIT:	MOVEI TAC,IOWQ
	MOVNM TAC,JOBQUE(J)
	MOVE DDB,UCHN		;RECOVER DDB FOR PTY.
	PUSHJ P,STLNAC		;RESTORE LINE (CLOBBERED BY TTYGET).
	JRST WSCHED
;⊗ PTWR1S PTWR1A PTWR1B PTWR1C PTCALL PTWR1D PTWR1W PTRDS PTRDS0 PTRDS6 PTRDS4 PTRDS5 PTWRS7 PTWRS9 PTWR2

PTWR1S:	SKIPN CHR,LETAB(LINE)	;IS THERE A LINE EDITOR FOR THIS PTY?
	JRST PTWR1A		;NO
	TLNN CHR,WTFLAG		;YES, IS IT BUSY?
	JRST PTWR1B		;NO
	POPJ P,			;YES, TAKE LOSE RETURN

PTWR1A:	MOVEI CHR,1
	CAMGE CHR,TIFCTR(DDB)	;IS THERE ROOM (greater than 1 NOT 0)?
	JRST PTWR1B		;YES, THERE'S ROOM
	XCTR XLB,[LDB CHR,UUO]	;NO, PEEK AT CHAR TO SEE IF IT'S A CALL
	ANDI CHR,177		;FLUSH PARITY BIT AND ANY BUCKIES
	JUMPE CHR,PTWR1B	;LET CALL THROUGH ANYWAY -- IT'LL CLEAR INPUT BUF
	CAIE CHR,3		;↑C IS HOW NON-DISPLAYS TYPE CALL
	POPJ P,			;NOT CALL, NO ROOM IN BUFFER, TAKE LOSE RETURN
PTWR1B:	AOS (P)			;THERE'S ROOM FOR THIS CHR, SKIP RETURN
	XCTR XLB,[LDB CHR,UUO]
	LDB UCHN,[POINT 2,CHR,28]
	PUSHJ P,STLNAC		;IN CASE KBDED IS AROUND CLOBBERING THINGS.
	TRNN CHR,10000		;IS THIS AN ESCAPE CHAR?
	JRST PTWR1C		;NO
	JSP TAC,UUOMES
	ASCIZ ⊗Illegal ESCAPE/BREAK char in PTWR1S/W UUO⊗

PTWR1C:	LDB DSER,[POINT 7,CHR,35] ;HERE FROM CLRBUF WITH A CLEAR IN CHR
	CAIL DSER,"A"		;SIMULATE KBDINT--PTY COULD BE A DPY
	CAILE DSER,"Z"
	JRST .+2
	TRO DSER,40
	MOVEI AC2,0
	MOVE TAC,JOB
	OFFSCN			;TURN OFF SCANNER CHANNEL
	SETZM PHYLIN		;CHAR DIDN'T COME FROM ANY PHYSICAL LINE
	TLNE LINE,PTYLIN	;Don't do DM conversion if not real PTY
	CAME TAC,PTYJOB-PTYL0(LINE) ; nor if we are not actual owner
	JRST PTWR1D
	PUSHJ P,RECDM		;If DM, do preprocessing
	 JRST SCNONJ		;This DM char needs no more handling
	 JFCL			;RECDM double skips but we don't care
	MOVE TAC,LINTAB(LINE)	;SET UP ESCAPE BITS
	DPB LINE,[PUNITS⊗6,,TAC] ;BUT NULLIFY MAPPING
	HLL TAC,PRGESC(LINE)	;Get escape bits
	PUSHJ P,NOESC		;PRETEND CHR HAS JUST BEEN TYPED IN
	JRST SCNONJ		;TURN ON SCANNER AND POPJ.

IFN FTIP,<
;Here from IMPSER to send a CALL to an IMP PTY.
↑PTCALL:MOVEI CHR,600		;Invent a CALL
	MOVE DDB,TTYTAB(LINE)	;Set up PTY's DDB
	MOVSI IOS,TPMON		;Put us into monitor mode to avoid image mode
	OFFSCN			;Turn off scanner channel
	IORM IOS,DEVIOS(DDB)
	SETZM PHYLIN		;Fall into PTWR1D
>;IFN FTIP
;HERE WHEN TTY ISN'T REALLY A PTY, OR ISN'T OURS
PTWR1D:	MOVEI LINE,(LINE)	;flush LH bits
	PUSHJ P,NOLOK2		;PROCESS CHAR, IGNORING ESCAPE BITS
	JRST SCNONJ		;TURN ON SCANNER AND RETURN

PTWR1W:	PUSHJ P,PTWR1S		;WRITE A CHAR
	 SKIPA UCHN,DDB		;DIDN'T GO. LET'S WAIT A WHILE.
	POPJ P,			;ALL DONE.
	PUSHJ P,TTYGET
	HRROM DDB,PTYPTR(UCHN)
	PUSHJ P,PTWAIT
	JRST PTWR1W

;PTRDS, PTWRS7, PTWRS9 CHANGED 3-30-71 TO USE LH (ADR+1) AS BYTE
;POINTER SPEC IF NON-ZERO ------ DCS
;Read a string of characters (at most =119, plus a null) from a PTY.
;User supplies a byte pointer or just an address for returned bytes.
;The 40,,0 bit in this byte pointer/address word means don't wait for first char.
PTRDS:	XCTR XR,[MOVE UUO,(UUO)] ;GET ADDRESS OF BUFFER IN LOSER CORE.
	TLNN UUO,7700		;Check size field of possible byte pointer
	TLZA UUO,777737		;Clear all but UNUSED bit of byte pointer
	TLZA UUO,37		;Keep byte pointer, clear indirect and index bits
	TLO UUO,440700		;No size field, use standard 7-bit bytes
	IBP UUO			;Prepare to DPB the first char
	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TTYHLD		;If this tty is holding, don't wait (forever)!
	TLNE LINE,DMLIN		;DMs don't hold that way
	JRST PTRDS6		;Grab all the chars we can
;Holding on non-DM -- return immediately with no chars
PTRDS0:	MOVEI CHR,0		;Mark end of string with a null
	JRST PTRDS3

PTRDS6:	MOVEI CHR,30*5-1	;Leave one byte of space for ending null
	XCTR XW,[MOVEM CHR,JOBTM1] ;Don't return more than 30 7-bit-byte wordsworth
	TLZE UUO,40		;If UNUSED bit in byte pointer is on,
	JRST PTRDS5		;then don't ever wait for a character
	PUSHJ P,PTRD1W		;Wait for at least one char to appear
PTRDS4:	IBP UUO			;Prepare to DPB the next char
	XCTR XRW,[SOSG JOBTM1]	;Run out of room for characters?
	JRST PTRDS0		;Yes, mark end of string
PTRDS5:	PUSHJ P,PTRD1S		;Get another char, if any
	 POPJ P,		;No more, we just now returned the ending null
	JRST PTRDS4		;Got one, look for another

;Here to write 7- or 9-bit string to a PTY.
PTWRS7:	TLCA UUO,444300		;MAKE 7-BIT PTR. ...
PTWRS9:	TLC UUO,445500		;MAKE 9-BIT PTR.
	HLR CHR,UUO		;SAVE BP SPEC FOR FIRST CHAR
	XCTR XR,[MOVE UUO,(UUO)] ;GET ADDRESS OF BUFFER IN USER CORE.
	TLZN UUO,7777		;CLEAR SIZE AND INDEX, CHECK
	HRL UUO,CHR		;ZERO, PROVIDE CORRECT PTR
	DPB CHR,[POINT 12,UUO,17] ;ASSURE CORRECT SIZE FIELD
PTWR2:	XCTR XLB,[ILDB CHR,UUO]
	PUSHJ P,STLNAC		;SET UP LINE, MAYBE CLOBBERED BY LINED
	JUMPE CHR,CPOPJ		;DONE IF NULL
	PUSH P,UUO		;save important AC, clobbered by DOTALK
	PUSHJ P,PTWR1W		;GIVE NEXT CHAR TO PTY.
	POP P,UUO
	JRST PTWR2		;LOOP UNTIL WE SEE A NULL.
;PTJOBX PTJDIR PTJDIS PTJTAB

PTJOBX:	LDB TAC,PJOBN		;GET JOB WHICH IS ON THIS PTY
	XCTR XR,[MOVE TAC1,(UUO)] ;GET COMMAND
	TLNN TAC1,770000	;IS IT SIXBIT OR DIRECT INDEX?
	JRST PTJDIR		;DIRECT
	MOVEI AC1,PTJLEN	;LENGTH OF TABLE
	CAME TAC1,PTJTAB-1(AC1)	;MATCH?
	SOJG AC1,.-1
	MOVE TAC1,AC1
PTJDIR:	JUMPLE TAC1,UUOERR
	CAILE TAC1,PTJLEN	;IS IT IN TABLE?
	JRST UUOERR		;NO
	HRRZ TAC1,PTJDIS-1(TAC1) ;GET DISPATCH
	JRST (TAC1)		;AND DISPATCH

DEFINE NAMES
<	C HALT,PTJHLT,0
	C CONT,PTJCON,0
	C DOFF,PTDOFF,0
	C DON,PTDON,0
	C LOGIN,PTLOGN,0
	C IWAITS,PTIWTS,0
	C CLRBFI,PTCLRB,0
	C DETACH,PTDET,0
	C PDETAC,PHNDET,0
>
DEFINE C(A,B,BITS)
<	XWD BITS,B
>
PTJDIS:	
XLIST
	NAMES
LIST
PTJLEN←←.-PTJDIS
DEFINE C(A,B,BITS)
<	SIXBIT/A/
>
PTJTAB:	
XLIST
NAMES
LIST
;NOTOK PTJHLT HLTOK PTJCON NOCONT PTIWTS PTIWT1

NOTOK:	POP P,J
	PUSHJ P,WSCHED		;WAIT A WHILE
PTJHLT:	JUMPE TAC,CPOPJ		;HALT JOB RUNNING ON THIS PTY
	PUSH P,J		;SAVE OURSELVES FIRST.
	MOVE J,TAC		;NOW DO IT TO HIM
	PUSHJ P,STOPCK		;NO, OK TO STOP?
	 JRST NOTOK
HLTOK:	PUSHJ P,STOP1
	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN

PTJCON:	JUMPE TAC,CPOPJ		;CONTINUE THE JOB RUNNING ON THIS PTY
	PUSH P,J
	MOVE J,TAC
	MOVM TAC,JOBQUE(J)
	CAIE TAC,STOPQ		;THIS IS ONLY PLACE YOU CAN CONTINUE FROM
	JRST NOCONT		;CAN'T CONTINUE
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JERR
	JRST NOCONT		;CAN'T CONTINUE FROM ERROR
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,SETRUN
	AOS -1(P)		;SUCCESS RETURN (2 SKIPS)
NOCONT:	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN

;SKIP IF PTY IS WAITING FOR INPUT

PTIWTS:	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TPMON		;MONMODE OR USRMODE?
	JRST PTIWT1
	JUMPL IOS,CPOPJ1	;USER MODE, CHECK TTYIOW BIT
	POPJ P,			;IT WAS OFF

PTIWT1:	LDB LINE,PUNIT		;(PTJOBX MUNGS "TAC1")
	MOVE TAC,TTYTAB(LINE)	;MONITOR MODE, GOBBLE TTYTAB
	TLNN TAC,COMBIT!DLYBIT!PAUSEB ;ANY COMMANDS STILL TO BE PROCESSED?
	AOS (P)			;NO
	POPJ P,
;PTCLRB PTDON PTDOFF PTLOGN PTLGN0 PTLGN1 PHNDET PTDET

; ROUTINES TO SET DUPLEXING OF PTY

;PTJOBX [N ↔ SIXBIT /CLRBFI/] -- DO CLRBFI FOR TTYN
PTCLRB:	PUSHJ P,STLNAC		;STUPID PTJOBX CLOBBERS LINE≡TAC1
	JRST SETBFI		;CLEAR INPUT BUFFER AND ANY LINE EDITOR

PTDON:	MOVEI IOS,NOECHO
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

PTDOFF:	MOVEI IOS,NOECHO
	ORB IOS,DEVIOS(DDB)
	POPJ P,

;START A NEW JOB ON A PTY.  USES FORK CODE.

PTLOGN:	JUMPN TAC,PTLGN1	;LOSE IF THERE'S A JOB ALREADY
	HRLM J,(P)		;SAVE OUR JOBNUM
	PUSHJ P,INIJOB		;GOBBLE A NEW JOB
	 JRST PTLGN0		;SORRY, NO JOBS
	 JRST PTLGN0		;THIS CAN'T HAPPEN (IT SAYS HERE)
	PUSHJ P,FORKC		;THIS COPIES THE OLD JOB'S STUFF
	MOVEI TAC,(J)		;TO RETURN IT TO LOSER
	AOSA (P)
PTLGN0:	MOVEI TAC,0
PTLGN1:	XCTR XW,[MOVEM TAC,(UUO)]
	POPJ P,

PHNDET:	SKIPA TAC,[F.PDET]	;FORCE A PDETACH COMMAND
PTDET:	MOVEI TAC,F.DET		;FORCE A DETACH COMMAND
	PUSHJ P,FORCEC		;PLANT IT
	JUMPE CHR,CPOPJ1	;JUMP IF NO PREVIOUS FORCED COMMAND
	POPJ P,
;DILDS1 DILDS0 DILBSY DILOK DILDSS DILVMD DILPWR DILCLR DILHUP DILENB DAREA VDI103 NDILIM DILINI DILIN DILINL DILTRL DILTR1

IFE DILNUM,<↑DIAL:JRST UUOERR>;IF NO DIALER, UUOERR
IFN DILNUM,<
;DIALER BITS AND DEFINITIONS

IFE FTVDIL,<
;CONI BITS
DILDS1←←4000		;DATASET ANSWERED OR DIALED END OF NUMBER CODE
DILDS0←←2000		;DATASET HUNG-UP
DILBSY←←1000		;DIALER BUSY
DILOK←←400		;DIALER OK (NOT TIMED OUT)
DILDSS←←200		;CONNECTED
DILVMD←←100		;IN VOICE MODE
DILPWR←←40		;POWER FAIL
;       20		;DIALER IS INTERRUPTING

;CONO BITS
DILCLR←←40		;CLEAR INTERRUPT CONDITION
DILHUP←←20		;HANG UP
DILENB←←10		;ENABLE INTERRUPT
>;IFE FTVDIL

;DATAO (and user spedified dialing) BITS (LEFT HALF)
DAREA←←4000		;DIAL AREA CODE
VDI103←←2000		;Dial a 103-type-modem call

NDILIM←←=15*60		;Maximum number of Dialer ints per minute before shutdown

;DIALER INITIALIZE ROUTINE
DILINI:
IFE FTVDIL,<
	CONO DIL,DILCLR!DILHUP!DILENB!DILCHN	;INIT HARDWARE
>;IFE FTVDIL
	SETZM DILZBG				;BEGIN ZERO OF DIALER DATA
	MOVE TAC,[DILZBG,,DILZBG+1]
	BLT TAC,DILZND				;AND ZERO TO END
IFE FTVDIL,<
↑DILIN:	MOVSI TAC,-DILNUM	;Number of dialers, here once a min to reset counts
	MOVEI TAC1,NDILIM	;Permit up to this many ints per pseudo min (150 baud)
DILINL:	MOVEM TAC1,DILINN(TAC)	;Set max int count
	AOBJN TAC,DILINL
>;IFE FTVDIL
	POPJ P,

DILTRL:	MOVSI AC1,-DILNUM
DILTR1:	HRRZ TAC,DILTTY(AC1)
	CAIE TAC,(LINE)
	AOBJN AC1,DILTR1
	JUMPGE AC1,CPOPJ
	PUSH P,LINE
	HRRZ LINE,AC1
	SKIPE DILJOB(LINE)
	PUSHJ P,RELDIL			;RELEASE DIALER
	POP P,LINE
	POPJ P,
;DILER0 DILER1 DILER2 DILER3 DILER4 DILER5 DILER6 DILER7 DILER8 DILERR DILSTT DIAL DILDIS MXDLCD DILGET DILTTY DILOWN DILSTA DILSTG DILDIL DILDI2 DILDI3 DAREAL DILDI4 DTELEL DILEP5 DILEP7 DILPUT DILHNG DILREL RELDIL DILSLP DILGO DLRTO DLRTO2 DLRTO3 DLRTO4 DLRTOU

;DIAL UUO
;CALL:	MOVEI AC,ADDR
;	DIAL AC,
;	<ERROR RETURN, AC CONTAINS STATUS BITS>
;	<SUCCESS, AC CONTAINS ANY DATA RETURNED>
;
;ADDR:	DIALER #,,FUNCTION CODE
;	SEE INDIVIDUAL CALL FOR REST OF DATA

DILER0:	JSP TAC,DILERR
DILER1:	JSP TAC,DILERR
DILER2:	JSP TAC,DILERR
DILER3:	JSP TAC,DILERR
DILER4:	JSP TAC,DILERR
DILER5:	JSP TAC,DILERR
DILER6:	JSP TAC,DILERR
DILER7:	JSP TAC,DILERR
DILER8:	JSP TAC,DILERR

DILERR:	SUBI TAC,DILER0+1
	HRRZ TAC,TAC
DILSTT:	XCTR XW,[MOVEM TAC,(UCHN)]	;STORE ERROR CODE BACK IN AC
	POPJ P,

;ERROR CODES FOR ALL DIAL UUO'S
;ERROR 0 -- ILLEGAL DIALER #
;ERROR 1 -- DON'T OWN DIALER
;ERROR 2 -- DON'T MEET DILOWN CONDITIONS
;ERROR 3 -- DIALER BUSY
;ERROR 4 -- DIALING FAILURE
;ERROR 5 -- CAN'T GET DDB FOR DIALER/ADAPTER'S TTY
;ERROR 6 -- DIALER/ADAPTER'S OUTPUT BUFFER OVERFLOWED
;ERROR 7 -- ILLEGAL DIGIT IN NUMBER
;ERROR 8 -- DIALER ITSELF TIMED OUT, PROBABLY NOT WORKING

↑DIAL:	XCTR XR,[HRRZ UUO,(UCHN)]	;FETCH POINTER TO ARG BLOCK
	XCTR XR,[HLRZ LINE,(UUO)]	;GET DIALER NUMBER
	CAIL LINE,DILNUM		;LEGAL?
	JRST DILER0			;NO, ERROR 0
	XCTR XR,[HRRZ DSER,(UUO)]	;GET FUNCTION CODE
	CAIL DSER,MXDLCD		;LEGAL FUNCTION CODE?
	JRST UUOERR			;NO
	CAME J,DILJOB(LINE)		;HIS?
	JUMPN DSER,DILER1		;NO, ERROR 1 (UNLESS DILGET)
	JRST @DILDIS(DSER)		;YES, CALL ROUTINE

DILDIS:	DILGET				;0 GET DIALER
	DILSTA				;1 GET DIALER STATUS
	DILDIL				;2 DIAL A NUMBER
	DILHNG				;3 HANG UP
	DILREL				;4 RELEASE
MXDLCD←←.-DILDIS

;CODE 0--GET DIALER
DILGET:	CAMN J,DILJOB(LINE)		;DOES HE OWN IT?
	JRST CPOPJ1			;ALREADY HAS IT, SUCCESS
	SKIPE DILJOB(LINE)		;DOES ANYONE OWN IT?
	JRST DILER1			;YES, DON'T OWN ERROR
	PUSHJ P,DILOWN			;CHECK CONDITIONS FOR DIALER OWNERSHIP
	 JRST DILER2			;LOSE
	MOVEM J,DILJOB(LINE)		;CLAIM IT
IFN FTVDIL,<
	SETZM VDILST(LINE)		;clear status of this line
>;IFN FTVDIL
	JRST CPOPJ1

;Table for translating Dialer number to TTY number.
DILTTY:
FOR @' I←0,DILNUM-1 <
	DIL'I'TT
>;FOR I

;Skip if allowed to have dialer whose number is in LINE.
DILOWN:	MOVE DDB,DILTTY(LINE)
	SKIPN DDB,TTYTAB(DDB)		;CHECK TTY FOR DIALER
	POPJ P,				;NO TTY THERE AT ALL
	LDB TAC,PJOBN
	CAME TAC,J			;IS IT HIS?
	POPJ P,				;NO
	MOVE TAC,DEVMOD(DDB)
	TRNE TAC,ASSPRG			;DOES HE HAVE IT INITED?
	AOS (P)				;YES, SUCCESS
	POPJ P,

IFN FTVDIL,<	;Vadic dialer code
;Code 1 -- Get status
DILSTA:	AOS (P)			;always successful
DILSTG:	MOVE TAC,VDILST(LINE)	;get status for this line
	JRST DILSTT		;return status to user

;Code 2 -- Dial a number
DILDIL:	OFFSCN			;don't let the dialer interrupt while we look
	SKIPN VDISTS		;Is the dialer idle?
	JRST DILDI2		;yes
;dialer/adapter is busy, mark this line as waiting for use of dialer/adapter
	HRLZM J,VDILST(LINE)	;store number of job waiting to dial this line
	ONSCN
	PUSHJ P,DILSLP		;wait for wakeup
	MOVE TAC,VDILST(LINE)	;see if maybe the dialer timed out
	TLNE TAC,-1		;skip if some status got set up
	JRST DILDIL		;check again
	JRST DILER8		;report timeout now, don't keep waiting

DILDI2:	HRLI LINE,(J)		;make it n,,m (job,,dialer line)
	ONSCN			;dialer interrupts can't bother us now
	SETZM VDILST(LINE)	;no status returned yet for this dial attempt
	PUSH P,LINE		;save job,,dialer number
	SKIPE DDB,TTYTAB+VDILIN	;is there already a DDB?
	JRST DILDI3		;yes
	MOVEI LINE,VDILIN	;tty number of dialer/adapter
	MOVEI TAC,(LINE)	;DDBSRV wants both TAC and LINE set up same
	PUSHJ P,DDBSRV		;get tty ddb for dialer/adapter
	 JRST DILEP5		;failed, shouldn't happen
	MOVEI TAC,ASSCON	;mark ddb in use by job zero--prevent init, TTYKIL
	IORM TAC,DEVMOD(DDB)	;set Assign bit (job number already set to zero)
	MOVEI TAC,GAGBIT	;gag this tty
	IORM TAC,IMLHAC(DDB)	;prevent unwanted output on this tty
;convert phone number to string for adapter, stuffing in tty output buffer.
;if buffer fills up, we abandon hope and abort the call.
DILDI3:	OFFSCN
	PUSHJ P,TSETBF		;clear input and output buffers, for good measure
	ONSCN
	MOVEI CHR,"B"-100	;↑B is start of text for adapter
	PUSHJ P,DILPUT		;put char into output buffer
	XCTR XR,[MOVE TAC,2(UUO)] ;get 2nd word of phone nbr
	XCTR XR,[MOVE AC1,1(UUO)] ;get area code word
	ANDI AC1,777700		;just area code
	CAIN AC1,4B21!1B25!5B29	;area 415?
	TLZ TAC,DAREA		;yes, don't dial area code
	MOVEI CHR,"0"		;assume non-103 type call, dialer 0
	TLNE TAC,VDI103		;103-type requested?
	ADDI CHR,4		;yes, tell adapter
	PUSHJ P,DILPUT		;output dialer/modem type character
	MOVEI CHR,DILNUM-1	;dialers are right to left in Vadic slots
	SUB CHR,(P)		;so reverse dialer number to get modem nbr
	LSH CHR,1		;multiply by two to get slot in Vadic rack
	MOVEI CHR,"0"(CHR)	;add base char to get right ASCII char
	PUSHJ P,DILPUT		;send modem address character
	TLNN TAC,DAREA		;want to dial area code?
	JRST DILDI4		;no
	MOVE AC2,[POINT 4,AC1,17] ;byte ptr to area code
	MOVEI AC3,3		;number of digits in area code
DAREAL:	ILDB CHR,AC2		;get digit
	CAILE CHR,9		;real digit?
	JRST DILEP7		;no, error
	ADDI CHR,"0"		;make ASCII digit
	PUSHJ P,DILPUT		;put out digit in area code
	SOJG AC3,DAREAL		;loop until done area code digits
DILDI4:	MOVE AC2,[POINT 4,TAC,7] ;byte ptr to telephone number
	MOVEI AC3,7		;number of digits in number
DTELEL:	ILDB CHR,AC2		;get digit
	CAILE CHR,9		;real digit?
	JRST DILEP7		;no, error
	ADDI CHR,"0"		;make ASCII digit
	PUSHJ P,DILPUT		;put out digit in telephone number
	SOJG AC3,DTELEL		;loop until done whole telephone number
	MOVEI CHR,"<"		;(matching ">") end of number character
	PUSHJ P,DILPUT		;tell adapter this is end of number
	MOVEI CHR,"O"-100	;↑O is buffer empty cmd to adapter
	PUSHJ P,DILPUT		;output to adapter
	MOVEI CHR,"C"-100	;↑C is end of text to adapter
	PUSHJ P,DILPUT		;output to adapter
	MOVE TAC,(P)		;get job and dialer number
;conversion is done, start up adapter's tty.
	PUSHJ P,DILGO		;start output to adapter, set timeout going
	MOVE J,JOB		;clobbered by TYPT2
	PUSHJ P,DILSLP		;wait for wakeup when dialing done or fails
	POP P,LINE		;get back dialer number
	MOVE TAC,VDILST(LINE)	;get latest status
	CAIN TAC,VDIOK		;successful dialing?
	JRST CPOPJ1		;yes, skip return to user
	CAIN TAC,VDITMO		;give different code for timeout
	JRST DILER8		;dialer timed out, didn't even try to dial probably
	JRST DILER4		;return dialer failure code to user

DILEP5:	POP P,LINE		;fix stack
	JRST DILER5		;report system error, can't get ddb for dialer

DILEP7:	POP P,LINE		;fix stack
	OFFSCN
	PUSHJ P,TSETBF		;flush input and output buffers
	ONSCN
	JRST DILER7		;report error, illegal digit in number

;put character from CHR into output buffer of dialer's tty, whose DDB is in DDB.
;on error (buffer full), returns up a level to error routine
DILPUT:	OFFSCN
	PUSHJ P,PUTCRS		;put char into output buffer quickly
	JUMPN CHR,SCNONJ	;jump if OK
	SUB P,[1,,1]		;output buffer filled up, don't return
	POP P,LINE		;fix stack
	PUSHJ P,TSETBF		;clear input and output buffers, flush our work
	ONSCN
	JRST DILER6		;give overflowing buffer error

;Code 3 -- Hang up dialer's phone
DILHNG:	PUSH P,LINE		;remember which dialer
	MOVE LINE,DILTTY(LINE)	;get tty nbr from dialer nbr
	PUSHJ P,HNGCMD		;hang up this tty
	 AOS -1(P)		;HNGCMD skips on failure, we skip on success
	POP P,LINE		;get back dialer nbr
	JRST DILSTG		;get status and return it

;Code 4 -- Release dialer
DILREL:	PUSHJ P,RELDIL
	JRST DILSTA		;return status

;Release dialer
RELDIL:	SETZM DILJOB(LINE)	;un-claim this dialer
	PUSH P,LINE		;remember which dialer
	MOVE LINE,DILTTY(LINE)	;get tty nbr from dialer nbr
	PUSHJ P,HNGCMD		;hang up this tty
	 JFCL			;HNGCMD skips on failure, we don't care
	POP P,LINE		;get back dialer nbr
	POPJ P,

;here to go into IOWQ to wait for something
DILSLP:	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE		;put job into IOWQ
	JRST WSCHED		;wait for some wakeup

DILGO:	MOVEM TAC,VDISTS	;store n,,m (job,,dialer line) for dialer int
	MOVE TAC,DCLKNM		;get timeout sequence number
	LSH TAC,=12		;position for clock request
	ADD TAC,[$DLRTO,,=60*JIFSEC] ;timeout in 60 seconds if no response
	CLKENQ(TAC)		;Plant clock request
	PUSHJ P,STLNAC		;set up LINE
	JRST TYPT2		;start output for adapter's tty line

;Here when the clock request times out.  If user still waiting for dialer
;and this clock request matches the last clk req made, then dialer is hung.
;Datum of clock request (seq nbr) is in TAC.
↑DLRTO:	OFFSCN
	SKIPE AC1,VDISTS	;skip if no one waiting for dialer response
	CAME TAC,DCLKNM		;waiting for dialer, is this clk req the latest?
	JRST SCNONJ		;not waiting, or this isn't latest clk req
	AOS VDITOC		;count dialer timeouts, for debugging
	SETZM VDISTS		;clear current status
	SKIPN DDB,TTYTAB+VDILIN	;get tty ddb for dialer
	JRST SCNONJ		;hmm
	PUSHJ P,TSETBF		;clear tty buffers
	MOVEI CHR,"A"-100	;↑A means abort now
	PUSHJ P,DILPUT		;stuff into output buffer
	ONSCN
	JUMPL AC1,DLRTO3	;jump if timeout occurred after another timeout
	PUSHJ P,DLRTOU		;give timeout to user of this line, wake up user
DLRTO2:	MOVNI TAC,1		;set status indicating waiting for reset response
	JRST DILGO		;start dialer output, start timeout going

;Here after back to back dialer timeouts.  Wake up all jobs waiting
;for dialer and give each timeout error.
DLRTO3:	MOVEI AC1,DILNUM-1	;loop through all dialable lines
	PUSH P,AC1
DLRTO4:	HLL AC1,VDILST(AC1)	;get status of this line in LH (line in RH)
	TLNE AC1,-1		;skip if no job waiting for this line
	PUSHJ P,DLRTOU		;give timeout to user of this line, wake up user
	SOSL AC1,(P)		;next line, skip if done
	JRST DLRTO4		;loop through lines
	SUB P,[1,,1]		;flush line count from stack
	JRST DLRTO2		;now go start up output to try resetting dialer

DLRTOU:	MOVEI CHR,VDITMO	;get code for timeout
	MOVEM CHR,VDILST(AC1)	;store timeout status for this dialer line
	HLRZ J,AC1		;get job number
	JRST VDIWAK		;wake up that job, if still waiting
>;IFN FTVDIL
;VDITMO VDIOK VDIINT VDIIN2 VDIIN3 VDIIN4 VDIWAK

IFN FTVDIL,<
;The possible states of the dialer/adapter are:
;	VDISTS/	0	idle			
;	VDISTS/	n,,m	dialing dialer m for job n, awaiting response character
;	VDISTS/	-1	awaiting reset response character
;There are DILNUM dialable lines (only one dialer/adapter, usable on any line).
;For each dialable line, there is a cell VDILST(dialer nbr) which indicates
;the status of that dialer.  The possible values of this cell are:
;	n,,0	Job n is waiting to dial this dialer (another line using dialer)
;	0	Idle -- this dialer not yet dialed since dial-get
;	100	Timeout occurred -- adapter didn't respond
;(the following are characters received from the adapter, stored in VDILST:)
;	101 (A) Data Set Status -- successful call completion
;	102 (B) Abort/ACR -- call aborted by system or dialer
;	103 (C) (unused)
;	104 (D) Format error -- data framing error in dial string at adapter
;	105 (E) Parity error -- parity error in dial string at adapter
;	106 (F) RAM overflow -- dial string too long
;	107 (G) Data Line Occupied -- modem or dialer is busy (off hook)

;NOTE: We need to make sure that we properly handle a user typing CALL while his
;job is waiting for a dialer.  Also must handle his typing CONTINUE thereafter.
;Finally, there is a timeout for the dialer, in case it never interrupts back.

VDITMO←←100	;code indicating timeout occurred with no adapter response.
VDIOK←←101	;"A" is success response from adapter upon call completion.

;Here when have just received input character (in CHR) from Vadic dialer/adapter
VDIINT:	SKIPN AC1,VDISTS	;get number of dialer line being dialed
	POPJ P,			;none, ignore character
	SETZM VDISTS		;dialer is now idle
	AOS TAC,DCLKNM		;cancel timeout's clock request
	CAILE TAC,77		;keep sequence nbr in 6 bits
	SETZM DCLKNM		;start over at zero
	JUMPL AC1,VDIIN2	;jump if we were only awaiting reset response
	ANDI CHR,177		;discard parity bit
	MOVEM CHR,VDILST(AC1)	;store current status for this dialer line
	HLRZ J,AC1		;get job number
	PUSHJ P,VDIWAK		;wake up that job, if still waiting
;Finished with that dialing task.  See if anyone else is waiting to dial.
;To avoid a deadlock (CALLed out of Dial wait), we simply wake up all the
;waiters and let them fight it out to see who's gonna get the dialer next.
VDIIN2:	MOVSI AC2,-DILNUM	;aobjn for potential waiters
VDIIN3:	HLRZ J,VDILST(AC2)	;get possible job number of waiter
	JUMPE J,VDIIN4		;jump if no job waiting for this dialer
	PUSHJ P,VDIWAK		;wake up job waiting to dial
VDIIN4:	AOBJN AC2,VDIIN3	;loop through possible waiters
	POPJ P,			;no more waiters

VDIWAK:	MOVM TAC,JOBQUE(J)	;see what queue that job is in
	CAIE TAC,IOWQ		;still waiting for us?
	POPJ P,			;no
	MOVNI TAC,RUNQ		;probably, let job run again
	MOVEM TAC,JOBQUE(J)	;store new queue
	JRST REQUE		;get job into RUNQ
>;IFN FTVDIL
;DILSTA DILDIL DILWAT DILHNG DILREL RELDIL

IFE FTVDIL,<	;old dialer code
;CODE 1 GET STATUS
DILSTA:	CONI DIL,TAC			;GET CURRENT STATUS
	HRL TAC,DILCNI(LINE)		;LAST I-LEVEL CONI IN LEFT HALF
	AOS (P)				;ALWAYS SUCCESSFUL HERE
	JRST DILSTT			;RETURN STATUS BITS IN AC

;CODE 2 DIAL A NUMBER
DILDIL:	CONSZ DIL,DILBSY
	JRST DILER3			;DIALER BUSY
	CONSZ DIL,DILPWR		;IS DIALER POWER OK?
	JRST DILER4			;NO, GIVE HIM AN ERROR RIGHT AWAY
	XCTR XR,[MOVE TAC,2(UUO)]	;PICKUP DATAO WORD
	XCTR XR,[MOVE AC1,1(UUO)]	;PICKUP CONO WORD
	ANDI AC1,777700			;JUST AREA CODE
	CAIN AC1,4B21!1B25!5B29		;AREA 415?
	TLZ TAC,DAREA			;YES, DON'T DIAL AREA CODE
	CONO PI,DILOFF			;DISABLE DIALER CHANNEL
	CONO DIL,DILCLR!DILENB!DILCHN(AC1)	;SETUP
	DATAO DIL,TAC			;AND GO
DILWAT:	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	MOVE AC1,[JRST DILING]		;DISPATCH FOR I-LEVEL
	MOVEM AC1,DILIDS(LINE)
	SETZM DILCNI(LINE)		;CLEAR CONI BITS FOR CHECK
	CONO PI,DILON
	PUSHJ P,WSCHED			;WAIT FOR DIALER
	CONO PI,DILOFF			;INTERLOCK
	SKIPN TAC,DILCNI(LINE)		;GET CONI BITS
	JRST DILWAT
	CONO PI,DILON
	TRC TAC,DILDS1!DILOK!DILDSS	;ALL THESE SHOULD BE ON
	TRCN TAC,DILDS1!DILOK!DILDSS
	TRNE TAC,DILDS0!DILPWR		;THESE SHOULD BE OFF
	CAIA
	JRST DILSTAT			;OK, RETURN STATUS
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	JRST DILER4			;DIALER ERROR

;CODE 3 HANG UP
DILHNG:	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	JRST DILSTAT			;RETURN STATUS

;CODE 4 RELEASE DIALER
DILREL:	PUSHJ P,RELDIL
	JRST DILSTAT			;RETURN STATUS

RELDIL:	SETZM DILIDS(LINE)		;CLEAR I-LEVEL DISPATCH
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	SETZM DILJOB(LINE)
	POPJ P,
>;IFE FTVDIL
;DILINT DILXIT DILKIL DILXT1 DILING DILIN0 DILIN1 DILACT DILERP DILERT DILLUZ DILRUN

IFE FTVDIL,<
;DIALER INTERRUPTS COME HERE
↑DILINT:MOVEM LINE,DILLIN
	MOVEI LINE,0			;ONLY ONE LINE FOR NOW
	MOVEM TAC,DILTAC
	SOSG DILINN(LINE)		;COUNT DIALER INTERRUPTS FOR RUNAWAY CHECK
	JRST DILLUZ			;Too many interrupts
	CONI DIL,TAC			;GET STATUS BITS
	MOVEM TAC,DILCNI(LINE)		;LATEST CONI BITS
	SKIPE DILIDS(LINE)		;THIS DIALER ACTIVE?
	XCT DILIDS(LINE)		;DISPATCH TO DIALER ROUTINE OR EXIT
DILXIT:	CONSO DIL,DILBSY		;DIALER BUSY?
	JRST DILXT1			;NO, DON'T CHECK FOR HANGUP
	CONSO DIL,DILOK			;IF NOT OK
DILKIL:	CONO DIL,DILHUP			;HANG UP
DILXT1:	CONO DIL,DILCLR!DILENB!DILCHN	;CLEAR INTERRUPT, ENABLE, SET CHANNEL
	MOVE TAC,DILTAC
	MOVE LINE,DILLIN
IFN FTXADR,<
	XJEN DILCHL
>;IFN FTXADR
IFE FTXADR,<
	JEN @DILCHL
>;IFE FTXADR

DILING:	TRNE TAC,DILDS1			;SHOULD HAVE JUST CONNECTED
	TRNN TAC,DILDSS			;AND STILL BE CONNECTED
	TDZA TAC,TAC			;NOT CONNECTED, IDLE STATE
	MOVE TAC,[JRST DILACT]		;CONNECTED, SET TO ACTIVE STATE
	MOVEM TAC,DILIDS(LINE)		;SET DISPATCH
	MOVEM J,DILJ
	MOVE J,DILJOB(LINE)
	MOVM TAC,JOBQUE(J)
	CAIE TAC,IOWQ			;STILL WAITING FOR US?
	JRST DILIN1
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	MOVEI TAC,QJOB(J)
	SYSPIFF
	SKIPE (TAC)
	JRST DILIN0
	EXCH TAC,QJOB
	HRROM TAC,@QJOB
DILIN0:	SYSPIN
DILIN1:	MOVE J,DILJ
	JRST DILXIT

DILACT:	TRNE TAC,DILOK			;IF NOT OK,
	TRNE TAC,DILDS0!DILPWR		;OR ANY ERRORS
	XCT DILERP(LINE)		;THEN REPORT ERROR
	JRST DILXIT			;I WONDER WHAT WAS WRONG?

DILERP:	JRST DILERT			;REPORT TO TTY

DILERT:	MOVE TAC,DILTTY(LINE)
	SKIPN TAC,TTYTAB(TAC)		;JUST IN CASE
	JRST DILXIT			;FOO
	MOVEM J,DILJ
	MOVSI J,IODERR
	IORM J,DEVIOS(TAC)		;FLAG ERROR TO TTY
	MOVE J,DILJ
	JRST DILXIT

DILLUZ:	HRLI LINE,DILRUN	;Clock routine to notify CTY
	SYSPIFF
	IDPB LINE,CLKQ		;Plant clk req
	SYSPIN
	MOVEI TAC,NDILIM	;Max int count per min
	MOVEM TAC,DILINN(LINE)	;Reset count, in case still losing
	JRST DILKIL		;HANG UP, ENABLE, SET CHANNEL, CLEAR INTERRUPT

;Here from clock request when dialer has been hung up for interrupting too much
DILRUN:	PUSHJ P,DISGST		;Print time on CTY
	PUSHJ P,DISMES
	 ASCIZ/Hanging up runaway auto-dialer.
/
	POPJ P,
>;IFE FTVDIL
>;IFN DILNUM
;⊗ TTYSET EXPTTY TTYDDL TTYDD0 TTYOPM TTYNDB TTYDD1 TTYDD2 TTYDDE TTYDE2 MINUS1 NODBOK TTYOP LTTYOP TTWID TTESC TTESC2 NOCCR NOCCR0 NOCCR1 NOCCR2 ZERBUF NOCCR4 NOCCR3 GETHP GETHP3 TTYSTO TTYSTN GTLNCH GETHP2 GETWID LINSET LINCLE STIOS CLIOS GTIOS DMDIDL GDPHGT SDPHGT SDPWID GETRSP GETHID GETDMF GTCDPY GETGAG SETGAG GTTGAG STTGAG GETCVT SETCVT GETPSW SETPSW GETGLA SETGLA GETDEL SETDEL SETIMP SETDM SETDPT SETDPL SETDPP SETDPB SETDPN DPMSKM GETDPT SETSPD GETWHO SETWHO GETPAD SETPAD GETBAU SETBAU GTNESC GTNES1 GTNES2 STNESC GTNEDT STNEDT GTHTOG STHTOG GTQMOD STQMOD GTLNBT GTEXST STEXST GTDPDS STDPDS

COMMENT ⊗
TTYSET: UUO LIVES HERE--EXECUTE COMMANDS FROM A TABLE ⊗
;CALL:	MOVE AC,[-LEN,,TABLE]
;	TTYSET AC,
;
;TABLE:	BLOCK LEN
;
;Bits 1:8 of each function word in table specify operation desired.
;If EXPTTY bit (sign bit) is on, then 777,,0 bits specify tty line to examine/set.
;In set cmd, right half of function word is usually immediate data.
;In get cmd, right half specifies address where data is to be returned.
;Set cmd only works for ttys or ptys owned by the job.
;Set cmd with illegal or free line and set cmd of self when detached are no-ops.
;Get cmd with illegal or free line and get cmd of self when detached return -1.

EXPTTY←←400400	;Left half bit(s) in cmd word that indicates diddling explicit TTY.
;During transition, we'll accept either bit, but eventually the 400 bit will
;be phased out and we'll use only the sign bit, allowing tty nbrs to be 9 bits.
IFG PUNITS-8,<.FATAL EXPTTY in TTYSET UUO can't use 400 bit any more>

↑TTYDDL:JUMPGE TAC,CPOPJ
TTYDD0:	XCTR XR,[MOVE UUO,(TAC)]	;GET NEXT COMMAND
	LDB AC1,[POINT 8,UUO,8]		;PICK UP OP CODE
TTYOPM:	CAIL AC1,LTTYOP
	JRST UUOERR			;ILLEGAL TTYSET OPCODE
;NOW FIGURE OUT WHAT TTY TO OPERATE ON
	HRRZ LINE,JBTLIN(J)		;GET DEFAULT TTY (IMPROPER IF DETACHED)
	TLNE UUO,EXPTTY			;SPECIFIC TTY?
	LDB LINE,[POINT PUNITS,UUO,17]	;YES, GET LINE NUMBER OF INTEREST
	CAIL LINE,TTPLEN		;LEGAL LINE NUMBER?
	JRST TTYDE2			;Can't do anything if TTY number bad
	SKIPN DDB,TTYTAB(LINE)		;YES, LINE IN USE?
	JRST TTYDDE			;NO
	LDB AC2,PJOBN			;GET TTY'S OWNER JOB
TTYNDB:	HLL LINE,LINTAB(LINE)		;GET LINE CHARACTERISTICS
	SKIPL TTYOP(AC1)		;IS THIS A GETTING OPERATION?
	CAIN AC2,(J)			;NO, ARE WE SETTING OUR OWN TTY?
	JRST TTYDD1			;YES, GO DO IT
	MOVSI TEM,DEVPRV
	TDNE TEM,JB2PRV(J)		;ARE WE PRIVILEGED?
	JRST TTYDD1			;YES, GO DO IT
	TLNE LINE,PTYLIN		;NO, MAYBE THE TTY IS A PTY OF OURS
	CAME J,PTYJOB-PTYL0(LINE)	;IS A PTY -- IS IT OURS?
	JUMPN AC2,TTYDD2		;OK to diddle some TTY not in use (w/DDB!)
;NOW WE HAVE DDB AND LINE SET UP TO THE RIGHT TTY (UNLESS ERROR DISPATCH TO MINUS1)
TTYDD1:	PUSH P,TAC			;PRESERVE IMPORTANT ACS
	PUSH P,J
	PUSHJ P,@TTYOP(AC1)		;Execute the command.  To simplify life,
	 JFCL				;allow for skip by TTY XXX cmd routine.
	POP P,J
	POP P,TAC
TTYDD2:	AOBJN TAC,TTYDD0		;ANY MORE COMMANDS?
	POPJ P,				;NO

;Here if specfied TTY has no DDB.  Maybe that's OK, maybe not.
TTYDDE:	MOVE TEM,TTYOP(AC1)	;Get dispatch and LH bits
	MOVEI AC2,0		;Set job number to zero since no DDB in use
	TLNE TEM,NODBOK		;Skip unless this TTYSET doesn't need DDB
	JRST TTYNDB		;Go ahead without DDB
TTYDE2:	SKIPL TTYOP(AC1)	;ILLEGAL TTY -- SKIP IF GETTING DATA
	JRST TTYDD2		;Jump if setting: No-op since there is no DDB
	SETO AC1,		;MAKE US DISPATCH TO MINUS ONE -- RETURN -1
	JRST TTYDD1		;Return -1 for no DDB

MINUS1:	SETO TAC,		;RETURN -1 FOR IMPROPER GET COMMAND
	JRST TTYSTO

;Dispatch&flag table for TTYSET functions.  Index with Op code.
;SIGN BIT MEANS GETTING VALUE--JOB CAN SPECIFY TTY TO DO OPERATION ON.
NODBOK←←200000		;Dispatch flag meaning no DDB needed for this function

	MINUS1		;-1	;USED BY DISPATCHER TO RETURN -1
TTYOP:	CPOPJ		;0	;NO-OP
	LINSET		;1	;TURN ON GIVEN LINE CHARACTERISTICS BITS
	LINCLE		;2	;TURN OFF GIVEN LINE CHARACTERISTICS BITS
400000,,GTLNCH		;3	;GET LINE CHARACTERISTICS
	TTESC		;4	;DO ESC COMMAND
	TTWID		;5	;SET TTY WIDTH FIELD
400000,,GETWID		;6	;GET TTY WIDTH OR DPY WIDTH
400000,,GETHP		;7	;GET TTY HORIZONTAL POSITION
	NOCCR		;10	;PREVENT USER FROM DOING CONTROL-CR NOW ONLY
	STIOS		;11	;TURN ON GIVEN IOS BITS
	CLIOS		;12	;TURN OFF GIVEN IOS BITS
400000,,GTIOS		;13	;GET TTY'S IOS BITS
	DMDIDL		;14	;DIDDLE SPECIAL DM BITS
400000,,GDPHGT		;15	;GET DPY HEIGHT (LINES/SCREEN)
	SDPHGT		;16	;SET DPY HEIGHT (DMs ONLY)
400000,,GETRSP		;17	;GET RESPONSIBLE TTY
400000,,GETHID		;20	;GET HIDDEN BIT FOR TTY
400000,,GETDMF		;21	;GET DM STATE FLAGS
400000,,GTCDPY		;22	;GET CONTROLLING DPY
400000,,GETGAG		;23	;GET GAG BIT
	SETGAG		;24	;SET GAG BIT
400000,,GETCVT		;25	;GET CONVERT BIT
	SETCVT		;26	;SET CONVERT BIT
400000,,GETPSW		;27	;GET PASSWORD BIT
	SETPSW		;30	;SET PASSWORD BIT
	CLINED		;31	;CLEAR LINE EDITOR
400000,,GTTGAG		;32	;GET TEMPORARY GAG BIT
	STTGAG		;33	;SET TEMPORARY GAG BIT
	SETIMP		;34	;MAKE THIS PTY AN IMP TTY
	SETDM		;35	;MAKE THIS TTY A DATAMEDIA
400000,,GETGLA		;36	;GET TTY GLASS BIT
	SETGLA		;37	;SET TTY GLASS BIT
NODBOK,,SETSPD		;40	;SET SPEED
NODBOK,,HNGCMD		;41	;HANG UP THE LINE
400000,,GETWHO		;42	;GET JOB NUMBER OF WHOLINE
	SETWHO		;43	;SET JOB NUMBER FOR WHOLINE
400000,,GETPAD		;44	;GET DM PADDING CHAR
	SETPAD		;45	;SET DM PADDING CHAR
400000,,GETBAU		;46	;GET DM BAUD RATE FOR PADDING CALCULATIONS
	SETBAU		;47	;SET DM BAUD RATE FOR PADDING CALCULATIONS
400000,,GETDEL		;50	;GET TTY NO DELETE BIT
	SETDEL		;51	;SET TTY NO DELETE BIT
	SDPWID		;52	;SET DISPLAY (DM) WIDTH
400000,,GTNESC		;53	;GET NOEDIT ESCAPE CHARS
	STNESC		;54	;SET NOEDIT ESCAPE CHAR (SIC)
400000,,GTNEDT		;55	;GET NOEDIT FLAG
	STNEDT		;56	;SET NOEDIT FLAG
400000,,GTHTOG		;57	;GET HTOGGL FLAG
	STHTOG		;60	;SET HTOGGL FLAG
400000,,GTQMOD		;61	;GET NOEDIT QUOTE MODE
	STQMOD		;62	;SET NOEDIT QUOTE MODE
400000,,GETDPT		;63	;GET DISPLAY TYPE NAME
	SETDPT		;64	;SET DISPLAY TYPE FROM NAME
	TTYNDM		;65	;MAKE THIS TERMINAL NOT A DISPLAY (CLEAR DMLIN)
	DPINIT		;66	;MAKE SYSTEM RE-INIT THIS DISPLAY (NO TYPE CHANGE)
	TABCHK		;67	;Re-set tab stops if terminal has them
400000!NODBOK,,GTLNBT	;70	;Get LINBIT entry for this TTY
400000!NODBOK,,GTEXST	;71	;Get bit indicating TTY's existence
NODBOK,,STEXST		;72	;Set bit indicating TTY's existence
	SETBFT		;73	;Clear TTY input buffer
	SETBF2		;74	;Clear TTY output buffer
	HNGCLS		;75	;Close network connection for PTY
400000,,GTDPDS		;76	;Get DPYDES bits (even if non-display)
	STDPDS		;77	;Diddle DPYDES bits (even if non-display)
;The next few aren't implemented yet.
;	PTOWNR			;GET PTY'S OWNER JOB
;	STSPCL			;SET SPECIAL BITS IN 4TH WORD OF ACT TABLE
;	GTSPCL			;GET SPECIAL BITS IN 4TH WORD OF ACT TABLE
;	STACT			;SET ACTIVATION TABLE LESS SPECIAL BITS
;	GTACT			;GET ACTIVATION TABLE INCLUDING SPECIAL BITS
LTTYOP←←.-TTYOP
	0		;Two TTYSET patch spaces.  If you patch a routine in,
	0		; don't forget to patch LTTYOP at TTYOPM.
;Max op code is 377, since sign bit is used as EXPTTY bit.

TTWID:	MOVEI TAC1,(UUO)	;GET ARG
	JUMPE TAC1,TTWID0	;IF NO ARG, USE OLD DEFAULT
	JRST TTWID1

;NOTE THAT THIS CLOBBERS J BECAUSE LINED USES J FOR DPY HEADER ADDRESS.
;ANY TTY CAN TRY TO SEND ESCAPES, BUT CERTAIN ONES ARE NO-OPS IF TTY ISN'T A DISPLAY
TTESC:	LDB AC1,[POINT 9,UUO,26] ;GET NUMERIC ESCAPE ARGUMENT
	CAILE AC1,ESCMAX
	MOVEI AC1,ESCMAX	;MAX ALLOWABLE ARG
	TRNE UUO,400		;DOES HE WANT BREAK INSTEAD OF ESCAPE?
	HRLI AC1,400000		;YES, ARG IS IN SIGN-MAGNITUDE FORM
	MOVEI AC2,777200	;Any of these on in UUO means non-null arg
	AND AC2,UUO
	LDB DSER,[POINT 7,UUO,35] ;GET ESCAPE LETTER
	SETO DAT,		;Flag for ESCDIF meaning no radix conversion
TTESC2:	CAIL DSER,"a"		;ENTER HERE FROM TTY ESCAPE/BREAK COMMAND
	CAILE DSER,"z"
	CAIA
	TRZ DSER,40		;MAKE SURE IT'S UPPER CASE
	MOVE J,LETAB(LINE)	;GET DPY HEADER IF ANY
	OFFSCN			;OFF WITH THE SCANNER CHANNEL
	MOVEM AC2,GOTARG	;TELL LINED IF WE GOT A NULL ARG OR ZERO ARG
	MOVEM DAT,ESCDIF	;Remember whether arg is in proper radix
	MOVE DAT,LINE		;LINED WANTS LINE BITS IN DAT
	SETZM PHYLIN		;NOT FROM A PHYSICAL TTY
	PUSHJ P,TTYESC		;GO OFF TO LINED
	JRST SCNONJ

NOCCR:	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,NOCCR0		;do the work
	JRST SCNONJ		;restore scanner channel

NOCCR0:	SKIPLE J,LETAB(LINE)	;ONLY DO IT IF HAVE HDR & LINE EDITOR EMPTY
;Enter here from ESCFF in LINED.
↑NOCCR1:TLNE J,WTFLAG		;IS LINE BEING TRANSFERRED TO TTY INPUT BUF?
	JRST NOCCR2		;JUST CLEAR OUT INPUT BUFFER
	SETZM LEPNT1(J)		;PREVENT CONTROL-CR FROM GETTING LAST LINE
	PUSHJ P,LEINIT		;INIT THE LINE EDITOR BUFFER
NOCCR2:	MOVEI DAT,TTIBUF(DDB)	;Pointer to buffer to zap
	PUSHJ P,ZERBUF		;Zero the unused part of the buffer
	MOVE AC2,TITCTR(DDB)	;Get current takr count
	DPB AC2,PCOMIC		;Store for RESCAN to avoid backing into nulls
	POPJ P,

↑ZERBUF:MOVEI CHR,0		;Fill unused bytes in buffer with nulls
	MOVE AC1,FCTR(DAT)	;Set up counters and pointer to
	MOVE AC2,PCTR(DAT)	; simulate PUTCHI, except that we "fill"
	MOVE AC3,PUTR(DAT)	; the last byte but PUTCHI doesn't
NOCCR4:	SOJL AC1,CPOPJ		; ANY FREE SPACES LEFT?
	SOJG AC2,NOCCR3		;LAST BYTE IN BUFFER FILLED?
	HLRZ AC2,BUF(DAT)	;INITIAL COUNTER
	HRR AC3,BUF(DAT)	;BYTE POINTER
NOCCR3:	IDPB CHR,AC3		;Put in a null
	JRST NOCCR4

GETHP:	SKIPN LETAB(LINE)	;GET DPY HEADER, IF ANY
	JRST GETHP2		;NO, GIVE HIM TTY HPOS
	TLNE UUO,EXPTTY		;CAN'T WAIT FOR SOMEONE ELSE'S DPY
	JRST GETHP3
	PUSHJ P,HPWAIT		;WAIT FOR OUTPUT BUFFER TO EMPTY ON DPY
	 JRST MINUS1		;job became detached while waiting, return -1
GETHP3:	LDB LINE,PUNIT		;HPWAIT MAY CLOBBER ALL KINDS OF ACS
	SKIPN J,LETAB(LINE)	;(IT BETTER NOT CLOBBER UUO OR DDB)
	JRST GETHP2		;WHERE'D HIS DPY HEADER GO?
	MOVE DAT,CURPP(J)	;GET POINTER TO CURRENT PP
	MOVE TAC,DPHPOS(DAT)	;GET NEGATIVE OF AMT OF ROOM LEFT ON LINE
	ADD TAC,LNLNGT(DAT)	;ADD LENGTH OF LINE
TTYSTO:	MOVEI UUO,(UUO)		;JUST LEAVE ADDRESS IN UUO
	CAIL UUO,20		;IS ADDRESS LEGAL? (IS IT AN AC?)
	CAILE UUO,JOBPFI	;NOT AN AC. IS IT IN PROTECTED PART?
	JRST .+2		;NO, LEGAL ADDRESS
	JRST UADERR		;USER WOULD NEVER HAVE SEEN RESULT--ERROR
	XCTR XW,[MOVEM TAC,(UUO)] ;STORE RESULT IN USER'S CORE
	POPJ P,

TTYSTN:	PUSHJ P,TTYSTO		;Store this value in current word
	AOJA UUO,CPOPJ		;Prepare to store next value in next user word

GTLNCH:	SKIPA TAC,LINE		;GET LINE CHARACTERISTICS
GETHP2:	LDB TAC,PHPOS		;GET CURRENT HORIZONTAL POSITION
	JRST TTYSTO

GETWID:	SKIPE J,LETAB(LINE)	;GET DPY HEADER IF ANY
	SKIPA TAC,DPYWID(J)	;GET DISPLAY'S LINE LENGTH
	LDB TAC,PTTYWD		;GET TTY WIDTH
	JRST TTYSTO

LINSET:	TLOA LINE,(UUO)		;TURN ON BITS REQUESTED
LINCLE:	TLZ LINE,(UUO)		;TURN OFF BITS REQUESTED
	XCTR XW,[MOVEM LINE,JOBTM1] ;STORE IN USER CORE FOR SETLIN
	MOVEI UUO,JOBTM1	;TELL SETLIN WHERE TO FIND CHARACTERISTICS
	JRST SETLIN

STIOS:	TDOA UUO,DEVIOS(DDB)	;TURN ON SPECIFIED IOS BITS
CLIOS:	ANDCA UUO,DEVIOS(DDB)	;TURN OFF SPECIFIED IOS BITS
	MOVE DSER,DEVSER(DDB)	;SET UP POINTER TO DISPATCH TABLE
	JRST SETIOS

GTIOS:	MOVE TAC,DEVIOS(DDB)	;GIVE USER HIS IOS SETTINGS
	JRST TTYSTO

;BIT 35 OF COMMAND WORD MEANS TURN ON DM128.
;BIT 34 OF COMMAND WORD MEANS TURN OFF DM128.
;BIT 33 TURNS ON NOBOLD
;BIT 32 TURNS OFF NOBOLD
;BIT 31 TURNS ON NO177
;BIT 30 TURNS OFF NO177
;BIT 29 TURNS ON DM3025
;BIT 28 TURNS OFF DM3025
;BIT 27 TURNS ON DMWAITS
;BIT 26 TURNS OFF DMWAITS
;;;BIT 25 TURNS ON LEFTAR
;;;BIT 24 TURNS OFF LEFTAR
DMDIDL:	SKIPE AC2,LETAB(LINE)	;IS HE AN ACTIVE DM?
	TLNN LINE,DMLIN
	POPJ P,			;NO
	MOVSI AC1,DM128
	TRNE UUO,1
	IORM AC1,DPYDES(LINE)	;TURN ON DM128
	TRNE UUO,2
	ANDCAM AC1,DPYDES(LINE)	;TURN OFF DM128
	MOVSI AC3,NOBOLD
	TRNE UUO,4
	IORM AC3,DPYDES(LINE)	;TURN ON NOBOLD (HARDWARE NOT INTERCHANGED)
	TRNE UUO,10
	ANDCAM AC3,DPYDES(LINE)	;TURN OFF NOBOLD (HARDWARE IMPROVED)
	MOVSI TAC,NO177
	TRNE UUO,20
	IORM TAC,DPYDES(LINE)	;TURN ON NO177 CAUSE 177 DOESN'T PRINT
	TRNE UUO,40
	ANDCAM TAC,DPYDES(LINE)	;TURN OFF NO177 CAUSE 177 DOES PRINT
	MOVSI TEM,DM3025
	TRNE UUO,100
	IORM TEM,DPYDES(LINE)	;TURN ON DM3025
	TRNE UUO,200
	ANDCAM TEM,DPYDES(LINE)	;TURN OFF DM3025
	MOVSI TEM,DMWAITS
	TRNE UUO,400
	IORM TEM,DPYDES(LINE)	;TURN ON DMWAITS
	TRNE UUO,1000
	ANDCAM TEM,DPYDES(LINE)	;TURN OFF DMWAITS
;	MOVSI TEM,LEFTAR
;	TRNE UUO,2000
;	IORM TEM,DPYDES(LINE)	;TURN ON LEFTAR
;	TRNE UUO,4000
;	ANDCAM TEM,DPYDES(LINE)	;TURN OFF LEFTAR
	POPJ P,

GDPHGT:	SKIPN J,LETAB(LINE)
	JRST MINUS1		;IF NOT A DISPLAY, RETURN -1
	MOVE TAC,DPYHGT(J)	;GET NUMBER OF LINES ON DISPLAY SCREEN
	JRST TTYSTO

SDPHGT:	TLNE LINE,DMLIN		;THIS FUNCTION ONLY WORKS FOR DMs
	SKIPN AC2,LETAB(LINE)
	POPJ P,
	HRREI TAC,(UUO)
	OFFSCN
	JRST SETDP3		;USE TTY DM n CODE TO SET THE HEIGHT

SDPWID:	TLNE LINE,DMLIN		;THIS FUNCTION ONLY WORKS FOR DMs
	SKIPN AC2,LETAB(LINE)
	POPJ P,
	HRREI AC3,(UUO)		;USE TTY DM n m CODE TO DO THE WORK
	JRST SDMWID		;I THINK WE CAN DO THIS OK WITH SCANNER ON

GETRSP:	LDB TAC,[DDQREQ+LINE,,LSTESC] ;GET RESPONSIBILITY FIELD
	CAIN TAC,APLINE
	JRST MINUS1		;NO ONE IS RESPONSIBLE
	JRST TTYSTO

GETHID:	LDB TAC,[PHIDDN+LINE,,LSTESC] ;GET HIDDEN BIT
	JRST TTYSTO

GETDMF:	SKIPE J,LETAB(LINE)
	TLNN LINE,DMLIN
	JRST MINUS1		;RETURN MINUS ONE IF NOT A DM OR NO DPY HDR
	HRRZ TAC,DMFLAG(J)	;GET THE DM STATE FLAGS
	JRST TTYSTO

;ROUTINE TO RETURN LINE CHARACTERISTICS AND LINE NUMBER OF A TTY'S CONTROLLING DPY
GTCDPY:	TLNE LINE,DDDLIN!DMLIN!DISLIN ;IS THIS A DISPLAY?
	JRST GTLNCH		;YES, RETURN LINE NUMBER AND BITS
	TLNE LINE,PTYLIN	;Non-PTYs and
	TLNE LINE,IMPBIT	; ARPA PTYs are
	JRST MINUS1		;NOT CONTROLLED BY A DPY, RETURN -1
	MOVE LINE,PTYJOB-PTYL0(LINE) ;GET OWNING JOB OF PTY
	MOVE LINE,JBTLIN(LINE)	;GET NUMBER OF JOB'S TTY
	CAMN LINE,[-1]
	JRST MINUS1		;DETACHED, NOT CONTROLLED BY DPY
	HLL LINE,LINTAB(LINE)	;GET LINE CHARACTERISTICS
	JRST GTCDPY		;NOW CHECK THIS LINE

GETGAG:	LDB TAC,GAGBPT		;GET TTY GAG BIT
	JRST TTYSTO

SETGAG:	DPB UUO,GAGBPT		;SET TTY GAG BIT
	POPJ P,

GTTGAG:	LDB TAC,GAGTPT		;GET TEMPORARY GAG BIT
	JRST TTYSTO

STTGAG:	DPB UUO,GAGTPT		;SET TEMPORARY GAG BIT
	POPJ P,

GETCVT:	LDB TAC,CVTBPT		;GET TTY CVT BIT
	JRST TTYSTO

SETCVT:	DPB UUO,CVTBPT		;SET TTY CVT BIT
	POPJ P,

GETPSW:	LDB TAC,PSWBPT		;GET TTY PSW BIT
	JRST TTYSTO

SETPSW:	DPB UUO,PSWBPT		;SET TTY PSW BIT
	POPJ P,

GETGLA:	LDB TAC,GLABPT		;GET TTY GLASS BIT
	JRST TTYSTO

SETGLA:	DPB UUO,GLABPT		;SET TTY GLASS BIT
	POPJ P,

GETDEL:	LDB TAC,DELBPT		;GET TTY NO DELETE BIT
	JRST TTYSTO

SETDEL:	DPB UUO,DELBPT		;SET TTY NO DELETE BIT
	POPJ P,

SETIMP:	MOVSI TAC,IMPBIT
	TLNE LINE,PTYLIN	;GOTTA BE A PTY TO BE AN IMP TTY
	IORM TAC,LINTAB(LINE)	;MAKE US AN IMP
	POPJ P,

SETDM:	TLNE LINE,DISLIN!DDDLIN	;Fixed display types can't be DM-type displays
	POPJ P,
	MOVEI AC1,0		;Index of plain DM display type
	PUSH P,[0]		;Use default number of rows
	PUSH P,[0]		;Use default number of cols
	JRST SETDPD		;Make this line a display

;Set display type from info in block pointed to by RH of function wd.
;0/sixbit display type name
;1/display height
;2/display width
;3/padding char
;4/padding baud rate
;5/tab flag in low-order bit (bit on if dpy has tabs)
;6/EDITKY LH bits mask,,EDITKY LH bits
;7/DPYDES LH bits mask,,DPYDES LH bits
;Any zero word in the block is ignored (with the default used instead).
;To force word 4,5 to be non-zero, turn on the sign bit.
;Only the right half of each word is actually used to set the given value.
SETDPT:	TLNE LINE,DISLIN!DDDLIN	;Fixed display types can't be DM-type displays
	POPJ P,
	XCTR XR,[MOVE AC1,(UUO)] ;Get name of display type
	MOVSI AC2,-NDTYPS	;Aobjn pointer to table of display type names
SETDPL:	CAME AC1,DTNAME(AC2)
	AOBJN AC2,SETDPL
	JUMPGE AC2,CPOPJ	;Jump if no such display type name
	HRRZ AC1,AC2		;get dpy type index in AC1
	OFFSCN			;Suppress output while we diddle parameters
	PUSHJ P,DSETUP		;Set default parameters, get DPYDES value in AC1
	XCTR XR,[HRRZ AC2,2(UUO)] ;Get dpy width
	PUSH P,AC2		  ;Stack it for SETDPU
	XCTR XR,[HRRZ AC2,1(UUO)] ;Get dpy height
	PUSH P,AC2		  ;Stack it for SETDPU
	XCTR XR,[MOVE AC2,3(UUO)] ;Get padding char
	TRNE AC2,377		  ;Can't be null (would confuse pty service)
	DPB AC2,[POINT 9,PADCNT(LINE),35] ;Store padding char
	XCTR XR,[SKIPN AC2,4(UUO)] ;Get padding baud rate
	JRST SETDPP		   ;None
	MOVEI AC2,(AC2)		   ;Flush flag (flag needed for 0 baud spec)
	IDIVI AC2,BDUNIT	   ;Normalize for storing
	DPB AC2,[POINT 9,PADCNT(LINE),26] ;Store padding baud rate
SETDPP:	XCTR XR,[SKIPN AC2,5(UUO)] ;Get tabs flag
	JRST SETDPB		;None, skip tab stuff
	MOVSI AC3,TBXPND	;Bit to set or clear
	ANDCAM AC3,LINTAB(LINE) ;Assume has tabs
	TRNN AC2,1		;Low order bit of word on means has tabs
	IORM AC3,LINTAB(LINE)	;No tabs, make them get expanded
SETDPB:	XCTR XR,[SKIPN AC2,6(UUO)] ;Get no edit mode
	JRST SETDPN		;Nothing specified, skip no-edit stuff
	MOVSI AC3,NEUMSK	;No-edit flag bits the user can diddle
	AND AC3,AC2		;Mask the bits user wants diddled
	ANDCAM AC3,EDITKY(LINE)	;Turn off bits user is specifying
	HRLZ AC2,AC2		;Get new values of bits in LH
	MOVSI AC3,NEUMSK	;Mask off un-diddleable bits
	AND AC3,AC2		;Keep only diddleable bits
	IORM AC3,EDITKY(LINE)	;Turn on requested bits
SETDPN:	XCTR XR,[SKIPE AC2,7(UUO)] ;Get dpy type bits, skip if none
	PUSHJ P,DPMSKM		;combine old DPYDES bits in AC1 w/new bits in AC2
	JRST SETDPU		;Go set display type from descriptor in AC1

;Combine old DPYDES bits in LH of AC1 with bits whose mask is in LH of AC2
;and whose values are in RH of AC2.  Return combined value in LH of AC1.
DPMSKM:	MOVSI AC3,DPUMSK	;DPYDES bits the user can diddle
	AND AC3,AC2		;Mask the bits user wants diddled
	ANDCAM AC3,AC1		;Turn off bits user is specifying
	HRLZ AC2,AC2		;Get new values of bits in LH
	MOVSI AC3,DPUMSK	;Mask off un-diddleable bits
	AND AC3,AC2		;Just the new bits
	IORM AC3,AC1		;Turn on requested bits
	POPJ P,

;Return display info in block:
;0/sixbit display type name
;1/display height
;2/display width
;3/padding char
;4/padding baud rate
;5/tab flag in low-order bit (bit on if dpy has tabs)
;6/EDITKY LH bits mask,,EDITKY LH bits
;7/DPYDES LH bits mask,,DPYDES LH bits
;The sign bits of words 4,5 may be on, in order to make a set-dpy-type
;TTYSET function (see above) work when given back the returned block from here.
;The LH of word 6 will be returned as -1 for the same purpose.
GETDPT:	SKIPE AC2,LETAB(LINE)
	SKIPN AC1,DPYDES(LINE)	;Get pointer to dpy descriptor table
	JRST MINUS1		;Not a display
	MOVE TAC,DPYNAM(LINE)	;Get official name of this display type
	TLNE LINE,DDDLIN	;DDs don't use a table
	MOVSI TAC,'DD '
	TLNE LINE,DISLIN	;Neither do IIIs
	MOVSI TAC,'III'
	PUSHJ P,TTYSTN		;Return name
	MOVE TAC,DPYHGT(AC2)	;Get dpy height
	PUSHJ P,TTYSTN		;Return it
	MOVE TAC,DPYWID(AC2)	;Get width
	PUSHJ P,TTYSTN		;Return it
	LDB TAC,[POINT 9,PADCNT(LINE),35] ;Get pad char
	PUSHJ P,TTYSTN		;Return it
	LDB TAC,[POINT 9,PADCNT(LINE),26] ;Get pad baud rate
	IMULI TAC,BDUNIT	;Unnormalize, return real baud count
	TLO TAC,400000		;Force returned value to be non-zero
	PUSHJ P,TTYSTN		;Return it
	MOVEI TAC,1		;Assume terminal has tabs
	MOVSI AC3,TBXPND
	TDNE AC3,LINTAB(LINE)	;Skip if not expanding tabs for this terminal
	MOVSI TAC,400000	;No tabs for this terminal
	PUSHJ P,TTYSTN		;Return tab flag
	HLRO TAC,EDITKY(LINE)	;Get no-edit bits and full mask in LH
	PUSHJ P,TTYSTN		;Return bits
	HLRO TAC,DPYDES(LINE)	;Get dpy type bits and full mask in LH
	JRST TTYSTN		;Return bits

SETSPD:	HRRZ TAC,LINBIT(LINE)	;IS THIS A DCA PORT?
	JUMPE TAC,CPOPJ		;NO, DO NOTHING
	MOVEI LINE,-400000(TAC)	;YES, GET PORT NUMBER INTO LINE
	MOVEI CHR,(UUO)		;GET SPEED INDEX
	JRST DCASPX		;go set the speed (may skip)
repeat 0,<
	MOVE AC1,DCATAB(LINE)	;GET FLAGS
	TRNE AC1,DCAPRM		;Is this a no-modem line? If so, allow any speed.
	JRST SPDCM3		;Set whatever speed desired (skip on error, ign)
	TRNN AC1,DCABDB		;IS THIS A BAUD DETECT LINE?
	POPJ P,			;NO, DO NOTHING
IFN FTF2,<
PRINTX The F2 has no 110 baud rate right now.
>;IFN FTF2
IFE FTF2,<
	CAIE CHR,LS110		;ONLY ALLOW LEGAL SPEEDS
>;IFE FTF2
	CAIN CHR,LS150
	JRST DCASPS		;TELL DCASER TO SET THE SPEED
	CAIN CHR,LS300
	JRST DCASPS
	POPJ P,			;NO-OP IF SPEED IS ILLEGAL
>;repeat 0

GETWHO:	SKIPN TAC,LETAB(LINE)	;GOTTA BE ACTIVE DISPLAY TO HAVE WHOLINE
	JRST MINUS1		;NO DISPLAY
	HRRZ TAC,WHOTAB(TAC)	;GET JOB NUMBER (MAY BE ZERO IF NO WHOLINE)
	JRST TTYSTO		;RETURN IT

;This function sets the job to be displayed on the wholine, but it doesn't
;force the wholine out quickly (on DMs/DDs) like ESC n W does (use TTYSET '004).
SETWHO:	SKIPN TAC,LETAB(LINE)	;GOTTA BE ACTIVE DISPLAY TO HAVE WHOLINE
	POPJ P,			;NO DISPLAY
	HRROM UUO,WHOTAB(TAC)	;YES, STORE JOB #.  ALSO PUT -1 IN INCR TIME SLOT.
	SETZM WHORUN(TAC)	;CLEAR TIME TO UPDATE RUNTIME NEXT
	POPJ P,

GETPAD:	TLNE LINE,DMLIN		;ONLY APPLIES IF DM
	SKIPN LETAB(LINE)	;WITH A DPY HDR
	JRST MINUS1		;NOT CURRENTLY A DM
	LDB TAC,[POINT 9,PADCNT(LINE),35] ;GET PADDING CHAR
	JRST TTYSTO

SETPAD:	TLNE LINE,DMLIN		;ONLY VALID IF DM
	SKIPN LETAB(LINE)	;WITH DPY HDR
	POPJ P,			;FORGET IT
	MOVEI AC2,(UUO)		;Get argument of pad char
	JRST TTPAD3		;Go store pad char if legal value given

GETBAU:	TLNE LINE,DMLIN		;GOTTA BE DM
	SKIPN LETAB(LINE)	;WITH DPY HDR
	JRST MINUS1		;NOT CURRENTLY A DM
	LDB TAC,DMBAUD		;GET BAUD RATE
	IMULI TAC,BDUNIT	;NORMALIZE IT TO REAL BAUD VALUE
	JRST TTYSTO		;RETURN VALUE TO USER

SETBAU:	TLNE LINE,DMLIN		;GOTTA BE DM
	SKIPN LETAB(LINE)	;WITH DPY HDR
	POPJ P,			;FORGET IT
	MOVEI TAC,(UUO)		;GET BAUD RATE
	JRST TTBAU2		;UNNORMALIZE IT AND STORE VALUE

GTNESC:	SKIPN AC2,LETAB(LINE)	;GET NOEDIT MODE ESCAPE CHARS
	JRST MINUS1		;RETURN -1 IF NOT A NOEDIT DPY
	SKIPL EDITKY(LINE)
	JRST GTNES2		;Different way for edit-key dpy
	MOVEI TAC,0		;ACCUMULATE BITS IN TAC
	HRLI AC2,-VECTNM	;AOBJN POINTER TO VECTOR WORDS
	MOVEI TAC1,1		;BIT TO TURN ON
GTNES1:	SKIPGE NEVECT(AC2)	;IS THIS CHAR AN ESCAPE?
	IOR TAC,TAC1		;YES, FLAG IT
	LSH TAC1,1		;PREPARE NEXT BIT
	AOBJN AC2,GTNES1
	JRST TTYSTO

GTNES2:	LDB CHR,EKESCC		;Get EDIT-KEY esc char
	LDB CHR,NECVBP		;GET VECTOR INDEX
	JUMPE CHR,MINUS1	;Can't happen: esc isn't a legal esc
	MOVEI TAC,1
	LSH TAC,-1(CHR)		;Set the right bit
	JRST TTYSTO

;Set noedit mode escape char, may skip return.
STNESC:	SKIPN AC2,LETAB(LINE)	;SET A NOEDIT MODE ESCAPE CHAR
	POPJ P,			;NO-OP IF NOT display
	MOVEI CHR,(UUO)		;CHAR INTO CHR
	JRST TTNES0		;CALL TTY SETESC COMMAND CODE, MAY SKIP RETURN

GTNEDT:	SKIPE AC2,LETAB(LINE)	;GET NOEDIT BIT
	SKIPL EDITKY(LINE)
	TDZA TAC,TAC		;NOT NOEDIT
	MOVEI TAC,1		;NOEDIT
	JRST TTYSTO

;Set noedit bit, may skip return.
STNEDT:	HRRZS (P)		;SET NOEDIT BIT
	TRNN UUO,1		;PREPARE TO SIMULATE TTY COMMAND
	HRROS (P)		;BIT ON IS POSITIVE (SETTING) SENSE
	JRST NOEDCM		;CALL TTY NO EDIT CMD ROUTINE, MAY SKIP RETURN

GTHTOG:	SKIPE AC1,LETAB(LINE)	;GET NOEDIT MODE HTOGGLE MODE
	SKIPL EDITKY(LINE)
	JRST MINUS1		;Not NOEDIT dpy
	LDB TAC,NETBPT		;HTOGGL BIT
	JRST TTYSTO

STHTOG:	SKIPE AC2,LETAB(LINE)	;SET HTOGGL BIT
	SKIPL EDITKY(LINE)	;ONLY IF ALREADY NOEDIT MODE
	POPJ P,
	MOVSI TAC,NEHTFL	;THE BIT
	TRNN UUO,1
	ANDCAM TAC,EDITKY(LINE)	;CLEAR IT
	TRNE UUO,1
	IORM TAC,EDITKY(LINE)	;SET IT
	POPJ P,

GTQMOD:	SKIPE AC1,LETAB(LINE)	;GET NOEDIT QUOTE MODE
	SKIPL EDITKY(LINE)
	JRST MINUS1		;Note NOEDIT dpy
	LDB TAC,NEMBPT		;ALLQUOTE,QUOTE,META,CTRL
	JRST TTYSTO

STQMOD:	SKIPE AC1,LETAB(LINE)	;SET NOEDIT QUOTE MODE
	SKIPL EDITKY(LINE)	;ONLY IF ALREADY NOEDIT MODE
	POPJ P,
	DPB UUO,NEMBPT		;ALLQUOTE,QUOTE,META,CTRL
	POPJ P,

GTLNBT:	MOVE TAC,LINBIT(LINE)	;Return default bits and DCA port and bit
	JRST TTYSTO

;Return bit indicating if TTY EXISTs.  Low-order bit returned on if EXISTs.
;Returns 1 if EXISTS, 0 if NO EXIST or not on DCA, -1 if illegal TTY number.
GTEXST:	HRRZ AC1,LINBIT(TAC1)	;See if is on DCA
	MOVEI TAC,0		;Assume non-ex
	TRZN AC1,400000		;Skip if on DCA
	JRST TTYSTO		;Non-ex TTY (not on DCA → non ex), return 0
	MOVE AC2,DCATAB(AC1)	;Get status for TTY's port
	TRNN AC2,DCADWN		;Skip if up
	MOVEI TAC,1		;Return 1 for up
	JRST TTYSTO

;Do TTYSET equivalent of TTY [NO] EXIST.  Low-order bit on means EXIST.
;Note that speed of DCA port is reset to default, as in TTY EXIST command.
STEXST:	HRRZ TAC,LINBIT(TAC1)	;Get DCA port number, if any
	JUMPE TAC,CPOPJ		;Jump if not on DCA, do nothing
	TRNN UUO,1		;Skip if want TTY EXIST equivalent
	JRST DCADET		;Wants TTY NO EXIST -- mark this TTY down
	PUSH P,TAC		;Preserve port number (+400000)
	PUSHJ P,DCAATT		;Mark this TTY up
	POP P,TAC
	PUSHJ P,DCASPR		;And set speed to default
	 POPJ P,		;Should never lose
	POPJ P,

;Get DPYDES bits, whether display or non-display.
GTDPDS:	MOVS TAC,DPYDES(LINE)	;get the dpy descriptor bits in RH
	HRLI TAC,DPUMSK		;get mask of user-settable bits in LH
	JRST TTYSTO		;return 'em

;Diddle DPYDES bits, whether display or non-display.
;RH of function word points to: DPYDES LH bits mask,,DPYDES LH bits
STDPDS:	XCTR XR,[MOVE AC2,(UUO)] ;Get mask,,bits
	OFFSCN
	MOVE AC1,DPYDES(LINE)	;get old bits
	PUSHJ P,DPMSKM		;combine old DPYDES bits in AC1 w/new bits in AC2
	MOVEM AC1,DPYDES(LINE)	;store new bits
	JRST SCNONJ
