COMMENT ⊗   VALID 00084 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00010 00002	FILNAM FILEXT FILDAT FILLEN DMPEND MODWRD DEVWRD HEDWRD DMPWRD NEWCOR INCWRD COMWRD CHRWRD
C00012 00003	SGDVOK SGSETB SGSET SGSET0 SGSETA SGSETC SGSET3 SGSETD SGPPN SGSET1
C00018 00004	SSAVJB SAVJOB SAVJB1 SAVEUP
C00021 00005	GETJOB GETJ1 GETNUP NOFILE
C00023 00006	RUNJOB MRDJB2 NOSTRT MRDJOB MRDUSR MRDRLN MC MRDPRG MRDBG MRDB1 MRDB3 MRDB4 MRDLEN
C00028 00007	SG1 SGCOR1 SGCOR SG2 SGCOR2 SG3 SGERRA SGERR1
C00033 00008	SGREL SGREL1 NOROM0 NOROOM NOROM1
C00035 00009	GETJB GETJB1 GETJB3 GETJB2
C00039 00010	GETJ7 GETJ8 GETJ5
C00042 00011	GETJ5B GETERR GETERA GETDN2 GETDON GETDN1
C00046 00012	SSAVJA SAVJB SAVJBB SAVJ0 SAVJ1 SAVJ3 SAVJ2 SGTERA SGTERR SAV4
C00052 00013	ACCESS ACCES1 ACCES2
C00054 00014	ESTSEG ESTSE1 ESTSE2
C00057 00015	LINKSEG CONSEG DEFSE3 SEGFIN LNKCHK DEFSE1 DEFSE2 MAKESEG MAKSE2
C00063 00016	KILSEG KILSE6 KILSE3 KILSE7 KILSE5 KILSE4 KILSE2 KILSE1 NZERR KILSE9
C00067 00017	ZERO5 ZEROSEG
C00069 00018	FLUSHSEG FLUSH1 FLUSH3 FLUSH6 FLUSH4 FLUSH5 FLUSH2 FLUSH7 FLUSH8 FLUSH9 DSFLUSH DSFL1
C00073 00019	UAPPLY UAPP1 UAPP2 UAPP3
C00075 00020	CTEXT CTEXT1 CTEX1 CTEX CTEXA CTXCNC GETLCCHR GETLC1
C00078 00021	SKIPSJ SKIPS SKIPS1 SKIPSA SKIPSB SKIPS2 SKIPS3 TYCRLF CRLF CONMES CON0
C00081 00022	COMEND COMERP COMERA COMERR COMERL COMER1 ERRMES
C00084 00023	INLMES PRQM PRSPC NOTENF PRCRCC PRCNTC PRPER
C00086 00024	DEASG DEASTY DEA1 KILALL KILAL1 KILAL2
C00089 00025	DECIN1 DECIN OCTINS OCTIN ANYRIN OCT0
C00092 00026	PJPGNO PJPG1 PJPG2 NBRPPN
C00096 00027	ADRTST APRILM APRIL2 APRIL1 APRJRS APRNXM PDLAPR APRCNS APRSCD APRPBL UERROR CERROR
C00101 00028	PIERR1 PIERR3 P2ADCK P2ADC1 P2ADC2
C00105 00029	NCUBG2 UUOER4 UUOERR UUOER3 UUOER1 UUOE2A UUOER2
C00110 00030	ILLINS ILLIN1 ILLIN1 HALT ILLTAB ILLTLN $DSUB $DADD $DADD1 $DMUL $DMUL1 $N1FLG $CRY1 $CRY2 $DFMP $DFMP1 $DFMP2 $DFMP3 $EXPN $SWITCH $ARG $DFSB $DFAD $DFSB1 $DFAD1 $DFAD2 $DFAD4 $DFAD3 $DFAD5 $DFAD6 $DFA15 $DFAD7 $DFAD9 $DFA13 $DFAD8 $DFA14 $DFA10 $DFA11 $DFA12 $DMOVEM $KIFIX $FIXR $FIXR0 $FIXR1 $FLTR $FLTR3 $FLTR4 $FLTR2 $FLTR6 $FLTR7 $FLTR5 $FLTR1 $DFDV $DFDV1 $DFDV3 $DFDV5 $DFDV4 $DFDV6 $DFDV2 $DFDV7
C00134 00031	SPWMES SPWIPC SPWNXM SPWPDL SPWCNS SPWTMX SPWIUU SPWMS1
C00136 00032	ADRERR UADER1 UADRER UADERR ILLINP BTLERR ILLOUT ILLMOD IOIERR DEVHNG BADDIR DEVEXC
C00140 00033	HNGSTP
C00141 00034	HNGMES
C00142 00035	ERRPTU ERRDEV ERRPNT ERRZZ2 ERRZZP NAMPPN TTYCTY
C00146 00036	UUOMES UUOPCP UUOMEP
C00148 00037	PCPNT EXCALP PCSTOP
C00150 00038	XMODE UMODE PCP PCP0 OCTDIS OCTPND OCTPNT ANYRDX OCTP1 SRAD10 RADX10
C00153 00039	ERNAM PRNAME PRPPN
C00155 00040	DISINIT DISOUT DISOU1 DISOUX DISOX1 DISOX2 DISBEG DISEND
C00159 00041	DISFLUSH DISFL3 DISFL1 DISFLX REFLUS
C00163 00042	 CTYDMR DISTYO DISTY1 DISTYH DISTYC DISTYF DISTYL DISTY3 DISTY2 DISUSJ DISUSR DISGST DISUS2 DISUS0 TTTPPJ
C00173 00043	 DISMES DISME1 DISTAC DISTC1 DISCRLF DISTAB DISJOB DISJB1 DISJAR
C00176 00044	DISERR ERRTAB ERRLEN DISSTT DISSTR ERRSTR ERRST1 DIS8TX DIS8T1
C00178 00045	 DISLOT DISLOC ERRLOC DISLC1 ERRADR DISADR DISAD1 DISAD2 DISAD3 DISOCT ERROCT DSOCT2 DISOHS ERROHS DISOCH ERROCH DSOCH1 DISDCP ERRDCP DISDEC ERRDEC DISDC1 DISNUM DISHE2 ERRHE2 ERRHET DISIPA ERRIPA
C00183 00046	 ERRSIX DISSIX DISFIL DISFI1 DISPPN DISIXS DSIXS1 DSIXS3
C00186 00047	CTYTYO CTYTY3 TABWAT
C00188 00048	DISDATE DISDA1 DISTIM DISTI2 DIS2DG NCUEN2
C00191 00049	ADVBFE ADVBE1 ADVBE2
C00194 00050	PRSET PRSET1 ADRCK
C00197 00051	ADVBFF ADVBF1 ADVXIT ADVIBX ADVIB1 ADVIB2 ADVIB3 ADVOBX ADVOB1
C00203 00052	UUOACK UADCK1 UADRCK UADCK2 UADCK3
C00205 00053	COMCHK COMCK0 COMCK1 COMCK2 COMCKE
C00209 00054	DMPTCH DMPCMD
C00212 00055	ASSASG ASSAS3 ASSAS9 ASSASJ ASSAS4 ASSAS2 ASSAS1 ASSAS0
C00216 00056	FNDDDB DEVSRC DEVLG DEVLP0 DEV0 DEVPHY DEVLP1 DEVLP2 DEVLP3
C00220 00057
C00222 00058	BUFCLC BUFCLM BUFC2 BUFC1
C00225 00059	BUFCLR CLRBYT DEVCR DEVSTU
C00228 00060	IOWAIT IORELS IOALL IOALL1 IOALL2 IOALLP IOALP1 IOALP2 IOALLW IOALLX IOALLY IOALLR IOALR1 IOALR2 IOALR3
C00234 00061	IOKILL CLRUSR
C00236 00062	ORACT SETACT CLRACT STOIOS ORACT1
C00237 00063	DEVCHK DEVCK0 DEVCKA DEVCK3 DEVCK1 DEVKSW DEVKSL DEVKS3 DEVKS2 DEVKSX DEVTTL DEVTER DEVTE2 DEVNOT DEVCK6 IRMAXX DEVCK9 CTYIRM DEVCK7 DEVCK8 DEVCK4
C00252 00064	 IOSETC ITMCNT ITMCN1
C00256 00065	SETIOS SETMOD
C00257 00066	PHOLD HOLD MSTOP ESTOP ESTP3B ESTP3C ESTOP3 ESTOP2 ESTOP4 ESTOP5
C00263 00067	STOP1 SETSTP SETSTL SETST1 SETST2 STOP1A
C00267 00068	DLYCOM DLYCO2 NOCORQ NOCOR1 MONJOB
C00270 00069	MONSTR
C00271 00070	USTART USTRT1 MSTART MSTAR1 MSTAR2
C00275 00071	SETRUN SETR1 REQUE SETR2
C00277 00072	SETSLP WAKE
C00279 00073	GETDCDT GETWT ELFWAIT MTWAIT DVWAIT DVWAT1 SETSTT
C00284 00074	STTIOD SETIOD SETID0 SETID1 NULTST NULTS1
C00287 00075	WSCHED WSCHDA WSCHD1 WSCHD2 STOP2
C00289 00076	WAIT1
C00291 00077	WSYNC WSYN.1 WSYN.2 WSYN.3 WSYN.4 WSYN.5 WSYN.6
C00295 00078	BATCON - INITIATE PHANTOM PROCESSES  BATCLK BATLOP BAT0 BAT1 BAT2 BAT2A BAT3 BAT3C BAT3B
C00299 00079	 GETBT0 GETBAT GETBA7 GETBA6 GETBA5 GETBA4 GETBTX GETBT1 GETBT2 GETBT3 BATSW DELBAT DELB1 BATRS DELBTT BATTT BATSWP FIREUP FIRSER FIREU1 FIREU2
C00307 00080	STAPUT STAPTT STACLK STAPOK STAPOJ STAPDO GLUSTT NAMSTT NAMCLK NAMOK SEGSTT
C00310 00081	FBI FBINEW FBIXIT STPRV2
C00313 00082	POPTRP FATTRP BUGTRP FATTR1 FATTR2
C00316 00083	LOGIT LOGIT0 LOGIT1 LOGIT4 LOGIT2 LOGIT5 LOGIT6 LOGKIL LOGLUZ OUTPPN
C00324 00084	Record event sequence in debugging buffer  DEBWD
C00325 ENDMK
C⊗;
;FILNAM FILEXT FILDAT FILLEN DMPEND MODWRD DEVWRD HEDWRD DMPWRD NEWCOR INCWRD COMWRD CHRWRD

BEGIN APRSER ↔ SUBTTL	SAVGET	4 AUG 67

	INTERN	DISMES,DISTYO,DISCRLF,DISTAB,DISJOB,DISOCT,DISLOC,DISOCH
	INTERN	DISSIX,DISTIM,DDTCALL,DDTTYPE,FSGETU,DISFLUSH,DISUSR,DISGST
	INTERN	WSCHED,WSYNC

;HISYS			;ASSEMBLE IN HIGH CORE

;SPECIAL LOCATION IN USER JOB DATA AREA FOR STORING ARGUMENTS
;USED IN UUO CALLS TO THE MONITOR

;FOR LOOKUP UUO
FILNAM←←0		;FILE NAME
FILEXT←←FILNAM+1	;FILE EXTENSION
FILDAT←←FILNAM+2	;DATE WRITTEN
FILLEN←←FILNAM+3	;LH=-LENGTH,RH=FIRST LOC-1 DUMPED ON ENTER
			;PROJECT PROGRAMMER ON LOOKUP

DMPEND←←FILLEN+1	;LAST WORD OF DUMP COMMAND LIST=0

;FOR OPEN UUO
MODWRD←←5		;IOS MODE WORD FOR OPEN UUO
DEVWRD←←MODWRD+1	;DEVICE NAME
HEDWRD←←MODWRD+2	;INPUT AND OUTPUT BUFFER HEADER ADDRESSES


DMPWRD←←11	;DUMP WORD FOR SAVE COMMAND
NEWCOR←←12	;NEW CORE ASSIGNMENT FOR RUN AS SPECIFIED BY THIRD
		;ARGUMENT TO PREVIOUS SAVE.
↑INCWRD←←13	;STARTING INCREMENT STORAGE FOR MONITOR JOB.

COMWRD←←17	;IN WHICH WE PASS THE SIXBIT COMMAND TO THE PROGRAM
CHRWRD←←16	;IN WHICH WE PASS THE ASCII DELIMITER TO THE PROGRAM
;SGDVOK SGSETB SGSET SGSET0 SGSETA SGSETC SGSET3 SGSETD SGPPN SGSET1

;COMMAND STRING ARGUMENTS FOR SAVE,GET,RUN AND R
;COMMANDS AND STORE THEM IN JOB DATA AREA WHICH MUST BE IN CORE
;WHEN SGSET IS CALLED FROM COMMAND DECODER
;WE MUST REFERENCE USER CORE BY XCTR, NOT BY ABSOLUTE ADDRESS, THEREFORE,
;THE MAP MUST BE SETUP FOR THIS USER BEFORE WE GET HERE.
;CALL:	MOVE TAC,INPUT BYTE POINTER
;	MOVE TAC1,SIXBIT DEVICE NAME (FIRST ARGUMENT TO RUN, GET, ETC. COMMAND)
;	MOVE TEM,Terminating character that follows first arg to command
;	MOVE DAT,OUTPUT BYTE POINTER
;	MOVE IOS,ADR. OF MONITOR JOB(SAVJOB,GETJOB,RUNJOB)
;	PUSHJ P,SGSET
;ALTERNATIVELY: SET AC2 TO EXPLICIT PPN OF FILE AND ENTER BY:  PUSHJ P,SGSET0

SGDVOK:	PUSH P,TAC			;CHECK TO SEE IF ARG IS LEGAL SAVEGET DEV
	PUSH P,IOS
	PUSH P,DAT
	PUSH P,DDB
	MOVE TAC,TAC1
	PUSHJ P,DEVSRC			;IS THERE SUCH A DEVICE
	JRST SGSETB			;NOT A LEGAL DEVICE. ASSUME IT WAS FILENAME
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK!DVDTA!DVMTA	;ONLY LEGAL DEVICES FOR SAVE GET
	AOS -4(P)
SGSETB:	POP P,DDB
	POP P,DAT
	POP P,IOS
	JRST TPOPJ

;HERE AT CLOCK LEVEL FROM COMMAND DECODER
SGSET:	MOVEI AC2,0			;NORMAL ENTRY - DISABLE PPN KLUDGE
SGSET0:	MOVEM AC2,JOBPPN(J)		;THIS IS THE RUN FROM ANOTHER AREA KLUDGE
	XCTR XW,[MOVEM TAC1,DEVWRD]	;STORE FIRST ARG. MAY BE DEVICE, OR FILE
	JUMPE TAC1,SGSETC		;ASSUME DSK IF NO ARG
;	CAIE	TEM,":"
;	CAIN	TEM," "
;	SKIPA				;Only colon and blank trigger dev search
;	JRST	SGSETC
	PUSHJ P,SGDVOK			;SEE IF IT'S A VALID DEVICE NAME
	JRST SGSETC			;WASN'T A DEVICE NAME
	SKIPN TAC1,JOBNAM(J)		;WAS DEVICE.   AUTOMATIC FILENAME?
	JRST SGSET3			;NO. READ ONE FROM THE COMMAND STRING
SGSETA:	XCTR XW,[MOVEM TAC1,FILNAM]	;OK. SET FILE NAME
	MOVSI TAC1,'DMP'
	XCTR XW,[MOVEM TAC1,FILEXT]	;DEFAULT EXTENSION
	XCTR XW,[SETZM FILLEN]
	XCT SGPPN			;LOAD AC1 WITH DEFAULT PPN
	JRST SGSET1

SGSETC:	MOVSI TAC1,'DSK'		;NO TRY TO ASSUME DISK
	XCTR XRW,[EXCH TAC1,DEVWRD]	;USE THIS FOR FILENAME
	JUMPN TAC1,SGSETD
	SKIPN TAC1,JOBNAM(J)
	JRST NOTENF
	JRST SGSETA

SGSET3:	PUSHJ P,CTEXT1			;GET FILE NAME FROM COMMAND STRING
	JUMPE TAC1,NOTENF		;THERE MUST BE A FILE NAME
SGSETD:	XCTR XW,[MOVEM TAC1,FILNAM]	;STORE FILE NAME
	MOVEM TAC1,JOBNAM(J)		;STORE ALSO FOR SYSTAT
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI TAC1,'DMP'		;ASSUME EXTENSION
	CAIN TEM,"."			;EXTENSION EXPECTED?
	PUSHJ P,CTEXT1			;YES. GET EXTENSION, OTHERWISE USE DEFAULT
	XCTR XW,[HLLZM TAC1,FILEXT]	;STORE IT FOR LOOKUP
	XCTR XW,[SETZM FILLEN]
	PUSHJ P,PJPGNO			;SCAN PPN FROM COMMAND LINE
SGPPN:	JSP AC1,[SKIPN AC2,DSKPPN(J) 	;THIS IS A SUBROUTINE CALLED BY XCT SGPPN
		 MOVE AC2,PRJPRG(J)
		 JRST (AC1)]
	PUSHJ P,DECIN1		;CORE SIZE, IN PAGES OR K, (OPTIONAL THIRD ARG.)
	JRST SGSET1		;DOES NOT RETURN IF ERROR, RETURN HERE IF NO ARG.
	JRST COMERA		;ILLEGAL CHARACTER
	LSH TAC1,-CSHIFT	;CONVERT TO HIGHEST RELATIVE LOCATION (+9 OR +10)
	SUBI TAC1,1
	TLNE TAC1,-1		;STOP BEFORE ACTING SILLY
	JRST COMERR		
SGSET1:	XCTR XW,[HRRZM TAC1,JOBCOR]	;STORE FOR RUN COMMAND AND SAVE
	SKIPN JOBPPN(J)		;SKIP IF EXPLICIT PPN KLUDGE.
	MOVEM AC2,JOBPPN(J)	;SAVE PPN
;IOS CONTAINS DISPATCH ADDRESS (SUCH AS RUNJOB, GETJOB, SAVJOB, SSAVJB)
	MOVE TAC1,IOS		;SCHEDULE MONITOR JOB
	JRST MSTART		;START JOB WITH PC IN MONITOR MODE

;MSTART RETURNS TO COMMAND DECODER AFTER SCHEDULING THE JOB TO BE RUN AT
;UUO LEVEL, STARTING AT THE SPECIFIED PC.  NOTE THAT THE NORMAL ACS ETC.
;THAT ARE NORMALLY SETUP AT UUO LEVEL ARE NOT SETUP IN THIS CASE.  HENCE,
;MONSTR MUST BE CALLED TO INITIALIZE ACS TO REASONABLE VALUES.
;SSAVJB SAVJOB SAVJB1 SAVEUP

;THIS JOB SAVES A JOB AREA ON RETRIEVABLE STORAGE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO SAVE STATUS OF IO DEVICES, JOBPDP, OR AC'S
;IN FACT THE ONLY USEFUL THING WHICH MAY BE DONE WITH A JOB AREA
;AFTER IT HAS BEEN SAVED IS TO START EXECUTION OVER AT THE STARTING
;ADDRESS


;HERE AT UUO LEVEL FOR SSAVE COMMAND
↑SSAVJB:JSP TAC1,SG1		;SET UP FOR SAVE
	JFCL			;IGNORE LOOKUP FAILURE
	PUSHJ P,SSAVJA		;NON-FLUSH SEGMENT ENTRANCE
	JRST SAVJB1

;HERE AT UUO LEVEL FOR SAVE COMMAND
↑SAVJOB:JSP TAC1,SG1		;SET UP ACS AND ASSIGN DEVICE AND LOOKUP
	JFCL			;IGNORE LOOKUP FAILURE
	PUSHJ P,SAVJB		;THIS ROUTINE ACTUALLY DOES THE WORK
SAVJB1:	PUSHJ P,INLMES		;Job saved in nn(+qq) pages. ((Upper not saved))
	ASCIZ /Job saved in /
	XCTR XR,[HLRO TAC,FILLEN]
	MOVNS TAC
	ADDI TAC,JOBSAV
	LSH TAC,-12
	ADDI TAC,1	
	LSH TAC,1		;COUNT PAGES (CROCK!)
	PUSHJ P,RADX10		;TELL HIM HOW MUCH WE SAVED IT IN
	XCTR XR,[SKIPE NEWCOR]
	JRST SAVEUP		;AND UPPER
	LDB TAC,PSEGN
	JUMPE TAC,GETNUP	;IF NO UPPER, CALL PHOLD AND PRINT " pages"
	JSP TAC,PHOLD		;YES, TELL HIM NOT SAVED
	ASCIZ / pages. (Upper not saved)/


SAVEUP:	MOVEI TEM,"+"
	XCT TYO
	XCTR XR,[HLRO TAC,NEWCOR]
	MOVNS TAC
	ADDI TAC,1777
	LSH TAC,-12
	LSH TAC,1
	PUSHJ P,RADX10
	JRST GETNUP		;CALL PHOLD AND PRINT " pages"
;GETJOB GETJ1 GETNUP NOFILE

;THIS JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO RESTORE STATUS OF IO DEVICES, PC, OR AC'S
;JOBPC IS SET TO STARTING ADDRESS OF JOB
;CORE MUST ALREADY HAVE BEEN ASSIGNED AND THE FOLLOWING LOC. SETUP IN
;JOB DATA AREA:
;JOBPDP, JOBREL


↑GETJOB:			;HERE AT UUO LEVEL TO PERFORM GET
	JSP TAC1,SG1		;SET UP ACS, ASSIGN DEVICE, AND DO LOOKUP
	JRST NOFILE		;FILE NOT FOUND RETURN
	PUSHJ P,GETJB		;GET THE JOB
GETJ1:	PUSHJ P,INLMES		;RETURN ONLY IF EVERYTING OK
	ASCIZ /Job setup in /
	HLRZ TAC,JBTPAG(J)
	PUSHJ P,RADX10
	LDB TAC,PSEGN
	JUMPE TAC,GETNUP
	HLRZ TAC,JBTPAG(TAC)		
	PUSH P,TAC
	MOVEI TEM,"+"
	XCT TYO
	POP P,TAC
	PUSHJ P,RADX10
GETNUP:	JSP TAC,PHOLD
	ASCIZ / pages/


NOFILE:	PUSHJ P,CLRTPV		;NOT FOUND--CLEAR TEMPORARY PRIVILEGES
	PUSHJ P,SGREL		;RELEASE DEVICE, FIND TTY
	PUSHJ P,PRQM		
	XCTR XR,[MOVE TAC1,FILNAM]	;PRINT FILE NAME
	PUSHJ P,PRNAME
	PUSHJ P,PRPER		;PRINT PERIOD
	XCTR XR,[HLLZ TAC1,FILEXT]
	PUSHJ P,PRNAME		;PRINT EXTENSION
	JSP TAC,PHOLD		;PRINT MESS. AND STOP JOB
	ASCIZ / not found/
;RUNJOB MRDJB2 NOSTRT MRDJOB MRDUSR MRDRLN MC MRDPRG MRDBG MRDB1 MRDB3 MRDB4 MRDLEN

;JOB HAS JUST A JOB DATA AREA ASSIGNED WHEN CONTROL GETS HERE
;THIS MONITOR JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;ASSIGNS CORE AND START


;HERE AT UUO LEVEL TO PERFORM RUN OR R COMMAND
↑RUNJOB:JSP TAC1,SG1			;SETUP ACS, ASSIGN DEVICE, AND DO LOOKUP
	JRST NOFILE			;NO FILE FOUND RETURN
	PUSHJ P,GETJB			;GET THE FILE
	XCTR XR,[HRRZ TAC,JOBSA]	;GET STARTING ADDRESS
	JUMPE TAC,NOSTRT
	ADD TAC,SAVSAI(J)		;ADD STARTING ADDRESS INCREMENT
MRDJB2:	HRLI TAC,USRMOD			;SET USER MODE BIT
	MOVEM TAC,UUOPC(J)		;MAKE IT LOOK LIKE UUO RETURN
	MOVE TAC,JOBPPN(J)		;GET PRJPRG OF FILE
	JRST USRXIT			;AND GO START USER

NOSTRT:	PUSHJ P,INLMES
	ASCIZ /? No starting address.
/
	JRST GETJ1

IFN FTF2!FTKLB,<
GLOBAL JOBDA

;HERE JUST LIKE AT RUNJOB, BUT WANT TO SET UP USER CORE TO READ F2 TAPE
↑MRDJOB:JSP TAC,MONSTR			;SET ACS TO NORMAL UUO LEVEL ENVIRONMENT
	PUSHJ P,RESETUUO		;RELEASE ALL DEVICES
	MOVE TAC,[MRDPRG,,JOBDA]	;NOW WE BLT PROGRAM INTO USER CORE
	XCTR XBLTW,[BLT TAC,JOBDA+MRDLEN-1] ;GIVE USER CORE THE PROG
	MOVEI TAC,JOBDA			;START USER PROGRAM AT BEGINNING
	JRST MRDJB2			;JOIN RUNJOB CODE

;Here is the program that we BLT into user core for the user to read the magtape.
;This is user mode code, loaded at 140.  This program is run by the MREAD monitor
;command to read the next file off the tape into user core, assuming it is a
;DMP file.
MRDUSR←←1000			;User location where we start reading tape into
MRDRLN←←1000			;record size in words
MC←←0				;User IO channel
MRDPRG:
	PHASE JOBDA
	INIT MC,17
	 'MTA0  '
	 0
	 HALT .			;stop user program on INIT failure
MRDBG::	MOVEI 2,MRDUSR-1	;Where to start reading
MRDB1::	HRLI 2,-MRDRLN		;RECORD SIZE
	MOVEI 3,0		;END OF LIST
	MOVEI 4,MRDRLN(2)	;end address of record, ensure we have enough core
	CAMLE 4,JOBREL
	CORE 4,			;get core for next record
	 JFCL
IFE FTKLB,<
	INPUT MC,2		;READ A RECORD
>;IFE FTKLB
IFN FTKLB,<
	HALT .			;patch here
>;IFN FTKLB
	ADDI 2,MRDRLN		;NEXT ADDR
	STATZ MC,IOIMPM!IODERR!IODTER!IOBKTL ;any error?
	 HALT .			;yes, stop user prog
	STATO MC,IODEND		;end of file?
	 JRST MRDB1		;Record OK, go get another
	MOVE 1,JOBDDT+MRDUSR-74	;Do funny things system does
	SETDDT 1,
	MOVE 1,JOBS41+MRDUSR-74
	MOVEM 1,JOB41
	MOVSI 0,MRDUSR		;Get ready to BLT program down
	HRRI 0,74
	MOVE 1,MRDB3		;BLT rest of our program into ACs
	BLT 1,MRDB4
	JRST 3

MRDB3::	.+1,,3
	BLT 0,74-MRDUSR-1+2(2)	;(goes into AC 3) The big BLT (copy program down)
	EXIT			;(goes into AC 4) Done!
MRDB4←←.-<MRDB3+1>+3-1		;ending address for BLT into the ACs

	BLOCK 40		;Some patch space
	DEPHASE
MRDLEN←←.-MRDPRG		;Length of program
>;IFN FTF2!FTKLB
;SG1 SGCOR1 SGCOR SG2 SGCOR2 SG3 SGERRA SGERR1

;SETUP ACS, RESET IO, ASSIGN DEVICE, LOOKUP FILE.
;CALL:	JSP TAC1,SG1
;	FILE NOT FOUND RETURN
;	FILE FOUND RETURN
;	IOWD FOR THIS SIZE CORE RETURNED IN AC TAC
;	DEVMOD IN TAC1



;HERE AT UUO LEVEL.  IF THIS WAS CALLED FOR SAVGET, WE NEED TO SETUP
;UUO LEVEL ACS.  IF THIS WAS CALLED FROM SWAP UUO, WE SETUP AC'S ANYWAY.
SG1:	JSP TAC,MONSTR			;SET ACS TO NORMAL UUO LEVEL ENVIRONMENT
	PUSHJ P,RESETUUO		;RELEASE ALL DEVICES
	MOVEI TAC,17			;DUMP MODE - FLUSH OLD MODE 2.
	XCTR XW,[MOVEM TAC,MODWRD]	;STORE FOR OPEN UUO
	XCTR XW,[SETZM HEDWRD]		;CLEAR BUFFER HEADER ARG.
	XCTR XR,[SKIPN TAC,JOBCOR]	;WAS CORE SIZE SPECIFIED
	JRST SGCOR			;NO
	HLRZ TAC1,JBTPAG(J)		;YES.  WHAT'S THE OLD CORE SIZE?
	LSH TAC1,9
	CAMGE TAC,TAC1			;SKIP IF WE HAVEN'T ENOUGH ALREADY.
	JRST SGCOR1			;WE HAVE ENOUGH.  USE WHAT HE SPECIFIED.
	PUSHJ P,RUNCOR			;TRY FOR ENOUGH
	JRST SG2			;CAN'T GET IT.  GIVE HIM WHAT HE'S GOT NOW
SGCOR1:	XCTR XR,[MOVN TAC,JOBCOR]
	JRST SGCOR2

SGCOR:	SKIPE USRDDT		;IF DDT IS IN
	JRST SG2			; THEN SAVE UP TO JOBREL
	XCTR XR,[HRRZ TAC,JOBFF]	;PICK UP FIRST FREE LOCATION
	JUMPE TAC,SG2			;IF ZERO, SAVE UP TO JOBREL
	HLRZ TAC1,JBTPAG(J)		;GET THE CORE SIZE
	LSH TAC1,9
	CAML TAC,TAC1			;IS JOBFF IN BOUNDS?
	JRST SG2			;NO, SAVE THROUGH JOBREL
	MOVN TAC,TAC			;NEGATE TO FORM HALF OF IOWD
	JRST SGCOR2

SG2:	HLRZ TAC,JBTPAG(J)		;HERE, SAVE CORE THRU JOBREL
	LSH TAC,9
	SUBI TAC,1
	MOVN TAC,TAC
SGCOR2:	ADDI TAC,JOBSAV			;LOWER CORE NOT DUMPED
	HRLI TAC,JOBSAV
	XCTR XW,[MOVSM TAC,DMPWRD]	;STORE IOWD WORD OF THIS SIZE CORE
	OPEN 0,MODWRD			;TRY TO ASSIGN DEVICE
	JRST SGERRA			;NOT AVAILABLE
	MOVE TAC1,DEVNAM(DDB)
	MOVEM TAC1,JOBDEV(J)
	MOVE TAC1,DEVLOG(DDB)
	MOVEM TAC1,JOBLOG(J)
	MOVE TAC1,DEVMOD(DDB)
	MOVE AC1,JOBPPN(J)		;GET PROJECT-PROGRAMMER NUMBER
	XCTR XW,[MOVEM AC1,FILLEN]	;SET IT INTO PLACE
	LOOKUP 0,FILNAM			;LOOKUP FILE NAME
	SOS (P)				;NOT FOUND - NON-SKIP RETURN
	XCTR XR,[MOVE TAC,DMPWRD]	;FOUND, RETURN IOWD FOR THIS SIZE CORE
	MOVE TAC1,DEVMOD(DDB)
	MOVE J,JOB			;RESTORE JOB NUMBER FOR THOSE WHO NEED IT
	TLNE TAC1,DVDSK			;DISK?
	JRST SG3			;YES.
	SETZM JOBPPN(J)			;NOT DSK.
	JRST CPOPJ1

SG3:	MOVE AC1,FILPPN(DDB)
	EXCH AC1,JOBPPN(J)
	JRST CPOPJ1			;SKIP RETURN, UNLESS FILE NOT FOUND

;HERE IF SAVE DEVICE NOT AVAILABLE - PRINT ERROR MESSAGE AND STOP JOB

SGERRA:	JUMPE DDB,SGERR1
	MOVEM DDB,(P)			;PRINT DEVICE XXX
	PUSHJ P,TTYFNU			;FIND TTY
	PUSHJ P,PRQM			;PRINT "?"
	PUSHJ P,ERNAM			;"DEVICE XXX"
	JSP TAC,PHOLD			;PRINT AND STOP JOB
	ASCIZ / not available/

SGERR1:	PUSHJ P,TTYFNU
	JSP TAC,PHOLD
	ASCIZ /? No such device/
;SGREL SGREL1 NOROM0 NOROOM NOROM1

;ROUTINE TO RELEASE DEVICE AND FIND TTY

SGREL:	SKIPN USRJDA	;HAS CHANNEL BEEN RELEASED ALREADY?
	JRST TTYFUW		;YES. FIND TTY AND WAIT FOR OUTPUT TO FINSIH
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVMTA		;MAGTAPE?
	TLNN DDB,INPB		;YES. WAS AN INPUT DONE?
	JRST SGREL1		;NO
	CLOSE 0,CLSOUT		;YES. CLOSE INPUT.
	STATO 0,IOTEND		;AT END OF TAPE?
	MTAPE 0,6		;NO. SKIP TO EOF
SGREL1:	RELEASE 0,		;NO, RELEASE DEVICE
	JRST TTYFUW		;FIND TTY AND WAIT FOR OUTPUT TO FINISH

NOROM0:	MOVE TAC,DEVMOD(DDB)		;HERE IF USER'S CORE ARG WAS TOO BIG. 
	TLNN TAC,DVMTA			;PRINT MINIMUM CORE SIZE NEEDED, EXCEPT
	XCTR XW,[SETZM JOBCOR]		;ON MTA, MINIMUM CORE SIZE IS UNKNOWN.
NOROOM:	PUSHJ P,SGREL			;RELEASE DEVICE, FIND TTY
	PUSHJ P,CRLF
	PUSHJ P,PRQM
	XCTR XR,[SKIPLE TAC,JOBCOR]	;GET MIN. HIGHEST REL.LOC. FOR JOB TO RUN
	JRST NOROM1			;USE IT IF SPECIFIED.
	XCTR XR,[HLRO TAC1,FILLEN]	;-LENGTH OF FILE
	MOVNS TAC1			;+LENGTH
	XCTR XR,[HRRZ TAC,FILLEN]	;FIRST LOC-1 DUMPED
	ADD TAC,TAC1			;LAST LOC DUMPED
NOROM1:	ADDI TAC,777			;ROUND UP TO PAGE BOUNDARY
	LSH TAC,CSHIFT			;CONVERT TO PAGE OR K COUNT
	PUSHJ P,RADX10
	JSP TAC,PHOLD			;GO START TTY, AND STOP JOB
	ASCIZ / pages of core needed/
;GETJB GETJB1 GETJB3 GETJB2

;ROUTINE TO GET FILE FROM DEVICE

GETJB:	PUSHJ P,RESETSEG		;FLUSH UPPER AND ANY DETACHED SEGMENTS
	XCTR XW,[SETZM JOBINT] 		;THIS ISN'T CLEARED BY GETTING FILE
	XCTR XR,[MOVE TAC,FILDAT]
	MOVEM TAC,JOBCRD(J)		;COPY CREATION DATE FOR SEGMENT ACCESS
	XCTR XR,[MOVE TAC,DMPWRD]
	TLNE TAC1,DVDSK			;DISK?
	XCTR XRW,[HRRM TAC,FILLEN]	;YES.
	XCTR XR,[HRRZ TAC,JOBCOR]	;HIGHEST REL.LOC. REQUESTED
	XCTR XW,[MOVEM TAC,NEWCOR]	;SAVE IT
	JUMPG TAC,GETJB1		;JUMP IF CORE ARGUMENT WAS SPECIFIED
	TLNE TAC1,DVMTA			;MAGTAPE?
	JRST GETJB3			;MAGTAPE.
	XCTR XR,[MOVE TAC1,FILLEN]
	TLNN TAC1,-1			;-WC OF ZERO IS ILLEGAL
	JRST GETERR
	HLRO TAC1,TAC1			;USE AMOUNT OF CORE SPECIFIED IN DIRECTORY
	XCTR XR,[HRRZ TAC,FILLEN]	;FIRST LOC.-1
	SUB TAC,TAC1			;TOTAL # OF WORDS NEEDED-1=HIGHEST LOC DMPED
	IORI TAC,1777			;HIGHEST LOC. IN 1K BLOCKS
GETJB1:	MOVE J,JOB			;SETUP JOB NUMBER
	PUSHJ P,RUNCOR			;TRY TO ASSIGN CORE
	JRST NOROM0			;USER ARG TOO BIG. PRINT MINIMUM NEEDED.
	MOVE TAC1,DEVMOD(DDB)
	TLNN TAC1,DVMTA			;MAGTAPE?
	JRST GETJB2			;NO.
GETJB3:	HLRZ TAC1,JBTPAG(J)		;YES. SET FILLEN TO CURRENT CORE SIZE.
	LSH TAC1,9
	SUBI TAC1,JOBSAV+1
	MOVNS TAC1
	HRLI TAC1,JOBSAV
	XCTR XW,[MOVSM TAC1,FILLEN]
GETJB2:	XCTR XW,[SETZM DMPEND]		;SET 2ND WORD OF DUMP LIST TO 0
	XCTR XW,[SETZM JOBCOR]		;SO NOROOM MESSAGE ALWAYS WORKS
	XCTR XR,[HLRO TAC,FILLEN]	;GET - NO. WORDS TO READ OR WRITE
	SUBI TAC,JOBSAV			;NO. OF LOWER CORE LOC. NOT DUMPED
	HLRZ TAC1,JBTPAG(J)
	LSH TAC1,9
	ADDI TAC,-1(TAC1)		;+HIGHEST LOCATION IN USER AREA
	JUMPL TAC,NOROOM		;WILL IT FIT?
	MOVEM DDB,USRHCU		;SET HIGHEST IO CHAN IN USE NEGATIVE
					;ALSO ADDRESS OF SAVE GET DEVICE.
	INPUT 0,FILLEN			;READ INTO PROTECTED PART OF JOB DATA AREA
	PUSHJ P,CLRUSR			;CLEAR OUT POSSIBLE GARBAGE
					;AND SET USRHCU BACK TO 0
	MOVEM DDB,USRJDA		;RESTORE CHANNEL 0 ASSIGNMENT
	PUSH P,IOS			;SAVE POSSIBLE ERROR BITS
	PUSHJ P,SGREL			;RELEASE DEVICE,FIND TTY
	XCTR XR,[MOVE TAC,JOBS41]	;RESTORE USER UUO JSR LOC.
	XCTR XW,[MOVEM TAC,JOB41]	;IN CASE THIS IS GET OR RUN
	POP P,TAC			;GET BACK BITS
	TRNE TAC,IOBKTL+IODERR+IODTER+IOIMPM	;ANY ERRORS FROM GET DEVICE?
	JRST SGTERR			;YES.  LOSE MESSAGE
	MOVE TAC,JOBPPN(J)
	XCTR XR,[HLRZ TAC,HILOC]	;SEGMENT PROTECTION SAVED HERE
					;IF NO SEGMENT WAS SAVED, PROT WILL BE 0.
	ANDI TAC,377			;FLUSH UNUSED BITS
	DPB TAC,[POINT 9,JOBCRD(J),8]
;FALL OFF PAGE.  SEE IF THERE'S AN UPPER TO SETUP
;GETJ7 GETJ8 GETJ5

;MORE GETJB  - HERE WE DISCOVER IF WE HAVE A HIGH SEGMENT TO SET-UP
;FIRST TRY TO ATTACH TO THE SAVED NAME (IF ANY)
;MAKE SURE IT IS WRITE PROTECTED, AND THAT IS WHAT WE WANT
;IF ALL THIS FAILS, TRY A REMAP ON OUR SEGMENT.

	XCTR XR,[SKIPN TAC,HILOC]	;DOES THIS JOB HAVE A HIGH SEGMENT?
	JRST GETDN1			;NO, FIX UP CORE SIZE AND LEAVE
	MOVEI TAC,(TAC)			;ONLY INTERESTED IN RIGHT HALF
	IORI TAC,1777			;WHERE IT WILL BE MOVED TO
	HLRZ TAC1,JBTPAG(J)
	LSH TAC1,9
	CAIG TAC,401777			;IF LOWER IS BIGGER THAN 128K, NO UPPER
	CAIL TAC,-1(TAC1)		;IS ADDRESS ABOVE TOP?
	JRST GETERA			;YES, EVIL EVIL(NOT A DUMP FILE)
	PUSH P,DDB			;DDB CLOBBERED BY SEGMENT UUOS
REPEAT 0,<
	XCTR XR,[SKIPN TAC,HINAME]	;GET SAVED HIGH SEGMENT NAME!
	JRST GETJ5
	XCTR XW,[MOVEM TAC,FILLEN]
	ATTSEG FILLEN,			;ATTACH TO IT?
	 JRST GETJ5			;ERROR RETURN
	LDB TAC,PSEGN			;GET ITS JOB NUMBER
	MOVE TAC,JBTSTS(TAC)
	XCTR XR,[SKIPL HILOC]		;DO WE WANT WRITE PROT?
	JRST GETJ7
	TLNE TAC,JWP			;YES, IS HE WRITE PROTECTED
	JRST GETDON			;PROT MATCHES
	JRST GETJ8

GETJ7:	TLNN TAC,JWP			;IS HE UNPROTECTED?
	JRST GETDON			;THAT'S IT!
GETJ8:	DETSEG				;DETACH THIS ONE
>;REPEAT 0
GETJ5:	XCTR XR,[HRRZ TAC,HILOC]	;CURRENT BOTTEM OF SEGMENT
	SUBI TAC,1
	PUSHJ P,BLTUP			;MOVE UPPER TO NEXT 1K BOUNDARY
	PUSH P,JOBNAM(J)		;SAVE OUR JOB NAME WHILE WE FAKE REMAP
	XCTR XR,[SKIPE TAC,HINAME]	;SAVED UPPER HAVE A NAME?
	MOVEM TAC,JOBNAM(J)		;YES, MAKE REMAP LOOK FOR THAT NAME
	XCTR XR,[MOVE TAC,HILOC]	;SIGN BIT INDICATES WANT WRITE PROT
	SUBI TAC,1
	IORI TAC,1777
	XCTR XW,[MOVEM TAC,FILLEN]	;SET UP AC FOR REMAP, SIGN ON IF WANT...
	REMAP FILLEN,			;...WRITE PROTECT
	 JRST GETJ5B			;ERROR RETURN, TRY SETPR2
	JRST GETDN2
;GETJ5B GETERR GETERA GETDN2 GETDON GETDN1

;END OF GET, REMAP ERROR, SETPR2 KLUDGE

GETJ5B:	POP P,JOBNAM(J)			;RESTORE OUR JOB NAME
	POP P,DDB			;GET BACK TTY DDB
	MOVEI DAT,TTOBUF(DDB)		;AND SET UP THIS GUY
	PUSHJ P,INLMES
	ASCIZ /
Couldn't get you a segment.  Will try to let you win with SETPR2.
/
	HLRZ TAC,JBTPAG(J)
	LSH TAC,9
	SUBI TAC,1
	XCTR XW,[MOVEM TAC,JOBCOR]	;DON'T LET HIM CORE DOWN BELOW UPPER
	ADDI TAC,1
	XCTR XW,[MOVEM TAC,JOBFF]	;AND TELL HIM NOT TO WRITE OVER IT
	XCTR XRW,[HRLM TAC,JOBSA]	;IN BOTH WAYS
	XCTR XR,[SUB TAC,FILLEN]	;LENGTH OF UPPER+1
	MOVSI TAC,-2(TAC)
	XCTR XR,[SKIPL HILOC]
	TLZ TAC,1			;SET UP W.P. BIT
	XCTR XR,[HRR TAC,FILLEN]
	ADDI TAC,1+3			;REMOVE OFFSET, SET "RELATIVE"
					;   & "PSEUDO-UPPER" BITS
	PUSHJ P,STPR2
	JRST GETDN1

GETERR:	PUSHJ P,SGREL			;RELEASE DEVICE AND FIND TTY
GETERA:	JSP TAC,PHOLD
	ASCIZ /? not a dump file/

GETDN2:	POP P,JOBNAM(J)			;RESTORE OUR REAL JOB NAME
	XCTR XR,[SKIPN TAC,HINAME]
	JRST GETDON
	LDB TAC1,PSEGN
	MOVE DDB,NJOBS(TAC1)
IFN FTELOK,<
	CAMN TAC,[SIXBIT /E/]
	CAILE DDB,1
	CAIA
	MOVEM TAC1,ESEGNO		;STORE JOB NUMBER OF E UPPER SEGMENT
>;IFN FTELOK
IFE FTSTAT,<
	CAIG DDB,1			;MORE THAN ONE JOB MEANS WE'RE NOT THE FIRST
	MOVEM TAC,JOBNAM(TAC1)
>;IFE FTSTAT
IFN FTSTAT,<
	CAILE DDB,1
	JRST GETDON
	MOVEM TAC,JOBNAM(TAC1)
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
GETDON:	POP P,DDB			;GET BACK TTY DDB
	MOVEI DAT,TTOBUF(DDB)
GETDN1:	PUSHJ P,FINZRL			;(IN SCHEDU)  SETS UP JOBRL2 (aka JOBHRL)
	MOVE TAC,JOBPPN(J)
	XCTR XW,[MOVEM TAC,FILLEN]	;RESTORE PPN FOR PROGRAM TO SEE
	XCTR XW,[MOVEM TAC,DMPEND]	;IN USER'S ACS 3 AND 4
	XCTR XR,[SKIPE TAC,NEWCOR]	;DID USER TYPE 3RD ARGUMENT?
	XCTR XR,[CAMG TAC,JOBCOR]	;YES, IS 3RD ARG GREATER THAN MIN SIZE
					;SPECIFIED BY 3RD ARG TO SAVE (IF ANY)
	XCTR XR,[MOVE TAC,JOBCOR]	;NO, ASSIGN NEW BIGGER AMOUNT OF CORE
	JUMPLE TAC,CPOPJ		;IF 0 OR NEG, DOESN'T MAKE SENSE.
	IORI TAC,1777
	HLRZ TAC1,JBTPAG(J)		;HOW MUCH DOES HE HAVE NOW
	LSH TAC1,9
	SUBI TAC1,1
	CAMN TAC1,TAC			;DIFFERENT?
	POPJ P,				;NO
	PUSHJ P,RUNCOR
	JFCL				;IGNORE IF CAN'T
	POPJ P,
;SSAVJA SAVJB SAVJBB SAVJ0 SAVJ1 SAVJ3 SAVJ2 SGTERA SGTERR SAV4

;ENTER AT SAVJB FOR SAVE COMMAND
;SSAVJA FOR SSAVE COMMAND
;SAVJBB FOR SAVE SIDE OF THE SWAP UUO, WITH NEWCOR SETUP.

;DO NOT CLOBBER ANY ACS BETWEEN CALLING SG1 AND ENTERING ANY OF THESE.

SSAVJA:	XCTR XW,[SETOM NEWCOR]		;FLAG TO SAVE UPPER
	JRST SAVJBB

SAVJB:	XCTR XW,[SETZM NEWCOR]		;SIGNAL NO SAVE OF UPPER SEGMENT
SAVJBB:	XCTR XW,[MOVEM AC1,FILLEN]	;RESTORE PPN TO FOURTH WORD OF LOOKUP BLOCK
	TLNN TAC1,DVDSK			;DISK?
	XCTR XW,[MOVEM TAC,FILLEN]	;NO. SET FILE LENGTH IN DIRECTORY HEADER
	XCTR XW,[SETZM FILDAT]		;MAKE SURE WE GET TODAY'S DATE
	XCTR XRW,[HLLZS FILEXT]		;DATE75 - MAKE SURE RH. OF EXT. WORD IS CLEAR.
	TLNE TAC1,DVDSK			;DSK?
	CLOSE 0,CLSOUT			;YES, CLOSE INPUT TO AVOID BEING IN READ/ALTER
	ENTER 0,FILNAM			;ENTER FILE NAME IN DIRECTORY
	JRST SAV4			;DIRECTORY FULL
	XCTR XR,[MOVE TAC,DMPWRD]	;RESTORE FILLEN AFTER DISK ENTER
	XCTR XW,[MOVEM TAC,FILLEN]
	XCTR XR,[MOVE TAC,JOB41]	;SAVE USER UUO HANDLING JSR
	XCTR XW,[MOVEM TAC,JOBS41]	;IN UPPER PART OF JOB DATA AREA
	XCTR XR,[SKIPN NEWCOR]		;SHALL WE SAVE UPPER?
	JRST SAVJ1			;NO
	LDB TAC,PSEGN			;SEGMENT NUMBER
	JUMPE TAC,SAVJ1

IFE FTDSKM,<
IFN FTHPSG,<
	HRRZ TAC1,JBTPAG(TAC)
	CAIGE TAC1,1000
	JRST SAVJ0
	MOVE J,JOB
	MOVEI TAC,1
	PUSHJ P,LTHUUO			;MOVE FROM HIGH TO LOW
	MOVE J,JOB
	LDB TAC,PSEGN
	PUSHJ P,SAVJ0			;SSAVE THE LOWER AND LOWCORE-UPPER
	MOVEI TAC,0
	PUSHJ P,LTHUUO			;MOVE FROM LOW TO HIGH
	JFCL				;IGNORE FAILURE
	MOVE J,JOB
	POPJ P,
>;FTHPSG
>;IFE FTDSKM

SAVJ0:	HLRZ TAC1,JBTPAG(TAC)
	LSH TAC1,9			;SIZE OF SEGMENT 
	MOVN TAC1,TAC1
	MOVS TAC1,TAC1
	HRRI TAC1,377777		;-WC,,ADDRESS-1
	XCTR XW,[MOVEM TAC1,NEWCOR]
	XCTR XR,[HLRO TAC1,FILLEN]	;-LENGTH OF LOWER
	SETCM TAC1,TAC1			;COMPUTE +(LENGTH OF FIRST PART)-1
	IORI TAC1,177			;MAKE IT A DISK BLOCK BOUNDARY-1
	ADDI TAC1,JOBSAV+1+1		;ROUNDING UP AND MAKING INTO CORE LOC
	LDB TAC,[POINT 9,JOBCRD(TAC),8]
	HRL TAC1,TAC			;SET SEGMENT PROT BITS IN JOBRL2 LH.
	LDB TAC,PSEGN			;GET THIS BACK
	MOVE TAC,JBTSTS(TAC)
	TLNE TAC,JWP
	TLO TAC1,400000			;SET SIGN BIT IF WRITE PROTECTED.
	XCTR XW,[MOVEM TAC1,JOBRL2]	;MAKE COMPATIBLE
	XCTR XW,[MOVEM TAC1,HILOC]
	LDB TAC,PSEGN			;AND AGAIN
	MOVE TAC,JOBNAM(TAC)
	CAMN TAC,JOBNAM(J)		;SAME NAMED UPPER AS LOWER
	SETZ TAC,			;YES, FLAG AS SUCH
	XCTR XW,[MOVEM TAC,HINAME]	;SAVE IN THIS NEW PLACE!
	JRST SAVJ3

SAVJ1:	XCTR XW,[SETZM HILOC]
	XCTR XW,[SETZM JOBRL2]
	XCTR XW,[SETZM HINAME]
	XCTR XW,[SETZM NEWCOR]		;MAKE SURE NO SAVE HAPPENS!
SAVJ3:	XCTR XW,[SETZM DMPEND]
	XCTR XR,[HLRO TAC,FILLEN]
	SUBI TAC,JOBSAV
	HLRZ TAC1,JBTPAG(J)
	LSH TAC1,9
	ADDI TAC,-1(TAC1)
	JUMPL TAC,NOROOM
	XCTR XR,[HLRO TAC,FILLEN]
	MOVNS TAC
	ADDI TAC,JOBSAV
	XCTR XW,[MOVEM TAC,JOBCOR]	;MAKE SURE HE GETS TO BE RIGHT SIZE WHEN HE COMES BACK IN
	OUTPUT 0,FILLEN
	TRNE IOS,IOBKTL!IODERR!IODTER!IOIMPM
	JRST SGTERA			;TRANSMISSION ERROR
	XCTR XR,[SKIPN NEWCOR]		;ANY UPPER TO WRITE?
	JRST SGREL			;NO.
	XCTR XW,[SETZM NEWCOR+1]
	OUTPUT 0,NEWCOR
	LDB TAC,PSEGN
	JUMPE TAC,SAVJ2
	HLRZ TAC1,JBTPAG(TAC)
	LSH TAC1,9		
	SUBI TAC1,1			;PROTECTION SIZE OF SEGMENT
	TRO TAC1,400000
	XCTR XW,[MOVEM TAC1,HILOC]
	XCTR XW,[MOVEM TAC1,JOBRL2]
SAVJ2:	TRNN IOS,IOBKTL!IODERR!IODTER!IOIMPM
	JRST SGREL
SGTERA:	PUSHJ P,SGREL
SGTERR:	JSP TAC,PHOLD			;PRINT ERROR MESSAGE AND STOP JOB
	ASCIZ \? SAVE/GET IO error\


SAV4:	PUSHJ P,SGREL			;RELEASE,DEVICE, FIND TTY
	JSP TAC,PHOLD			;PRINT MESSAGE AND STOP JOB
	ASCIZ /? Enter failed/
;ACCESS ACCES1 ACCES2

BEGIN SEGCSS ↔ SUBTTL	SEGCSS	8 SEPT 69	JAM
; SEGMENT ACCESS CONTROL
; PUT JOB NUMBER OF MASTER ON STACK AND NUMBER OF SEGMENT IN J
; CALLING . . .
;	PUSH P,J		;MASTER JOB NUMBER
;	MOVE J,<SEGMENT NUMBER>
;	PUSHJ P,ACCESS
;	<NO ACCESS POSSIBLE>
;	<READ ACCESS ONLY>
;	<ALL ACCESS LEGAL>

↑ACCESS:MOVE TAC,-1(P)		; PICK UP MASTER JOB NUMBER
	MOVE TAC1,PRJPRG(TAC)
	LDB TAC,[POINT 9,JOBCRD(J),8]
	TRZE TAC,400		;UNPURIFIED?
	JRST ACCES2		;YES - DIFFERENT TEST (TAC IS NOW JOB # OF DEFILER)
	CAMN TAC1,JOBPPN(J)	; IS THIS THE SAME JOB?
	JRST ACCES1		; YES, USE OWNER'S PROTECTION
	MOVE TAC1,JB2PRV(TAC)	;GET PASSIVE PRIVS
	TLNN TAC1,LUPPRV	;BH TO OWNER-LOCAL-GUEST
	LSH TAC,3		; SHIFT TO GUEST PROTECTION
	LSH TAC,3		; MOVE OVER TO LOCAL PROTECTION
ACCES1:	TRNN TAC,300		; NOW, IS THERE ANY PROTECTION?
	JRST CPOPJ2		; NO, EVERYTHING GOES
	TRNN TAC,200		; IS IT READ PROTECTED?
	AOS (P)			; NO, IT CAN BE READ
	POPJ P,			; OTHERWISE INACCESSABLE

ACCES2:	CAMN TAC,-1(P)		;ONLY ORIGINAL OWNER WINS HERE
	JRST CPOPJ2
	POPJ P,
;ESTSEG ESTSE1 ESTSE2

; ROUTINE TO INVENT AN UPPER SEGMENT
; SKIP RETURNS WITH JOB NUMBER OF SEGMENT IN J; NON SKIP IF JOB CAPACITY EXCEEDED
; SETS CORE SIZE TO ZERO, SETS PPN TO *SEG*, SETS AS DETATCHED

↑ESTSEG:MOVEI J,1
	MOVSI TAC,JNA!CMWB	;BITS WHICH MUST BE OFF IN A FREE SLOT
ESTSE1:	TDNN TAC,JBTSTS(J)	;SKIP IF JOB SLOT IN USE.
	JRST ESTSE2		;WE HAVE A SLOT TO USE.
	CAMGE J,JOBNM1		;HAVE WE SEEN ALL SLOTS?
	AOJA J,ESTSE1		;NOT YET.
	MOVEI J,0		;RETURN A ZERO
	POPJ P,			;FAILURE.

ESTSE2:	SKIPE JBTPAG(J)		;BUG TRAP
	PUSHJ P,INIJXX		;MAKE LOSE MESSAGE
	SETZM JBTPAG(J)		;SEGMENT HAS NO CORE ASSIGNED IN CORE ...
	SETZM JBTSWP(J)		;... OR ON THE DISK
	SETZM JB2SWP(J)
	MOVSI TAC,JSEG!JNA!JLOG	;SET SEGMENT, SLOT USED, LOGGED IN
	IORM TAC,JBTSTS(J)	;IN JOB STATUS FOR SEGMENT
	SETZM NJOBS(J)		;NO ONE USING THIS UPPER YET
	SETOM JBTLIN(J)		;DETACHED
	SETZM TTIME(J)		;NO RUN TIME FOR THIS UPPER
	SETZM RTIME(J)
	SETZM XTIME(J)		;NO XTIME
	SETZM DSKOPS(J)		;NO DISK OPS
IFKL10,<
	SETZM JBTCSH(J)		;NOT IN THE CACHE YET
>;IFKL10
	MOVE TAC,TIMDAT
	MOVEM TAC,FTIME(J)	;SET UP JOB LAST RUN TIME.
	LSH J,1
	SETZM MTRETIME(J)
	SETZM MTRETIME+1(J)
IFN FTMTRACT,<
	SETZM MTRMTIME(J)
	SETZM MTRMTIME+1(J)
	SETZM MTRTTIME(J)
	SETZM MTRTTIME+1(J)
	SETZM MTRXTIME(J)
	SETZM MTRXTIME+1(J)
>;IFN FTMTRACT
IFN FTMTRTIME,<
	SETZM MTRRTIME(J)
	SETZM MTRRTIME+1(J)
>;IFN FTMTRTIME
	LSH J,-1
	MOVE TAC,[SIXBIT /*SEG*/]	;PPN = *SEG*
	MOVEM TAC,PRJPRG(J)
	SETZM DSKPPN(J)		;No alias PPN
	MOVEI TAC,STOPQ		;QUEUE US INTO THE STOPQ
	MOVNM TAC,JOBQUE(J)
	AOS (P)			;SETUP SKIP RETURN
	JRST REQUE
;LINKSEG CONSEG DEFSE3 SEGFIN LNKCHK DEFSE1 DEFSE2 MAKESEG MAKSE2

;THIS ROUTINE DEFINES A SEGMENT. IT SEARCHES FOR AN EXISTING
;SEGMENT FIRST WITH THE PROPER CREDENTIALS AND GIVES YOU ITS NUMBER FIRST.
;FIRST IT KILLS ANY SEGMENT YOU MAY HAVE.  TAKES THE DIRECT RETURN IF NO
;PROPER SEGMENT IS FOUND;  OTHERWISE, IT ATTACHES TO THE SEGMENT AND SKIP RETURNS.

↑LINKSEG:
	PUSHJ P,LOW128		;SKIP UNLESS LOWER IS BIGGER THAN 128K
	 POPJ P,		;UPPER IS TOO BIG, CAN'T HAVE A SEGMENT
	PUSHJ P,KILSEG		;GET RID OF EXISTING UPPER.
	MOVEI AC1,0		;don't care about matching write protection
	PUSHJ P,LNKCHK		;check for existing segment we can link to
	 POPJ P,		;none
↑CONSEG:PUSH P,J		;save our job number
	EXCH J,TAC		;J←job number of the matching segment found
	PUSHJ P,ASGMAP		;ADD SEGMENT TO THE PAGE MAP (IF SEGMENT IS IN CORE)
DEFSE3:	MOVE TAC,J		;JOB NUMBER OF THE SEGMENT
	POP P,J			;GET BACK OUR OWN JOB NUMBER
	DPB TAC,PSEGN		;MAKE IT OUR UPPER
IFN FTSTAT,<
	PUSHJ P,SEGSTT
>;IFN FTSTAT
	JUMPE TAC,SEGFIN	;(MAKESEG GOES TO DEFSE3 WITH J 0 if no jobs free)
	AOS NJOBS(TAC)		;BUMP COUNT OF NUMBER OF PEOPLE POINTING TO HIM
	AOS (P)			;TAKE SUCCESS RETURN
SEGFIN:	CAMN J,JOB
NOKL10,<CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON	;CLEAR USER ARS
>;IFKL10
	POPJ P,

;routine to scan through all upper segments for one matching current job (J).
;skips on success, with found segment's job number in TAC.  Here from REMAP.
;Call with LH AC1 containing: 200000,,0 bit on if care about matching correct
;upper segment write protection; if 200000,,0 bit is on, 400000,,0 bit indicates
;desired state of write protection: on if want write-protected.
↑LNKCHK:PUSH P,J
	HRR AC1,J		;SAVE NUMBER OF MASTER JOB
	MOVE J,JOBNM1		;look through all jobs for a matching segment
DEFSE1:	MOVE TAC,JBTSTS(J)	;LOOK FOR AN UPPER.
	TLNN TAC,JSEG
	JRST DEFSE2		;NOT AN UPPER. SKIP IT.
	MOVE TAC,JOBNAM(J)
	MOVE TAC1,JOBPPN(J)
	CAMN TAC,JOBNAM(AC1)	;DOES THE JOB NAME MATCH?
	CAME TAC1,JOBPPN(AC1)	;AND DOES THE PPN MATCH?
	JRST DEFSE2		; NO
	LDB TAC,[POINT 1,JBTSTS(J),JWPPOS] ;GET WRITE PROTECT BIT FOR SEG
	ROT TAC,-1		;SHIFT JWP BIT TO SIGN BIT.
	XOR TAC,AC1		;COMPARE WITH USER'S ARGUMENT
	TLNE AC1,200000		;skip if don't care about write protect state
	JUMPL TAC,DEFSE2	;jump if wrong value of write protectedness
	MOVE TAC,JOBCRD(J)
	MOVE TAC1,JOBDEV(J)
	CAMN TAC,JOBCRD(AC1)	;DOES THE CREATION DATE AND PROTECTION MATCH?
	CAME TAC1,JOBDEV(AC1)	;AND DOES THE DEVICE MATCH?
	JRST DEFSE2		;NO
	MOVE TAC,JOBLOG(J)	;CHECK LOGICAL NAME TOO
	CAMN TAC,JOBLOG(AC1)
	PUSHJ P,ACCESS		;NOW, CAN WE LEGALLY ACCESS THIS SEGMENT?
	 JRST DEFSE2		;NO
	 CAI
	MOVE TAC,J		;return segment number in TAC
	POP P,J			;restore our job number
	JRST CPOPJ1		;success

DEFSE2:	SOJG J,DEFSE1
	POP P,J
	POPJ P,

↑MAKESEG:
	PUSHJ P,KILSEG
	PUSH P,J
	PUSHJ P,ESTSEG		;IF NO EXISTING ONE, MAKE ONE UP
	 JRST DEFSE3		;IF NOT AVAILABLE, JUST LEAVE
	MOVE TAC,J		;SAVE SEGMENT NUMBER
	POP P,J
	DPB TAC,PSEGN
IFN FTSTAT,<
	PUSHJ P,SEGSTT
>;FTSTAT
↑MAKSE2:AOS NJOBS(TAC)		;BUMP # PEOPLE POINTING TO HIM (CALLED FROM UNPURE)
	MOVE TAC1,JOBNAM(J)	; NOW ESTABLISH ITS CREDENTIALS
	MOVEM TAC1,JOBNAM(TAC)
IFN FTELOK,<
	CAMN TAC1,[SIXBIT /E/]
	MOVEM TAC,ESEGNO	;STORE JOB NUMBER OF E UPPER SEGMENT
>;IFN FTELOK
IFN FTSTAT,<
	PUSH P,J
	MOVE J,TAC
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
	MOVE TAC1,JOBPPN(J)
	MOVEM TAC1,JOBPPN(TAC)
	MOVE TAC1,JOBCRD(J)
	MOVEM TAC1,JOBCRD(TAC)
	MOVE TAC1,JOBDEV(J)
	MOVEM TAC1,JOBDEV(TAC)
	MOVE TAC1,JOBLOG(J)
	MOVEM TAC1,JOBLOG(TAC)
	POPJ P,
;KILSEG KILSE6 KILSE3 KILSE7 KILSE5 KILSE4 KILSE2 KILSE1 NZERR KILSE9

; ROUTINE TO KILL A HIGH SEGMENT
; ENTER WITH JOB NUMBER OF OWNER IN J
; IF OTHER PEOPLE POINT TO IT, IT WILL REMAIN
; IF NO-ONE ELSE POINTS TO IT, IT WILL GO AWAY

↑↑KILSEG:PUSHJ P,ZERPR2			;ZERO PAGE MAP ENTRIES IF THERE'S A JBTPR2
	JRST SEGFIN			;THERE WAS A JBTPR2 AND IT'S NOW ZERO
	MOVE TAC,J			;SAVE JOB NUMBER
	LDB J,PSEGN			;GET OUR SEGMENT NUMBER
	JUMPN J,KILSE6			;JUMP IF THERE IS A SEGMENT
	MOVE J,TAC			;THERE'S NO SEGMENT. FORGET IT
	POPJ P,

KILSE6:	PUSH P,TAC			;SAVE JOB NUMBER ON THE STACK
	PUSHJ P,ZSGMAP			;FLUSH THE SEGMENT FROM LOWER'S PAGE MAP
	PUSH P,J			;SAVE SEGMENT NUMBER.
	SKIPA J,JOBNM1			;SEARCH FOR ANY OTHERS POINTING HERE
KILSE3:	SOJLE J,KILSE1			;DECREMENT J. JUMP IF JOB LIST EXHAUSTED
	CAMN J,-1(P)			;IS THIS THE CURRENT JOB?
	JRST KILSE3			;YES. WE KNOW ABOUT HIM, SO SKIP IT.
	LDB TAC,PSEGN
	CAMN TAC,(P)			;DOES HE POINT TO OUR SEGMENT?
	JRST KILSE4			;YES. - DON'T KILL SEGMENT.
KILSE7:	SKIPN AC1,JBTDTS(J)		;DOES THIS GUY HAVE A DETACHED SEGMENT LIST?
	JRST KILSE3			;NO.
KILSE5:	LDB TAC,PDSEGN			;LOOK THRU DET SEG LIST
	JUMPE TAC,KILSE3		;JUMP WHEN DET SEG LIST IS EMPTY
	CAME TAC,(P)			;SAME AS THIS SEGMENT?
	AOJA AC1,KILSE5			;NO. KEEP LOOKING.
KILSE4:	POP P,J				;SOMEONE ELSE POINTS TO THIS SEGMENT
KILSE2:	SOSGE NJOBS(J)
	PUSHJ P,KILSE9			;MAKE LOSE MESSAGE.
	POP P,J				;POP CURRENT JOB NUMBER
	MOVEI TAC,0
	DPB TAC,PSEGN			;ZERO SEGMENT FIELD
IFN FTSTAT,<
	PUSHJ P,SEGSTT
>;FTSTAT
	JRST SEGFIN

;HERE IF THERE ARE NO FURTHER REFERENCES TO THIS SEGMENT.
KILSE1:	POP P,J				;GET THE SEGMENT NUMBER
	PUSHJ P,ZEROSEG			;EXPUNGE SEGMENT
	MOVE TAC,NJOBS(J)
	CAIE TAC,1			;THERE SHOULD BE ONLY 1 POINTER TO THIS
	PUSHJ P,NZERR
	JRST KILSE2

NZERR:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /NJOBS NOT 0 AT KILSE1
/
	POPACS
	POPJ P,


KILSE9:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /NJOBS NEGATIVE AT KILSE2
/
	POPACS
	SETZM NJOBS(J)
	POPJ P,
;ZERO5 ZEROSEG

;ROUTINE TO ERASE A SEGMENT ENTIRELY, SEGMENT'S JOB NUMBER IN J

ZERO5:	PUSHJ P,WSCHED			;WAIT FOR SPW TO STOP.
ZEROSEG:MOVEI TAC,0			;NEW SIZE DESIRED = 0
	PUSHJ P,CORE0			;GIVE BACK THIS SEGMENT'S CORE
	JRST ZERO5			;I/O OR SPACEWAR STILL ACTIVE
	PUSHJ P,UAPPLY			;CONTINUE SPACWAR FOR LOWERS
	 PUSHJ P,SPWCNT
	MOVSI TAC,JSEG!JWP!JNA!JLOG!JACCT!RUN
	ANDCAM TAC,JBTSTS(J)
IFN FTELOK,<
	CAMN J,ESEGNO
	SETZM ESEGNO			;FLUSHING E UPPER SEGMENT
>;IFN FTELOK
	SETZM JOBNAM(J)
	SETZM PRJPRG(J)
IFN FTNSWP,<
	PUSHJ P,RELSWP			;FLUSH SWAPPING SPACE
>;IFN FTNSWP
	JRST NOCORQ			;REQUE TO NULQ. ZERO JBTMAP, JBTSWP
;FLUSHSEG FLUSH1 FLUSH3 FLUSH6 FLUSH4 FLUSH5 FLUSH2 FLUSH7 FLUSH8 FLUSH9 DSFLUSH DSFL1

; ROUTINE TO FLUSH A JOB'S HIGH SEGMENT AND ALL THE SEGMENTS HE MAY HAVE
; PREVIOUSLY DETACHED, IF AND ONLY IF NO ONE ELSE IS POINTING AT THEM.
; CALL FROM UUO OR CLOCK LEVEL ONLY!!!!!!

↑↑FLUSHSEG:
	PUSHJ P,KILSEG			;KILL HIS IMMEDIATE UPPER
	SKIPN AC1,JBTDTS(J)		;IS THERE A DET SEG LIST?
	POPJ P,				;NO. THIS IS EASY.
	PUSH P,J			;SAVE CALLING JOB'S NUMBER
FLUSH1:	SKIPN J,(AC1)			;GET THE NUMBER OF THE DETACHED SEGMENT
	JRST FLUSH2			;JUMP IF THERE ARE NO MORE.
	JUMPL J,FLUSH6			;JUMP IF THIS IS SPECIAL DETACHED.
	MOVE TAC1,JOBNM1
	ANDI J,JOBNMK			;SEGMENT NUMBER ONLY (job field mask)
FLUSH3:	LDB TEM,[POINT JOBNSZ,JBTSTS(TAC1),35] ;DO OTHERS POINT HERE?
	CAMN TEM,J			;DIRECT MATCH?
FLUSH6:	AOJA AC1,FLUSH1			;YES. CAN'T BE FLUSHED.
	CAME TAC1,(P)			;DON'T MATCH AGAINST OUR OWN JOB
	SKIPN DAT,JBTDTS(TAC1)		;DOES THIS JOB HAVE A DETACH LIST?
	JRST FLUSH5			;NO, GO TO NEXT JOB
FLUSH4:	LDB TEM,[POINT JOBNSZ,(DAT),35]	;YES, PICK UP ITS SEGMENT NUMBER
	JUMPE TEM,FLUSH5		;JUMP IF END OF LIST
	CAMN TEM,J			;DOES HE POINT TO US?
	AOJA AC1,FLUSH1			;YES, CAN'T ZERO THIS SEGMENT
	AOJA DAT,FLUSH4			;NO, TRY NEXT DETACHED SEGMENT

FLUSH5:	SOJG TAC1,FLUSH3		;LOOP AROUND FOR NEXT JOB
	MOVE TAC,JBTSTS(J)		;NOW, DOES THIS SEGMENT STILL EXIST?
	TLNN TAC,JNA
	AOJA AC1,FLUSH1			;NO, DON'T BOTHER
	PUSH P,AC1
	PUSHJ P,ZEROSEG			;WIPE OUT THAT SEGMENT, NO OTHER REFS TO IT
	SKIPE NJOBS(J)
	PUSHJ P,NZERR
	POP P,AC1
	AOJA AC1,FLUSH1

FLUSH2:	POP P,J				;GET OUR JOB NUMBER BACK
	MOVE AC1,JBTDTS(J)		;SEARCH FOR SPECIAL DET SEG.
	MOVEI AC2,(AC1)			;AC1 POINTS AT HOLE. AC2 POINTS AT DATUM
FLUSH7:	SKIPLE TAC,(AC2)		;SKIP IF SPECIAL OR EMPTY
FLUSH8:	AOJA AC2,FLUSH7			;NORMAL DET SEG. GET NEW DATUM
	MOVEM TAC,(AC1)			;DATUM IS BUBBLED DOWN.
	JUMPE TAC,FLUSH9		;JUMP IF DONE.
	AOJA AC1,FLUSH8			;ADVANCE HOLE, ADVANCE DATUM.

FLUSH9:	CAME AC1,JBTDTS(J)		;IS HOLE IS STILL IN THE SAME PLACE?
	POPJ P,				;NO. WE STILL HAVE A DET SEG LIST.
	PUSHJ P,FSGIVE
	SETZM JBTDTS(J)
	POPJ P,

↑↑DSFLUSH:				;MAKE SPECIAL DET SEG INTO ORDINARY.
	SKIPN AC1,JBTDTS(J)
	POPJ P,
DSFL1:	MOVSI TAC,400000
	ANDCAB TAC,(AC1)
	JUMPE TAC,CPOPJ
	AOJA AC1,DSFL1
;UAPPLY UAPP1 UAPP2 UAPP3

;APPLY A ROUTINE TO ALL LOWERS OF AN UPPER.
;CALL:
;	MOVE J,<UPPER'S NUMBER>
;	PUSHJ P,UAPPLY
;	<INSTRUCTION TO XCT>	;J HAS LOWER'S NUMBER, DDB HAS UPPER'S NUMBER
;	RETURN HERE
;NO AC'S ARE CLOBBERED EXCEPT BY THE XCT'ED INSTRUCTION.
;DDB AND J SHOULD NOT BE USED TO RETURN ARGUMENTS, ETC.
;IF THE XCT'ED INSTRUCTION SKIPS, THE SCAN TERMINATES IMMEDIATELY

↑↑UAPPLY:	
	PUSH P,DDB
	PUSH P,J
	MOVEI J,JOBN-1
UAPP1:	LDB DDB,PSEGN		;GET NUMBER OF THIS LOWER'S UPPER
	CAMN DDB,(P)
	JRST UAPP3		;MATCHES.
UAPP2:	SOJG J,UAPP1
	POP P,J
	POP P,DDB
	JRST CPOPJ1

UAPP3:	PUSH P,J
	XCT @-3(P)		;J = JOB NUMBER OF LOWER, DDB = JOB NUMBER OF UPPER.
	JRST .+2
	SETZM (P)		;IF INSTR. SKIPS, STOP THIS PROCESS!
	POP P,J
	JRST UAPP2

BEND SEGCSS
;CTEXT CTEXT1 CTEX1 CTEX CTEXA CTXCNC GETLCCHR GETLC1

SUBTTL COMCSS

LOSYS

;RETURN NEXT ALPHANUMERIC STRING IN COMMAND LINE (SIXBIT)
;CALL:	MOVE TAC,BYTE POINTER TO PREVIOUS CHAR.
;	PUSHJ P,CTEXT
;SIXBIT STRING RETURNED LEFT JUSTIFIED IN TAC1


↑CTEXT:	PUSHJ P,SKIPS		;SKIP LEADING SPACES, TABS, NULLS, AND CLEAR TAC1
	CAIA
↑CTEXT1:PUSHJ P,SKIPS1		;DO NOT RETURN IF CR WAS PREVIOUS BREAK
	MOVE UCHN,[POINT 6,TAC1]
	LDB TEM,TAKR(DAT)
	ANDI TEM,177
	PUSHJ P,GETLC1		;CONVERT TO UPPERCASE.
CTEX1:	PUSHJ P,CTEX		;IS IT ALPHANUMERIC
	TRC TEM,40		;CONVERT TO SIXBIT
	TLNE UCHN,770000	;HAVE WE ACCUMULATED 6 CHARS?
	IDPB TEM,UCHN		;NOT YET.  STORE AWAY
	PUSHJ P,GETLCCHR	;GET UPPERCASE CHARACTER
	JRST CTEX1

;SCAN FOR ALPHANUMERIC CHAR IN TEM
CTEX:	CAIL TEM,"0"
	CAILE TEM,"Z"		;LETTERS ARE LARGER THAN NOS.
	JRST CTEXA		;NEITHER
	CAILE TEM,"9"
	CAIL TEM,"A"
	POPJ P,			;LETTER OR NUMBER RETURN
CTEXA:	CAIN TEM,":"		;DEVICE NAME?
	PUSHJ P,GETLCCHR	;YES, SKIP COLON
	JUMPN TEM,TPOPJ		;RETURN UP ONE LEVEL unless CTRL/C
CTXCNC:	MOVSI TAC1,'HAL'	;CUE UP A PHONY 'HALT'
	MOVEI TEM,12		;TERMINATE WITH LINE FEED
	DPB TEM,TAKR(DAT)	;STORE IN INPUT BUFFER DO ↑C NOT SEEN
	JRST TPOPJ		;AND RETURN UP A LEVEL


↑GETLCCHR:			;GET NEXT CHARACTER - MAKE IT UPPER CASE.
	PUSHJ P,GETCHR
GETLC1:	CAIG TEM,"Z"+40
	CAIGE TEM,"A"+40
	POPJ P,
	SUBI TEM,40
	POPJ P,
;SKIPSJ SKIPS SKIPS1 SKIPSA SKIPSB SKIPS2 SKIPS3 TYCRLF CRLF CONMES CON0

;IGNORE LEADING SPACES, TABS, AND NULLS.  CLEARS TAC1.
;DOES NOT RETURN IF PREVIOUS CHAR. OR NEXT NON-SPACING
;CHAR. IS CR (I.E., POPS SUBROUTINE LEVEL UP 1 ON RETURN)
;CALL:	MOVE TAC,<BYTE POINTER TO PREVIOUS BREAK CHAR.>
;	PUSHJ P,SKIPS1


↑SKIPSJ:PUSHJ P,SKIPS1		;BEWARE OF UPLEVEL RETURN
	POPJ P,

SKIPS:	PUSHJ P,GETLCCHR	;GET FIRST CHAR ON LINE
SKIPS1:	MOVEI TAC1,0		;FOR CTEXT AND DECIN
	LDB TEM,TAKR(DAT)	;IN CASE TEM IS CLOBBERED
	ANDI TEM,177
	CAIE TEM,"."		;IF A PERIOD, GET NEXT CHARACTER
	CAIN TEM,15		;SKIP TO LF IF CR.
SKIPSA:	PUSHJ P,GETLCCHR	;GET NEXT CHARACTER
SKIPSB:	JUMPE TEM,SKIPS3	;LEAVE IF NO MORE CHARS
	CAIN TEM,";"		;STOP HIM AT SEMI-COLON
	JRST SKIPS3		;MAKE IT LOOK LIKE END OF LINE
	PUSHJ P,SPCHEK		;IS THIS A SPECIAL CHAR?
	JRST SKIPS2		;NO
	TLNE TAC,BREAKB		;BREAK? END OF LINE?
	JRST SKIPS3		;YES, LEAVE
SKIPS2:	CAIG TEM,40		;SPACE OR CONTROL CHAR?
	CAIN TEM,14		;  (LET TTY ESC <FF> WORK)
	POPJ P,			;NO, RETURN
	JRST SKIPSA		;YES

SKIPS3:	JUMPE TEM,CTXCNC	;↑C?
	MOVEI TEM,12		;WE USE LINE FEEDS FOR BREAK CHARS
	JRST TPOPJ		;RETURN UP ONE LEVEL



;ROUTINE TO MOVE ASCIZ STRING TO USER'S TERMINAL OUTPUT BUFFER
;CALL:	MOVE DAT,BYTE POINTER TO LAST OUTPUT CHARACTER
;	MOVEI TAC,<ADDRESS OF ASCIZ MESSAGE>
;	PUSHJ P,CONMES 		;DOESN'T START TTY

;CALL:	MOVE DAT,BYTE POINTER TO OUTPUT
;	PUSHJ P,CRLF		;DOESN'T START TTY.

↑TYCRLF:			;TTYSER HAS ITS OWN CRLF
↑CRLF:	MOVEI TAC,[BYTE (7) 15,12,0]
↑CONMES:HRLI TAC,440700		;FORM ASCIZ BYTE POINTER
	PUSH P,TAC		;SAVE BYTE POINTER
CON0:	ILDB TEM,(P)		;GET NEXT CHAR.
	JUMPE TEM,TPOPJ		;IF NULL, RETURN UPLEVEL
	XCT TYO
	JRST CON0
;COMEND COMERP COMERA COMERR COMERL COMER1 ERRMES

;APPEND A "?" TO INPUT STRING AND SET AS OUTPUT.
;CALLED FROM OCTIN, RETURNS TO SECOND LEVEL ON PDL
;CALL:	MOVE TAC, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ P,COMERA


↑COMEND:PUSHJ P,SKIPS1		;IF ANYTHING LEFT IN INPUT LINE, FALL INTO COMERA
↑COMERP:POP P,UCHN		;REMOVE SUBROUTINE RETURN BEFORE CALLING COMERA
↑COMERA:PUSHJ P,GETCHR


;REPLACE LAST CHARACTER IN INPUT STRING BY "?" AND SET AS OUTPUT.
;CALL:	MOVE TAC,<BYTE POINTER TO LAST CHAR. IN INPUT STRING>
;	PUSHJ P,COMERR

↑COMERR:MOVE UCHN,TITCTR(DDB)	;SAVE POSITION IN SCAN
	PUSHJ P,TRESCN		;BACK UP TO START OF COMMAND
COMERL:	PUSHJ P,GETCHR		;GET A CHARACTER FROM COMMAND LINE
	JUMPE TEM,COMER1	;QUIT ON NULL HERE!
	CAIE TEM,15		;QUIT AT CR
	CAMN UCHN,TITCTR(DDB)	;HAVE WE PASSED A BAD CHAR YET?
	JRST COMER1		;YES
	PUSHJ P,OUTCHS		;NO, TYPE CHARACTER
	JRST COMERL		;AND LOOP FOR ANOTHER

COMER1:	PUSHJ P,SETBFI		;CLEAR ANY MORE TYPE IN
	MOVEI TEM,"?"		;APPEND ? TO ERRONEOUS WORD
	PUSHJ P,OUTCHS		;AND PRINT IT
	MOVSI J,NOJOBN!NOINCK	;NOW WE PAINSTAKINGLY FAKE OUT COMRET
	IORM J,-1(P)		;*** IF YOU CALL COMERR FROM ANYPLACE THAT
	MOVSI J,NOPER!NOCRLF	;*** DOESN'T HAVE COMRET NEXT ON THE PDL
	ANDCAM J,-1(P)		;*** BOY ARE YOU IN BAD TROUBLE!
	MOVEI J,0		;CLEAR JOB NUMBER
	JRST CRLF

↑ERRMES:MOVEI J,0		;CLEAR JOB NUMBER TO INDICATE ERROR
	JRST CONMES
;INLMES PRQM PRSPC NOTENF PRCRCC PRCNTC PRPER

;PRINT INLINE ASCIZ MESSAGE
;CALL:	PUSHJ P,INLMES
;	ASCIZ /THE MESSAGE/
;RETURN TO NEXT LOC AFTER MESSAGE


↑INLMES:
;	CAIN DDB,SCNDDB
;	JRST INLMEC		;print on CTY via disaster buffer
	POP P,TAC			;SETUP PRINT ADDRESS FOR CONMES
	PUSHJ P,CONMES
	JRST 1(TAC)			;RETURN TO NEXT LOC AFTER MESSAGE

;INLMEC:	POP P,AC1		;adr of error message
;	PUSHJ P,DISSTR		;print on CTY
;	JRST 1(TAC)		;return to loc after ASCIZ string

;TYPE "? " FOR ERROR MESSAGE
;CALL:	PUSHJ P,PRQM
;	RETURN

↑PRQM:	MOVEI TEM,"?"
	XCT TYO
	MOVEI TEM," "
	XCT TYO
	POPJ P,

PRSPC:	MOVEI TAC,[ASCIZ /    /]	;PRINT 4 SPACES.
	JRST CONMES


;PRINT "TOO FEW ARGUMENTS"
;CALL:	MOVE DAT,<OUTPUT BYTE POINTER>
;	PUSHJ P,NOTENF

↑NOTENF:JSP TAC,ERRMES
	ASCIZ /Too few arguments
/

;ROUTINE TO PRINT A PERIOD
;CALL:	PUSHJ P,PRPER


↑PRCRCC:PUSHJ P,CRLF
↑PRCNTC:PUSHJ P,INLMES
	ASCIZ /↑C
/
↑PRPER:	MOVEI TEM,"."
	JRST OUTCHS
;DEASG DEASTY DEA1 KILALL KILAL1 KILAL2

;ROUTINE TO DEASSIGN A DEVICE
;CALL:	MOVE DDB,DEVICE DATA BLOCK
;	MOVE J,JOB NUMBER
;	PUSHJ P,DEASG
;	<NOT PREVIOUSLY ASSIGNED BY CONSOLE>
;	<RETURN WITH DEVICE DEASSIGNED>

↑DEASG:	LDB UCHN,PJOBN		;WAS DEVICE ASSIGNED TO THIS JOB?
	CAME UCHN,J
	POPJ P,			;NO, RETURN
	PUSH P,J		;SAVE JOB NUMBER
	MOVSI UCHN,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAM UCHN,DEVMOD(DDB)
	SETZM DEVLOG(DDB)	;CLEAR LOGICAL NAME
	MOVEI TAC1,ASSCON	;IS DEVICE ASSIGNED BY CONSOLE?
	TDNE TAC1,DEVMOD(DDB)
	AOS -1(P)		;ASSIGNED BY CONSOLE.  DO OK RETURN
	PUSHJ P,RELEA6		;CLEAR JOB NO. IN DDB IF DDB NOT NEEDED
	POP P,J			;BY THIS JOB ANY MORE
	POPJ P,

;ROUTINE TO DEASSIGN ALL DEVICES EXCEPT LOGICAL TTY
;CALL:	MOVE J,<JOB NUMBER>
;	MOVE DDB,<ADR. OF DEVICE NOT TO BE DEASSIGNED>
;	PUSHJ P,DEASTY


↑DEASTY:
	ANDI DDB,-1		;CLEAN OUT THE LH SHIT
	PUSH P,DDB		;SAVE DDB ADDRESS
	HLRZ DDB,DEVLST		;SEARCH ALL DDB'S
DEA1:	CAME DDB,(P)		;IS THIS DEVICE NOT TO BE DEASSIGNED?
	PUSHJ P,DEASG		;NO, TRY TO DEASSIGN IT
	JFCL			;IGNORE IF CAN'T
	HLRZ DDB,DEVSER(DDB)
	JUMPN DDB,DEA1
	POP P,DDB		;RESTORE TTY DDB ADDRESS
	POPJ P,

;ROUTINE TO RELEASE ALL DEVICES BELONGING TO A JOB WITH NO CORE IN ORDER TO
;KILL IT

↑KILALL:ANDI DDB,-1
	PUSH P,DDB
	HLRZ DDB,DEVLST
KILAL1:	LDB TAC,PJOBN		;WHOSE DDB?
	MOVE DSER,DEVSER(DDB)	;GET DISPATCH AND NEXT DDB
	CAME DDB,(P)		;AND IS IT THE TTY WHICH WE WANT TO KEEP?
	CAIE TAC,(J)
	JRST KILAL2		;NOT MINE, OR TTY
	PUSH P,DSER		;SAVE IN CASE OF ANDY MOORER
	PUSHJ P,DRL(DSER)	;DEVICE-DEPENDENT RELEASE
	MOVEI TAC1,ASSCON!ASSPRG
	PUSHJ P,RELEA6		;FLUSH DDB
	POP P,DSER
KILAL2:	HLRZ DDB,DSER		;NEXT
	JUMPN DDB,KILAL1
	POP P,DDB
	POPJ P,
;DECIN1 DECIN OCTINS OCTIN ANYRIN OCT0

;READ CONSOLE AND CONVERT ANY RADIX NUMBER
;CALL:	MOVE DSER,<DESIRED RADIX>
;	PUSHJ P,ANYRIN
;	<NO ARG. TYPED RETURN, TAC1=0>
;	<ILLEGAL CHARACTER RETURN>
;	<NORMAL EXIT>		;TAC1 RETURNS NUMBER
;
;SCAN STOPS ON FIRST CR,HYPHEN,SPACE,TAB OR ILLEGAL CHAR.
;IF IT IS ILLEGAL CHAR.,SUBROUT. LEVEL IS POPED AND COMERA IS CALLED
;WHICH PRINTS MONITOR COMMAND ERROR. THUS CALLER NEVER SEES RETURN
;SKIPS LEADING SPACES AND TABS



↑DECIN1:
↑DECIN:	MOVEI DSER,=10		;DECIMAL INPUT
	JRST ANYRIN

↑OCTINS:PUSHJ P,GETLCCHR	;SKIP PRECEEDING + OR -
↑OCTIN:	MOVEI DSER,10		;OCTAL INPUT
ANYRIN:	PUSHJ P,SKIPS1		;SKIP LEADING SPACES, TABS, NULLS
				;DO NOT RETURN IF CR WAS PREVIOUS BREAK
				;OR THIS BREAK
OCT0:	CAIE TEM,12		;LF IS A DELIMITER TOO
	CAIL TEM,175		;ALT MODE?
	JRST CPOPJ2
	CAIE TEM,";"		;SEMICOLON?
	CAIN TEM," "		;SPACE?
	JRST CPOPJ2		;YES, SKIP RETURN
	CAIE TEM,"-"		;NO, DASH?
	CAIN TEM,15		;CR?
	JRST CPOPJ2		;YES
	CAIE TEM,","		;COMMA?
	CAIN TEM,"["		;LEFT BRACKET?
	JRST CPOPJ2		;YES.
	CAIN TEM,11		;tab is OK
	JRST CPOPJ2
	SUBI TEM,60
	JUMPL TEM,CPOPJ1	;ERROR IF NEG.  GIVE THE 1 SKIP RETURN.
	CAIL TEM,(DSER)		;OR .GE. RADIX
	JRST CPOPJ1		;ERROR, GREATER OR EQUAL TO RADIX
	IMULI TAC1,(DSER)
	ADD TAC1,TEM
	XCT CONTYI		;GET ANOTHER CHAR
	JRST OCT0
;PJPGNO PJPG1 PJPG2 NBRPPN

;GET PROJECT-PROGRAMMER NUMBERS
;CALL:	MOVE TAC,<INPUT BYTE POINTER>
;	PUSHJ P,PJPGNO
;	<ERROR RETURN>
;	OK RETURN
;
;(AC2)LH ← PROJECT NUMBER
;(AC2)RH ← PROGRAMMER NUMBER

PJPGNO:	PUSHJ P,SKIPS1		;SKIP LEADING BLANKS.
	CAIE TEM,"["		;IS THERE A [?
	POPJ P,			;NO. NO PPN.
	PUSHJ P,PJPG1		;READ PROJ. "NUMBER".
	HLL AC2,TAC1
	CAIE TEM,","		;SHOULD BE FOLLOWED BY A COMMA.
	JRST PJPG2
	PUSHJ P,PJPG1		;NOW PROG. NO.
	HLR AC2,TAC1
	CAIN TEM,"]"		;] IS OPTIONAL.
	PUSHJ P,GETLCCHR	;THROW IT AWAY IF PRESENT.
	JRST CPOPJ1

PJPG1:	PUSHJ P,CTEXT		;SCAN NEXT THING.
	JUMPE TAC1,TPOPJ	;RETURN UPLEVEL IF NOTHING.
	TLNN TAC1,7777
	LSH TAC1,-14		;JUSTIFY NOW IN CASE SKIPSB DOESN'T COME BACK
	TLNN TAC1,77
	LSH TAC1,-6
	PUSHJ P,SKIPSB		;MAKE SURE WE SEE TERMINATOR.
	POPJ P,			;PROGRAM BUMMERS BEWARE OF UPLEVEL RETURN!

PJPG2:	CAIE TEM,12		;TERMINATED BY LF?
	POPJ P,			;NO.  THEN WASN'T A GOOD PPN
	SKIPN TAC1,DSKPPN(J)	;COPY PRG FROM APPROPRIATE PLACE
	MOVE TAC1,PRJPRG(J)
	HRR AC2,TAC1
	JRST CPOPJ1

;ROUTINE TO READ A JOB NUMBER AND OPTIONAL PPN FOR MONITOR COMMAND.
;DOES NOT RETURN IF GIVEN JOB NUMBER IS NOT LOGGED IN
; OR IF PPN DOESN'T MATCH THAT OF GIVEN JOB.
;FOUR POSSIBLE RETURNS:
;	PUSHJ P,NBRPPN		;GET JOB NUMBER AND PPN
;	 <NON-DIGIT IS LEADING NON-BLANK CHAR>
;	 <NO ARGUMENT GIVEN>
;	 <JOB NUMBER IS THAT OF AN UPPER SEGMENT>
;	<NORMAL RETURN, JOB NUMBER IN TAC1, PPN IN AC2>

NBRPPN:	PUSHJ P,DECIN		;GET JOB NO.
	 AOS (P)		;NO NUMBER SPECIFIED
	 POPJ P,		;ILLEGAL CHAR IN NUMBER
	POP P,AC1		;RETURN ADDRESS
	JUMPLE TAC1,NOTLOG	;MAKE SURE JOB NUMBER IS REASONABLE
	CAIL TAC1,JOBN		;IS JOB NUMBER TOO BIG?
	JRST NOTLOG		;ILLEGAL JOB NUMBER.  PRINT NO SUCH JOB
	MOVE AC2,JBTSTS(TAC1)	;HAS THIS JOB NO BEEN ASSIGNED?
	TLNN AC2,JNA
	JRST NOTLOG		;NO, PRINT NO SUCH JOB
	TLNE AC2,JSEG		;IS THIS A SEGMENT?
	JRST 2(AC1)		;YES, DOUBLE SKIP RETURN
	PUSH P,TAC1		;SAVE JOB NO.
	PUSHJ P,PJPGNO		;GET PROJ.-PROG. NOS. ARG
	MOVE AC2,PRJPRG(J)	;NO PP NO. USE CURRENT ONE
	POP P,TAC1		;RESTORE
	CAME AC2,PRJPRG(TAC1)	;MATCHES THE DETACHED JOB'S PPN?
	JRST ATT3		;NO - ERROR
	JRST 3(AC1)		;SUCCESS RETURN, JOB NUMBER IN TAC1, PPN IN AC2
;ADRTST APRILM APRIL2 APRIL1 APRJRS APRNXM PDLAPR APRCNS APRSCD APRPBL UERROR CERROR

SUBTTL ERRCON	4 AUG 67

;THESE ERROR ROUTINE PRINT "ERROR IN JOB N"
;FOLLOWED BY AN APPROPRIATE ERROR MESSAGE
;THEN THE JOB IS STOPPED AND CONSOLE IS RETURNED TO
;MONITOR COMMAND MODE

;ADRTST - SKIP IF TAC CONTAINS A LEGAL ADDRESS.
;NEEDS J, PID SETUP. CLOBBERS TAC1.
ADRTST:	MOVEI TAC1,(J)
	PUSHJ P,CORSGT		;TAC1←CORE SIZE OF LOWER
	CAMGE TAC,TAC1		;SKIP IF PC OUTSIDE OF LOWER
	JRST CPOPJ1		;PC IN BOUNDS.
	TRNN TAC,400000		;PC IN UPPER?
	POPJ P,			;NO.  OUT OF BOUNDS
	PUSH P,TAC		;SAVE SUSPECT PC.
	MOVE TAC,TAC1		;TAC←FIRST ADDRESS ABOVE LOWER
	CAIGE TAC,400000	;IF THAT'S GREATER THAN 400000 THEN IT'S FIRST
	MOVEI TAC,400000	;    LOC. IN UPPER, ELSE 400000 IS FIRST IN UPPER
	LDB TAC1,PSEGN		;IS THERE AN UPPER?
	JUMPE TAC1,TPOPJ	;IF NOT, THEN PC IS OUT OF BOUNDS
	PUSHJ P,CORSGT		;TAC1←SIZE OF UPPER IN WORDS
	ADD TAC1,TAC		;TAC1←FIRST LOC BEYOND THE UPPER.
	POP P,TAC		;GET TARGET PC AGAIN
	CAMGE TAC,TAC1		;SKIP IF PC IS WITHIN THE UPPER.
	AOS (P)			;WITHIN BOUNDS
	POPJ P,			;PC OUT OF BOUNDS.

;APR DETECTED ERRORS
;PUSHDOWN OVERFLOW,ILLEGAL MEMORY, NONEXISTENT MEMORY
;FOR WHICH THE USER IS NOT ENABLED.
;SEE APRSER TO SEE HOW APR INTERRUPTS ARE HANDLED
;CALL:	SKIPE TAC,APRERR	;RESULT OF CONI APR,APRERR
;	PUSHJ P,APRILM		;FROM CLK SERVICE ROUT.(LOWEST PRIOTITY PI)
;	RETURN TO RESCHEDULE NEW USER

↑APRILM:SETZM APRERR		;ZERO ERROR FLAG
	MOVE J,JOB		;BLAME CURRENT JOB, WHOMEVER IT MAY BE
	TRNN TAC,ILM		;ILLEGAL MEMORY REFERENCE?
	JRST APRNXM		;NO
	MOVE TAC,APRPC
	TLNN TAC,USRMOD
	JRST APRIL1		;MPV FROM EXEC MODE PC. (SHIT)
APRIL2:	HRRZ TAC,TAC
	PUSHJ P,ADRTST		;SEE IF PC IS OUT OF BOUNDS (OTHERWISE, NORMAL ILM)
	JRST APRJRS		;PC OUT OF BOUNDS
APRIL1:	JSP TAC,ERRPNT
	ASCIZ /Ill mem ref/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

APRJRS:	JSP TAC,ERRPNT
	ASCIZ /PC exceeds mem bounds/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

APRNXM:
IFE FTF2,<
	TRNN TAC,NXM		;NX MEM?
	JRST PDLAPR		;NO
	JSP TAC,ERRPNT		;YES
	ASCIZ /Non ex mem/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

PDLAPR:
>;IFE FTF2
	TRNN TAC,POV		;PUSHDOWN OVERFLOW?
	JRST APRCNS		;NO
	JSP TAC,ERRPNT		;YES
	ASCIZ /Pdl ov/
	JRST APRSCD

APRCNS:	TRNN TAC,CNS		;CONS TRAP?
	JRST APRPBL		;NO
	JSP TAC,ERRPNT
	ASCIZ /Cons trap/
APRSCD:	MOVE TAC1,APRPC		;PRINT APR PC 
	JRST PCPNT

APRPBL:
IFKL10,<
	TLNN TAC,PCPUBL		;PROPRIETARY VIOLATION?
>;IFKL10
	JSP DAT,UERROR		;NO. HARDWARE PROBLEM.
IFKL10,<
	JSP TAC,ERRPNT
	ASCIZ /Proprietary violation (Public bit set in PC)/
	JRST APRSCD
>;IFKL10

;UERROR IS FOR UUO LEVEL, BLAMES CURRENT JOB
;CERROR IS FOR CLOCK LEVEL AND LOSES

↑UERROR:MOVE J,JOB		;PRINT FOR CURRENT JOB NUMBER
↑CERROR:JSP TAC,ERRPNT		;J ALREADY SET UP "?ERROR IN JOB CRLF"
	ASCIZ /Error in monitor/
	MOVE TAC1,-1(P)		;GET LOC OF JSP DAT,ERROR
	JRST PCPNT		;PRINT PC AND STOP JOB
;PIERR1 PIERR3 P2ADCK P2ADC1 P2ADC2

;CALL:	JSR PIERR
;
;TYPES "ERROR IN MONITOR" FOLLOWED BY CONTENTS OF DAT.  HALTS


↑PIERR1:MOVEM PID,ESVPID	;SAVE PID
	MOVEI PID,P1PID
PIERR3:	MOVEM P,ERRPD		;SAVE IT WHERE WE CAN FIND IT
	MOVE P,ERRPDL
	AOBJN P,.+1
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /MONITOR ERROR AT /
	MOVE TAC,PIERR
	SUBI TAC,1
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,DDTCALL
	HALT AUTOLOAD		;THIS IS A LOSE ALWAYS NOW

IFN FTP2,<
;CALL:	MOVEI TAC,ADDR
;	PUSHJ P,P2ADCK
;	 <ERROR RETURN>
;	<OK RETURN>
;
;This routine takes an address which is supposed to be in P2COMM and
;makes sure it really is.  It's useful for checking addresses which
;came from P2 pointers, in case someone has clobbered P2 core.
;If the address being checked is not OK, the routine stops P2 and,
;if called from UUO level, it calls WSCHED, which won't return if
;the job is using a P2 device because it will be hung stopped.
;The address to be checked should be a P2 address space address, not
;a P1 (offset by P2VORG) virtual address.

↑P2ADCK:CAIL TAC,240		;IS THIS ADDR NEGATIVE OR IN THE PROTECTED P2 AREA?
	CAIL TAC,P2MNUM⊗9	;OR IS IT OUTSIDE THE SHARED SPACE?
	JRST P2ADC1		;YES, LOSE
	SETZM P2ADBD		;FLAG A WINNING CALL
	JRST CPOPJ1

P2ADC1:	SETZM P2NUM		;LOSING, TRY TO TURN OFF P2
	SETZM DETFLG		;IN ANY CASE, DON'T TRY TO USE IT ANYMORE
	PUSHJ P,HNGP2D		;GIVE HUNG TIMEOUTS TO ITS DEVICES
	SETZM HNGTIM		;GET QUICK DEVCHK
	SKIPE P2ADBD		;HAVE I ALREADY RELOADED?
	JRST P2ADC2		;YES, DON'T KEEP TRYING
	SETOM P2ADBD		;FLAG THAT IT'S BEEN DONE
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES		;TELL SOMEONE
	ASCIZ /πP2ADCK bad addressπ, I'll try to reload P2.
/
	MOVEI TAC,['P2LOAD'↔'  1  2'↔<REAPRV!ACWPRV,,0>↔0]
	PUSHJ P,FIREUP
	 JFCL			;TOUGH
P2ADC2:	CONSO PI,77400		;UUO LEVEL?
	JRST WSCHED		;YES, MAYBE THIS WON'T RETURN (HUNG DEVICE)
	POPJ P,
>;IFN FTP2
;NCUBG2 UUOER4 UUOERR UUOER3 UUOER1 UUOE2A UUOER2

IFN FTNCU,<
NCUBG2::	;beginning address of special code we don't want cached
>;IFN FTNCU

;ILLEGAL UUO  - CALLED AT ANY LEVEL!

;here if error in UUO called from user level
UUOER4:	MOVE TAC1,JBTPDL(J)	;get job's pdl base
	ADD TAC1,[JBTPLN,,JBTPLN] ;adjust to end of job's uuo pdl
	CAML P,JBTPDL(J)	;skip if pdl ptr precedes job's pdl
	CAML P,TAC1		;skip if pdl ptr is within job's pdl
	MOVE P,JBTPDL(J)	;pdl ptr not in pdl, reset to job's pdl
	JRST UUOER1

↑UUOERR:ERRSPW			;IF SPACEWAR MODE, JUMP TO SPWERR
	MOVEI PID,P1PID
	MOVEM J,TSAVJ		;SAVE J
	MOVE J,JOB		;SOMETIMES NOT SET UP BY DPYSER
	MOVE TAC,@UUOLOC	;get the offending UUO
	MOVEM TAC,TSAVUU	;save UUO for printing below
	MOVE TAC1,UUOPC(J)	;get UUO's PC (+1)
	JUMPE J,UUOER3		;jump if null job
	TLNE TAC1,USRMOD	;skip if uuo called from exec
	JRST UUOER4		;USER MODE CALL
UUOER3:	MOVEM P,ERRPD		;UUO FROM EXEC, STORE LOSER'S P in new stack
 	MOVE P,ERRPDL		;get a good pdl for processing error
	ADD P,[1,,1]		;simulate push (old P just now stored there)
UUOER1:	JSP TAC,ERRPTU		;RETURNS WITH DAT AND DDB PUSHED
	ASCIZ /Illegal UUO (/
	MOVE TAC,TSAVUU		;GET THE UUO THAT DID IT
	PUSHJ P,OCTPND		;print on user terminal or CTY disaster buffer
	MOVEI TEM,")"
;	CAIN DDB,SCNDDB		;TYO now fixed to use DISTYO if CTY....
;	PUSHJ P,DISTYO
;	CAIE DDB,SCNDDB
	XCT TYO
	MOVE TAC1,UUOPC(J)	;GET LAST UUO PC
	TLNE TAC1,USRMOD	;USER ERROR?
	SOJA TAC1,PCPNT
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /Ill UUO from EXEC at UUO level
UUO at /
	MOVE TAC,UUOPC(J)
	MOVEI TAC,-1(TAC)
	PUSHJ P,DISOCH
	PUSHJ P,DISTAB
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / UUOOPC = /
	MOVE TAC,UUOOPC(J)
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /  P= /
	MOVE TAC,ERRPD
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ/
JBTLIN = /
	MOVE TAC,JBTLIN(J)
	PUSHJ P,DISOCH
	HRRE TAC,JBTLIN(J)
	JUMPL TAC,UUOE2A
	CAIL TAC,TTPLEN
	JRST UUOE2A
	PUSH P,TAC
	PUSHJ P,DISMES
	ASCIZ/   LINTAB(JBTLIN) = /
	POP P,TAC
	MOVE TAC,LINTAB(TAC)
	PUSHJ P,DISOCH
UUOE2A:	CAMN J,TSAVJ
	JRST UUOER2
	PUSHJ P,DISMES
	ASCIZ /  J was: /
	MOVE TAC,TSAVJ
	PUSHJ P,DISOCH		;ONLY MAKES SENSE IN DECIMAL IF A JOB NUMBR
UUOER2:	PUSHJ P,DISMES
	ASCIZ/
(Will continue by finishing UUOERR)
/				;REMIND WIZARD THAT THIS IS PART OF UUOERR!
	PUSHJ P,SYSFIX
	 JFCL			;NO ERRORS
	 JFCL			;FOUND TROUBLE, BUT COULDN'T FIX IT!
	PUSHJ P,DISFLUSH	;TELL THE WORLD
	POPACS
	PUSHJ P,WDDTCALL
	MOVE TAC1,UUOPC(J)
	SOJA TAC1,PCPNT		;ALWAYS TRY JUST FLUSHING LOSER

;ILLINS ILLIN1 ILLIN1 HALT ILLTAB ILLTLN $DSUB $DADD $DADD1 $DMUL $DMUL1 $N1FLG $CRY1 $CRY2 $DFMP $DFMP1 $DFMP2 $DFMP3 $EXPN $SWITCH $ARG $DFSB $DFAD $DFSB1 $DFAD1 $DFAD2 $DFAD4 $DFAD3 $DFAD5 $DFAD6 $DFA15 $DFAD7 $DFAD9 $DFA13 $DFAD8 $DFA14 $DFA10 $DFA11 $DFA12 $DMOVEM $KIFIX $FIXR $FIXR0 $FIXR1 $FLTR $FLTR3 $FLTR4 $FLTR2 $FLTR6 $FLTR7 $FLTR5 $FLTR1 $DFDV $DFDV1 $DFDV3 $DFDV5 $DFDV4 $DFDV6 $DFDV2 $DFDV7

;ILLEGAL INSTRUCTION
;HALT INSTRUCTION IS A SPECIAL CASE WHICH STOPS JOB BUT
;THE USER MAY CONTINUE FROM IT (EFFECTIVE ADR.)
;CALLED AT UUO LEVEL WITH A JRST


↑ILLINS:HLRZ TAC,UUO		;ILLEGAL OPCODE
	ANDI TAC,777600		;LOOK AT OPCODE AND HIGH 2 AC BITS
	CAIN TAC,(<JRST 4,>)	;IS IT A HALT? (JRST 14, IS ILLEGAL)
	JRST HALT		;YES, PRINT DIFFERENT MESSAGE

IFKL10,<
	LDB TAC,[POINT 9,UUO,8]	;GET THE OPCODE
	MOVSI AC3,-ILLTLN	;LENGTH OF TABLE OF OLD INSTRUCTIONS
	PUSH P,[USRXT0]		;(IN CASE WE FIND ONE) SIMULATION WILL POPJ
ILLIN1:	LDB TAC1,[POINT 9,ILLTAB(AC3),8] ;ILLTAB IS IN KLSER
	CAMN TAC1,TAC
	JRST @ILLTAB(AC3)	;SIMULATE OLD INSTRUCTION
	AOBJN AC3,ILLIN1	;LOOP, LOOKING THRU OLD TABLE
	SUB P,[1,,1]		;FAILED.  FLUSH "RETURN" FROM STACK
>;IFKL10

IFN FTF2,<
	LDB TAC,[POINT 9,UUO,8]	;GET THE OPCODE
	MOVSI AC3,-ILLTLN	;LENGTH OF TABLE OF OLD INSTRUCTIONS
	PUSH P,[USRXT0]		;(IN CASE WE FIND ONE) SIMULATION WILL POPJ
ILLIN1:	LDB TAC1,[POINT 9,ILLTAB(AC3),8] ;ILLTAB IS AT THE BOTTOM OF THIS PAGE
	CAMN TAC1,TAC
	JRST @ILLTAB(AC3)	;SIMULATE OLD INSTRUCTION
	AOBJN AC3,ILLIN1	;LOOP, LOOKING THRU OLD TABLE
	SUB P,[1,,1]		;FAILED.  FLUSH "RETURN" FROM STACK
>;IFN FTF2

	JSP TAC,ERRPTU
	ASCIZ /Illegal Instruction (/
	MOVE TAC,UUO
	PUSHJ P,OCTPND		;print on user terminal or CTY disaster buffer
	MOVEI TEM,")"
	XCT TYO
	JRST UUOPCP		;PRINT UUO PC AND STOP JOB

↑HALT:	MOVE J,JOB		;PICK UP JOB NUMBER
	PUSHJ P,TTYERP		;SET TTY IN MONITOR MODE
	PUSHJ P,INLMES
	ASCIZ /Halt/
IFE FTF2,<
	SOS TAC1,UUOPC(J)	;UUOPC = LOCATION OF HALT PLUS ONE
>;IFE FTF2
IFN FTF2,<
	MOVE TAC1,UUOPC(J)	;UUOPC = LOCATION OF HALT
>;IFN FTF2
	PUSHJ P,PCP		;PRINT "USER LOC XXX"
	PUSHJ P,PRCRCC		;PRINT MONITOR MODE RESPONSE (CRLF ↑C .)
	HRRM UUO,UUOPC(J)	;SAVE EFFECTIVE ADDRESS OF HALT
	PUSHJ P,TTYSTC		;START TTY TYPING
	PUSHJ P,SETSTP		;STOP JOB, BUT FINISH THIS UUO
	SKIPN INTACT		;ILLEGAL AT INTERRUPT LEVEL
	JRST USRXIT		;"RETURN" TO ADDRESS OF HALT (WILL NEVER GET THERE)
	JRST ESTOP		;FLUSH USERS WHO HALT AT USER INTERRUPT LEVEL

IFN FTF2,<
;ILLTAB - SIMULATION OF OLD INSTRUCTIONS  - (CALLED FROM ILLINS IN COMCSS)

ILLTAB:	DADD $DADD
	DSUB $DSUB
	DMUL $DMUL	; NO DDIV YET
	DFAD $DFAD
	DFSB $DFSB
	DFMP $DFMP
	DFDV $DFDV
	DMOVEM $DMOVEM	; TEMPORARY FIX FOR UCODE BUG
	FIXR $FIXR	; FIX AND ROUND
	KIFIX $KIFIX	; FORTRAN-STYLE FIX
	FLTR $FLTR	; FLOAT AND ROUND
↑ILLTLN←←.-ILLTAB

$DSUB:	XCTR XR,[DMOVN AC1,(UUO)]
	JRST $DADD1

$DADD:	XCTR XR,[DMOVE AC1,(UUO)]
$DADD1:	XCTR XR,[DMOVE TAC,(UCHN)]
	TLZ TAC1,400000		; ASSUME TAC-TAC1 CONTIGUOUS
	TLZ AC2,400000		; AND AC1-AC2
	ADD TAC1,AC2
	ADD TAC,AC1
	TLZE TAC1,400000
	ADDI TAC,1
	TLNE TAC,400000;
	TLO TAC1,400000;
	XCTR XW,[DMOVEM TAC,(UCHN)]
	POPJ P,

; ASSUMES TAC-TAC1, PROG-TEM, AC1-AC2, and DDB-DAT ARE CONTIGUOUS

IFN DAT-DDB-1,<.FATAL ACs DDB and DAT are not contiguous as required here.>
IFN TEM-PROG-1,<.FATAL ACs PROG and TEM are not contiguous as required here.>
$DMUL:	XCTR XR,[DMOVE DDB,(UCHN)]	; ASSUME THAT DDB-DAT ARE CONTIGUOUS
	TLZ DAT,400000
	XCTR XR,[DMOVE PROG,(UUO)]	; ASSUME THAT PROG-TEM CONTIGUOUS
	TLZ TEM,400000

	MOVEI DSER,0	; ACCUMULATE CARRIES HERE
	MOVE TAC,DAT	; PICK UP L.O.B.
	MUL TAC,TEM	; PRODUCT OF LOB IN TAC-TAC1
	TLZ TAC1,400000	; CLEAR OUT SIGN BIT

	MOVE AC1,DDB	; H.O.B.
	MUL AC1,TEM	; CROSS PRODUCT IN AC1-AC2
	TLZ AC2,400000	; WITHOUT SIGN, THANK YOU
	ADD TAC,AC2	; ACCUMULATE PARTIAL SUM
	TLZE TAC,400000	; ANY CARRY?
	ADDI AC1,1	; YES, ADD IT IN NOW
	MOVE AC3,AC1	; SAVE HOB HERE FOR NOW
	TLZE AC3,400000	; NEGATIVE?
	SUBI DSER,1	; YES, EXTEND SIGN

	MOVE AC1,DAT
	MUL AC1,PROG	; NEXT CROSS-PRODUCT
	TLZ AC2,400000	; NO SIGN PLEASE
	ADD TAC,AC2	; LOW ORDER BITS FIRST
	TLZE TAC,400000	; CARRY?
	ADDI AC3,1	; YES
	TLZE AC1,400000	; NEGATIVE?
	SUBI DSER,1	; YES, SIGN EXTEND
	ADD AC3,AC1
	TLZE AC3,400000	; CARRY?
	ADDI DSER,1	; YES

	MOVE AC1,DDB	; HOB PRODUCT
	MUL AC1,PROG
	TLZ AC2,400000
	ADD AC3,AC2
	ADD DSER,AC1
	TLZE AC3,400000	; CARRY?
	ADDI DSER,1	; YES

	TLNN DSER,400000
	JRST $DMUL1
	TLO AC3,400000	; PROPAGATE IT THROUGH
	TLO TAC,400000
	TLO TAC1,400000
$DMUL1:	XCTR XW,[MOVEM DSER,(UCHN)]
	XCTR XW,[MOVEM AC3,1(UCHN)]
	XCTR XW,[DMOVEM TAC,2(UCHN)]
	POPJ P,

; USE STACK FOR TEMPS
; DFMP ASSUMES THE FOLLOWING SETS OF ACCUMULATORS ARE CONTIGUOUS:
; TAC-TAC1
; AC1-AC2
; J-DDB
; DAT-PROG
; TEM-DSER

$N1FLG←←0	; NEGATIVE ARGUMENT
$CRY1←←-1
$CRY2←←-2

$DFMP:	PUSH P,[0]	; $CRY2
	PUSH P,[0]	; $CRY1
	PUSH P,[0]	; $N1FLG


	XCTR XR,[DMOVE TAC,(UCHN)]	; LOAD 1ST (AC) OPERAND
	JUMPG TAC,$DFMP1		; (⊗⊗⊗)
	JUMPE TAC,$DFMP5		; (***) TAC1 ZERO ALSO IF NORMALIZED
       	SETCMM $N1FLG(P)		; NOTE SIGN OF RESULT
	DMOVN TAC,TAC			; MAKE OPERAND POSITIVE
$DFMP1:	XCTR XR,[DMOVE AC1,(UUO)]	; LOAD OTHER (E) OPERAND
	JUMPG AC1,$DFMP2		; (⊗⊗⊗)
	JUMPE AC1,$DFMP6		; (***)
	SETCMM $N1FLG(P)
	DMOVN AC1,AC1

$DFMP2:	LDB IOS,[331000,,TAC]
	LDB J,[331000,,AC1]	; EXTRACT EXPONENTS
	ADDI IOS,-200(J)	; ACCUMULATE RESULTING EXPONENT
	ANDCM TAC,[377000,,0]	; ZERO EXPONENTS
	ANDCM AC1,[377000,,0]

	MOVE J,TAC
IFN DDB-J-1,<.FATAL ACs J and DDB are not contiguous as required here.>
	MUL J,AC1	; J-DDB ← PROD OF H.O.B.
	ASHC J,10	; GIVE IT 8 BINARY PLACES

	MOVE DAT,TAC
IFN PROG-DAT-1,<.FATAL ACs DAT and PROG are not contiguous as required here.>
	MUL DAT,AC2	; DAT-PROG ← CROSS PRODUCT
	ASHC DAT,10	; 8 BINARY PLACES ALSO
	ADD DDB,DAT

	TLZE DDB,400000
	AOS $CRY1(P)	; ACCUMULATE CARRIES


	MOVE TEM,TAC1
IFN DSER-TEM-1,<.FATAL ACs TEM and DSER are not contiguous as required here.>
	MUL TEM,AC1	; TEM-DSER ← Next cross product
	ASHC TEM,10
	ADD DDB,TEM

	TLZE DDB,400000	; Can overflow twice
	AOS $CRY1(P)

	ADD PROG,DSER	; Add lo order words of cross product
	TLZE PROG,400000
	AOS $CRY2(P)

	MOVE TEM,TAC1	; Now prod. of lows
IFN DSER-TEM-1,<.FATAL ACs TEM and DSER are not contiguous as required here.>
	MUL TEM,AC2
	ASHC TEM,-=27	; Correct for binary place
	ADD DDB,TEM
	ADD PROG,DSER

	TLZE PROG,400000
	AOS $CRY2(P)

	TLZE DDB,400000
	AOS $CRY1(P)

	ADD DDB,$CRY2(P)
	TLZE DDB,400000
	AOS $CRY1(P)
	ADD J,$CRY1(P)

	TLNE J,000400
	JRST $DFMP3
IFN DDB-J-1,<.FATAL ACs J and DDB are not contiguous as required here.>
	ASHC J,1
	SUBI IOS,1
	TLNE PROG,200000
	ADDI DDB,1
	LSH PROG,1

	TLZE DDB,400000	; Won't happen often, but it can happen
	ADDI J,1

$DFMP3:	TLNE PROG,200000	;Round it
	ADDI DDB,1

	TLZN DDB,400000		; (JOS/24-FEB-82) May have yet another carry
	JRST $DFMP7		; ( " )
	ADDI J,1		; ( " ) Yep

	TLNN J,001000		; ( " ) Now may have carried into exponent
	JRST $DFMP7		; ( " )
IFN DDB-J-1,<.FATAL ACs J and DDB are not contiguous as required here.>
	ASHC J,-1		; ( " )
	ADDI IOS,1		; ( " ) Can't need another rounding when here

$DFMP7:	DPB IOS,[331000,,J]	; ( " )
	DMOVE TAC,J
	SKIPGE $N1FLG(P)
	DMOVN TAC,TAC

$DFMP4:	XCTR XW,[DMOVEM TAC,(UCHN)]
$DFMP5: SUB P,[3,,3]	; NORMALIZE STACK
	POPJ P,

$DFMP6: SETZB TAC,TAC1	; RESULT IS ZERO	(***)
	JRST $DFMP4	;			(***)

; STACK LOCATIONS
; CONTIGUITY ASSUMPTIONS
; TAC-TAC1
; J-DDB
; AC1-AC2

$EXPN←←0	; TOP OF STACK
$SWITCH←←-1
$ARG←←-3

$DFSB:	XCTR XR,[DMOVN AC1,(UUO)]
	JRST $DFSB1

$DFAD:	XCTR XR,[DMOVE AC1,(UUO)]
$DFSB1:	XCTR XR,[DMOVE TAC,(UCHN)]
	PUSH P,AC1
	PUSH P,AC2	; SAVE FIRST ARGUMENT
	PUSH P,[0]	; $SWITCH
	PUSH P,[0]	; $EXPN

	JUMPGE TAC,$DFAD1
	DMOVN TAC,TAC
$DFAD1:	JUMPGE AC1,$DFAD2
	DMOVN AC1,AC1

$DFAD2:	CAML TAC,AC1
	JRST $DFAD3
$DFAD4:	EXCH TAC,AC1
	EXCH TAC1,AC2
	SETOM $SWITCH(P)
	JRST $DFAD5

$DFAD3:	CAME TAC,AC1
	JRST $DFAD5
	CAMGE TAC1,AC2
	JRST $DFAD4

$DFAD5:	LDB J,[331000,,TAC]	; EXTRACT EXPONENT
	MOVEM J,$EXPN(P)
	LDB IOS,[331000,,AC1]
	SUBI IOS,(J)		; BETTER BE NEGATIVE OR ZERO

	XCTR XR,[DMOVE TAC,(UCHN)]	; PICK UP ARGUMENTS AGAIN
	DMOVE AC1,$ARG(P)	; AND SECOND ARGUMENT FROM STACK
	SKIPN $SWITCH(P)
	JRST $DFAD6
	EXCH TAC,AC1
	EXCH TAC1,AC2

$DFAD6:	ANDCM TAC,[377000,,0]	; GET RID OF EXPONENT
	TLNE TAC,400000
	TLO TAC,377000		; SIGN EXTEND
	ANDCM AC1,[377000,,0]	; FLUSH EXPONENT
	TLNE AC1,400000
	TLO AC1,377000		; SIGN EXTEND

	MOVE J,AC2
	SETZ DDB,
	ANDI IOS,-1		; KNOCK OUT LH (FOR FOLLOWING INDIRECTION)
IFN DDB-J-1,<.FATAL ACs J and DDB are not contiguous as required here.>
	ASHC J,@IOS		; TRIPLE-PRECISION SHIFT
	ASHC AC1,@IOS
	TLZ AC2,400000		; KNOCK OUT SIGN BIT (USE FOR CARRY FLAG)
	TLZ TAC1,400000		; AND IN FIRST ARG ALSO

	ADD TAC1,AC2		; NOW (FINALLY) DO THE ADDITION
	ADD TAC,AC1
	TLZE TAC1,400000
	ADDI TAC,1

; DO NORMALIZATION DIFFERENTLY FOR POSITIVE AND NEGATIVE

$DFA15:	JUMPL TAC,$DFAD7	; NEGATIVE?
	TLNE TAC,377000		; NO - ANY OVERFLOW INTO EXPONENT FIELD?
	JRST $DFAD8		; YES, SHIFT DOWN BY ONE
	JRST $DFAD9		; NO, SHIFT UP BY ONE

$DFAD7:	TLNN 1,001000		; FOR NEG. NUMBERS, ANY OVERFLOW INTO EXPONENT?
	JRST $DFAD8		; YES, SHIFT DOWN AND DONE
$DFAD9:	ASHC TAC,1		; SHIFT UP UNTIL IT RUNS INTO EXPONENT FIELD
	SOS $EXPN(P)
	SETZ J,
IFN DDB-J-1,<.FATAL ACs J and DDB are not contiguous as required here.>
	ASHC J,1
	ADD TAC1,J	; CAN'T OVERFLOW - COULD BE AN IOR
	JUMPN TAC,$DFA15
	JUMPN TAC1,$DFA15
$DFA13:	SETZB TAC,TAC1	; RESULT IS ZERO
	JRST $DFA12


$DFAD8:	TLZ TAC1,400000	; CLEAR SIGN (CAN BE SET FROM ASHC ABOVE)
	ADDI TAC1,1	; ROUND
	TLZE TAC1,400000
	ADDI TAC,1	; CARRY
	ASHC TAC,-1
	AOS $EXPN(P)
	CAMN TAC,[777000,,0]	; IS IT A NEGATIVE POWER OF 2?
	  JRST $DFAD8	; YES, MUST PUT A NON-ZERO BIT IN H.O.B
	JUMPL TAC,$DFA14
	TLNE TAC,377000	; ROUNDING MIGHT OVERFLOW
	JRST $DFAD8	; SO DO IT AGAIN
	JRST $DFA10

$DFA14:	TLNN TAC,001000
	JRST $DFAD8
	JUMPE TAC,$DFA13

$DFA10:	MOVE IOS,$EXPN(P)
	JUMPGE TAC,$DFA11
	SETCM IOS,IOS	; NEGATIVE NUMBERS COMPLEMENT THE EXPONENT FIELD

$DFA11:	DPB IOS,[331000,,TAC]	; INSERT EXPONENT FIELD
	TLZ TAC1,400000	; KILL SIGN BIT (LIKE KL10 DOES)
$DFA12:	XCTR XW,[DMOVEM TAC,(UCHN)]	; RETURN RESULT TO USER
	SUB P,[4,,4]	; NORMALIZE STACK
	POPJ P,

$DMOVEM:
	XCTR XR,[DMOVE TAC,(UCHN)]
	XCTR XW,[DMOVEM TAC,(UUO)]
	POPJ P,

$KIFIX:	XCTR XR,[MOVE TAC,(UUO)]
	SKIPGE TAC
	FADRI TAC,(<0.5>)
	SKIPL TAC
	FSBRI TAC,(<0.5>)
	JRST $FIXR0

$FIXR:	XCTR XR,[MOVE TAC,(UUO)]
$FIXR0:	LDB AC1,[331000,,TAC]
	TLZ TAC,377000
	JUMPGE TAC,$FIXR1
	TLO TAC,377000
	XORI AC1,377
$FIXR1:	CAIL AC1,244
	POPJ P,			; IF OUT OF BOUNDS, NO CHANGE
	SETZ TAC1,
	ASHC TAC,-233(AC1)
	TLNE TAC1,200000
	ADDI TAC,1		; ROUND IT
	XCTR XW,[MOVEM TAC,(UCHN)]
	POPJ P,

$FLTR:	XCTR XR,[MOVE TAC,(UUO)]
	JUMPE TAC,$FLTR1
	SETZ TAC1,
	MOVEI AC1,243
	JUMPL TAC,$FLTR2
$FLTR3:	TLNE TAC,200000
	JRST $FLTR4
	ASH TAC,1
	SUBI AC1,1
	JRST $FLTR3

$FLTR4:	ASHC TAC,-10
	TLNE TAC1,200000
	ADDI TAC,1
	TLNN TAC,377000
	JRST $FLTR5
	ASH TAC,-1
	ADDI AC1,1
	JRST $FLTR5

$FLTR2:	TLNN TAC,200000
	JRST $FLTR6
	ASH TAC,1
	SUBI AC1,1
	JRST $FLTR2

$FLTR6:	ASHC TAC,-10
	TLNE TAC1,200000
	ADDI TAC,1
	CAMN TAC,[777000,,0]	; NEGATIVE POWER OF 2 ?
	JRST $FLTR7		; YES, TREAT SEPARATELY
	TLNE TAC,001000
	JRST $FLTR5
$FLTR7:	ASH TAC,-1
	ADDI AC1,1
$FLTR5:	SKIPGE TAC
	XORI AC1,377
	DPB AC1,[331000,,TAC]

$FLTR1:	XCTR XW,[MOVEM TAC,(UCHN)]
	POPJ P,

; CONTIGUITY ASSUMPTIONS
; TAC-TAC1
; DDB-DAT-PROG-TEM-DSER
IFN DAT-DDB-1,<.FATAL ACs DDB and DAT are not contiguous as required here.>
IFN PROG-DAT-1,<.FATAL ACs DAT and PROG are not contiguous as required here.>
IFN TEM-PROG-1,<.FATAL ACs PROG and TEM are not contiguous as required here.>
IFN DSER-TEM-1,<.FATAL ACs TEM and DSER are not contiguous as required here.>

$DFDV:	XCTR XR,[DMOVE DDB,(UCHN)]	; PICK UP FIRST ARGUMENT
	ASHC DDB,10		; GET RID OF EXPONENT
	ASHC DDB,-1		; GIVE US ONE GUARD BIT
	XCTR XR,[DMOVE TAC,(UUO)]	; GET SECOND ARGUMENT
	ASHC TAC,10		; FLUSH EXPONENT (NO GUARD BITS)

	DIV DDB,TAC		; Um/Vm → 1, REMAINDER → 2
	MOVE PROG,DAT		; GIVE US SOME ROOM
	SETZB DAT,TEM		; CLEAR LOW ORDER WORDS
	ASHC PROG,-1		; ONE MORE GUARD BIT
	DIV PROG,TAC		; DIVIDE REMAINDER BY HI-ORDER DIVISOR
	SKIPGE PROG		; SIGN EXTEND QUOTIENT
	 SETO DAT,
	ASHC DAT,1		; GET RID OF GUARD BIT
	ADD DDB,DAT		; ADD IN EXTENDED SIGN (AND GUARD BIT)
	MOVE DAT,PROG		; MOVE LOW ORDER WORD INTO PLACE

	MOVE TEM,TAC1		; PICK UP LO-ORDER WORD OF DIVISOR
	SETZB PROG,DSER		; CLEAR MAKE IT DOUBLE PRECISION
	TLZ TEM,400000		; LO-ORDER WORD IS ALWAYS POSITIVE
	ASHC TEM,-1		; MAKE A GUARD BIT
	DIV TEM,TAC		; DIVIDE BY HI-ORDER WORD OF DIVISOR
	MUL TEM,DDB		; THIS GIVES US TWO GUARD BITS
	SKIPGE TEM
	 SETO PROG,		; EXTEND SIGN
	ASHC PROG,1		; FLUSH ONE GUARD BIT
	TLNE DSER,200000	; TRIPLE PRECISION SHIFT
	 IORI TEM,1
	DMOVN PROG,PROG		; NEGATE IT
	TLZ TEM,400000		; USE SIGN BIT AS CARRY FLAG
	TLZ DAT,400000
	ADD DDB,PROG		; DOUBLE-PRECISION ADD
	ADD DAT,TEM
	TLZE DAT,400000
	 ADDI DDB,1		; CARRY INTO HI-ORDER WORD

	XCTR XR,[MOVM PROG,(UCHN)]
	LDB TEM,[331000,,PROG]	; PICK OUT EXPONENT
	XCTR XR,[MOVM PROG,(UUO)]
	LDB DSER,[331000,,PROG]
	SUB TEM,DSER
	ADDI TEM,201		; EXCESS 200 NOTATION (+1 FOR GUARD BIT)
	JUMPN DDB,$DFDV1
	JUMPE DAT,$DFDV2	; RETURN ZERO
$DFDV1:	JUMPGE DDB,$DFDV3
	TLNN DDB,200000		; NEGATIVE NUMBER - LOOK FOR ZERO IN H.O.B.
	 JRST $DFDV4
	JRST $DFDV5

$DFDV3:	TLNE DDB,200000
	 JRST $DFDV4
$DFDV5:	ASHC DDB,1		; NORMALIZE BY SHIFTING UP
	SUBI TEM,1		; ADJUST EXPONENT
	JRST $DFDV1		; LOOP BACK AGAIN (SHOULDN'T HAPPEN MORE THAN ONCE)

$DFDV4:	TLZ DAT,400000		; NORMALIZATION COULD HAVE SET SIGN BIT
	ADDI DAT,200		; ROUND IT
	TLZE DAT,400000		; AND PROPAGATE CARRY
	 ADDI DDB,1
	ASHC DDB,-10		; MAKE ROOM FOR EXPONENT
	CAME DDB,[777000,,0]	; NEGATIVE POWER OF 2 ?
	 JRST $DFDV6		; NO
	ASHC DDB,-1		; YES, HANDLE SEPARATELY
	ADDI TEM,1		; QUIRK OF PDP-10 F.P. IS WE DISALLOW 0 MANTISSAS
$DFDV6:	SKIPGE DDB
	 XORI TEM,377		; EXPONENTS FOR NEG. NUMBERS ARE COMPLEMENTED
	DPB TEM,[331000,,DDB]	; INSERT EXPONENT
	TLZ DAT,400000		; KL-10 DOES SO WHY NOT US?
	JRST $DFDV7

$DFDV2:	SETZB DDB,DAT
$DFDV7:	XCTR XW,[DMOVEM DDB,(UCHN)]
	POPJ P,

>; IFN FTF2

;SPWMES SPWIPC SPWNXM SPWPDL SPWCNS SPWTMX SPWIUU SPWMS1

;ERROR MESSAGE FOR SPW MODULES - HERE FROM P1 CLOCK LEVEL.

HISYS

↑SPWMES:JSP TAC,ERRPNT
	ASCIZ /Spacewar lossage/
	MOVE TAC,JBTST2(J)	;GET GOOD BITS
	TLNN TAC,ILMSPW		;ILL MEM REF?
	JRST SPWNXM		;NO
	HRRZ TAC,TAC
	PUSHJ P,ADRTST		;SEE IF PC IS OUT OF BOUNDS (OTHERWISE, NORMAL ILM)
	JRST SPWIPC		;PC OUT OF BOUNDS
	PUSHJ P,INLMES
	ASCIZ / - Ill mem ref/
	JRST SPWMS1

SPWIPC:	PUSHJ P,INLMES
	ASCIZ / - PC exceeds mem bounds/
	JRST SPWMS1

SPWNXM:	TLNN TAC,NXMSPW
	JRST SPWPDL
	PUSHJ P,INLMES
	ASCIZ / - Non ex mem/
	JRST SPWMS1

SPWPDL:	TLNN TAC,POVSPW
	JRST SPWCNS
	PUSHJ P,INLMES
	ASCIZ / - Pdl ov/
	JRST SPWMS1

SPWCNS:	TLNN TAC,CNSSPW
	JRST SPWTMX
	PUSHJ P,INLMES
	ASCIZ / - Cons trap/
	JRST SPWMS1

SPWTMX:	TLNN TAC,ILLTMO
	JRST SPWIUU
	PUSHJ P,INLMES
	ASCIZ / - Time out/
	JRST SPWMS1
SPWIUU:	TLNN TAC,UUOSPW
	PUSHJ P,BUGTRP		;DAMN IT, I WANT TO KNOW WHAT CAN CAUSE THIS - MRC
	PUSHJ P,INLMES
	ASCIZ/ - Illegal UUO/
SPWMS1:	HRRZ TAC1,JBTST2(J)
	HRLI TAC1,USRMOD	;SETUP FOR PCPNT
	PUSHJ P,KILSPW		;FLUSH SPACEWAR
	JRST PCPNT
;ADRERR UADER1 UADRER UADERR ILLINP BTLERR ILLOUT ILLMOD IOIERR DEVHNG BADDIR DEVEXC

;ADDRESS CHECK ERROR AT ANY LEVEL
;DDB MUST BE SET UP TO POINT TO OFFENDING DEVICE

↑ADRERR:JSP TAC,ERRDEV		;GET JOB NO. FROM DDB
UADER1:	ASCIZ /Address check for /
	JRST DEVEXC		;"DEVICE XXX; EXEC CALLED FROM EXEC/USER LOC YYY"
				;THEN STOP JOB

↑UADRER:			;SAME AS ADRERR EXCEPT GETS JOB # FROM JOB
	MOVEI TAC,UADER1	;ADDRESS CHECK AT UUO LEVEL.
	JRST ERRPTU		;WILL PRINT UADER1 AND CALL DEVEXC

;ADDRESS CHECK FOR NON-IO UUOS
;CALL BY <JRST UADERR>, DOES NOT RETURN
;WE GET HERE FOR MPV INTERRUPTS FROM UUO LEVEL OR FROM SPACEWAR
;IN CASE OF SPACEWAR, UUOMES TRANSFERS TO SPWERR IN SPWSER

↑UADERR:JSP TAC,UUOMES
	ASCIZ /Address out of bounds, UUO /

↑ILLINP:JSP TAC,ERRPTU		;INPUT UUO FOR OUTPUT DEVICE - UUO LEVEL ONLY
	ASCIZ /Output /
	PUSHJ P,ERNAM		;PRINT "DEVICE XXX"
	JSP TAC,UUOMES		;PRINT MESSAGE, PC, AND STOP JOB
	ASCIZ / cannot do input/


;USER'S BUFFER IS TOO BIG FOR DEVICE SERVICE THAT EMPLOYS AN 
;"INTERNAL SYSTEM BUFFER" - CALLED FROM UUO LEVEL ONLY

↑BTLERR:JSP TAC,ERRPTU		;SET UP TTY DDB
	ASCIZ /Buffer too large for /
	JRST DEVEXC		;"DEVICE XXX", PC, AND STOP JOB


↑ILLOUT:JSP TAC,ERRPTU		;OUTPUT UUO FOR INPUT DEVICE - UUO LEVEL ONLY
	ASCIZ /Input /
	PUSHJ P,ERNAM		;PRINT "DEVICE XXX"
	JSP TAC,UUOMES		;PRINT MESSAGE,UUOPC,STOP JOB
	ASCIZ / cannot do output/

;ILLEGAL DEVICE DATA MODE (INIT, OPEN, OR SETSTS UUOS) - UUO LEVEL ONLY
↑ILLMOD:JSP TAC,ERRPTU
	ASCIZ /Illegal data mode for /
	JRST DEVEXC		;PRINT "DEVICE XXX",UUO PC

;IO UUO TO USER CHANNEL WITH NO PREVIOUS INIT OR OPEN - UUO LEVEL ONLY
↑IOIERR:JSP TAC,ERRPTU
	ASCIZ \I/O to unassigned channel\
	JRST UUOPCP		;PRINT UUO PC

;ROUTINE FOR HUNG IO DEVICE
;CALL:	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,DEVHNG


↑DEVHNG:MOVEI TAC,IOACT		;TURN OFF IO DEVICE ACTIVE BIT IN
	ANDCAM TAC,@DEVSPT(DDB)	;MEMORY AND IOS
	TRZ IOS,IOACT
	JSP TAC,ERRDEV
	ASCIZ /Hung /
	JRST DEVEXC			;"DEVICE XXX UUO AT ... "

↑BADDIR:JSP TAC,ERRPNT
	ASCIZ /Bad directory for /

;ROUTINE TO PRINT "DEVICE XXX; EXEC CALLED FOR EXEC/USER YYY"
;THEN STOP JOB
;TO BE USED BY DEVICE DEPENDENT ERROR MESSAGES AFTER JSP TAC,DEVERR

↑DEVEXC:PUSHJ P,ERNAM			;PRINT "DEVICE XXX"
	MOVE TAC,(P)			;GET DEVICE DDB
	MOVE TAC1,DEVMOD(TAC)		;RPH PATCH TO CLEAR GOBIT ON DISK ERRORS
	TLNN TAC1,DVDSK
	JRST EXCALP
	MOVSI IOS,GOBIT
	ANDCAB IOS,@DEVSPT(TAC)		;CLEAR GO BIT IF STOPPING DISK
	JRST EXCALP			;PRINT PC AND STOP.
;HNGSTP

;STOP A JOB WHEN A DEVICE IS NOT READY FOR I/O - UUO LEVEL ONLY
;CALL:	MOVE DDB,<ADDR OF DEVICE DDB>
;	MOVE J,JOB NUMBER
;	PUSHJ P,HNGSTP


↑HNGSTP:PUSH P,IOS		;SAVE STUFF FOR DEVICE
	PUSH P,DDB
	PUSHJ P,TTYFUW
	PUSHJ P,PRQM		;"? "
	PUSHJ P,ERNAM		;"Device XXX"
	PUSHJ P,INLMES		;AND MESSAGE
	ASCIZ / isn't ready/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC		;START TTY IN COMMAND MODE
	POP P,DDB
	POP P,IOS
	PUSHJ P,STOP1		;STOP JOB
	JRST WSCHED		;AND RESCHEDULE
;HNGMES

;PRINT A MESSAGE AND STOP A JOB BUT ALLOW IT TO CONTINUE.
;	MOVEI TAC,[ASCIZ /MESSAGE HERE/]
;	PUSHJ P,HNGMES

↑HNGMES:
	PUSH P,IOS
	PUSH P,DDB
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,DAT
	PUSH P,TEM
	PUSH P,TAC1
	PUSH P,TAC
	MOVE J,JOB
	PUSHJ P,TTYFUW
	POP P,TAC		;ADDRESS OF MESSAGE
	PUSHJ P,CONMES
	PUSHJ P,PRCRCC		;APPEND CRLF ↑C .
	PUSHJ P,TTYSTC		;START TTY
	PUSHJ P,STOP1		;AND STOP USER
	POP P,TAC1
	POP P,TEM
	POP P,DAT
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,DDB
	POP P,IOS
	JRST WSCHED
;ERRPTU ERRDEV ERRPNT ERRZZ2 ERRZZP NAMPPN TTYCTY

;COMMON ERROR MESSAGE SETUP ROUTINES

LOSYS

;CALL:	JSP TAC,ERRPTU, ERRDEV, OR ERRPNT
;	ASCIZ /MESSAGE/
;	RETURNS HERE WITH DDB SAVED 0(P)
;	C(DDB)=TTYDDB, DAT TO TTY OUTPUT BUFFER POINTER
;	J=JOB NUMBER

;USE ERRPTU IF AT UUO LEVEL FOR SURE
;ERRDEV IF ERROR FOR AN ASSIGNED DEVICE AT ANY LEVEL
;ERRPNT WITH J ALREADY SET TO OFFENDING JOB NUMBER
;THE JSP CALL IS USED IN CASE PUSHDOWN SPACE BECOMES CRITICAL
;AGAIN AND ERRPNT HAS TO WIPE EXISTING LIST OUT

↑ERRPTU:SKIPN J,JOB		;BLAME CURRENT JOB IF NOT 0
↑ERRDEV:LDB J,PJOBN		;JOB NUMBER FROM DEVICE DATA BLOCK
↑ERRPNT:JUMPN J,.+2
	SETOM NULBAD
	PUSH P,DAT		; SAVE CALL TO ERROR
	SKIPL J
	CAIL J,JOBN		;REASONABLE JOB NUMBER?
	CAIA
	JRST ERRZZ2		;JOB NUMBER IS OK
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JOB CLOBBERED AT ERRPTU
/
	DEBCHECK(POPACS)
ERRZZ2:	PUSH P,DDB		;SAVE ADR. OF DEV. DATA BLOCK
	PUSH P,TAC		;SAVE RETURN FROM ERRPNT
	PUSHJ P,TTYCTY		;find job's tty DDB, or use CTY if phantom
	 JRST ERRZZP		;phantom error
	PUSHJ P,INLMES
	ASCIZ /? Error in job /
	PUSHJ P,PJOB		;PRINT JOB NO.
	PUSHJ P,NAMPPN		;maybe print job name and PPN
	JRST INLMES

ERRZZP:	PUSHJ P,DISUSR		;print time of msg on cty
	 SIXBIT /USRERR/
	POP P,AC1		;return addr from ERRPNT
	PUSHJ P,DISSTR		;print error msg on cty
	PUSH P,TAC		;save final byte ptr, points to real return addr
	MOVE TAC1,UUOPC(J)	;pc of error
	MOVEI AC1,[ASCIZ/  UUO at user /]
	TLNN TAC1,USRMOD
	MOVEI AC1,[ASCIZ/  UUO at exec /]
	PUSHJ P,DISSTR
	MOVEI TAC,(TAC1)
	PUSHJ P,DISLOC		;print PC
	PUSHJ P,DISMES
	 ASCIZ/  /
	PUSHJ P,DISJOB		;print jobnumber(jobname)
	MOVE TAC,PRJPRG(J)	;get ppn
	PUSHJ P,DISPPN		;print ppn
	JRST CPOPJ1		;return past message following call to ERRPTU, etc

NAMPPN:	MOVE TAC,JBTSTS(J)	;UUOMES enters here
	TLNE TAC,JLOG		;skip if JOB IS A PHANTOM or unlogged in but on TTY
	POPJ P,
	MOVE TAC1,JOBNAM(J)
	PUSHJ P,PRNAME		; TYPE ITS NAME TOO
	PUSHJ P,PRSPC
	MOVE TAC1,PRJPRG(J)	; NOT TO MENTION PPN
	PUSHJ P,PRPPN
	JRST PRSPC		;print some spaces

TTYCTY:	PUSHJ P,TTYERP		;FIND JOB'S TTY AND SET UP DDB.
	MOVE IOS,DEVIOS(DDB)	;IS THIS A DETACHED DDB?
	MOVE TAC,JBTSTS(J)	;IF SO, IS IT A PHANTOM?
	TLNN TAC,JLOG
	TLNN IOS,TTYDTC
	JRST CPOPJ1		;NO, CARRY ON (skip return)
	MOVEI DDB,SCNDDB	;YES, USE CTY FOR ERROR MESSAGE
	MOVE IOS,DEVIOS(DDB)
	POPJ P,
;UUOMES UUOPCP UUOMEP

;ROUTINE TO PRINT UUO PC AND STOP JOB - UUOMES, UUOPCP
;IF IN USER MODE PC WILL PRINT AS "AT USER LOC XXX"
;IF IN EXEC MODE "AT EXEC LOC XXX; EXEC CALLED FORM EXEC/USER/ LOC YYY


↑UUOMES:MOVE J,JOB		;MAKE SURE J IS SET UP
	ERRSPW			;JUMP TO SPWERR IF SPACEWAR IN PROGRESS
	PUSH P,TAC		;save address of error msg
	PUSHJ P,TTYCTY		;find job's tty DDB, or use CTY if phantom
	 JRST UUOMEP		;phantom, type on CTY via diasater buffer
	PUSHJ P,NAMPPN		;maybe print job name and PPN (if not logged in)
	POP P,TAC		;adr of error msg
	PUSHJ P,CONMES		;PRINT MESSAGE POINTED TO BY TAC
↑UUOPCP:MOVE TAC1,UUOPC(J)	;UUO PC STORED AT BOTTOM OF PDL
				;FIRST LOC ON PD LIST
	SOJA TAC1,PCPNT		;DECREMENT TO POINT TO UUO IN USER AREA

UUOMEP:	PUSHJ P,DISUSR		;print time of error on cty
	 SIXBIT /USRERR/
	POP P,AC1		;ptr to error msg
	PUSHJ P,DISSTR		;print error string on cty
	MOVE TAC1,UUOPC(J)	;pc of error
	MOVEI AC1,[ASCIZ/ at user /]
	TLNN AC1,USRMOD
	MOVEI AC1,[ASCIZ/ at exec /]
	PUSHJ P,DISSTR
	MOVEI TAC,(TAC1)
	PUSHJ P,DISLOC		;print PC
	PUSHJ P,DISMES
	 ASCIZ/  /
	PUSHJ P,DISJOB		;print jobnumber(jobname)
	MOVE TAC,PRJPRG(J)	;get ppn
	PUSHJ P,DISPPN		;print ppn
	JRST PCSTOP		;stop job
;PCPNT EXCALP PCSTOP

;ROUTINE TO PRINT ONE OF THREE MESSAGES AND STOP JOB
;1) "AT EXEC LOC XXX; EXEC CALLED FROM EXEC LOC YYY"
;2) "AT EXEC LOC XXX; EXEC CALLED FORM USER LOC YYY"
;3) "AT USER LOC YYY"

;CALL:	MOVE TAC1,XXX		;WITH PC FLAGS IN LH
;	PUSHJ P,PCPNT
;	NEVER RETURN IF AT UUO LEVEL


↑PCPNT:	PUSHJ P,PCP		;PRINT " AT EXEC XXX" OR " AT USER "
	TLNE TAC1,USRMOD	;WAS PC IN USER MODE?
	JRST PCSTOP		;YES, ENOUGH INFO.

;ROUTINE TO PRINT EITHER:
;1) "; EXEC CALLED FROM EXEC LOC YYY"
;2) "; EXEC CALLED FROM USER LOC YYY"
;AND STOP JOB
;CALL:	PUSHJ P,EXCALP
;	NEVER RETURNS IF AT UUO LEVEL


↑EXCALP:PUSHJ P,UUOATP
↑PCSTOP:PUSHJ P,HOLD		;STOP JOB, START TTY AND SET JOB ERROR BIT
	POP P,DDB		;RETURN ONLY IF AT INTERRUPT LEVEL
	JRST TPOPJ		;REMOVE ERROR CALL AND RETURN

;JUST PRINT IT, BUT DON'T STOP JOB (YET)
UUOATP:	MOVEI TAC,[ASCIZ /; UUO/]
;	CAIN DDB,SCNDDB		;CONMES (TYO) uses disaster buffer if CTY
;	PUSHJ P,DISSTT		;print string via disaster buffer for phantom
;	CAIE DDB,SCNDDB
	PUSHJ P,CONMES		;print on user terminal
	MOVE TAC1,UUOPC(J)	;UUO PC ON PDL
	SUBI TAC1,1		;BACK IT UP TO POINT TO UUO
	JRST PCP		;PRINT "EXEC LOC " OR USER LOC
;XMODE UMODE PCP PCP0 OCTDIS OCTPND OCTPNT ANYRDX OCTP1 SRAD10 RADX10

;ROUTINE TO PRINT PC AS:
;1) "EXEC LOC XXX" OR "USER LOC XXX"
;CALL:	MOVE TAC1,PC TO PRINT(LH=PC FLAGS)
;	PUSHJ P,PCP


XMODE: ASCIZ / at exec /
UMODE: ASCIZ / at user /

↑PCP:	MOVEI TAC,XMODE		;ASSUME PC IN EXEC MODE
	TLNE TAC1,USRMOD	;IS IT?
	MOVEI TAC,UMODE		;NO, USER MODE
;	CAIN DDB,SCNDDB
;	PUSHJ P,DISSTT
;	CAIE DDB,SCNDDB
	PUSHJ P,CONMES		;PRINT ONE OR OTHER
IFN FTKLB,<
	MOVE TAC,SCTERR		;get any nonzero section number to include in PC
	HRR TAC,TAC1		;include local part of PC
	SETZM SCTERR		;don't print section number again till re-occurs
>;IFN FTKLB
IFE FTKLB,<
	HRRZ TAC,TAC1		;PRINT RIGHT HALF IN OCTAL
>;IFE FTKLB
;	CAIE DDB,SCNDDB
	JRST OCTPNT		;type on TTY (preserves TAC1)
;	TLNN TAC,-1		;any nonzero section?
;	JRST DISLOT		;no, print RH via dis buf (preserves TAC1)
;	PUSH P,TAC1		;yes
;	PUSHJ P,DISOHS		;print in halfword format on CTY
;	POP P,TAC1
;	POPJ P,

;ROUTINE TO PRINT 36 BIT OCTAL NO
;CALL:	MOVE DAT, TTY OUTPUT BYTE POINTER
;	MOVE TAC,OCTAL NO
;	PUSHJ P,OCTPNT

OCTPND:	CAIN DDB,SCNDDB
	JRST DISOHS		;print on CTY via disaster buffer
↑OCTPNT:PUSH P,TAC1		;SAVE TAC1
	MOVEI TAC1,10		;OCTAL BASE
ANYRDX:	PUSH P,J
	MOVEI J,(TAC1)
	PUSHJ P,OCTP1
	POP P,J
	POP P,TAC1
	POPJ P,

OCTP1:	LSHC TAC,-=35		; AVOID SIGN BIT LOSSAGE
	LSH TAC1,-1
	DIVI TAC,(J)
	HRLM TAC1,(P)
	JUMPE TAC,.+2
	PUSHJ P,OCTP1
	HLRZ TEM,(P)
	MOVEI TEM,"0"(TEM)
	XCT TYO
	POPJ P,

;PRINT DECIMAL NUMBER WITH LEADING MINUS SIGN IF NEGATIVE
↑SRAD10:MOVEI TEM,"-"
	SKIPGE TAC
	XCT TYO
	MOVM TAC,TAC
;FALL INTO RADX10

;ROUTINE TO PRINT DECIMAL NO.
;CALL:	SAME AS OCTPNT
;TAC1 IS PRESERVED
↑RADX10:PUSH P,TAC1		;OUTPUT DECIMAL
	MOVEI TAC1,12
	JRST ANYRDX
;ERNAM PRNAME PRPPN

;PRINT "DEVICE XXX" 
;CALL:	MOVE DAT,ASCII OUTPUT BYTE POINTER
;	PUSH P,DDB
;	PUSHJ P,ERNAM


↑ERNAM:	PUSHJ P,INLMES
	ASCIZ /Device /
	SKIPE TAC1,-1(P)	;IS DDB = 0?
	MOVE TAC1,DEVNAM(TAC1)	;GET DEVICE NAME
				;FALL INTO PRNAME
;PRINT SIXBIT NAME
;CALL:	MOVE DAT,ASCII OUTPUT BYTE POINTER
;	MOVE TAC1,NAME
;	PUSHJ P,PRNAME

↑PRNAME:JUMPE TAC1,CPOPJ	;DONE IF NULL
	MOVEI TAC,0
	LSHC TAC,6		;SHIFT IN NEXT CHAR.
	JUMPE TAC,PRNAME	;NO LEADING SPACES
	MOVEI TEM,40(TAC)
	XCT TYO			;TYPE OUT IN ASCII.
	JRST PRNAME

;PRINT PPN
;CALL:	MOVE TAC1,PPN
;	PUSHJ P,PRPPN

↑PRPPN:	PUSH P,TAC1
	HLLZS TAC1
	PUSHJ P,PRNAME
	MOVEI TEM,","
	XCT TYO
	POP P,TAC1
	HRLZS TAC1
	JRST PRNAME
;DISINIT DISOUT DISOU1 DISOUX DISOX1 DISOX2 DISBEG DISEND

	SUBTTL DISASTER TYPEOUT

↑DISINIT:			;INITIALIZE DISASTER SERVICE 
	MOVE TAC,[POINT 7,DISBUF]
	MOVEM TAC,DISPTR
	MOVEM TAC,DISOPT
	MOVEI TAC,5*DISLEN
	MOVEM TAC,DISCTR
	POPJ P,

; ROUTINE TO TYPE OUT DISASTER BUFFER ON CTY AT CLOCK LEVEL
; RECCOMMENDED CALLING . . .
;	MOVE TAC,DISPTR
;	CAME TAC,DISOPT
;	PUSHJ P,DISOUT
; PUTS AS MUCH TEXT AS IT CAN INTO THE CTY OUTPUT BUFFER AND INITIATES
; CTYTYO.

↑DISOUT:MOVEI	J,0
	PUSHJ	P,TTYFND		;SET UP DDB AND DAT TO THE CTY
	MOVEI	IOS,IOSUPR
	ANDCAM	IOS,DEVIOS(DDB)		;TURN OFF ↑O
DISOU1:	MOVE	TAC,FCTR(DAT)		;HOW FULL IS THE BUFFER?
	CAIG	TAC,8			;MAKE SURE ENOUGH ROOM FOR A TAB EXPAND
	JRST	TYPGO			;FULL TO THE GILLS. INITIATE TYPEOUT
	PUSHJ	P,DISOUX		;GET A CHARACTER
	JRST	TYPGO			;THERE ARE NONE LEFT IN DISBUF. GO TYPEOUT
	PUSHJ	P,OUTCH5		;Somebody has to be smart enough to
					;actually do some work....
	JRST	DISOU1			;LOOP.

;ROUTINE TO REMOVE A CHARACTER FROM DISBUF.
;CALL AT ANY LEVEL.  MAINTAINS STATE OF PION.
;SKIP-RETURNS WITH CHARACTER IN TEM, WRAPS DISOPT AS NEEDED
;DIRECT RETURN IF DISBUF IS EMPTY

DISOUX:	PUSH P,AC2			;SAVE ACS
	PUSH P,AC3
	MOVE AC2,DISBEG			;ptr to beginning of disaster buffer
	MOVE AC3,DISEND			;LAST BYTE
	CONSZ PI,PION			;PI SYSTEM ON?
	SKIPA AC1,[CONO PI,PION]	;YES. TURN IT ON WHEN WE EXIT
	MOVSI AC1,(<JFCL>)
	SYSPIFF			;OK. NOBODY MOVE
	AOS TEM,DISCTR			;CHARACTERS LEFT IN THE BUFFER?
	CAILE TEM,5*DISLEN
	JRST DISOX2			;NO - OOPS.
	ILDB TEM,DISOPT			;STUFF THE BYTE
	CAMN AC3,DISOPT			;WAS THAT THE LAST AVAILABLE BYTE?
	MOVEM AC2,DISOPT		;YES. RESET TO FRONT OF BUFFER
	XCT AC1				;RESTORE PION IF WE TURNED IT OFF.
	AOS -2(P)			;SKIP-RETURN - WE HAVE A CHARACTER
DISOX1:	POP P,AC3
	POP P,AC2
	POPJ P,

DISOX2:	SOS TEM,DISCTR			;BUFFER BETTER LOOK EMPTY!
	XCT AC1
	JRST DISOX1

DISBEG:	POINT 7,DISBUF			;SET TO REINITIALIZE DISPTR
DISEND:	POINT 7,DISBUF+DISLEN-1,34	;LAST BYTE in disaster buffer
;DISFLUSH DISFL3 DISFL1 DISFLX REFLUS

; TURNS PIS OFF AND TYPES ENTIRE DISASTER BUFFER TO CTY
; SERVOS CTY ALL BY ITSELF
; CALLING . . .
;	PUSHJ P,DISFLUSH
; Clobbers AC1, TAC, DAT, TEM 

↑DISFLUSH:
	CONSZ PI,PION
	SKIPA AC1,[CONO PI,PION]
	MOVSI AC1,(<JFCL>)
	PUSH P,AC1		;SAVE STATE OF PI SYSTEM
	SYSPIFF
IFN FTSUAI,<
	CONO CAR,ONRED!ONYEL	;Turn on the Red and Yellow lights!
>;IFN FTSUAI
	PUSH P,TIMDAT
	POP P,LASTDISASTER
IFN FT11CLK,<
	SETZM CONYET		;Quickly ask 11 for time after proceeding
>;IFN FT11CLK
IFKL10,<
	MOVEI TAC,DTMONG
	PUSHJ P,DTEXXW		;GET STATE OF MONITOR MODE
	PUSH P,TAC		;SAVE STATE OF MONITOR MODE
	MOVEI TAC,DTMONC	;CLEAR MONITOR MODE
	PUSHJ P,DTEXXW		;MUST WAIT IN CASE GOING TO DDT
>;IFKL10
	SKIPN DAT,TTYTAB+TCONLN	;IS THE CTY THERE AT ALL?
	JRST DISFL1		;NO, SKIP ALL THIS CRAP
	ADDI DAT,TTOBUF		;POINT TO OUTPUT BUFFER.
DISFL3:	MOVE TAC,TAKR(DAT)	;TYPE CTY OUTPUT BUFFER BEFORE
	CAMN TAC,PUTR(DAT)	;  TYPING DISASTER BUFFER
	JRST DISFL1		;CTY OUTPUT BUFFER EMPTY.  DO DISBUF NEXT
	PUSHJ P,GETCHO		;PICK UP A CHARACTER FROM THE OUTPUT BUFFER
	PUSHJ P,CTYTYO		;AND TYPE IT OUT
	JRST DISFL3

DISFL1:	PUSHJ P,DISOUX		;GET A CHARACTER FROM DISASTER BUFFER
	JRST DISFLX		;DISASTER BUFFER EMPTY NOW.
	PUSHJ P,CTYTYO		;TYPE OUT ON CTY
	JRST DISFL1

DISFLX:
IFKL10,<
	POP P,AC1		;RESTORE PREVIOUS STATE OF MONITOR MODE
	MOVEI TAC,DTMONS	;IT'S OFF NOW, SET IT, IF NEEDED.
	SKIPE AC1		;SKIP IF IT WAS OFF
	PUSHJ P,DTEXXW		;MUST WAIT IN CASE GOING TO DDT
>;IFKL10
	POP P,AC1
IFN FTSUAI,<
	CONO CAR,OFFRED!OFFYEL	;Turn off the Red and Yellow lights!
>;IFN FTSUAI
	XCT AC1			;RESTORE STATE OF PI SYSTEM
	POPJ P,

;Routine to re-type the disaster buffer, called from DDT with PUSHJ P,REFLUS$X.
;Preserves all ACs.
↑REFLUS:PUSHACS			;don't clobber nuttin'
	CONSZ PI,PION		;check PI state
	SKIPA AC1,[CONO PI,PION] ;is on, turn on when done
	MOVSI AC1,(<JFCL>)	;is off, leave off when done
	SYSPIFF		;turn off PI while working
	PUSH P,AC1		;save state of PI system
	PUSHJ P,DISFLU		;first, make sure everything's already typed once
	SETZM DISCTR		;make buffer look full, no free space now
	PUSHJ P,DISFLU		;type everything again
	POP P,AC1
	XCT AC1			;restore PI state
	POPACS
	POPJ P,
;⊗ CTYDMR DISTYO DISTY1 DISTYH DISTYC DISTYF DISTYL DISTY3 DISTY2 DISUSJ DISUSR DISGST DISUS2 DISUS0 TTTPPJ

CTYDMR←←=14		;Default column # of left margin for text lines on CTY

;DISTYO
;  Assure proper indentation and output a single character.
;  If the current column (CTYCUR)is less than the desired column (CTYMAR),
;  then spaces are output before the character is output.  If the character
;  was a <cr>, then the CTYMAR is reset to the default indentation.  Thus, to
;  output something in column 0 (for instance), simply set CTYMAR to 0 before
;  calling.
;
;  call with:
;	MOVE	TEM,<char>
;	PUSHJ	P,DISTYO
; 
;  TEM is the only AC clobbered

;First we indent out to specified left margin (as required)
↑DISTYO:PUSH P,TAC
	CAIGE TEM,40
	JRST DISTYC		;No indentation for non-printing char
	SETZM CTYLFS		;Indicate no LFs since this printing char
	MOVE TAC,CTYMAR		;Get desired column
	SUB TAC,CTYCUR		;See how far from there we are
	JUMPLE TAC,DISTY1	;Jump if already there
	PUSH P,TEM
	MOVEI TEM," "
	PUSHJ P,DISTYH		;Output right number of spaces
	SOJG TAC,.-1
	POP P,TEM		;This is the real character we want to output
DISTY1:	POP P,TAC
	;FALL INTO DISTYH FOR REAL SPEEDY OUTPUT (HA, HA).
;DISTYH - output a single character
;  The routine DISTYH will 'guarantee' that the character in TEM get printed
;  on the CTY.  If the disaster buffer is full when DISTYH is called, DISTYF
;  is called to flush the buffer.
DISTYH:	PUSHJ P,DISTYL		;Try to output the character
	 JRST DISTYF		;   failed - try again
	CAIL TEM,40		;Was the character we output a printing character?
	AOSA CTYCUR		;   yep, increment current column #
	CAIE TEM,15		;Was the character we output a <cr>?
	POPJ P,			;   nope, just return
	SETZM CTYCUR		;The character was a <cr>, reset the column #
	MOVEI TEM,CTYDMR
	MOVEM TEM,CTYMAR	;Reset default indentation
	POPJ P,

;Here with control char (less than '040) from DISTYO.  Maybe suppress blank line.
DISTYC:	CAIE TEM,12		;If LF, maybe we should ignore it
	JRST DISTY1		;Output non printing char (maybe CR)
	AOS TAC,CTYLFS		;Count another LF, in case we print this one
	CAILE TAC,2		;If more than one LF, suppress this LF
	JRST TPOPJ		;Suppress blank line
	JRST DISTY1		;Output LF

;Here only from DISTYH above.
DISTYF:	PUSH P,AC1		;SAVE AN AC - CLOBBERED BY DISFLUSH
	PUSH P,TEM		;Save <char>
	PUSH P,TAC
	PUSH P,DAT
	PUSHJ P,DISFLUSH	;EMPTY THE DISASTER BUFFER
	POP P,DAT
	POP P,TAC
	POP P,TEM
	POP P,AC1
	JRST DISTYH		;Try again

;DISTYL - the low level disaster buffer output routine
; Type one char on the CTY via the disaster buffer.  Takes skip return if
; there is room in the buffer.  Called from DISTYH.
;
; call with:
;	MOVE TEM,<char>
;	PUSHJ P,DISTYL
;	(error return)
;	(success)

DISTYL:	PUSH P,AC2			;SAVE ACS
	PUSH P,AC3
	PUSH P,AC1
	MOVE AC2,DISBEG			;SET TO REINITIALIZE DISPTR
	MOVE AC3,DISEND			;PTR to last byte in disaster buffer
	CONSZ PI,PION			;PI SYSTEM ON?
	SKIPA AC1,[CONO PI,PION]	;YES. TURN IT ON WHEN WE EXIT
	MOVSI AC1,(<JFCL>)
	SYSPIFF			;OK. NOBODY MOVE
	SOSGE DISCTR			;ROOM IN THE BUFFER?
	JRST DISTY3			;NO - OOPS.
	IDPB TEM,DISPTR			;STUFF THE BYTE
	CAMN AC3,DISPTR			;WAS THAT THE LAST AVAILABLE BYTE?
	MOVEM AC2,DISPTR		;YES. RESET TO FRONT OF BUFFER
	AOSA -3(P)			;Take skip return on success
DISTY3:	AOS DISCTR			;No room - fix count
DISTY2:	XCT AC1				;RESTORE PION IF WE TURNED IT OFF.
	POP P,AC1
	POP P,AC3
	POP P,AC2
	POPJ P,

; The following routines all output to the CTY with the format:
;
; {blank line if <usrnam> has changed or is blank}
; HH:MM USRNAM {no trailing crlf}
;
; All subsequent text lines will be indented to column CTYDMR (CTY default margin)
; 
;DISGST - call for system messges, makes blank <usrnam>, forces leading blank line
;DISUSR - call with [PUSHJ P,DISUSR  ↔  SIXBIT /USRNAM/]
;DISUSJ - call to use name of current job as <usrnam>
;
; No ACs are clobbered.

↑DISUSJ:PUSH P,TEM		;preserve all ACs
	PUSH P,TAC
	PUSH P,TAC1
	MOVE TEM,JOB		;Get current job number
	MOVE TAC,JOBNAM(TEM)	;Use name of that job as name of message
	MOVE TAC1,TIME		;Get time message is going out
	SUB TAC1,CTYJTM		;Amount of time since last user job message
	ADDM TAC1,CTYJTM	;Update message time to current time
	EXCH TEM,CTYJOB		;See if same job as previous, remember this job
	CAMN TEM,CTYJOB		;Same job number?
	CAME TAC,CTYUSR		;And same job name?
	JRST DISUS0		;No, put out a new time and name
	CAIG TAC1,JIFMIN	;Was previous user job message within last minute?
	JUMPGE TAC1,TTTPPJ	;Yes, let message continue (unless new day)
	JRST DISUS0		;No, put out new time and name

↑DISUSR:PUSH P,TEM		;preserve all ACs
	MOVE TEM,-1(P)		;GET ADDRESS OF INLINE NAME
	MOVE TEM,(TEM)		;GET INLINE NAME
	AOS -1(P)		;SKIP OVER INLINE NAME ON RETURN
	JRST DISUS2

↑DISGST:PUSH P,TEM		;preserve all ACs
	MOVEI TEM,0		;NO NAME FOR MANY UNLIKELY SYSTEM MESSAGES
DISUS2:	SETZM CTYJOB		;Not outputting message from user job
	PUSH P,TAC
	PUSH P,TAC1
	MOVE TAC,TEM		;Put name where we want it
DISUS0:	SKIPE CTYCUR		;If not at left margin
	PUSHJ P,DISCRLF		;   then output a crlf
	SKIPE TAC		;If blank name or
	CAME TAC,CTYUSR		; if name is different from last time?
	PUSHJ P,DISCRLF		;   then output blank line ahead of new message
	MOVEM TAC,CTYUSR	;Remember this usrnam for next time
	SETZM CTYMAR		;We want to start a line in column 0
	PUSH P,TAC
	PUSHJ P,DISTIM		;Print the current time, starting at col 0
	POP P,TAC1
	MOVEI TEM,40
	PUSHJ P,DISTYO		;AND A SPACE
	PUSHJ P,DISSIX		;TYPE NAME OF MESSAGE
	MOVEI TEM,CTYDMR	;Reset to default indentation
	MOVEM TEM,CTYMAR
	HRRZM P,CTYLFS		;Pretend we've seen blank line, to ignore quick CRLF
TTTPPJ:	POP P,TAC1		;RESTORE ALL ACS
	POP P,TAC
	POP P,TEM
	POPJ P,
;⊗ DISMES DISME1 DISTAC DISTC1 DISCRLF DISTAB DISJOB DISJB1 DISJAR

; ROUTINE TO DO A DISASTER OUTPUT OF A STRING
; CALL BY:
;	PUSHJ P,DISMES
;	ASCIZ /<STRING>/

↑DISMES:MOVSI AC1,(<POINT 7,0>)
	HLLM AC1,(P)			;SET RETURN ADDRESS TO A BYTE POINTER
DISME1:	ILDB TEM,(P)			;GET A BYTE
	JUMPE TEM,CPOPJ1		;NONE THERE. INCREMENT SAVED PC AND RETURN
	PUSHJ P,DISTYO
	JRST DISME1

;Disaster output of a string.  Call with TAC (Right half) set to string address.
;usual format is JSP TAC,FOO
;		 ASCIZ /Message/
;
;	FOO:	...
;		PUSHJ P,DISTAC
;
↑DISTAC:HRLI TAC,440700
	PUSH P,TAC	
DISTC1:	ILDB TEM,(P)		;GET A BYTE
	JUMPE TEM,TPOPJ		;NONE THERE.  Done
	PUSHJ P,DISTYO
	JRST DISTC1

↑DISCRLF:			;CALL TO DO DISASTER OUTPUT OF CRLF ON THE CTY
	MOVEI TEM,15
	PUSHJ P,DISTYO
	SKIPA TEM,[12]
↑DISTAB:MOVEI TEM,11		;TYPE TAB THRU DISASTER SERVICE
	JRST DISTYO

↑DISJOB:			;TYPE JOBNUMBER(JOBNAME). J IS SET WITH JOBNUMBER
				;J IS PRESERVED.
	PUSH P,J		;SAVE JOB NUMBER
	JUMPLE J,DISJAR
	CAIL J,JOBN
	JRST DISJAR
	MOVE TAC1,JOBNAM(J)	;GET THE JOBNAME
	PUSHJ P,DISSIX
	MOVEI TEM,"("
	PUSHJ P,DISTYO
DISJB1:	MOVE TAC,(P)
	PUSHJ P,DISDCP		;TYPE JOB NUMBER IN DECIMAL WITH DECIMAL POINT
	MOVEI TEM,")"
	PUSHJ P,DISTYO
	POP P,J
	POPJ P,

DISJAR:	PUSHJ P,DISMES
	ASCIZ /(DISJOB - ILLEGAL JOB NUMBER - /
	JRST DISJB1
;DISERR ERRTAB ERRLEN DISSTT DISSTR ERRSTR ERRST1 DIS8TX DIS8T1

;CALLING SEQUENCE
;	PUSHJ P,DISERR
;	CODE,,ADDR
;	CODE,,ADDR
;	      .
;	      .
;	      .
;	      .
;	     -1
;

↑DISERR:SKIPGE TEM,@(P)
	JRST CPOPJ1			;SKIP RETURN
	ASH TEM,-=23			;ONLY CODE BITS PLEASE
	MOVEI AC1,@(P)			;GET EFFECTIVE ADDRESS
	MOVEI AC1,@(AC1)		;NOW GET ITS EFFECTIVE ADDRESS
	MOVE TAC,(AC1)			;SET UP ARGUMENT FOR MOST CALLS
	CAIG TEM,ERRLEN-1
	PUSHJ P,@ERRTAB(TEM)		;DISPATCH
	AOS (P)				;NEXT ARG
	JRST DISERR

DEFINE ERRMAC $ (I)
<	ERR$I
>
ERRTAB:	QQQNAM
ERRLEN←←.-ERRTAB


; HERE ARE THE VARIOUS PRINTOUT ROUTINES FOR DISERR
;	OTHERS CALL DISOCT,DISDEC,DISDCP,DISLOC,DISSIX DISHE2 DIRECTLY

DISSTT:	MOVEI AC1,(TAC)
↑DISSTR:			;USED BY IMPSER -- MRC
ERRSTR:	HRLI AC1,(<POINT 7,0>)
	PUSH P,AC1
ERRST1:	ILDB TEM,(P)
	JUMPE TEM,TPOPJ		;QUIT ON ZERO, returning final byte ptr in TAC!
	PUSHJ P,DISTYO
	JRST ERRST1

IFN PUPNUM,<

;Print 8 bit text, given count in TAC1
↑DIS8TX:TLNN AC1,-1
	  HRLI AC1,(<POINT 8,0>)
	PUSH P,AC1
DIS8T1:	ILDB TEM,(P)
	SKIPE TEM		;SKIP NULLS
	PUSHJ P,DISTYO
	SOJG TAC1,DIS8T1
	JRST TPOPJ

>;IFN PUPNUM
;⊗ DISLOT DISLOC ERRLOC DISLC1 ERRADR DISADR DISAD1 DISAD2 DISAD3 DISOCT ERROCT DSOCT2 DISOHS ERROHS DISOCH ERROCH DSOCH1 DISDCP ERRDCP DISDEC ERRDEC DISDC1 DISNUM DISHE2 ERRHE2 ERRHET DISIPA ERRIPA

;DISLOC PRINTS OUT 6 DIGIT OCTAL LOCATION WITHOUT LEADING ZEROES
;CALL:	MOVE TAC,<LOCATION>
;	PUSHJ P,DISLOC

DISLOT:	PUSH P,TAC1		;preserve this AC
	PUSHJ P,DISLOC		;print RH of TAC in octal
	POP P,TAC1
	POPJ P,

↑DISLOC:			;Data in TAC, type up to six octits
ERRLOC:	PUSH P,[=6]
	HRLZ TAC1,TAC
DISLC1:	TLNE TAC1,700000	;DO WE HAVE A DIGIT YET?
	JRST DSOCT2		;YES, PRINT ADDRESS
	LSH TAC1,3		;SHIFT LEFT 3 BITS
	SOSLE (P)
	JRST DISLC1
	JRST DSOCT2		;PRINT ONE ZERO.

;DISADR - PRINT AN 8-OCTAL DIGIT PHYSICAL MEMORY ADDRESS FROM TAC
ERRADR:
↑DISADR:MOVEI TEM,=8		;PRINT WITH LEADING ZEROES
	AND TAC,[17777777]	;MAX PHYSICAL ADDRESS
DISAD1:	IDIVI TAC,=8
	HRLM TAC1,(P)		;STORE DIGIT
	SUBI TEM,1
	JUMPE TAC,DISAD3
	PUSHJ P,DISAD1
DISAD2:	HLRZ TEM,(P)
	ADDI TEM,"0"
	JRST DISTYO

DISAD3:	JUMPLE TEM,DISAD2
	PUSH P,[0,,DISAD2]
	SOJA TEM,DISAD3


; OCTAL PRINT ROUTINE FOR DISASTER MESSAGES
; CALLING . . .
;	MOVE TAC,<NUMBER>
;	PUSHJ P,DISOCT

↑DISOCT:
ERROCT:	PUSH P,[=12]
	MOVE TAC1,TAC
DSOCT2:	SETZ TAC,
	LSHC TAC,3
	MOVEI TEM,"0"(TAC)
	PUSH P,TAC1
	PUSHJ P,DISTYO
	POP P,TAC1
	SOSLE (P)
	JRST DSOCT2
	JRST TPOPJ

;PRINT AS TWO HALF WORDS, SUPPRESSING LEADING ZEROS
↑DISOHS:
ERROHS:	PUSH P,TAC		;save argument
	HLRZ TAC,TAC		;left half
	PUSHJ P,DISLOC		;print octal w/o leading zeroes
	MOVEI TEM,","		;print ",,"
	PUSHJ P,DISTYO
	MOVEI TEM,","
	PUSHJ P,DISTYO
	POP P,TAC		;get back arg
	MOVEI TAC,(TAC)		;just right half
	JRST DISLOC		;print right half w/o leading zeroes

;ANOTHER OCTAL PRINT ROUTINE. PRINTS  HALFWORD COMMA COMMA HALFWORD
↑DISOCH:			;Argument in TAC
ERROCH:	PUSH P,TAC		;SAVE THE ARGUMENT
	HLLZ TAC1,TAC		;GET LEFT SIDE IN LEFT SIDE
	PUSH P,[DSOCH1]		;"RETURN" ADDRESS
	PUSH P,[6]		;6 CHARACTERS PLEASE
	JRST DSOCT2		;DO IT.  RETURN TO DSOCH1

DSOCH1:	MOVEI TEM,","
	PUSHJ P,DISTYO
	MOVEI TEM,","
	PUSHJ P,DISTYO
	POP P,TAC1		;GET RIGHT SIDE
	HRLZ TAC1,TAC1
	PUSH P,[6]
	JRST DSOCT2		;WRITE IT AND RETURN

↑DISDCP:
ERRDCP:	PUSHJ P,DISDEC		;DECIMAL FOLLOWED BY "."
	MOVEI TEM,"."
	JRST DISTYO		;APPEND . TO DECIMAL NUMBER

↑DISDEC:
ERRDEC:	JUMPGE TAC,DISDC1
	MOVEI TEM,"-"
	PUSHJ P,DISTYO
DISDC1:	MOVM TAC,TAC

DISNUM:	IDIVI TAC,=10
	HRLM TAC1,(P)
	JUMPE TAC,.+2
	PUSHJ P,DISNUM
	HLRZ TAC,(P)
	MOVEI TEM,"0"(TAC)
	JRST DISTYO

;PRINT TAC AS TWO HEX DIGITS
↑DISHE2:
ERRHE2:	MOVEI TEM,"H"
	PUSHJ P,DISTYO
	LDB TEM,[POINT 4,TAC,31]
	PUSHJ P,ERRHET			;TYPE 4 BIT NUMBER AS HEX
	LDB TEM,[POINT 4,TAC,35]	;SECOND DIGIT
ERRHET:	CAIL TEM,=10
	ADDI TEM,"A"-"0"-=10
	ADDI TEM,"0"
	JRST DISTYO

IFN FTIP,<
;Print TAC as an IP host address.
↑DISIPA:
ERRIPA:	PUSH P,TAC
	LDB TAC,[POINT 12,(P),11]	;Include left 4 bits just in case
	PUSHJ P,DISDCP			;Type decimal and "."
	LDB TAC,[POINT 8,(P),19]
	PUSHJ P,DISDCP
	LDB TAC,[POINT 8,(P),27]
	PUSHJ P,DISDCP
	LDB TAC,[POINT 8,(P),35]
	PUSHJ P,DISDEC
	JRST TPOPJ
>;IFN FTIP
;⊗ ERRSIX DISSIX DISFIL DISFI1 DISPPN DISIXS DSIXS1 DSIXS3

;SIXBIT PRINT ROUTINE FOR DISASTER MESSAGES
; CALLING . . .
;	MOVE TAC1,<WORD>
;	PUSHJ P,DISSIX

ERRSIX:	MOVE TAC1,TAC		;SPECIAL ENTRY FROM DISERR
↑DISSIX:JUMPE TAC1,CPOPJ
	MOVEI TAC,0
	ROTC TAC,6
	MOVEI TEM," "(TAC)	;CONVERT TO ASCII
	PUSH P,TAC1
	PUSHJ P,DISTYO
	POP P,TAC1
	JRST DISSIX

↑DISFIL:PUSH P,TAC		;PRINT FILE NAME.  SAVE POINTER
	MOVE TAC1,(TAC)		;GET FILE NAME
	PUSHJ P,DISSIX		;SIXBIT
	MOVE TAC,(P)
	HLLZ TAC1,1(TAC)	;EXT
	JUMPE TAC1,DISFI1
	MOVEI TEM,"."
	PUSHJ P,DISTYO
	PUSHJ P,DISSIX
DISFI1:	POP P,TAC
	MOVE TAC,3(TAC)		;PPN IN TAC.
	JUMPE TAC,CPOPJ
↑DISPPN:MOVEI TEM,"["		;PRINT A PPN FROM TAC.
	PUSHJ P,DISTYO
	PUSH P,TAC
	HLLZ TAC1,TAC
	PUSHJ P,DISSIX
	MOVEI TEM,","
	PUSHJ P,DISTYO
	POP P,TAC
	HRLZ TAC1,TAC
	PUSHJ P,DISSIX
	MOVEI TEM,"]"
	JRST DISTYO

;CTYTYO CTYTY3 TABWAT

;TYPE ON THE CTY WITH PIS OFF  (ALSO TYPE ON CTY ON P2)
; CALLING . . .
;	MOVE TEM,<CHARACTER>
;	PUSHJ P,CTYTYO
; CLOBBERS TAC AND TEM

↑CTYTYO:PUSHJ P,CTGETC			;HAS THERE BEEN ANY TYPEIN?
	JRST CTYTY3			;NO.
	ANDI TAC,177
	CAIE TAC,"O"-100		;IS IT ↑O?
	JRST CTYTY3			;NOT ↑O.  GO ON.
	MOVEI TAC,"↑"
	PUSHJ P,CTPUTC
	MOVEI TAC,"O"
	PUSHJ P,CTPUTC
	MOVEI TAC,15
	PUSHJ P,CTPUTC
	MOVEI TAC,12
	PUSHJ P,CTPUTC
	PUSH P,DAT			;SAVE THIS
	SKIPN DAT,TTYTAB+TCONLN		;IS THERE A CTY DDB
	JRST .+3			;NO.
	ADDI DAT,TTOBUF
	PUSHJ P,SETBFO			;CLEAR OUTPUT BUFFER
	POP P,DAT
	JRST DISINI			;CLEAR DISASTER BUFFER AND POPJ

CTYTY3:	MOVE TAC,TEM			;GET THE CHARACTER
	PUSHJ P,CTPUTC			;TYPE IT.
	SKPNKA
	CAIE TEM,11
	POPJ P,
	MOVEI TEM,5
TABWAT:	MOVEI TAC,0
	PUSHJ P,CTPUTC
	SOJGE TEM,TABWAT
	POPJ P,
;DISDATE DISDA1 DISTIM DISTI2 DIS2DG NCUEN2

;SHOVE THE TIME AND DATE INTO DISASTER BUFFER

REPEAT 0,<
↑DISDATE:
;	MOVEI TEM,1		;SHLUFF
;	PUSHJ P,DISTYO	;TO WARM UP THE CTY
	MOVE TAC,THSDAT
	IDIVI TAC,=31		;DAY-1 IN TAC1
	PUSH P,TAC		;SAVE MONTH AND YEAR
	MOVEI TAC,1(TAC1)	;GET DAY INTO TAC
	PUSHJ P,DISDEC		;PRINT DECIMAL
	POP P,TAC		;MONTH AND YEAR INTO TAC
	IDIVI TAC,=12		;MONTH-1 IN TAC1, YEAR-64 IN TAC
	PUSH P,TAC		;SAVE YEAR
	PUSH P,DSER		;SAVE DSER = TEM+1
	LDB DSER,[POINT 21,MONTAB(TAC1),35]	;GET MONTH NAME
	LSH DSER,8				;SHIFT
	IOR DSER,[BYTE(7)40,0,0,0,40]	;SPACES ON EACH SIDE
DISDA1:	MOVEI TEM,0
IFN DSER-TEM-1,<.FATAL ACs TEM and DSER are not contiguous as required here.>
	LSHC TEM,7
	PUSH P,DSER
	PUSHJ P,DISTYO
	POP P,DSER
	JUMPN DSER,DISDA1
	POP P,DSER
	POP P,TAC1		;YEAR-64
	MOVEI TAC,=64(TAC1)
	PUSHJ P,DISDEC
	MOVEI TEM," "
	PUSHJ P,DISTYO
>;REPEAT 0
DISTIM:	MOVE TAC,TIME
	IDIVI TAC,JIFMIN	;HOURS AND MINUTES IN TAC
DISTI2:	IDIVI TAC,=60		;MINUTES IN TAC1
	PUSH P,TAC1
	PUSHJ P,DIS2DG		;PRINT HOURS AS TWO DIGITS WITH LEADING ZERO
	MOVEI TEM,":"
	PUSHJ P,DISTYO
	POP P,TAC		;GET BACK MINUTES AND FALL INTO DIS2DG
;TYPE TWO DIGIT DECIMAL NUMBER FROM TAC, WITH LEADING ZERO
DIS2DG:	IDIVI TAC,=10		; TYPE TIME AS HH:MM WITH LEADING ZEROS
	PUSH P,TAC1		; I HATED SEEING 19 FOR 00:19!
	MOVEI TEM,"0"(TAC)
	PUSHJ P,DISTYO
	POP P,TEM
	ADDI TEM,"0"
	JRST DISTYO

IFN FTNCU,<
NCUEN2::	;ending address of special code we don't want cached
>;IFN FTNCU

HISYS
;ADVBFE ADVBE1 ADVBE2

	SUBTTL IOCSS

;ROUTINE TO ADVANCE OUTPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ P,ADVBFE
;	EXIT1		RETURN IF NEXT BUFFER IS EMPTY
;	EXIT2		RETURN IF NEXT BUFFER IS FULL
;CLEARS THE USE BIT (IOUSE:=0) OF THE BUFFER POINTED TO BY THE
;OUTPUT BUFFER ADDRESS (DEVOAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS FULL.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO
;MAKE SURE IT IS NOT IN JOB DATA AREA OR ABOVE USER AREA
;THE SECOND WORD OF CURRENT BUFFER WAS CHECKED AT UUO LEVEL
;OR PREVIOUS CALL TO ADVBFE



↑ADVBFE:AOS NABFE			;COUNT BUFFER ADVANCE
	PUSH P,AC3
	JSP AC3,PRSET			;SET UP PROT-RELOC REGISTERS
	SKIPN TAC1,DEVOAD(DDB)		;PICK UP BUFFER ADDRESS
	JRST ADVXIT			;NONE THERE, EXIT
	JSP AC3,ADRCK			;MAKE SURE BUFFER ADDRESS IS LEGAL
	XCTR XW,[MOVEM IOS,-1(TAC1)]	;STORE IO STATUS INTO USER'S BUFFER
	MOVSI TAC,IOUSE
	XCTR XRW,[ANDCAB TAC,(TAC1)]	;CLEAR BUFFER IN USE BIT.
	TRNE IOS,IOIMPM!IODERR!IODTER!IOBKTL ;ANY IO ERRORS?
	JRST ADVXIT			;YES, DO NOT FILL NEXT BUFFER
	MOVEI TAC1,(TAC)		;ADDRESS OF NEXT BUFFER IN RING.
	JSP AC3,ADRCK			;CHECK IT
	HRRM TAC1,DEVOAD(DDB)		;COPY FREE BUFFER ADDRESS TO DDB
	JRST ADVBE2

;ENTER HERE FROM SCNSER TO CHECK IF NEXT BUFFER FULL OF DATA YET

↑ADVBE1:PUSH P,AC3
	JSP AC3,PRSET
ADVBE2:	SKIPN TAC1,DEVOAD(DDB)		;GET BUFFER ADDRESS FROM DDB
	JRST ADVXIT			;NONE THERE.
	XCTR XR,[SKIPL (TAC1)]		;SKIP IF BUFFER IS NOT BUSY
	JRST ADVXIT			;STILL BUSY
	JRST ADVBF1			;SKIP RETURN TO CALLER.  BUFFER FREE.
;PRSET PRSET1 ADRCK

;PRSET  ROUTINE TO PUSH CURRENT PR ON STACK AND SET UP NEW PR
; CALLING . . .
;	JSP AC3,PRSET
; RETURNS WITH PR ON STACK.

;NOTE: ADVBF1 KNOWS PRECISELY HOW MANY THINGS ARE PUSHED BY PRSET, SO
;IF YOU PUSH ANYTHING ELSE, BE SURE TO CHANGE ADVBF1 AND ADVXIT

PRSET:	PUSH P,AC2
	PUSH P,AC1
	PUSH P,J
	PUSH P,TEM
  NPRS←←.-PRSET		;number of things left pushed on stack at return time
	PUSHJ P,PSHMAP		;SAVE STATE OF MAP
	LDB J,PJOBN
	AOS AMC1		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP MAP OR PROTECT-RELOCATE
	MOVEI TEM,JOBPFI	;PROTECTED AREA BOUNDARY.
	PUSH P,TAC1
	MOVEI TAC1,(J)
	PUSHJ P,CORSGT		;TAC1←SIZE OF LOWER IN WORDS
	MOVE AC1,TAC1
	LDB AC2,PSEGN
	JUMPE AC2,PRSET1	;NO UPPER SEGMENT, LEAVE
;	MOVE TAC,AC1
;	CAIGE TAC,400000	;IF LOWER EXCEEDS 128K THEN FIRST ADDRESS IN UPPER
	MOVEI TAC,400000	;  IS 1 ABOVE LOWER, ELSE 400000
	MOVEI TAC1,(AC2)
	PUSHJ P,CORSGT		;TAC1←CORE SIZE OF UPPER IN WORDS
	ADD TAC1,TAC		;+UPPER SEGMENT ORIGIN=FIRST LOC AFTER UPPER.
	MOVE AC2,TAC1
PRSET1:	POP P,TAC1
	JRST (AC3)

;ADRCK ROUTINE TO ADDRESS CHECK SOMETHING
; CALLING . . .
;	MOVE TAC1,<ADDRESS TO BE CHECKED>
;	MOVE TEM,<FIRST PROTECTED ADDRESS>
;	MOVE AC1,<LOWER SEGMENT LENGTH> (I.E., FIRST ADDRESS ABOVE LOWER)
;	MOVE AC2,<UPPER SEGMENT LENGTH> (I.E., FIRST ADDRESS ABOVE UPPER)
;	JSP AC3,ADRCK
; GOES TO ADVXIT IF ERROR

ADRCK:	CAILE TEM,(TAC1)	;ABOVE PROTECTED JOB DATA AREA?
	JRST ADVXIT		;NO, ERROR
	CAILE AC1,(TAC1)	;INSIDE LOWER?
	JRST (AC3)		;YES
	TRNE TAC1,400000	;IS IT UPPER SEGMENT ADDRESS?
	CAIG AC2,(TAC1)		;YES, IS IT WITHIN THE UPPER SEGMENT?
	JRST ADVXIT		;NO, ERROR
	JRST (AC3)		;YES
;ADVBFF ADVBF1 ADVXIT ADVIBX ADVIB1 ADVIB2 ADVIB3 ADVOBX ADVOB1

;ROUTINE TO ADVANCE INPUT BUFFER AT INTERRUPT LEVEL.

;CALL:	PUSHJ P,ADVBFF
;	EXIT1		RETURN IF NEXT BUFFER IS FULL
;	EXIT2		RETURN IF NEXT BUFFER IS EMPTY
;SETS THE USE BIT (IOUSE:=1) OF THE BUFFER POINTED TO BY THE
;INPUT BUFFER ADDRESS (DEVIAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS EMPTY.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO MAKE SURE
;IT IS NOT IN IO PROTECTED PART OF JOB DATA AREA OR ABOVE
;USER AREA
;ALSO END OF BUFFER IS CHECKED TO MAKE SURE NOT ABOVE JOB AREA



↑ADVBFF:PUSH P,AC3
  NADVS←←.-ADVBFF	;number of things we've push on the stack
	AOS NABFF
	JSP AC3,PRSET
	SKIPN TAC1,DEVIAD(DDB)		;IS THERE A BUFFER ADDRESS THERE?
	JRST ADVXIT			;NO, ERROR EXIT
	JSP AC3,ADRCK			;IS BUFFER ADDRESS LEGAL?
	XCTR XW,[MOVEM IOS,-1(TAC1)]	;STORE DEVICE STATUS IN BUFFER
	MOVSI TAC,IOUSE
	XCTR XRW,[IORB TAC,(TAC1)]	;TURN ON USE BIT
	MOVEI TAC1,(TAC)		;ADDRESS OF NEXT BUFFER IN THE RING
	JSP AC3,ADRCK			;IS SECOND BUFFER'S ADDRESS LEGAL?
	HRRM TAC1,DEVIAD(DDB)		;YES. STUFF IT IN THE DDB
	XCTR XR,[SKIPGE TAC1,(TAC1)]	;IS THE NEXT BUFFER FREE?
	JRST ADVXIT			;NO. STILL BUSY
	HLRZ TAC1,TAC1			;TAC1←BUFFER SIZE
	ADDI TAC1,(TAC)			;TAC1←ADDRESS OF END OF THE BUFFER
	JSP AC3,ADRCK			;ADDRESS CHECK
ADVBF1:	SKIPGE TAC,JBTSTS(J)		;IF JOB IS NOT RUNNING
	TLNE TAC,STOPIO			;OR SWAPPING OR COMMAND WAIT
	JRST ADVXIT			;DO NOT ALLOW THE DEVICE TO GO ON.
	TRNN IOS,IOCON!IOIMPM!IODERR!IODTER!IOBKTL ;SKIP IF ANY ERRORS OR IOCON MODE.
	AOS -NPSM-NPRS-NADVS(P)		;SUCCESS RETURN.  FALL INTO ADVXIT
;***  CHANGE THE AOS ABOVE IF THE NUMBER OF THINGS PUSHED BY PRSET IS CHANGED
;NPSM is count of PUSHes by PSHMAP, NPRS is by PRSET, NADVS is by ADVBFF.
ADVXIT:	PUSHJ P,POPMAP			;POP BACK MAP AND AC CONTEXT
	POP P,TEM
	POP P,J
	POP P,AC1
	POP P,AC2
	POP P,AC3
	POPJ P,

;ROUTINE TO EXECUTE CALLER SUPPLIED INSTRUCTION FOR EACH FREE INPUT BUFFER
;IN THE USER'S RING.  CALL ONLY WITH MAP SET UP
;CALL:	PUSHJ P,ADVIBX
;	<INSTRUCTION TO EXECUTE>
;	ALWAYS RETURN HERE
;IF THE EXECUTED INSTRUCTION SKIPS, THEN ADVIBX RETURNS WITHOUT GOING THROUGH
;THE REST OF THE RING

↑ADVIBX:PUSH P,AC3
	SKIPN AC3,DEVIAD(DDB)		;IS THERE A BUFFER ADDRESS THERE?
	JRST ADVIB3			;NO, FORGET IT, SKIP OVER ARG
	MOVE TAC1,AC3
ADVIB1:	XCTR XR,[SKIPGE TAC,(TAC1)]	;SKIP IF THE BUFFER IS FREE
	JRST ADVIB3			;FORGET IT, SKIP OVER ARGUMENT
	PUSH P,TAC
	PUSH P,AC3
	XCT @-3(P)			;EXECUTE CALLER'S INSTRUCTION
	CAIA
	JRST ADVIB2			;ABORT IF IT SKIPS
	POP P,AC3
	POP P,TAC
	MOVEI TAC1,(TAC)		;ADDRESS OF NEXT BUFFER
	CAIE TAC1,(AC3)			;BACK TO FRONT OF LIST?
	JRST ADVIB1			;NO, DO MORE
	JRST ADVIB3

ADVIB2:	POP P,AC3
	POP P,TAC
ADVIB3:	POP P,AC3
	JRST CPOPJ1			;SKIP OVER ARGUMENT

;ROUTINE TO EXECUTE CALLER SUPPLIED INSTRUCTION FOR EACH FREE OUTPUT BUFFER
;IN THE USER'S RING.  CALL ONLY WITH MAP SET UP
;CALL:	PUSHJ P,ADVOBX
;	<INSTRUCTION TO EXECUTE>
;	ALWAYS RETURN HERE
;IF THE EXECUTED INSTRUCTION SKIPS, THEN ADVOBX RETURNS WITHOUT GOING THROUGH
;THE REST OF THE RING

↑ADVOBX:PUSH P,AC3
	SKIPN AC3,DEVOAD(DDB)		;IS THERE A BUFFER ADDRESS THERE?
	JRST ADVIB3			;NO, FORGET IT, SKIP OVER ARG
	MOVE TAC1,AC3
ADVOB1:	XCTR XR,[SKIPL TAC,(TAC1)]	;SKIP IF THE BUFFER IS FULL
	JRST ADVIB3			;FORGET IT, SKIP OVER ARGUMENT
	XCTR XR,[SKIPN 1(TAC1)]		;SKIP IF THERE IS ANY DATA IN THE BUFFER
	JRST ADVIB3
	PUSH P,TAC
	PUSH P,AC3
	XCT @-3(P)			;EXECUTE CALLER'S INSTRUCTION
	CAIA
	JRST ADVIB2			;ABORT IF IT SKIPS
	POP P,AC3
	POP P,TAC
	MOVEI TAC1,(TAC)		;ADDRESS OF NEXT BUFFER
	CAIE TAC1,(AC3)
	JRST ADVOB1
	JRST ADVIB3
;UUOACK UADCK1 UADRCK UADCK2 UADCK3

;ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
;CALL:	HRRZ AC1,<REL ADR.>
;	PUSHJ P,UADCK1
;	NEVER RETURNS IF ERROR,STOPS JOB AND PRINTS ERROR
;BAD ADR. IF IN LOC 20-JOBPFI IN JOB DATA AREA
;OR IF ABOVE PROTECTION(USRREL) FOR CURRENT JOB


↑UUOACK:HRRZ AC1,UUO		;CHECK UUO.
↑UADCK1:TRNN AC1,777760		;IN USER ACS?
	POPJ P,			;YES, ADDRESS IS OK
				;FALL INTO UADRCK

;UADRCK ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
;USER ACS ARE ALSO ILLEGAL(ADR IS FOR IO USE LATER AT
;INTERRUPT LEVEL)
;CALL:	HRRZ AC1,<REL.ADR.>
;	PUSHJ P,UADRCK
;	NEVER RETURN IF ERROR


↑UADRCK:MOVE J,JOB
	CAILE AC1,JOBPFI 	;IS ADR. IN IO PROT. PART OF JOB DATA AREA?
	JRST UADCK2		;NO
	PUSH P,AC1
	MOVE AC1,UUOPC(J)
	TLNE AC1,USRMOD
	JRST UADRER		;USER ISN'T ALLOWED, BUT SAVGET IO NEEDS TO
	POP P,AC1
	POPJ P,

UADCK2:	PUSH P,TAC
	PUSHJ P,TAC1
	MOVE TAC,AC1
	PUSHJ P,ADRTST
	JRST UADCK3
	POP P,TAC1
	POP P,TAC
	POPJ P,

UADCK3:	POP P,TAC1
	POP P,TAC
	JRST UADRER
;COMCHK COMCK0 COMCK1 COMCK2 COMCKE

;CHECK VALIDITY OF A DUMP MODE COMMAND LIST AT UUO LEVEL
;A DUMP MODE COMMAND LIST IS A LIST OF 0 OR MORE IOWD FORMAT WORDS
; TERMINATED BY A GOTO WORD (LH=0), WHICH POINTS TO ANOTHER LIST
; OF 0 OR MORE IOWD FORMAT WORDS, ETC., UNTIL A GOTO WORD IS ENTIRELY ZERO.
;SINCE MONITOR DOES NOT RESCHEDULE WHEN IN EXEC MODE A MAXIMUM LIST
; OF 100 WORDS IS IMPOSED.

;THIS ROUTINE MUST BE CALLED ONLY WHEN THE APR (MAP) IS SET FOR THIS JOB
;CALL:	MOVE UUO,<RELATIVE ADDRESS OF FIRST COMMAND>
;	PUSHJ P,COMCHK
;	<ADDRESS CHECK>		;NO ERROR ROUTINE IS CALLED BY COMCHK
;	<OK>			;TOTAL -WC IS RETURNED IN DAT
;				;ADDRESS OF FIRST IOWD (LH NOT 0) IN UUO


↑COMCHK:PUSH P,UUO		;SAVE POINTER TO LIST
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,UCHN
	HLRZ UCHN,JBTPAG(J)
	LSH UCHN,9		;UCHN←NUMBER OF WORDS IN LOWER
	MOVEI AC1,JOBPFI	;HIGHEST LOC PROTECTED FROM IO IN JOB DATA AREA
	MOVE AC2,UUOPC(J)
	TLNN AC2,USRMOD		;IF THIS A MONITOR CALL, THEN
	MOVEI AC1,JOBSAV	;     HIGHEST LOCATION NOT USED BY SAVGET IO
	SETZB DAT,AC2		;CLEAR WORD COUNT AND ADDRESS OF FIRST IOWD
	MOVEI J,100		;ONLY 100 LISTS
	JRST COMCK1

COMCK0:	HRR UUO,TAC1		;CHANGE COMMAND LIST POINTER ON GO TO WORD
	HRRZ TAC,UUO		;CHECK JUMP ADDRESS
	CAILE TAC,JOBPFI	;ADR ABOVE PROTECETED AREA?
	CAIL TAC,(UCHN)		;AND WITHIN USER'S CORE?
	JRST COMCKE		;ADDRESS ERROR.
COMCK1:	SOJLE J,COMCKE		;JUMP IF WE EXCEED 100 WORDS FETCHED
	XCTR XR,[SKIPN TAC1,(UUO)]	;GET NEXT IOWD.
	JRST COMCK2		;END OF LIST.
	TLNN TAC1,-1		;IS IT A GO TO WORD?
	JRST COMCK0		;YES.  INTERPRET JUMP COMMANDS
	HLRO AC3,TAC1		;NO.  SAVE NEGATIVE WORD COUNT
	HRRZ TAC1,TAC1		;GET LOWEST ADDRESS-1
	CAIGE TAC1,(AC1)	;ABOVE LOWEST PROTECTED ADDRESS?
	JRST COMCKE		;NO.  ERROR.
	SUB TAC1,AC3		;COMPUTE LAST LOCATION
	CAIL TAC1,(UCHN)	;IN BOUNDS?
	JRST COMCKE		;NO.  ERROR.
	SUB DAT,AC3		;ACCUMULATE -WC
	SKIPN AC2		;IS THIS THE FIRST IOWD IN LIST?
	MOVE AC2,UUO		;YES. SAVE ITS ADDRESS IN AC2
	AOJA UUO,COMCK1		;FETCH NEXT IOWD

COMCK2:	SKIPE AC2		;ARE THERE ANY IOWDS WITH LH NOT 0?
	MOVE UUO,AC2		;YES, POINT UUO TO FIRST SUCH IOWD.
				;  OTHERWISE, UUO POINTS TO A ZERO.
	POP P,UCHN
	POP P,AC3	
	POP P,AC2
	JRST TPOPJ1		;REMOVE SAVED UUO AND SKIP RETURN

COMCKE:	POP P,UCHN
	POP P,AC3
	POP P,AC2
	POP P,UUO
	POPJ P,			;ERROR RETURN
;DMPTCH DMPCMD

;DMPCMD - FETCH NEXT IOWD FROM A DUMP MODE COMMAND LIST AND ADDRESS CHECK
;CLOBBERS AC1,AC2,AC3, (CALLED BY IMPSER, DSKSER, PUPSER, VRSSER)

;CALL AT UUO LEVEL, OR WITH MAP SET UP FOR THIS USER:
;	MOVE UUO,<ADDRESS OF COMMAND LIST>
;	PUSHJ P,DMPCMD
;	<END OF LIST>
;	<OK RETURN.>	;UUO POINTS TO CURRENT IOWD FROM COMMAND LIST
;			;TAC1 = RELATIVE STARTING ADDRESS, + BIT 0 IF READONLY
;			;TAC = -WC
;ON ERROR, THIS ROUTINE DOES NOT RETURN, BUT CALLS ADRERR.
;UPPER SEGMENT AND SETPR2 ADDRESSES ARE OK.

DMPTCH:	HRR UUO,TAC1			;HERE ON JUMP WORD.  UUO←NEW ADDRESS
↑DMPCMD:XCTR XR,[SKIPN TAC1,(UUO)]	;GET NEXT COMMAND WORD.
	POPJ P,				;ZERO TERMINATES
	TLNN TAC1,-1			;SKIP IF THERE IS A WORD COUNT
	JRST DMPTCH			;WC=0, THIS IS A JUMP WORD
	MOVEI TAC,1(TAC1)		;USER-RELATIVE STARTING ADDRESS.
	PUSH P,TAC			;SAVE IT.
	HLRO TAC,TAC1			;TAC←-WC
	HRRZ TAC1,TAC1			;FIRST ADDRESS-1
	SUB TAC1,TAC			;TAC1←ENDING ADDRESS
	TLNN TAC1,-1			;SKIP IF ENDING ADDRESS .GT. 256K
	PUSHJ P,RELOCA
	JSP DAT,ADRERR			;ADDRESS ERROR
	MOVE TAC1,(P)			;GET RELATIVE STARTING ADDRESS
	PUSHJ P,RELOCB			;CHECK STARTING ADDRESS (MUST BE SAME SEG)
	JSP DAT,ADRERR			;LOSE.
	HRR TAC1,(P)			;KEEP WRITE PROTECT BIT AND GET
	SUB P,[1,,1]			;  STARTING ADDRESS.  
	JRST CPOPJ1			;RETURN.  TAC=-WC. TAC1=USER STARTING ADDR
;ASSASG ASSAS3 ASSAS9 ASSASJ ASSAS4 ASSAS2 ASSAS1 ASSAS0

;ASSIGN DEVICE IF UNASSIGNED
;CALL:	MOVE J, JOB NUMBER
;	MOVE DDB, ADDRESS OF DDB
;	MOVEI TAC1, EITHER ASSPRG OR ASSCON
;	PUSHJ P, ASSASG
;	CAN'T ASSIGN RETURN
;	DEVICE ASSIGNED RETURN


↑ASSASG:
IFN FTDEVLUP,<
	MOVE TAC,JB2PRV(J)	;GET PASSIVE PRIVS
	TLNE TAC,LUPPRV		;LOCAL USER?
	JRST ASSAS3		;YES. BYPASS TEST
	MOVE TAC,DEVCMR(DDB)
	TLNE TAC,DEVLUP		;REQUIRES LOCAL USER STATUS?
	POPJ P,			;YES.  FAIL.
ASSAS3:
>;FTDEVLUP
	MOVE TAC,DEVCMR(DDB)
IFN FTP2,<
	TLNN TAC,DEVP2		;P2 DEVICE?
	JRST ASSAS9		;NO
	SKIPN NOP2		;YES, SKIP IF P1 HAS P2 DOWN
	SKIPN DETFLG		;SKIP IF P2 THINKS IT'S READY
	POPJ P,			;FAIL IF P2 DOWN FOR P2 DEVICE
ASSAS9:
>;IFN FTP2
	TLNN TAC,DEVSHR		;SHARABLE DEV?
	JRST ASSAS2		;NO
	LDB TAC,PJOBN		;If this DDB belongs to someone, isn't model
	JUMPN TAC,ASSASJ
	MOVE TAC,DEVMOD(DDB)	;Yes, maybe it is detached (in model ddb)
	TRNE TAC,ASSCON		;Is this sharable device down?
	POPJ P,			;Yes, take failure return
ASSASJ:	HRRZ TAC,DEVSER(DDB)
	PUSHJ P,DGETDD(TAC)	;YES - MAKE A NEW DDB, MUST PRESERVE LH(DDB)
	AOS (P)
	JRST ASSAS0		;Can't be a TTY if it's sharable

ASSAS4:	IORM TAC1,DEVMOD(DDB)	;DDB IS ALREADY OURS
	JRST CPOPJ1

ASSAS2:	LDB TAC,PJOBN
	CAIN TAC,(J)		;IS THIS DDB OURS ALREADY?
	JRST ASSAS4		;YES
ASSAS1:	MOVE TAC,[TTYATC,,ASSCON!ASSPRG]
	OFFSCN			;TURN OFF SCANNER CHANNEL
	TDNE TAC,DEVMOD(DDB)	;ONE LAST CHECK
	JRST SCNONJ		;OOPS - EATEN AWAY FROM UNDER US
	PUSHJ P,ASSAS0
	ONSCN			;TURN ON SCANNER CHANNEL
	JRST CPOPJ1

ASSAS0:	DPB J,PJOBN		;NO, STORE JOB NUMBER
	IORM TAC1,DEVMOD(DDB)	;SET ONE OF ASSIGN BITS
	MOVSI TAC,DVTTY
	TDNN TAC,DEVMOD(DDB)	;SKIP IF ASSIGNING A TTY
	POPJ P,			;NOT A TTY
	PUSH P,AC1
	LDB TAC,PUNIT
	SKIPGE TTYTAB(TAC)	;SKIP IF COMBIT IS NOT SET
	SOS COMCNT		;CLEAR COMMAND COUNT
	MOVSI AC1,COMBIT!DLYBIT!PAUSEB ;NO MONITOR COMMANDS FOR THIS GUY NOW
	ANDCAM AC1,TTYTAB(TAC)	;AND CLEAR COMMAND READY BITS, ETC.
	POP P,AC1
	POPJ P,
;FNDDDB DEVSRC DEVLG DEVLP0 DEV0 DEVPHY DEVLP1 DEVLP2 DEVLP3
	
;FIND THE DDB, GIVEN SIXBIT NAME OR CHANNEL NUMBER.
↑FNDDDB:TLNE TAC,770000		;IS IT NAME OR #?
	JRST DEVSRC		;NAME.
	CAMG TAC,USRHCU		;LEGAL CHANNEL?
	SKIPN DDB,USRJDA(TAC)	;GET DDB POINTER, IF ANY
	POPJ P,			;LOSE
	JRST CPOPJ1

;ROUTINE TO SEARCH FOR A DEVICE, GIVEN THE SIXBIT NAME
;CALL:	MOVE J,<JOB NUMBER>	;(FOR LOGICAL NAMES)
;	MOVE TAC,[SIXBIT .DEVICE NAME.]
;	PUSHJ P,DEVSRC
;	<NOT FOUND>
;	<FOUND>			;DDB SETUP.

↑DEVSRC:MOVSI DDB,JLOG	;IF JOB IS NOT LOGGED IN, THEN
	TDNE DDB,JBTSTS(J)	;  SEARCH ONLY PHYSICAL NAMES (DSK:LOGOUT[1,2])
	PUSHJ P,DEVLG		;SEARCH LOGICAL NAMES FIRST
	JRST DEVPHY		;NOT FOUND, SEARCH PHYSICAL NAMES
	JRST CPOPJ1		;FOUND

↑DEVLG:	HLRZ DDB,DEVLST		;SEARCH LOGICAL NAMES. BEGINNING OF DDB CHAIN
DEVLP0:	CAME TAC,DEVLOG(DDB)	;COMPARE WITH LOGICAL NAME
	JRST DEV0		;NO MATCH
	LDB TAC1,PJOBN		;DOES THE LOGICAL NAME BELONG TO THIS JOB?
	CAMN TAC1,J
	JUMPN TAC,CPOPJ1	;YES, GIVE SUCCESSFUL RET. IF NAME NOT 0
DEV0:	HLRZ DDB,DEVSER(DDB)	;NO, KEEP LOOKING
	JUMPN DDB,DEVLP0
	POPJ P,			;FINISHED AND NOT FOUND

;Search for device's DDB given its physical name.  Return with DDB set
;up, and LH(DDB) containing SYSDEV if device was SYS (DDB will point to DSK).
↑DEVPHY:CAMN TAC,['OPR   ']	;SEARCH PHYSICAL NAMES.   IS IT "OPR"?
	MOVE TAC,DEVOPR		;YES, CHANGE TO OPERATOR'S TTY
	CAMN TAC,['SYS   ']	;IS IT "SYS"?
	TLCA TAC,'DSK'≠'SYS'	;YES, CHANGE TO SYS: DEVICE NAME
	TDZA TAC1,TAC1		;NO, CLEAR SYS: FLAG
	MOVEI TAC1,SYSDEV	;YES, SET SYS: FLAG
	HLRZ DDB,DEVLST		;SEARCH DEVICE DATA BLOCKS
DEVLP1:	TLO DDB,(TAC1)		;SET SYSDEV BIT IF SEARCHING FOR SYS
	CAMN TAC,DEVNAM(DDB)	;MATCH OF PHYSICAL NAME?
	JUMPN TAC,CPOPJ1	;YES, GIVE OK RET. IF NAME IS NOT 0
DEVLP2:	HLRZ DDB,DEVSER(DDB)
	JUMPN DDB,DEVLP1
	CAME TAC,['TTY   ']	;IS THIS PUBLIC LOGICAL NAME TTY?
	JRST DEVLP3		;NO. SEE IF IT'S A SPECIFIC TTY.
	PUSH P,DAT		;SAVE OUTPUT BYTE POINTER (TTY) OR INIT. ARG. ADR.
	PUSHJ P,TTYFND		;YES, FIND TTY JOB IS ATTACHED TO
	HRRZ DDB,DDB		;TTY isn't SYS device, clear SYSDEV bit in LH
	POP P,DAT		;RESTORE
	JRST CPOPJ1		;AND GIVE SUCCESSFUL RETURN

DEVLP3:	PUSH P,TAC		;SAVE DEVICE NAME IN CASE NOT FOUND
	PUSH P,DAT		;AND THIS IN CASE IT IS
	PUSHJ P,UGTDDB		;SEE IF TTY DDB (ENTRY POINT FOR TIP PORT OK)
	 CAIA
	AOS -2(P)		;SKIP ON SUCCESS
	HRRZ DDB,DDB		;TTY isn't SYS device, clear SYSDEV bit in LH
	POP P,DAT
	POP P,TAC
	POPJ P,
;

;CALL:	PUSHJ P,BUFCLC
;	<OK RETURN>		;IF MEMORY NOT EXCEEDED

Comment $	Buffer Ring Format

This routine will set up an N buffer ring, where N is taken from the
right half of ac UUO.  The byte pointer PDVBLN into the DDB yields
the <data size of each buffer>+1.  In addition to the one overhead
word implied by PDVBLN, two additional words are needed for each
buffer.  Thus, the size of each buffer (refered to as SIZE+2) is three
more than the data area in the buffer.  (The UUOs UINBF and UOUTBF
enter at BUFCLM with TAC setup to the <data size of the buffer>+1
which is the parameter specified by the user.)

N buffers are set up, (B0, B1, ... B(N-1)).  The address of the first
buffer, B0, is given by the right half of JOBFF.  JOBFF will be 
advanced by N*(SIZE+2) upon return.  User's core size will be expanded
if necessary.

The buffer ring looks like:
B0/
B0+1/		SIZE,,B1+1
		BLOCK SIZE
B1/
B1+1/		SIZE,,B2+1
	    	BLOCK SIZE

		....

B(N-1)/
B(N-1)+1/	SIZE,,B0+1
		BLOCK SIZE


On return, ac BUFPNT will contain IOUSE,,B0+1
and JOBFF will have been increased by N*(SIZE+2)

$

;BUFCLC BUFCLM BUFC2 BUFC1

BUFCLC:	LDB TAC,PDVBLN		;GET BUFFER SIZE IN TAC
BUFCLM:	PUSH P,AC3		;ALTERNATE ENTRY FOR UINBF, UOUTBF
	XCTR XR,[HRRZ BUFPNT,JOBFF]
	ADDI BUFPNT,1		;BUFPNT←FIRST FREE USER LOC+1
	HRRZ AC3,BUFPNT
	HRL AC3,TAC		;AC3←(BUFSIZ,,JOBFF+1)
	ADDI TAC,2		;ADD 2 TO BUFFER SIZE (= ACTUAL SIZE OF BUFFER)
	HRRZ TAC1,UUO		;GET NUMBER OF BUFFERS
	JUMPG TAC1,.+2		;SKIP UNLESS NONE WERE REQUESTED. (ME 12-11-72)
	MOVEI TAC1,2		;GIVE HIM TWO, IF NONE WERE REQUESTED.
	HRRZ AC1,TAC		;AC1←(SIZE+2)
	IMUL AC1,TAC1		;AC1←N*(SIZE+2)
	ADDI AC1,-1(AC3)	;AC1←N*(SIZE+2)+(C(JOBFF)+1)-1 (=NEW JOBFF)
	PUSH P,AC1		;SAVE NEW VALUE FOR JOBFF
	MOVE AC1,JOB
	HLRZ AC1,JBTPAG(AC1)
	LSH AC1,9
	CAMLE AC1,(P)		;SKIP IF WE HAVE LESS CORE THAN WE NEED
	JRST BUFC1		;WE HAVE ENOUGH CORE.  GO MAKE BUFFERS.
	MOVE AC1,(P)		;THIS IS HOW MUCH WE'LL NEED
	PUSH P,TAC		;NO. SO, SAVE SOME ACS AND GET MORE CORE.
	PUSH P,UUO
	PUSH P,TAC1
	PUSH P,BUFPNT
	PUSH P,AC3
	PUSH P,DDB
	PUSH P,DSER
	MOVE J,JOB
	MOVE TAC,AC1		;HOW HIGH WE NEED.
	MOVEI UUO,UUO
	PUSHJ P,UCORE
	JRST UADRER		;ADDRESS ERROR IF WE CAN'T GET ENOUGH CORE.
	POP P,DSER
	POP P,DDB
	POP P,AC3
	POP P,BUFPNT
	POP P,TAC1	
	POP P,UUO
	POP P,TAC
	JRST BUFC1

BUFC2:	HRR BUFPNT,AC3			;ADVANCE TO NEXT BUFFER.
BUFC1:	ADD AC3,TAC			;MAKE ADDRESS OF NEXT BY ADDING LENGTH
;BUFPNT=CURRENT BUFFER, AC3=POINTER TO NEXT BUFFER.
	XCTR XW,[MOVEM AC3,(BUFPNT)]	;PREVIOUS BUFFER POINTS TO NEXT BUFFER
	SOJG TAC1,BUFC2			;LOOP TO MAKE ENOUGH BUFFERS.
	XCTR XR,[HRR AC3,JOBFF]		;GET JOBFF
	ADDI AC3,1			;SIZE,,ADDRESS OF FIRST BUFFER
	XCTR XW,[MOVEM AC3,(BUFPNT)]	;LINK LAST BUFFER TO FIRST BUFFER
	POP P,AC1
	XCTR XRW,[HRRM AC1,JOBFF]	;STORE NEW VALUE OF JOBFF.
	HRRZ BUFPNT,AC3			;LOAD IN USE BIT AND ADDRESS OF FIRST BUFFER
	HRLI BUFPNT,IOUSE
	POP P,AC3
	POPJ P,
;BUFCLR CLRBYT DEVCR DEVSTU

;BUFCLR - ROUTINE TO CLEAR IO BUFFER IN USER AREA - UUO LEVEL ONLY!
;CALL:	HRRZ TAC,<REL. ADR. OF 2ND WORD OF USER BUFFER>
;	PUSHJ P,BUFCLR		;CLEARS THE WC AND DATA AREA OF THE BUFFER
;	<OK RETURN>		;CALLS UADRER ON FAILURE

↑BUFCLR:XCTR XW,[SETZM 1(TAC)]			;CLEAR WC WORD OF BUFFER.
	XCTR XLB,[LDB TAC1,[POINT 17,(TAC),17]]	;TAC1←BUFFER SIZE
	ADDI TAC1,(TAC)				;TAC1←LAST ADDRESS IN BUFFER
	HRL TAC,TAC				;ADDR,,ADDR
	ADD TAC,[1,,2]				;<WC WORD ADDR>,,<WC WORD ADDR+1>
	XCTR XBLTRW,[BLT TAC,(TAC1)]		;ZERO CORE IN USER SPACE.
	POPJ P,


;CLRBYT - CLEAR RESIDUE OF WORD POINTED TO BY A BYTE POINTER
;CALL:	MOVE TAC,<BYTE POINTER>
;	PUSHJ P,CLRBYT
;CLEARS THE REST OF THE WORD POINTED TO BY THE BYTE POINTER.

↑CLRBYT:LDB TAC1,[POINT 6,TAC,5]	;SET UP POINTER
	DPB TAC1,[POINT 12,TAC,11]	;TAC 0-5:=0,TAC 6-12:=P
	MOVEI TAC1,0
	DPB TAC1,TAC			;CLEAR BITS 36-P THROUGH 35
	POPJ P,				;RETURN


;CHECK RING USE BIT TO SEE IF USER HAS ANOTHER BUFFER TO FILL.  UUO LEVEL ONLY!
;CLOBBERS TAC.  SKIPS IF USER HAS SOME FREE BUFFER TO FILL.

↑DEVCR:	HLRZ TAC,DEVBUF(DDB)		;ADDRESS OF USER'S BUFFER HEADER
	XCTR XR,[MOVE TAC,(TAC)]	;FETCH POINTER TO CURRENT BUFFER.
	XCTR XR,[SKIPL (TAC)]		;CHECK THE RING USE BIT.
	JRST CPOPJ1			;BUFFER IS FREE, LET HIM FILL IT
	POPJ P,


;SET UP WORD COUNT IN AC2 AND 7-BIT RELATIVE BYTE POINTER TO DATA IN AC3
;DDB MUST BE SET UP.  ROUTINE SKIPS ON SUCCESS, DOESN'T SKIP IF BUFFER IS EMPTY.
;UUO LEVEL ONLY!

↑DEVSTU:HRRZ AC3,DEVOAD(DDB)		;GET ADDRESS OF USER BUFFER
	XCTR XR,[SKIPL (AC3)]		;SKIP UNLESS BUFFER IS EMPTY
	POPJ P,				;BUFFER ALREADY HAS BEEN EMPTIED.
	XCTR XR,[HRRZ AC2,1(AC3)]	;AC2←BUFFER WC.
	ADD AC3,[POINT 7,2]		;7 BIT BYTES RELATIVE TO BUFFER.
	JRST CPOPJ1			;SKIP ON SUCCESS
;IOWAIT IORELS IOALL IOALL1 IOALL2 IOALLP IOALP1 IOALP2 IOALLW IOALLX IOALLY IOALLR IOALR1 IOALR2 IOALR3

;THE SIGN BIT IN THE ARGUMENT TO IOALL (USED BY IOWAIT) PREVENTS IOALLP
;FROM RELEASING THE IO PDL, WHICH WOULD OTHERWISE HAPPEN IF IT CONTAINS
;ONLY UNUSED CHANNELS (NO DDB POINTER).  AS OF 8/27/75 THE ONLY CALLERS
;OF IOALL ARE THE TWO BELOW AND ONE ON THE NEXT PAGE WHICH CALLS RELEA5
;SO IOWAIT IS THE ONLY USER WHO DOESN'T WANT TO RELEASE THE PDL.  -- BH

;NOTE FURTHER THAT IOALL (AND, HENCE ITS CALLERS, IORELS, IOKILL, IOWAIT)
;CALLS ANYACT WHICH WILL SUSPEND SPACEWAR.  YOU'D BETTER MAKE SURE THAT
;ALL CALLERS REINSTATE SPACEWAR WHEN THEY CAN (ONLY RELEVANT FOR IOWAIT,
;SINCE ALL OTHER CALLERS ARE DOING RESET OR EXIT).

;IOALL - DO IO FOR ALL DEVICES ASSIGNED TO JOB.
;CALL:	MOVEI TAC,<ADR. OF IO SUBR>
;	PUSHJ P,IOALL


↑IOWAIT:SKIPA TAC,[400000,,WAIT1];WAIT FOR ALL DEVICES TO BE INACTIVE
↑IORELS:MOVEI TAC,RELEA3	;RELEASE ALL IO DEVICES. FALL INTO IOALL
IOALL:	PUSH P,TAC		;SAVE SUBROUTINE CALL
	SETZB UCHN,UUO		;START WITH USER CHANNEL 0
	SKIPL DDB,USRHCU	;IS THIS NEGATIVE?
	JRST IOALL1		;NO. - NORMAL
	SETZM USRHCU		;SAVGET ACTIVE. RELEASE DEVICE ANYWAY!
	JRST IOALL2

IOALL1:	CAMLE UCHN,USRHCU	;IS IT GREATER THAN HIGHEST CHAN. USED?
	JRST IOALLP		;YES. DO THE IOPDL NEXT
	SKIPN DDB,USRJDA(UCHN)	;GET NEXT DDB ADR., IS IT IN USE?
	AOJA UCHN,IOALL1	;NO, KEEP GOING
IOALL2:	MOVE IOS,@DEVSPT(DDB)
	DPB UCHN,PUUOAC
	MOVE DSER,DEVSER(DDB)	;SETUP ADR. OF DEV. DISP. TABLE
	LDB J,PJOBN		;DOES THIS DDB BELONG
	CAME J,JOB		;TO THIS JOB?
	AOJA UCHN,IOALL1	;NO. DON'T BOTHER WITH THIS OTHER
	PUSH P,UCHN		;JAM CLOBBERS THIS IN IMPSER
	PUSHJ P,@-1(P)		;CALL IO SUBR
	POP P,UCHN
	MOVE J,JOB		;KEEP THIS HONEST
	AOJA UCHN,IOALL1	;INCREMENT USER CHAN. NO.

IOALLP:	SKIPL UCHN,JBTIOP(J)	;GET IO PDL POINTER
	JRST IOALLW		;NONE THERE. 
IOALP1:	SKIPN DDB,(UCHN)	;SKIP FLUSHED CHANNELS
	JRST IOALP2
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)	;EVERYONE MUST LIVE SOMEWHERE
	MOVE DDB,USRJDA
	PUSH P,UCHN
	MOVEI UCHN,0
	MOVE IOS,@DEVSPT(DDB)
	DPB UCHN,PUUOAC
	MOVE DSER,DEVSER(DDB)	;SETUP ADR. OF DEV. DISP. TABLE
	LDB J,PJOBN		;DOES THIS DDB BELONG
	CAMN J,JOB		;TO THIS JOB?
	PUSHJ P,@-1(P)		;YES, CALL THE SUB.
	MOVE J,JOB		;KEEP THIS HONEST
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
	JUMPE DDB,IOALP2
	MOVSI DDB,400000	;SET FLAG TO NOT RETURN JBTIOP
	IORM DDB,(P)
IOALP2:	ADD UCHN,[2,,2]
	JUMPL UCHN,IOALP1
	SKIPG (P)		;SKIP IF WE SHOULD RETURN THE IOPDL
	JRST IOALLW		;DON'T RETURN THE IOPDL
	PUSH P,AC1
	HRRZ AC1,JBTIOP(J)	;FLUSH IO STACK
	SETZM JBTIOP(J)
	PUSHJ P,FSGIVE
	POP P,AC1
IOALLW:	PUSH P,AC2
	PUSH P,TAC1
	JRST IOALLY

IOALLX:	PUSHJ P,WSCHED		;DELAY A WHILE
IOALLY:	PUSHJ P,ANYACT		;MAKE SURE ALL IO HAS REALLY STOPPED
	JRST IOALLX
	POP P,TAC1
	POP P,AC2
	JRST TPOPJ		;FLUSH ARGUMENT ADDRESS AND RETURN.


;HERE TO CHASE THROUGH THE DDB LIST AND CALL RELEA5 FOR ANY DDB OF OURS
;CALLED FROM IOKILL, FINISH COMMAND.
;THIS IS A KLUDGE TO RECTIFY THE PROBLEM OF DDBS GETTING LOST FROM JOBJDA
;DUE TO SWAPPING, PARITY ERRORS, ETC.

IOALLR:	PUSH P,USRJDA
	MOVEI DDB,DEVLST-DEVSER
IOALR1:	HLRZ DDB,DEVSER(DDB)
	JUMPE DDB,IOALR3
IOALR2:	LDB J,PJOBN
	CAME J,JOB
	JRST IOALR1
	MOVE UCHN,DEVMOD(DDB)
	TRNN UCHN,ASSPRG	;ASSIGNED BY PROGRAM?
	JRST IOALR1		;NO
	MOVEM DDB,USRJDA
	MOVEI UCHN,0
	DPB UCHN,PUUOAC
	MOVE IOS,@DEVSPT(DDB)
	MOVE DSER,DEVSER(DDB)	;SETUP ADR. OF DEV. DISP. TABLE
	PUSH P,DSER		;SAVE DSER
	PUSHJ P,RELEA5		;RELEASE THIS DDB
	POP P,DDB
	HLRZ DDB,DDB		;ADDRESS OF NEXT DDB
	JUMPN DDB,IOALR2	;CONTINUE THROUGH THE DDB CHAIN.
IOALR3:	POP P,USRJDA
	MOVE J,JOB		;KEEP THIS HONEST
	POPJ P,
;IOKILL CLRUSR

;KILL ALL DEVICES(RELEASE WITHOUT WAITING FOR DEVICE INACTIVE)

↑IOKILL:MOVEI TAC,RELEA5
	PUSHJ P,IOALL		;RELEASE ALL DEVICES WITHOUT WAITING
	PUSHJ P,IOALLR		;CHASE THRU DDB LIST AND RELEASE ANY OTHERS

;ROUTINE TO CLEAR PROTECTED JOB DATA AREA IN MONITOR
;AND RECLAIM FREE AREA ABOVE USER PROGRAM FOR IO BUFFERS

	XCTR XR,[HLRZ TAC,JOBSA]	;RESET FIRST FREE LOC. FOR THIS JOB
	XCTR XW,[MOVEM TAC,JOBFF]
↑CLRUSR:XCTR XW,[SETZM JOBENB]		;INITIALIZE USER FOR NO TRAPS ENABLED
	MOVEI TAC,USRLO1		;FIRST LOC+1 TO CLEAR
	HRLI TAC,USRLO			;FIRST LOC.
	SETZM USRLO
	BLT TAC,USRHI
	SETZM USRHCU			;CLEAR HIGHEST USER IO CHAN. IN USE
	POPJ P,
;ORACT SETACT CLRACT STOIOS ORACT1

;FLAG DEVICE AS ACTIVE
;CALL:	MOVE IOS,IO STATUS BITS
;	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,SETACT
;CALLED BY ALL IO SERVICE ROUTINES AT UUO AND INTERRUPT LEVELS

LOSYS


↑ORACT:	ERRSPW			;JUMP TO SPWERR IF SPACEWAR LEVEL
	TRO IOS,IOACT
	IORB IOS,@DEVSPT(DDB)
	JRST ORACT1

↑SETACT:ERRSPW
	TROE IOS,IOACT
	JRST STOIOS
	TLZA IOS,IOW
↑CLRACT:TRZ IOS,IOACT
↑STOIOS:MOVEM IOS,@DEVSPT(DDB)
ORACT1:	LDB TAC,PDVTIM		;GET NO. OF SECONDS
	DPB TAC,PDVCNT		;TO WAIT BEFORE DEVICE IS HUNG
	POPJ P,

HISYS
;DEVCHK DEVCK0 DEVCKA DEVCK3 DEVCK1 DEVKSW DEVKSL DEVKS3 DEVKS2 DEVKSX DEVTTL DEVTER DEVTE2 DEVNOT DEVCK6 IRMAXX DEVCK9 CTYIRM DEVCK7 DEVCK8 DEVCK4

;HUNG TIMEOUT 
;UPDATES HUNG COUNT FOR EACH DEVICE.  HERE ONCE A SECOND from CLKSER only.
;DISPATCHES TO DEVICE SERVICE IF COUNT IS EXHAUSTED.

↑DEVCHK:
IFN FTF2,<
	MOVSI UUO,-NPACKS	;See if any disk packs have timed out
	SOSE PACBSY(UUO)	;Decrement busy count, skip if timing out
	AOBJN UUO,.-1
	JUMPGE UUO,.+2		;JUMP IF SCAN FINISHED -- ALL DISKS OK
	PUSHJ P,DSKDSP+DHNG	;CALL DISK HUNG ROUTINE
>;IFN FTF2
IFE FTF2,<
	SOSE DSKHNG+0		;SEE IF DISK IS HUNG THIS WAY! (CHANNEL 0)
	SOSN DSKHNG+1		;SEE IF CHANNEL 1 IS HUNG
	PUSHJ P,DSKDSP+DHNG	;CALL DISK HUNG ROUTINE
IFN TVNUM,<
	SKIPLE IOPHCT		;SKIP IF IOP IS INACTIVE
	SOSE IOPHCT		;IOP ACTIVE. COUNT DOWN AND SKIP IF HUNG.
	JRST .+2		;IOP IDLE OR NOT HUNG
	PUSHJ P,IOPHNG		;KICK IOP
>;IFN TVNUM
IFN FTRH,<
	PUSHJ P,PHYCHK↑		;Call PHYSIO once per second
>;IFN FTRH
>;IFE FTF2

IFN UPACKS,<
	MOVEI DDB,UDP1.NX	;SKIP DSK AND UDP, GET FIRST DDB AFTER UDP
>;IFN UPACKS
IFE UPACKS,<
	MOVEI DDB,DSK.NX	;SKIP DSK AND UDP, GET FIRST DDB AFTER UDP
>;IFE UPACKS
DEVCK0:	MOVE IOS,@DEVSPT(DDB)	;IS DEVICE ACTIVE?
	MOVE DAT,DEVCMR(DDB)	;PULL IN EXTRA DEVCHR BITS
IFN FTP2,<
	TLNN DAT,DEVP2		;IS THIS A P2 DEVICE?
	JRST DEVCKA		;NO
	TLNE DAT,DEVP2H		;P2 WANT HUNG DEVICE?
	JRST DEVCK4		;YES
	SKIPE NOP2HG		;SUPPRESSING HUNG TIMEOUT ON P2 DEVICES?
	JRST DEVCK1		;YES, IGNORE THIS DEVICE
>;IFN FTP2
DEVCKA:	TRNE IOS,IOACT
	JRST DEVCK3		;YES.
	TLNE DAT,DEVIBF		;DOES THIS DEVICE HAVE AN INTERNAL BUFFER?
	TLNN IOS,DEVSBB		;IF IT DOES, IS IT BUSY?
	JRST DEVCK1		;NOT BUSY, IGNORE DEVICE
DEVCK3:	LDB TAC,PDVCNT		;YES, DECREMENT HUNG COUNT
	SOJL TAC,DEVCK1		;0 MEANS IGNORE DEVICE
	DPB TAC,PDVCNT		;NOW REPLACE IT IN THE DDB
	JUMPN TAC,DEVCK1	;HAS COUNT GONE TO 0?
	MOVE DSER,DEVSER(DDB)	;YES, GET DISPATCH TABLE ENTRY
	PUSH P,DDB
	PUSHJ P,DHNG(DSER)	;DISPATCH TO SERVICE ROUTINES TO UNHANG DEVICE
	 PUSHJ P,DEVHNG		;PRINT ERROR MESSAGE AND STOP JOB
	POP P,DDB		;DO NOT PRINT MESS. AND STOP JOB RETURN
DEVCK1:	HLRZ DDB,DEVSER(DDB)
	CAIE DDB,TTYLST		;DON'T DO TTY'S
	JUMPN DDB,DEVCK0

IFN FTSPWT,<
	MOVE DDB,[-KBDNUM,,DCADP0] ;Aobjn ptr for kbd SPW data
DEVKSW:	SKIPL TAC,KBDCHR(DDB)	;Is a SPW REQ pending for the kbd?
DEVKSL:	AOBJN DDB,DEVKSW	;No, next kbd
	JUMPGE DDB,DEVKSX	;Jump if finished checking kbds
	TLNN TAC,POLTMO		;Been a previous one-second tick since REQ?
	JRST DEVKS2		;No, this is the first one, set flag for next time
	MOVE TAC1,DCATAB(DDB)	;Yes, the kbd has timed out, see if it is down
caia;	TLNN TAC,POLTM2		;Skip if already recorded timeout for this kbd
	TRNE TAC1,DCADWN	;Skip unless flagged down
	JRST DEVKS3		;Don't type on CTY
	PUSHACS
	PUSHJ P,DISUSR		;Print time of msg on CTY
	 SIXBIT /KBDTMO/
	PUSHJ P,DISERR
	 [ASCIZ/SPW timeout for kbd on DCA port /]
	 DISARG LOC,<DDB-20(P)>	;Port number
	 [ASCIZ/; KBDCHR cell = /]
	 DISARG OCH,<TAC-20(P)>
	 -1
	PUSHJ P,DISCRL
	POPACS
DEVKS3:	MOVSI AC1,SPWREQ!POLTMO	;Clear request flag and timeout-checking flag
	ANDCAM AC1,KBDCHR(DDB)
	MOVSI AC1,POLTM2	;Set flag to avoid typing on CTY again
	IORM AC1,KBDCHR(DDB)	;Remember that kbd has timed out
	JRST DEVKSL		;Next kbd

DEVKS2:	MOVSI AC1,POLTMO	;Remember that a second has ticked with no response
	IORM AC1,KBDCHR(DDB)
	JRST DEVKSL		;Next kbd

DEVKSX:
>;FTSPWT
IFN FTDTTYBUG,<
	SKIPN TTDDCK		;IS BUG TRAP ENABLED?
	JRST DEVNOT		;NOPE
	MOVEI DDB,SCNDDB	;SCAN TTY DDBS FOR ANY WITH NO JOB, SKIP CTY
DEVTTL:	HLRZ DDB,DEVSER(DDB)	;NEXT DDB
	JUMPE DDB,DEVNOT	;JUMP IF NO MORE TTY DDBS
	MOVE AC2,DEVMOD(DDB)	;SEE IF DDB IN USE BY ANYONE AT ALL
	TDNN AC2,[TTYATC,,ASSPRG!ASSCON] ;SKIP IF THIS DDB IS REALLY IN USE
	SKIPGE CRETIM(DDB)	;SKIP UNLESS ALREADY NOTED THIS DDB LOST
	JRST DEVTTL		;PROBABLY OK, OR ALREADY LISTED AS LOST
	MOVSI TAC,TTYKCL	;SEARCH FOR CLOCK REQ TO KILL THIS DDB
	HRR TAC,DDB
	HRRZ AC3,CLKQ		;ADDRESS OF LAST ENTRY IN CLOCK QUEUE
DEVTER:	CAIGE AC3,CLKQUE	;BACK TO BEGINNING OF QUEUE?
	JRST DEVTE2		;YES, NO CLK REQ, WE HAVE A LOST TTY DDB
	CAMN TAC,(AC3)		;IS THIS A CLK REQ TO KILL DDB WE'RE CHECKING?
	JRST DEVTTL		;YES, THEN DDB ISN'T LOST (YET)
	SOJA AC3,DEVTER

DEVTE2:	LDB AC1,PJOBN		;GET JOB NUMBER
	LDB DAT,PUNIT		;GET LINE NUMBER
	HRRZ AC3,TTYTAB(DAT)
	CAIN AC3,(DDB)		;DOES TTYTAB ACTUALLY POINT TO THIS DDB?
	JRST DEVTTL		;YES, ISN'T LOST AFTER ALL
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /LOSDDB/
	PUSHJ P,DISERR
	[ASCIZ/Lost TTY DDB = /]
	DISARG LOC,<DDB-20(P)>
	[ASCIZ/  DEVNAM = /]
	DISARG SIX,<DEVNAM(DDB)>
	[ASCIZ/  PUNIT = /]
	DISARG LOC,<DAT-20(P)>
	[ASCIZ/  PJOBN = /]
	DISARG LOC,<AC1-20(P)>
	[ASCIZ/  CRELIN = /]
	DISARG LOC,<CRELIN(DDB)>
	[ASCIZ/  Created at /]
	-1
	HRRZ TAC,CRETIM(DDB)	;Get TTY DDB's creation time in seconds
	IDIVI TAC,=60		;Minutes in TAC, seconds in TAC1
	PUSH P,TAC1
	PUSHJ P,DISTI2		;Print hours and minutes
	MOVEI TEM,":"
	PUSHJ P,DISTYO
	POP P,TAC		;Seconds
	PUSHJ P,DIS2DG		;Print seconds as two digits with leading zero
	PUSHJ P,DISMES
	ASCIZ / on /
	HLRZ TAC,CRETIM(DDB)
	ANDI TAC,77777		;Flush "DDB-created-detached" bit
	IDIVI TAC,=31		;Figure out day of month of DDB creation
	MOVEI TAC,1(TAC1)
	PUSHJ P,DISDEC		;Print day of month in decimal
	MOVE TAC,CRETIM(DDB)
	MOVEI TEM,"!"		;Print exclamation point if ddb created detached
	TLNE TAC,200000		;Bit meaning created detached
	PUSHJ P,DISTYO		;Created detached
	PUSHJ P,DISCRLF
	AOS TTDDCN		;Count another lost tty ddb
	DEBCHECK(POPACS)	;Call DDT if debugging
	MOVSI TAC,400000
	IORM TAC,CRETIM(DDB)	;Remember that this lost ddb has been listed
	JRST DEVTTL

DEVNOT:
>;IFN FTDTTYBUG
IFE FTGRIN,<
	PUSH P,[SCNNUM]		;NOW CHECK THIS MANY TTYS FOR IRMAS
>;IFE FTGRIN
IFN FTGRIN,<
	PUSH P,[SCNNUM+DDNUM]	;CHECK FOR IRMAS ON GRINNELL.  THEY HAPPEN!
PRINTX DEVCHK checks for IRMAs on Grinnells, since they do happen.
>;IFN FTGRIN
	MOVEI DDB,SCNDDB	;Check CTY specially for IRMAs
	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TOIP		;Typeout in progress?
	TLNE IOS,TTYHLD		;Yes, is he holding (tty'ly)?
	JRST DEVCK8		;No typeout in progress or else holding--not hung
	TLNN IOS,IRMA		;Have we been a second without an interrupt?
	JRST DEVCK7		;No
	JRST CTYIRM		;Yes, start up output on CTY

DEVCK6:	SKIPN DDB,TTYTAB(TAC1)
	JRST DEVCK8		;No DDB, can't be hung
	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TOIP		;Typeout in progress?
	TLNE IOS,TTYHLD		;Yes, is he holding (tty'ly)?
	JRST DEVCK8		;No typeout in progress or else holding--not hung
	HRRZ AC1,LINBIT(TAC1)	;Get DCA port number, if any
	TRZN AC1,400000		;Skip if on DCA scanner
	JRST DEVCK8		;Don't check tty not on scanner
	TLNN IOS,IRMA		;Have we been a second without an interrupt?
	JRST DEVCK7		;No
	MOVSI IOS,TOIP!IRMA	;Yes, we caught an IRMA (missed interrupt)
	ANDCAB IOS,DEVIOS(DDB)	;Clear these bits so we can restart output
	MOVE AC1,DCATAB(AC1)	;See if DCA port is down or CDless phone line
	TRNN AC1,DCAPRM		;If this is a phone line,
	TLNE AC1,DCACAR		; w/o carrier detect up, then flush output buf
	TRNE AC1,DCADWN		;Skip if port is up
	JRST DEVCK9		;Down tty or Phone line w/o CD -- clear output
	PUSHJ P,UTYPET		;Now start up the silly tty again
IFN FTIRMA,<
	LDB AC1,PJOBN		;Get tty's owner
	MOVE TAC,DEVMOD(DDB)
	TRNE TAC,ASSCON		;ASSIGNED BY CONSOLE
	JUMPE AC1,DEVCK8	; BY JOB 0 MEANS DETACHED FROM SYS

	LDB TAC,PUNIT		;TTY NUMBER
REPEAT 1,<
	SOS TAC1,IRMCNT(TAC)	;SEE IF THIS IS THE FIRST IRMA THIS MINUTE
>;REPEAT 1
REPEAT 0,<
	SOSL TAC1,IRMCNT(TAC)	;COUNT RECENT IRMAS
	JRST IRMAXX		;NOT ENOUGH TO KILL IT
	HRRZ TAC,LINBIT(TAC)	;DCA PORT NUMBER
	JUMPE TAC,IRMAXX	;NOT DCA PORT
	PUSHACS
	PUSH P,TAC
	PUSHJ P,DCADET		;TURN THE PORT OFF IN HARDWARE
	POP P,TAC
	MOVEI DAT,-400000(TAC)
	PUSHJ P,DCARUI		;NOW NOTIFY THE OPERATOR
	POPACS
>;REPEAT 0
IRMAXX:	CAIE TAC1,IRMANO-1	;IS THIS THE FIRST IRMA?
	JRST DEVCK8		;NO, NO MESSAGE

	PUSH P,JOBNAM(AC1)	;so we can print it
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /IRMA!/
	PUSHJ P,DISERR
	[ASCIZ /Output interrupt missed on TTY/]
	DISARG LOC,<-2(P)>	;line number
	[ASCIZ/   Jobname: /]
	DISARG SIX,<-1(P)>	;Job name
	-1
	PUSHJ P,DISCRLF
	SUB P,[1,,1]		;Flush jobname from stack

IFN FTDCHK,<
	PUSHACS
	LDB TAC1,PUNIT		;TTY NUMBER
	HRRZ TAC1,LINBIT(TAC1)	;PORT NUMBER, IF DCA PORT
	TRZE TAC1,400000	;SKIP IF NOT DCA PORT
	PUSHJ P,DCAIRM		;CALL DCASER TO TYPE OUT STATUS FOR THIS LINE
	POPACS
>;IFN FTDCHK
>;IFN FTIRMA
	JRST DEVCK8

DEVCK9:	PUSHJ P,SETBF2		;Down tty -- clear output buffer
CTYIRM:	PUSHJ P,UTYPET		;Now start up the silly tty again
	JRST DEVCK8

DEVCK7:	MOVSI IOS,IRMA
	IORM IOS,DEVIOS(DDB)	;Note that we're awaiting an interrupt for this TTY
DEVCK8:	SOSL TAC1,(P)
	JRST DEVCK6
	SUB P,[1,,1]		;Flush line number data from stack
	POPJ P,

DEVCK4:	MOVSI TAC,DEVP2H	;CLEAR THE BIT
	ANDCAM TAC,DEVCMR(DDB)
	MOVEI TAC,ASSPRG
	TDNE TAC,DEVMOD(DDB)	;SKIP IF NO LONGER INITED
	PUSHJ P,DEVHNG		;FLUSH THE PROGRAM
	JRST DEVCK1
;⊗ IOSETC ITMCNT ITMCN1

;CALLED FROM INPUT AND OUTPUT UUOS.

;CALLING SEQUENCE
;	MOVE JBUF,<ADDRESS OF USER'S BUFFER HEADER>
;	MOVE TAC1,<ADDRESS OF BUFFER>
;	MOVE J,<BUFFER WC>
;	PUSHJ P,IOSETC
;	EXIT		ALWAYS RETURNS HERE

;SETS JBFPTR18-35:=C(TAC1 18-35)
;JBFCTR:=C(J)*[WORD LENGTH/BYTE SIZE]
;WHERE:	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=C(JBFPTR6-11)
;	[X]:= INTEGER PART OF X


↑IOSETC:MOVSI TAC,7777			;CLEAR BYTE POINTER IN BUFFER HEADER.
	XCTR XRW,[ANDM TAC,1(JBUF)]	;CLEAR ALL BUT BYTE SIZE, INDEX.
	XCTR XRW,[HRRM TAC1,1(JBUF)]	;SET ADDRESS PART.
	XCTR XRW,[AOS 1(JBUF)]		;ADVANCE ADDRESS TO WC WORD
	XCTR XLB,[LDB AC2,[POINT 6,1(JBUF),11]]		;USER'S BYTE SIZE.
	PUSHJ P,ITMCNT
	XCTR XW,[MOVEM J,2(JBUF)]	;STORE ITEM COUNT IN USER'S BUFFER HEADER
	POPJ P,				;EXIT TO USER.

;Subroutine to compute number of bytes in a buffer.

;CALLING SEQUENCE
;	MOVE TAC1,<ADDRESS OF BUFFER>
;	MOVE J,<BUFFER WC>
;	MOVE AC2,<USER'S BYTE SIZE>
;	PUSHJ P,ITMCNT
;	<ALWAYS RETURNS HERE>

;If LH(J) is nonzero it assumed to be the LH of a byte pointer, and the
;byte count is adjusted to account for unused bytes.  This is for special
;devices, like the IMP, which compute an exact byte count.

↑ITMCNT:XCTR XLB,[LDB TAC1,[POINT 17,(TAC1),17]]	;GET BUFFER SIZE
	HLLZ AC1,J			;Get LH of byte ptr
	HRRZ J,J			;Get word count
	CAIG J,-1(TAC1)			;Word count too big?
	 JRST ITMCN1			;No.
	MOVEI J,-1(TAC1)		;Yes, reduce it
	SETZ AC1,			;And forget about later adjustment
ITMCN1:	MOVEI TAC,=36			;COMPUTE ITEM COUNT FROM NUMBER OF DATA
	IDIV TAC,AC2			;  WORDS*NUMBER OF BYTES/WORD USING THIS
	IMUL J,TAC			;  BYTE SIZE.
	JUMPE AC1,CPOPJ			;Return if no byte ptr
	LDB TAC,[POINT 6,AC1,5]		;Number of unused bits in last word
	CAIL TAC,=36			;Virgin byte ptr?
	 POPJ P,			;Yes - don't believe it!
	IDIV TAC,AC2			;Compute leftovers
	SUBI J,(TAC)			;Subtract from byte count
	POPJ P,
;SETIOS SETMOD

;(SETSTS UUO)  SET DEVICE STATUS WORD FROM UUO, SETUP IOS


;SETSTS UUO

↑SETIOS:PUSHJ P,WAIT1
	MOVE TAC1,DEVCMR(DDB)
	TLNE TAC1,DEVSTS	;CALL DEVICE SERVICE AT STATUS CHANGE?
	PUSHJ P,DSETST(DSER)	;YES. DO IT.  (DSK,UDP,TTY)
	PUSHJ P,SETMOD
	JRST ILLMOD
	POPJ P,

;HERE FROM INIT (OPEN) UUO

↑SETMOD:LDB TAC1,[POINT 4,UUO,35] ;GET DEVICE DATA MODE
	MOVEI TAC,1		;AND CHECK FOR LEGALITY
	LSH TAC,(TAC1)
	TDNN TAC,DEVMOD(DDB)
	POPJ P,			;ILLEGAL MODE.
	TRZ UUO,IOACT		;LET USER SET ALL BITS EXCEPT IOACT
	HRRM UUO,@DEVSPT(DDB)
	JRST CPOPJ1
;PHOLD HOLD MSTOP ESTOP ESTP3B ESTP3C ESTOP3 ESTOP2 ESTOP4 ESTOP5

	SUBTTL RUNCSS 4 AUG 67

LOSYS

;RUN CONTROL IS A COLLECTION OF ROUTINES WHICH SET AND CLEAR BITS IN
;THE JOB STATUS WORD OF ALL (ANY) JOBS SO THAT THE SCHEDULER WILL START
;AND STOP THEM ACCORDINGLY.

;COMMON ERROR STOPPING ROUTINES
;CALLED AT ANY LEVEL (UUO, CLK, OR INTERRUPT)

;CALL:	MOVE J,JOB CAUSING ERROR OR BEING STOPPED
;	MOVE DDB,<ADRRESS OF THAT JOB'S TTY DDB>
;	MOVE DAT,<BYTE POINTER TO LAST CHAR IN TTY OUTPUT BUFFER>
;	PUSHJ P,PHOLD
;OR:	PUSHJ P,HOLD
;OR:	PUSHJ P,ESTOP

;	NEVER RETURN IF CALLED AT UUO LEVEL


;PHOLD - PRINT MESSAGE THEN
;HOLD - STOP JOB, SET ERROR BIT, AND ADD "↑C<CRLF><CRLF><PERIOD>

;CALL:	MOVEI TAC,<ADDR. OF MESSAGE>
;	PUSHJ P,PHOLD


↑PHOLD:	PUSHJ P,CONMES		;MOVE MESSAGE TO TTY OUTPUT BUFFER.
	SKIPA			;skip test for CTY since msg otherwise incomplete
↑HOLD:	CAIE DDB,SCNDDB		;don't print ↑C on CTY (probably phantom)
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC		;SET TTY TO MONITOR MODE. START TTY.  ESTOP

MSTOP:
↑ESTOP:	JUMPE J,CPOPJ			;STOP USER. FLAG ERROR STOP
	ERRSPW				;IF SPACEWAR, JUMP TO SPWERR
	MOVSI TAC,JACCT
	ANDCAM TAC,JBTSTS(J)		;NO LONGER AN ACCOUNTING PROGRAM
	MOVSI TAC,JLOG
	TDNE TAC,JBTSTS(J)		;IS THIS JOB REALLY LOGGED IN?
	JRST ESTOP4			;YES, PROCEED NORMALLY
	SKIPN JBTPAG(J)
	JRST ESTOP4			;NOT LOGGED IN AND NO CORE.
	CONSZ PI,77400			;NOT LOGGED IN.  ARE WE AT UUO LEVEL
	JRST ESTP3B			;NOT UUO LEVEL. USE MONITOR JOB TO KILL JOB
	SKIPE INTACT
	JRST ESTP3C			;AT UUO LEVEL AND USER INT LEVEL
	JRST JOBKL			;AT UUO LEVEL, KILL JOB FROM HERE.

ESTP3B:	CAMN J,JOB			;PI IN PROGRESS.  JLOG OFF
	SKIPN INTACT
	JRST ESTOP3			;NOT CURRENT JOB AND AT USER INT LEVEL
ESTP3C:	PUSHJ P,ESTOP3			;SET JLOG, SETUP MONJOB,
	SETOM ESTINT			;TELL CH7 WE'RE COMING FROM ESTOP
	JRST WSCHD2			;GET INTO CHANNEL 7

ESTOP3:	IORM TAC,JBTSTS(J)	; FINISH LOGGING IN JOB SO WE WON'T GET HERE AGAIN
	MOVE TAC,['-DIE!-']
	MOVEM TAC,JOBNAM(J)	;(EVEN IF WE FAIL TO KILL THIS, WE GET NEW PHANTOM)
	PUSHJ P,INTKIL		;NO MORE INTERRUPTS PLEASE.
	PUSHJ P,MAPSET		;SETUP MAP FOR THIS JOB
	MOVEI TAC1,JOBKL	;ADDRESS OF MONITOR JOB TO RUN AND KILL JOB.
	JRST MONJOB		;CAUSE MONITOR JOB TO BE STARTED. RESTORE MAP. POPJ


;GET HERE FROM JOBKL(KSTOP),  ALSO SET JOB TO NOT RUNNABLE FROM CORE 0 - CORE 1.
;AND FRON INJO2 IF THE JOB HAD NO CORE ASSIGNED ON THE DISK
↑ESTOP2:JUMPE J,CPOPJ		;IS THIS ERROR IN JOB 0?
	ERRSPW			;IF SPACEWAR JOB, JUMP TO SPWERR
	MOVSI TAC,JACCT		;ZERO OUT ACCT BIT
	ANDCAM TAC,JBTSTS(J)	;SO IF LOGIN BLOWS, WE CAN KILL IT!!
ESTOP4:	MOVSI TAC,JERR		;SET ERROR BIT
	IORB TAC,JBTSTS(J)	;SO JOB CAN NOT CONTINUE(CONT COM.)
	TRNN TAC,JLOCK		;IS THIS JOB LOCKED IN?
	JRST ESTOP5		;NO
	MOVSI TAC,UNLOKC	;MAKE A CLOCK REQUEST TO UNLOCK IT.
	HRR TAC,J
	SYSPIFF
	IDPB TAC,CLKQ		;USE DPYSER CLOCK QUEUE.
	SYSPIN
ESTOP5:	PUSHJ P,INTKILL		;CLEAR THE USER INTERRUPT SYSTEM
	CAMN J,JOB		;IF NOT CURRENT JOB
	CONSZ PI,77400		;OR AT INTERRUPT LEVEL
	JRST STOP1		;JUST GO TO STOP1 AS ALWAYS
	SKIPE INTACT
	JRST STOP1		;ALSO IF FROM USER INT
	PUSHJ P,SETSTP		;OTHERWISE PUT HIM IN STOPQ, ETC.
	MOVE TAC,UUOPC(J)
	TLNN TAC,USRMOD
	TDZA TAC,TAC		;GIVE HIM 0 IF PC WAS EXEC
	HRRI TAC,-1(TAC)	;ELSE BACK IT UP TO LOSING UUO
	MOVEM TAC,UUOPC(J)
	JRST USRX4A		;CATCH HIM ON HIS WAY OUT OF UUOCON.
;STOP1 SETSTP SETSTL SETST1 SETST2 STOP1A

;STOP A JOB FROM BEING SCHEDULED

;CALL:	MOVE J,<JOB NUMBER>
;	PUSHJ P,STOP1
;	EXIT	;RETURN HERE IMMEDIATELY, IF CALLED FROM HIGHER
;PRIORITY PI CHANNEL THAN CLK(LOWEST), OTHERWISE WHEN JOB IS RUNABLE
;CALLED FROM COMMAND DECODER WHEN <CONTROL>C TYPED IN BY USER

↑STOP1:	PUSHJ P,SETSTP		;SET IT TO STOPQ, ETC
	CAME J,JOB		;IS THIS JOB CURRENT USER
	JRST REQUE		;NO, SET REQUE JOB FLAG
	SKIPE INTACT
	SETOM ESTINT		;TELL CH7 WE'RE COMING FROM ESTOP
IFN FTSCNBUG,<
	JSR CH7CHK		;MAKE SURE SCANNER CHANNEL WAS LEFT ON
>;FTSCNBUG
	JRST WSCHD2		;YES, CALL WSCHED TO WAKE CH7

;THIS ROUTINE DOES ALL THE WORK OF STOPPING THE GUY WITHOUT ACTIVATING CH7
↑SETSTP:MOVSI TAC,RUN
	SYSPIFF
	TDNN TAC,JBTSTS(J)	;IS RUN BIT OFF IN JOB STATUS WORD?
	JRST STOP1A		;YES
	ANDCAM TAC,JBTSTS(J)	;NO, SO CLEAR IT
	SYSPIN
	MOVEI TAC,AVLNUM	;START AT HIGHEST QUEUE WITH A STATE
SETSTL:	CAME J,CALLTB(TAC)	;SEE IF THERE'S A JOB THAT'S JUST BEEN PUT IN
	SOJGE TAC,SETSTL	;RUNQ BUT HASN'T RUN YET, I.E., HAS AOSED XXXREQ
	CAIGE TAC,MINQ		;BUT IS NOT IN XXXQ AND HASN'T STARTED HIS CRITICAL
	JRST SETST1		;SECTION OF CODE YET.
	SETZM CALLTB(TAC)	;FOUND ONE, CLEAR TABLE ENTRY
	HRRZ TAC,TAC		;GET QUEUE CODE
	DPB TAC,[POINT JWSIZ,JBTSTS(J),JWPOS]	;PUT BACK, SINCE RUNQ CLEARED IT
	SETOM AVALTB(TAC)	;ASSUME SOMEONE ELSE WANTS IT
	JRST SETST2		;NOW GO SOS XXXREQ

SETST1:	MOVM TAC,JOBQUE(J)	;GET JOB WAIT QUEUE CODE(IF ANY)
	CAIG TAC,MAXQ		;DOES STATE HAVE Q ?
SETST2:	SOSL REQTAB(TAC)	;YES. REDUCE IT.
	JRST STOP1A		;NO QUEUE OR THAT QUEUE HAS WAITERS
	SETZM AVALTB(TAC)	;CLEAR AVAL FLAG IF NO ONE WAITING
STOP1A:	SYSPIN		;MAKE SURE PI ON
	MOVE TAC1,J
	PUSHJ P,CORSGT		;GET CORE SIZE OF THIS JOB (INTO TAC1)
	SKIPN TAC1		;SKIP IF THERE'S CORE ASSIGNED TO THIS JOB
	TROA TAC1,NULQ		;NO CORE ASSIGNED - REQUE JOB TO NULL QUEUE
	MOVEI TAC1,STOPQ	;CORE ASSIGNED - THIS JOB GOES TO STOPQ
	MOVNM TAC1,JOBQUE(J)	;STORE QUEUE CODE.
	POPJ P,			;↑C, CONTINUE WILL NOT UNLOCK A JOB!
;DLYCOM DLYCO2 NOCORQ NOCOR1 MONJOB

HISYS

;REQUE JOB WHICH HAS HAD A COMMAND TYPED
;WHICH NEEDS CORE AND THE CORE IMAGE IS ON THE DISK.
;OR IS IN CORE AND HAS ACTIVE DEVICES.
;CALLED FROM COMMAND DECODER
;CALL:	MOVE J,JOB NO.
;	PUSHJ P,DLYCOM


↑DLYCOM:MOVSI TAC,CMWB		;SET COMMAND WAIT BIT IN JBTSTS
	IORB TAC,JBTSTS(J)	;(NOTE: IF JNA IS OFF, CMWB KEEPS SLOT)
	TLNE TAC,JNA
	JRST DLYCO2
	PUSH P,TIMDAT		;GET <DATE>,,<TIME IN SECS>
	POP P,JBTBTM(J)		;SAVE JOB BEGINING TIME.
DLYCO2:	TLNN TAC,SWP		;DO WE NEED HIM IN??
	POPJ P,			;IN ALREADY
	MOVSI TAC,COMSNB	;ADD TO SWAPIN LIST
	JRST SETSIN


;NOCORQ - PUT A JOB IN NULQ, DELETE SWAPIN REQUESTS. RELEASE SWAP SPACE AND JBTMAP

↑NOCORQ:PUSHJ P,FLUSIN		;FLUSH FROM SWAP IN LIST
	CAME J,JOB		;IS THIS THE CURRENT JOB?
	JRST NOCOR1		;NO.
	PUSH P,J
	MOVEI J,0
	AOS AMC2		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP PAGER TO REFERENCE NULL JOB
	POP P,J
NOCOR1:	SKIPE AC1,JBTMAP(J)
	PUSHJ P,GIVMAP		;RETURN THE PAGE MAP TO FREE STORAGE
	SETZM JBTMAP(J)
	SETZM JBTSWP(J)		;NO CORE ASSIGNED ON THE DISK
	SETZM JB2SWP(J)
	MOVEI TAC,NULQ		;NO JOB NUMBER OR NO CORE QUEUE
	MOVNM TAC,JOBQUE(J)
	JRST REQUE


;SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL
;CALLED BY COMMANDS WHICH MAY OR MAY NOT NEED TO
;RUN MONITOR JOB DEPENDING ON WHETHER JOB HAS CORE(KJOB,IJOB)
;TTY WILL REMAIN IN MONITOR MODE
;JOB MUST HAVE CORE ASSIGNED
;CALL:	MOVE J,<JOB NUMBER>
;	MOVEI TAC1,<ADDR. OF MONITOR JOB TO BE RUN>
;BE SURE MAP FOR THIS JOB IS SETUP.
;	PUSHJ P,MONJOB
;WHEN SCHEDULED TO RUN, MONITOR JOB MUST SET UP ITS OWN ACS (MONSTR)


↑MONJOB:PUSHJ P,MSTART		;START WITH PC IN MONITOR
	JRST SETRUN		;SET TTY TO START JOB WHEN COMMAND RESPONSE
				;IS FINISHED AND KEEP TTY IN MONITOR MODE
;MONSTR

;SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL.
;J←JOB NO.
;PROG←PROTECT RELOCATE
;P←JBTPDL
;PID←PROCESSOR ID.
;USED BY KJOB,CORE 0,SAVE,GET,RUN,R AND FINISH COMMANDS
;CALL:	MOVEI TAC1,<MONITOR JOB STOP ADDRESS>
;	JSP TAC,MONSTR
;	RETURN WITH ACS P, PROG AND J SETUP AS ABOVE.


↑MONSTR:MOVEI PID,P1PID
	MOVE J,JOB		;GET CURRENT JOB NUMBER
	SKIPN P,JBTPDL(J)	;GET A PDL FOR THIS JOB.  MAKE SURE IT'S THERE.
	JRST LOSPDL
	PUSH P,TAC1		;SAVE STOP ADRRESS
	PUSH P,TAC		;RETURN TO MONITOR JOB
	JRST TTYSRC		;SET UP TTY DDB
;USTART USTRT1 MSTART MSTAR1 MSTAR2

;SET JOB STATE TO BE SCHEDULED TO RUN WITH SPECIFIED STARTING
;ADDRESS INCLUDING PC FLAGS CALLED ONLY WHEN JOB IN CORE AND AFTER
;JOB HAS BEEN SAFELY STOPPED IN ONE OF 2 STATES:
;1) PC IN USER MODE
;2) JOB IN A WAIT FOR SHARABLE DEVICE, OR IO WAIT
;CALL:	MOVE TAC1,<STARTING PC>
;	MOVE J,<JOB NUMBER>
;MAP FOR THIS JOB MUST BE SETUP.  JOB MUST BE IN CORE.
;	PUSHJ P,USTART (PC TO USER MODE), OR MSTART (PC TO MONITOR MODE)
;	<RETURN HERE IMMEDIATELY>


↑USTART:XCTR XR,[MOVE TAC,JOBPC]	;GET OLD PC
	TLNE TAC,USRMOD			;IS IT IN USER MODE TOO?
	JRST USTRT1			;YES, DUMP ACS AND PC FLAGS ARE ALREADY HIS
	MOVEI TAC,JOBDAC		;NO, MOVE USERS(UUO) ACS TO DUMP ACS
	XCTR XBLTRW,[BLT TAC,JOBD17]	;MOVE 20-37 INTO 0-17.
	MOVE TAC,UUOPC(J)		;UUO PC HAS LAST KNOWN PC
	TLNN TAC,USRMOD			;IF NOT USEER MODE
	MOVE TAC,UUOOPC(J)		;TRY THIS
	TLNN TAC,USRMOD			;IS IT?
	TLZ TAC,-1			;NO, CLEAR ALL PC FLAGS
	HRRI TAC,-1(TAC)		;SUBTRACT 1 FROM RIGHT HALF AND PRESERVE
					;PC FLAGS (RH=0 ON HALT 0 OR FIRST START)
USTRT1:	HLL TAC1,TAC			;PRESERVE USER APR FLAGS
	TLO TAC1,USRMOD			;MAKE SURE NEW PC IN USER MODE
NOKL10,<TLZ TAC1,37			;MAKE SURE NO INDIRECT BITS OR INDEX FIELD >
IFKL10,<TLZ TAC1,37!PCPUBL		;CLEAR INDIRECT/INDEX. SET PRIVATE >
	JRST MSTAR1

↑MSTART:
IFKL10,<TLO TAC1,PCU
>;IFKL10
	XCTR XR,[MOVE TAC,JOBPC]	;PICK UP USER'S PC
	TLNE TAC,USRMOD			;IN USER MODE?
	JRST MSTAR1			;YES, THIS IS CORRECT JOBOPC
	MOVE TAC,UUOPC(J)		;HERE IS LAST USER PC (MAYBE)
	HRRI TAC,-1(TAC)		;JUST LIKE USTART
MSTAR1:	TLNE TAC,USRMOD			;IF THIS ISN'T USER PC LEAVE HIS OLD ONE
	XCTR XW,[MOVEM TAC,JOBOPC]	;STORE IT FOR LATER USE
	XCTR XW,[MOVEM TAC1,JOBPC]	;STORE NEW PC
	CAMN J,JOB			;IS THIS CURRENT JOB?
	MOVEM TAC1,USRPC		;YES.  STORE IN SYSTEM CORE AS WELL.
	SKIPE INTACT
	CAME J,SJOB			;IS THIS JOB RUNNING USER INTERRUPTS?
	JRST MSTAR2			;NO
	MOVE TAC,INTSP			;UPDATE USRPC IN THE INTERRUPT STACK
	MOVEM TAC1,USRPC-USRJDA-20(TAC)
MSTAR2:	PUSHJ P,STXTM2			;UPDATE INTERACTION RUN TIME FOR THIS JOB
	MOVSI TAC,JERR+WTMASK
	ANDCAM TAC,JBTSTS(J)		;CLEAR ERROR AND WAIT STATUS BITS
	MOVNI TAC,RUNQ			;REQUE JOB TO RUN QUEUE
	MOVEM TAC,JOBQUE(J)
	SETOM STIME(J)			;THIS CORE IMAGE HAS BEEN MODIFIED
	JRST TTYSET			;SET TTY STATE TO INITIAL COND.

;TTYUSR OR TTYURC SHOULD BE CALLED TO INDICATE WHETHER TTY TO USER
;OR EXEC MODE AND THAT JOB IS TO RUN (RUN BIT =1) WHEN MONITOR COMMAND
;RESPONSE FINISHES.  SET MONITOR MODE.
;SETRUN SETR1 REQUE SETR2

;SETRUN - SET JOB STATUS RUN BIT (RUN).  CALLED BY SCANNER SERVICE WHEN
;TTY MONITOR COMMAND RESPONSE FINISHES.  THIS ACTION IS ENABLED BY CALLING
;TTYUSR, OR TTYURC IN SCNSER
;CALL:	MOVE J,<JOB NUMBER>
;	PUSHJ P,SETRUN

;REQUE - CAUSE JOB TO BE REQUEUED NEXT TIME THE SCHEDULER RUNS
;CALL:	MOVE J,<JOB NUMBER>
;	STORE QUEUE CODE IN JOBQUE(J)
;	PUSHJ P,REQUE


↑SETRUN:LDB TAC,[POINT JWSIZ,JBTSTS(J),JWPOS]  ;GET OLD WAIT QUEUE CODE
	JUMPE TAC,SETR1		;JUMP IF NONE
	AOSE REQTAB(TAC)	;DEVICE AVAILABLE?
	JRST SETR2		;NO - PUT US BACK INTO WAIT Q
	HRRZM J,CALLTB(TAC)	;YES - BUT WATCH OUT FOR CALL BEFORE RUNNING
SETR1:	MOVSI TAC,RUN		;SET RUN BIT IN JOB STATUS WORD
	IORM TAC,JBTSTS(J)
↑REQUE:	PUSH P,TAC
	MOVEI TAC,QJOB(J)
	SYSPIFF
	SKIPE (TAC)
	JRST .+3
	EXCH TAC,QJOB		;QJOB←ADDRESS QJOB(J).  TAC←OLD QJOB
	HRROM TAC,@QJOB		;QJOB(J)←-1,,OLD QJOB
	SYSPIN
	JRST TPOPJ

SETR2:	MOVNM TAC,JOBQUE(J)
	JRST SETR1
;SETSLP WAKE

;ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
;CALLED AFTER CLOCK QUEUE REQUEST PUT IN BY UUO ROUTINE

↑SETSLP:MOVSI TAC,CLKR		;FLAG THAT A CLOCK REQUEST HAS BEEN PUT IN.
	IORM TAC,JBTSTS(J)	;SO ONLY ONE PER JOB
	MOVEI AC1,IOWQ		;SLEEP STATE CODE
	JRST SETSTT		;SET STATUS AND RESCHEDULE

;HERE AT CLOCK LEVEL WHEN CLOCK REQUEST TIMES OUT FOR SLEEP. JOB NO. IN TAC

↑WAKE:	MOVNI TAC1,RUNQ		;RUN QUEUE CODE
	MOVE J,TAC		;JOB NO.
	MOVSI TAC,CLKR		;CLEAR CLOCK REQUEST BIT FOR THIS JOB
	ANDCAM TAC,JBTSTS(J)	;SO IT CAN PUT ANOTHER ONE IN
	MOVM TAC,JOBQUE(J)	;GET QUEUE CODE
	CAIE TAC,IOWQ		;IS JOB STILL SLEEPING?
	POPJ P,			;NO
	MOVEM TAC1,JOBQUE(J)	;YES, STORE RUN QUEUE CODE
	JRST REQUE		;(↑C, START CAN GET JOB OUT OF SLEEP)
;GETDCDT GETWT ELFWAIT MTWAIT DVWAIT DVWAT1 SETSTT

;GET DATA CONTROL AND ANOTHER SHARABLE DEVICE.
;JOB NEVER GETS ONE DEVICE AND WAITS FOR SECOND, SINCE TYPING
;CONTROL C WOULD NEVER FINISH WITH FIRST DEVICE
;CALL:	PUSHJ P,GETDCXX
;	AOSE XXREQ		;REQUEST COUNT FOR OTHER DEVICE
;	<RETURN WHEN BOTH AVAILABLE>

↑GETDCDT:↑GETDCMT:
	XCT @(P)		;INCREASE SHARABLE DEVICE REQ. COUNT
GETWT:	PUSHJ P,DVWAT1		;NOT AVAIL., GO WAIT FOR IT
	AOSN DCREQ		;IS DATA CONTROL AVAILABLE?
	JRST CPOPJ1		;YES, RETURN BOTH AVAILABLE
	MOVE AC1,@(P)		;DATA CONTROL NOT AVAILABLE
	SUBI AC1,REQTAB
	SOSL REQTAB(AC1)	;REDUCE REQ. COUNT FOR OTHER SHARABLE DEVICE.
	SETOM AVALTB(AC1)	;SET AVAILABLE IF OTHER JOBS WAITING
	JFCL DCREQ		;ARGUMENT FOR DCWAIT
	PUSHJ P,DCWAIT		;WAIT FOR DATA CONTROL FREE
	MOVE AC1,@(P)		;INCREMENT REQ. COUNT
	AOSN @AC1		;NOW IS SHARABLE DEVICE FREE?
	JRST CPOPJ1		;YES
	SOSL DCREQ		;NO, REDUCE DATA CONTROL REQUEST
	SETOM DCAVAL		;SET AVAIL.  SOME OTHER JOB WAITING FOR IT
	JRST GETWT		;TRY AGAIN

;WAIT FOR A SHARABLE DEVICE -  UUO LEVEL ONLY- FROM DEVICE SERVICE ROUTINES
;CALL:	AOSLE XXREQ		;ADD 1 TO SHARABLE DEVICE REQUEST COUNT
;				;IS DEVICE AVAILABLE?
;	PUSHJ P,XXWAIT		;NO, PUT JOB IN WAIT QUEUE
;	<RETURN WHEN DEVICE AVAILABLE>

;INITIALLY THE REQUEST COUNT IS -N, WHERE N IS THE
;NUMBER OF JOBS WHICH CAN USE THE SHARABLE DEVICE AT THE SAME TIME
;A REQUEST COUNT OF 0 MEANS THE MAXIMUM NO. OF JOBS ARE
;USING THE DEVICE, A POSITIVE NUMBER IS THE
;NUMBER OF JOBS WAITING IN THE SHARABLE DEVICE WAIT QUEUE

↑ELFWAIT:SKIPGE ELFREQ
	PUSHJ P,BUGTRP		;It must have been -2 before we AOS'd it!
↑MTWAIT:↑DTWAIT:↑DCWAIT:↑STWAIT:
↑DVWAIT:MOVE AC1,(P)		;GET ADDRESS OF CALLER
	SKIPA AC1,-2(AC1)	;GET AOSLE XXREQ INSTRUCTION
DVWAT1:	MOVE AC1,@-1(P)		;GET ADR. OF CALLER OF THIS ROUTINE
	SUBI AC1,REQTAB		;COMPUTE WAIT-STATE QUEUE CODE
SETSTT:	MOVE AC3,JOB		;CURRENT JOB NO.
	HRRZ AC1,AC1		;CLEAN UP JOB QUEUE CODE
	MOVNM AC1,JOBQUE(AC3)	;STORE IN JOB STATUS WORD

IFN FTMQBUG,<
IFN MTCNUM,<
	CAIE AC1,MTQ		;ARE WE ENTERING MTQ?
	JRST WSCHED		;NO.  JUST WAIT.
	CAMN AC3,MTQBUG		;IS BUG TRAP ENABLED?
	SETOM MTQBG1		;YES. SET FLAG DENOTING WRITE IS SIGNIFICANT
	PUSHJ P,WSCHED
	SKIPN MTCUSR		;IS MTC FREE?
	POPJ P,			;YES.
	SYSPIFF		;DON'T LET MTCUSR GET CLEARED AT INT LEVEL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /AT MTWAIT AFTER WAITING FOR MTC, BUT IT'S NOT FREE.
/
	DEBCHECK(POPACS)
	SETZM MTCUSR		;fix it??
	SYSPIN
	POPJ P,
>;IFN MTCNUM
>;IFN FTMQBUG


	JRST WSCHED		;GO SCHEDULE ANOTHER AND RETURN TO CALLER
				;WHEN SHARABLE DEVICE BECOMES AVAILABLE
				;SEE CLOCK AND CLKCSS WORD WAIT QUEUE CODE.
;STTIOD SETIOD SETID0 SETID1 NULTST NULTS1

;CALL FROM INTERRUPT LEVEL (INCLUDING CLK LEVEL) ONLY.
;SET JOB TO RUN AFTER IT HAS BEEN STOPPED BECAUSE IT HAD TO WAIT
;FOR IO TO COMPLETE FOR SOME DEVICE.  EACH SERVICE ROUTINE AT INTERRUPT
;LEVEL CHECKS WHEN IT FINISHES A TASK (BUFFERFUL) TO SEE IF THE
;JOB USING THE DEVICE HAS PREVIOUSLY CAUGHT UP WITH DEVICE AND HAS
;BEEN STOPPED
;
;CALL:	MOVE DDB,<ADR. OF DEVICE DATA BLOCK>
;	MOVE IOS,@DEVSPT(DDB)	;GET DEVICE IO STATUS WORD FROM DDB
;	TLZE IOS,IOW		;IS JOB IN AN IO WAIT FOR THIS DEVICE?
;	PUSHJ P,SETIOD		;YES, GO FLAG JOB TO START UP AGAIN
;	RETURN
;
;REQUEUES JOB TO A RUN QUEUE.  THE SCHEDULER THEN SEES THAT THIS JOB
;HAS ITS IO WAIT SATISFIED AND IS WAITING TO BE RUN AGAIN


↑STTIOD:PUSH P,[-TQ]		;HIGH-PRIORITY RUN QUEUE.
	CAIA
↑SETIOD:PUSH P,[-RUNQ]		;REQUE TO RUNQ
	EXCH J,(P)		;SAVE J
	PUSH P,J		;SAVE QUEUE NUMBER
	LDB J,PJOBN		;GET JOB NUMBER FROM DDB
	SETZM JBTIOW(J)		;CLEAR DDB WHOLINE THINKS WE'RE WAITING FOR
	SKIPL JBTSTS(J)		;IS JOB STILL RUNNABLE?
	JRST SETID0		;NO. AVOID CHANGING QUEUE AND CALLING REQUE
	POP P,JOBQUE(J)
	PUSHJ P,REQUE		;ARRANGE TO REQUEUE THIS JOB.
	JRST SETID1

SETID0:	POP P,J			;FLUSH QUEUE CODE FROM STACK
SETID1:	POP P,J			;RESTORE ORIGINAL CONTENTS OF J
NULTST:	SKIPE JOB		;IS NULL JOB RUNNING?
	POPJ P,			;NO.  LET CURRENT JOB FINISH ITS QUANTUM
	SYSPIFF		;FORCE NULL JOB OFF.
	JRST STOP2
;WSCHED WSCHDA WSCHD1 WSCHD2 STOP2

;WSCHED - CAUSE CLK ROUTINE TO RESCHEDULE   STOP2

;CALLED AT ANY LEVEL
;CALL:	PUSHJ P,WSCHED
;	RETURN IMMEDIATELY EXCEPT IF AT UUO LEVEL
;	IF AT UUO LEVEL, RETURN WHEN JOB IS RUNABLE AGAIN


↑WSCHED:MTRON (MTRWSC)
WSCHD1:
IFN FTSCNBUG <			;GUARANTEED ONLY HERE FOR P1
	JSR CH7CHK		;MAKE SURE SCANNER HASN'T BEEN LEFT OFF BY UUO
>;FTSCNBUG
	MTROFF (MTRWSC)
	ERRSPW			;IF THIS IS A SPACEWAR JOB, JUMP TO SPWERR
WSCHD2:	AOS NWSCHEDS		;COUNT SCHEDULES (HERE FROM STOP1)
IFKL10,<
IFE FTMTRACT,<
	PUSH P,J
	MOVE J,MTRJOB
	CAMN J,JOB
	AOS MTRNSC		;COUNT ANOTHER SCHEDULE FOR THE METERED JOB
	POP P,J
>;IFE FTMTRACT
>;IFKL10
	SYSPIFF		;AVOID PREMATURE CLK INT
	SETOM SCHEDF		;THIS IS A SCHEDULING INTERRUPT
↑STOP2:	HLLOS CLKFLG		;SET FLAG TO INDICATE CLK INTERRUPT
				;EVEN THOUGH CLK INTERRUPT IS NOT A TIME INTERRUPT
	SETZM PIOFFS
	CONO PI,PION+1B24!1⊗(7-CLKCHN)
				;TURN PI BACK ON AND REQUEST INTERRUPT TO
				;CLK PI CHANNEL(LOWEST PRIORITY CHANNEL)
	CONO PI,0		;RANDOM INSTRUCTION WHICH NEEDS THE ECL EBUS
				;AND WILL THEREFORE HANG UNTIL THE INTERRUPT
				;HAPPENS
	POPJ P,			;INTERRUPT IMMEDIATELY IF AT UUO LEVEL
;WAIT1

;ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
;CALLING SEQUENCE
;	PUSHJ P,WAIT1
;	<RETURN HERE>
;
;n.b. this routine waits for INACTIVE, as compared to WSYNC which waits for IOW=0
 
;IF THE DEVICE IS INACTIVE (IOACT=0), RETURNS TO EXIT. OTHERWISE, SETS
;IOW:=1 AND ENTERS WAIT UNLESS IOACT BECOMES ZERO BEFORE THE
;JUMP IS MADE, IN WHICH CASE IT SETS IOW:=0 AND RETURNS TO EXIT.
;ON LEAVING THE WAIT STATE, RETURNS TO EXIT.

;CALLS WSYNC AND LOOPS TO PREVENT CALL-CONTINUE LOSSAGE.

↑WAIT1:	MOVE IOS,@DEVSPT(DDB)
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,DVTTY		;TTY MAY ALWAYS PROCEED FROM HERE - RPH
	POPJ P,
	MOVSI AC1,DEVIBF
	TDNE AC1,DEVCMR(DDB)	;SKIP UNLESS INTERNALLY BUFFERED
	SKIPA AC1,[DEVSBB,,0]
	MOVEI AC1,IOACT
	TDNN IOS,AC1		;IS DEVICE ACTIVE?
	POPJ P,			;NO.
	PUSHJ P,WSYNC		;WAIT
	JRST WAIT1
;WSYNC WSYN.1 WSYN.2 WSYN.3 WSYN.4 WSYN.5 WSYN.6

;WAIT FOR SETIOD TO BE CALLED BY INTERRUPT SERVICE ROUTINE
;IE  UNTIL CURRENT BUFFER ACTIVITY IS COMPLETED
;CALLED ONLY FROM UUO LEVEL
;CALL:	MOVE DDB,<ADR. OF DEVICE DATA BLOCK>
;	PUSHJ P,WSYNC
;	<RETURN HERE>

;RETURN IMMEDIATELY IF DEVICE IS INACTIVE, ELSE RETURN WHEN DEVICE FINISHES
;ITS NEXT BUFFER.  THIS ROUTINE PREVENTS THE STATE IOACT=0 AND IOW=1 FROM
;OCCURING. SETS IOW, WAITS UNTIL EXIT WHEN IOACT (OR DEVSBB) IS CLEARED.
;MUST NOT CLOBBER TAC1.  DOES CLOBBER AC1,AC2,AC3 AND RETURNS NEW IOS.


↑WSYNC:	MOVEI AC1,DIOWQ		;DEVICE IO WAIT QUEUE (QUEUE IF IOACT SET)
	MOVE AC3,@DEVSPT(DDB)	;SEE IF JOB IS LOCKED IN CORE
	MOVE AC2,DEVMOD(DDB)	;FOR DEVICES OTHER THAN THE TTY MEANS IOACT IS ON
	TLNN AC2,DVTTY
	TRNN AC3,IOACT		;LOCKED IN?
	MOVEI AC1,IOWQ		;NO, STRAIGHT IO WAIT QUEUE CODE
	MOVSI AC2,DEVIBF	;IS THIS DEVICE INTERNALLY BUFFERED?
	TDNE AC2,DEVCMR(DDB)	;(LPT, PTP, CAR, DSK, PTR, TV, DLN)
	SKIPA AC2,[DEVSBB,,0]	;YES, THEN TEST DEVSBB,
	MOVEI AC2,IOACT		;OR IOACT IF NOT SO BUFFERED.
	HRRZ AC3,DEVCMR(DDB)	;FIRST, DOES HE HAVE CONTROL CELLS?
	PUSH P,AC3		;PUSH ADDRESS OF CONTROL CELL ON STACK.
	MOVE AC3,JOB		;CURRENT JOB NO.
	SKIPN (P)		;ANY CONTROL CELLS?
	JRST WSYN.1		;NO.
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
WSYN.1:	MOVSI IOS,IOW		;SETUP DEVICE IO WAIT BIT
	SYSPIFF		;MAKE SURE NO ONE'S PEEKING.
	TDNN AC2,@DEVSPT(DDB)
	JRST WSYN.4		;NOTHING ELSE TO WAIT FOR. TURN ON PI,RELEASE SYNC
	IORM IOS,@DEVSPT(DDB)
	MOVNM AC1,JOBQUE(AC3)
	SYSPIN
	HRRZM DDB,JBTIOW(AC3)	;STORE DDB WE ARE WAITING FOR, FOR WHOLINE
	SKIPN (P)		;ANY CONTROL CELLS?
	JRST WSYN.2		;NO.
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
↑WSYN.2:PUSHJ P,WSCHED
	SKIPN (P)		;ANY CONTROL CELLS?
	JRST WSYN.3		;NO
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
WSYN.3:	TDNN IOS,@DEVSPT(DDB)	;MAKE SURE IOW IS CLEAR NOW.  REG 1/29/75
	JRST WSYN.5		;YES. SOMEONE CALLED SETIOD (OR STTIOD)
	ANDCAM IOS,@DEVSPT(DDB)	;TURN OFF IOW IN CASE OF TTY OR SOME OTHER MISTAKE
	MOVE IOS,DEVMOD(DDB)	;TTY IS A SPECIAL CASE.
	TLNE IOS,DVTTY	
	JRST WSYN.5		;TTY, JUST SET UP IOS AND LEAVE
	JRST WSYN.1		;LOOP UNTIL SOMEONE TURNS IOW OFF OR IOACT GOES OFF.

WSYN.4:	SYSPIN
WSYN.5:	MOVE IOS,@DEVSPT(DDB)
	SKIPN (P)
	JRST WSYN.6
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
WSYN.6:	SUB P,[1,,1]
	POPJ P,
SUBTTL BATCON - INITIATE PHANTOM PROCESSES ;⊗ BATCLK BATLOP BAT0 BAT1 BAT2 BAT2A BAT3 BAT3C BAT3B

;THERE ARE 4 EQUAL-LENGTH TABLES IN CACDAT WHICH CONTAIN THE NAMES
;OF ALL THE PHANTOM JOBS, THE CORRESPONDING PPN AND PRIVILEGES, AND
;THE DATE AND TIME WHEN NEXT TO START THE PROCESS.  ALL THE JOBS ARE
;STARTED WHEN THE SYSTEM STARTS UP, AND CHECKED FOR RESTART EVERY MINUTE.

BATCLK:	MOVEI TAC,=60*JIFSEC	;RESET TO LOOK AGAIN IN 1 MINUTE
	MOVEM TAC,BATYET	;SET RETRY TIME
	SKIPE MAINTM		;MAINTMODE?
	SKIPA TAC,[-NFIRES,,0]	;Only startup FIREUP types DURING MAINTENANCE.
	MOVSI TAC,-BATLEN	;LENGTH OF BATMAN
BATLOP:	MOVEM TAC,BATPNT	;SAVE IT
	SKIPE AC1,BATMAN(TAC)	;JOBNAM
	SKIPN AC3,ROBIN(TAC)	;PPN
	JRST BAT3		;AVOID EMBARASSING CONFUSION!
	SKIPGE J,ALFRED(TAC)	;GET THE TIME AND DATE OF NEXT STARTUP
	JRST BAT3		;NEGATIVE MEANS DON'T START IT.
	JUMPE J,BAT0		;IF ZERO THEN START IT.
	MOVE TAC,TIME		;GET JIFFIE TIME
	IDIVI TAC,=60*JIFSEC	;MAKE IT MINUTES
	HRL TAC,THSDAT		;GET THE DATE
	CAMGE TAC,J		;COMPARE WITH HIS REQUEST
	JRST BAT3		;NOT YET.
	HRRZ TAC,BATPNT		;GET CURRENT POINTER BACK
	SETZM ALFRED(TAC)	;SO WE DON'T GET HERE AGAIN
	;Network servers can have multiple instances (even before
	;they change their name), so we make the following test.
BAT0:	HRRZ TAC,BATPNT		;Right half only
	CAIGE TAC,NFIRES	;Skip if a regular phantom
	JRST BAT2A		;Start fireup phantoms unconditionally
	MOVEI J,JOBN-1		;SCAN JOBS LOOKING FOR ONE LIKE THIS.
	MOVSI TAC,JNA
BAT1:	TDNN TAC,JBTSTS(J)	;IS THERE A JOB HERE?
	JRST BAT2		;NO.
	CAMN AC1,JOBNAM(J)	;WITH A NAME LIKE MINE?
	CAME AC3,PRJPRG(J)	;AND A PPN LIKE MINE TOO?
	JRST BAT2		;NO MATCH.
REPEAT 0,<; SOMEBODY SOMEDAY WILL WRITE THIS CODE
	SKIPL AC2,JBTSTS(J)	;IS THIS JOB RUNNABLE?
	TLNE AC2,JLOG		;NOT RUNNABLE. IS IT LOGGED IN?
	JRST BAT3		;RUNNABLE OR LOGGED IN.
;HERE WE HAVE A DEAD PHANTOM.  KILL IT AND START A NEW ONE.
;TO BE CONTINUED....
>;REPEAT 0
	JRST BAT3		;TO BE CONTINUED. IN THE MEANTIME, DO NOTHING.

BAT2:	SOJG J,BAT1		;LOOP LOOKING THRU ALL JOBS.
BAT2A:	PUSHJ P,INIJOB		;ATTEMPT TO MAKE A NEW JOB
	 JRST BAT3C		;NONE AVAILABLE. (NO JOB SLOTS)
	 JRST BAT3B		;AVAILABLE LATER. (NEEDS FREE STORAGE)
	PUSHJ P,GETBAT		;START A PHANTOM JOB.
BAT3:	MOVE TAC,BATPNT		;GET BACK BAT POINTER
	AOBJN TAC,BATLOP
	POPJ P,			;DONE

BAT3C:	SKIPA TAC,[=15*JIFSEC]	;RETRY IN 15 SECONDS (NEED JOB SLOT)
BAT3B:	MOVEI TAC,JIFSEC	;RETRY ONE SECOND FROM NOW
	MOVEM TAC,BATYET
	POPJ P,
;⊗ GETBT0 GETBAT GETBA7 GETBA6 GETBA5 GETBA4 GETBTX GETBT1 GETBT2 GETBT3 BATSW DELBAT DELB1 BATRS DELBTT BATTT BATSWP FIREUP FIRSER FIREU1 FIREU2

IFG XGPNUM,<
↑GETBT0:MOVE J,TAC		;HERE FROM AN XGPSER CLOCK REQUEST
	JRST GETBTX		;JNA FOR THIS JOB IS TURNED ON ALREADY.
>;IFG XGPNUM

GETBAT:
;;BATCLK does all the worrying about MAINTMODE.
;;	SKIPE MAINTMODE
;;	POPJ P,
	HRRZ TAC,BATPNT		;GET THE POINTER TO BAT TABLES
	CAILE TAC,NFIRES-1	;IS THIS ONE OF FIREUP'S CELLS?
	JRST GETBA4		;NO
	SETZM BATMAN(TAC)	;YES, DON'T START ANOTHER ONE
IFN FTIP,<
	PUSH P,DDB
	SKIPN DDB,BATCAR(TAC)	;skip if any DDB is awaiting this job
	JRST GETBA5
;Here we have a DDB that someone wants to be given to this phantom.
;But for safety, we first must make sure this DDB hasn't gone away,
;so we'll search the DDB list for it.
	PUSH P,AC3
	MOVEI AC3,DEVLST-DEVSER	;search entire device chain (for generality)
GETBA7:	HLRZ AC3,DEVSER(AC3)	;get next DDB
	JUMPE AC3,GETBA6	;jump if end of list, didn't find our DDB there
	CAIE AC3,(DDB)		;is this the DDB we're looking for?
	JRST GETBA7		;nope, keep looking
	LDB AC3,PJOBN		;yes!  make sure this DDB isn't already owned
	JUMPN AC3,GETBA6	;jump if already owned (D.R.D.)
	DPB J,PJOBN		;assign this DDB to new phantom job
GETBA6:	SETZM BATCAR(TAC)	;now forget about this DDB
	POP P,AC3		;restore saved ACs
GETBA5:	POP P,DDB
>;IFN FTIP
GETBA4:	MOVE TAC,GORDON(TAC)	;GET THIS PHANTOM'S PRIVILEGE BITS
	MOVEM TAC,JBTPRV(J)	;SAVE
	MOVEM TAC,JB2PRV(J)	;ALSO IN PASSIVE BITS
	MOVEM AC3,PRJPRG(J)
	MOVEM AC3,JOBPPN(J)
	MOVEM AC1,JOBNAM(J)	;SETUP THIS GUY'S NAME
IFN FTSTAT,< PUSHJ P,NAMSTT >
	MOVSI TAC,JNA		;MAKE SURE NO ONE GETS THIS NUMBER
	IORM TAC,JBTSTS(J)
GETBTX:	MOVSI TAC,'DSK'		;DEVICE DISK. 
	MOVEM TAC,JOBDEV(J)
	MOVSI TAC,'DMP'		;AND DUMP
	MOVEM TAC,JOBLOG(J)
	SETZM JOBCRD(J)		;NO CORE SIZE OR STARTING INCREMENT
	SETZM JBTUFD(J)
	SETZM DSKPPN(J)		;INITIALIZE DISK ALIAS PPN
	SETZM JBTKCJ(J)
	SETZM JBTMSC(J)		;NO RANDOM BITS
	SETZM JBTDDB(J)		;NO DDB FOR WHOLINE
	MOVSI TAC,JLOG
	ANDCAM TAC,JBTSTS(J)
	HLLZS SAVSAI(J)		;JUST IN CASE
GETBT1:	SETO TAC1,		;ASK FOR A DETACHED TTY DDB
	PUSHJ P,DDBSRC		;FIND ONE.
	JRST DELBTT		;NO DDB, DELAY
GETBT2:	MOVEI TAC,JOBDA		;AMOUNT OF NEW CORE NEEDED FOR JOB DATA AREA.
	PUSHJ P,CORE0		;GET IT SOME CORE
	JRST DELBAT		;NOT AVAILABLE, WAIT FOR IT
GETBT3:	MOVSI TAC,SWP
	SKIPN XJOB(J)		;IF STILL GETTING CORE, DELAY A WHILE
	TDNE TAC,JBTSTS(J)	;DID JOB GO AWAY DURING ALL THIS?
	JRST BATSWP		;YES, GET IT BACK IN
↑BATSW:				;ENTER HERE FROM SWAPPER WHEN JOB COMES IN
	PUSHJ P,SETLOG		;SET-UP LOGIN STUFF (UUOCON)
	PUSHJ P,MAPSET		;SETUP MAP FOR THIS USER.
	MOVE TAC,JOBNAM(J)
	XCTR XW,[MOVEM TAC,FILNAM]
	MOVE TAC,JOBDEV(J)	;DEVICE
	XCTR XW,[MOVEM TAC,DEVWRD]
	HLLZ TAC,JOBLOG(J)	;EXTENSION
	XCTR XW,[MOVEM TAC,FILEXT]
	SKIPN TAC,JOBCRD(J)	;CORE SIZE
	JRST .+3		;DON'T FUTZ WITH ZERO
	LSH TAC,12		;TO WORDS
	SUBI TAC,1		;TO PROT
	XCTR XW,[MOVEM TAC,JOBCOR]
	HRRZ TAC,JOBLOG(J)
	XCTR XW,[MOVEM TAC,INCWRD]	;SAVE IN PLACE WE CAN FIND IT LATER
	MOVEI TAC1,PRUNJB		;THIS GUY KNOWS ABOUT INCREMENTAL START-UP
	JRST MONJOB			;RETURN FROM MONJOB VIA MAPSET

DELBAT:	LSH J,=12		;HERE WE WAIT FOR CORE TO BECOME AVAILABLE
	ADD J,[$BATRS,,1]	;Get to BATRS in one tick
DELB1:	CLKENQ(J)		;Plant clk req
	POPJ P,

↑BATRS:	MOVE J,TAC
	JRST GETBT2

DELBTT:	LSH J,=12
	ADD J,[$BATTT,,1]	;Get to BATTT in one tick
	JRST DELB1

↑BATTT:	MOVE J,TAC
	JRST GETBT1

BATSWP:	MOVSI TAC,BATSNB	; SET THIS FLAG AND PUT IN SWAPIN LIST
	JRST SETSIN		; WILL CALL BATSW WHEN SWAPPED IN

;; ROUTINE TO START RANDOM PROGRAM AS A PHANTOM AT NEXT TICK
;;	MOVEI TAC,[NAME↔PPN↔PRIVS↔DDB to give job]
;;	PUSHJ P,FIREUP
;;	 <ERROR RETURN>
;;	<SUCCESS RETURN>
;; THE ERROR RETURN MEANS SOMEBODY HAS ALREADY FILLED UP OUR BUFFER, SO
;; YOU HAVE TO COME BACK NEXT TICK (MAKE A CLOCK REQUEST).  THE SUCCESS
;; RETURN MEANS THAT YOUR REQUEST HAS BEEN ENTERED.  NO GUARANTEE THAT
;; IT'LL ACTUALLY BE RUN, EG MAYBE NO JOB SLOTS, MAYBE NO DMP FILE, ETC.

↑FIREUP:			;ROUTINE TO START A NONSTANDARD PHANTOM
	SKIPE MAINTM		;NO PHANTOMS IN MAINTMODE
	 JRST CPOPJ1		; SO PRETEND WE DID IT
;Network servers enter here to get started up even if the system is down.
;Servers get started in maint mode if the SERVOK flag is on (IMPSER).
↑FIRSER:MOVSI TAC1,-NFIRES	;INDEX INTO BATMAN AND FRIENDS
FIREU1:
IFE FTIP,<
	SKIPE TEM,BATMAN(TAC1)	;IS THIS ONE TAKEN?
	 CAMN TEM,(TAC)
	  JRST FIREU2
>;IFE FTIP
IFN FTIP,<
	SKIPN TEM,BATMAN(TAC1)	;IS THIS ONE TAKEN?
	  JRST FIREU2		;no, use it
>;IFN FTIP
	AOBJN TAC1,FIREU1	;YES, TRY SECOND STRING
	POPJ P,			;SORRY, HAVE TO COME BACK AGAIN

FIREU2:
IFN FTIP,<
	MOVE TEM,3(TAC)		;Get DDB to give to phantom
	MOVEM TEM,BATCAR(TAC1)
>;IFN FTIP
	MOVE TEM,2(TAC)		;GET PRIVILEGES
	MOVEM TEM,GORDON(TAC1)
	MOVE TEM,1(TAC)		;GET PPN
	MOVEM TEM,ROBIN(TAC1)
	MOVE TEM,(TAC)		;GET NAME
	MOVEM TEM,BATMAN(TAC1)
	SETZM ALFRED(TAC1)	;USE SOME TODAY
	SETZM BATYET		; WAKE UP BATCLK
	JRST CPOPJ1
;STAPUT STAPTT STACLK STAPOK STAPOJ STAPDO GLUSTT NAMSTT NAMCLK NAMOK SEGSTT

;STATISTICS SERVICE
IFN FTSTAT,<

↑STAPUT:IORI TAC,(J)
↑STAPTT:CONSO PI,77000		;ARE WE ON CHAN HIGHER THAN 7?
	JRST STAPOK		;NO, OK
	HRLI TAC,STACLK		;YES, SEND THIS DATA UP TO CH7
	SYSPIFF
	IDPB TAC,CLKQ
	SYSPIN
	POPJ P,

STACLK:	HRRZ TAC,DAT
STAPOK:	PUSH P,TAC
	MOVE TAC,TIME
	SKIPN TIMEFF
	CAMN TAC,STATIM		;DID THE TIME CHANGE SINCE LAST STAT. BYTE?
	JRST STAPOJ		;NO. (OR YES, BUT CH7 HASN'T SEEN IT YET)
	MOVEM TAC,STATIM	;YES.  STORE TIME OF LAST STAT. BYTE.
	HLRZ TAC,TAC		;TRANSMIT TIME IN 2 BYTES.
	ANDI TAC,7777
	IORI TAC,TIMSTA
	PUSHJ P,STAPDO
	HRRZ TAC,STATIM
	PUSHJ P,STAPDO
STAPOJ:	POP P,TAC
STAPDO:	IDPB TAC,STATPTR
	MOVE TAC,STATPTR
	CAME TAC,[POINT 18,STATS+STATLEN-1,35]
	POPJ P,
	MOVE TAC,[POINT 18,STATS]
	MOVEM TAC,STATPTR
	AOS STATNUM
	POPJ P,

↑GLUSTT:PUSH P,TAC
	MOVE TAC,JBTGLU(J)
	ANDI TAC,77
	LSH TAC,6
	TRO TAC,GLUSTA
	PUSHJ P,STAPUT
	POP P,TAC
	POPJ P,

↑NAMSTT:CONSO PI,77000		;ARE WE ON CHAN HIGHER THAN 7?
	JRST NAMOK		;NO, OK
	PUSH P,J
	HRLI J,NAMCLK		;REMEMBER THE JOB NUMBER AND COME BACK LATER
	SYSPIFF
	IDPB J,CLKQ
	SYSPIN
	POP P,J
	POPJ P,

NAMCLK:	HRRZ J,DAT
NAMOK:	PUSH P,TAC
	MOVEI TAC,NAMSTA(J)
	PUSHJ P,STAPOK		;FIRST BYTE SAYS NAME FOLLOWS
	HLRZ TAC,JOBNAM(J)
	PUSHJ P,STAPOK
	HRRZ TAC,JOBNAM(J)
	PUSHJ P,STAPOK
	JRST TPOPJ

↑SEGSTT:PUSH P,TAC
	LDB TAC,PSEGN
	LSH TAC,6
	TRO TAC,SEGSTA
	PUSHJ P,STAPUT
	JRST TPOPJ

>;IFN FTSTAT
;FBI FBINEW FBIXIT STPRV2

IFN FTFBI,<

↑FBI:	CONSZ PI,77400		;THIS IS ONLY ALLOWED AT UUO LEVEL
	POPJ P,
	PUSHACS
	MOVE TAC,NPROGR
	CAIL TAC,LPROGR
	JRST FBIXIT		;NO MORE ROOM IN TABLE
	MOVE AC2,-20(P)		;GET RETURN ADDRESS
	HRRZ AC2,(AC2)		;GET FEATURE NUMBER
	MOVE J,JOB
	MOVE AC1,JOBNAM(J)
	JUMPE TAC,FBINEW
	CAMN AC1,PROGR-1(TAC)	;IS THIS JOBNAME ALREADY IN THE TABLE?
	CAME AC2,PROGF-1(TAC)	;WITH THIS FEATURE NUMBER?
	SOJG TAC,.-2		;NO
	JUMPG TAC,FBIXIT	;JUMP IF ALREADY IN TABLE
FBINEW:	AOS TAC,NPROGR
	MOVEM AC1,PROGR-1(TAC)	;MAKE NEW ENTRY
	MOVEM AC2,PROGF-1(TAC)	;REMEMBER FEATURE NUMBER
	MOVE TEM,JOBPPN(J)	;GET PPN OF DUMP FILE
	MOVEM TEM,PROGP-1(TAC)	;SAVE IN TABLE
	PUSH P,AC2
	PUSH P,PRJPRG(J)	;SAVE PPN OF USER
	PUSH P,JOBPPN(J)	;SAVE PPN OF DUMP FILE FOR TYPEOUT
	PUSH P,AC1
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT/FEATUR/
	PUSHJ P,DISERR
	[ASCIZ/Feature #/]
	DISARG LOC,<-4(P)>	;RIGHT HALF OF INSTRUCTION FOLLOWING PUSHJ
	[ASCIZ/ used by /]
	DISARG SIX,<-3(P)>
	[ASCIZ/ in program named /]
	DISARG SIX,<-1(P)>
	[ASCIZ/[/]
	DISARG SIX,<-2(P)>
	[ASCIZ/]
/]
	-1
	SUB P,[4,,4]
FBIXIT:	POPACS
	POPJ P,

>;FTFBI

↑STPRV2:PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISERR
	[ASCIZ/ with: /]
	DISARG OCH,<TAC1-20(P)>
	[ASCIZ/  asking for: /]
	DISARG OCH,<TAC-20(P)>
	-1
	PUSHJ P,DISCRL
	POPACS
IFN FTFBI,<
	PUSHJ P,FBI
	 CAI 0			;Feature number 0
>;FTFBI
	SETZM JB2PRV(J)
	SETZM TAC,JBTPRV(J)	;ASK AND YE SHALL RECEIVE
	JRST STOTAC
;POPTRP FATTRP BUGTRP FATTR1 FATTR2

;Enter here for bugtrap that wants to pop up a level on return from DDT.
↑POPTRP:SYSPIFF
	SETOM POPUPF		;Pop up a level after DDT
	JRST FATTR1

↑FATTRP:SYSPIFF
	SETZM POPUPF		;Don't want to pop up a level
	SETOM FATALE		;Flag fatal error
	JRST FATTR2
	
↑BUGTRP:SYSPIFF
	SETZM POPUPF		;Don't want to pop up a level
FATTR1:	SETZM FATALE		;Flag non-fatal error
FATTR2:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	MOVEI AC1,[ASCIZ/FATAL /]
	SKIPE FATALE		;Skip if non-fatal bug trap hit
	PUSHJ P,DISSTR		;Fatal, say so
	CONI PI,UUO		;GET STATE OF PI SYSTEM
	PUSHJ P,DISERR
	 [ASCIZ/Bug Trap hit.  PI CONI = /]
	 DISARG OCH,UUO          ;UUO ISN'T CLOBBERED BY DISERR
	 [ASCIZ/  Callers = /]
	 DISARG LOC,<-21(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-22(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-23(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-24(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-25(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-26(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-27(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-30(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-31(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-32(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-33(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-34(P)>
	 [ASCIZ /
ACs:/]
FOR I←0,17<
	 [ASCIZ\
I/	\]
	 DISARG OCH,<I-20(P)>
>
	 -1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,XDDTCA		;Call DDT, check for fatality, skip if non-fatal
	 JRST AUTOLO		;Fatal error, don't return to caller
	SKIPE POPUPF
	SUB P,[1,,1]		;Pop up a level on return.
	SYSPIN
	POPJ P,
;LOGIT LOGIT0 LOGIT1 LOGIT4 LOGIT2 LOGIT5 LOGIT6 LOGKIL LOGLUZ OUTPPN

;ROUTINE TO LOG USE OF A MONITOR COMMAND THAT AFFECTS ANOTHER PERSON'S JOB.
;ENTER HERE AT UUO LEVEL (KILL, FINISH, RESET CMDS)
;OR AT CLOCK LEVEL (ATTACH CMD).
;PRESERVES ALL ACS.
;
;IF JOB IS DOING COMMAND TO ITSELF, THIS ROUTINE DOES NOTHING.
;OTHERWISE, AFFECTED JOB'S TTY INPUT AND OUTPUT BUFFERS ARE FIRST CLEARED,
;AND DISPLAY IS RESET TO NORMAL STATE.
;IF PPNS OF BOTH JOBS ARE SAME, ONLY TYPES MESSAGE ON AFFECTED JOB.
;OTHERWISE, ALSO TYPES MESSAGE ON CTY UNLESS FRCFLG IS SET (FROM ATTJOB UUO).
;
;CALL BY:
;	MOVEI J,<AFFECTED JOB>
;	MOVEI TAC1,<INITIATING JOB (ZERO IF NOT LOGGED IN)>
;	MOVEI TAC,[ASCIZ/past tense of verb /]	;TYPE OF ACTION DONE
;	MOVEI DDB,<TTY DDB OF AFFECTED JOB>
;	PUSHJ P,LOGIT
;
;IF INITIATING JOB NUMBER IS ZERO, MUST BE HERE ONLY AT CLOCK LEVEL FROM COMMAND
;DECODER AS LINSAV IS USED AS TTY NUMBER OF INITIATOR.

LOGIT:	CAMN J,TAC1		;DOING SOMETHING TO OWN JOB?
	POPJ P,			;YUP, NO LOG
	PUSHACS
LOGIT0:	JUMPE TAC1,LOGIT1	;JUMP IF INITIATOR IS NOT LOGGED IN
	JUMPL TAC1,LOGLUZ	;ILLEGAL JOB NUMBER
	CAIL TAC1,JOBN
	JRST LOGLUZ		;ILLEGAL JOB NUMBER
	MOVE AC1,PRJPRG(TAC1)	;GET PPN OF INITIATING JOB
	SKIPN FRCFLG		;DON'T LOG ON CTY IF BLESSED BY LOGIN PROGRAM
	CAMN AC1,PRJPRG(J)	;SAME AS PPN OF AFFECTED JOB?
	JRST LOGIT2		;YES, DON'T REPORT ON CTY
LOGIT1:	PUSHJ P,DISUSR		;PRINT TIME FOR NEW MESSAGE ON CTY
	 SIXBIT /USRLOG/
	PUSHJ P,DISJOB		;PRINT JOB NUMBER AND NAME OF AFFECTED JOB
	MOVE TAC,PRJPRG(J)
	PUSHJ P,DISPPN		;PRINT PPN OF AFFECTED JOB
	PUSHJ P,DISERR
	[ASCIZ/ /]
	DISARG STR,<@TAC-20(P)>	;VERB OF ACTION DONE
	[ASCIZ/by /]
	-1
	MOVE J,TAC1-17(P)	;JOB NUMBER OF INITIATING JOB
	JUMPE J,[
		PUSHJ P,DISMES
		ASCIZ/unlogged in user/
		HRRZ J,LINSAV	;GET TTY NUMBER WHERE CURRENT COMMAND WAS TYPED
		JRST LOGIT4	]
	PUSHJ P,DISJOB		;PRINT JOB NUMBER AND NAME OF INITIATING JOB
	MOVE TAC,PRJPRG(J)
	PUSHJ P,DISPPN		;PRINT PPN OF INITIATING JOB
	HRRZ J,JBTLIN(J)	;TTY NUMBER OF INITIATING JOB
LOGIT4:	PUSHJ P,DISMES
	ASCIZ/ on TTY/
	MOVE TAC,J		;TTY NUMBER
	PUSHJ P,DISLOC		;PRINT TTY NUMBER (SHOULDN'T BE DETACHED!)
	PUSHJ P,DISCRLF
	MOVE J,J-17(P)		;RESTORE J
LOGIT2:	MOVE DDB,DDB-17(P)	;RESTORE TTY DDB
	OFFSCN			;TURN OFF SCANNER CHANNEL WHILE WE
	PUSHJ P,TSETBF		; CLEAR TTY INPUT AND OUTPUT BUFFERS
	ONSCN
	HRRE TAC,JBTLIN(J)	;GET 'TTY' LINE NO. FOR JOB., IF ANY.
	JUMPL TAC,LOGIT6	;jump if detached, don't type on detached DDB
	HLL TAC,LINTAB(TAC)	;see if this is a display
	TLNE TAC,DISLIN!DDDLIN!DMLIN ;skip if not a dpy (don't reset dpy up chain)
	PUSHJ P,DPYRST		;RESET DISPLAY TO NORMAL (CLOBBERS DDB, ETC)
	MOVE DDB,DDB-17(P)	;RESTORE DDB FOR TYPEOUT
	PUSHJ P,INLMES
	ASCIZ/;
;Your job has been /
	MOVE TAC,TAC-17(P)	;ADDRESS OF LOG MESSAGE VERB
	PUSHJ P,CONMES		;TELL WHAT HAPPENED TO HIM
	SKIPN TAC,TAC1-17(P)	;ANY INITIATING JOB?
	JRST [	PUSHJ P,INLMES
		ASCIZ/by unlogged in user/
		HRRZ J,LINSAV	;GET LINE NUMBER WHERE CURRENT COMMAND WAS TYPED
		JRST LOGIT5 ]
	PUSHJ P,INLMES
	ASCIZ/by job /
	MOVE TAC,TAC1-17(P)	;GET INITIATING JOB NUMBER
	PUSHJ P,RADX10
	MOVE J,TAC1-17(P)	;GET INITIATING JOB NUMBER
	MOVE TAC,PRJPRG(J)
	PUSHJ P,OUTPPN		;PRINT PPN
	HRRZ J,JBTLIN(J)	;LINE NUMBER OF INITIATING JOB
LOGIT5:	PUSHJ P,INLMES
	ASCIZ/ on TTY/
	MOVE TAC,J		;GET TTY LINE NUMBER OF INITIATOR
	PUSHJ P,OCTPNT
	PUSHJ P,CRLF
LOGIT6:	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,UTYPET		;START TTY OUTPUT
	LDB TAC,PUNIT		;LINE NUMBER OF LOSER, FOR BEEPING
	MOVE IOS,DEVIOS(DDB)
	TLNN IOS,TTYDTC		;SKIP IF DETACHED DDB
	PUSHJ P,BEEP1		;BEEP LOSER
	POPACS
	POPJ P,

;Here for KILL cmd or uuo. Can't be killing self. Same args in ACs as LOGIT above.
LOGKIL:	PUSHACS
;	MOVE AC1,JBTPRV(TAC1)	;GET PRIVS OF KILLER
;	TLNN AC1,MESPRV
;	JRST LOGIT0		;NORMAL KILL
	JUMPGE TAC1,LOGIT0	;JUMP IF NORMAL KILL
;HERE FOR AUTOLOGOUT FROM SPY KILLING AN INACTIVE JOB.
	OFFSCN			;TURN OFF SCANNER CHANNEL WHILE WE
	PUSHJ P,TSETBF		; CLEAR TTY INPUT AND OUTPUT BUFFERS
	ONSCN
	PUSHJ P,DPYRST		;RESET DISPLAY TO NORMAL (CLOBBERS DDB, ETC)
	MOVE DDB,DDB-17(P)	;RESTORE DDB FOR TYPEOUT
	PUSHJ P,INLMES
	ASCIZ/;;
;; Autologout
/
	JRST LOGIT6		;NOW START TTY AND BEEP KILLEE

LOGLUZ:	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/AT LOGIT WITH ILLEGAL INITIATING JOB NUMBER = /]
	DISARG OCT,<TAC1-20(P)>
	[ASCIZ/
/]
	DISARG STR,<@TAC-20(P)>	;TELL WHAT IS HAPPENING TO AFFECTED JOB
	[ASCIZ/JOB = /]
	DISARG DEC,<J-20(P)>	;NUMBER OF AFFECTED JOB
	[ASCIZ/
/]
	-1
	DEBCHECK(POPACS)
	POPJ P,

OUTPPN:	MOVEI TEM,"["		;PRINT A PPN FROM TAC
	PUSHJ P,OUTCHS
	PUSH P,TAC
	HLLZ TAC1,TAC
	PUSHJ P,PRNAME
	MOVEI TEM,","
	PUSHJ P,OUTCHS
	POP P,TAC
	HRLZ TAC1,TAC
	PUSHJ P,PRNAME
	MOVEI TEM,"]"
	JRST OUTCHS
;Record event sequence in debugging buffer ;⊗ DEBWD

;Routine used for debugging.  Records a sequence of events (data) in
;a circular buffer.  Call with datum in TAC.  Preserves all ACs.
IFN FTDBGB,<
↑DEBWD:	PUSH P,AC1		;save an AC
	AOS DBGCNT		;count nbr of items stored
	AOSL AC1,DBGPTR		;get the pointer (putter), skip if out of range low
	CAIL AC1,DBGEND-DBGBEG	;skip if within range still
	SETZB AC1,DBGPTR 	;yes, start over at beginning
	MOVEM TAC,DBGBEG(AC1)	;store datum in circular buffer
	POP P,AC1		;restore AC
	POPJ P,
>;IFN FTDBGB
