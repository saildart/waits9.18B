COMMENT ⊗   VALID 00004 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN SWPSER ↔ SUBTTL SWPSER	SQIN,SQOUT
C00004 00003	DMDSWP DMDSW1 DMDSW2 DMDSWX DMDSW3 DMDSW4 SWPEND SWPEN1 SWPEN2 SWPEN3 SWPEN4 SWPEN5
C00014 00004	GXSAT GXSAT GXSAT1 GXSAT2 GXSAT3 GXSATR GXSATS GXSATX GXSNXT GXSNX1 GXSNX2 GXSNX3 GXSNX4 RELSWP RELSW1 SWPINI
C00021 ENDMK
C⊗;
BEGIN SWPSER ↔ SUBTTL SWPSER	;SQIN,SQOUT

;PUT A REQUEST IN THE SWAPPING QUEUE.
;  ENTER AT SQIN FOR INPUT, SQOUT FOR OUTPUT
;
;CALL:	MOVE TAC1,JBTPAG(J)
;	HLRZ TAC,JBTSWP(J)
;	PUSHJ P,SQIN OR PUSHJ P,SQOUT
;	<RETURN HERE ALWAYS>
;
;	CONTENTS OF TAC,TAC1 LOST
;TAC = LH(JBTSWP) (SEE GXSAT AND COMMENT IN ALLDAT)
;   IS JOB NUMBER FOR SWAPPING PACK SWAPPING
;   IS 400000 + FIRST SWAPPING BAND FOR FILE PACK SWAPPING

↑SQIN:	TLO TAC,400000		;SET READ INDICATOR
↑SQOUT:	MOVEM TAC,SERA		;STORE THE BLOCK NUMBER
	HLLZ TAC1,TAC1
	LSH TAC1,9		;LH(TAC1) ← NUMBER OF WORDS
	MOVNM TAC1,SQREQ	;SQREQ ← USER RELATIVE AOBJN POINTER
	JRST DFGO		;CALL DSKSER
;DMDSWP DMDSW1 DMDSW2 DMDSWX DMDSW3 DMDSW4 SWPEND SWPEN1 SWPEN2 SWPEN3 SWPEN4 SWPEN5

;DMDSWP, SWPEND

IFN FTDMDP,<
.FATAL Any resemblence in DSKSER to that depicted below is an accident!

;DMDSWP IS CALLED FROM PAGSER WHEN A PAGE FAULT OCCURS IN A PAGE THAT IS
;MARKED AS SWAPPED OUT (THE 4000 BIT IN THE PAGE TABLE ENTRY IS OFF).
;TAC1 HAS THE PAGE GROUP NUMBER (VIRTUAL PAGE NUMBER OF THE FAULT / 4)
;THAT IS TO BE SWAPPED IN.  IT IS ASSUMED THAT NOT ALL OF THE PAGES IN
;THE PAGE GROUP NEED BE SWAPPED.  THE PAGE TABLE IS CONSULTED TO SEE WHICH
;PAGES ACTUALLY NEED TO BE SWAPPED.  THE JOB NUMBER IS ASSUMED TO BE IN J.
;DMDSWP GETS THE CORE FOR THOSE PAGES THAT NEED TO BE SWAPPED AND PUTS THEIR
;PHYSICAL PAGE NUMBERS IN THE PAGE MAP.  IT ALSO SETS THE T (TRANSFER) BIT
;IN THE PAGE MAP ENTRIES.  IT THEN STORES IN TFRIOW IN THE JOB'S SWAPPING
;DDB THE PAGE GROUP NUMBER AND A 4 BIT FIELD INDICATING WHICH PAGES
;IN THE GROUP ARE ACTUALLY TO BE SWAPPED.  IT SETS A BIT IN TFRCTL TELLING
;DSKSER TO INTERPRET THE TFRIOW IN THIS SPECIAL WAY AND THEN QUEUES UP
;A SWAPPING REQUEST.  TFRSEC IS SET TO THE DISK ADDRESS OF THE TRACK CONTAINING
;THE PAGES AND THE SIGN BIT IS SET TO INDICATE A SWAP OP.
;DMDSWP TAKES THE DIRECT RETURN IF IT CAN'T GET CORE TO SWAP INTO.

DMDSWP:	PUSH P,LOC
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,DDB
	MOVE DDB,J
	IMULI DDB,DDBSIZ
	ADDI DDB,SWPDDB+DDBSKW		;JOB'S SWAPPING DDB
	SKIPE TFRCTL(DDB)		;SKIP IF SWAPPING DDB IS AVAILALBE
	JRST DMDSWX			;IN USE (MUST BE FOR SWAPOUT), TAKE FAIL RET
	MOVE TAC,TAC1			;PAGE GROUP NUMBER
	ROT TAC,-1
	MOVE AC1,J
	LSH AC1,6			;J*64 GIVES JBTSWA ENTRY FOR THIS JOB
	ADDI TAC,JBTSWA(AC1)
	HLRZ AC1,(TAC)			;EVEN PAGE GROUP
	SKIPGE TAC
	HRRZ AC1,(TAC)			;ODD PAGE GROUP
	JUMPE AC1,DMDER1		;NO SWAPPING SPACE WAS ASSIGNED
	TLO AC1,400000			;MARK AS SWAP OP
	MOVEM AC1,TFRSEC(DDB)		;STORE DISK ADDRESS
IFE FTMPP2,<
	MOVE TAC,JBTMAP(J)		;PAGE TABLE PAGE NUMBER
>;IFE FTMPP2
IFN FTMPP2,<
	PUSHJ P,JOBMAP
	 JFCL
	MOVEI TAC,(AC1)
>;IFN FTMPP2
	LSH TAC,9
	LSH TAC1,2			;CONVERT PAGE GROUP TO PAGE NUMBER
	ADDI TAC,(TAC1)			;ADDRESS OF FIRST PAGE IN GROUP
	SETZB AC1,AC2			;BITS AND COUNT
	HRLI TAC,-4			;FOR EACH OF 4 PAGES IN THE GROUP
DMDSW1:	SKIPE AC3,(TAC)			;SKIP IF THERE'S A PAGE MAP ENTRY
	TLNE AC3,104010			;SKIP IF NOT IN CORE AND NOT IN TRANSIT
	JRST DMDSW2			;  AND NOT FRESH
	IORI AC1,20			;SET A BIT
	ADDI AC2,1			;AND COUNT A COUNT
DMDSW2:	LSH AC1,-1			;SHIFT BITS OVER
	AOBJN TAC,DMDSW1
	JUMPE AC2,DMDER0		;NOBODY TO SWAP IN
	HRL TAC1,AC1			;BITS,,FIRST VIRTUAL PAGE NUMBER IN GROUP
	DPB AC2,[POINT 3,TAC1,2]	;STORE COUNT IN TOP 3 BITS
	MOVEM TAC1,TFRIOW(DDB)		;STORE HERE FOR DSKSER
	MOVSI AC3,DSWAP
	MOVEM AC3,TFRCTL(DDB)
	MOVSI TAC1,10			;IN TRANSIT BIT
	SUBI TAC,4			;ADDRESS OF FIRST PAGE IN GROUP AGAIN
	MOVE AC3,TAC			;PUT IT SOMEPLACE SAFE
	PUSHJ P,GETNPG			;GET (AC2) MANY PAGES
	 PUSHJ P,DMDSW3			;ARGUMENT TO GETNPG
	 JRST DMDSWX			;NO CORE
	PUSHJ P,DFGO			;START UP DSKSER
	AOS -5(P)			;INDICATE WE WERE ABLE TO ASSIGNE THE CORE
DMDSWX:	POP P,DDB
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,LOC
	POPJ P,

DMDSW3:	TRNE AC1,1			;SKIP IF WE'RE SUPPOSED TO SKIP THIS PAGE
	JRST DMDSW4
	LSH AC1,-1
	AOJA AC3,DMDSW3			;TRY NEXT PAGE

DMDSW4:	HRRM LOC,(AC3)			;STORE PHYSICAL PAGE NUMBER IN MAP
	IORM TAC1,(AC3)			;TURN ON "IN TRANSIT" BIT
	LSH AC1,-1
	AOJA AC3,CPOPJ			;ADVANCE TO NEXT PAGE FOR NEXT CALL


;SPWEND IS CALLED (JUMPED TO ACTUALLY) FROM DSKCHN WHEN THE SWAP OPERATION
;HAS COMPLETED WITHOUT ANY ERRORS.  DDB AND J ARE ALREADY SET UP.
;HERE WE FIX UP THE PAGE MAP ENTRIES OF THE PAGES THAT ACTUALLY GOT SWAPPED
;IN AND REQUE THE JOB IF IT IS IN THE PAGEQ.
SWPEND:
IFE FTMPP2,<
	MOVE TAC,JBTMAP(J)
>;IFE FTMPP2
IFN FTMPP2,<
	PUSHJ P,JOBMAP
	 JFCL
	MOVEI TAC,(AC1)
>;IFN FTMPP2
	LSH TAC,9
	ADD TAC,TFRIOW(DDB)		;PAGE TABLE ENTRY ADDR OF FIRST PAGE IN GRP
	HRL TAC,TFRIOW(DDB)		;PAGE NUMBER
	PUSH P,TAC			;SAVE FOR SWPEN4
	LDB AC1,[POINT 4,TFRIOW(DDB),17];BITS OF WHICH PAGES WERE SWAPPED IN
SWPEN1:	TRNN AC1,1			;SKIP IF THIS PAGE WAS SWAPPED
	JRST SWPEN2
	MOVE AC2,(TAC)			;GET PAGE TABLE ENTRY
	TLZ AC2,20			;CLEAR IN TRANSIT BIT
IFN FTKLB,<
.FATAL This use of the page table entries doesn't work for model B microcode paging.
;because I haven't figured out what really needs to be on for pages swapped out
;on the model B.  This whole page needs to be checked out.  Also PAGSER for FTDMDP.
>;IFN FTKLB
	TLO AC2,P.READ ! P.ACC		;SET (BOTH) ACCESS BITS
	MOVEM AC2,(TAC)
SWPEN2:	LSH AC1,-1			;SHIFT THE BITS
	ADDI TAC,1			;ADVANCE PAGE TABLE ENTRY POINTER
	JUMPN AC1,SWPEN1		;JUMP IF MORE PAGES TO DO
	MOVE TAC,JBTSTS(J)
	SETZM TFRCTL(DDB)		;FLAG SWAPPING DDB NOT IN USE ANY MORE
	TLNE TAC,JSEG			;IS THIS AN UPPER?
	JRST SWPEN4			;YES, PROPAGATE TO LOWERS
	POP P,(P)			;DON'T NEED PAGE TABLE ADDR ANY MORE
SWPEN3:	MOVM TAC,JOBQUE(J)
	CAIE TAC,PAGEQ			;SKIP IF HE WAS IN PAGEQ
	POPJ P,				;NOTHING LEFT TO DO
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	JRST REQUE			;REQUEUE HIM TO RUNQ

SWPEN4:	POP P,AC1			;GET PAGE NO,,ADDR OF ENTRY IN UPPER'S MAP
	PUSHJ P,UAPPLY			;COPY TO ALL LOWERS
	 PUSHJ P,SWPEN5
	POPJ P,

;J HAS LOWER'S NUMBER, DDB HAS UPPER'S NUMBER
SWPEN5:	SKIPE AC2,JBTMAP(J)		;DOES THIS LOWER HAVE A MAP?
	SKIPN JBTPAG(J)			;AND IN CORE?
	JRST SWPEN3			;NO.  SEE ABOUT PAGE WAIT
IFN FTMPP2,<
	MOVEI TAC,(AC2)			;PHYSICAL PAGE NUMBER OF UPMP
	MOVEI TAC1,DPGEXP		;EXEC VIRTUAL PAGE FOR US
	PUSHJ P,ADDEMP			;GOBBLE IT
	MOVEI AC2,DPGEXP⊗9		;EXEC VIRTUAL ADDR OF UPMP
>;IFN FTMPP2
IFE FTMPP2,<
	LSH AC2,9
>;IFE FTMPP2
	HLRZ TAC,AC1			;GET FIRST PAGE NUMBER WITHIN UPPER
	ADDI AC2,400(TAC)		;ADDR OF FIRST PAGE'S ENTRY IN LOWER'S MAP
	DMOVE TAC,(AC1)			;COPY 4 WORDS FROM UPPER TO LOWER
	DMOVEM TAC,(AC2)
	DMOVE TAC,2(AC1)
	DMOVEM TAC,2(AC2)
IFN FTMPP2,<
	MOVEI TAC1,DPGEXP
	PUSHJ P,DELEMP			;FLUSH EXEC VIRTUAL PAGE
>;IFN FTMPP2
	JRST SWPEN3			;NOW SEE ABOUT REQUEUING
>;IFN FTDMDP
;GXSAT GXSAT GXSAT1 GXSAT2 GXSAT3 GXSATR GXSATS GXSATX GXSNXT GXSNX1 GXSNX2 GXSNX3 GXSNX4 RELSWP RELSW1 SWPINI

;GXSAT, RELSWP, SWPINI   ALLOCATION OF SWAPPING SPACE

;DECIDE WHERE TO SWAP JOB. CALLED FROM OUTJOB.
;CALL:
;	MOVE TAC1,JBTPAG(J)
;	PUSHJ P,GXSAT
;	ALWAYS RETURN HERE

;RETURNS TAC = JOB NUMBER FOR SWAPPING PACK.
;	     = 400000 + FIRST SWAPPING BAND FOR FILE PACK SWAPPING

IFE FTNSWP,<
↑GXSAT:	MOVEI TAC,(J)		;FOR SWAPPING PACK SWAPPING, RETURN JOB NUMBER
	POPJ P,
>;IFE FTNSWP

IFN FTNSWP,<
↑GXSAT:	PUSH P,TAC1
	MOVEI AC1,0		;ACCUMULATE AMOUNT OF SPACE ASSIGNED
	MOVNI AC2,1		;INITIALIZE PREVIOUS POINTER
	MOVSI AC3,400000	;LAST BAND ASSIGNED BIT IN SWBAND
	HLRZ TAC1,TAC1
	LSH TAC1,9		;NUMBER OF WORDS NEEDED IN ASSIGNMENT
	HLRZ TAC,JBTSWP(J)
	DPB TAC,SWPPRV		;SAVE POINTER TO FIRST BAND IN SWBAND-1
	JUMPE TAC,GXSAT2	;THERE IS NO SPACE ASSIGNED NOW
GXSAT1:	TRZ TAC,777000
IFE FTRH,<
	ADDI AC1,9*SWDSIZ	;EACH BAND IS WORTH 9 MORE TRACKS
	TRNE TAC,1
	ADDI AC1,SWDSIZ		;OR 10 IF IT IS AN ODD NUMBERED BAND
>;IFE FTRH
IFN FTRH<
	ADD AC1,RHSBSZ		;Add size of RH-Swapping Band
>;IFN FTRH
	CAML AC1,TAC1
	JRST GXSATR		;HAVE ENOUGH, RELEASE THE REST
	MOVE AC2,TAC		;SAVE PREVIOUS
	LDB TAC,SWPNXT		;GET POINTER TO NEXT BAND ASSIGNED
	TDNN AC3,SWBAND(AC2)
	JRST GXSAT1		;LOOP IF MORE ASSIGNED
	ANDCAM AC3,SWBAND(AC2)
GXSAT2:	PUSHJ P,GXSNXT		;NEED MORE, FIND ANOTHER FREE BAND
	 JRST GXSAT3		;NO MORE FREE, TRY THOSE OF SWAPPED IN JOBS
	HLLM AC3,SWBAND(TAC)	;ZERO JOB AND NEXT FIELD OF ENTRY, SET "LAST" BIT
	DPB J,SWPJOB		;ASSIGN IT TO US
	DPB TAC,SWPPRV		;PREVIOUS POINTS AT US
	JRST GXSAT1

GXSAT3:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /SWAPPING SPACE EXHAUSTED, YOU LOSE
/
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCAL
	JRST AUTOLOAD

GXSATR:	MOVE AC2,SWBAND(TAC)
	IORM AC3,SWBAND(TAC)	;THIS IS THE END OF THE LINE
	JUMPL AC2,GXSATX	;DONE IF THE BIT WAS SET
GXSATS:	LDB TAC,SWPNX2		;GET NEXT ENTRY
	MOVE AC2,SWBAND(TAC)	;SAVE A COPY AND ...
	HRRZS SWBAND(TAC)	;... KILL IT
	JUMPGE AC2,GXSATS
GXSATX:	LDB TAC,SWFRST		;PICK UP POINTER TO FIRST BAND FROM SWBAND-1
	IORI TAC,400000
	POP P,TAC1
	POPJ P,

GXSNXT:	JUMPL TAC,GXSNX2	;JUMP IF TAC ALREADY HAS AN AOBJN POINTER
	MOVSI TAC,-BNDTSZ	;size of band table
GXSNX1:	LDB TEM,SWPJOB		;SEE IF THIS BAND IS ASSIGNED
	JUMPE TEM,CPOPJ1	;IT'S FREE
GXSNX2:	AOBJN TAC,GXSNX1
	PUSH P,J		;No more free bands, take some from job in core
	MOVEI J,JOBN-1		;Search for in core job with swapping bands
GXSNX3:	HLRZ TAC,JBTSWP(J)	;Any swapping bands assigned to this job?
	JUMPE TAC,GXSNX4	;Jump if no bands assigned
	MOVE TEM,JBTSTS(J)	;See if job is in core (if no job!, take bands)
	TLNN TEM,SWP		;Can't touch bands if job is swapped on them
	CAMN J,(P)		;In core, but don't steal bands from ourself!
	JRST GXSNX4		;Swapped out, don't touch (or is the job asking)
	PUSHJ P,RELSWP		;Swapped in, steal his assigned bands
	ANDI TAC,777		;Just the band number (first band just returned)
	POP P,J			;Restore our job
	JRST CPOPJ1		;Success return w/band number in TAC

GXSNX4:	SOJG J,GXSNX3		;Look at next job, maybe to reclaim its bands
	POP P,J			;Restore our job
	POPJ P,			;No more jobs, no more swapping space!

;RELSWP RELEASES SWAPPING SPACE OCCUPIED BY A JOB WHOSE NUMBER IS IN J
↑RELSWP:PUSH P,TAC
	HLRZ TAC,JBTSWP(J)
	JUMPE TAC,TPOPJ		;NO SPACE WAS ASSIGNED
	PUSH P,AC2
	ANDI TAC,777
RELSW1:	MOVE AC2,SWBAND(TAC)	;SAVE CURRENT ENTRY
	HRRZS SWBAND(TAC)	;KILL THE ENTRY
	LDB TAC,SWPNX2		;SET TAC TO POINT AT THE NEXT ONE
	JUMPGE AC2,RELSW1	;JUMP IF NOT THE END
	HRRZS JBTSWP(J)		;SAY SPACE NOT ASSIGNED
	POP P,AC2
	JRST TPOPJ
>;IFN FTNSWP

;INITIALIZE THE SWAPPER
↑SWPINI:
IFE FTDMDP,<
	SETZM SWPCNT
	SETZM FIT
	SETZM FORCE
	SETZM FINISH
	SETZM SERA
>;IFE FTDMDP
IFN FTDMDP,<
	SETZM SWOCNT
	SETZM PFFLDC
>;IFN FTDMDP
	POPJ P,

	BEND SWPSER
