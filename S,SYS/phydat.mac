COMMENT ⊗   VALID 00016 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002		TITLE	PHYDAT	Definitions & Storage for PHYSIO  DSKMSK
C00009 00003		STKACS & Macros to reference stacked ACs.  STKACS STKAC1
C00012 00004	 PHYCHT PHYCHL PHYUNT PHYUNL BHC RSKP R RFALSE RTRUE PA1 ..SAVT RESTT .SAV1 .SAV2 .SAV3 SAVQ RESTQ .SAV4 SAVPQ RESTPQ SAVP RESTP .STKST STKRT0 .ASSET .ASRET
C00017 00005	HOME BLOCK DEFINITIONS  CODHOM HBLEN HM1BLK HM2BLK HOMNAM HOMID HOMPHY HOMSNM HOMLUN HOMHOM HOMP4S HOMFST HOMRXB HOMSTA HOMSTC HOMSIZ HOMBTB HOMMID HOMFE0 HOMFE1 HOMFE2 HOMFE3 HOMSER HOMUID HOMOID HOMFSN HOMCOD HOMSLF
C00020 00006	Support RH file system  HOMPGA CHKHOM CHKHO1 CHKHO2 CHKHO5 CHKHO6 CHKH6B CHKH6A CHKHO7 CHKH13 CHKH14 CHKH11 CHKH12 CHKH17 CHKERR CHKENF CHKERS CHKER0 CHKER1 CHKER2 CHKH40 CHKH16
C00029 00007	 CKHOMU CHKHO8 FSI6TY FSIOTY
C00034 00008	Support RH file system  REDHOM HBCCHK CPYH1 CPYH2 CPYH10 CPYH20 SWPHOM
C00046 00009	BLDSTR - ROUTINE TO SET UP SDB'S AND SDBADR  BLDSTR BLDST1 BLDST2 BLDST3 CRTSTR ADDSTR ADDST0 ADDST5 FNDCHN FNDCH1 GETTYP
C00058 00010	 RHACCW RHABAD RHACC0 RHACC1 RHAC1A RHAC1B WHISIO WHISI0 WHISI1 TIM RHIODN RHIOD1 RHIORT
C00066 00011	For MTCSER  DDNTBL MODCAP MTMTGO MT78GO MT78G2 MTIOSS MTIOS1 MTIOS2
C00076 00012	Mapping routines  MASBGX MRKMPG MULKCR PSIRQ NOSK11 OKSK11 PHYPAG PHYPG1 MAPRCA UNMRCA MOVRCA STORCA APRRPT ASGRES RELRES MEMSCN
C00083 00013		BATQ		Mark BAT blocks  BATQ
C00084 00014		ELOGOO	CALL TO LOGOUT ANOTHER JOB.  ELOGOO FSIPSO TTEMES TTEMS1 FNDSTR MTCLVA MTCLVL SWPDON
C00087 00015		SUBTTL Routines to handle BUGHLT, BUGCHK, BUGINF  BUGH0 BGCCHK BGCINF BHGSTO BCGSTO BIGSTO BUGST1 BUGH3 BUGH9 BUGH9A BUGH10 DISMPT DISMP1
C00094 00016		END
C00095 ENDMK
C⊗;
	TITLE	PHYDAT	Definitions & Storage for PHYSIO ;⊗ DSKMSK

	Search	MONSYM,MACSYM,PROLOG,PHYPAR

;make some PHYPAR defs global
Intern IRBSTS,IRBMOD,IRBCNT,IRBXFL,IRBIVA,IRBADR,IRBDDB,IRMWRD,MS%DOM,MS%FAT
Intern UDBSIZ,UDBSTR
Intern IS.ERR,IS.NRT,US.OFS,US.CHB,US.DSK,CDBUDB,UDBSTS,MAXRH
Intern US.WLK,US.MAI,US.REW,US.BOT
Intern UDBCHR

;Externals from TOPS-20
	Extern	RH2DSP,RP4DSP,TM8DSP,FNDCKU,CKUPAK
	Extern	DGUMAP,DSKSIZ,DSKUTP,NDSKUT,PHYSIO,CHKCKU,CKUNPK

;Externals now in CACDAT
Extern	RHDDBQ,RHDQTX,RHDQTB
Extern	BUGHLT,BUGCHK,BUGINF,BUGACS,BUGACU,BUGPDL,BUGLCK,BUGNUM,BUGPLN
Extern	CHNTAB,FSGET,FSIPPA,FSSUN,NSSUN,PRSNUM,IRTNP

;Externals from WAITS
EXTERN	QDSKIO,DWRITE
Extern	PREAD,P.WRT,EXPGT,RHGERR,INTRTN,C1ACS,DEVIOS
Extern	SECPAG,SECCYL,PAGCYL,CYLUNT,SECUNT,BTWCYL,LPPCYL	;disk size (CACDAT)
Extern	MINFPG,MAXFPU,SECSRF,USSECU,UNIRPB,UNIRTS,UNIBPG	;disk size (CACDAT)
Extern	UNIRPB,UNIRTS,UNIRTL					;disk size (CACDAT)
EXTERN	DISMES,DISTYO,DISCRLF,DISTAB,DISJOB,DISOCT,DISLOC,DISOCH
EXTERN	DISSIX,DISTIM,DDTCALL,DDTTYPE,FSGETU,WDDTCALL,DISFLUSH,FSGIVE
EXTERN	JOB,PHYEXP,ADDEMP,DELEMP,DISUSR,DISGST
EXTERN	SDBUDB,SDBNUM,STRTAB,SDBSTS,SDBNSS,SDBNAM,SDBSIZ,SDBRXB,SDBFSS,SDBTYP,SDBPUC
EXTERN	ST.NAM,ST.SAD,ST.SSZ,ST.BFS,ST.BSS,ST.LAD,ST.MDB,ST.BTB,ST.JOB,ST.CNT,ST.LSA
EXTERN  ST.SMD,ST.MFA,ST.STA,ST.STB,ST.STS,ST.UIS,ST.UIL,ST.LEN,ST.STN
EXTERN	ST.FSS,ST.TYP,ST.RPU,ST.RPB,ST.RTS,ST.SCW,ST.RPC,ST.BPC ;ST.NSS
EXTERN	DD.BPG,DD.RPB,DD.SSZ,DD.RTL,DD.RPG,DD.IRB,DD.CCP,DD.MAP
EXTERN	SDBADR,STRMAX,SYBEXP
EXTERN	MAKSTR,FDDTCALL,FILINE,STRMOU
EXTERN	TFRSEC,TFRCTL,TFRIOW,SDBPTR,STRADR
	
	Intern	UDBADR,CDBADR,UDBCDB
	Intern	PHYCHT,PHYUNT
	Intern	SAVQ,SAVP,SAVPQ,.STKST,.SAV1,.SAV2,.SAV3,.SAV4
	Intern	DSKMSK,BUGH0
	Intern	NOSK11,OKSK11,PSIRQ

;WAITS AC definitions
DEFINE XD (SYMBOL,VALUE)
<SYMBOL=VALUE
INTERN SYMBOL>			;Make LOADER detect conflicts.

XD IOS,0	;*IO DEVICE STATUS WORD 
XD TAC,1	;TEMPORARY
XD TAC1,2	;TEMPORARY
XD J,3		;*JOB NUMBER
XD DDB,4	;*LH=UUOS DONE SO FAR FOR THIS DEVICE (SEE BELOW),
XD DAT,5	;TTY OUTPUT BUFFER POINTER FOR COMMANDS, ERROR MESSAGES, OR TEMP.
XD PROG,6	;*LH=HIGHEST REL. LOC. IN USER AREA
XD TEM,7	;TEMPORARY. NO SPECIAL MEANING
XD DSER,10	;*ADDRESS OF DEVICE SERVICE ROUT. DISPATCH TABLE
XD UCHN,11	;*USER IO CHANNEL NO. (AC FIELD OF THE UUO)
XD PID,12	;PROCESSOR DATA AREA ADDRESS
XD UUO,13	;*CURRENT UUO IN PROGRESS
XD AC1,14	;TEMPORARY ACS
XD AC2,15
XD AC3,16
XD P,17		;*PUSH DOWN POINTER 


DSKMSK==<-DSKNB>←<-↑D18>	;Mask to remove all but disk address bits in LH

;	STKACS & Macros to reference stacked ACs. ;⊗ STKACS STKAC1
;
;Co-routine to save ACS 0 to 16 on the stack.
;Call via   CALL STKACS
;	    return here with caller's ACs saved on stack
;	    return to caller via RET or RETSKP which will unstack the ACs.
;	    Caller's AC number ''N'' may be referenced or changed via
;		    N-17(P)
;
;These macros depend on you not stacking anything else after calling STKACS...
;
DEFINE	..TAC	<TAC-17(P)>
DEFINE	..F	<F-17(P)>
DEFINE	..T1	<T1-17(P)>
DEFINE	..T2	<T2-17(P)>
DEFINE	..T3	<T3-17(P)>
DEFINE	..T4	<T4-17(P)>
DEFINE	..Q1	<Q1-17(P)>
DEFINE	..Q2	<Q2-17(P)>
DEFINE	..Q3	<Q3-17(P)>
DEFINE	..P1	<P1-17(P)>
DEFINE	..P2	<P2-17(P)>
DEFINE	..P3	<P3-17(P)>
DEFINE	..P4	<P4-17(P)>
DEFINE	..P5	<P5-17(P)>
DEFINE	..P6	<P6-17(P)>
DEFINE	..CX	<CX-17(P)>

STKACS::ADD	P,[17,,17]	;augment stack
	JUMPG	P,STKAC1	;jump if overflow
	MOVEM	16,0(P)		;save ac 16
	MOVEI	16,-16(P)
	BLT	16,-1(P)
	MOVE	16,0(P)
	CALL	@-17(P)		;at this point, only P has been changed.
	JRST	.+2
	AOS	-20(P)
	MOVSI	16,-16(P)
	BLT	16,16
	ADJSP	P,-20		;discard 0:16 and return to caller of STKACS
	RET

STKAC1:	SUB	P,[17,,17]
	PUSH	P,TAC
	MOVE	TAC,[POINT 7,[ASCIZ/Fatal: NOT ENOUGH ROOM TO PUSH ACS AT STKACS.
FIND A WIZARD OR RELOAD.  /]]
	JSR	DDTTYPE
	POP	P,TAC
	JRST	DDTCALL

;⊗ PHYCHT PHYCHL PHYUNT PHYUNL BHC RSKP R RFALSE RTRUE PA1 ..SAVT RESTT .SAV1 .SAV2 .SAV3 SAVQ RESTQ .SAV4 SAVPQ RESTPQ SAVP RESTP .STKST STKRT0 .ASSET .ASRET

PHYCHT::.CTRH2,,RH2DSP
PHYCHL==:PHYCHT-.		;NEGATIVE LENGTH OF TABLE

PHYUNT::.UTRP4,,RP4DSP
	.UTTM7,,TM8DSP
;	.UTMEI,,MEIDSP
PHYUNL==:PHYUNT-.		;NEGATIVE LENGTH OF TABLE

BHC::	0,,0
	1,,1
	2,,2
	3,,3
	4,,4
	5,,5
	6,,6
	7,,7
	10,,10
	11,,10
	12,,12
	13,,13
	14,,14
	15,,15
	16,,16
	17,,17

RSKP::	AOS	(P)
R::	RET

RFALSE::TDZA	T1,T1
RTRUE::	SETO	T1,
	RET

PA1::	POP	P,T1
	RET

..SAVT::ADJSP	P,4
	DMOVEM	T1,-3(P)
	DMOVEM	T3,-1(P)
	CALL	(CX)
RESTT:	SKIPA
	AOS	-4(P)
	DMOVE	T1,-3(P)
	DMOVE	T3,-1(P)
	ADJSP	P,-4
	RET

.SAV1:	PUSH	P,Q1
	CALL	(CX)
	AOS	-1(P)
	POP	P,Q1
	RET

.SAV2:	ADJSP	P,2
	DMOVEM	Q1,-1(P)
	CALL	(CX)
	SKIPA
	AOS	-2(P)
	DMOVE	Q1,-1(P)
	ADJSP	P,-2
	RET

.SAV3:
SAVQ:	ADJSP	P,3
	DMOVEM	Q1,-2(P)
	MOVEM	Q3,0(P)
	CALL	(CX)
RESTQ:	SKIPA
	AOS	-3(P)
	DMOVE	Q1,-2(P)
	MOVE	Q3,0(P)
	ADJSP	P,-3
	RET

.SAV4:	ADJSP	P,4
	DMOVEM	Q1,-3(P)
	DMOVEM	Q3,-1(P)
	CALL	(CX)
	SKIPA
	AOS	-4(P)
	DMOVE	Q1,-3(P)
	DMOVE	Q3,-1(P)
	ADJSP	P,-4
	RET

SAVPQ:	ADJSP	P,11			;Call with JSP CX,SAVPQ
	DMOVEM	Q1,-10(P)
	MOVEM	Q3,-6(P)
	DMOVEM	P1,-5(P)
	DMOVEM	P3,-3(P)
	DMOVEM	P5,-1(P)
	CALL	(CX)
RESTPQ:	SKIPA
	AOS	-11(P)
	DMOVE	Q1,-10(P)
	MOVE	Q3,-6(P)
	DMOVE	P1,-5(P)
	DMOVE	P3,-3(P)
	DMOVE	P5,-1(P)
	ADJSP	P,-11
	RET

SAVP:	ADJSP	P,6
	DMOVEM	P1,-5(P)
	DMOVEM	P3,-3(P)
	DMOVEM	P5,-1(P)
	CALL	(CX)
RESTP:	SKIPA
	AOS	-6(P)
	DMOVE	P1,-5(P)
	DMOVE	P3,-3(P)
	DMOVE	P5,-1(P)
	ADJSP	P,-6
	RET

;call by	JSP CX,.STKST
;		count,,count		;count of local stack cells to allocate
;		return here
;		...
;		RET (or RSKP)		;return to deallocate space
;
;
.STKST:	PUSH	P,CX			;push local return
	HRRZ	CX,0(CX)		;get count of cells to allocate
	ADJSP	P,-1(CX)		;allocate cells (less 1 for push)
	MOVNI	CX,1(CX)		;negative number of cells allocated+1
	HRRZ	CX,CX			;0,,-<cells allocated+1>
	PUSH	P,CX			;save negative cell count
	ADDI	CX,1(P)			;-<cellcount+1>+1(P) = addr of return CX
	MOVE	CX,(CX)			;restore local return from stack
	CALL	1(CX)			;co-return to caller
	JRST	STKRT0
	ADJSP	P,@(P)			;Stack top has 0,,-<adjustment>
	AOS	(P)
	RET

STKRT0:	ADJSP	P,@(P)			;Stack top has 0,,-<adjustment>
	RET

;SUPPORT ROUTINE FOR ASUBR
.ASSET::PUSH	P,P6		;SAVE AC FOR STACK POINTER
	MOVE	P6,P		;SETUP FRAME PTR
	ADJSP	P,4		;ALLOCATE SPACE
	DMOVEM	T1,1(P6)	;SAVE ARGS
	DMOVEM	T3,3(P6)
	PUSHJ	P,0(CX)		;CONTINUE ROUTINE
.ASRET:: JRST	[MOVEM P6,P	;NO-SKIP RETURN, CLEAR STACK
		POP P,P6
		RET]
	MOVEM	P6,P
	POP	P,P6
	RETSKP

;HOME BLOCK DEFINITIONS ;⊗ CODHOM HBLEN HM1BLK HM2BLK HOMNAM HOMID HOMPHY HOMSNM HOMLUN HOMHOM HOMP4S HOMFST HOMRXB HOMSTA HOMSTC HOMSIZ HOMBTB HOMMID HOMFE0 HOMFE1 HOMFE2 HOMFE3 HOMSER HOMUID HOMOID HOMFSN HOMCOD HOMSLF

CODHOM==:707070			;HOME BLOCK SPECIAL CODE
HBLEN==:200			;LENGTH OF HOME BLOCK
HM1BLK==:1			;BLOCK # OF FIRST HOME BLOCK
HM2BLK==:↑D10			;BLOCK # OF SECOND HOME BLOCK

HOMNAM==:0		;SIXBIT /HOM/
HOMID==:1		;SIXBIT /ID/ (ZERO ON SAIL)
HOMPHY==:2		;PHYSICAL ADR'S OF HOME BLOCKS
HOMSNM==:3		;SIXBIT /STRUCTURE NAME/
HOMLUN==:4		;XWD TOTAL PACKS, LOGICAL PACK #
HOMHOM==:5		;BLOCK # OF OTHER HOME BLK,, BLK # OF THIS HB
HOMP4S==:6		;# OF PAGES FOR SWAPPING ON EACH UNIT
HOMFST==:7		;FIRST SWAPPING TRACK ON EACH UNIT
HOMRXB==:10		;ADR OF INDEX BLOCK OF ROOT DIRECTORY
HOMSTA==:11		;Address of SAT Table
HOMSTC==:12		;Count of SAT Table consecutive sectors
HOMSIZ==:13		;SIZE OF A UNIT IN SECTORS (BLOCKS)
HOMBTB==:14		;SIZE OF TOP HALF OF BIT TABLE (NUMBER OF TRACKS)
HOMMID==:15		;MEDIA IDENTIFICATION (PACK UNIQUE CODE) (ZERO ON SAIL)

HOMFE0==:61		;FE FILE SYSTEM WORD ONE (SECTOR #)
HOMFE1==:62		;FE FILE SYSTEM WORD TWO (# OF SECTORS)

;HOME BLOCK LOCATIONS 61-100 ARE RESERVED FOR THE FRONT-END.

HOMFE2==:101		;BOOTSTRAP.BIN WORD ONE (SECTOR #)
HOMFE3==:102		;BOOTSTRAP.BIN WORD TWO (# OF SECTORS)
HOMSER==:164		;SERIAL NUMBER OF CPU WHICH IS BOOTED BY THIS STRUCTURE
HOMUID==:165		;UNIT ID
HOMOID==:170		;OWNER ID
HOMFSN==:173		;FILE SYSTEM TYPE
HOMCOD==:176		;0 ,, CODHOM
HOMSLF==:177		;THIS HOME BLOCK #
;Support RH file system ;⊗ HOMPGA CHKHOM CHKHO1 CHKHO2 CHKHO5 CHKHO6 CHKH6B CHKH6A CHKHO7 CHKH13 CHKH14 CHKH11 CHKH12 CHKH17 CHKERR CHKENF CHKERS CHKER0 CHKER1 CHKER2 CHKH40 CHKH16

	HOMPGA==SYBEXP←PGSFT
;The initialization code uses some of the pages that are allocated to DSKSER
;for system buffers.

;CHKHOM--locate and mount all relevant structures.
;called with DDB (aka Q3)/ a DDB which has been set with PUNIT = structure
;			    number of primary RH structure. (PRSNUM)
;			    SDBADR(this structure) addresses a prototype SDB
;			    in which ST.NAM is set to the name of primary struct.
;All structures that are found will be mounted.  For additional structures,
;additional SDBs and DDBs are made with new unit numbers, etc.

;procedure
;for every channel, for every unit.  read the home block (CKHOMU)
;if the unit has discernable homeblocks, search SDBADR to maximum, or blank,
;seeking a structure with the same name.  If none, create a prototype.
;Given the SDB of a proto or partial structure, fill in, to the extent that
;the new info is compatable.   Print messages regarding incompatabilities.
;mark incompatabilities as structure errors in ST.STS


CHKHOM::MOVSI	P4,-CHNN	;SET UP TO READ EVERY HOME BLOCK
	PUSH	P,Q3		;preserve DDB!
CHKHO1:	SKIPN	P1,CHNTAB(P4)	;THIS CHANNEL EXIST?
	JRST	CHKHO2		;NO, TRY NEXT ONE
	CALL	DGUMAP		;YES, LOOP OVER ALL UNITS ON THIS CHANNEL
	 CALL CKHOMU		;XCT for each U in C. EXAMINE EACH U ON THE CHANNEL
CHKHO2:	AOBJN	P4,CHKHO1	;LOOP OVER ALL CHANNELS
	POP	P,Q3		;restore DDB

;LOOP THROUGH STRUCTURES CHECKING FOR CONSISTENCY AND COMPLETENESS
	MOVSI	P1,-STRMAX	;SET UP TO LOOK AT SDBADR
	HRLZ	P2,PRSNUM
	HRR	P2,PRSNUM
	ADD	P1,P2		;AOBJN pointer to interesting part of SDBADR
CHKHO5:	SKIPN	P2,SDBADR(P1)	;IS THIS STR DEFINED?
	JRST	CHKHO7		;NO, SKIP IT
	HRRZ	T1,P1		;GET STRUCTURE NUMBER
	MOVEM	T1,ST.STN(P2)	;PUT THE STR NUMBER INTO STRUC
	MOVE	T1,ST.STS(P2)	;GET FLAGS
	TXNE	T1,HB%HBM	;IS THERE ANY INCONSISTENCY IN HOME B'S
	JRST	CHKH16		;YES, GO COMPLAIN
	TXNE	T1,MI%MXB	;IS BIT TABLE TOO BIG?
	JRST	CHKH40		;YES. GO COMPLAIN
	MOVN	P3,ST.UIS(P2)	;GET NUMBER OF PACKS IN THIS STR
	JUMPE	P3,CHKHO7	;If zero, we have no primary structure
	HRLZS	P3		;SET UP AOBJN COUNTER
	HRR	P3,P2		;GET ADR OF SDB

;LOOP THROUGH LOGICAL UNITS
CHKHO6:	SKIPN	T1,ST.UIL(P3)	;IS THERE A UNIT?
	JRST	CHKH11		;NO, MISSING UNIT
	TXNE	T1,HB%MUN	;MULTIPLE UNIT?
	JRST	CHKH12		;YES, GO COMPLAIN
	TXNE	T1,HB%WLK	;WRITE LOCKED?
	CALL	CHKH17		;YES

;STORE INTO UDBSTR (UNIT WITHIN STRUCTURE,,STRUCTURE NUMBER)

CHKH6B:	MOVEM	P1,UDBSTR(T1)	;STORE STRUCTURE NUMBER IN RH
	MOVEI	T2,0(P3)	;ADDRESS OF SDB FOR THIS STRUCTURE PLUS UNIT NO.
	SUBI	T2,0(P2)	;MINUS ADDRESS OF SDB FOR THIS STRUCTURE
	HRLM	T2,UDBSTR(T1)	;STORE UNIT NUMBER IN LH

	TXNN	T1,HB%1OK	;GOOD PRIMARY HOME BLOCK?
	JRST	CHKH13		;NO
	TXNN	T1,HB%2OK	;GOOD BACKUP HOME BLOCK?
	JRST	CHKH14		;NO
CHKH6A:	AOBJN	P3,CHKHO6	;CHECK OTHER UNITS IN STR
	PUSH	P,DDB
	MOVE	DDB,ST.MDB(P2)
	CALL	STRMOU		;If the STR is valid, mount the SAT
	POP	P,DDB
CHKHO7:	AOBJN	P1,CHKHO5	;LOOP FOR ALL STR'S
	MOVE	T1,PRSNUM	;number of the desired public structure
	MOVE	T1,SDBADR(T1)
	SKIPE	ST.UIS(T1)	;Is this real?  ST.UIS is zero in prototype
	RET			;Yes, a real primary structure
	CALL	DISGST		;print time of msg on CTY
	PUSHJ	P,DISMES
	ASCIZ	/Fatal: Primary Structure not Found
/
	PUSHJ	P,DISFLU
	JRST	FDDTCALL


;ERRORS IN A SINGLE UNIT

;Problem with one home block. Non-fatal.  Print a warning.

CHKH13:	JSP	T1,CHKENF
	ASCIZ	/ Primary Home Block is incorrect in Structure /

CHKH14:	JSP	T1,CHKENF
	ASCIZ	/ Secondary Home Block is incorrect in Structure /

;Missing U in STR.  This is a fatal error, but examine remaining units
CHKH11:	JSP	T1,CHKERR
	ASCIZ	/ missing from Structure /

;Multiple U in STR. This is a fatal error, but examine THE REMAINING UNITS
CHKH12:	JSP	T1,CHKERR
	ASCIZ	/ multiply defined in Structure /

;Unit is WRITE LOCKED.  This is a NON-fatal error.  Examine the remaining units
CHKH17:	JSP	T1,CHKER1		;RET returns to caller of CHKH17
	ASCIZ	/ is write-locked in Structure /

CHKERR:	PUSH	P,T1
	MOVX	T1,MS%FAT
	IORM	T1,ST.STS(P2)	;set as a fatal error
	POP	P,T1
CHKENF:	CALL	CHKER1		;non-fatal error
	JRST	CHKH6A

CHKERS:	PUSH	P,T1		;error in structure not unit-related
	MOVX	T1,MS%FAT
	IORM	T1,ST.STS(P2)	;set as a fatal error
	POP	P,T1
	CALL	CHKER0		;
	JRST	CHKHO7		;GO BACK AND LOOK AT OTHER STR'S

CHKER0:	SAVEPQ
	PUSH	P,ST.NAM(P2)
	HRLI	T1,440700
	PUSH	P,T1
	PUSHJ	P,DISUSR
	'CHKERR'
	JRST	CHKER2		;there's no logical unit w/message.

CHKER1:	SAVEPQ
	PUSH	P,ST.NAM(P2)	;structure name
	HRLI	T1,440700	;form a byte pointer to msg.
	PUSH	P,T1		;address of message
	HRRZ	T1,P3		;GET UNIT NUMBER
	SUBI	T1,0(P2)	;SUBTRACT OFF THE SDB ADR
	PUSH	P,T1		;Unit number
	PUSHJ	P,DISUSR
	'CHKERR'
	PUSHJ	P,DISMES
	ASCIZ	/Logical unit /
	POP	P,TAC
	PUSHJ	P,DISLOC
CHKER2:	POP	P,T1		;enter here from CHKER0 - no unit # to print
	CALL	FSIPSO		;print msg pointed to by T1
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	ASCIZ	/.
/
	RET

;PROBLEMS RELATED TO A STRUCTURE
;BIT TABLE FILE IS TOO BIG FOR MONITOR'S ADDRESS SPACE

CHKH40:	JSP	T1,CHKERS
	ASCIZ	/Bit table is too large in structure /

;HOME BLOCK INCONSISTENCY.  FATAL ERROR.  PROCEED TO THE NEXT STRUCTURE
CHKH16:	JSP	T1,CHKERS
	ASCIZ	/Inconsistent set of packs composing structure /
;⊗ CKHOMU CHKHO8 FSI6TY FSIOTY

;SUBROUTINE CALLED BY CHKHOM TO EXAMINE THE STATE OF A PARTICULAR UNIT.
;CALLED WITH:
;  P1/	CDB
;  P2/	KDB IF ANY
;  P3/	UDB
;RETURNS:  +1 ALWAYS
;USES Q1-Q3

CKHOMU:	MOVE	T1,UDBSTS(P3)	;GET UNIT STATUS
	TXNN	T1,US.DSK	;IS THIS A DISK UNIT?
	RET			;NO, DON'T EXAMINE IT
	CALL	STKACS		;Better not change anything awful...
	MOVE	Q3,PRSNUM	;number of the primary structure
	MOVE	Q3,SDBADR(Q3)	;SDB of primary structure
	MOVE	Q3,ST.MDB(Q3)	;Model DDB for primary S. (For REDHOM, CPYHx)
	MOVE	T3,P3		;COPY UDB FOR CALL
	CALL	FNDCH1		;CALCULATE THE CKU NUMBERS
	MOVEM	T1,Q2		;REMEMBER FOR LATER USE
	MOVE	T2,FSIPPA	;GET PAGE FOR IO
	MOVEI	T3,HM1BLK	;GET HOME BLOCK NUMBER
	MOVEI	T4,HOMPGA	;GET VIRTUAL ADR TO READ INTO
	CALL	REDHOM		;READ IN THE HOME BLOCKS
	 RET			;ERROR OR OFF-LINE
	MOVX	Q1,HB%1OK!HB%2OK;Holds status flags.  Assume good HBs
	MOVEI	T1,HOMPGA	;NOW CHECK THE FIRST HOME BLOCK
	MOVEI	T2,HM1BLK	;...
	CALL	HBCCHK		;CHECK THE CONSISTENCY CHECKS
	 TXZ	Q1,HB%1OK	;HOME BLOCKS BAD
	MOVEI	T1,HOMPGA+HBLEN	;NOW CHECK THE BACKUP HOME BLOCK
	MOVEI	T2,HM2BLK
	CALL	HBCCHK
	 TXZ	Q1,HB%2OK	;BACKUP HOME BLOCK IS BAD
	TXNE	Q1,HB%2OK	;ARE THERE ANY GOOD HOME BLOCKS
	HRRI	Q1,HOMPGA+HBLEN	;YES, GET ADR OF HOME BLOCK
	TXNE	Q1,HB%1OK	;SEE IF PRIMARY IS GOOD
	HRRI	Q1,HOMPGA	;YES, USE IT
	TRNN	Q1,-1		;ANY HOME BLOCKS GOOD?
	RET			;NO, RETURN
	MOVX	T1,US.WLK	;SEE IF THIS UNIT IS WRITE LOCKED
	TDNE	T1,UDBSTS(P3)	;...
	TXO	Q1,HB%WLK	;YES, SET WRITE LOCKED FLAG
	HRRZ	T1,Q1		;GET ADDRESS OF HOME BLOCK
	MOVE	T2,HOMSNM(T1)	;GET STRUCTURE NAME
	SETZ	T4,		;INDICATE NO COPYING REQUIRED
	TXNN	Q1,HB%1OK	;WAS FIRST HOME BLOCK OK?
	MOVEI	T4,CPYH2	;NO. SET UP TO COPY THE SECONDARY
	TXNN	Q1,HB%2OK	;WAS SECOND HOME BLOCK OK?
	MOVEI	T4,CPYH1	;NO. SET UP TO COPY PRIMARY
	JUMPE	T4,CHKHO8	;BOTH OK. DON'T COPY EITHER
	MOVEI	T1,HOMPGA	;T1/VIRTUAL START OF WORK PAGE
	MOVE	T2,FSIPPA	;T2/PHYSICAL START OF WORK PAGE
	MOVE	T3,Q2		;GET CKU NUMBERS
	CALL	@T4		;COPY THE GOOD ONE INTO THE BAD ONE
	 JRST  CHKHO8		;FAILED. LEAVE ERROR BITS SET
	TXO	Q1,HB%1OK!HB%2OK ;OK, CLEAR ERROR BITS
CHKHO8:	MOVE	T1,Q1		;T1/(FLAGS,,ADR OF HOME BLOCK)
	MOVE	T2,P3		;T2/ADDRESS OF UDB FOR THIS UNIT
	CALL	BLDSTR		;Build SDBADR & SDB.  Return SBD addr in T1
	 RET			;RAN OUT OF STR'S
;SDB BUILT AND SDBADR POINTS TO IT.  STORE POINTER TO UDB+FLAGS IN ST.UIL
	MOVE	T2,P3		;GET ADDRESS OF UDB
	HLL	T2,Q1		;SAVE FLAGS FOR THIS UNIT
	HRRZ	T3,HOMLUN(Q1)	;GET LOGICAL UNIT # OF THIS UNIT
	ADDI	T3,ST.UIL(T1)	;GET INDEX INTO SDB FOR THIS UNIT
	SKIPE	0(T3)		;GET CURRENT UDB ADR
	TXO	T2,HB%MUN	;MARK THAT THERE ARE MULTIPLE UNITS
	IORM	T2,0(T3)	;STORE UDB ADR AND FLAGS IN ST.UIL
	RET			;DONE WITH THIS UNIT


FSI6TY:	CALL	STKACS
	MOVE	TAC1,T1
	CALL	DISSIX
	RET

FSIOTY:	CALL	STKACS
	MOVE	TAC,T1
	CALL	DISOCT
	RET
;Support RH file system ;⊗ REDHOM HBCCHK CPYH1 CPYH2 CPYH10 CPYH20 SWPHOM

;ROUTINE TO READ IN THE PRIMARY AND BACKUP HOME BLOCKS
;OR THE PRIMARY AND BACKUP BAT BLOCKS
;ACCEPTS IN T1/ CKU NUMBERS OF DRIVE TO BE READ
;	    T2/	ADDRESS OF PAGE TO READ INTO
;           T3/ LOCAL BLOCK ADDRESS OF PRIMARY BLOCK
;	    T4/	VIRTUAL CORE ADDRESS
;	CALL REDHOM
;RETURNS +1:	DRIVE OFF-LINE
;	 +2:	BOTH BLOCKS READ IN (BUT NOT NECESSARILY WITHOUT ERRORS)
;
;NOTICE:  SINCE AN RP20 HAS SECTORS OF 1000 WORDS, AND WE HAVE READ ONLY
;200 WORDS, A CERTAIN KIND OF OVERRUN IS EXPECTED TO OCCUR BY PHYH2, AND
;THEREFORE IS IGNORED.  IF THE HOME BLOCKS READ BAD OCCASIONALLY, THEN
;THE PROBLEM MIGHT BE THAT THESE IGNORED OVERRUNS ARE "REAL".


REDHOM::STKVAR <REDCKU,REDHOB,REDBLK,REDVIR>
	MOVEM T1,REDCKU		;SAVE CHANNEL, CONTROLLER, AND UNIT NUMBER
	MOVEM T2,REDHOB		;SAVE ADDRESS OF PAGE TO HOLD HOME BLKS
	MOVEM T3,REDBLK		; SAVE LOCAL BLOCK NUMBER
	MOVEM T4,REDVIR		; SAVE VIRTUAL ADDRESS
	SETZM (T4)		; ZERO WHOLE AREA
	HRLI T4,(T4)		; IN BOTH HALFS
	AOS T4
	HRRZ T2,T4		;GET BASE ADDRESS AGAIN
	BLT T4,<HBLEN*2-1>(T2)	; ZAP ENTIRE AREA

	MOVE	T1,REDBLK	;GET UNIT RELATIVE ADR TO BE READ
	TXO	T1,1B0		;It's going to be Absolute
	MOVEM	T1,TFRSEC(Q3)	;Unit relative address
	MOVE	T1,REDCKU	;GET CKU NUMBER
	PUSHJ	P,CKUNPK	;Unpack.  Chan in T1, Unit in T3
	DPB	T1,[Point 3,TFRSEC(DDB),3]	;Store channel number
	DPB	T3,[Point 3,TFRSEC(DDB),6]	;Store unit number
	SETZM	TFRCTL(Q3)	;exec paging; read.
	MOVSI	T1,-HBLEN
	HRR	T1,REDVIR	;Address of location to store HB
	MOVEM	T1,TFRIOW(Q3)	;-WC,,Addr
	CALL	QDSKIO		;READ IN THE HOME BLOCK (Q3=DDB setup)

	MOVE	T4,REDVIR		;RESTORE VIRTUAL ADDRESS
	SKIPE	TFRCTL(Q3)		;WAS THERE AN ERROR?
	SETZM	HOMNAM(T4)		;YES. CLEAR NAME

	MOVE	T1,REDBLK		;GET the DISK ADDRESS
	ADDI	T1,HM2BLK-HM1BLK	;POINT TO BACKUP HOME BLOCKS
	DPB	T1,[POINT 29,TFRSEC(DDB),35]
	MOVSI	T1,-HBLEN		;SET UP LENGTH
	HRR	T1,REDVIR		;GET ADDRESS TO READ INTO
	ADDI	T1,HBLEN		;PUT IT JUST AFTER FIRST HOME BLOCK
	MOVEM	T1,TFRIOW(DDB)
	SETZM	TFRCTL(DDB)
	CALL	QDSKIO			;READ IN HOME BLOCK (Q3=DDB setup)
	MOVE	T4,REDVIR		;GET VIRTUAL ADDRESS
	SKIPE	T1,TFRCTL(DDB)		;DISK ERROR?
	SETZM	<HOMNAM+HBLEN>(T4) 	;YES. ZAP THIS NAME
	TLC	T1,-1			;CHECK FOR DRIVE OFFLINE KIND OF ERROR
	TLCN	T1,-1			;DRIVE OFF-LINE?
	RET				;YES
	RETSKP				;READ IN BOTH OK

;HBCCHK

;ROUTINE TO CHECK THE CONSISTENCY OF THE HOME BLOCKS
;ACCEPTS IN T1/	ADDRESS OF HOME BLOCK
;	    T2/	HOME BLOCK #
;	CALL HBCCHK
;RETURNS +1:	NOT CONSISTENT OR MULTIPLE LOGICAL UNITS
;	 +2:	CONSISTENT, LOGICAL UNIT # IN T1

HBCCHK::MOVS T3,HOMNAM(T1)	;GET SIXBIT /HOM/
	CAIE T3,'HOM'		;IS THIS CORRECT?
	RET			;NO, GIVE ERROR RETURN
	MOVE T3,HOMCOD(T1)	;GET HOME BLOCK CODE
	CAIE T3,CODHOM		;MUST BE "707070"
	RET			;INCONSISTENT
	MOVE T3,HOMSLF(T1)	;GET BLOCK NUMBER OF HOME BLOCK
	CAME T2,T3		;IS IT WHAT IS EXPECTED?
	RETBAD			;NO, NOT A CONSISTENT HOME BLOCK
	MOVE T2,HOMFSN(T1)	;GET FILE SYSTEM TYPE
	CAME T2,[BYTE (2)0(8)" "," "(2)0(8)"A","W"]
	RETBAD			;NOT A WAITS PACK
	MOVE T2,HOMFSN+1(T1)	;GET CHARACTERS 5-8 OF TYPE
	MOVE T3,HOMFSN+2(T1)	;GET CHARACTERS 9-12 OF TYPE
	CAMN T2,[BYTE (2)0(8)"T","I"(2)0(8)" ","S"]
	CAME T3,[BYTE (2)0(8)" "," "(2)0(8)" "," "]
	RETBAD			;NOT A WAITS PACK
	RETSKP			;HOME BLOCK IS OK

;CPYH1, CPYH2
;ROUTINES TO CORRECT ONE INCORRECT HOME BLOCK
;AND WRITE THE CORRECTED BLOCK ON THE DISK
;CALLED FROM MSTR JSYS
;
;ACCEPTS: T1/	FLAGS,,VIRTUAL ADDRESS OF PAGE CONTAINING HOME BLOCKS
;	  T2/	PHYSICAL ADDRESS OF PAGE CONTAINING HOME BLOCKS
;	  T3/	CKU NUMBERS FOR THIS PACK
;  IF A MESSAGE IS REQUESTED, ALSO:
;	  P4/	ST.UIL POINTER FOR THIS UNIT
;	  P5/	STRUCTURE NUMBER
;		CALL CPYH1/CPYH2
;RETURNS: +1	 ERROR WRITING THE HOME BLOCK
;	  +2	SUCCESS, GOOD HOME BLOCK COPIED OVER BAD ONE



CPYH1::	TDZA T4,T4		;INDICATE COPYING PRIMARY TO SECONDARY
CPYH2::	SETOM T4		;INDICATE COPYING SECONDARY TO PRIMARY
	ASUBR <CPHVIR,CPHPHY,CPHCKU> ;STORE INPUT ARGUMENTS
	STKVAR	<CPHDIR,CPHLOC>	;ALLOCATE SPACE FOR DIRECTION OF TRANSFER FLAG
	MOVEM	T4,CPHDIR	;SAVE DIRECTION OF TRANSFER
	HRRZ	T3,CPHVIR	;POINT TO START OF HOME BLOCK 1
	HRROI	T1,[ASCIZ/% Copying primary HOME block to secondary on /]
	SKIPE	CPHDIR		;REALLY COPYING SECONDARY TO PRIMARY ?
	JRST	[HRROI T1,[ASCIZ/% Copying secondary HOME block to primary on /]
		ADDI T3,HBLEN	;POINT TO START OF HOME BLOCK 2
		JRST .+1]
	MOVEM T3,CPHLOC		;SAVE ADDRESS OF GOOD HOME BLOCK
IFWAITS<
	CALL DISGST		;print time on CTY
>;IFWAITS
	CALL FSIPSO		;OUTPUT INITIAL PART OF MESSAGE
	MOVE T3,CPHLOC		;POINT TO CORRECT HOME BLOCK
	MOVE T1,HOMSNM(T3)	;GET NAME OF STRUCTURE
	CALL FSI6TY		;PRINT NAME OF STRUCTURE
	HRROI T1,[ASCIZ/ unit /]
	CALL FSIPSO		;PRINT 'UNIT'
	MOVE T3,CPHLOC
	HRRZ T1,HOMLUN(T3)	;GET UNIT NUMBER
	CALL FSIOTY		;PRINT THE UNIT NUMBER
	HRROI T1,[ASCIZ/
/]
	CALL FSIPSO
				;...
; HERE TO DO THE ACTUAL COPY

CPYH10:	HRRZ T1,CPHVIR		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	MOVE T3,[HM2BLK,,HM1BLK] ;GET BLOCK NUMBERS OF OTHER,,THIS HOME BLOCK
	MOVEI T4,(T1)		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	HRLI T1,HBLEN(T1)	;GET SOURCE ADDRESS FOR COPY
	SKIPE CPHDIR		;COPYING SECONDARY TO PRIMARY ?
	JRST CPYH20		;YES, GO SET UP TERMINATING ADDRESS
	HRLI T1,(T4)		;NO, GET SOURCE ADDRESS
	HRRI T1,HBLEN(T4)	;GET DESTINATION ADDRESS
	MOVS T3,T3		;SWAP THIS,,OTHER HOME BLOCK NUMBERS
	ADDI T4,HBLEN		;POINT TO SECOND HOME BLOCK
CPYH20:	MOVEI T2,(T1)		;GET BASE FOR TERMINATING ADDRESS
	BLT T1,HBLEN-1(T2)	;COPY GOOD HOME BLOCK
	MOVSM T3,HOMHOM(T4)	;SAVE THIS,,OTHER BLOCK NUMBERS
	HRRZM T3,HOMSLF(T4)	;SAVE THIS BLOCK NUMBER


; NOW WRITE OUT THE CORRECTED HOME BLOCK

	HRRZ T1,CPHVIR		;GET VIRTUAL ADDRESS OF HOME BLOCKS
	SKIPN CPHDIR		;WRITING OUT FIRST HOME BLOCK?
	CALL SWPHOM		;NO, SWAP THEM SO PAGE STARTS WITH SECOND ONE
	HRRZ T1,T3		;GET SECTOR NUMBER
	TXO	T1,1B0
	MOVEM	T1,TFRSEC(DDB)	;Part of physical Address
	MOVE	T1,CPHCKU
	CALL	CKUNPK
	DPB	T1,[POINT 3,TFRSEC(DDB),3]	;Channel
	DPB	T3,[POINT 3,TFRSEC(DDB),6]	;Unit
	MOVSI	T2,-HBLEN
	HRR	T2,CPHVIR
	MOVEM	T2,TFRIOW(DDB)
	MOVSI	T1,DWRITE
	MOVEM	T1,TFRCTL(DDB)
	CALL	QDSKIO		;WRITE THE CORRECTED HOME BLOCK (Q3=DDB setup)
	MOVE	T4,TFRCTL(DDB)	;SAVE RESULT
	HRRZ	T1,CPHVIR	;GET BACK VIRTUAL ADDRESS OF HOME BLOCKS
	SKIPN	CPHDIR		;DID WE SWAP THEM?
	CALL	SWPHOM		;YES, SWAP THEM BACK
	JUMPN	T4,R		;IF ERROR, RETURN FAILURE
	RETSKP			;RETURN SUCCESS


;ROUTINE TO SWAP THE HOME OR BAT BLOCKS IN A PAGE.  NECESSARY BECAUSE
;THE DISK WRITE HAS TO BEGIN AT THE FIRST WORD OF A PAGE FOR RP20'S.
;CALL:
;  T1/	VIRTUAL ADDRESS OF THE PAGE HOLDING THE HOME OR BAT BLOCKS
;RETURNS:
;  +1:	ALWAYS, WITH THE TWO HOME OR BAT BLOCKS SWAPPED.
;THIS ROUTINE TRASHES THE REMAINDER OF THE PAGE AFTER THE TWO BLOCKS.

SWPHOM:	MOVSI T2,0(T1)		;COPY FROM FIRST BLOCK
	IORI T2,HBLEN*2(T1)	;TO SECOND HALF OF PAGE
	BLT T2,HBLEN*3-1(T1)	;SAVE FIRST HOME BLOCK AWAY
	MOVSI T2,HBLEN(T1)	;NOW POINT AT SECOND HOME BLOCK
	IORI T2,0(T1)		;AND TOP OF PAGE
	BLT T2,HBLEN-1(T1)	;COPY SECOND HOME BLOCK UP ONTO FIRST ONE
	MOVSI T2,HBLEN*2(T1)	;NOW WANT TO COPY BACK FIRST HOME BLOCK
	IORI T2,HBLEN(T1)	;ON TOP OF OLD SECOND HOME BLOCK
	BLT T2,HBLEN*2-1(T1)	;DO IT
	RET			;DONE

;BLDSTR - ROUTINE TO SET UP SDB'S AND SDBADR ;⊗ BLDSTR BLDST1 BLDST2 BLDST3 CRTSTR ADDSTR ADDST0 ADDST5 FNDCHN FNDCH1 GETTYP

;ACCEPTS:
;	T1/VIRTUAL ADDRESS OF WORK PAGE HOLDING HOME BLOCK
;	T2/ADDRESS OF UDB FOR THIS UNIT

;	CALL BLDSTR

;RETURNS +1: NO MORE ROOM IN SDBADR
;		T1/ADDRESS OF SDB
;	 +2: SUCCESS,
;		T1/ ADDRESS OF SDB

;THIS ROUTINE IS CALLED BY FSIINI, ONCE FOR EACH PHYSICAL UNIT
;IF AN SDB ENTRY EXISTS FOR A STRUCTURE WITH THE NAME IN THE HOME
;BLOCKS, IT ADDS THIS UNIT TO THAT STRUCTURE. IF NOT, IT CREATES
;A NEW SDB.  IF ERRORS ARE DETECTED, FLAGS ARE SET IN ST.UIL (IF THE
;ERROR APPLIES TO A SINGLE UNIT) OR ST.STS (IF IT APPLIES TO THE
;STRUCTURE).  ERRORS ARE NOT INDICATED BY A +1 RETURN.

BLDSTR::STKVAR <UDBLOC>
	MOVEM	T2,UDBLOC	;SAVE ADDRESS OF UDB
	MOVE	T2,HOMSNM(T1)	;GET THE STR NAME
	MOVSI	T4,-STRMAX	;SET UP TO SEARCH FOR THIS STR NAME
BLDST1:	SKIPN	T3,SDBADR(T4)	;IS THIS STR DEFINED?
	JRST	BLDST2		;No. Hence, a new one is needed
	CAMN	T2,SDBNAM(T3)	;IS THIS THE STRUCTURE WE WANT?
	JRST	BLDST3		;Yes.
	AOBJN	T4,BLDST1	;NO, LOOP THROUGH ALL STR'S
	RETBAD			;NO MORE SLOTS AVAILABLE

BLDST2:	CALL	CRTSTR		;create SDB & DDB
	MOVE	T3,SDBADR(T4)	;Pickup the SDB address
BLDST3:	MOVE	Q3,ST.MDB(T3)	;Get the right DDB too
	MOVE	T2,UDBLOC	;YES, GET ADDRESS OF UDB
	CALL	ADDSTR		;ADD THE UNIT TO THE STRUCTURE
	 MOVE T1,T3		;FAILED, GET ADDRESS OF SDB
	RETSKP			;UNIT ADDED, TAKE SUCCESS RETURN

;Create a prototype SDB and DDB for new structure.
CRTSTR:	CALL	STKACS
	PUSH	P,T2		;structure name
	HRRZ	TAC,T4		;Structure number
	POP	P,TAC1		;Structure name
	CALLRET	MAKSTR		;back to DSKSER to make SDB & DDB

;ADDSTR - ADD A UNIT TO AN EXISTING SDB

;ACCEPTS:
;	T1/ VIRTUAL ADDRESS OF START OF HOME BLOCKS
;	T2/ ADDRESS OF UDB FOR THIS UNIT
;	T3/ ADDRESS OF SDB FOR THIS STRUCTURE

;	CALL ADDSTR

;RETURNS +1: PACK DOESN'T AGREE WITH REST OF STRUCTURE
;		T1/ERROR CODE
;		T3/ ADDRESS OF SDB
;	 +2: PACK ADDED TO STRUCTURE
;		T1/ ADDRESS OF SDB

ADDSTR:	MOVE	T4,T2		;Copy UDB address to T4
	MOVE	T2,HOMSNM(T1)	;GET STR NAME
	MOVEM	T2,UDBVID(T4)	;STORE STR NAME AS VOLUME ID IN UDB
	SKIPE	ST.UIS(T3)	;is this the first time here?
	JRST	ADDST0		;No.
	HLRZ	T2,HOMLUN(T1)	;GET NPACKS
	MOVEM	T2,ST.UIS(T3)	;STORE NUMBER OF UNITS IN SDB
	MOVE	T2,HOMRXB(T1)	;ROOT INDEX ADR
	MOVEM	T2,ST.MFA(T3)	;Store as address of the MFD
	MOVE	T2,HOMMID(T1)	;GET MEDIA ID
	MOVEM	T2,SDBPUC(T3)	;Save for test against ID of other packs
	CALL	GETTYP		;GET DISK SIZE POINTER
	 JSP	TAC,FILINE	;"Not a known disk"
	MOVEM	T4,SDBTYP(T3)	;SAVE IT IN THE SDB
	MOVE	T2,SECUNT(T4)	;number of sectors per unit
	IMUL	T2,ST.UIS(T3)
	MOVEM	T2,ST.LAD(T3)	;number of sectors per structure
	MOVEM	T2,ST.LSA(T3)	;number of sectors per structure

	MOVE	T2,SECCYL(T4)	;number of sectors per cylinder
	PUSH	P,T3
	MOVE	T3,UNIRPB(T4)	;number of data records per block
	ADDI	T3,1		;size of block including rtvl
	IDIV	T2,T3		;number of blocks per cylinder
	POP	P,T3		;restore SDB address
	IMUL	T2,CYLUNT(T4)	;form number of blocks per unit
	IMUL	T2,ST.UIS(T3)	;number of blocks in structure
	MOVEM	T2,ST.BTB(T3)	;number of blocks in structure (# bits in SAT)

	MOVE	T2,UNIRPB(T4)	;Number of data records per block.
	MOVEM	T2,ST.RPB(T3)	;Save in SDB
	MOVEM	T2,DD.RPB(DDB)	;.....(DDB=Q3)
	ADDI	T2,1		;Number of allocated Records per B (incl rtvl)
	MOVEM	T2,ST.BPC(T3)	;this is a divisor for later
	MOVE	T2,SECCYL(T4)
	MOVEM	T2,ST.RPC(T3)	;Records per cylinder
	IDIVM	T2,ST.BPC(T3)	;Blk per Cyl := rpc/(allocated Rec per Blk)
	MOVE	T2,UNIRTS(T4)
	MOVEM	T2,ST.RTS(T3)	;size of rtvl record into SDB
	MOVEM	T2,DD.SSZ(DDB)	;size of retrieval record = record size
	CAME	T2,UNIRTL(T4)
	 JSP	TAC,FILINE
	MOVEM	T2,DD.RTL(DDB)	;number of words occupied in rtvl record
	IMUL	T2,SECPAG(T4)	;sector size * number of sectors/page
	CAIE	T2,PGSIZ	;must equal page size
	 JSP	TAC,FILINE	;confusion!
	MOVE	T2,UNIBPG(T4)	;Number of Blocks Per Group in this device
	MOVEM	T2,DD.BPG(DDB)
	IMUL	T2,DD.RPB(DDB)
	MOVEM	T2,DD.RPG(DDB)	;Records per group in this device
	MOVE	T2,HOMP4S(T1)	;NUMBER PAGES FOR SWAPPING PER UNIT
	IMUL	T2,SECPAG(T4)	;CONVERT TO SECTORS
	MOVEM	T2,SDBNSS(T3)	;SAVE IN SDB
	MOVE	T2,HOMFST(T1)	;FIRST SWAPPING TRACK
	IMUL	T2,SECCYL(T4)	;CONVERT TO SECTOR NUMBER
	MOVEM	T2,SDBFSS(T3)	;SAVE IN SDB
	MOVE	T2,CYLUNT(T4)	;GET NUMBER OF CYLINDERS PER UNIT
	IMUL	T2,SECCYL(T4)	;CONVERT TO SECTORS
	MOVEM	T2,SDBSIZ(T3)	;SAVE IN SDB
	MOVE	T2,HOMSTA(T1)
	MOVEM	T2,ST.STA(T3)	;Store disk address of the SAT
	MOVE	T2,HOMSTC(T1)	;count of records in SAT
	IMUL	T2,DD.SSZ(DDB)	;times the record size
	MOVEM	T2,ST.SSZ(T3)	;Save size (in words) of the SAT
	MOVE	T1,T3		;RETURN WITH ADR OF SDB IN T1
	RETSKP

;addition of unit to existing structure
ADDST0:	HLRZ	T2,HOMLUN(T1)	;GET NUMBER OF PACKS IN STR
	CAME	T2,ST.UIS(T3)	;SAME AS PREVIOUS HOME BLOCK?
	JRST	ADDST5		;NO, MISMATCH
	MOVE	T2,HOMRXB(T1)	;GET ADR OF ROOT IB
	CAME	T2,ST.MFA(T3)	;CHECK FOR MATCHING ADR'S
	JRST	ADDST5		;NO MATCH
	MOVE	T2,HOMMID(T1)	;GET MEDIA ID
	CAME	T2,SDBPUC(T3)	;SAME AS ID OF OTHER PACKS ?
	JRST	ADDST5		;NO, FAIL
	CALL	GETTYP		;GET DISK SIZE POINTER
	 JRST	ADDST5		;INDICATE 'PACKS MUST BE OF SAME TYPE'
	CAME	T4,ST.TYP(T3)	;IS THE NEW DISK THE SAME SIZE
	JRST	ADDST5		;NO. NO MATCH
	MOVE	T2,HOMP4S(T1)	;NUMBER PAGES FOR SWAPPING PER UNIT
	IMUL	T2,SECPAG(T4)	;CONVERT TO SECTORS
	CAME	T2,SDBNSS(T3)	;Same as in SDB?
	JRST	ADDST5
	MOVE	T2,HOMFST(T1)	;FIRST SWAPPING TRACK
	IMUL	T2,SECCYL(T4)	;CONVERT TO SECTOR NUMBER
	CAME	T2,SDBFSS(T3)	;Same as in SDB?
	JRST	ADDST5
	MOVE	T2,HOMSTA(T1)
	CAME	T2,ST.STA(T3)	;Agree on the disk address of the SAT?
	JRST	ADDST5
	PUSH	P,SECPAG(T4)	;Get the number of sectors per page
	MOVE	T2,HOMSTC(T1)	;count of records in SAT
	LSH	T2,PGSFT	;shift as if each record is one page
	IDIVM	T2,(P)
	POP	P,T2
	CAME	T2,ST.SSZ(T3)	;Same SAT size as we had before?
	JRST	ADDST5
	MOVE	T1,T3		;RETURN WITH ADR OF SDB IN T1
	RETSKP

ADDST5:	MOVX T2,HB%HBM		;MARK THAT THE HOME BLOCKS MISMATCH
	IORM T2,ST.STS(T3)
	RETBAD 			;INDICATE 'PACKS MUST BE OF SAME TYPE'

;FNDCHN

;ROUTINE TO FIND THE CKU NUMBERS FOR A PACK (THE CHANNEL, CONTROLLER,
;AND UNIT NUMBERS OF THE PACK).
;ACCEPTS:	P4/ ST.UIL INDEX   (FOR CALL TO FNDCHN)
;OR:		T3/ UDB   (FOR CALL TO FNDCH1)
;RETURNS:	T1/ CKU NUMBERS
;DESTROYS T2-T4

FNDCHN:	HRRZ	T3,0(P4)	;GET UDB
FNDCH1::SAVEP			;PROTECT SOME ACS
	HRRZ	P1,UDBCDB(T3)	;SET UP POINTERS
	HRRZ	P2,UDBKDB(T3)	;AS THEY NORMALLY ARE
	MOVE	P3,T3		;FOR CALL
	CALL	FNDCKU		;GET THE PROPER NUMBERS
	CALLRET	CKUPAK		;PACK THEM INTO ONE AC AND RETURN

;GETTYP - GET TYPE OF DISK

;ACCEPTS:
;	T1/ ADDRESS OF HOME BLOCK
;	T3/ ADDRESS OF SDB
;	T4/ ADDRESS OF UDB FOR THIS UNIT

;	CALL GETTYP

;RETURNS +1: UNKNOWN DISK TYPE
;	 +2: VALID DISK TYPE,
;		T2/ OFFSET INTO DSKUTP FOR THIS DISK TYPE
;		T4/ ADDRESS OF DISK SIZE TABLE

;PRESERVES T1 AND T3

GETTYP:	LOAD	T4,USTYP,(T4)	;GET TYPE OF UNIT
	MOVSI	T2,-NDSKUT	;T2/(-COUNT OF TABLE,,CURRENT OFFSET)
	CAME	T4,DSKUTP(T2)	;IS THIS A DISK?
	AOBJN	T2,.-1		;NO. KEEP LOOKING
	JUMPGE	T2,[HRRZ T2,HOMLUN(T1)
		ADDI T2,ST.UIL(T3)
		MOVX T4,MS%TYP
		IORM T4,0(T2)
		RETBAD]
	MOVE	T4,DSKSIZ(T2)	;YES. GET ADDRESS OF SIZE DATA FOR THIS TYPE
	RETSKP
;⊗ RHACCW RHABAD RHACC0 RHACC1 RHAC1A RHAC1B WHISIO WHISI0 WHISI1 TIM RHIODN RHIOD1 RHIORT

;RHACCW:  Add a transfer to a CCW list.  
;
;Call with	DDB/	Setup
;		DD.CCP(DDB)	Aobjn pointer to next space for a CCW
;		TFRIOW(DDB)	-WC,,MA of transfer
;		TFRSEC(DDB)	Absolute disk address, including bits 1:3 = channel
;		DD.MAP(DDB)	Exec virt addr of page map of transfer,
;				   with 1B0 set for disk read = core write
;				If DD.MAP is zero, RH of TFRIOW must be zero too,
;					signifying a data skip operation.
;	Normally Skips
;	If non-skip, returns an error PC in TAC

RHACCW::CALL	STKACS
	LDB	P1,[POINT 3,TFRSEC(DDB),3]	;Channel number
	SKIPN	P1,CHNTAB(P1)			;CDB for the channel
	JSP	TAC,RHABAD			;Error.  No CDB
	CALL	RHACC0
	 JRST	RHABAD
	RETSKP

RHABAD:	MOVEM	TAC,..TAC
	RET

RHACC0:	STKVAR	<IOLADR,IOLSIZ,IOLWC>	;Allocate local storage
	HRRZ	T2,TFRIOW(DDB)		;User address
	MOVEM	T2,IOLADR		;Save
	HLRO	T3,TFRIOW(DDB)
	MOVNM	T3,IOLSIZ
RHACC1:	SKIPG	IOLSIZ			;Anything left to do?
	RETSKP				;no.  We're done!
	SKIPL	DD.CCP(DDB)
	JSP	TAC,R			;Ran out of room for CCWs
	MOVE	T1,IOLADR
	ANDI	T1,PGSIZ-1		;Compute word within page
	SUBI	T1,PGSIZ		;-number of words to end of this pg
	MOVN	T1,T1			;+number of words to end of this pg
	CAMLE	T1,IOLSIZ		;Compare words on page to xfer size
	MOVE	T1,IOLSIZ		;Transfer fits on page.
	MOVEM	T1,IOLWC		;Save WC of this CCW
	ADDM	T1,DD.IRB+IRBCNT(DDB)	;Increment WC in IORB
	MOVN	T1,T1
	ADDM	T1,IOLSIZ		;WC remaining after this CCW
	MOVE	T1,IOLADR
	HRRZ	T2,DD.MAP(DDB)		;Get the EVA of the page map
	JUMPE	T2,RHAC1A		;Special test if map address is zero
	CALL	PHYPAG			;return map word in T1
	TLNN	T1,P.WRT		;Skip if write access to page is permitted
	SKIPL	DD.MAP(DDB)		;Write Prot.  Skip if a device read will write mem
	CAIA
	JSP	TAC,R		;Memory WRITE violation from device read op
	TLNN	T1,PREAD	;Skip if read access to mem is permitted.
	SKIPGE	DD.MAP(DDB)	;NO READ.  Skip if a device write will READ MEM
	CAIA
	JSP	TAC,R		;no memory READ ACCESS on device write
	ANDI	T1,17777	;reduce T1 to physical page number only
	LSH	T1,PGSFT	;Shift to physical address
	JRST	RHAC1B

RHAC1A:	SKIPE	T1,IOLADR	;Map is zero.  Address must be zero too.  Data Skip
	JSP	TAC,R		;No.  Lose.
RHAC1B:	MOVE	T2,IOLADR
	ANDI	T2,PGSIZ-1
	IOR	T2,T1		;Physical address of transfer
	MOVE	T1,IOLWC
	ADDM	T1,IOLADR	;Address after this transfer
	HRLI	T1,IRMWRD	;WANT WORD MODE
	HRRZ	T3,CDBDSP(P1)	;GET CHANNEL DISPATCH ADDRESS
	HRRZ	T3,CDSCCW(T3)	;AND THEN CCW ROUTINE
	CALL	(T3)		;TRANSLATE ADDRESS AND COUNT INTO CCW VALUE
	MOVE	T2,DD.CCP(DDB)	;GET BACK AOBJN WORD
	MOVEM	T1,(T2)		;STORE CCW WORD BACK INTO THE LIST
	ADD	T2,[1,,1]
	MOVEM	T2,DD.CCP(DDB)
	JRST	RHACC1

;WAITS Start IO
WHISIO::CONSZ	PI,1B<28+PHYCHN>	;Skip if PI level is off
	CONSZ	PI,1B<20+PHYCHN>	;Skip unless PI level in progress
	JRST	WHISI1
	CALL	WHISI0			;PI6 ON and NOT PI6 in progress
	JRST	FDDTCALL

WHISI0:	CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/Fatal: Bad PI context at WHISIO
/
	JRST	DISFLU

WHISI1:	LDB	T1,[POINT 3,TFRSEC(DDB),3]
	MOVNI	T2,1
	LDB	T3,[POINT 3,TFRSEC(DDB),6]
	CALL	CHKCKU
	JSP	TAC,RHGERR
	MOVE	T2,T1			;Copy UDB Address to T2
	MOVEI	T1,DD.IRB(DDB)		;And the IORB address to T1
	MOVEI	T3,RHIODN
	MOVEM	T3,IRBIVA(T1)		;Store interrupt vector for IO done

	AOS	T3,RHDDBQ
	CAIL	T3,RHDQTX
	MOVEI	T3,RHDQTB
	MOVEM	T3,RHDDBQ
	HRRZM	DDB,(T3)

TIM==20
	DATAI	TIM,DSKQTM(DDB)		;GET CURRENT TIME
	MOVE	T3,IRBCNT(T1)
	MOVEM	T3,DSKQWC(DDB)

	AOS	DQCNT##			;Count entry to queue
	CALL	PHYSIO
	RET	


;Here from PHYSIO, PI in progress in DSKCHN.
;T1 contains the IORB address. Transfer has been finished.
RHIODN:	PUSHJ	P,STKACS	;Save the PHYSIO ACs
	MOVEM	P,IRTNP		;save the PHYSIO P.
	MOVEI	DDB,RHIORT	;Save the address of the return to PHYSIO
	MOVEM	DDB,INTRTN	;In the conventional place for DSKSER
	HRRZ	DDB,IRBDDB(T1)	;Get the DDB
	MOVEI	IOS,0
	MOVE	T2,IRBSTS(T1)
	TXNE	T2,IS.ERR		;Any error in transfer?
	MOVEI	IOS,IODERR!IODTER	;Yes. Set error bits in DEVIOS
	IORM	IOS,DEVIOS(DDB)
	SOS	DQCNT
	AOS	T3,RHDDBQ	;copy removal to activity Q
	CAIL	T3,RHDQTX
	MOVEI	T3,RHDQTB
	MOVEM	T3,RHDDBQ
	TLO	DDB,200000	;put a mark for removed from Q
	MOVEM	DDB,(T3)

Extern DSKQTM,DMXQTM,DSKQWC,DMXQWC

	DATAI	TIM,TAC
	DSUB	TAC,DSKQTM(DDB)			;GET DIFFERENCE IN TIME
	DMOVEM	TAC,DSKQTM(DDB)
	DSUB	TAC,DMXQTM
	JUMPL	TAC,RHIOD1
	DMOVE	TAC,DSKQTM(DDB)
	DMOVEM	TAC,DMXQTM
	MOVE	TAC,DSKQWC(DDB)
	MOVE	TAC1,TFRCTL(DDB)
	TLNE	TAC1,DWRITE
	TLO	TAC,400000			;mark write xfr
	MOVEM	TAC,DMXQWC

RHIOD1:	MOVSI	17,C1ACS(DDB)
	BLT	17,17		;RESTORE ACS TO STATE AT TIME OF CALL TO TGO
	MOVE	IOS,DEVIOS(DDB)	;GET CURRENT STATUS
	RET			;AND RETURN (LOOKS LIKE RETURN FROM TGO)

RHIORT:	MOVE	P,IRTNP		;restore PHYSIO's stack pointer
	RET			;Return, via STKACS, to PHYSIO


;For MTCSER ;⊗ DDNTBL MODCAP MTMTGO MT78GO MT78G2 MTIOSS MTIOS1 MTIOS2

EXTERN	MTUDMD, MTUIRB, MT78ER, IOLOCK, IOLCCW, MTCUTB
EXTERN	DEVIOS, DR, IO, IOBKTL, IOBOT, IODERR, IODTER, IOSEOF, IONRCK
EXTERN	IOIMPM, IOTEND, MTUCFS, MTUIRB, MTUOC, PUNIT

;Table to map from two bits in DEVIOS in WAITS to PHYSIO density indices.
DDNTBL:	.SJD16		;0 - 1600 BPI (556 BPI on 545 drives)
	.SJD16		;1 - 1600 BPI (200 BPI on 545 drives)
	.SJD16		;2 - 1600 BPI (556 BPI on 545 drives)
	.SJD62		;3 - 6250 BPI (800 BPI on 545 drives)

;Table to map from data mode number (minus 1) to UDBCHR bit that is on
;if drive has that mode.  Used in MTCSER.
MODCAP::UC.CD		;1 - CORE DUMP MODE
	UC.6B		;2 - SIXBIT MODE
	UC.AA		;3 - ANSI ASCII MODE
	UC.IC		;4 - INDUSTRY COMPATIBLE MODE
	UC.HD		;5 - HI-DENSITY MODE

;Here from MTCSER to finish setting up the IORB before calling PHYSIO.
MTMTGO::PUSH P,UCHN		;preserve some ACs for UUOCON
	PUSH P,DSER
	PUSH P,DDB		;ensure this is not clobbered in PHYSIO
	PUSH P,TAC		;save IOWD
	PUSH P,AC1		;save EVA of map (if data transfer function)
IFE T1-IOS,<.FATAL IOS is clobbered here because it is also T1>
IFE T2-IOS,<.FATAL IOS is clobbered here because it is also T2>
IFE T3-IOS,<.FATAL IOS is clobbered here because it is also T3>
IFE T4-IOS,<.FATAL IOS is clobbered here because it is also T4>
IFE P4-IOS,<.FATAL IOS is clobbered here because it is also P4>
	HRLZ T1,AC2		;get PHYSIO function in LH T1
	TRNE IOS,IONRCK		;user requesting no re-reading?
	TXO T1,IS.IER		;yes, inhibit error recovery
	MOVEI P4,MTUIRB(DDB)	;make pointer to IORB which is within magtape DDB
	MOVEM T1,IRBSTS(P4)	;put function into IORB, clear status bits
	HRRZ T2,MTUDMD(DDB)	;get current mode (core dump, indust compat, hi dens)
	SKIPN T2		;see if any specified
	MOVEI T2,.SJDMC		;none, use core dump as default mode
	LDB T3,[POINT 2,IOS,28]	;density
	MOVE T3,DDNTBL(T3)	;get density parameter that PHYSIO wants
	LDB T4,[POINT 1,IOS,26]	;parity -- bit on means even parity (nonstandard)
	STOR T2,IRBDM,(P4)	;put data mode into IORB
	STOR T3,IRBDN,(P4)	;put density into IORB
	STOR T4,IRBPAR,(P4)	;put parity into IORB
	MOVEI T4,0
	STOR T4,IRBPRI,(P4)	;store zero in priority field
	POP P,T3		;restore EVA of map
	MOVEI T3,(T3)		;assume device write (LH 0),,EVA in T3
	TLNN IOS,IO		;skip if device write
	TLO T3,400000		;set sign bit to indicate device read
	POP P,T1		;IOWD (push'd from TAC)
	HLRE T2,T1		;-size of buffer
	MOVEI T1,1(T1)		;User buffer address
	MOVN T2,T2		;+size of buffer = size of transfer (record)
;now we have the args set up for IOLOCK
	PUSHJ P,MT78GO		;Go to PHYSIO to read the tape record
	 PUSHJ P,MT78ER		;transfer too long or system error
	POP P,DDB
	MOVE IOS,DEVIOS(DDB)	;get latest version of status bits
	POP P,DSER		;restore UUOCON's ACs
	POP P,UCHN
	POPJ P,			;return to MTCSER and UUOCON

;Here with T1,T2,T3 all set for call to IOLOCK, 
;DDB = Q3 pointing to magtape DDB.
;Skips unless IOLOCK fails (transfer too long or sys error).
;Note: some error(s) may have occurred even if it skips.
MT78GO:	ASUBR <MBFADR,MBFSIZ,MAPADR,XXUNUSED> ;save T1-T4 with these names
	MOVEM T2,MTUIRB+IRBCNT(Q3) ;store data count in IORB
	JUMPE T2,MT78G2		;jump if not a data transfer (size is zero)
	MOVEM T2,MTUOC(Q3)	;save original count in DDB
	CALL IOLOCK		;create the Page List.  return in T1.
	 RET			;some error (maybe transfer too long)
	HRRZM T1,MTUCFS(Q3)	;store address of Page list in DDB
				;(IOLCCW will convert this to CCW list)
	LDB T2,PUNIT		;get WAITS unit nbr from DDB
	HLRZ P1,MTCUTB(T2)	;get the CDB address for IOLCCW
	MOVE T2,MBFADR		;get user address for transfer
	MOVE T3,MBFSIZ		;get size of transfer
	CALL IOLCCW		;convert T1 to CCW list
	HLRE T1,@MTUCFS(Q3)	;get CCW list length, negated
	MOVN T1,T1		;positive CCW length
	HRRZ T2,@MTUCFS(Q3)	;get ptr to CCW list
	ADD T1,T2		;calcuate end adr of CCW list (ending Channel addr)
	HRL T2,T1		;make it tail,,head of CCW list
	MOVEM T2,MTUIRB+IRBXFL(Q3) ;store in IORB (within DDB)
MT78G2:	MOVEI T1,MTUIRB(Q3)	;make pointer to IORB which is within magtape DDB
	LDB T2,PUNIT		;get WAITS unit nbr from DDB
	HRRZ T2,MTCUTB(T2)	;get UDB from table
	CALL PHYSIO		;START THE IO, takes T1/IORB and T2/UDB.
	RETSKP			;successfully queued

;Routine to set up the status word (DEVIOS) from IORB status when op done.
;Call with DDB in Q3, IORB in P4.  Sets/clears bits in DEVIOS(DDB).
MTIOSS::MOVE T1,IRBSTS(P4)	;GET STATUS BITS
	MOVE T2,[IOSEOF,,IOTEND!IOBOT] ;SET UP TO TEST CONDITIONS
	ANDCAM T2,DEVIOS(Q3)	;CLEAR THESE BITS FIRST.  Keep them in T2
	TLNE T2,IO		;doing output?
	TXNN T1,IS.WLK		;yes, write locked (this only on if write attempted)
	CAIA			;all OK
	TRO T2,IOIMPM		;write locked during output, flag an error
	TXNN T1,IS.TPM		;EOF SET?
	TLZ T2,IOSEOF		;NO
	TXNN T1,IS.EOT		;AT END OF TAPE?
	TRZA T2,IOTEND		;NO
	TRO T2,IOIMPM		;yes--leave IOTEND on in T2, set error bit too
	TXNN T1,IS.BOT		;OR AT BEGINING OF TAPE
	TRZ T2,IOBOT		;NO
	TXNE T1,IS.DTE		;DATA ERROR?
	TRO T2,IODTER		;YES
	TXNE T1,IS.DVE		;DEVICE (HARDWARE) ERROR?
	TRO T2,IODERR		;YES
	TXNE T1,IS.RTL		;RECORD TOO LONG?
	TRO T2,IOBKTL		;YES
	IORB T2,DEVIOS(Q3)	;SET BITS IN STATUS WORD
repeat 0,<	;even dump mode is allowed to read a short record in big IOWD
	LOAD T3,ISFCN,(P4)	;GET THE FUNCTION
	CAIN T3,IRFRDR		;READ BACKWARDS?
	JRST MTIOS1		;YES, CHECK RECORD LENGTH
	CAIE T3,IRFRED		;READ?
	CAIN T3,IRFWRT		;OR WRITE?
MTIOS1:	SKIPA T3,IRBCNT(P4)	;YES, CHECK RECORD LENGTH
	JRST MTIOS2		;NO, DONT SET IOBKTL
	SUB T3,MTUOC-MTUIRB(P4) ;SUBTRACT ORIGINAL COUNT
	ANDI T2,17		;leave just the mode bits
	CAIL T2,DR		;DUMP MODE?
	SKIPN T3		;YES, MUST BE 0 ELSE ERROR
	JRST MTIOS2		;NO RECORD LENGTH ERROR
	MOVEI T2,IOBKTL		;SET UP FOR RECORD LENGTH ERROR
	TXNN T1,IS.TPM		;SAW A TAPE MARK THIS TIME?
	IORB T2,DEVIOS(Q3)	;NO, SET IOBKTL IN MTASTS
MTIOS2:
>;repeat 0
	RET			;ALL DONE

;Mapping routines ;⊗ MASBGX MRKMPG MULKCR PSIRQ NOSK11 OKSK11 PHYPAG PHYPG1 MAPRCA UNMRCA MOVRCA STORCA APRRPT ASGRES RELRES MEMSCN

MASBGX==:0
			;WAITS takes care of these three functions for us???
MRKMPG::		  ;mark page as modified: an IO read op wrote on it
MULKCR::		  ;unlock page after IO done
PSIRQ:: RET	 	;PSI requ. for online/offline transitions

NOSK11::		;NOSKED
OKSK11::JRST (CX)	;OKSKED


;;return the physical page number for the virtual ADDRESS given in T1,
;;using the map whose exec virtual address is given in right half of T2.
PHYPAG::LSH	T1,-PGSFT
	CAIL	T1,1000
	JRST	PHYPG1
	ADDI	T1,(T2)
	MOVE	T1,(T1)
	RET

PHYPG1:	CALL	STKACS
	CALL	DISUSR
	'PHYPG1'
	CALL	DISMES
	ASCIZ	/Illegal virtual page number at PHYPAG
T1 = /
	MOVE	TAC,..T1
	CALL	DISOCT
	CALL	DISCRLF
	CALL	DISFLU
	JRST	FDDTCALL

;;Map a physical page into exec space.   Assumes PI's off!
;;	T1/	physical page number
;;	CALL	MAPRCA
;;	return here always, T1 contains the exec virtual address of page
MAPRCA::CALL	STKACS
	MOVE	TAC,..T1
	MOVEI	TAC1,PHYEXP
	CALL	ADDEMP
	MOVEI	TAC,PHYEXP
	LSH	TAC,PGSFT
	MOVEM	TAC,..T1
	RET

;;UnMap a physical page from exec space.   Assumes PI's off!
;;	T1/	EXEC virtual address of the page
;;	CALL	UNMRCA
;;	return here always, T1 contains the exec virtual address of page
UNMRCA::CALL	STKACS
	MOVE	TAC1,..T1
	LSH	TAC1,-PGSFT
	CALL	DELEMP
	RET

;;Copy data from real core address
;;	T2/	core page number
;;	T1/	relative address in page
;;	CALL	MOVRCA
;;	return here always, T1 contains the data word

MOVRCA::CALL	STKACS
	MOVE	TAC,..T2	;core page number
	MOVEI	TAC1,PHYEXP	;exec page number to map this to
	CALL	ADDEMP		;add page to exec map
	MOVEI	TAC1,PHYEXP
	LSH	TAC1,PGSFT
	IOR	TAC1,..T1	;add low order address to address formed in TAC1
	MOVE	TAC,..T3
	MOVE	TAC,(TAC1)
	MOVEM	TAC,..T1
	MOVEI	TAC1,PHYEXP
	CALL	DELEMP		;flush exec page
	RET

;;Store into real core address
;;	T3/	Data to store
;;	T2/	core page number
;;	T1/	relative address in page
;;	CALL	STORCA
;;	return here always, T1 unchanged

STORCA::CALL	STKACS
	MOVE	TAC,..T2	;core page number
	MOVEI	TAC1,PHYEXP	;exec page number to map this to
	CALL	ADDEMP		;add page to exec map
	MOVEI	TAC1,PHYEXP
	LSH	TAC1,PGSFT
	IOR	TAC1,..T1	;add low order address to address formed in TAC1
	MOVE	TAC,..T3
	MOVEM	TAC,(TAC1)
	MOVEI	TAC1,PHYEXP
	CALL	DELEMP		;flush exec page
	RET

;ROUTINE USED BY PHYSIO TO OUTPUT RH20/CHANNEL MEMORY
;ERROR INFORMATION
;	T1/ CHANNEL NUMBER
;	T2/ LOGOUT STATUS WORD
;	T3/ UPDATED CCW
;STACK MUST BE SET UP

APRRPT::CALL	STKACS
	PIOFF			;OWN MACHINE
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ 	/
RH20 or Channel detected memory error
Channel /
	MOVE	TAC,..T1	;GET CHANNEL #
	CALL	DISLOC		;PRINT IT
	CALL	DISMES
	ASCIZ	/
Channel Status Word /
	MOVE	TAC,..T2	;GET WORD
	CALL	DISOCH		;TYPE IT
	CALL	DISMES
	ASCIZ	/
Final Channel Command Word /
	MOVE	TAC,..T3	;GET FINAL CCW
	CALL	DISOCH
	CALL	DISCRLF
	CALL	DISCRLF
	PION			;TURN ON PIS
	RET			;AND DONE

;ACCEPTS IN T1/	Length.
;	CALL ASGRES
;RETURNS +1:	FAILED TO GET THE REQUESTED SPACE
;	 +2:	ADDRESS OF BLOCK IN T1

ASGRES::CALL	STKACS		;save t20 acs on stack.
	HRRZ	AC3,..T1	;get the size requested
	CALL	FSGET		;If called at initialization, JOB = 0 and
	 RET			; FSGET knows it can't wait
	SETZM	(AC1)		;zero the block.
	MOVSI	TAC,(AC1)	;source,,
	HRRI	TAC,1(AC1)	;        destination
	EXCH	AC1,..T1	;size of req. to AC1, result returned in T1
	ADD	AC1,..T1	;to size, add position
	BLT	TAC,-1(AC1)	;clear block
	RETSKP

;ACCEPTS IN T1/	Address of free stg block
;	CALL RELRES
;RETURNS +1:	released the block

RELRES::CALL	STKACS		;save t20 acs on stack.
	HRRZ	AC1,..T1
	CALL	FSGIVE
	RET

MEMSCN::CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/At MEMSCN (unimplemented):
Supposed to scan for channel write parity errors in physical region
from /
	MOVE	TAC,..T1
	CALL	DISLOC
	CALL	DISMES
	ASCIZ	/ to /
	MOVE	TAC,..T1
	ADD	TAC,..T2
	SUBI	TAC,1
	CALL	DISLOC
	CALL	DISCRLF
	CALL	DISFLU
	CALL	WDDTCALL
	RET
;	BATQ		Mark BAT blocks ;⊗ BATQ
;
;ROUTINE CALLED BY SYSERR POSTING ROUTINE TO MARK A DISK BAT
;BLOCK ON A "HARD" DISK ERROR. ACCEPTS:
;	1/ UDB POINTER
;	2/ LOCAL LINEAR DISK ADDRESS
;
;RETURNS: +1 ALWAYS WITH BAT BLOCK UPDATED

BATQ::	CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/Hard disk error.  UDB = /
	MOVE	TAC,1-17(P)
	CALL	DISLOC
	CALL	DISMES
	ASCIZ	/;  Disk Address = /
	MOVE	TAC,1-17(P)
	CALL	DISOCT
	CALL	DISCRLF
	RET

;	ELOGOO	CALL TO LOGOUT ANOTHER JOB. ;⊗ ELOGOO FSIPSO TTEMES TTEMS1 FNDSTR MTCLVA MTCLVL SWPDON
;ACCEPTS:	T1/ JOB NUMBER
;RETURNS:	+1 WITH LOGOUT REQUESTED

Repeat 0,<
ELOGOO::CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/A peripheral unit (in maintenance mode) has timed out.
PHYSIO wants to log out the job that is referencing that unit.  We
don't know how to do that.
/
	MOVE	J,..T1
	CALL	DISJOB
	CALL	DISCRLF
	RET			;AND DONE
>;Repeat 0

;Print message on CTY.  T1 = tops-20 source designator
FSIPSO:
TTEMES::CALL	STKACS
	TLC	T1,-1
	TLCN	T1,-1
	HRLI	T1,440700	;set -1 in left half to POINT 7,x
	MOVEM	T1,..T1		;Store where it'll be visible to caller
TTEMS1:	ILDB	TEM,..T1	;GET A BYTE
	JUMPE	TEM,R		;NONE THERE.  Done
	CALL	DISTYO
	JRST	TTEMS1

FNDSTR::CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/Unimplemented:  FNDSTR.  Find Structure Number from PAGEM request
/
	CALL	DISFLU
	JRST	DDTCALL

MTCLVA::
repeat 0,<
	CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/MTCLVA: PHYSIO requests: ''clear volume valid'' for all magtapes
/
>;repeat 0
	RET

MTCLVL::
repeat 0,<
	CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/MTCLVL: PHYSIO requests: ''clear volume valid'' for magtape
UDB = /
	MOVE	TAC,..P3
	CALL	DISLOC
	CALL	DISCRLF
>;repeat 0
	RET

SWPDON::CALL	STKACS
	CALL	DISGST		;print time of msg on CTY
	CALL	DISMES
	ASCIZ	/SWPDON: PHYSIO reports completion of a swapping operation?
/
	CALL	DISFLU
	JRST	WDDTCALL
	SUBTTL Routines to handle BUGHLT, BUGCHK, BUGINF ;⊗ BUGH0 BGCCHK BGCINF BHGSTO BCGSTO BIGSTO BUGST1 BUGH3 BUGH9 BUGH9A BUGH10 DISMPT DISMP1

BUGH0::	PIOFF			;TURN OFF SYSTEM
	AOSE	BUGLCK		;FIRST TIME?
	HALT .			;NO!!
	MOVEM	17,BUGACS+17	;SAVE ACS FOR DUMP
	MOVEI	17,BUGACS
	BLT	17,BUGACS+16
	MOVEI	17,BUGACU		;SET UP TO SAVE PACS
	XBLTUM	[BLT 17,BUGACU+17] 	;SAVE PREV CONTEXT ACS
	HRRZ	T1,BUGHLT	;Return Address = Address of XCT plus 1.
	HRRZ	T1,-1(T1)	;E field of XCT instruction = address of JSR
	CALL	BHGSTO		;print messages.
	CALL	DISMES
	ASCIZ	/
Fatal....
/
	CALL	DISFLUSH
	JRST	DDTCALL

;LESS SERIOUS BUGS - BUGCHK & BUGINF

BGCCHK::			;HERE VIA CALL BGCCHK
	AOS	BUGNUM		;COUNT UP BUGCHK'S AND BUGINF'S SINCE STARTUP
	ADJSP	P,1		;GET A WORD TO USE
	CONI	PI,0(P)		;SAVE PI STATE HERE
	PIOFF
	AOSE	BUGLCK		;FIRST TIME?
	HALT	.		;NO
	MOVEM	17,BUGACS+17	;SAVE ACS
	MOVEI	17,BUGACS
	BLT	17,BUGACS+16
	MOVE	P,BUGACS+P	;RESTORE P FOR A MOMENT
	MOVE	T1,-1(P)	;GET ADDRESS OF BUGCHK
	MOVEM	T1,BUGCHK	;LEAVE TRACKS (return address)
	HRRZ	T1,-1(T1)	;RH of XCT instruction = address of CALL
	MOVE	P,[-BUGPLN,,BUGPDL-1] 	;GET A STACK
	CALL	BCGSTO		;GO CREATE SYSERR ENTRY
	CALL	DISFLUSH
	CALL	WDDTCALL
;	MOVSI	17,BUGACS	;RESTORE ACS
;	BLT	17,17
;	CALL	DGFKIL		;RETURN ANY DIAG RESOURCES THE PROCESS MAY OWN
	MOVSI	17,BUGACS	;RESTORE ACS AGAIN
	BLT	17,17
	SETOM	BUGLCK		;UNLOCK
	EXCH	T1,0(P)		;SAVE T1, GET PI STATUS
	TXNE	T1,PIPION	;NEED TO ENABLE?
	PION
	POP	P,T1		;RESTORE T1
	RET			;CONTINUE


;PROCESS BUGINF

BGCINF::			;HERE VIA CALL BUGINF
	AOS	BUGNUM		;COUNT UP BUGCHK'S AND BUGINF'S SINCE STARTUP
	PIOFF
	AOSE	BUGLCK		;FIRST TIME?
	HALT	.		;NO
	MOVEM	17,BUGACS+17	;SAVE ACS
	MOVEI	17,BUGACS
	BLT	17,BUGACS+16
	MOVE	P,BUGACS+P	;RESTORE P FOR A MOMENT
	MOVE	T1,0(P)		;GET ADDRESS OF BUGINF
	MOVEM	T1,BUGINF	;LEAVE TRACKS
	HRRZ	T1,-1(T1)	;RH of XCT instruction = address of CALL
	MOVE	P,[-BUGPLN,,BUGPDL-1]	;GET A STACK
	CALL	BIGSTO		;GO CREATE SYSERR ENTRY
;	CALL	DISFLUSH
;	CALL	WDDTCALL
	MOVSI	17,BUGACS	;RESTORE ACS
	BLT	17,17
	SETOM	BUGLCK		;UNLOCK
	PION
	RET			;CONTINUE

;ROUTINE TO REPORT AN ERROR
;ACCEPTS IN T1/	POINTER TO BUG HLT/CHK BLOCK
;	    P1/	HLT/CHK/INF
;CALLED BY BUGHLT, BUGCHK, AND BUGINF CODE

BHGSTO:	PUSH	P,T1		;save address of XCT.
	CALL	DISUSR		;print time on CTY & BUGHLT
	'BUGHLT'
	JRST	BUGST1

BCGSTO: PUSH	P,T1
	CALL	DISUSR		;print time on CTY and "BUGCHK"
	'BUGCHK'
	JRST	BUGST1

BIGSTO:	PUSH	P,T1
	CALL	DISUSR		;print time on CTY and "BUGINF"
	'BUGINF'
BUGST1:	MOVE	T1,(P)		;address of the JSR/PUSHJ instr.
BUGH3:	ADDI	T1,2
	SKIPE	T2,-1(T1)	;FIND THE zero that terminates the name/loc pairs
	JRST	BUGH3
	PUSH	P,T1		;save the address of the name of bug halt
	MOVE	TAC1,0(T1)	;then this is the name of the bug halt
	CALL	DISSIX
	CALL	DISTAB
	POP	P,AC1		;address of name of bug halt (again)
	ADD	AC1,[POINT 7,1]	;point to string of bug message
	CALL	DISMPT
	CONSZ PI,77400		;skip unless PI in progress
	JRST BUGH9		;no job directly involved, don't print random job
	CALL	DISCRLF		;uuo level
	SKIPE	J,JOB		;show job, if any
	CALL	DISJOB
BUGH9:	MOVE	TAC1,(P)
	SKIPN	1(TAC1)		;is there more data?
	JRST	BUGH10
	CALL	DISMES
	ASCIZ	/
*/
	MOVE	TAC1,(P)
	MOVE	TAC1,1(TAC1)	;get the data
	CALL	DISSIX		;print name
	MOVEI	TEM,"/"
	CALL	DISTYO
	CALL	DISTAB
	MOVEI	TAC1,2
	ADDB	TAC1,(P)
	MOVE	TAC1,(TAC1)	;the address of the datum
	CAIG	TAC1,17
	JRST	BUGH9A
	MAP	TAC,(TAC1)	;IS THIS ADDRESS IN CORE?
	TLNE	TAC,360000
	TLNE	TAC,200000	;HARD PAGE FAIL CODE?
	JRST	[CALL DISMES
		ASCIZ /Not in Core/
		JRST BUGH9]	;NO, CAN'T PRINT IT OUT
	SKIPA	TAC,(TAC1)	;GET THE CONTENTS OF LOCATION
BUGH9A:	MOVE	TAC,BUGACS(TAC1)
	CALL	DISOCH
	JRST	BUGH9

BUGH10:	CALL	DISCRLF
	ADJSP	P,-1		;discard address of JSR or PUSHJ
	RET

DISMPT:	PUSH	P,AC1
DISMP1:	ILDB	TEM,(P)
	JUMPE	TEM,[ADJSP P,-1
		     RET]
	PUSHJ	P,DISTYO
	JRST	DISMP1

	END
