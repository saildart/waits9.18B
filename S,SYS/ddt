COMMENT ⊗   VALID 00062 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00014 00002	SWITCHES:  UEDDTS X. XTITLE JOBREL JOBSYM ZLOW XTITLE XTITLE F R S W T W1 W2 SCH AR ODF TT SMB T W1 W2 SCH AR ODF TT SMB R S W ZLOW F P T W1 W2 SCH AR ODF TT SMB R S W A B C APR PI KLPAG CCA TTYY PTRR PTPP LPDL
C00024 00003	Flags  COMF TIF PTF CTF SF QF CF CCF MF LTF ROF STF FAF SAF FPF FEF MLF DVF ITF OUTF CF1 LF1 Q2F R20F SBF NAF POWF EQF GLOBAL LOCAL PNAME DELI DELO PPID NBP MAXPR
C00027 00004	DEVICES, DEVICE CODE DEFINITIONS
C00030 00005	DDTBEG IOTLG IOTBL IOTLG IOTB2 SAVPI SAVTTY ACTALL OUTLPT SAVAPR OUTRTN STRING MSK MXINC MXINC BMASK FLGPTR B1ADR B1SKP B1CNT B1STR BNADR SIMADR AUTOPI AC0 AC17 SCHM ODFM SARS TEM1 PS PRGM BLOCK TBLK TEMDDT SVF SW1 SVFB SVTB BLVL WRD WRD2 PRNC FRASE SYL LWT TEM2 FRASE1 TEM3 DENDDT INSXCT I.NST I.NSTAC I.NSTEA I.NSTPC SAV0 XCTS XTEM FLAGS LOCSAV GETFLG FSV FHTTMP FHDTMP SYM SPSAV DEFV ULIMIT LLOC LLOCO SAVLOC IOTFLG DINIDN KLFLG DDTPEN KEXPGT KEPTAD KLTMON SVKLP SYMP SP2NUM SCNTMO SCNINP SCNREP SCNPOR SCNOUP DDTETO PROCPC GOTALT USRLCH USRACT DDTACT
C00038 00006	BP1 BP1 B1INS BPN
C00039 00007	BCOM BCOM3 BCOM2 NOBREAK LEAV1 PROC1 LEAV BREAK XEC0 XEC1 XEC2 DOITA DOITC DOITB JMP
C00044 00008	SAVE SAV1 SAVX SAV1A SAV5 XCTBUF RESTORE RESTR1 RES3 RES2
C00056 00009	 NOTDDT KEEPIN INDDT SYMLOC EXMMAP DDTXCOR DDTPGS DDMEND DDPEND DDTBLK ONCBLK MDDBLK P1EBLK DDSTSW DDS170 MAPON PSBPSB PSBEXP NPFPI DDSPFW DDSFFG DDSFPC DDSNPC SKLUPT DDTSUM SWPWRD LDDTMAP DDTMAP SYSMAP
C00061 00010	DDTA  CDDTA DDTINI DDXINI SETXC2 SETXC2 DDXILP SETXCT DDXLUZ DDXLU2 DDXLU3
C00073 00011	GETDDT GETDL2 GETDLZ GTDDMP DDTMES PINDEX PINDE2
C00078 00012	GETBAK GETBL2 GETBLZ BKDDMP
C00081 00013	 SWPEXM SWPEX3 SWPEX2 SWPDEP XCREXM XCRRTN XCRFIN XCRDEP DDTTR2 DDTTRP MWRIT0 MWRITE MWRITA
C00091 00014	DCKLST DCHKMC ASNDB  DCHKPD DCHKAC DCHECK DCHEK1 DCHEK2 DCHEK4 DCHEK5 DCHEK3 OTOCA DTOCA DKTOCA DTOC2 DCKRAD DCHKTB NDCHK DCHKNM DCCBEG DCCLEN CLRCOR ARMTAC ARMBEG ARMLEN CLRARM CPOPJ2 CPOPJ1 CPOPJ ASCOUT ASCOU1 SIXOUT DTOUT XTKL DDTEXX DDTEX3 DDTEX2 DDTFLC TPIASH TENA TCHNG TBIT37 TREQ RPIASH RCLEAR RENA RCHNG RREQ RMISSED RBIT37 TINSTR TIN4 TIN3 TIN TIN2 TOUT WTP1OU WTP1OK WTP1CK NOP1OU CTPUTT CHKEPT CTGETT TOUTSC TOUTSL TOUTSE TOUTSX CTPUTD LPOUT LPPTR LPWRD LPCNT LISTEN LISTE1 K10CS K10RTN K10REP K10PIR K10TST K10EN K10IAK K10PI K10CS1 AS.NLB AS.BKO AS.1SB AS.BSO AS.ECH AS.PEN AS.REN AS.RTS AS.DTR AS.NDB AS.SYN AS.ODD AS.RCL AS.XCL AS.DSC AS.DSR AS.CAR AS.FER AS.PER AS.OER AS.RDA AS.THRE ASTWAT ASDRD0 ASDWR0 ASDRD2 ASDWR2 ASDRD4 ASDWR4 ASDRD6 ASDWR6 ASDRED ASDWRT ASDPRT LISSCN LISSCX LISSCR LISSCP LISSCO XTKL2
C00125 00015	 TMPTAC DDTP2 DDT DDTDDT DDT DDGVUS RDDTA DDTB DDTC DDTD DD1 DD1.5 DD2 LIS LIS0 LIS1 LIS2 L1 L1RPR L2 L21 L212 L213 L4 L5 RET ERR UNDEF WRONG WRONG1
C00134 00016	NUM LE1 DOLLAR PERC LET LET1 LE1A LE2 NUM1 NM1 POWER POW2
C00138 00017	PERIOD QUAN PILOC QUAN1 QUAN2 CONTRO
C00140 00018	ESTU ESTUT UND1 QUESTN QUEST1 QUEST2 QUEST4 UKILL KILL2 REMUN DUNDEF DEF3 DEF4 REMAUN REMAU1 EVAL0 EVAL1 EVAL2 EVAL3
C00147 00019	 CHKSYM SRTCHK SRTCH2 KILL TAG DEFIN DEF1 DEF2 PNAMES PPNAM1 PPNAM2 GETPGM GETPG1 GETPG2 SETNAM SET1 SET2 SET3 SETBLK SB1 SBPRM PBLKNS PBLKN1 PBLKN2 SYMD
C00158 00020	LOOK LOOK1 LOOK2 LOOK3 LOOK LOOK1 LOOK2 LOOK2A LOOK3 LOOK3A TOPDWD TOPDWN BLNME BLNM1 BLNM2 PNAM PNAM2 LOOK4 LOOK5 LOOK5A SPT0 SPT SPT1X SPT1W SPT1 SPT2 SPT3
C00169 00021	EVAL EVL2 EVL1 EV4 EV3 EV1 EV2B EV2
C00173 00022	 BLKNAM BLKNA1 BLKNA2 LASSYM S.SYM X.SYM UNIQ UNIQP SYMRNG TXCT FFETCH FNDHI FNDLO C3FLG SSCHK SSCHK1 SSCHK2 SRTAG SRDEF SRDEF1 SPNAME SPROG SPNAM1 SPRG0 SPRG1 SPRG2 SPRG3 SPRG4 SRGPGM SRGPG1 SRGPG3 SBLOCK SBLK1 SBLK2 SBLK3 SPBNS SPBNS1
C00187 00023	SKILL SSYMD SYMDEL SYMDL1 SYMDL2 SYMDL3 SYMDL4 SYMINS SYMI3 SYMI2 SYMI1 SYMI1A SYMI1B SYMI1C SYMI1D SYMI1E SYMI5F SYMI1F SYMI4 SYMI4C SYMI4D SYMI4E SYMI5A SYMI5B
C00195 00024	SEVAL SEVAL0 SEVAL1 SEVL1C SEVL1B SEVL1A SEVAL2 SEVAL3 SEVAL4 WCHBLK WCHBL1 GCLASS REVAL REVAL0
C00202 00025	CCLASS CCLAS1 SLOOK SLC2 SLC1 SLC1A SLC34 SLC34A SLC34B SLC34D SLC34C SLC43 SLC43A SLC3 SLC4 FNDSYM FNDSY1 FNDSY2 FNDSY3 FNDSY4 FNDSY5 FNDSY6 FNDSY7 FNDSY8 FNDSYC FNDSYB FNDSYA FNDSY9 FNDSYD FNDSYE FNDXT2 FNDSYF FNDSYG FNDSYH
C00215 00026	TEXI TEXI1A TEXI4 TEXI5 TEXI2 TEXI6 TEXI3 SIXBI1 SIXBIN SIXBI2
C00220 00027	BYTI BYTI4 BYTIM4 BYTIM5 BYTI1A BYTI3 BYTI3A SVBTI SVBTI1 SVBTI2 SVBTID
C00224 00028	MULT DIVD ASSEM MINUS PLUS LPRN ACCF ACCCF SPACE SPAC1 RPRN RPRN1 CRN CRNRB CRF LCT TSPC
C00227 00029	LINEF LI0 LI1 LI2 VARRW DARRW CARR OCON OSYM SUPTYO SLASH SLAS2 SLAS1 ICON
C00230 00030	LTAB TAB TAB1 DEPRA EQUAL PSYM R50PNT SIXBP SIXBP1
C00232 00031	JOBSET JOBST1 JOBST0 JOBST3 JOBST2 JOBST4 JOBSP2 JOBSET EP2DDT EP2DDM EP2DDN EP2DDR EP2DDL EP2DDP EP2DDX STROUT STROU1 TEXO HWRDS SFLOT SYMBOL CON UCON RELA ABSA BASECH BASE1 SEMIC
C00241 00032	STR STR1 XEC BREAKA BREAKB BREAK1 BREAK2 RETB BRKNAM PROCEED PROC3 PROCD1 PROC0 PROC2
C00246 00033	$X $X00 $X01 $X02 $X03 $XTBL
C00254 00034	MONUAI MONUI MONUAE MONUE MONINI XECDET MONIN1 INLINI USRUUO IUFA IDFN DFLT FLOAT FLOATI IJRST IJRST0 IJRST1 JRSPRC IJRST3 I.XCT IIXCT1 IIPUSHJ IPOPJ IPOPJ2 IPUPO IFSC I.JSA I.JSR I.JSR2 I.JSP I.JSR4 IJFFO JMPSKP IAOBJ IJFCL JMP1 SKP JUSTE DBLI DINT IEXTND TESTS IOTS JUSTI CHEKIS SET MULDIV CHECKI SETEA SETI DOIT SKIP% NOSKIP TELL NXTIT NXT0 $XQUIT NXT1 NXT2 PFLG0 DBL0 FAC0 FLG0 IMM0 IMM1 DEA0 EA0 EA2 EA6 PINST SWAP SWAPL
C00268 00035	IXCT4 IIXCT IXCT IXCT5 IXCT6 BPLUP BPLUP1 IINIT INITL
C00272 00036	IPUSHJ CPUSHP IJSA IJSR IJSR2 IJSR3 IJSR4 IJSP INSRTB INSRT1 INSRT3 REMOVB REMOV1
C00275 00037	BPS BPS1 BPS2 BPS3 BPS4 BPS5 AUTOP
C00277 00038	DEPRS DEP XDEP DEP0 DPTHIX DPTHIC DPTEXL UDTDPE UDTDP0 UDTDP1 UDTDP2 UDEPLZ DEP1 FETCH XFETCH FETCH0 NOEXPE NOEXP2 EXPCHK EXPCH2 EXPCDD EXPEXM EXMHIX EXPXIT EXMHIC EXPEXL JEXM JEXM1 FIRARG ULIM ULIM1
C00289 00039	CONSYM LFPIN RFPIN PIN PIN1 PIN1A PI3A PI4 PI7 PI8 PI8A
C00292 00040	HLFW HLFW1 PAD PADSO PADS1A PADS3 PADS3A PADS3B PADS3C INOUT CKIOT
C00295 00041	MASK MASK2 MASK1 EFFEC WORD NWORD SEAR1A SEAR1 SEAR2 SEAR2A SEAR2C SEAR2B SERLPC SEAR3 SEAR4 EFFEC0 EFFECR EFFECA EFFEC1 EFFEC2 EFFEC3
C00299 00042	 SETUP SETUP1 SETUP2 ZERO ZERO1 ZERO2 ZEROR
C00302 00043	TOCC FTOC TOC TOCS TOCA TOC1 TOC3 TOC2 TOC4 TOC5 TOC6
C00304 00044	TFLOT TFLOT1 FP1 FP1A FP3 FP3A FP4 FP4A FP4B
C00306 00045	FP7 FP7A1 FP7B FP7A FP7A2 FT8 FT FT01 FCP FSGN TEXTT TEXT TEXT2 TEXTT9 TEXTT0
C00309 00046	PSR PUNCH PUN2 PUN1 PBLK PBLK1 LOADER LOAD1 LOAD2 BLKEND PWRD PWRD2 FEED FEED1
C00313 00047	LOADB BEG RD AA TBL1 TBL2 ADR LOADE
C00315 00048	VERIFY CORE CORE1 CORE2 VER2 VER3 RUNEND GETW GETW1 BLOCKS BLOCKQ BLK1 BLK2 BLK3
C00318 00049	TTYRET TTY1 TTYLEV TEXIN KLLEV KLSRT
C00322 00050	GETCH GETCH2 GETCH3 TIN TIN3 TIN2 TINSTR TIN4 TOUT NOTDEL TTYLEV FINOUT SPCBRK TTYSAV SETSPC SETSP2 TTYRST TTYRS2 POUTBF LISTEN LISTEN INBFF TTYRET TEXIN
C00329 00051	PRFLAG PRFLG1 PRFLG2 PRFLG3 GETPTR FLGSLP LFTT RFTT FLGMOD FLGOUT FLGOU1 FLGOU2 RLFFLG
C00333 00052	BITO BITT BITT2 BITTM BITTM1 BITTM2 SVBT4 SVBTS SVBTS2 SVBT3 SVBT2
C00336 00053	BDISP DISP
C00339 00054		SUBTTL DDT - OP DECODER
C00345 00055	TBL
C00352 00056	PNTR INST CHP TXT SAVPDL BTAB OPEVAL OPTYPE DC1 DC2
C00355 00057	DECT DECX NOMAT NOMAT1 DC6 DC6AA DC6BB DC7 DC8
C00358 00058	DDTPATCH BUFF
C00359 00059	UESTRT NODMAP COPSYM ESYMS XSCOP1 XSCOP2 P2SYMS P2NOCR P2DOWN P2NOSY P2LOSE P2SYM2 USYMS CSYMS UELP1 U2SYMS U2SYM2 NOCORE NOSYM1 EXCSYM EXMMAP EXSYMS EXJOBN EXJWRD EXPPSB EXPGTA EXPGT
C00371 00060	DDTREN NOREN SYMPR PRSET PRLUZ PROFF LOGIT LOGIT0 LOGZ0 LOGOUT LOGZ LOGZ1 LOGLOS LOGDC2 LOGWRD LOGOCT LOGDEC LOGNUM LOGCHR LOGOK LOGSIX INLMES INLMS1 LOGCNT LOGPTR LOGADR LOGBUF LOGNAM LOGEXT LOGDAT LOGPPN
C00378 00061		How to put up new SYS:DDT.DMP How to debug UEDDT using RAID.
C00380 00062		SUBTTL	DDT User's Guide
C00406 ENDMK
C⊗;
;SWITCHES: ;⊗ UEDDTS X. XTITLE JOBREL JOBSYM ZLOW XTITLE XTITLE F R S W T W1 W2 SCH AR ODF TT SMB T W1 W2 SCH AR ODF TT SMB R S W ZLOW F P T W1 W2 SCH AR ODF TT SMB R S W A B C APR PI KLPAG CCA TTYY PTRR PTPP LPDL
;	EDDT←←0 FOR NORMAL, USER DDT (DEFAULT)
;	UEDDTS←←1 FOR USER EXEC DDT
;	EXEC DDT SETTINGS:
;		EDDT&1=0		ASSUME UDDT
;		EDDT&2=2		ASSUME EDDT WITH PAPER TAPE
;		EDDT&10=10		ASSUME PDP-10 PAPER TAPE INSTEAD OF PDP-6
;		EDDT&20=20		ASSUME SYSTEM EXEC DDT AND COMPILE SPECIAL CODE!
;		EDDT&40=40		MAKE RELOCATABLE EXEC DDT
;		EDDT&100=100		USE 10/6 INTERFACE INSTEAD OF TTY
;		IF LEFT HALF OF EDDT IS NOT=0, DO A LOC<EDDT⊗-=18>

IFNDEF P2SYS,<P2SYS←←0>			;ON IF ASSEMBLING P2 SYSTEM
IFNDEF FTP2DDT,<FTP2DDT←←0>		;MAYBE P2 DOESN'T WANT DDT
IFNDEF FTF2,<IFNDEF F2UUO,<FTF2←←0;> FTF2←←1> ;ON IF ASSEMBLING F2 SYSTEM
IFNDEF FTDLS,<FTDLS←←FTF2>		;MAYBE F2 IS RUNNING OLD MICROCODE
IFNDEF FTSCTY,<FTSCTY←←0>		;NO SPECIAL SCANNER CTY IF UNSPECIFIED
IFNDEF FTSUAI,<FTSUAI←←0>		;NOT SUAI EXEC DDT IF UNSPECIFIED
IFNDEF FTDLS,<FTDLS←←0>			;NO DLS code if UNSPECIFIED
IFNDEF FTKLB,<FTKLB←←0>			;NOT A KL model B if unspecified
IFNDEF FTSEPONCE,<FTSEPONCE←←0>		;not separate assembly if unspecified
IFNDEF FT17P,<FT17P←←0>			;nonzero to have P be 17

IFN FTKLB,<
IFNDEF KLESEC,<KLESEC←←540>		;offset in KLEPT of section pointers
>;IFN FTKLB

IFNDEF FTDDT,<FTDDT←←-1>
IFN <P2SYS&FTP2DDT>!<<¬P2SYS>&FTDDT>,<	;THIS ENTIRE ASSEMBLY IS CONDITIONAL
	IFNDEF FTDMAP,<↓FTDMAP←←0>
	IFNDEF EDDT,<↓EDDT←←0>
	IFE EDDT&20,<↓FTDMAP←←0>
	IFN P2SYS,<↓FTDMAP←←0>		;NO MAPPING OF DDT ON P2
	IFN P2SYS,<↓FTSCTY←←0>		;NO SCANNER CTY ON P2 EVER
	IFE EDDT&21-21,<BEGIN DDT>	;IF SYSTEM EXEC DDT

IFNDEF NOKL10,<DEFINE NOKL10<IFN FTF2>>
IFNDEF IFKL10,<DEFINE IFKL10<IFE FTF2>>

IFNDEF UEDDTS,<UEDDTS←←0>	;SET UP UEDDT
IFNDEF SAVESW,<SAVESW←←0>	;SET UP A STARTING ADRESS
↓UEDDTS←←UEDDTS

DEFINE XP' (X.,Y.),<
X.←←Y.
>

IFE EDDT&21-1,<TITLE EDDT - EXEC MODE VERSION
	NOLIT
	XALL
	XTITLE←←<RADIX50 0,EDDT>>

IFN EDDT,<SUBTTL DDT - EXEC MODE VERSION
	JOBREL←←37
	JOBSYM←←36
	ZLOW←←40
IFE FTSEPONCE,<
IFNDEF KLEPT,<KLEPT←←0>			;DEFAULT LOCATION OF KL10 EXEC PROCESS TABLE
>;IFE FTSEPONCE
>;IFN EDDT

IFE EDDT!UEDDTS,<TITLE UDDT - USER MODE DDT
	NOLIT
	XALL
	XTITLE←←<RADIX50 0,UDDT>>

IFN UEDDTS,<TITLE UEDDT - USER MODE EXEC DDT
	NOLIT
	XALL
	XTITLE←←<RADIX50 0,UEDDT>>

IFNDEF XTITLE,<XTITLE←←0>

;Following ACs are used as first AC of two-AC instructions: T,W1,R(A),B,TT,TM1
IFN EDDT,<
↓F←←0		;FLAGS
IFN FT17P,<
↓R←←↓A←←1	;POINTERS TO TABLES, CORE, ETC.  ABC MUST BE CONSECUTIVE.
↓S←←↓B←←R+1
↓W←←↓C←←R+2	;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
↓TM1←←4		;must be T-1
↓T←←5		;TRANSFER DATA
↓W1←←T+1
↓W2←←W1+1
↓SCH←←10	;MODE CONTROL SWITCH FOR OUTPUT
↓AR←←SCH+1	;MODE CONTROL SWITCH FOR OUTPUT
↓ODF←←AR+1	;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
↓TT←←13		;TEMPORARY (can't be P-1 !)
↓SMB←←14	;SYMBOL TABLE POINTER FOR SORTED SYMBOLS--must be 14 (symbol table contains 14s in index field)
IFE EDDT&20,<↓P←←17> ;SETUP PUSHDOWN POINTER IF NOT SYSTEM
>;IFN FT17P

IFE FT17P,<
IFE EDDT&20,<P←←3>	;SETUP PUSHDOWN POINTER IF NOT SYSTEM
TM1←←4		;must be T-1
T←←5		;TRANSFER DATA
W1←←6
W2←←7
SCH←←10		;MODE CONTROL SWITCH FOR OUTPUT
AR←←11		;MODE CONTROL SWITCH FOR OUTPUT
ODF←←12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT←←13		;TEMPORARY
SMB←←14		;SYMBOL TABLE POINTER FOR SORTED SYMBOLS
R←←A←←15	;POINTERS TO TABLES, CORE, ETC.  ABC MUST BE CONSECUTIVE.
S←←B←←R+1
W←←C←←R+2	;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
>;IFE FT17P

comment ⊗  ;here are the DDT/WAITS AC name matchups, before and after FT17P.

IFE FT17P:	IFN FT17P:
    F	IOS,0	    F	IOS,0
    --	TAC,1	    R	TAC,1
    --	TAC1,2	    S	TAC1,2
    P	P,3	    W	J,3
    TM1 J,4	    TM1 DDB,4
    T	DAT,5	    T	DAT,5
    W1	DDB,6	    W1	PROG,6
    W2	PROG,7	    W2	TEM,7
    SCH TEM,10	    SCH DSER,10
    AR	DSER,11	    AR	UCHN,11
    ODF UCHN,12	    ODF PID,12
    TT	PID,13	    TT	UUO,13
    SMB UUO,14	    SMB AC1,14
    R	AC1,15	    --	AC2,15
    S	AC2,16	    --	AC3,16
    W	AC3,17	    P	P,17

end of comment ⊗

>;IFN EDDT

IFE EDDT,<		;DEFINITIONS FOR NON-EXEC MODE DDT
	EXTERN JOBREL,JOBSYM,JOBSA,JOBHRL,JOBFF
	ZLOW←←140
F←0		;FLAGS
P←3		;PUSH DOWN
TM1←4		;must be T-1
T←5		;TRANSFER DATA
W1←6
W2←7
SCH←10		;MODE CONTROL SWITCH FOR OUTPUT
AR←11		;MODE CONTROL SWITCH FOR OUTPUT
ODF←12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT←13		;TEMPORARY
SMB←14		;SYMBOL TABLE POINTER FOR SORTED SYMBOLS
R←15		;POINTERS TO TABLES, CORE, ETC.
S←R+1
W←R+2		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
A←←R		;ABC MUST BE CONSECUTIVE.
B←←R+1
C←←R+2

>;IFE EDDT

;DEVICE CODES FOR EXEC MODE VERSION
↑APR←←0
↑PI←←4			;PI SYSTEM
↑KLPAG←←10
↑CCA←←14
↓TTYY←←120		;CONSOLE TTY
PTRR←←104		;PTR
PTPP←←100		;PTP

LPDL←←50		;MAX LENGTH PUSH DOWN LIST


IFN EDDT,<
IFNDEF SWEEPB,<SWEEPB←←200000>
;EXEC PROCESS TABLE (EPT) LOCATIONS
IFNDEF DTE0,<DTE0←←200>
IFNDEF DONG11,<DONG11←←20000>		;RING 11'S DOORBELL
IFE FTSEPONCE,<
IFKL10,<
IFNDEF $DDT,<$DDT←←441+KLEPT>		;DDT START ADDRESS
>;IFKL10
>;IFE FTSEPONCE
IFNDEF DTFLG,<DTFLG←←444>		;DTE20 OP COMPLETE FLAG (RELATIVE TO EPT)
IFNDEF DTF11,<DTF11←←450>		;      10 FROM 11 ARGUMENT
IFNDEF DTCMD,<DTCMD←←451>		;      TO 11 COMMAND WORD
>;IFN EDDT

IFKL10,<
IFE FTSEPONCE,<
;Set up KLEPT location 441 so that the KLDCP command DDT will start PDP-10 DDT.
IFN EDDT&<-1,,0>,<	LOC	$DDT
			JRST	DDT	>
>;IFE FTSEPONCE
>;IFKL10

IFN EDDT,<
IFMAC ADJSP,<
PRINTX Here is the ADJSP purge kludge to suppress the macros.
PURGE ADJSP,ADJSP
;purged twice 'cause first time gets the opcode, second the macro
OPDEF ADJSP[105000,,0]	;Put this opcode back, used in DDT table
>;IFMAC ADJSP
>;IFN EDDT
;Flags ;⊗ COMF TIF PTF CTF SF QF CF CCF MF LTF ROF STF FAF SAF FPF FEF MLF DVF ITF OUTF CF1 LF1 Q2F R20F SBF NAF POWF EQF GLOBAL LOCAL PNAME DELI DELO PPID NBP MAXPR

;LEFT HALF FLAGS

COMF←←200000		;COMMA TYPED FLAG
TIF←←100000		;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF←←100		;+, -, OR * HAS BEEN TYPED
CTF←←400
SF←←4			;SYLLABLE FLAG
QF←←1			;QUANTITY TYPED IN TO WORD ASSEMBLER

CF←←40			;$ TYPED
CCF←←10000		;$$ TYPED
MF←←2			;MINUS SIGN TYPED IN
LTF←←20			;LETTER TYPED IN TO CURRENT SYLLABLE
ROF←←10			;REGISTER OPEN FLAG
STF←←4000
FAF←←1000		; less-than-sign TYPED
SAF←←2000		; greater-than-sign TYPED

FPF←←20000		;FLOATING POINT -  . TYPED IN
FEF←←400000		;FLOATING EXPONENT -  E FLAG

MLF←←200		;*FLAG
DVF←←40000		;DIVIDE FLAG




;RIGHT HALF FLAGS

ITF←←2			;INSTRUCTION TYPED IF ITF=1
OUTF←←4			;OUTPUT IF OUTF=1
CF1←←400		;OUTPUT 1 REGISTER AS CONSTANT
LF1←←2000		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F←←1			;NUMBER TYPED AFTER ALT MODE 
R20F←←10		;TEMP FLAG USED IN SETUP
SBF←←20
NAF←←200		;NEGATIVE ADDRESSES PERMISSABLE
POWF←←4000		;ARGUMENT FOR EXPONENT COMING
EQF←←20000		;WANTS REAL NUMERIC MODE

GLOBAL←←040000		;GLOBAL SYMBOL
LOCAL←←100000
PNAME←←740000		;PROGRAM NAME
DELI←←200000		;DELETE INPUT
DELO←←400000		;DELETE OUTPUT

PPID←←0			;=0 IF SYMBOL TABLE POINTER IS IN JOBSYM
			;USED AS INDEX FIELD IN SYMP


IFE EDDT&1,<	LOC 74		;JOB DDT  (USER MODE DDT)
		DDT		;DDT'S STARTING ADDRESS
IFN UEDDTS,<	LOC 124
		DDTREN >	;REENTER ADDRESS FOR UEDDT
		RELOC 0 >;END IFE EDDT&1

IFN EDDT&<XWD -1,0>,<LOC <EDDT>⊗-=18>

INTERN DDT,$M,DDTEND

;THE MAXIMUM NUMBER OF BREAKPOINTS IS =36 (SEE AUTOPI)
↓NBP←←=8		;NUMBER OF BREAKPOINTS
IFN EDDT,<↓NBP←←=30>

IFE UEDDTS,<DEFINE SYMTST<>>
IFN UEDDTS,<DEFINE SYMTST
<	SKIPE SYMLUZ
	PUSHJ P,SYMPR>
MAXPR←←400000	;MAX SIZE OF UPPER>
;DEVICES, DEVICE CODE DEFINITIONS

DEFINE DEVICES
<
XQ APR,0
XQ PI,4
XQ KLPAG,10	;KL10 PAGER DEVICE
XQ CCA,14	;KL10 CACHE CLEARER
XQ TIM,20	;KL10 TIMER
IFE FTF2,<;Otherwise prints MTR for all the pager instruction on F2
XQ MTR,24	;KL10 METER
>;IFE FTF2
XQ PAG,24
XQ PTP,100
XQ PTR,104
XQ IOP,110
XQ CTY,120
XQ LPT,124
XQ C1A,140
XQ C1B,144
XQ DTE0,200	;KL10'S 10/11 INTERFACE
XQ DC,204	;DATA CONTROL (136)  NOTE THIS IS NOT THE NORMAL DEVICE CODE!
XQ DTC,210
XQ DTS,214
XQ MTC,220
XQ MTS,224
XQ MTM,230	
XQ ADC,240
XQ DAC,244
XQ F2M,270
XQ DCSA,300
XQ DCSB,304
XQ DKB,310
IFE FTF2,<	;$%$%#$ DWP.  F2 uses that opcode for some bad reason.
XQ DCA,320
>;IFE FTF2
XQ VDS,340	;EARNEST VIDEO SWITCH
XQ P1D,340	;P1/P2 INTERFACE, P2 SIDE
XQ FRM,340	;MOORE DIGITAL SYNTHESIZER
XQ DDD,344	;POOR DD IOB INTERFACE
XQ PLT,344	;PLOTTER (P2)
XQ HOT,350	;THERMOMETER
XQ VRN,350	;VARIAN PLOTTER INTERFACE ON P2
XQ CAR,354	;Cart interface
XQ KIM,360	;PARALYZER (KIM SERIAL INTERFACE)
XQ VMI,364
IFE FTDLS,<
XQ PK,370
XQ DIL,374
>;IFE FTDLS
IFN FTDLS,<
XQ DLS,370
>;IFN FTDLS
IFE FTF2,<
IFN FTAIP,<
XQ IMP,400
>;IFN FTAIP
>;IFE FTF2
XQ TV,404
;XQ ARM,420
;XQ AD,424
XQ DPY,430
XQ KBD,434
XQ XGP,440
;XQ DSK,444
XQ P2D,450	;P1/P2 INTERFACE, P1 SIDE
XQ ELF,470
;XQ PMP,500
;XQ IBM,504
XQ SAMA,520
XQ SAMB,524
XQ MPX,530
XQ SAMC,530
XQ SAMD,534
IFN FTF2,<
IFN FTAIP,<
XQ IMP,550
>;IFN FTAIP
;$%$%#$ DWP.  Temporary device code for F2's DCA simulation
XQ DCA,700
>;IFN FTF2
XQ PCLK,730
XQ GRN,740	; INTERIM GRINNELL INTERFACE
XQ AS,774
>;END DEVICES


IFE EDDT&21-1,<		;COMPILE DEVICE DEFINITION FOR NON-SYSTEM EXEC DDT

DEFINE XQ(A,B)
<A←←B
>

DEVICES
>;IFE EDDT&21-1
;DDTBEG IOTLG IOTBL IOTLG IOTB2 SAVPI SAVTTY ACTALL OUTLPT SAVAPR OUTRTN STRING MSK MXINC MXINC BMASK FLGPTR B1ADR B1SKP B1CNT B1STR BNADR SIMADR AUTOPI AC0 AC17 SCHM ODFM SARS TEM1 PS PRGM BLOCK TBLK TEMDDT SVF SW1 SVFB SVTB BLVL WRD WRD2 PRNC FRASE SYL LWT TEM2 FRASE1 TEM3 DENDDT INSXCT I.NST I.NSTAC I.NSTEA I.NSTPC SAV0 XCTS XTEM FLAGS LOCSAV GETFLG FSV FHTTMP FHDTMP SYM SPSAV DEFV ULIMIT LLOC LLOCO SAVLOC IOTFLG DINIDN KLFLG DDTPEN KEXPGT KEPTAD KLTMON SVKLP SYMP SP2NUM SCNTMO SCNINP SCNREP SCNPOR SCNOUP DDTETO PROCPC GOTALT USRLCH USRACT DDTACT

	SUBTTL	DDT - SOME STORAGE STUFF

↑DDTBEG:			;FIRST ADDRESS IN DDT
IFN EDDT,<STARTA:	0>	;START ADDRESS FROM PAPER TAPE

↓IOTLG←←0			;ASSUME NO DEVICES

IFN EDDT!UEDDTS,<		;COMPILE DEVICE TABLE FOR EXEC AND UEDDT
IOTBL:				;TABLE OF DEVICE NUMBERS KNOWN TO DDT
DEFINE XQ(A,B)<B>
DEVICES
IOTLG←.-IOTBL			;LENGTH OF DEVICE NUMBERS TABLE

IOTB2:				;TABLE OF RADIX50 DEVICE NAMES
DEFINE XQ (A,B)<RADIX50 0,A>
DEVICES
>;IFN EDDT!UEDDTS

SAVPI:	0
XP $I,SAVPI
	1177			;TURN OFF CHANNELS 1-7
SAVTTY:	0

ACTALL:	0		;SET TO -1 TO FORCE DDT TO ACTIVATE ON EVERY CHAR
IFN EDDT&1,<
OUTLPT:	0
SAVAPR:	0
>;IFN EDDT&1
IFE EDDT&1,<0↔0>	;PRESERVE OFFSET FROM $M FOR NON EXEC DDT TOO
OUTRTN:0
STRING:	0
MSK:	XWD -1,-1
XP $M,MSK
IFN UEDDTS!<EDDT&1>,<
MXINC:	200		;LOTS OF TABLES IN THE SYSTEM ARE THIS BIG
>;IFN UEDDTS!<EDDT&1>
IFE UEDDTS!<EDDT&1>,<
MXINC:	100		;MAX OFFSET PRINTED WITH SYMBOL NAME FOR VALUE
>;IFE UEDDTS!<EDDT&1>
BMASK:	0
FLGPTR:	0
B1ADR:	0			;CELL TO EXAMINE,,ADDRESS OF BREAK
B1SKP:	0			;CONDITIONAL INSTRUCTION - SEE BCOM3
B1CNT:	0			;PROCEED COUNTER - SEE BCOM2, ALSO $P COMMAND
B1STR:	0			;STRING ADDRESS - SEE RETB

DEFINE DBPNT ! (Z.) <XP $!Z.!B,B1ADR+4*Z.-4>

RADIX =10
FOR QZ←1,NBP
<DBPNT (QZ)
>
RADIX =8
	BLOCK	NBP*4-4		;ROOM FOR THE REST OF THE BREAKPOINTS
BNADR←←.-4
SIMADR: 0			;FAKE BP LOCATION.  NOT USED, BUT MUST BE HERE.
	0			;FAKE BP CONDITIONAL INSTR.
	0			;FAKE BP PROCEED COUNTER.
	0			;FAKE BP STRING ADDR.  NOT USED

AUTOPI:	0

AC0:	BLOCK 17

AC17:	0

SCHM:	PIN		;DO NOT CHANGE ORDER
	PADSO
ODFM:	10

SARS:	0
TEM1:	0

PS:	BLOCK LPDL

PRGM:	0		;IOWD POINTER TO SYMBOL TABLE 	- PROGRAM NAME $:
BLOCK:	0		;				- BLOCK NAME   $&
TBLK:	0		;				- TEMPORARY BLOCK BN&S
TEMDDT:	0
SVF:	0
SW1:	0
SVFB:	0
SVTB:	0
BLVL:	0
WRD:	0
WRD2:	0
PRNC:	0

FRASE:	0	;DONT CHANGE ORDER, SEE  SEARC+3
SYL:	0
LWT:	0
TEM2:	0
FRASE1:
TEM3:	0
DENDDT:	0

INSXCT:	XCT	I.NST		;SOME STORAGE FOR $X SINGLE STEP FEATURE.
I.NST:	0
I.NSTAC:0
I.NSTEA:0
I.NSTPC:0
SAV0:	0
XCTS:	0
XTEM:	0
FLAGS:	0
LOCSAV:	0

GETFLG:	0			;non zero once we've tried to auto-open a program

FSV:	0
FHTTMP:	0	;TEMP CELL FOR FLOATING POINT VALUE ACCUMULATION
FHDTMP:	0	;TEMP CELL FOR FLOATING POINT VALUE ACCUMULATION
SYM:	0
SPSAV:	0	;POINTER TO LAST SYMBOL TYPED
DEFV:	0
ULIMIT:	0
LLOC:	0
LLOCO:	0
SAVLOC:	0
IOTFLG:	0
DINIDN:	0	;SET TO -1 IF KEPTAD HAS EVER BEEN SET UP
KLFLG:	0	;SET TO -1 IF EXECUTING DDT ON A KL10
DDTPEN:	0	;PTR to DDT's special page's entry in EXPGT
KEXPGT:	0	;SET TO CORE ADDRESS OF THE EXEC PAGE TABLE (section 0)
KEPTAD:	0	;SET TO THE CORE ADDRESS OF THE KL10 EPT (EXEC PROCESS TABLE)
KLTMON:	0	;STATE OF TTY MONITOR MODE (RESTORED WHEN LEAVING DDT)
SVKLP:	0	;SAVE CONI KLPAG HERE
SYMP:IFN UEDDTS,<EXCSYM;	SO WE CAN DEBUG IT>	XWD PPID,JOBSYM

IFN P2SYS,<
SP2NUM:	0	;SAVED VALUE OF P2NUM ON ENTRY TO DDT
>;IFN P2SYS

IFN EDDT&1,<
 IFN FTSCTY,<
SCNTMO:	0	;Number of time outs while doing output to scanner CTY
SCNINP:	0	;Number of input chars ignored while doing output to scanner
SCNREP:	0	;Number of failures to get reply from DCA
SCNPOR:	0	;Number of ints from other ports
SCNOUP:	0	;Number of output interrupts seen when checking input
 >;IFN FTSCTY
DDTETO:	0	;Number of times DTE timed out on us
↑PROCPC:0	;PC TO CONTINUE AT FOR $P.  STORE PC HERE AND THEN JUMP TO DDT
>;IFN EDDT&1

IFE EDDT&1,<
GOTALT:	-1	;LH IS -1 IF WE HAVEN'T SAVED USER'S TABLE AND SET SPCBRK
		;RH IS -1 IF LAST CHAR SEEN WAS ALTMODE--ACTIVATE ON NEXT CHAR
USRLCH:	-1		;USER LINE CHARACTERISTICS SAVED HERE ON ENTRY TO DDT
USRACT:	777777,,777777	;USER SETACT TABLE SAVED HERE ON ENTRY TO DDT
	777700,,037600
	000000,,374000
	000007,,600000
;DDT's special activation table!
;Don't activate on operators, only on commands that don't require altmode.
;If you change this table, you should change the copy in UP2DDT[SS,SYS]/2P/31L.
DDTACT:	777777,,777764	;Don't activate on space, double quote, number-sign
	000100,,032400	;Do activate on /:;=?
	000000,,374000	;Do activate on [\]↑← and left quote
	000001,,400020	;Don't activate on BS -- BSACT gives us BS in empty line
>;IFE EDDT&1
;BP1 BP1 B1INS BPN

	SUBTTL	DDT - BREAKPOINT LOGIC

COMMENT %

THE LISTING OF THE FOLLOWING SOURCE CODE IS OMITTED FOR YOUR READING PLEASURE:

BP1:	REPEAT NBP,<
	0		;JSR TO HERE FOR BREAKPOINT
	JSA T, BCOM
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
	0
>

%

	XLIST

BP1:	REPEAT NBP,<
	0		;JSR TO HERE FOR BREAKPOINT
	JSA T, BCOM
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
	0
>

	LIST

B1INS←←BP1+2
BPN←←.-4		;ADDRESS OF THE LAST BREAKPOINT

;BCOM BCOM3 BCOM2 NOBREAK LEAV1 PROC1 LEAV BREAK XEC0 XEC1 XEC2 DOITA DOITC DOITB JMP

;BCOM, XEC0 - BREAKPOINT AND EXECUTE LOGIC

BCOM:	0			;BREAKPOINT LOGIC
	POP	T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI	T,B1SKP-B1INS+1(T)
	HRRM	T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI	T,B1CNT-B1SKP(T)
	HRRM	T,BCOM2		;PROCEED COUNTER SETUP
	MOVE	T,BP1-B1CNT(T)	;GET PC OF TRAP
IFN EDDT&1,<	TLZ T,010000	;TURN OFF USER MODE BIT>
	HLLM	T,LEAV1		;SAVE FLAGS FOR RESTORING
	EXCH	T,BCOM		;RESTORE T
BCOM3:	SKIPN	B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	JRST	BCOM2		;THERE IS NO CONDITIONAL INSTRUCTION
	XCT	@BCOM3		;EXECUTE THE COND. INSTR.  ALL ACS ARE USER'S
	JRST	NOBREAK		;DON'T BREAK IF NO SKIP.
BCOM2:	SOSG	B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST	BREAK		;PROCEED COUNTER NON POSITIVE - TAKE A BREAK!
NOBREAK:
	MOVEM	T,AC0+T
	LDB	T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL	T,264			;JSR
	CAILE	T,266			;JSA,JSP
	TRNN	T,700			;UUO
	JRST	PROC1			;MUST BE INTERPRETED
	CAIE	T,260			;PUSHJ
	CAIN	T,256			;XCT
	JRST	PROC1			;MUST BE INTERPRETED
	MOVE	T,AC0+T
	JRST	2,@LEAV1		;RESTORE FLAGS, GO TO LEAV

LEAV1:	XWD	0,LEAV			;FLAGS STORED IN LH.

PROC1:	MOVE	T,AC0+T			;HERE TO INTERPRET INSTR.
	JSR	SAVE
	 JFCL
	JRST	PROC2

LEAV:	0			;INSTRUCTION MODIFIED
	JRST	@BCOM		;DIRECT RETURN
	AOS	BCOM		;INSTRUCTION SKIPPED.
	JRST	@BCOM

BREAK:	JSR	SAVE		;HERE TO TAKE A BREAK
	 JRST	BREAKA
	JRST	BREAKB


;THIS CODE GETS US OUT OF DDT AND BACK IN FOR $X AND FOR $G
XEC0:	MOVEM	T,TEMDDT	;SAVE INSTRUCTION TO XCT
	PUSHJ	P,CRF		;TYPE CRLF
	PUSHJ	P,TTYLEV	;RESTORE STATE OF TTY
	PUSHJ	P,INSRTB	;REINSERT BREAKPOINTS
	MOVE	W,TEMDDT	;IN CASE OF INTERUPTS (JS STUFF)
	JSP	T,RESTORE	;RESTORE WILL XCT W
XEC1:	 JRST	XEC2		;USED AT PROC0  (NON-SKIP)
	JSR	SAVE		;(SKIP)
	 PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	PUSHJ	P,CHKSYM	;REINITIALIZE SYMBOL TABLE STUFF
	MOVEI S,[ASCIZ /<SKP>
/]
	PUSHJ P,ASCOUT		;A MUCH BETTER WAY TO SAY IT SKIPPED
	JRST	DD1

XEC2:	JSR	SAVE		;NON-SKIP RETURN FROM XCT'ED INSTR. OMIT EXTRA CRLF
	 PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	PUSHJ	P,CHKSYM
	JRST	DD1

; This code for single step logic (pg. 35-6)
; Enter with I.NST containing instruction to be executed,
;  INSXCT containing an XCT (either EXEC or normal) which will
;  be stored in the appropriate XCTBUF. ?This scheme hopefully
;  takes care of the EXEC XCT problem.

DOITA:	MOVEM	F,SAV0
	PUSHJ	P,TTYLEV
	PUSHJ	P,INSRTB
	MOVE	W,INSXCT
	JSP	T,RESTOR
	 JRST	DOITB		;INSTRUCTION DIDN'T SKIP
DOITC:	JSR	SAVE		;Skipped
	 PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	PUSHJ	P,CHKSYM
	MOVEI S,[ASCIZ /<SKP>
/]
	MOVE F,SAV0
	TLNN F,CCF		; Don't print if $$X
	PUSHJ P,ASCOUT		;A MUCH BETTER WAY TO SAY IT SKIPPED
	JRST	SKIP%

DOITB:	JSR	SAVE
	 PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	PUSHJ	P,CHKSYM
	JRST	NOSKIP

; Control is transferred to JMP whenever a conditional jump jumps.
;  It returns to the $X code to simulate the jump.
JMP:	JSR	SAVE
	 PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	PUSHJ	P,CHKSYM
	JRST	JMP1
;SAVE SAV1 SAVX SAV1A SAV5 XCTBUF RESTORE RESTR1 RES3 RES2

	SUBTTL	SAVE AND RESTORE ACS AND PI SYSTEM

SAVE:	0		;SAVE THE ACS AND PI SYSTEM
	SKIPN SARS	;SKIP IF ACS ARE ALREADY SAVED
	JRST SAV1	;NOPE
	AOS SAVE	;SKIP RETURN INDICATES WE DON'T REMOVE BREAKPOINTS
	JRST SAV5	;CONTINUE IN SAVE

SAV1:
IFN EDDT&1,<
	CONI APR,SAVAPR		;SAVE APR CONI
	CONI PI,SAVPI		;SAVE OF PI SYSTEM
	CONO PI,@SAVPI+1	;SET STATE OF PI SYSTEM (CH 1-7 OFF)
IFE EDDT&40,<
>;IFE EDDT&40
>;IFN EDDT&1
	MOVEM 17,AC17			;STUFF THE ACS
	HRRZI 17,AC0
	BLT 17,AC0+16

IFN EDDT,<
NOKL10,<
IFE P2SYS,<	;NO DDT MAPPING ON P2
IFE EDDT&21-21,<
	MOVE T,BBN71		;get ptr to PSB, assuming this is a KA
	ANDI T,3777		;just page table page number
	LSH T,9			;make word address
	SUBI T,3000		;pre-calcuate PSB-EXPGT
	MOVEM T,PSBEXP		;remember for later
	SUBI T,PSB-3000		;calculate real.PSB - WAITS.PSB
	MOVEM T,PSBPSB		;remember for SWPDEP
	MOVEI T,3000		;get ptr to EXPGT, assuming this is a KA
	MOVEM T,KEXPGT		;store KA/BBN EPT address
;the next instruction is to make sure the deposit works on a KA even if
;the PSB is somewhere other than where the system expects it to be, because
;"DDTEXP" is defined in terms of where WAITS puts the PSB.
IFGE DDTPGE-600,<	;need this if the temp page for DDT is in PSB (600 or more)
	ADD T,PSBPSB		;adjust expgt address by correction to real PSB
>;IFGE
	ADDI T,DDTEXP
	TLZE T,-1		;make sure no funny business
	HALT .+1
	MOVEM T,DDTPEN		;store pointer to DDT's special page's map entry
>;IFE P2SYS
>;IFE EDDT&21-21
>;NOKL10
	SETZM KLFLG		;ASSUME NOT A KL10
	MOVE T,[T,,T]
	BLT T,T
	CAMN T,[T,,T]
	JRST SAV1A
	SETOM KLFLG		;THIS IS A KL10
	CONI KLPAG,T		;GET EBR.
	MOVEM T,SVKLP		;SAVE STATE OF KL10 PAGER
	CONSZ APR,SWEEPB	;WAIT FOR SWEEP BUSY TO FALL
	JRST .-1
	CONSO KLPAG,600000	;IS THE CACHE ON ALREADY?
	JRST SAVX		;NO.
	BLKO CCA,		;VALIDATE CORE
	CONSZ APR,SWEEPB
	JRST .-1
SAVX:
IFE EDDT&21-21,<
IFN FTDMAP,<
	TRC T,60000		;make sure pager and tops-20 paging are on
	TRCE T,60000		;skip if both were on
	SKIPE INDDT		;skip if mapped out
	JRST SAVY		;all OK
	JSP TAC,DDTMES
	 ASCIZ/KL pager (or TOPS-20 mode) is off, will turn it on to map DDT in.
You'll need to turn it on too to run WAITS some more -- use CONO KLPAG,@KLPCON.
/
	MOVE T,KLPCON		;get what system wants pager set to
>;IFN FTDMAP
>;IFE EDDT&21-21
SAVY:	TRZ T,600000		;CLEAR CACHE LOOK AND LOAD
	CONO KLPAG,(T)		;TURN OFF CACHE.
	DATAI CCA,0		;SWEEP CACHE.  INVALIDATE ALL.
	CONSZ APR,SWEEPB	;WAIT FOR SWEEP BUSY TO FALL
	JRST .-1
	ANDI T,17777		;MASK EBR ONLY
	LSH T,9			;SHIFT TO MAKE A CORE ADDRESS
	MOVEM T,KEPTAD		;SAVE EPT ADDRESS.
IFKL10,<
IFN FTKLB,<
	MOVE T,KLESEC(T)	;get ptr to EXPGT (for section 0)
	LSH T,9			;make word address
	MOVEM T,KEXPGT		;save, in case it isn't where WAITS puts it
>;IFN FTKLB
IFE FTKLB,<
PRINTX How do we find the EXPGT on KL model A??
	MOVEI T,EXPGT		;use constant till we figure out how to read it
	MOVEM T,KEXPGT		;save for later
>;IFE FTKLB
	ADDI T,DDTEXP
	TLZE T,-1		;make sure no funny business
	HALT .+1
	MOVEM T,DDTPEN		;store pointer to DDT's special page's map entry
>;IFKL10
>;IFN EDDT

SAV1A:	MOVE T,SAVE			;GET THE PC FLAGS
	HLLM T,SAVPI			;STUFF IN LH OF PI CONI WORD
SAV5:	SETOM SARS			;FLAG THAT THE ACS HAVE BEEN SAVED
	MOVEI P,PS			;STACK

IFE P2SYS,<
IFN <FTDMAP!FTF2>&EDDT&1,<
;F2 needs GETDDT regardless of FTDMAP
	PUSHJ P,GETDDT	;MAP DDT INTO EXEC
>;IFN <FTDMAP!FTF2>&EDDT&1
>;IFE P2SYS

IFE EDDT,<		PUSHJ P,TTYRET	;USER MODE. TTY TO DDT MODE >;IFE EDDT

	MOVEI F,0
	MOVE T,[SCHM,,SCH]
	BLT T,ODF			;LOAD THE ACS WITH MODE SWITCHES
	JRST @SAVE			;RETURN

;THE XCTBUF IS 8 COPIES OF THE PROCEED FROM BREAKPOINT (AND EXECUTE)
;CODE.  8 COPIES CORRESPOND TO THE 7 PI LEVELS PLUS NO PIS IN PROGRESS
;LEVEL.
;ONCE THE PI SYSTEM IS RESTORED, AN INTERRUPT MAY HAPPEN THAT STARTS DDT
;AT SOME HIGHER PRIORITY PI CHANNEL.  IF THIS OCCURS, EXITING THAT HIGHER
;CHANNEL WILL USE A DIFFERENT XCTBUF AND THUS ENSURE THAT ALL INSTRUCTIONS
;HAPPEN CORRECTLY, IN THEIR CORRECT PI CHANNELS.

XCTBUF:
REPEAT <EDDT&1*7>+1,<
	CONO	PI,@SAVPI		;RESTORE STATE OF PI SYSTEM
	0				;INSTRUCTION TO EXECUTE
	SKIPA				;DIDN'T SKIP
	AOS .+1				;INSTR. DID SKIP
	JRST .				;SET ADDRESS TO RETURN TO.
	0				;USED TO SIMULATE PUSHJ
	>

XCTQ←←6		;SIZE OF EACH ENTRY IN XCTBUF

;RESTORE - ENTER WITH T CONTAINING THE RETURN ADDRESS AND W AN INSTRUCTION TO XCT
RESTORE:SETOM	TEM3		;RESTORE ACS AND PI SYSTEM (EXIT DDT)
RESTR1:	HRRM	T,SAVE		;HERE TO DO $P TO PROCEED AT A PUSHJ.  TEM3 IS ZERO

IFN 0&EDDT&1,<			;SYS WRITE REF KLUDGE HAS BEEN REMOVED.
	MOVE	T,SAVAPR
	ANDI	T,SYSCLB!7	
	TRNN	T,SYSCLB
	CONO	APR,CLRCLB(T)	;IF THE SYSTEM WASN'T CLOBBERED WHEN WE CAME 
				;IN, THEN IT ISN'T CLOBBERED NOW.
>

	MOVE	T,SAVPI		;PC FLAGS,,PI STATE
	HLLM	T,SAVE		;STORE PC FLAGS
	MOVEM	W,TEMDDT	;STORE INSTRUCTION TO XCT
	MOVEI	W,XCTBUF	;ASSUME NOT PI IN PROGRESS.

IFN EDDT,<
	AND	T,SAVPI+1	;TURN ON ONLY THOSE CHANNELS WE TURNED OFF
	ANDI	T,177
	IORI	T,2000		;TURN ON CHANNELS
	EXCH	T,SAVPI		;STORE PI CONO BITS.  GET IN PROGRESS BITS.

;WHICH XCTBUF USED DEPENDS ON HIGHEST CHANNEL IN PROGRESS WHEN WE STARTED.
ZZ←←7
REPEAT 7,<	TRNE	T,1⊗<17-ZZ>
		MOVEI	W,XCTBUF+<XCTQ*ZZ>
ZZ←←ZZ-1>;REPEAT 7

>;IFN EDDT

	HLL	W,SAVE		;GET THE PC FLAGS
	MOVEM	W,RES2		;STORE FLAGS,,ADDRESS OF XCTBUF
IFE EDDT,<AOS	RES2>		;IN USER MODE, SKIP THE CONO PI
	MOVE	T,TEMDDT	;GET THE INSTR. TO XCT
	MOVEM	T,1(W)		;STORE IT WHERE WE'LL RUN OVER IT
	HRRZ	T,SAVE		;GET THE RETURN ADDRESS
	HRRM	T,4(W)		;STUFF IT IN THE JRST
	SKIPGE	TEM3		;IS THIS $P AT A PUSHJ?
	JRST	RES3		;NOPE.
	MOVE	T,BCOM		;GET THE ADDRESS AND FLAGS FROM BREAKPOINT
	MOVEM	T,5(W)		;STUFF IN XCTBUF
	MOVEI	T,5(W)		;CHANGE THE ADDRESS OF THE PUSH TO POINT
	HRRM	T,1(W)		;  AT THE PC AND FLAGS.
				;PUSHJ BECOMES A PUSH AND A JRST
RES3:
IFN EDDT&20,<
	MOVE	TAC,MONPTR	;RECOMPUTE MONITOR CHECKSUM
	PUSHJ	P,CHECK
	SKIPN	STRING		;ONLY IF COMMANDS COMING FROM KEYBOARD!
	MOVEM	TAC1,MONSUM

IFN FTHSYS,<
	MOVE	TAC,HMNPTR	;RECOMPUTE CHECKSUM OF HIGH PART.
	PUSHJ	P,CHECK
	SKIPN	STRING
	MOVEM	TAC1,HMNSUM
>;FTHSYS

IFE P2SYS,<
IFN FTDMAP!FTF2,<
;F2 needs GETBAK regardless of FTDMAP
	PUSHJ	P,GETBAK	;RESTORE EXEC MAP, REMOVING DDT FROM MAP
>;IFN FTDMAP!FTF2
>;IFE P2SYS
>;IFN EDDT&20
	MOVSI	17,AC0		;RESTORE USER ACS
	BLT	17,17
	SETZM	SARS
IFE EDDT&1,<	JRST	2,@RES2	;EXIT IF USER DDT.>;IFE EDDT
IFN EDDT&1,<
	SKIPN	KLFLG		;YET MORE WORK TO DO IF THIS IS A KL10.
	JRST	2,@RES2		;RESTORE FLAGS AND JUMP TO XCTBUF
	MOVEM	1,TEM3
	CONO	APR,027760	;CLEAR ALL FLAGS
	LDB	1,[POINT 12,SAVAPR,17]	;GET ORIGINAL APR ENABLES
	CONO	APR,100000(1)		;SET ORIGINAL ENABLES
	LDB	1,[POINT 12,SAVAPR,35]	;GET ORIGINAL FLAGS AND PIA
	IORI	1,20			;SET SWEEP DONE.  CACHE IS CLEAN.
	CONO	APR,10000(1)		;SET ORIGINAL FLAGS AND PIA
	MOVE	1,TEM3
	CONO	KLPAG,@SVKLP		;RESTORE PAGER TO ORIGINAL STATE
	JRST	2,@RES2
>;IFN EDDT&1

RES2:	0
;⊗ NOTDDT KEEPIN INDDT SYMLOC EXMMAP DDTXCOR DDTPGS DDMEND DDPEND DDTBLK ONCBLK MDDBLK P1EBLK DDSTSW DDS170 MAPON PSBPSB PSBEXP NPFPI DDSPFW DDSFFG DDSFPC DDSNPC SKLUPT DDTSUM SWPWRD LDDTMAP DDTMAP SYSMAP

	SUBTTL	EXEC DDT - MAPPING DDT CODE
IFE P2SYS,<	;NO DDT MAPPING ON P2
IFE EDDT&21-21,<
COMMENT ⊗
INITIALIZATION ROUTINES FOR MAPPING DDT
MAPPING DDT CONTROL CELLS AND THEIR MEANINGS:

NOTDDT/		-1	FLUSH DDT ENTIRELY

KEEPIN/		-1	DDT STAYS IN CORE ALWAYS
		0	DDT IS MAPPABLE

INDDT/		-1	DDT IS IN CORE
		0	DDT IS ON mapped out

EXMMAP/		0	Examine/deposit at actual physical address
		-1	Examine/deposit via exec map, use SYSMAP for DDT/EXPGT shadow
		-2	Examine/deposit via exec map, ref DDT instead of shadow
		n	(positive) Examine/deposit starting at phys page n

DDTXCOR/	-1	DDT IS MAPPED OUT IN EXTRA CORE

DDTFLG/		0	THIS IS -1 WHEN DDT IS ACTIVE
			(KEEPS P2 FROM MONITOR CHECKSUMMING)
end of comment ⊗

↑↑NOTDDT:	0	;START WITH DDT

↑↑KEEPIN:	-1	;DDT STAYS IN AT LEAST UNTIL THE FIRST START-UP

↑↑INDDT:	-1	;DDT STARTS OUT IN CORE!

↑↑SYMLOC:	0	;SET BY BEGIN TO CONTENTS OF DDTSYM BEFORE ONCE ONLY CODE

↑↑EXMMAP:	-1	;DEFAULT IS TO USE THE MAP FOR EXAMINE/DEPOSIT

↑↑DDTXCOR: IFE FTIP,<-1>;Not initialized, assume want DDT remapped.
	   IFN FTSEPONCE,<-1> ;can move DDT/symbols since DDT&ONCE are at end
IFE FTSEPONCE,<IFN FTIP,<0>> ;don't move DDT/symbols if IP/TCP is inbetween.

↑↑DDTPGS:	0	;NUMBER OF PAGES IN DDT BEING MAPPED
DDMEND:		0	;ONE GREATER THAN LAST ADDRESS IN DDT PAGES BEING MAPPED
DDPEND:		0	;1+ADDRESS OF LAST EXPGT ENTRY FOR DDT PAGES BEING MAPPED
IFN FTDMAP,<
MDDBLK:		-1	;number of block called MDDT, for FNDSYM
DDTBLK:		-1	;number of block called DDT, for FNDSYM
ONCBLK:		-1	;number of block called ONCE, for FNDSYM
;Flushing P1EBLK symbols seems to flush AC definitions, I suppose cause
;they match those in the WAITS program.
;P1EBLK:		-1	;number of block called P1END, for FNDSYM
>;IFN FTDMAP

NOKL10,<
DDSTSW:		0	;SAVED TRAP STATUS WORD
DDS170:		0	;SAVE PAGE FAULT TRAP LOCATION
↑↑MAPON:	0	;SET TO -1 FOR DDT AFTER SYSINI HAS TURNED ON MAP.
			;MAPON IS NEVER CLEARED, ALTHOUGH COULD BE CLEARED
			;MANUALLY IF THE MAP IS TURNED OFF MANUALLY
			;FOR SOME REASON.
PSBPSB:		0	;real.PSB - WAITS.expected.PSB adjustment
PSBEXP:		0	;real.PSB-EXPGT for KA is remembered here
>;NOKL10

IFKL10,<
NPFPI←←10	;nbr of PI levels (including UUO level) we save these PF cells for)
DDSPFW:	BLOCK NPFPI	;SAVED PAGE FAIL WORD (uuo level, ch1, ..., ch7)
IFN FTKLB,<
DDSFFG:	BLOCK NPFPI	;SAVED PAGE FAULT FLAGS (uuo level, ch1, ..., ch7)
>;IFN FTKLB
DDSFPC:	BLOCK NPFPI	;SAVE PAGE FAULT PC WORD (uuo level, ch1, ..., ch7)
DDSNPC:	BLOCK NPFPI	;SAVE PAGE FAULT NEW PC WORD (uuo level, ch1, ..., ch7)
SKLUPT:	BLOCK NPFPI	;Set to core address of KL UPT (uuo level, ch1, ..., ch7)
>;IFKL10

↑↑DDTSUM:	0	;CHECKSUM OF DDT

SWPWRD:		0	;PLACE TO KEEP WORD WE ARE DEPOSITING!

LDDTMAP←←120	;Estimate of size of DDTA through end of symbols
↑↑DDTMAP:BLOCK LDDTMAP	;EXPGT pointers to DDT in extra core are saved here
SYSMAP:	BLOCK LDDTMAP	;EXPGT pointers from system shadow of DDT saved here
;DDTA ;⊗ CDDTA DDTINI DDXINI SETXC2 SETXC2 DDXILP SETXCT DDXLUZ DDXLU2 DDXLU3

IFN FTSEPONCE,<
;Make "DDTA", which must be on a page boundary, get computed by the loader,
;since DDT is no longer an absolute assembly.  DDTA is the first word of
;the first page starting at or after RDDTA (which used to be called DDTA).
;(The "1*" in the following expression prevent the parens from being
;taken as holding an index register value, without changing the expr value.)
DEFINE DDTA<1*((RDDTA+777)&777000)> ;first loc of DDT to be mapped out
>;IFN FTSEPONCE
↑CDDTA:	DDTA			;used by UUOCON, avoid loader bug

;INITIALIZE MAPPING DDT!!!

;Here from SYSINI when starting WAITS.
↑DDTINI:SETOM EXMMAP		;DEFAULT IS EXAMINE MAPPED
	SETOM INDDT		;DDT IS IN NOW
IFN FTSEPONCE,<
	MOVEI TAC,DDTA
	MOVEM TAC,165		;set up pointer for UEDDT
IFKL10,<
	MOVEI TAC,DDT		;set up pointer for KLDCP DDT command
	MOVEM TAC,KLEPT+441	; so that it will start PDP-10 DDT
>;IFKL10
>;IFN FTSEPONCE
	MOVE AC2,DDTSYM
	MOVEM AC2,SYMLOC	;REMEMBER DDTSYM WHILE SYMBOLS AND DDT ARE OUT
	SETOM KEEPIN		;ASSUME NOT MAPPING DDT OUT TODAY
	HLRE TAC,DDTSYM
	MOVMS TAC
	ADD TAC,DDTSYM		;MAKE POINTER TO JUST BEYOND SYMBOLS
	SKIPN TAC		;SKIP IF ANY SYMBOLS
	MOVEI TAC,DDTEND	;POINTER TO JUST BEYOND DDT
	HRRZM TAC,SYSSIZ	;THAT'S WHERE THE SYSTEM ENDS
	POPJ P,

IFN FTDMAP,<
;Code on this page uses compiled-in addresses of KLUPT and EXPGT
;because here only with WAITS running.

;Move DDT to extra core, if desired, from where it can be mapped in when needed.
DEFINE EXDDTA,<1*(DDTA⊗-9+DDTAPS)> ;Offset of DDTA's place within EXPGT
↑DDXINI:SKIPN NOTDDT		;No DDT, no moving
	SKIPN DDTXCOR		;Want DDT moved and mapped?
	POPJ P,			;Nope
	PUSHJ P,SRTCHK		;set up SMB (for BLKNAM) -- skip if symbols unsorted
	 JFCL			;don't care whether symbols are sorted
	MOVE T,[RADIX50 0,MDDT]
	PUSHJ P,BLKNAM		;get block nbr for MDDT's block, skip on error
	 MOVEM T,MDDBLK		;remember block nbr for FNDSYM
	MOVE T,[RADIX50 0,DDT]
	PUSHJ P,BLKNAM		;get block nbr for DDT's block, skip on error
	 MOVEM T,DDTBLK		;remember block nbr for FNDSYM
	MOVE T,[RADIX50 0,ONCE]
	PUSHJ P,BLKNAM		;get block nbr for ONCE's block, skip on error
	 MOVEM T,ONCBLK		;remember block nbr for FNDSYM
;	MOVE T,[RADIX50 0,P1END]
;	PUSHJ P,BLKNAM		;get block nbr for ONCE's block, skip on error
;	 MOVEM T,P1EBLK		;remember block nbr for FNDSYM
	HLRE DDB,DDTSYM		;HOW MANY PAGES WE GET IN MAP FOR MOVED DDT
	MOVN DDB,DDB
	ADD DDB,DDTSYM		;ONE PAST LAST SYMBOL
	MOVEI DDB,-DDTA+777(DDB) ;SIZE OF DDT+SYMBOLS+777
	LDB DDB,[POINT 9,DDB,26] ;NUMBER OF PAGES IN DDT+SYMBOLS
	MOVEM DDB,DDTPGS	;REMEMBER NUMBER OF PAGES FOR LATER
	CAILE DDB,LDDTMAP	;Do we have enough room to save EXPGT entries?
	JRST DDXLUZ		;Nope, can't map DDT out -- say so.
;This code uses compiled in address of EXPGT because here only with WAITS running.
	ADDI DDB,EXPGT+EXDDTA	;Calculate address beyond last DDT EXPGT entry
	MOVEM DDB,DDPEND	;Remember for SWPEXM
	MOVE DDB,DDTPGS		;Number of mapped pages again
	LSH DDB,9		;Make it words
	ADDI DDB,DDTA		;Calculate address beyond last mapped DDT word
	MOVEM DDB,DDMEND	;Remember for SWPEXM
	MOVEI TAC1,DDTA⊗-9	;P1 VIRTUAL FIRST PAGE OF MAPPABLE DDT
	MOVE DDB,DDTPGS		;Number of pages for next routine to get
	PUSHJ P,GTXCOR		;GET PHYSICAL PAGES FOR MOVED DDT
	 JRST DDXLU3		;FAILED
	MOVN TAC,DDTPGS		;NUMBER OF pages WE JUST TOOK FROM USER CORE
	LSH TAC,9		;make it pages removed from user core
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
NOKL10,<PUSH P,BBN70
	MOVE TAC,[JRST SETXCT]
	MOVEM TAC,BBN70
>;NOKL10
IFKL10,<PUSH P,KLUPT+KLPFNP
IFN FTKLB,<
	MOVEI TAC,SETXCT
>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,[PCU,,SETXCT]
>;IFE FTKLB
	MOVEM TAC,KLUPT+KLPFNP
>;IFKL10
	MOVE TAC,[PWRT,,DDTA⊗-9] ;PAGE TABLE POINTER TO DDT SOURCE
	MOVE TAC1,[DDTEXP⊗9,,DDTA] ;INITIAL BLT POINTER (DDTA mapped to extra core)
	MOVE AC2,DDTPGS		   ;NUMBER OF MOVED PAGES IN DDT+SYMBOLS
NOKL10,<CONO PAG,0		;LOAD MBR
	CONO PAG,7		;TURN ON MAPPING
SETXC2:	CONO PAG,1		;CLEAR ARS MAPPING EXEC PAGES
>;NOKL10
IFKL10,<
;This code uses compiled in address of EXPGT because here only with WAITS running.
IFE FTKLB,<
	BLKI KLPAG,[EXPGT⊗-9 ↔ -1] ;SET EXPGT AND USPGT POINTERS IN AC BLOCK 6
>;IFE FTKLB
IFN FTKLB,<
	MOVE AC1,[PWRTC,,EXPGT⊗-9] ;set writeable, cacheable section 0
	MOVEM AC1,KLEPT+KLESEC	;store exec section 0 pointer
>;IFN FTKLB
SETXC2:	CONO KLPAG,@KLPCON
>;IFKL10
	MOVEM TAC,EXPGT+DDTEXP	;CLOBBER MAP FOR PAGE DDTEXP TO DDT SOURCE
	MOVE AC1,TAC1		;GET BLT POINTER
	BLT AC1,777(TAC1)	;MOVE PAGE OF LOW CORE INTO EXTRA CORE
	ADDI TAC1,1000		;UPDATE DEST OF BLT (SOURCE IS DDTEXP⊗9)
	ADDI TAC,1		;UPDATE PAGE TABLE POINTER TO DDT SOURCE
	SOJG AC2,SETXC2		;LOOP, COUNTING DOWN PAGES MOVED.
;AS A RESULT OF THE ABOVE, DDTA THRU END OF SYMBOLS IS COPIED TO EXTRA CORE.
NOKL10,<
PRINTX If DDT's code and symbols go across addr 600000, then this won't work!!!
;All of DDT and symbols must be either completely above or completely below 600000.
>;NOKL10
	MOVE TAC,DDTPGS		;Number of pages of mapped DDT
;This code uses compiled in address of EXPGT because here only with WAITS running.
	MOVE AC2,[EXPGT+EXDDTA,,DDTMAP] ;Save the map pointers to extra core
	BLT AC2,DDTMAP-1(TAC)	;Copy part of EXPGT so we can restore it at GETDDT
	SETZM EXPGT+EXDDTA	;Now clear out map of mapped DDT (going)
	MOVE AC2,[EXPGT+EXDDTA,,EXPGT+EXDDTA+1] ;(going)
	CAILE TAC,1		;(No BLT if only one page -- fat chance!)
	BLT AC2,EXPGT+EXDDTA-1(TAC) ;DDT is now mapped out (gone)
	SETZM SYSMAP		;Now clear our "remembered" version of system's
	MOVE AC2,[SYSMAP,,SYSMAP+1] ; map pointers from EXPGT, just for good
	BLT AC2,SYSMAP+LDDTMAP-1    ; measure, although shouldn't need to (DRD)
	ADDM TAC,LOFREE		;We're giving low core this many more free pages!
	MOVEI AC2,0		;Now we're going to zero core table for freed pages
	MOVEI DSER,EXDDTA	;Start freeing core at this physical page
DDXILP:	DPB AC2,COREP		;Clear core use code
	ADDI DSER,1		;Next page
	SOJG TAC,DDXILP		;Loop thru all of DDTs mapped pages
NOKL10,<POP P,BBN70
	CONO PAG,1		;CLEAR ARS MAPPING EXEC PAGES
>;NOKL10
IFKL10,<POP P,KLUPT+KLPFNP
	CONI KLPAG,AC2
	CONO KLPAG,(AC2)	;CLEAR ARS
>;IFKL10
	SETZM KEEPIN		;Now OK to map DDT out to extra core
	MOVEI TAC,DDGVUS
	MOVEM TAC,SYSSIZ	;GIVE LOSERS ALL THIS CORE!
	PUSHJ P,SETTOP		;Set SYSTOP and SYSPAG from TAC
	SETZM INDDT		;DDT no longer mapped in
	SETZM DDTSYM		;NO SYMBOLS, NOW
;(FOR UEDDT, USE SYMLOC, NOT DDTSYM)
	POPJ P,

;Here if get page fail trap while moving DDT to extra core.
;Give up on extra core and leave DDT in first moby.
SETXCT:
NOKL10,<SUB P,[1,,1]
	POP P,BBN70
>;NOKL10
IFKL10,<SUB P,[1,,1]
	POP P,KLUPT+KLPFNP
>;IFKL10
	JRST DDXLU2

DDXLUZ:	JSP TAC,DDTMES
	ASCIZ /DDT plus symbols too big for DDTMAP table -- can't map DDT out;
increase LDDTMAP in DDT and recompile.
/
DDXLU2:	SETOM KEEPIN		;Not mapping DDT out after all
	SETZM DDTXCOR
	SETZM DDTPGS		;No pages mapped (DRD)
	SETOM MDDBLK		;forget block nbr of MDDT (type out its symbols)
	SETOM DDTBLK		;forget block nbr of DDT (type out its symbols)
	SETOM ONCBLK		;forget block nbr of ONCE (type out its symbols)
;	SETOM P1EBLK		;forget block nbr of P1END (type out its symbols)
	POPJ P,

DDXLU3:	JSP TAC,DDTMES
	ASCIZ /Can't find enough extra core for mapping DDT out of low moby; will keep there.
/	;Also, we have lost (DDTPGS)-(DDB) extra core pages!
	JRST DDXLU2
>;IFN FTDMAP
;GETDDT GETDL2 GETDLZ GTDDMP DDTMES PINDEX PINDE2

;GETDDT   CALLED FROM SAVE TO GET DDT INTO CORE!  DDTMES

GETDDT:
NOKL10,<
	MOVE TAC,PSB+TSW
	MOVEM TAC,DDSTSW	;SAVE TRAP STATUS WORD
	MOVE TAC,BBN70
	MOVEM TAC,DDS170	;SAVE 170 (TRAP LOCATION)
	MOVE TAC,[JRST DDTTRP]
	MOVEM TAC,BBN70		;SET UP TRAP LOCATION FOR PAGE FAULTS DURING DDT
>;NOKL10
IFKL10,<
	PUSH P,T
	PUSH P,TT
	PUSHJ P,PINDEX		;get highest in-progess PI channel number into TT
	DATAI KLPAG,T		;find out location of KL UPT
	ANDI T,17777		;just page number
	TRNE T,17000		;better be in section 0
	JRST GETDLZ		;UPT not in section 0!
	LSH T,9			;make word address
	HRROM T,SKLUPT(TT)	;save for restoring these cells on leaving DDT
	MOVE TAC,KLPFW(T)
	MOVEM TAC,DDSPFW(TT)	;SAVE PAGE FAIL WORD
	MOVE TAC,KLPFPC(T)
	MOVEM TAC,DDSFPC(TT)	;SAVE PAGE FAIL PC
	MOVE TAC,KLPFNP(T)
	MOVEM TAC,DDSNPC(TT)	;SAVE PAGE FAIL NEW PC WORD
IFN FTKLB,<
	MOVE TAC,KLPFFG(T)
	MOVEM TAC,DDSFFG(TT)	;SAVE PAGE FAULT FLAGS
	MOVEI TAC,DDTTRP
>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,[PCU,,DDTTRP]
>;IFE FTKLB
	MOVEM TAC,KLPFNP(T)	;SET UP NEW PC WORD FOR PAGE FAULTS DURING DDT
GETDL2:	POP P,TT
	POP P,T
>;IFKL10
IFN FTSUAI,<
	CONO CAR,ONRED		;Turn on the Red light!
>;IFN FTSUAI
	SKIPE INDDT		;IF DDT ALREADY IN ...
	POPJ P,			;...THEN NOTHING ELSE TO DO
IFN FTDMAP,<
	SKIPE DDTXCOR
	JRST GTDDMP		;DDT IS IN HIGH CORE
>;IFN FTDMAP
	JSP TAC,DDTMES
	ASCIZ /CAN'T FIND DDT ANYWHERE
/
	HALT .

IFKL10,<
GETDLZ:	JSP TAC,DDTMES
	ASCIZ /KL UPT is not in Section 0 -- DDT can't change page fault new PC!
/
	HALT GETDL2		;try to go on if he says to
>;IFKL10

IFN FTDMAP,<
;Map DDT back in, replacing piece of the system.
;This code uses compiled in address of EXPGT because here only with WAITS running.
GTDDMP:	MOVE TAC,[EXPGT+EXDDTA,,SYSMAP] ;PREPARE TO SAVE CURRENT EXPGT ENTRIES
	MOVE TAC1,DDTPGS		;Number of entries to save
	BLT TAC,SYSMAP-1(TAC1)		;Copy EXPGT to SYSMAP
	MOVE TAC,[DDTMAP,,EXPGT+EXDDTA] ;Now set up EXPGT with pointers to DDT
	BLT TAC,EXPGT+EXDDTA-1(TAC1)	;COPY DDTMAP to EXPGT
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONO KLPAG,60000+KLEPT⊗-9	;CLEAR PAGER
>;IFKL10
	MOVE TAC,SYMLOC
	MOVEM TAC,DDTSYM		;Now we have symbols mapped in
	SETOM INDDT			;And DDT is mapped in too
	POPJ P,
>;IFN FTDMAP

;DDTMES   TYPES MESSAGE ON CTY
;CALLING SEQUENCE:
;	JSP TAC,DDTMES
;	ASCIZ/MESSAGE/
;	<RETURNS HERE>

DDTMES:	HRLI TAC,(<POINT 7,0>)
	JSR DDTTYPE
	JRST 1(TAC)		;SEE HOW CLEVER WE ARE!!!!

;Put current PI channel number (highest in progress) into TT (0=uuo level).
PINDEX:	PUSH P,TT-1
	CONI PI,TT-1
	ANDI TT-1,77400		;leave only PI in prog flags
	JFFO TT-1,PINDE2
	TDZA TT,TT		;UUO level, return 0
PINDE2:	SUBI TT,=21-1		;turn bit 21 (ch1) into 1
	POP P,TT-1
	POPJ P,
;GETBAK GETBL2 GETBLZ BKDDMP

;GETBAK   CALLED FROM RESTORE TO UPDATE SYMBOL TABLE AND GET USER CORE BACK!

GETBAK:
NOKL10,<MOVE TAC,DDSTSW
	MOVEM TAC,PSB+TSW	;RESTORE TRAP STATUS WORD
	MOVE TAC,DDS170
	MOVEM TAC,BBN70		;AND PAGE FAULT TRAP LOCATION
>;NOKL10
IFKL10,<
	PUSH P,T
	PUSH P,TT
	PUSHJ P,PINDEX		;get highest in-progess PI channel number into TT
	SKIPN T,SKLUPT(TT)	;get back ptr to KL UPT we saved earlier
	JRST GETBLZ		;we never saved a valid ptr!!
	MOVE TAC,DDSPFW(TT)
	MOVEM TAC,KLPFW(T)	;RESTORE TRAP STATUS WORD
	MOVE TAC,DDSFPC(TT)
	MOVEM TAC,KLPFPC(T)	;AND PAGE FAULT PC WORD
	MOVE TAC,DDSNPC(TT)
	MOVEM TAC,KLPFNP(T)	;AND PAGE FAULT NEW PC WORD
IFN FTKLB,<
	MOVE TAC,DDSFFG(TT)	;AND PAGE FAULT FLAGS
	MOVEM TAC,KLPFFG(T)
>;IFN FTKLB
GETBL2:	SETZM SKLUPT(TT)	;forget we knew where UPT was
	POP P,TT
	POP P,T
>;IFKL10
IFN FTSUAI,<
	CONO CAR,OFFRED		;Turn off the Red light!
>;IFN FTSUAI
	SKIPN KEEPIN		;DDT GOING OUT?
	SKIPN INDDT		;AND IN NOW
	POPJ P,			;NO
	SETZM DDTSYM		;NO DDT, NO SYMBOLS.
	SETZM INDDT		;DDT NO LONGER IN CORE
IFN FTDMAP,<
	SKIPE DDTXCOR
	JRST BKDDMP
>;IFN FTDMAP
	HALT .			;CAN'T GET HERE

IFKL10,<
GETBLZ:	PUSH P,TT
	JSP TAC,DDTMES
	ASCIZ /No saved ptr to KL UPT -- DDT can't restore page fault data.
/
	POP P,TT
	HALT GETBL2		;try to go on if he says to
>;IFKL10

IFN FTDMAP,<
;Map the system back in where we had put DDT.
;This code uses compiled in address of EXPGT because here only with WAITS running.
BKDDMP:	MOVE TAC,[SYSMAP,,EXPGT+EXDDTA] ;Want to restore normal EXPGT entries
	MOVE TAC1,DDTPGS		;Number of entries to save
	BLT TAC,EXPGT+EXDDTA-1(TAC1)	;Copy SYSMAP to EXPGT
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONO KLPAG,60000+KLEPT⊗-9	;RESET PAGER
>;IFKL10
	POPJ P,
>;IFN FTDMAP
;⊗ SWPEXM SWPEX3 SWPEX2 SWPDEP XCREXM XCRRTN XCRFIN XCRDEP DDTTR2 DDTTRP MWRIT0 MWRITE MWRITA

;EXAMINE & DEPOSIT ROUTINES FOR MAPPING DDT (FORMERLY SWAPPING DDT)!

;EXAMINE LOCATION (R), RETURN ANSWER IN T.
;CHECKS STATE OF EXMMAP TO SEE WHETHER WE WANT TO DO A MAPPED OR UNMAPPED
;EXAMINE.  IF DOING A MAPPED EXAMINE, OR IF THE MAP IS OFF, THEN THE
;DOUBLE SKIP RETURN IS TAKEN AND THE CALLER IS EXPECTED TO DO THE EXAMINE
;AND T IS PRESERVED (IN CASE CALLED FROM SWPDEP).
;IF EXAMINING PHYSICAL CORE, THE DIRECT RETURN IS TAKEN WITH ANSWER IN T.
;Takes skip return if map is off or if address is an AC; caller should
;do the examine.
SWPEXM:
IFKL10,<CONSO KLPAG,1B22	;YES.  SKIP IF KL10 PAGER IS TURNED ON
	JRST CPOPJ1		;DON'T USE MAP
>;IFKL10
NOKL10,<SKIPN MAPON		;SKIP IF THE BBN PAGER HAS BEEN TURNED ON
	JRST CPOPJ1		;DON'T USE MAP (SYSINI HASN'T TURNED ON MAP YET)
>;NOKL10
	SKIPG EXMMAP		;Not really examining ACs if using special page
	CAILE R,17		;Skip if address is an AC
	CAIA
	JRST CPOPJ1		;LET SOMEONE ELSE FIGURE OUT HOW TO EXAMINE ACS
IFE FTDMAP,<
	SKIPGE EXMMAP		;SKIP UNLESS EXAMINING USING EXISTING MAP
	JRST CPOPJ2
>;IFE FTDMAP
IFN FTDMAP,<
	SKIPL EXMMAP		;SKIP IF EXAMINING USING EXISTING MAP
	JRST SWPEX2		;Examine physical core
	SKIPN DDTXCOR		;Are DDT and symbols mapped in specially?
	JRST CPOPJ2		;Nope
	MOVNI T,1		;If EXMMAP is exactly -1, then must look in shadow
	CAME T,EXMMAP		;But -2 or less means allowed to see DDT itself
	JRST CPOPJ2		;EXMMAP is -2 (or less) -- use real map.
	CAIL R,DDTA		;IS THIS EXAMINE INTO MAPPED DDT'S SHADOW?
	CAML R,DDMEND		;SKIP IF EXAMINING DDT SHADOW
	JRST SWPEX3		;Not examining DDT, see if examining EXPGT
	SUBI R,DDTA		;EXAMINE SHADOW, NOT DDT -- GET OFFSET WITHIN DDT
	MOVE T,R
	LSH R,-9		;FIGURE OUT PAGE NUMBER WITHIN MAPPED SEGMENT
	SKIPN SYSMAP(R)		;skip if any map entry here
	JRST DDTTR2		;no map entry -- say 'Page fault'
	HRRZ R,SYSMAP(R)	;Get physical page number
	LSH R,9			;Turn into word address
	ANDI T,777		;Offset within page
	ADDI R,(T)		;Physical address to examine
	JRST XCREXM		;Go examine physical memory

;This code uses compiled in address of EXPGT because here only with WAITS running
;or with DDPEND zero.  Check for examine of part of system mapped out for DDT.
SWPEX3:	CAIL R,EXPGT+DDTA⊗-9	;IS THIS EXAMINE INTO EXPGT FOR DDT'S SHADOW?
	CAML R,DDPEND		;SKIP IF EXAMINING EXPGT SHADOW
	JRST CPOPJ2		;Act normal, not special case
	MOVEI R,SYSMAP-EXPGT-DDTA⊗-9(R) ;Adjust address so that caller can
	JRST CPOPJ2			; do the examine using existing map

>;IFN FTDMAP
SWPEX2:	PUSH P,T
	MOVE T,EXMMAP
	LSH T,9			;Get base page number
	ADD R,T			;Allow reference to physical core above 777777
	POP P,T
	JRST XCREXM		;Do physical examine, take direct return

;Deposit value from T into location pointed to by R.  Check value of EXMMAP
;for whether we want to do a mapped or unmapped deposit.  Takes direct
;return if deposit done (or lost); skips if map is off or not using map or
;address is an AC, in which case caller should do the deposit directly.
SWPDEP:	MOVEM T,SWPWRD
	PUSHJ P,SWPEXM		;First, try to examine word
	 JRST XCRDEP		;GOT IT IN!
	 JRST CPOPJ1		;MAP IS OFF, or address is AC, let caller do work
	SKIPL EXMMAP		;SKIP IF EXAMINING USING EXISTING MAP
	JRST CPOPJ1		;NOT USING MAP.  LET SOMEONE ELSE THINK ABOUT IT.
	PUSH P,W
	PUSH P,S
	LDB S,[POINT 13,R,26]	;PAGE NUMBER OF REFERENCE
	MOVE T,KEXPGT		;address of EXPGT
	ADDI T,(S)		;ADDRESS OF THE EXPGT ENTRY FOR THIS PAGE.
NOKL10,<
	CAIL S,600		;SKIP IF VIRTUAL PAGE IS IN THE EXPGT
	ADD T,PSBEXP		;VIRTUAL PAGE IS IN THE PSB, fix table entry address
>;NOKL10
	SKIPN T,(T)		;GET THE EXISTING MAP ENTRY
	JRST DDTTRP		;PAGE FAULT
	HRLI T,PWRT		;ALLOW US TO WRITE THERE.
	MOVEM T,@DDTPEN		;set up temporary map entry in expgt
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONI KLPAG,T
	CONO KLPAG,(T)		;CLEAR ARS
>;IFKL10
	LDB S,[POINT 9,R,35]	;KEEP OFFSET IN PAGE
	MOVE T,SWPWRD		;SETUP T WITH THE DATUM
	MOVEM T,<DDTEXP⊗9>(S)	;STORE DATUM
	POP P,S
	SETZM @DDTPEN		;clear the temp map entry
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONI KLPAG,W
	CONO KLPAG,(W)		;CLEAR ARS
>;IFKL10
	POP P,W
	POPJ P,

XCREXM:	PUSH P,W
	MOVE W,[MOVE T,<DDTEXP⊗9>(S)]
XCRRTN:	PUSH P,S
	LDB S,[POINT 13,R,26]	;PAGE NUMBER OF REFERENCE
	HRLI S,PWRT
	MOVEM S,@DDTPEN		;set up map entry so we can read or write one word
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONI KLPAG,S
	CONO KLPAG,(S)		;CLEAR ARS
>;IFKL10
	LDB S,[POINT 9,R,35]	;KEEP OFFSET IN PAGE
	XCT W
XCRFIN:	POP P,S
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<CONI KLPAG,W
	CONO KLPAG,(W)		;CLEAR ARS
>;IFKL10
	POP P,W
	POPJ P,

XCRDEP:	PUSH P,W
	MOVE T,SWPWRD
	MOVE W,[MOVEM T,<DDTEXP⊗9>(S)]
	JRST XCRRTN

DDTTR2:	PUSH P,W		;simulate page fault trap because page table
	PUSH P,S		; entry was zero
DDTTRP:	MOVEI S,[ASCIZ / ?PAGE FAULT /]
	PUSHJ P,ASCOUT
	JRST XCRFIN

IFN FTF2,<
;JSR MWRITE to write out tape with whole system.  Rewind tape before and after.
MWRIT0:	0		;Save AC 0 here

MWRITE:	0		;JSR here
	MOVEM 0,MWRIT0	;Save AC 0
	HLRE 0,DDTSYM
	MOVMS 0
	ADD 0,DDTSYM
	JUMPN 0,.+2
	MOVEI 0,DDTEND	;Maybe no symbols, end with DDT itself
	ADDI 0,777	;Round up to next page boundary
	ANDI 0,777000	;Cut at page boundary
	HRRM 0,MWRITA	;Store in F2 magtape write instruction
	MOVEI 0,0	;Starting address of write
	726000,,0	;Rewind the tape
MWRITA:	731000,,777777	;Write tape, RH is word count (or ending address?)
	726000,,1	;Write EOF
	726000,,0	;Rewind again
	MOVE 0,MWRIT0	;Restore AC 0
	JRST @MWRITE	;Return
>;IFN FTF2
;DCKLST DCHKMC ASNDB ;⊗ DCHKPD DCHKAC DCHECK DCHEK1 DCHEK2 DCHEK4 DCHEK5 DCHEK3 OTOCA DTOCA DKTOCA DTOC2 DCKRAD DCHKTB NDCHK DCHKNM DCCBEG DCCLEN CLRCOR ARMTAC ARMBEG ARMLEN CLRARM CPOPJ2 CPOPJ1 CPOPJ ASCOUT ASCOU1 SIXOUT DTOUT XTKL DDTEXX DDTEX3 DDTEX2 DDTFLC TPIASH TENA TCHNG TBIT37 TREQ RPIASH RCLEAR RENA RCHNG RREQ RMISSED RBIT37 TINSTR TIN4 TIN3 TIN TIN2 TOUT WTP1OU WTP1OK WTP1CK NOP1OU CTPUTT CHKEPT CTGETT TOUTSC TOUTSL TOUTSE TOUTSX CTPUTD LPOUT LPPTR LPWRD LPCNT LISTEN LISTE1 K10CS K10RTN K10REP K10PIR K10TST K10EN K10IAK K10PI K10CS1 AS.NLB AS.BKO AS.1SB AS.BSO AS.ECH AS.PEN AS.REN AS.RTS AS.DTR AS.NDB AS.SYN AS.ODD AS.RCL AS.XCL AS.DSC AS.DSR AS.CAR AS.FER AS.PER AS.OER AS.RDA AS.THRE ASTWAT ASDRD0 ASDWR0 ASDRD2 ASDWR2 ASDRD4 ASDWR4 ASDRD6 ASDWR6 ASDRED ASDWRT ASDPRT LISSCN LISSCX LISSCR LISSCP LISSCO XTKL2

;TTY I/O ROUTINES AND DEVICE PIA CHECKER

;DCHECK - DEVICE PIA CHECKER

;CALL WITH JSR DCHECK$X

DCHKPD:	BLOCK 40
DCHKAC:	BLOCK 20
↑DCHECK:0
	MOVEM 17,DCHKAC+17
	MOVEI 17,DCHKAC
	BLT 17,DCHKAC+16
	MOVEI P,DCHKPD-1		;GET A PDL
	MOVSI W2,-NDCHK
DCHEK1:	MOVE TT,DCHKTB(W2)		;GET BYTE POINTER
	MOVE S,TT			;SAVE ALLOWABLE DEVICE CODES
	LDB TM1,[POINT 7,TT,24]		;GET DEVICE CODE
	HRRI TT,R			;CONI WILL BE IN R
	MOVE T,TM1
	LSH T,=26			;SHIFT TO DEVICE CODE FIELD
	IOR T,[CONI R]
	XCT T				;DO THE CONI INTO R
	LDB TT,TT			;GET THE PIA
	MOVEI SCH,3
DCHEK2:	IDIVI S,10			;GET NEXT ALLOWABLE PIA IN W
	CAIN W,(TT)			;DOES THE PIA MATCH?
	JRST DCHEK3			;YES, GO ON TO NEXT ENTRY
	SOJG SCH,DCHEK2			;TRY ALL THREE POSSIBLE PIAS
	MOVEI S,[ASCIZ /DEVICE /]	;S AND T GET CLOBBERED
	PUSHJ P,ASCOUT			;BY TYPEOUT
	MOVE W1,DCHKNM(W2)		;GET DEVICE NAME
	PUSHJ P,SIXOUT
	MOVEI S,[ASCIZ / (/]
	PUSHJ P,ASCOUT
	MOVEI T,(TM1)			;GET DEVICE CODE BACK
	LSH T,2				;MAKE IT A MULTIPLE OF 4
	PUSHJ P,OTOCA			;TYPE IT, CLOBBERS W1
	MOVEI S,[ASCIZ /) CONI BITS /]
	PUSHJ P,ASCOUT
	LDB T,[POINT 6,DCHKTB(W2),11]	;SIZE FIELD OF BYTE POINTER
	LDB W,[POINT 6,DCHKTB(W2),5]	;POSITION FIELD
	ADDI T,(W)
	MOVN T,T
	ADDI T,=36
	PUSHJ P,DTOCA			;TYPE IT IN DECIMAL
	MOVEI T,"-"
	PUSHJ P,DTOUT
	MOVEI T,=35
	SUBI T,(W)
	PUSHJ P,DTOCA
	MOVEI S,[ASCIZ / ARE /]
	PUSHJ P,ASCOUT
	MOVEI T,(TT)			;GET PIA
	PUSHJ P,OTOCA			;AND TYPE IT OUT
	MOVEI S,[ASCIZ / SHOULD BE /]
	PUSHJ P,ASCOUT
	MOVE SCH,[POINT 3,DCHKTB(W2),26]
	MOVEI R,0			;REMEMBER VALUES SEEN
DCHEK4:	ILDB W,SCH			;GET AN ALLOWABLE PIA VALUE
	MOVEI S,1
	LSH S,(W)
	TROE R,(S)
	JRST DCHEK5			;ALREADY TYPED THIS VALUE
	MOVEI S,[ASCIZ / OR /]
	TLOE R,400000			;SKIP COMMA FIRST TIME
	PUSHJ P,ASCOUT
	MOVEI T,(W)
	PUSHJ P,OTOCA			;TYPE OUT PIA
DCHEK5:	TLNE SCH,770000
	JRST DCHEK4
	MOVEI S,[ASCIZ /
/]
	PUSHJ P,ASCOUT
DCHEK3:	AOBJN W2,DCHEK1
	MOVEI S,[ASCIZ /DONE CHECKING
/]
	PUSHJ P,ASCOUT
	MOVSI 17,DCHKAC
	BLT 17,17
	JRST 2,@DCHECK

OTOCA:	SKIPA W1,[10]
DTOCA:	MOVEI W1,12
	MOVEM W1,DCKRAD
DKTOCA:	LSHC T,-43
	LSH W1,-1		;W1=T+1
	DIV T,DCKRAD
	HRLM W1,0(P)
	JUMPE T,DTOC2
	PUSHJ P,DKTOCA
DTOC2:	HLRZ T,0(P)
	ADDI T,"0"
	JRST DTOUT

DCKRAD:	10

;ENTRIES IN THE DCHKTB TABLE HAVE THE FOLLOWING FORMAT:
;LH:  LH OF BYTE POINTER TO A FIELD IN THE CONI THAT HAS A PIA
;RH:  BITS 18-24 CONTAIN THE 7 BIT DEVICE CODE
;     BITS 27-29, 30-32 AND 33-35 CONTAIN LEGAL PIA VALUES

DEFINE DCKLST <
	DCHKMC (APR,3,35,APRCHN,APRCHN,APRCHN)
	DCHKMC (DCA,3,35,SCNCHN,SCNCHN,SCNCHN)
IFE FTF2,<
	DCHKMC (MTR,3,35,APRCHN,APRCHN,APRCHN)
	DCHKMC (DTE0,3,35,DTECHN,DTECHN,DTECHN)
	DCHKMC (DC,3,35,DCTCHN,DCTCHN,0)
	DCHKMC (DTC,3,35,DTCCHN,DTCCHN,0)
	DCHKMC (MTC,3,35,MTCCHN,MTCCHN,0)
	DCHKMC (VMI,3,35,0,0,0)
;	DCHKMC (PK,3,35,PKCHN,PKCHN,PKCHN)
;	DCHKMC (DIL,3,35,DILCHN,DILCHN,DILCHN)
	DCHKMC (DPY,3,35,DPYCHN,DPYCHN,0)
IFNDEF P2DCHN,<P2DCHN←←0>
	DCHKMC (P2D,3,35,P2DCHN,0,0)			;P1/P2 INTERFACE
	DCHKMC (ELF,3,32,ELFCHN,ELFCHN,0)		;ELF ERRORS
	DCHKMC (ELF,3,35,0,0,0)				;ELF DATA
	DCHKMC (DDD,3,35,DPYCHN,DPYCHN,0)
	DCHKMC (MPX,3,35,MPXCHN,MPXCHN,MPXCHN)
IFN FTAIP,<
	DCHKMC (IMP,3,35,IMPCHN,IMPCHN,0)		;OUTPUT
	DCHKMC (IMP,3,32,IMPCHN,IMPCHN,0)		;INPUT
	DCHKMC (IMP,3,29,IMPCHN,IMPCHN,0)		;INPUT END
>;IFN FTAIP
>;IFE FTF2
IFN FTF2,<
IFN FTAIP,<
	DCHKMC (IMP,3,35,IMPCHN,IMPCHN,0)		;INPUT
	DCHKMC (IMP,3,31,IMPCHN,IMPCHN,0)		;OUTPUT
	DCHKMC (IMP,3,27,IMPCHN,IMPCHN,0)		;INPUT END
>;IFN FTAIP
>;IFN FTF2
>;END DEFINITION OF DCKLST

DEFINE DCHKMC (DEVICE,SIZE,BITPOS,PIA1,PIA2,PIA3) <
	POINT SIZE,<<DEVICE⊗9>!(PIA1*100+PIA2*10+PIA3)>,BITPOS
>

DCHKTB:	DCKLST
NDCHK←←.-DCHKTB

DEFINE DCHKMC (DEVICE,SIZE,BITPOS,PIA1,PIA2,PIA3) <
	SIXBIT /DEVICE/
>

DCHKNM:	DCKLST			;ASSEMBLE NAMES OF DEVICES

IFKL10,<
IFE FTKLB,<	;model B processor doesn't have this DATAO PI, in microcode
;Do a JSR CLRCOR$X with DCCBEG and DCCLEN set up to clear indicated core
DCCBEG:	0		;Starting physical address of core to clear
DCCLEN:	0		;Length of core to clear
CLRCOR:	0		;JSR here to clear some core
	DATAO PI,DCCBEG	;Clear core using WAITS KL-10 microcode instruction
			;Note that DATAO PI, fails to clear
			;  AC shadow locations in each moby.
			;Someday we'll make this work using the map, and then
			;  it can be enabled on non-KL systems and it won't
			;  miss the shadow ACs.
	JRST @CLRCOR	;Return

;Do a JSR CLRARM$X to clear ARM-10M memory
ARMTAC:	0		;Place to store TAC in below routine
;Next three locations must parallel those at DCCBEG through CLRCOR.
ARMBEG:	1,,0		;Starting addr of ARM-10M memory
ARMLEN:	10,,0		;Length of ARM-10M memory
CLRARM:	0			;JSR here to clear ARM-10M
	MOVEM TAC,ARMTAC	;Save AC
	MOVE TAC,[ARMBEG,,DCCBEG]
	BLT TAC,CLRCOR		;Set up DCCBEG, DCCLEN, CLRCOR (return addr)
	MOVE TAC,ARMTAC		;Restore AC
	JRST CLRCOR+1		;Simulate JSR CLRCOR
>;IFE FTKLB
>;IFKL10

>;END IFE EDDT&21-21 CONDITIONAL (SEE TOP OF PAGE 9)
>;IFE P2SYS

CPOPJ2:	AOS (P)
CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,


ASCOUT:	HRLI S,440700
ASCOU1:	ILDB T,S
	JUMPE T,CPOPJ
	PUSHJ P,TOUT
	JRST ASCOU1

IFN EDDT&1,<

SIXOUT:	MOVEI T,0
	LSHC T,6
	JUMPE T,CPOPJ
	ADDI T,40
	PUSHJ P,DTOUT
	JRST SIXOUT

DTOUT:	CAIG T,4
	POPJ P,
XTKL:	PUSH P,0		;TRANSMIT CHARACTER IN T TO CTY
	MOVE 0,T
IFN FTSCTY,<
	SKIPL SCNCTY		;Skip if no alternate CTY on scanner
	SKIPN SUPCTY		;Skip if suppressing duplicate output thru DTE
>;IFN FTSCTY
	PUSHJ P,DDTEXX
	POP P,0
IFN FTSCTY,<
	SKIPL SCNCTY		;Is CTY on TTY scanner?
	JRST TOUTSC		;Yes, type out there too
>;IFN FTSCTY
	POPJ P,

DDTEXX:	PUSH P,T
	MOVE T,KEPTAD
IFDEF FTNDTE,<IFN FTNDTE,<
;First we wait for any previous 11 cmd to have finished!
	PUSH P,0		;
	MOVEI 0,400000		;Let's not hang here forever, over one char
	SKIPN @DDTFLC	;DTFLG(T)		;WAIT FOR previous response!
	SOJG 0,.-1		;Loop unless timed out
	JUMPG 0,DDTEX3		;Jump if didn't time out
	AOS DDTETO		;Count a DTE timeout
DDTEX3:	POP P,0
>>;FTNDTE
	SETZM @DDTFLC	;DTFLG(T)		;CLEAR COMMAND DONE FLAG
	MOVEM 0,DTCMD(T)	;STORE COMMAND WORD FOR 11
	CONO DTE0,DONG11	;RING 11'S DOORBELL
	MOVEI 0,400000		;Let's not hang here forever, over one char
	SKIPN @DDTFLC	;DTFLG(T)		;WAIT FOR RESPONSE
	SOJG 0,.-1		;Loop unless timed out
	JUMPG 0,DDTEX2		;Jump if didn't time out
	AOS DDTETO		;Count a DTE timeout
IFDEF FTNDTE,<IFN FTNDTE,<
	SETOM @DDTFLC	;DTFLG(T)		;Don't make us wait for timeout again next time
>>
	TDZA 0,0		;Return zero since DTE timed out
DDTEX2:	MOVE 0,DTF11(T)		;RETURN 11'S REPONSE WORD
IFDEF FTNDTE,<IFN FTNDTE,<
;>>	SETZM @DDTFLC	;DTFLG(T)	;Don't want this instruction with FTNDTE in WAITS
	POP P,T
	POPJ P,

DDTFLC:	JUMP DTFLG(T)		;indirected through to enable easy patching

IFN EDDT&100,<
; CONO/CONI BITS FOR 10/6 INTERFACE

; TRANSMITTER SIDE, CONO BITS

TPIASH←←0	; SHIFT PIA ZERO POSITIONS (BITS 33-35)
TENA←←20	; ENABLE TRANSMITTER INTERRUPTS
TCHNG←←40	; TRANSMITTER ANY CHANGE (MUST BE ON IN CONO WORD)
TBIT37←←10000	; 37TH OUTPUT BIT (MUST BE ON FOR FIRST WD OF HEADER)

; TRANSMITTER SIDE, CONI BITS

		; PIA IS IN LOW ORDER BITS (BITS 33-35)
TREQ←←10	; INTERRUPT IS BEING REQUESTED
;TENA←←20	; ENABLE TRANSMITTER INTERRUPTS

; RECEIVER SIDE, CONO BITS

RPIASH←←6	; SHIFT PIA 6 POSITIONS (BITS 27-29)
RCLEAR←←1000	; CLEARS "DATA MISSED" FLAG
RENA←←2000	; ENABLE RECEIVER INTERRUPTS
RCHNG←←4000	; ENABLE ANY CHANGE (MUST BE ON TO DO ANYTHING BUT RCLEAR)

; RECEIVER SIDE, CONI BITS

		; PIA COMES IN ON BITS 27-29
RREQ←←1000	; INTERRUPT IS BEING REQUESTED
;RENA←←2000	; ENABLE RECEIVER INTERRUPTS
RMISSED←←4000	; DATA MISSED FLAG (CLEARED BY RCLEAR)
RBIT37←←10000	; 37TH INPUT BIT (SHOULD BE ON IN FIRST WD OF HEADER)
>;IFN EDDT&100

TINSTR:	ILDB	T,STRING
	JUMPE	T,TIN3		;THERE IS NO CHR
IFN P2SYS,<
	SKIPN P1CHRI		;IS THERE INPUT FROM P1?
>;IFN P2SYS
IFE EDDT&100,<
	CONSZ	TTYY,40		;IS THERE TTY INPUT?
>; IFE EDDT&100
IFN EDDT&100,<
	CONSZ	SIX,RREQ	; ANY RECEIVER REQUEST?
>; IFN EDDT&100
	JRST	TIN3		;YES.  THAT MEANS FLUSH STRING PROCESSING.
	CAIE	T,15		;CR?
	JRST	TIN2		;NO.
	ILDB	T,STRING	;GET NEXT BYTE
	CAIN	T,12
	JRST	TIN4		;LF FOLLOWS CR.  THROW LF AWAY
	MOVSI	T,70000		;OOPS. NO LF THERE.  BACK UP THAT BYTE POINTER.
	ADDM	T,STRING
TIN4:	MOVEI	T,15		;REINVENT CR
	JRST	TIN2		;WE HAVE A CHARACTER.

TIN3:	SETZM	STRING		;SET STRING BYTE POINTER TO ZERO AND READ TTY
TIN:	SKIPE	STRING
	JRST	TINSTR		;USE STRING BYTE POINTER IF SET.
	PUSHJ	P,LISTEN	;WAIT FOR SOMETHING.
	 JRST	.-1
TIN2:	CAIE	T,175
	CAIN	T,176
	MOVEI	T,33		;CHANGE ALL ALT MODES TO NEW
	CAIN	T,177
	JRST	WRONG
	TRNE	T,140		;SKIP IF THIS IS A NON-PRINTING CHR.
TOUT:	CAIG	T,4		;DON'T TYPE CHARACTERS NULL, CTRL A,B,C OR D.
	POPJ	P,
	SKIPE	OUTRTN
	JRST	@OUTRTN		;IF OUTRTN IS SET, USE IT.  (RETURN VIA POPJ P,)
IFN FTF2,<
printx LPT output is OK at CCRMA
>;IFN FTF2
IFE FTF2,<
	SKIPE	OUTLPT
	JRST	LPOUT		;DO LPT OUTPUT THING INSTEAD
>;IFE FTF2
	ANDI	T,177		;CHARACTER ONLY
	SKIPE	KLFLG		;KL10?
	JRST	XTKL		;YES.  OUTPUT VIA DTE20/PDP-11
IFN P2SYS,<
WTP1OU:	CAIN T,177	;Don't pass padding to P1 -- CTPUTD comes here
	JRST WTP1CK	;Rubout is padding, don't pass to P1
	PUSH P,TT
	MOVSI TT,40	;Use longer timeout if suppressing typeout on P2 CTY
	SKIPL P2TSUP	;Skip if suppressing typeout on P2 CTY
	MOVSI TT,4	;How long P1 can freeze output while reading buffer
	SKIPN P1FLGO	;This is -1 normally, positive if P1 wants a copy of
	SOJG TT,.-1	; the output, 0 if P1 wants to hold o/p briefly
	JUMPG TT,WTP1OK	; while it is emptying a buffer.
	SETOM P1FLGO	;Time out, P1 loses.
	SETZM P2TSUP	;Don't suppress P2 typeout any more
WTP1OK:	POP P,TT
	SKIPGE P1FLGO	;Skip if P1 getting in the act
	JRST NOP1OU	;No
	SOSG P1FLGO	;See if still room in buffer
	JRST WTP1OU	;No, wait for P1
	SKIPE P1BPTO	;P1-provided byte pointer (into P2COMM buffer)
	IDPB T,P1BPTO	;Give char to P1 as well as to P2's CTY.
WTP1CK:	SKIPGE P2TSUP	;Skip unless suppressing typeout on P2 CTY
	SKIPGE P1FLGO	;Skip if P1 is really in the act
	JRST NOP1OU
	POPJ P,		;Don't type on P2 CTY
NOP1OU:
>;IFN P2SYS
	HRLM	T,(P)
	IMULI	T,200401	;GENERATE PARITY BIT IN THE USUAL WAY
	AND	T,[11111111]
	IMUL	T,[11111111]
	HLR	T,(P)
	TLNE	T,10
	TRC	T,200
IFE EDDT&100,<
	CONSZ	TTYY,20
	JRST	.-1
	DATAO	TTYY,T
>; IFE EDDT&100
IFN EDDT&100,<
	CONO SIX,TCHNG!TBIT37	; TURN ON CONTROL BIT
	HRLI T,600015		; PUT IN DDT CHR CODE
	DATAO SIX,T
	CONSO SIX,TREQ		; WAIT FOR IT TO GO OUT
	JRST .-1
>; IFN EDDT&100
	ANDI	T,177		;FLUSH PARITY BIT AND RETURN.
IFN FTSCTY,<
	SKIPL SCNCTY		;Is scanner on TTY scanner?
	JRST TOUTSC		;Yes, type out there too
>;IFN FTSCTY
	POPJ	P,

IFN FTSCTY,<
IFE EDDT&21-21,<		;Need this only if system exec DDT
;Here from CTPUTC in CACDAT
↑CTPUTT:PUSH P,T
	PUSHJ P,CHKEPT		;Make sure KEPTAD is set
	MOVE T,TAC		;Get char where we expect it
	PUSHJ P,TOUT		;Use DDT char out routine, maybe scanner CTY
	MOVE TAC,T
	POP P,T
	POPJ P,

CHKEPT:	SKIPE DINIDN		;SKIP IF ALREADY BEEN HERE, KEPTAD ALREADY SET
	POPJ P,
	SETOM DINIDN
	SETZM KLFLG		;ASSUME NOT A KL10
	MOVE T,[T,,T]
	BLT T,T
	CAMN T,[T,,T]
	POPJ P,			;NOT A KL
	SETOM KLFLG		;THIS IS A KL10
	CONI KLPAG,T		;GET EBR.
	ANDI T,17777		;MASK EBR ONLY
	LSH T,9			;SHIFT TO MAKE A CORE ADDRESS
	MOVEM T,KEPTAD		;SAVE EPT ADDRESS.
	POPJ P,

;Here from CTGETC in CACDAT
↑CTGETT:PUSH P,T
	PUSHJ P,CHKEPT		;Make sure KEPTAD is set
	MOVE T,TAC		;Get char where we expect it
	CONI PI,TAC
	SYSPIFF		;Scanner output routines can't have scanner int'ing
	PUSHJ P,LISTEN		;Use DDT char input routine, maybe scanner CTY
	 MOVEI T,0		;Return zero for no char read
	TRNE TAC,200
	CONO PI,PION		;Restore PI state
	MOVE TAC,T
	POP P,T
	JUMPN TAC,CPOPJ1	;Skip if got real char
	POPJ P,
>;IFE EDDT&21-21

;Output DDT character in T to scanner CTY.
TOUTSC:	PUSH P,A		;First, save some ACs
IFE FTDLS,<
	PUSH P,B
	PUSH P,C		;SAVE LINE NUMBER
	PUSH P,TT		;THESE ARE CLOBBERED TOO
	CONI PI,TT
	PUSH P,TT		;Save PI state
	SYSPIFF
	HRRZ C,SCNCTY		;GET PORT NUMBER INTO AC C
	PUSHJ P,ASDPRT		;GET PORT NUMBER IN CHIP SELECT FORMAT IN TT
	PUSHJ P,ASDWR6		;WRITE THE DATA
TOUTSL:	MOVEI TT,100000		;Wait this long for output interrupt (maybe 300 baud)
	CONSO DCA,K10PIR	;Wait for output done by looping until
	SOJG TT,.-1		; any port requests an interrupt (ugh)
	JUMPLE TT,TOUTSE	;Jump if timed out! Count losses.
	CONO DCA,K10IAK+K10EN+SCNCHN	;TURN ON INTERRUPT ACKNOWLEDGE
	MOVEI A,ASTWAT		;(PROCESSOR DEPENDENT VALUE)
	CONSO DCA,K10REP+K10RTN	;REPLY OR IACK RETURN
	SOJG A,.-1		;NO, WAIT (FOR A WHILE). [MAX SPEC.= 32 US.]
	CONSO DCA,K10REP	;DID WE GET OUT WITH A REPLY?
	 JRST TOUTSE		;NO
	DATAI DCA,B		;READ INTERRUPT RESPONSE DATA
	CONO DCA,K10EN+SCNCHN	;RESET IACK
	MOVEI TT,(B)		;KEEP PORT NUMBER IN CHIP SELECT FORMAT
	ANDI TT,7770		;NO GARBAGE PLEASE (EXCEPT "NO ADDR")
	IORI TT,K10CS!K10CS1	;ADD MAGIC BITS
	LSHC B,-7		;DO BIT FLIPPING ALGORITHM
	LSH B,-1		;SQUEEZE OUT CONSTANT 1 BIT
	LSHC B,4		;B = PORT #, C(0:2) = FLAGS
	CAME B,SCNCTY		;Port we're expecting?
	JRST TOUTSL		;No, ignore other ports
	JUMPGE C,TOUTSX		;JUMP IF XMT INTERRUPT, which is what we want
	AOS SCNINP		;Count an input char ignored from proper port
	JRST TOUTSL		;Keep looking for the XMT int, ignore input char

TOUTSE:	AOS SCNTMO		;Count time outs, etc., for output to scanner CTY
TOUTSX:	POP P,TT		;Original PI state
	TRNE TT,200		;Skip if PI was already off
	CONO PI,PION		;Restore PI state
	POP P,TT
	POP P,C
	POP P,B
>;IFE FTDLS
	POP P,A
	POPJ P,
>;IFN FTSCTY

IFN P2SYS,<
↑CTPUTD:PUSH P,T		;CTPUTC IN P2SER COMES HERE TO OUTPUT
	MOVE T,TAC
	PUSHJ P,WTP1OU		;SEND THE CHAR TO P1 AND OR CTY
	POP P,T
	POPJ P,
>;IFN P2SYS

IFN FTF2,<
printx Here's another place to change for LPT output on F2
>;IFN FTF2
IFE FTF2,<
LPOUT:	IDPB	T,LPPTR			;EXEC MODE LPT OUTPUT FEATURE
	SOSLE	LPCNT
	POPJ	P,
	PUSH	P,T
	MOVEI	T,5
	MOVEM	T,LPCNT
	DATAO	LPT,LPWRD
	MOVE	T,[POINT 7,LPWRD]
	MOVEM	T,LPPTR
	CONSO	LPT,100
	JRST	.-1
	POP	P,T
	POPJ	P,

LPPTR:	POINT 7,LPWRD
LPWRD:	0
LPCNT:	5
>;IFE FTF2

LISTEN:
IFN P2SYS,<
	SETZM P1DDTF		;NO LONGER NEED TO GO INTO DDT FOR P1
	SKIPE SP2NUM		;SKIP IF SYS WASN'T UP ON ENTRY TO DDT
	SKIPE P2NUM		;SKIP IF FLAGGED DOWN NOW
	JRST LISTE1		;WAS DOWN, OR NOW UP
	JRST GODOWN		;P1 WANTS US TO GO DOWN
LISTE1:	SKIPE T,P1CHRI		;Is P1 sending us a character?
	JRST [ SETZM P1CHRI ↔ JRST CPOPJ1 ] ; Yes, use it instead of TTY
>;IFN P2SYS

	SKIPE	KLFLG		;KL10?
	JRST	XTKL2
IFE EDDT&100,<
	CONSO	TTYY,40		;LISTEN FOR TTY
	JRST LISSCN
	DATAI	TTYY,T
>; IFE EDDT&100
IFN EDDT&100,<
	CONSO	SIX,RREQ
	JRST LISSCN
	DATAI	SIX,T
>; IFN EDDT&100
	ANDI	T,177
	JRST	CPOPJ1

IFE FTSCTY,<
LISSCN ←← CPOPJ
>;IFE FTSCTY
IFN FTSCTY,<
;ASTRA-K10 CONTROLLER - HARDWARE BITS AND PARAMETERS

IFN EDDT&21-21,< ;don't duplicate TTYSER's defs -- avoid multiply defined symbols

;CONI BITS (AND CONTROL CONO)

	K10CS←←4000		;CHIP SELECT
	K10RTN←←2000		;IACK RETURN (FROM TERMINATOR PLUG)
	K10REP←←1000		;REPLY (FROM CS SEQUENCE OR IACK)
	K10PIR←←400		;CBUS PIR (PROGRAM INTERRUPT REQUEST)
	K10TST←←40		;CBUS TEST BIT
	K10EN←←20		;ENABLE = NOT(CBUS MASTER RESET)
	K10IAK←←10		;CBUS IACK (INTERRUPT ACKNOWLEDGE)
	K10PI←←7		;PI CHANNEL MASK

;CONO BITS (SELECT CONO)

	K10CS1←←200		;BIT WHICH MUST BE ON DURING SELECT SEQUENCE
;	K10CFM←←3400		;MASK TO CARD-FILE #
;	K10PRT←←170		;MASK TO PORT WITHIN CARD-FILE
;	K10REG←←7		;MASK TO REGISTER WITHIN PORT

;ASTRA-AS PORT MODULE - DEFINITIONS

;CR1 - CONTROL REGISTER 1 (REG0)

	AS.NLB←←200		;NO LOOP-BACK (OFF FOR LOOPBACK)
	AS.BKO←←100		;BREAK-OUT
	AS.1SB←←40		;ONE STOP BIT (TWO IF OFF)
	AS.BSO←←40		;BUSY OUT (IF XMTR DISABLED)
				;NOTE!! AS.1SB & AS.BSO ARE SAME BIT!
	AS.ECH←←20		;AUTO-ECHO MODE
	AS.PEN←←10		;PARITY ENABLE
	AS.REN←←4		;RECEIVER ENABLE
	AS.RTS←←2		;REQUEST TO SEND (ALSO TRANSMITTER ENABLE)
	AS.DTR←←1		;DATA TERMINAL READY

;CR2 - CONTROL REGISTER 2 (REG2)

	AS.NDB←←300		;FIELD HAS 0,1,2,3 FOR 8,7,6,5 DATA BITS.
DEFINE ASNDB(NBITS)<<<8-NBITS>⊗6>>
	AS.SYN←←40		;SYNC MODE
	AS.ODD←←20		;ODD PARITY (IF PARITY ENABLED)
	AS.RCL←←10		;RECEIVER CLOCK SAME AS TRANSMITTER (CLK0 IF OFF)
	AS.XCL←←7		;TRANSMITTER CLOCK RATE (MASK)

;STATUS REGISTER (REG4)

	AS.DSC←←200		;DATA SET CHANGE (CHANGE IN AS.CAR OR AS.DSR)
	AS.DSR←←100		;DATA SET READY
	AS.CAR←←40		;CARRIER
	AS.FER←←20		;FRAMING ERROR
	AS.PER←←10		;PARITY ERROR
	AS.OER←←4		;OVERRUN ERROR
	AS.RDA←←2		;RECEIVER DATA AVAILABLE
	AS.THRE←←1		;TRANSMITTER HOLDING REGISTER EMPTY

;SYNC/FILL REGISTER (REG4)

;	<NONE>

;DATA REGISTER (REG6)

;	<NONE>

ASTWAT←←1000			;NUMBER OF TIMES TO LOOP WAITING FOR IACK.
				;THE SEQUENCE "MOVEI ASTWAT/SOJG ." MUST BE
				;SLOWER THAN 32 MICROSECONDS ON ALL CPUS.
>;IFN EDDT&21-21

;NOTE THAT THESE ROUTINES MUST BE ENTERED IN SCNCHN OR WITH SCNOFF IN EFFECT.
ASDRD0:	JSP B,ASDRED		;READ REG0 (CONTROL REG 1)
ASDWR0:	JSP B,ASDWRT		;WRITE REG0
ASDRD2:	JSP B,ASDRED		;READ REG2 (CONTROL REG 2)
ASDWR2:	JSP B,ASDWRT		;WRITE REG2
ASDRD4:	JSP B,ASDRED		;READ REG4 (STATUS REG)
ASDWR4:	JSP B,ASDWRT		;WRITE REG4
ASDRD6:	JSP B,ASDRED		;READ REG6 (DATA)
ASDWR6:	JSP B,ASDWRT		;WRITE REG6

ASDRED:	SUBI B,ASDRD0+1		;REGISTER NUMBER IN B
	ADDI B,(TT)		;ADD CHIP ADDR TO REGISTER NUMBER
IFE FTDLS,<
	CONO DCA,(B)		;LATCH THE ADDRESS TO THE BUS
	DATAI DCA,T		;READ THE POOP
>;IFE FTDLS
	POPJ P,

ASDWRT:	SUBI B,ASDWR0+1		;REGISTER NUMBER IN B
	ADDI B,(TT)		;ADD CHIP ADDR TO REGISTER NUMBER
IFE FTDLS,<
	CONO DCA,(B)		;LATCH THE ADDRESS TO THE BUS
	DATAO DCA,T		;WRITE THE POOP
>;IFE FTDLS
	POPJ P,

ASDPRT:	PUSH P,TT+1
	MOVEI TT,(C)		;GET PORT NUMBER INTO TT
	LSHC TT,-4		;MOVE PORT NUMBER INTO AC2 (WHICH IS CLOBBERED)
	LSH TT,1		;EXTRA BIT BETWEEN GROUP AND PORT
	LSHC TT,4		;GET PORT BACK
	LSH TT,3		;LEAVE ROOM FOR REGISTER
	ADDI TT,K10CS+K10CS1	;ADD IN THE NECESSARY MAGIC BITS
	POP P,TT+1
	POPJ P,

LISSCN:	SKIPGE SCNCTY		;Is CTY on tty scanner?
	POPJ P,			;No, no input
IFE FTDLS,<
	CONSO DCA,K10PIR	;Any port at all requesting interrupt?
	POPJ P,			;No
	CONO DCA,K10IAK+K10EN+SCNCHN	;TURN ON INTERRUPT ACKNOWLEDGE
>;IFE FTDLS
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,TT
	MOVEI A,ASTWAT		;(PROCESSOR DEPENDENT VALUE)
IFE FTDLS,<
	CONSO DCA,K10REP+K10RTN	;REPLY OR IACK RETURN
	SOJG A,.-1		;NO, WAIT (FOR A WHILE). [MAX SPEC.= 32 US.]
	CONSO DCA,K10REP	;DID WE GET OUT WITH A REPLY?
	 JRST LISSCR		;I NEARLY DIED, WHEN YOU WALKED HAND IN HAND, ETC.
	DATAI DCA,B		;READ INTERRUPT RESPONSE DATA
	CONO DCA,K10EN+SCNCHN	;RESET IACK
>;IFE FTDLS
	MOVEI TT,(B)		;KEEP PORT NUMBER IN CHIP SELECT FORMAT
	ANDI TT,7770		;NO GARBAGE PLEASE (EXCEPT "NO ADDR")
	IORI TT,K10CS!K10CS1	;ADD MAGIC BITS
	LSHC B,-7		;DO BIT FLIPPING ALGORITHM
	LSH B,-1		;SQUEEZE OUT CONSTANT 1 BIT
	LSHC B,4		;B = PORT #, C(0:2) = FLAGS
	CAME B,SCNCTY		;Port we want?
	 JRST LISSCP		;No, ignore other ports
	JUMPGE C,LISSCO		;JUMP IF XMT INTERRUPT, WE'RE LOOKING FOR INPUT
	MOVE C,B		;C NOW CONTAINS DCA PORT NUMBER
	PUSHJ P,ASDRD4		;READ THE STATUS REGISTER (FLAGS) TO T.
	HRLZ T,T		;I WANT TO CARRY THEM AROUND IN T<LH>.
	TLNN T,AS.RDA		;RECEIVED DATA INTERRUPT?
LISSCX:	TDZA T,T		;NO, MUST BE JUST MODEM, indicate no char yet
	PUSHJ P,ASDRD6		;READ DATA REG TO T
	POP P,TT
	POP P,C
	POP P,B
	POP P,A
	ANDI T,177		;Discard random bits
	JUMPE T,LISSCN		;Didn't really get anything, look again
	JRST CPOPJ1		;Return w/non-zero char in T

LISSCR:	AOS SCNREP		;Count failures to get reply from DCA
	JRST LISSCX

LISSCP:	AOS SCNPOR		;Count ints from other ports
	JRST LISSCX

LISSCO:	AOS SCNOUP		;Count output interrupts seen when checking input
	JRST LISSCX
>;IFN FTSCTY

XTKL2:
IFN FTSCTY,<
	SKIPL SCNCTY		;Scanner CTY around?
	SKIPN SUICTY		;Yes, want to ignore input from real CTY?
	CAIA			;No to one of these, read from CTY
	JRST LISSCN		;Yes, read only from scanner
>;IFN FTSCTY
	PUSH	P,0
	MOVEI	0,3400		;DDT MODE INPUT REQUEST TO DTE20/PDP-11
	PUSHJ	P,DDTEXX
	MOVE	T,0
	POP	P,0
	ANDI	T,177
	JUMPN	T,CPOPJ1
	JRST	LISSCN		;Look for input from Scanner as CTY!
>;IFN EDDT&1
;⊗ TMPTAC DDTP2 DDT DDTDDT DDT DDGVUS RDDTA DDTB DDTC DDTD DD1 DD1.5 DD2 LIS LIS0 LIS1 LIS2 L1 L1RPR L2 L21 L212 L213 L4 L5 RET ERR UNDEF WRONG WRONG1

	SUBTTL	DDT - INITIALIZATION, MAIN LOOP - DDTA


IFN FTDMAP,<
TMPTAC:	0
DDTP2:	MOVEM TAC,TMPTAC
	MOVE TAC,[POINT 7,[ASCIZ/SORRY, CAN'T GET DDT!
/]]
	JSR DDTTYPE
	MOVE TAC,TMPTAC
	HALT DDT

DDT:	SKIPE	NOTDDT
	JRST	DDTP2
	JSR	SAVE
	 JRST	RDDTA		;NORMAL ENTRY
	JRST	DDTB		;DDT RESTARTING WITHOUT NORMAL EXIT
;MAKE SURE EVERYTHING WE NEED STAYS IN - LIT AND VAR XLISTED
	XLIST			;OMIT UNSIGHTLY HEAP.
	LIT
	VAR
	LIST
>;IFN FTDMAP

;DDTA IS THE FIRST LOCATION THAT MAY BE MAPPED OUT!!!!
IFN FTSEPONCE,<
;RDDTA is the first word of the part that could be mapped out, but since
;RDDTA may not be on a page boundary, we only start mapping out at the
;first word of a page that begins at or after RDDTA.  That word is known
;as DDTA, although it's value is only calculated at load time -- it's
;definition is made by a macro at the top of page 10.
>;IFN FTSEPONCE

IFE FTDMAP,<
DDTDDT:				;TO DISTINGUISH FROM RAID'S STARTING ADDRESS
DDT:	JSR SAVE		;SAVE ACS - NON MAPPING VERSION OF DDT
>;IFE FTDMAP
IFN EDDT&1,<
DDGVUS::			;GIVE FROM HERE ON TO USERS
IFN FTDMAP,<
IFE FTSEPONCE,<
LOC <<.-1>&777000>+1000		;NEXT PAGE BOUNDARY -- CODE GETS PUT AT 1,,0
>;IFE FTSEPONCE
NOKL10,<DDTAPS←←IFGE .-600000,<PSB-EXPGT;>0 > ;Adjustment for DDT's pages in PSB
IFKL10,<DDTAPS←←0 >;IFKL10
	BEGIN MDDT mappable portion of DDT, block named for symbol avoidance
>;IFN FTDMAP
>;IFN EDDT&1
↑↑RDDTA:
IFE EDDT&1,<
	CAIA			;CALL ONLY ONE OF SETSPC AND REMOVB
	PUSHJ P,SETSPC		;SET SPECIAL ACT MODE -- ALWAYS SKIP RETURNS
>;IFE EDDT&1
	 PUSHJ P,REMOVB		;REMOVE BREAKPOINTS
↑DDTB:
IFE EDDT&21-21,<
	MOVE T,TIMDAT
	MOVEM T,LASTDISASTER	;Record time of pause
>;IFE EDDT&21-21
	PUSHJ P,CHKSYM		;SEE IF SYMBOL TABLE HAS MOVED
IFE EDDT!UEDDTS,<
	MOVE T,JOBOPC↑		;CONTINUE THRU JOBOPC
	TLNN T,10000		;USER MODE PC?
	JRST DDTC		;NO. ICK!
	HRRZ T,T		;PC ONLY
	CAIL T,DDTBEG
	CAILE T,DDTEND
	JRST DDTD		;JOBOPC POINTS OUTSIDE OF DDT
>;IFE EDDT
IFN EDDT&1,<
	MOVEI T,0
	EXCH T,PROCPC		;GET SPECIAL PC AT WHICH TO CONTINUE UPON $P
	TRNN T,-1		;IF NONE, LET $P CALL DDT
>;IFN EDDT&1
DDTC:	MOVEI T,XEC1		;MAKE $P CALL DDT
;HERE WHEN SOMEONE JUMPED TO DDT.  SET UP FAKE BREAKPOINT TO PROCEED FROM.
DDTD:	HRRM T,PROC0		;STORE ADDRESS TO PROCEED AT
	ADDI T,1		;MAKE IT LOOK LIKE ADDR STORED BY JSR
	HLL T,SAVPI		;GET PC FLAGS
	MOVEM T,BCOM		;MAKE US LOOK LIKE A BREAKPOINT FOR $P
	MOVEI T,SIMADR-B1ADR+B1SKP ;ADDRESS OF FAKE CONDITIONAL BREAK INSTR
	HRRM T,BCOM3		;MAKE $P USE FAKE BP CELL
	MOVEI T,SIMADR-B1ADR+B1CNT ;ADDRESS OF FAKE COUNT CELL
	HRRM T,BCOM2		;MAKE $P USE FAKE BP CELL
↑DD1:	TLZ	F,ROF			;CLOSE ANY OPEN REGISTER
	PUSHJ	P,CRF			;ANNOUNCE BY CRLF THAT WE ARE HERE.
DD1.5:	MOVE	T,[XWD SCHM,SCH]
	BLT	T,ODF			;LOAD ACS
	SKIPL	GETFLG			;OPEN A PROGRAM THE FIRST TIME AROUND.
	JRST	GETPGM			;RETURN TO RET OR DD2
DD2:	SETZM	PRNC			;PARENTHESES COUNT
	MOVEI	P,PS			;STACK POINTER
LIS:	MOVE	T,ESTU			;UNDEFINED SYMBOL POINTER
	MOVEM	T,ESTUT			;INIT UNDEFINED SYM ASSEM
	TDZ	F,[XWD 777777-ROF-STF,LF1+CF1+SBF+ITF+EQF+Q2F]
	SETZM	IOTFLG			;NOT AN IOT YET
LIS0:	TDZ	F,[XWD 777777-ROF-STF-FAF-SAF,NAF]
	SETZM	WRD
LIS1:	SETZM	FRASE
LIS2:	MOVEI	T,1
	MOVEM	T,FRASE1
	TLZ	F,MLF+DVF
L1:	TLZ	F,CF+CCF+SF+FPF		;TURN OFF CONTROL, SYL, PERIOD FLAG
	SETZM	SYL
L1RPR:	SETZM	SYM
	MOVEI T,6
	MOVEM T,TEMDDT		;INIT SYMBOL COUNTER
	MOVE T,[POINT 7,TXT]	;SET UP POINTER FOR OPEVAL
	MOVEM T,CHP
	SETZM DENDDT
	SETZM WRD2

L2:	PUSHJ	P,TIN		;PICK UP CHARACTER
	CAIL	T,"A"+40
	CAILE	T,"Z"+40
	SKIPA
	TRC	T,40		;CONVERT LOWER CASE TO UPPER CASE
	TLNE	F,CF		;SKIP UNLESS THIS CHARACTER FOLLOWS ALTMODE.
	JRST	L21		;ALTMODE PRECEDES THIS CHARACTER
	CAIG	T,"Z"		;Z
	CAIGE	T,"A"		;A
	JRST	.+2
	JRST	LET
L21:	MOVE	R,T
	CAILE	T,137		;CHARACTERS ABOVE LOWER CASE "Z" ARE ILLEGAL
	JRST	ERR
	IDIVI	R,3
	LDB	W,BDISP(R+1)
;EEK, GASP!  I THINK THE PRECEDENCE IS BUILT IN TO THE ADDRESSES OF THE THINGS
	CAIGE	W,MULT-DDT	;FIRST EVAL ROUTINE
	JRST	DDT(W)
	MOVE	T,SYL
	TLZN	F,LTF
	JRST	POWER
	MOVE	T,[XWD OPEVAL,EVAL]	;LOOKUP ROUTINES IN CORRECT ORDER
	SKIPN	WRD		;USE SYMBOL TABLE FIRST IF SOMETHING THERE
	MOVSS	T
	MOVEM	T,SAVE
	JRST	L213

L212:	HLRZS	T,SAVE		;TRY NEXT EVALUATION ROUTINE
	JUMPE	T,UND1		;NEITHER ONE
L213:	PUSHJ	P,(T)
	JRST	L212		;TRY NEXT ONE
L4:	TLZE	F,MF
	MOVN 	T,T		;MINUS FLAG WAS SEEN
	TLNN	F,SF
	CAIE	W,LPRN-DDT
	JRST	.+2
	JRST	LPRN		;LEFT PAREN SEEN
	EXCH	T,FRASE1
	TLNN	F,DVF
	IMULB	T,FRASE1
	TLZE	F,DVF
	IDIVB	T,FRASE1
	CAIGE	W,ASSEM-DDT
	JRST	DDT(W)		;MULTIPLY OR DIVIDE
	ADDB	T,FRASE
	CAIGE	W,SPACE-DDT
	JRST	DDT(W)		; + - @ ,
	ADD	T,WRD
	TLNE	F,TIF		;TRUNCATE INDICATOR FLAG
	HLL	T,WRD		;TRUNCATE
	MOVEM	T,WRD
	TLNN	F,QF
	MOVE	T,LWT
	SETZM	R
	MOVE	W1,ESTUT
	CAMN	W1,ESTU		;IF THERE ARE ANY UNDEFINED SYMBOLS IN
	JRST	L5		;THE CURRENT EXPRESSION, ANYTHING EXCEPT
	CAILE	W,CARR-DDT	;FURTHER EXPRESSION INPUT, OR DEPOSITING
	JRST	ERR		;  INTO MEMORY IS ILLEGAL
L5:	CAIG	W,RPRN-DDT
	JRST	DDT(W)
	SKIPE	PRNC
	JRST	ERR
	PUSHJ	P,DDT(W)
RET:	MOVEI	P,PS
	PUSHJ	P,LCT		;TYPE A TAB
	JRST	DD2

ERR:	MOVEI	W1,"?"
	JRST	WRONG1
UNDEF:	MOVEI	W1,"U"
	JRST	WRONG1
↑WRONG:	MOVE	W1,[ASCII /XXX/]
WRONG1:	MOVEI	P,PS
IFE EDDT&1,<
	CLRBFI		;FLUSH TYPEAHEAD, ERROR MAY OCCUR BEFORE ACTIVATOR
>;IFE EDDT&1
	PUSHJ	P,TEXT
	PUSHJ	P,LCT	;TYPE TAB
IFN EDDT&1,<
	PUSHJ	P,LISTEN
	 JFCL
>;IFN EDDT&1
	JRST	DD2
;NUM LE1 DOLLAR PERC LET LET1 LE1A LE2 NUM1 NM1 POWER POW2

NUM:	ANDI	T,17		;T HOLDS CHARACTER
	TLNE	F,CF+FPF
	JRST	NM1		;$ OR . SEEN
	MOVE	W,SYL
	LSH	W,3
	ADD	W,T
	MOVEM	W,SYL		;ACCUMULATE OCTAL VALUE
	MOVE	W,DENDDT
	IMULI	W,12		;CONVERT TO DECIMAL
	ADD	W,T
	MOVEM	W,DENDDT	;ACCUMULATE DECIMAL VALUE
LE1:	AOJA	T,LE1A

;FLUSH NEXT LINE, INSERT LABEL "DOLLAR" NEAR "CONTRO", IF YOU WANT $ TO BE ALTMODE
DOLLAR:	SKIPA	T,[46+101-13]	;RADIX 50 $.
PERC:	MOVEI	T,47+101-13	;PERCENT SIGN
LET:	TLC	F,SF+FPF	;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN	F,LTF+FEF+SF+FPF
	CAIE	T,105		;E
	TLOA	F,LTF
	TLOA	F,FEF		;E SEEN AS EXPONENT
	JRST	LET1
	TLZN	F,MF		;MINUS FLAG?
	SKIPA	W1,SYL		;NOT MINUS
	MOVN	W1,SYL		;GOBBLE NEGATIVE VALUE
	MOVEM	W1,FSV		;SAVE FLOATING POINT VALUE.
	SETZM	DENDDT
LET1:	SUBI	T,101-13	;FORM RADIX 50 SYMBOL
LE1A:	TLO	F,SF+QF
LE2:	MOVE	W,SYM
	MOVEI	R,101-13(T)	;SET UP IN SIXBIT FOR OPEVAL
	IMULI	W,50		;CONVERT TO RADIX 50
	ADD	W,T
	SOSGE	TEMDDT		;IGNORE CHARACS AFTER 6
	JRST	L2		;GO IGNORE
	IDPB	R,CHP		;SAVE FOR OPEVAL
	MOVEM	W,SYM
	JRST	L2

NUM1:	EXCH	T,WRD2		;FORM NUMBER AFTER $
	IMULI	T,12
	ADDM	T,WRD2
	TRO	F,Q2F		;FLAG NUMBER SEEN AFTER ALTMODE
	JRST	L2

NM1:	TLNE	F,CF		;$ SEEN?
	JRST	NUM1		;YES. NOW NUMBER.
	MOVSI	R,204500	;FORM FLOATING POINT NUMBER.  R←10.0
	FMPRM	R,FHDTMP	;MULTIPLY THE DIVISOR BY 10.0
	FMPRM	R,FHTTMP	;MULTIPLY TOTAL ACCUMULATED NUMBER BY 10.0
	MOVSI	R,211000(T)	;UNNORMALIZED VALUE OF THIS DIGIT
	FADRB	R,FHTTMP	;ADD DIGIT TO TOTAL THUS FAR
	FDVR	R,FHDTMP	;DIVIDE BY APPROPRIATE POWER OF 10.0
	MOVEM	R,SYL		;STORE FLOATING VALUE
	AOJA	T,LE1A

POWER:	TLNN	F,FEF
	JRST	L4		;NO EXPONENT
	CAIE	W,PLUS
	CAIN	W,MINUS
	TROE	F,POWF
	TRZA	F,POWF
	JRST	(W)		; E+-

	MOVE	W2,DENDDT
	SETZM	FRASE
	MOVEI	W1,FT-1
	TLZE	F,MF
	MOVEI	W1,FT01
	SKIPA	T,FSV
POW2:	LSH	W2,-1
	TRZE	W2,1
	FMPR	T,(W1)
	JUMPE	W2,L4
	SOJA	W1,POW2
;PERIOD QUAN PILOC QUAN1 QUAN2 CONTRO

PERIOD:	MOVE	T,LLOC		;PERIOD ( . ) SEEN.  USUALLY THIS IS CURRENT LOCATION
	TLNE	F,SF		;BUT IF A SYLLABLE HAD BEEN STARTED IT MEANS
	MOVE	T,DENDDT	;DECIMAL OR FLOATING POINT
	MOVEM	T,SYL
	TLNE	F,FPF		;FLOATING POINT ON ALREADY?  I.E., ARE THERE 2 PERIODS?
	TLO	F,LTF		;TWO PERIODS.  THIS ONE IS A LETTER!
	TLON	F,FPF+SF+QF	;SET FLOATING POINT.  SKIP IF IN THE MIDDLE OF SYL
	MOVEI	T,0		;AT FRONT OF SYL. DO THE RIGHT THING FOR .69
	IDIVI	T,400		;FLOAT THE VALUE OF T (HOW?)
	SKIPE	T
	TLC	T,243000
	TLC	W1,233000
	FAD	T,[0]
	FAD	W1,[0]
	FADR	T,W1
	MOVEM	T,FHTTMP	;STORE FLOATING VALUE
	MOVSI	T,201400
	MOVEM	T,FHDTMP	;VALUE OF DIVISOR (10.0↑<NUMBER OF DIGITS AFTER POINT>)
	MOVEI	T,45		;RADIX 50 PERIOD
	JRST	LE2

QUAN:	TLNN	F,CCF		;skip if two $$ typed
	SKIPA	T,LWT		;LAST QUANTITY TYPED
	MOVS	T,LWT		;swapped last quantity
	SKIPA
PILOC:	MOVEI	T,SAVPI		;$I - PI STATUS
QUAN1:	MOVEM	T,SYL
QUAN2:	TLO	F,SF+QF		;WRD,SYL STARTED
	TLZ	F,CF+CCF
	JRST	L2

CONTRO:				;ALTMODE SEEN
IFN EDDT&1, <	MOVEI	T,"$"		
		PUSHJ	P,TOUT	;ECHO $  SINCE REAL ALTMODE DOESN'T ECHO>
;DOLLAR:			;INSERT LABEL TO TREAT $ AS ALTMODE.
	TLOE	F,CF
	TLO	F,CCF		;SET $$ FLAG IF CF WAS SET BEFORE
	JRST	L2
;ESTU ESTUT UND1 QUESTN QUEST1 QUEST2 QUEST4 UKILL KILL2 REMUN DUNDEF DEF3 DEF4 REMAUN REMAU1 EVAL0 EVAL1 EVAL2 EVAL3

;;Following block removed so that these symbols will be in block MDDT
;;BEGIN UNDEF ↔ SUBTTL	DDT - ASSEMBLY OF UNDEFINED SYMBOLS
;;	GLOBAL	F,P,R,S,T,W,W1,W2

;THESE ARE HERE BECAUSE MAPPING DDT DOESN'T SAVE THE UNDEFINED SYMBOL TABLE
↑ESTU:	0
↑ESTUT:	0

↑UND1:	MOVE	R,ESTUT		;UNDEFINED SYM ASSEMBLER
	HLRE	S,ESTUT
	ASH	S,-1		;SETUP EVAL END TEST
	HRLOI	W1,37777+DELI+LOCAL
	PUSHJ	P,EVAL2
	CAIN	W,ASSEM-DDT
	TLNN	F,ROF
	JRST	UNDEF
	SKIPE	PRNC
	JRST	UNDEF
	MOVEI	T,"#"
	CAIE	W,ASSEM-DDT
	PUSHJ	P,TOUT
	MOVN	R,[XWD 2,2]
	ADDB	R,ESTUT
	MOVE	T,SYM
	TLO	T,GLOBAL
	MOVEM	T,(R)
	HRRZ	T,LLOCO
	TLNE	F,MF
	TLO	T,400000
	MOVEM	T,1(R)
	MOVEI	T,0
	JRST	L4

; ? COMMAND - LIST UNDEFINED SYMBOLS
; sym? - list programs (blocks) in which SYM is defined

↑QUESTN:PUSHJ	P,CRF		;START WITH CRLF
	TLNE	F,LTF		;was a symbol name typed?
	JRST	QUESTB		;yes.  name the blocks in which sym is defined
	MOVE	R,ESTU		;GET POINTER TO UNDEF SYMS
QUEST1:	JUMPGE	R,DD1		;JUMP IF ALL DONE.
	MOVE	T,(R)		;GET NEXT SYMBOL
	SKIPA	W1,ESTU		;
QUEST2:	ADD	W1,[XWD 2,2]	;ADVANCE
	CAME	T,(W1)		;ARE TWO SYMBOLS THE SAME?
	JRST	QUEST2		;NOPE.
	CAME	R,W1		;ARE WE UP TO OURSELVES YET?
	JRST	QUEST4		;NO. THEN WE'VE OUTPUT THIS SYMBOL ALREADY
	PUSHJ	P,SPT		;OUTPUT SYMBOL
	PUSHJ	P,CRF		;AND A CRLF
QUEST4:	ADD	R,[XWD 2,2]	;ADVANCE TO NEXT SYMBOL
	JRST	QUEST1

QUESTB:	JUMPG	SMB,SQUEST	;Jump if sorted symbol table
	HLRE	R,@SYMP		;-Count
	MOVN	R,R		;+Count
	HRL	R,R		;+WC,,+WC
	HRRZ	T,@SYMP		;Address of first symbol pair
	ADD	R,T		;R ← +WC,,LAST ADDRESS+1
	PUSH	P,[0]		;name of current pgm
	PUSH	P,[0]		;name of current blk
QUESTC:	SUB	R,[XWD 2,2]	;ADVANCE
	JUMPL	R,[SUB P,[2,,2]
		   JRST DD1]
	LDB	T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN	T,3		;BLOCK?
	JRST	[MOVE T,(R)	;YES.
		 TLZ T,740000	;Clear type bits
		 MOVEM T,0(P)	;save block name in temp
		 JRST QUESTC]
	JUMPE	T,[MOVE T,(R)	;PROGRAM NAME
		   MOVEM T,-1(P);save pgm name in temp
		   SETZM 0(P)	;no block name
		   JRST QUESTC]
	MOVE	T,(R)		;Get Symbol name
	TLZ	T,740000	;FLUSH TYPE BITS
	CAME	T,SYM		;MATCH RADIX50 STUFF
	JRST	QUESTC		;JUMP IF NO MATCH
	SKIPN	T,-1(P)		;pgm name (if none, it's global)
	JRST	QUESTD		;just print value
	PUSHJ	P,SPT1		;print pgm name
	MOVEI	T,":"
	PUSHJ	P,TOUT
	SKIPN	T,0(P)
	JRST	QUESTD		;no block name
	PUSHJ	P,SPT1		;block name
	MOVEI	T,"&"
	PUSHJ	P,TOUT
QUESTD:	PUSHJ	P,LCT		;print tab
	MOVE	T,1(R)
	PUSHJ	P,TOC		;print value
	PUSHJ	P,CRF
	JRST	QUESTC

;KILL AN UNDEFINED SYMBOL
↑UKILL:	MOVE	R,ESTU			;REMOVE UNDEFINED SYMS
	JUMPGE	R,UNDEF			;IF NO UNDEFINED SYMS THEN ARG IS UNDEF.
KILL2:	PUSHJ	P,EVAL0
	JRST	RET			;NONE LEFT.
	PUSHJ	P,REMUN			;REMOVE ONE UNDEFINED SYMBOL
	JRST	KILL2

REMUN:	MOVE	S,[XWD 2,2]		;REMOVE ONE UNDEFINED SYMBOL
	ADDB	S,ESTU
	MOVE	W,-2(S)			;MOVE LAST SYMBOL IN TABLE TO
	MOVEM	W,(R)			;CLOBBER THE SYMBOL THAT'S DELETED.
	MOVE	W,-1(S)
	MOVEM	W,1(R)
	POPJ	P,

↑DUNDEF:				;DEFINE AN UNDEFINED SYMBOL
	MOVE	R,ESTU
DEF3:	JUMPGE	R,CPOPJ			;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE	T,SYM
	CAME	T,(R)
	JRST	DEF4
	MOVE	S,DEFV
	SKIPGE	1(R)
	MOVN	S,S
	PUSH	P,R
	MOVE	R,1(R)
	PUSHJ	P,FETCH
	 JRST	ERR
	ADD	S,T
	HRRM	S,T
	PUSHJ	P,DEP
	POP	P,R
	PUSHJ	P,REMUN			;REMOVE THE NOW DEFINED SYMBOL
DEF4:	ADD	R,[XWD 2,2]		;ADVANCE TO NEXT SYMBOL
	JRST	DEF3

;REMOVED UNDEFINED SYMBOLS THAT WERE REFERENCED AT THIS ADDRESS
↑REMAUN:MOVE	R,ESTU
	MOVEM	W1,ESTU
REMAU1:	JUMPGE	R,CPOPJ
	HRRZ	W,1(R)
	CAMN	R,LLOCO
	PUSHJ	P,REMUN
	ADD	R,[2,,2]
	JRST	REMAU1


;EVAL0 - CALLED FROM UNDEFINED SYMBOL KILL
;EVAL2 - CALLED FROM UNDEFINED SYMBOL ASSEMBLER

EVAL0:	HRLOI	W1,37777+DELI
	HLRE	S,@SYMP
	ASH	S,-1		;SETUP END TEST
	JRST	EVAL3

EVAL1:	ADD	R,[XWD 2,2]
EVAL2:	SKIPL	R
	MOVE	R,@SYMP
	AOJG	S,CPOPJ		;TRANSFER IF NO SYMBOL FOUND
EVAL3:	MOVE	T,(R)
	XOR	T,SYM
	TLNN	T,PNAME
	TLOA	W1,LOCAL
	TDNE	T,W1
	JRST	EVAL1
	TLNN	T,340000
	JRST	EVAL1
	MOVE	T,1(R)
	JRST	CPOPJ1		;FOUND SYMBOL, SKIP

;;BEND	UNDEF
;⊗ CHKSYM SRTCHK SRTCH2 KILL TAG DEFIN DEF1 DEF2 PNAMES PPNAM1 PPNAM2 GETPGM GETPG1 GETPG2 SETNAM SET1 SET2 SET3 SETBLK SB1 SBPRM PBLKNS PBLKN1 PBLKN2 SYMD

	SUBTTL	DDT - SYMBOL MANIPULATION ROUTINE

;THIS SEQUENCE INITS SYM TABLE LOGIC
↑CHKSYM:HLRZ	T,ESTU		;0,,-NUMBER OF UNDEFINED SYMBOLS
	SUB	T,ESTU		;T← NUMBER OF UNDEFINED,,-LAST ADDRESS OF UNDEFINEDS
	MOVE	W,@SYMP
	ADD	T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	TRNE	T,-1		;NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	HRRZM	W,ESTU		;RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.
	PUSHJ P,SRTCHK		;see if symbols are sorted, set up SMB
	 JRST SSCHK		;symbols are sorted, go initialize things
	MOVE	T,PRGM
	SUB	T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	TSC	T,T		;NAME (PRGM) PNTR DO NOT END UP IN THE
	MOVE	W1,PRGM		;SAME PLACE, OR THEY DO NOT BOTH START ON
	XOR	W1,W		;AN EVEN (OR BOTH ON ODD) LOCATION, OR
	TRNN	W1,1		;PRGM .GE. 0, THEN RE-INIT PRGM.
	JUMPE	T,CPOPJ		;RETURN NOW IF HAPPY
	SETZM	PRGM		;NEED NEW PROGRAM AND BLOCK NAME
	SETZM	BLOCK
	POPJ	P,

;Check to see if the symbols are sorted.  If not sorted, skips w/SMB set to zero.
;If sorted, sets up SMB to point to symbol table and takes direct return.
↑SRTCHK:SKIPL @SYMP		;SKIP IF THERE ARE REALLY SYMBOLS SOMEWHERE
	JRST SRTCH2		;no symbols, so they're not sorted
	HRRZ SMB,@SYMP		;BASE OF SYMBOLS (IF SORTED)
	HLLO T,(SMB)		;GET FIRST WORD OF THE SYMBOL TABLE
	AOJE T,CPOPJ		;JUMP IF THIS IS NEW FORMAT(sorted)
SRTCH2:	MOVEI SMB,0		;FLAG OLD MODE (unsorted)
	JRST CPOPJ1		;skip for unsorted symbols

KILL:	TLNN	F,LTF			;$K - DELETE SYMBOLS
	JRST	ERR
	PUSHJ	P,EVAL
	JRST	UKILL			;SYMBOL WASN'T DEFINED.  KILL UNDEF SYMS.
	MOVEI	T,DELO/200000		;DELETE OUTPUT
	TLNE	F,CCF			;$$K TYPED?
	IORI	T,DELI/200000		;YES. DELETE BOTH INPUT AND OUTPUT
	JUMPG	SMB,SKILL		;JUMP IF SORTED SYMBOL TABLE.
	DPB	T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
	JRST	RET

TAG:	JUMPG	SMB,SRTAG		;HANDLE TAGS IN SORTED SYMBOL TABLE
	TLNN	F,LTF   		;NO LETTERS IS ERROR
	JRST	PNAMES 			;GO SAY ERROR (EXCEPT $: COMMAND)
	TLNE	F,FAF   		;DEFINE SYMBOLS
	JRST	DEFIN			;A less-than-sign B:
	TLNE	F,CF			;DEFINE SYMBOL AS OPEN REGISTER
	JRST	SETNAM
	MOVE	W,LLOCO
	HRRZM	W,DEFV
DEFIN:	PUSHJ	P,EVAL			;NEW SYMBOL?
	JRST	DEF1			;YES.  ENTER IT.
	JRST	DEF2			;NO, REDEFINE

DEF1:	MOVN	R,[XWD 2,2]		;ADD NEW SYMBOL
	ADDB	R,@SYMP			;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ	T,ESTU
	SUBI	T,2
	HRL	T,ESTU
	HRRM	T,ESTU
	SKIPGE	ESTU
	BLT	T,-1(R)
DEF2:	MOVE	T,DEFV
	MOVEM	T,1(R)			;PUT IN NEW VALUE
	MOVSI	T,GLOBAL
	IORB	T,SYM
	MOVEM	T,(R)			;PUT IN NEW SYM AS GLOBAL
	PUSHJ	P,DUNDEF		;DEFINE AN UNDEFINED SYMBOL
	JRST	RET


;$: - LIST NAMES OF PROGRAMS
PNAMES:	TLNN	F,CF			;$: COMMAND?
	JRST	ERR			;NO.  NO LETTERS AND : IS ERROR
	SYMTST
	PUSHJ	P,CRF			;START WITH CRLF
	MOVE	R,@SYMP			;GET POINTER TO SYMS
PPNAM1:	JUMPGE	R,DD1			;JUMP IF ALL DONE.
	SKIPE	T,(R)			;GET NEXT SYMBOL
	TLNE	T,740000		;TYPE BITS ARE ALL ZERO?
	JRST	PPNAM2			;NO
	PUSHJ	P,SPT1			;PRINT NAME
	PUSHJ	P,CRF
PPNAM2:	ADD	R,[XWD 2,2]		;ADVANCE TO NEXT SYMBOL
	JRST	PPNAM1


;FIND A PROGRAM NAME TO OPEN AUTOMATICALLY THE FIRST TIME DDT IS ENTERED.
GETPGM:	SETOM	GETFLG			;prevent coming back here.
	SYMTST
	JUMPG	SMB,SRGPGM		;DIFFERENT IF SORTED TABLE
	SKIPA	R,@SYMP
GETPG1:	ADD	R,[2,,2]		;ADVANCE TO NEXT SYMBOL NAME
	JUMPGE	R,DD2			;JUMP IF FAILURE.
	SKIPE	T,(R)
	TLNE	T,740000		;PROGRAM NAME?
	JRST	GETPG1
IFN UEDDTS,<
	CAME T,[RADIX50 0,RAID]		;LOOK FOR REAL PROGRAM THAT MIGHT
	CAMN T,[RADIX50 0,UDDT]		; BE LOADED WITH A DEBUGGER
	JRST GETPG1			;IGNORE DEBUGGERS' PROGRAM NAMES
>;IFN UEDDTS
	CAME	T,[XTITLE]		;IGNORE OUR OWN PROGRAM NAME.
	CAMN	T,[RADIX50 0,JOBDAT]
	JRST	GETPG1			;IGNORE THE ONES THAT ARE ALWAYS THERE.
	PUSHJ	P,GETPG2		;SUBR TO PRINT THE PROGRAM NAME $ :
	JRST	SET2

GETPG2:	MOVEM	T,SYM
	PUSHJ	P,SPT1			; TYPE WHICH PROGRAM WE'VE OPENED.
	MOVEI	T,"$"
	PUSHJ	P,TOUT
	MOVEI	T,":"
	JRST	TOUT

;SET PROGRAM NAME  NAME$:
SETNAM:	SYMTST
	MOVE	R,@SYMP
SET1:	JUMPGE	R,UNDEF			;JUMP IF WE'VE RUN OUT.
	MOVE	T,(R)
	CAMN	T,SYM
	JRST	SET2			;FOUND ONE!
	ADD	R,[XWD 2,2]
	JRST	SET1			;ADVANCE AND LOOP

SET2:	MOVEM	R,PRGM			;STORE IOWD POINTER TO PROGRAM NAME.
	SETZM	BLOCK			;CLEAR BLOCK NAME
SET3:	CAMN	R,@SYMP			;OFF THE END YET?
	JRST	RET			;YES.
	SUB	R,[XWD 2,2]		;NO.  GET NEXT SYMBOL
	LDB	T,[POINT 4,(R),3]
	JUMPE	T,RET			;RETURN WHEN ANOTHER PROGRAM IS SEEN.
	CAIE	T,3
	JRST	SET3			;LOOP ON SYMBOLS.
	MOVE	T,(R)			;HERE'S A BLOCK NAME.
	XOR	T,SYM			;SEE IF THE BLOCK NAME MATCHES THE PROGRAM
	TLZ	T,740000		;TURN OFF MODE BITS
	JUMPN	T,SET3			;LOOP IF NO MATCH
	JRST	SBPRM			;BLOCK NAME = PROGRAM NAME.
					;STORE R AS CURRENT BLOCK POINTER.

;HERE WE HAVE BNAME$&	OPEN A BLOCK INSIDE CURRENT PROGRAM
;OR WE MAY HAVE BNAME&SNAME - OPEN BLOCK TEMPORARILY.

SETBLK:	JUMPG	SMB,SBLOCK		;JUMP IF NEW FORMAT SYMBOLS
	TLNN	F,LTF
	JRST	PBLKNS			;NO LETTERS. $& COMMAND PRINTS BLOCK NAMES
	SKIPL	R,PRGM			;PROGRAM OPEN YET?
	JRST	ERR			;NO.  ERROR.
	SYMTST
SB1:	CAMN	R,@SYMP			;DONE LOOKING?
	JRST	UNDEF			;YES. CAN'T FIND ONE.
	SUB	R,[XWD 2,2]		;ADVANCE TO NEXT ONE
	LDB	T,[POINT 4,(R),3]
	JUMPE	T,UNDEF			;IF WE REACH ANOTHER PROGRAM, WE'VE LOST
	CAIE	T,3
	JRST	SB1			;IGNORE SYMBOLS OTHER THAN BLOCK NAMES
	MOVE	T,(R)
	XOR	T,SYM
	TLZ	T,740000
	JUMPN	T,SB1			;DOESN'T MATCH.
	TLNE	F,CF			;WE HAVE ONE.  ALTMODE SEEN?
	JRST	SBPRM			;ALTMODE
	MOVEM	R,TBLK			;SET TEMPORARY BLOCK NAME
	JRST	L1RPR

SBPRM:	MOVEM	R,BLOCK			;SET IOWD POINTER TO BLOCK.
	JRST	RET


PBLKNS:	TLNN	F,CF			;$&
	JRST	ERR			;ERROR
	SYMTST
	PUSHJ	P,CRF			;START WITH CRLF
	SKIPGE	R,PRGM			;IS THERE A PROGRAM OPEN?
	CAMN	R,@SYMP
	JRST	DD1			;NO.  NOTHING TO TYPE.
PBLKN1:	SUB	R,[2,,2]
	SKIPN	(R)
	JRST	PBLKN2			;IGNORE ZERO SYMBOL NAMES
	LDB	T,[POINT 4,(R),3]	;GET TYPE BITS
	JUMPE	T,DD1			;EXIT IF WE SEE ANOTHER PROGRAM NAME
	CAIE	T,3			;BLOCK NAME SEEN?
	JRST	PBLKN2			;NO
	LDB	T,[POINT 32,(R),35]	;GET RADIX50 OF BLOCK NAME
	PUSHJ	P,SPT1			;PRINT NAME
	PUSHJ	P,CRF
PBLKN2:	CAMN	R,@SYMP			;AT END OF SYMBOL TABLE YET?
	JRST	DD1			;YES. THEN DONE.
	JRST	PBLKN1			;NO

SYMD:	MOVEI	T,DELO/200000		;$D - DELETE LAST SYM & PRINT NEW
	JUMPE	SMB,.+2			;JUMP UNLESS SORTED SYMBOLS
	PUSHJ	P,SSYMD			;SETUP R AND ALWAYS SKIP ONCE
	HRRZ	R,SPSAV			;PICK UP POINTER TO LAST SYM
	JUMPE	R,ERR			;NO LAST SYMBOL
	DPB	T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	PUSHJ	P,LCT			;Print tab
	MOVE	T,LWT			;GET VALUE PART
	PUSHJ	P,CONSYM		;PRINT OUT NEXT BEST SYMBOL
	JRST	RET
;LOOK LOOK1 LOOK2 LOOK3 LOOK LOOK1 LOOK2 LOOK2A LOOK3 LOOK3A TOPDWD TOPDWN BLNME BLNM1 BLNM2 PNAM PNAM2 LOOK4 LOOK5 LOOK5A SPT0 SPT SPT1X SPT1W SPT1 SPT2 SPT3

;	LOOK - VALUE TO SYMBOL

; SYMBOL TYPE BITS
; 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 14 - BLOCK TYPE
; 10 - LOCAL
; 04 - GLOBAL
; 00 - PROGRAM NAME


REPEAT 0,<
LOOK:	SKIPL R,PRGM	;LOOK UP SYMBOL
	MOVE R,@SYMP
	HLRE S,@SYMP
	ASH S,-1	;SETUP COUNT FOR LENGTH OF SYM TABLE
	TLZ F,400000
	HRLZI W2,DELO+DELI
	MOVEM T,TEMDDT

LOOK1:	TDNE W2,(R)
	JRST LOOK3
	MOVE T,(R)
	TLNN T,PNAME	;NAME
	TLOA W2,LOCAL
	SKIPA T,TEMDDT
	JRST LOOK3
	MOVE W,1(R)
	XOR W,T
	JUMPL W,LOOK3
	SUB T,1(R)
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,1(R)
	SUB W,1(W1)
	JUMPLE W,LOOK3
LOOK2:	HRR W1,R		;POINTER BEST VALUE SO FAR
	TLO F,400000
	JUMPE T,SPT0
LOOK3:	ADD R,[XWD 2,2]
	SKIPL R
	MOVE R, @SYMP
	AOJLE S,LOOK1	;TERMINATING CONDITION
	MOVE T,TEMDDT
	TLNE F,400000
	SUB T,1(W1)
	JRST CPOPJ1
>


;ENTER HERE WITH T CONTAINING A VALUE FOR WHICH A SYMBOL IS SOUGHT.
;IF A SYMBOL THAT MATCHES THE VALUE T EXACTLY IS FOUND, IT'S NAME WILL
;BE PRINTED AND THE DIRECT RETURN TAKEN.  IF NO EXACT MATCH IS FOUND,
;THE CLOSEST SYMBOL WHOSE VALUE HAS THE SAME SIGN AS C(T) AND IS SMALLER
;THAN C(T) WILL BE POINTED TO BY W1 AND THE SKIP RETURN TAKEN.
;IF NO MATCH AT ALL IS FOUND, DOUBLE SKIP RETURN.


LOOK:	SETZM	SVFB		;POINTER TO BLOCK WHERE MATCH WAS FOUND
	SETZM	SVTB		;POINTER TO CURRENT BLOCK.
	SETZM	BLVL		;BLOCK LEVEL
	SYMTST
	JUMPG	SMB,SLOOK	;JUMP IF USING SORTED SYMBOL TABLE
	HLRE	S,@SYMP		;-WC OF SYMBOL TABLE
	ASH	S,-1		;-NUMBER OF SYMBOLS
	TLZ	F,600000
	MOVEM	F,SVF		;INITIALZE SVF (USED FOR AVAILABLE SYMBOLS)
	MOVSI	W2,DELO+DELI	;IGNORE SYMBOLS WITH THESE BITS SET
	MOVEM	T,TEMDDT	;SAVE ARGUMENT
	SKIPL	R,PRGM		;IS THERE SOME PROGRAM OPEN?
	JRST	TOPDWD		;NO - SEARCH ENTIRE TABLE.
LOOK1:	SUB	R,[XWD 2,2]	;BACKUP TO NEXT SYMBOL (SKIPS PROGRAM NAME)
	TDNE	W2,(R)		;IS SYMBOL SUPPRESSED?
	JRST	LOOK3		;YES.  LOOK FOR ANOTHER SYMBOL.
	LDB	T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN	T,3		;TYPE 14 IS A BLOCK NAME
	JRST	BLNME
	JUMPE	T,PNAM		;TYPE 0 IS A PROGRAM NAME
	MOVE	T,TEMDDT	;GET ARGUMENT (VALUE SOUGHT)
	MOVE	W,1(R)		;GET VALUE PART OF THIS SYMBOL
	XOR	W,T
	JUMPL	W,LOOK3		;SIGN BITS DIFFER - THIS MATCH IS NO GOOD
	SUB	T,1(R)		;COMPUTE THE DIFFERENCE
	JUMPL	T,LOOK3		;JUMP IF SYMBOL IS TOO BIG
	JUMPGE	F,LOOK2		;JUMP IF NO PREVIOUS "GOOD" MATCH
	MOVE	W,1(R)		;GET VALUE AGAIN
	SUB	W,1(W1)		;COMPARE WITH PREVIOUS GOOD MATCH
	JUMPLE	W,LOOK3		;JUMP IF PREVIOUS GOOD MATCH WAS BETTER THAN THIS
LOOK2:	HRR	W1,R		;A "BETTER" MATCH HAS BEEN FOUND.
	TLO	F,400000	;FLAG THAT A MATCH EXISTS
	TLNE	F,200000	;IN THE CURRENTLY OPEN BLOCK OR IN A SUPERIOR?
	JRST	LOOK2A		;YES.  DON'T BOTHER REMEMBERING A BLOCK NAME
	MOVE	W,SVTB
	MOVEM	W,SVFB		;POINTER TO BLOCK WHERE WE FOUND THIS SYMBOL
LOOK2A:	TLNE	W2,LOCAL	;ARE WE SEEKING GLOBALS ONLY?
	SETZM	SVFB		;YES.  THEN WHAT WE FOUND HAS NO BLOCK NAME
	JUMPE	T,LOOK4		;JUMP IF EXACT MATCH
LOOK3:	CAMN	R,@SYMP		;AT END OF TABLE YET?
	JRST	TOPDWN		;YES. - SEARCH UNOPENED PROGRAMS NOW.
LOOK3A:	AOJLE	S,LOOK1		;WHILE WORDS ARE LEFT IN SYMTAB, LOOP.
	MOVE	T,TEMDDT	;GET ARGUMENT
	JUMPGE	F,CPOPJ2	;JUMP IF NO MATCH
	SUB	T,1(W1)		;CALCULATE THE DIFFERENCE
	JUMPE	T,SPT0		;IT WAS EXACT MATCH.  PRINT IT AND RETURN.
	JRST	CPOPJ1		;SINGLE SKIP RETURN - INEXACT MATCH

TOPDWD:	TLO	W2,LOCAL	;NO PROGRAM OPEN.  MATCH ONLY GLOBALS
TOPDWN:	HLRE	R,@SYMP		;- WC OF SYMBOL TABLE.
	MOVNS	R		;+WC
	ADD	R,@SYMP		;FOR -WC,,LAST ADDRESS+1
	JRST	LOOK3A
;NOTE THAT THE COUNT S, PREVENTS US FROM RESCANNING AREAS WE'VE SEEN BEFORE

;HERE WHEN A BLOCK NAME IS SEEN.
BLNME:	MOVEM	R,SVTB		;SAVE ADDRESS OF THE BLOCK NAME WE'VE SEEN
	MOVE	T,1(R)		;BLOCK LEVEL
	CAMN	R,BLOCK		;IS THIS THE CURRENTLY OPEN BLOCK?
	JRST	BLNM1		;YES. SET BLVL OF OPEN BLOCK
	CAML	T,BLVL		;IS THIS A SUPERIOR OF CURRENT BLOCK?
	JRST	BLNM2		;NO. NOT A SUPERIOR OF CURRENT BLOCK
BLNM1:	MOVEM	T,BLVL		;STORE CURRENT BLOCK LEVEL
	TLOE	F,200000	;WE ARE COMING INTO AN AVAILABLE BLOCK.  SET FLAG
	JRST	LOOK3		;WE WERE ALREADY IN AN AVAILABLE BLOCK.
	EXCH	F,SVF		;USE ALTERNATE VERSIONS OF F,W1
	EXCH	W1,SW1
	JRST	LOOK3

;ENTERING A BLOCK NOT AVAILABLE TO CURRENTLY OPEN BLOCK
BLNM2:	TLZN	F,200000	;WERE WE IN AN AVAILABLE BLOCK?
	JRST	LOOK3		;NO.
	EXCH	F,SVF		;YES,  PUT F AND W1 BACK WHERE WE CAN FIND THEM
	EXCH	W1,SW1		;   WHEN WE ENTER ANOTHER AVAILABLE BLOCK.
	JRST	LOOK3

;HERE IF WE SEE A PROGRAM NAME.  THIS MEANS THAT WE HAVEN'T FOUND AN EXACT
;MATCH IN THE CURRENTLY OPENED PROGRAM.  ANY FURTHER MATCHES CAN ONLY BE
;GLOBALS.

PNAM:	TLO	W2,LOCAL	;SET MASK TO SELECT GLOBALS ONLY.
	TLNN	F,200000	;WERE WE INSIDE AN AVAILABLE BLOCK?
	JRST	LOOK3		;NO.
	JUMPGE	F,LOOK5		;JUMP IF NO "GOOD" MATCHS FROM AVAILABLE BLOCKS
	MOVE	F,SVF		;GET FLAGS FROM UNAVAILABLE BLOCKS
	JUMPGE	F,PNAM2		;JUMP IF NO "GOOD" MATCHES FROM UNAVAILABLE BLOCKS
	MOVE	T,1(W1)		;GET VALUE OF MATCH FROM AVAILABLE BLOCKS.
	EXCH	W1,SW1		;GET POINTER FROM UNAVAILABLE BLOCK
	CAMGE	T,1(W1)		;WHICH IS BETTER? (LARGEST IS BEST)
	JRST	LOOK5A		;SYMBOL FROM UNAVAILABLE BLOCK IS BETTER
	MOVE	W1,SW1		;RE EXCHANGE,  W1←POINTER TO BEST VALUE
PNAM2:	SETZM	SVFB		;NOT IN ANY BLOCK NOW
	TLO	F,400000	;FLAG WE HAVE A GOOD VALUE
	TLZ	F,200000	;WE ARE NOT IN AN AVAILABLE BLOCK
	JRST	LOOK3

LOOK4:	TLZN	F,200000	;EXACT MATCH.  ARE WE IN AN AVAILABLE BLOCK?
	JRST	LOOK3		;NO.  KEEP LOOKING
	SETZM	SVFB		;CLEAR SAVED BLOCK NAME.
	JRST	SPT0		;GO PRINT SOMETHING

;NO GOOD MATCHES FROM AVAILABLE BLOCKS
LOOK5:	EXCH	F,SVF		;RESTORE F, W1
	EXCH	W1,SW1
LOOK5A:	MOVE	T,1(W1)		;SYMBOL FROM UNAVAILABLE BLOCK IS BETTER
	CAMN	T,TEMDDT
	JRST	SPT0		;EXACT MATCH - PRINT IT.
	TLZ	F,200000	;NO LONGER INSIDE AN AVAILABLE BLOCK
	JRST	LOOK3


;RADIX 50 SYMBOL PRINT
SPT0:	HRRZM	W1,SPSAV	;SAVE POINTER TO TYPED SYM
SPT:	MOVE	T,SVFB		;GET BLOCK NUMBER
	JUMPE	T,SPT1W		;NONE THERE
	CAMN	T,BLOCK		;SAME BLOCK AS THE ONE THAT'S OPEN?
	JRST	SPT1W		;YES.  DON'T TYPE BLOCK NAME
	PUSH	P,W1		;SAVE..
	JUMPE	SMB,SPT1X	;JUMP IF OLD FORMAT SYMBOLS
	ADD	T,1(SMB)	;POINTER TO BLOCK NAMES
	ADDI	T,(SMB)
SPT1X:	LDB	T,[POINT 32,(T),35]	;GET BLOCK NAME (AND NO TYPE BITS)
	PUSHJ	P,SPT1		;TYPE IT.
	MOVEI	T,"&"
	PUSHJ	P,TOUT		;TYPE AMPERSAND
	POP	P,W1
SPT1W:	LDB	T,[POINT 32,(W1),35]	;GET SYMBOL (NO TYPE BITS)
SPT1:	IDIVI	T,50
	HRLM	W1,0(P)
	JUMPE	T,SPT2
	PUSHJ	P,SPT1
SPT2:	HLRZ	T,0(P)
	JUMPE	T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI	T,260-1
	CAILE	T,271
	ADDI	T,301-272
	CAILE	T,332
	SUBI	T,334-244
	CAIN	T,243
SPT3:	MOVEI	T,256
	JRST	TOUT

;EVAL EVL2 EVL1 EV4 EV3 EV1 EV2B EV2

;	EVAL - SYMBOL TO VALUE
;GIVEN A SYMBOL NAME IN SYM, RETURN ITS VALUE IN T AND ITS POINTER IN R AND SKIP.
;DIRECT RETURN IF SYMBOL UNDEFINED (IN CURRENT BLOCK AND ITS SUPERIORS)


;THIS IS THE WFW BLOCK STRUCTURE PATCH 
EVAL:	SYMTST
	MOVSI	W1,DELI		;DON'T MATCH KILLED SYMBOLS
	JUMPG	SMB,SEVAL	;USE SPECIAL EVAL IF SORTED.
	HLRE	S,@SYMP
	ASH	S,-1		;- NUMBER OF SYMBOLS IN TABLE
	SKIPL	R,TBLK		;TBLK IS SET BY FOO& (I.E., TEMPORARY BLOCK NAME)
	JRST	EVL1		;NO TEMP. BLOCK NAME SET
	SETZM	TBLK		;USE TEMP BLOCK NAME ONLY ONCE
EVL2:	MOVE	T,1(R)
	MOVEM	T,BLVL
	JRST	EV1

EVL1:	SKIPGE	R,BLOCK		;IS THERE AN OPEN BLOCK?
	JRST	EVL2		;YES. USE IT.
	MOVEI	T,1		;NO BLOCK OPEN. 
	MOVEM	T,BLVL		;SET BLOCK LEVEL TO 1
	SKIPGE	R,PRGM		;IS THERE A PROGRAM OPEN?
	JRST	EV1		;YES. USE IT
EV4:	HLRE	R,@SYMP
	MOVNS	R
	ADD	R,@SYMP		;R ← -WC,,LAST ADDRESS+2 - USE ENTIRE SYMBOL TABLE
	JRST	EV1		;(BUT ONLY MATCH GLOBALS SINCE FIRST THING WE'LL
				;  SEE IS A PROGRAM NAME)

EV3:	CAMN	R,@SYMP		;AT THE END OF PASS1?
	AOJL	S,EV4		;YES.  INITIATE PASS2  (SCAN REMAINDER)
	AOJGE	S,CPOPJ
EV1:	SUB	R,[XWD 2,2]	;ADVANCE
	MOVE	T,(R)		;GET SYMBOL NAME
	TDNE	T,W1		;FLUSHABLE?
	JRST	EV3		;YES.  GET NEXT
	LDB	T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN	T,3		;BLOCK?
	SOJA	S,EV2		;YES.  (BUGGER S, WILL BE UNBUGGERED LATER)
	SKIPN	T		;PROGRAM NAME
	TLOA	W1,LOCAL	;YES.  SET TO MATCH ONLY GLOBALS NOW
	SKIPA	T,(R)		;ORDINARY SYMBOL.  GET ITS VALUE
	JRST	EV3		;(FOR PROGRAMS, LOOP TO NEXT SYMBOL)
	XOR	T,SYM		;MATCH RADIX50 STUFF
	TLZ	T,740000	;FLUSH TYPE BITS
	JUMPN	T,EV3		;JUMP IF NO MATCH
	MOVE	T,1(R)		;RETURN VALUE IN T
	JRST	CPOPJ1

EV2B:	SUB	R,[2,,2]	;ADVANCE UNTIL WE GET ANOTHER BLOCK NAME
	LDB	T,[POINT 4,(R),3]
	CAIE	T,3
	AOJA	S,EV2B		;LOOP UNTIL A BLOCK NAME IS SEEN
EV2:	MOVE	T,1(R)		;HERE FOR A BLOCK NAME. GET ITS LEVEL
	CAML	T,BLVL		;DOES IT SURROUND THE BLOCK WE'RE IN?
	AOJA	S,EV2B		;NO. THIS IS NOT AN AVAILABLE BLOCK!
	MOVEM	T,BLVL		;STORE BLOCK LEVEL OF SURROUNDING BLOCK
	AOJA	S,EV3		;SCAN MORE.
;⊗ BLKNAM BLKNA1 BLKNA2 LASSYM S.SYM X.SYM UNIQ UNIQP SYMRNG TXCT FFETCH FNDHI FNDLO C3FLG SSCHK SSCHK1 SSCHK2 SRTAG SRDEF SRDEF1 SPNAME SPROG SPNAM1 SPRG0 SPRG1 SPRG2 SPRG3 SPRG4 SRGPGM SRGPG1 SRGPG3 SBLOCK SBLK1 SBLK2 SBLK3 SPBNS SPBNS1

IFN FTDMAP,<
;Block name lookup.  Returns block number in T for block name given in T.
;Skips if block name not found, else returns block number in T w/direct return.
;Always takes error return if symbols not sorted.
↑BLKNAM:JUMPE SMB,CPOPJ1	;take error return quickly if symbols not sorted
	MOVEM T,SYM		;save block name we're searching for
	HRRZ	W1,1(SMB)	;POINTER TO BLOCK NAMES AREA
	ADDI	W1,1(SMB)	;POINTER TO BN+1
	ADD	W1,PRGM		;POINTER TO THE PROGRAM NAME +1
	HRRZ	W2,2(SMB)	;POINTER TO BS AREA
	ADDI	W2,(SMB)	;DIRECT POINTER TO IT.
BLKNA1:	CAMG	W2,W1		;WHEN WE GET TO THE END
	JRST CPOPJ1		;IT'S TIME TO QUIT (failure return)
	MOVE	T,(W1)		;GET RADIX50
	TLZN	T,740000	;SHOULD HAVE SOME TYPE BITS ON FOR A BNAME
	AOJA W1,BLKNA1		;THIS MUST BE THE NEXT PROGRAM NAME
	XOR	T,SYM		;COMPARE WITH SYMBOL GIVEN
	JUMPE	T,BLKNA2	;JUMP IF WE'VE GOT ONE!
	AOJA	W1,BLKNA1

BLKNA2:	SUBI	W1,(SMB)
	SUB	W1,1(SMB)
	HRRZM	W1,T		;return block nbr in T
	POPJ P,			;success
>;IFN FTDMAP

;;Following block removed so that these symbols will be in block MDDT
;;BEGIN SYMSRT ↔ 	SUBTTL	DDT - SORTED SYMBOL TABLE MANIPULATIONS

;;	GLOBAL	F,P,R,S,T,W,W1,W2,SMB

LASSYM:	0
S.SYM:	BLOCK	3
X.SYM:	BLOCK	3
UNIQ:	0
UNIQP:	0
SYMRNG:	0
TXCT:	0
FFETCH:	0
FNDHI:	0
FNDLO:	0
C3FLG:	0			;SET FOR CLASS3 SYMBOLS IN FNDSYM.

;INITIALIZE PRGM AND BLOCK IF NEEDED.

↑SSCHK:	SETOM	TBLK
	SKIPGE	T,PRGM			;IS PRGM SET NON-NEGATIVE?
	JRST	SSCHK1			;NO. INITIALIZE BOTH
	SKIPL	BLOCK			;BLOCK NEGATIVE?
	CAMGE	T,BLOCK			;NO.  THEN BLOCK MUST BE LARGER THAN PRGM
	SKIPA	R,T			;SO FAR, OK.
	JRST	SSCHK1			;SOMETHINGS SCREWED UP.
	ADD	T,1(SMB)
	ADDI	T,(SMB)
	MOVE	T,(T)
	TLNE	T,740000		;SKIP IF THIS IS A PROGRAM NAME.
	JRST	SSCHK1			;LOSE.
	SKIPGE	T,BLOCK			;IS THERE A BLOCK NAME?
	JRST	SSCHK2			;NO. THEN WE'RE DONE
	ADD	T,2(SMB)
	ADDI	T,(SMB)
	HLRZ	T,(T)			;GET POINTER TO THIS BLOCK'S PROGRAM
	CAME	T,PRGM			;BLOCK SHOULD POINT TO PROGRAM
	PUSHJ	P,SPRG3			;AND IT DOESN'T.  REFRESH IT.
	JRST	SSCHK2


SSCHK1:	SETOM	PRGM			;INITIALIZE PRGM AND BLOCK POINTER
	SETOM	BLOCK			;(ZEROS ARE LEGAL VALUES)
SSCHK2:	HRRZ	R,5(SMB)		;POINTER TO CLASS1
	HRRZ	S,11(SMB)		;POINTER TO END OF CLASS4
	SUBM	R,S			;-NUMBER OF WORDS OF SYMBOL-VALUE PAIRS
	HRL	R,S
	ADDI	R,(SMB)			;-COUNT,,ABSOLUTE ADDRESS OF FIRST
	MOVEM	R,SYMRNG		;SAVE IT FOR SEVAL
	POPJ	P,


;HERE WHEN : SEEN.
↑SRTAG:	TLNN	F,LTF   		;NO LETTERS IS ERROR
	JRST	SPNAME 			;GO SAY ERROR (EXCEPT $: COMMAND)
	TLNE	F,FAF   		;DEFINE SYMBOLS
	JRST	SRDEF			;A less-than-sign B:
	TLNE	F,CF			;ALTMODE?
	JRST	SPROG			;YES. OPEN PROGRAM'S SYMBOLS
	MOVE	W,LLOCO			;DEFINE SYMBOL AS OPEN REGISTER
	HRRZM	W,DEFV
SRDEF:	PUSHJ	P,EVAL			;EVALUATE THE SYMBOL THAT WAS NAMED.
	JRST	SRDEF1			;NEW SYMBOL
	PUSHJ	P,SYMDEL		;REDEFINITION.  DELETE OLD.
SRDEF1:	PUSHJ	P,SYMINS		;NOW, INSERT THE NEW DEININTION.
	MOVSI	T,GLOBAL
	IORM	T,SYM			;FIXUP SYM TO BE GLOBAL FOR DUNDEF.
	PUSHJ	P,DUNDEF		;USE NEW DEFINITION TO FIX UNDEFINED SYMS
	JRST	RET

;PRINT PROGRAM NAMES.
SPNAME:	TLNN	F,CF			;$: COMMAND?
	JRST	ERR			;NO.  NO LETTERS AND : IS ERROR
SPROG:	SYMTST				;ENTER HERE WITH LTF SET.
	HRRZ	W1,1(SMB)		;POINTER TO BLOCK NAMES AREA
	ADDI	W1,(SMB)		;DIRECT POINTER TO BN
	HRRZ	W2,2(SMB)		;POINTER TO BLOCK STRUCTURE AREA
	ADDI	W2,(SMB)		;DIRECT POINTER TO BS
	MOVSI	R,W1			;POINTER TO BN
	MOVSI	S,W2			;POINTER TO BS
	TLNE	F,LTF			;ARGUMENT GIVEN TO $: COMMAND?
	JRST	SPRG0			;YES. (NAME$: SEEN)
	PUSHJ	P,CRF			;START WITH CRLF
	CAMG	W2,W1
	JRST	DD1			;NO BLOCK ⊂⊂⊂⊂∧?
SPNAM1:	MOVE	T,@R			;GET A BLOCK NAME
	PUSH	P,W1
	PUSHJ	P,SPT1
	PUSHJ	P,CRF
	POP	P,W1
	SKIPN	T,@S			;GET LINK FORWARD TO NEXT BLOCK
	JRST	DD1			;DONE.
	HLR	R,T
	HLR	S,T
	JRST	SPNAM1			;LOOP

;SET PROGRAM NAME
SPRG0:	CAMG	W2,W1
	JRST	UNDEF			;NO BLOCK NAMES?
SPRG1:	MOVE	T,@R			;GET A BLOCK NAME
	CAMN	T,SYM			;MATCHES?
	JRST	SPRG2			;YES!
	SKIPN	T,@S			;GET LINK FORWARD TO NEXT BLOCK
	JRST	UNDEF			;UNDEFINED
	HLR	R,T
	HLR	S,T
	JRST	SPRG1			;LOOP

SPRG2:	HRRZM	R,PRGM			;SAVE PROGRAM NAME. (A NUMBER)
	PUSHJ	P,SPRG3			;SETUP INITIAL BLOCK NAME
	JRST	RET

;ROUTINE TO SETUP INITIAL BLOCK FROM OPEN PROGRAM.  CALLED FROM SPRG2 AND SSCHK
SPRG3:	HRL	R,R			;PROGRAM NUMBER IN BOTH HALVES
	SETOM	BLOCK			;INITIALLY NO BLOCK NAME
	SKIPN	T,@S			;GET LINK TO NEXT PROGRAM NAME
	JRST	SPRG4			;THERE IS NO NEXT (GET THE LAST!)
	HLR	S,T
	SUBI	S,1
	CAMN	R,@S			;IS THIS THE WORD WE WANT?
	HRRZM	S,BLOCK			;YES.
	POPJ	P,

SPRG4:	SUBM	W2,W1			;CALCULATE LAST ADDRESS
	HRRI	S,-1(W1)
	CAME	R,@S
	POPJ	P,
	HRRZ	S,S
	CAMLE	S,PRGM
	MOVEM	S,BLOCK
	POPJ	P,

;AUTOMATICALLY OPEN SYMBOL TABLE FOR SOME PROGRAM WHEN DDT IS FIRST STARTED
↑SRGPGM:HRRZ	W1,1(SMB)		;POINTER TO BLOCK NAMES AREA
	ADDI	W1,(SMB)		;DIRECT POINTER TO BN
	HRRZ	W2,2(SMB)		;POINTER TO BLOCK STRUCTURE AREA
	ADDI	W2,(SMB)		;DIRECT POINTER TO BS
	MOVSI	R,W1			;POINTER TO BN
	MOVSI	S,W2			;POINTER TO BS
	CAMG	W2,W1
	JRST	DD1			;NO BLOCK NAMES?
SRGPG1:	MOVE	T,@R			;GET A BLOCK NAME
IFN UEDDTS,<
	CAME T,[RADIX50 0,RAID]		;LOOK FOR REAL PROGRAM THAT MIGHT
	CAMN T,[RADIX50 0,UDDT]		; BE LOADED WITH A DEBUGGER
	JRST SRGPG3			;IGNORE DEBUGGERS' PROGRAM NAMES
>;IFN UEDDTS
	CAME	T,[XTITLE]		;IGNORE OUR OWN PROGRAM NAME.
	CAMN	T,[RADIX50 0,JOBDAT]
	JRST	SRGPG3			;IGNORE
	PUSHJ	P,GETPG2		;STORE GOOD NAME IN SYM.  PRINT NAME$:
	TLO	F,LTF			;SET FLAG FOR SPROG
	JRST	SPROG			;SIMULATE NAME$:

SRGPG3:	SKIPN	T,@S			;GET LINK FORWARD TO NEXT BLOCK
	JRST	DD1			;DONE.  DIDN'T GET ANY WE LIKED.
	HLR	R,T
	HLR	S,T
	JRST	SRGPG1			;LOOP

;SET BLOCK NAME  & SEEN   (EITHER BNAME$&, BNAME&SNAME, OR $& COMMANDS)
↑SBLOCK:SKIPGE	PRGM
	JRST	ERR		;ERROR IF NO PROGRAM OPEN
	SYMTST
	HRRZ	W1,1(SMB)	;POINTER TO BLOCK NAMES AREA
	ADDI	W1,1(SMB)	;POINTER TO BN+1
	ADD	W1,PRGM		;POINTER TO THE PROGRAM NAME +1
	HRRZ	W2,2(SMB)	;POINTER TO BS AREA
	ADDI	W2,(SMB)	;DIRECT POINTER TO IT.
	TLNN	F,LTF		;LETTER SEEN?
	JRST	SPBNS		;NO.  $& COMMAND PRINTS BLOCK NAMES
SBLK1:	CAMG	W2,W1		;WHEN WE GET TO THE END
	JRST	UNDEF		;IT'S TIME TO QUIT
	MOVE	T,(W1)		;GET RADIX50
	TLZN	T,740000	;SHOULD HAVE SOME TYPE BITS ON FOR A BNAME
	JRST	UNDEF		;THIS MUST BE THE NEXT PROGRAM NAME
	XOR	T,SYM		;COMPARE WITH SYMBOL GIVEN
	JUMPE	T,SBLK2		;JUMP IF WE'VE GOT ONE!
	AOJA	W1,SBLK1

SBLK2:	SUBI	W1,(SMB)
	SUB	W1,1(SMB)
	TLNN	F,CF		;WAS ALTMODE SEEN?
	JRST	SBLK3		;NO. SET TEMPORARY BLOCK NAME
	HRRZM	W1,BLOCK
	JRST	RET

SBLK3:	HRRZM	W1,TBLK		;SET TEMPORARY BLOCK NAME
	JRST	L1RPR

;PRINT BLOCK NAMES
SPBNS:	TLNN	F,CF		;$&
	JRST	ERR		;ERROR
	PUSHJ	P,CRF		;START WITH CRLF
SPBNS1:	CAMG	W2,W1		;WHEN WE GET TO THE END
	JRST	DD1		;IT'S TIME TO QUIT
	MOVE	T,(W1)		;GET RADIX50
	TLZN	T,740000	;SHOULD HAVE SOME TYPE BITS ON FOR A BNAME
	JRST	DD1		;THIS MUST BE THE NEXT PROGRAM NAME
	PUSH	P,W1
	PUSHJ	P,SPT1
	PUSHJ	P,CRF
	POP	P,W1
	AOJA	W1,SPBNS1

;Print the program, block and value of all symbols whose name matches SYM
SQUEST:	SKIPL	R,SYMRNG
	JRST	DD1			;no symbols
SQUES1:	MOVE	W2,(R)			;GET RADIX50 OF A SYMBOL
	XOR	W2,SYM
	TLZ	W2,740000		;MASK OFF TYPE BITS
	JUMPN	W2,SQUES2		;REJECT IF DIFFERENT
	MOVE	W2,(R)			;GET SYMBOL AGAIN.
	TLNE	W2,040000		;GLOBAL? 
	JRST	SQES1C			;YES.  Print only the symbol value
	LDB	W2,[POINT 13,1(R),12]	;GET THE BLOCK NUMBER
	ADD	W2,1(SMB)		;offset to block name space
	ADDI	W2,(SMB)
	MOVE	T,(W2)			;fetch block name
	TLZN	T,740000		;skip if block name given.
	JRST	SQES1D			;this is a pgm name.  no block.
	LDB	W2,[POINT 13,1(R),12]	;GET THE BLOCK NUMBER
	ADD	W2,2(SMB)		;offset to block structure space
	ADDI	W2,(SMB)
	HLRZ	W2,(W2)			;fetch block number of program
	ADD	W2,1(SMB)		;offset to block name space
	ADDI	W2,(SMB)
	MOVE	W2,(W2)			;name of program
	CAMN	W2,T			;if same name, suppress block name
	JRST	SQES1D			;print only pgm name
	PUSH	P,T			;save blk name
	MOVE	T,W2
	PUSHJ	P,SQES1E
	POP	P,T
	MOVEI	W2,"&"
	PUSHJ	P,SQES1F
	JRST	SQES1G

SQES1E:	MOVEI	W2,":"
SQES1F:	PUSH	P,W2
	PUSHJ	P,SPT1			;print pgm name
	POP	P,T
	JRST	TOUT

SQES1D:	PUSHJ	P,SQES1E
SQES1G:	PUSHJ	P,LCT
SQES1C:	PUSH	P,R
	HRRZ	R,R			;REVAL must have only RH of R
	PUSHJ	P,REVAL
	PUSHJ	P,TOC
	PUSHJ	P,CRF
	POP	P,R
SQUES2:	ADD	R,[2,,2]
	JUMPL	R,SQUES1
	JRST	DD1

;SKILL SSYMD SYMDEL SYMDL1 SYMDL2 SYMDL3 SYMDL4 SYMINS SYMI3 SYMI2 SYMI1 SYMI1A SYMI1B SYMI1C SYMI1D SYMI1E SYMI5F SYMI1F SYMI4 SYMI4C SYMI4D SYMI4E SYMI5A SYMI5B

;	SKILL	SSYMD	SYMDEL	SYMINS

↑SKILL:	MOVE	R,LASSYM		;$K AND $$K COMMANDS.
	DPB	T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
	TLNE	F,CCF			;WAS IT $$K ?
	PUSHJ	P,SYMDEL		;YES. EXPUNGE THE DEFINITION.
	JRST	RET

;SUBROUTINE FOR $D COMMAND
↑SSYMD:	HRRZ	R,S.SYM+2		;HERE'S WHERE SEVAL PUT IT.
	JRST	CPOPJ1

;DELETE A SYMBOL.  ENTER HERE WITH R=POINTER TO SYMBOL. 
SYMDEL:	PUSHJ	P,GCLASS		;T←CLASS NUMBER (1 TO 4)
	CAIE	T,4			;CLASS 4 IS HARDER.
	JRST	SYMDL2			;NOT CLASS 4.
	MOVEI	W,@1(R)			;GET POINTER TO FULLV SPACE.
	HRLI	W,1(W)			;SOURCE,,DEST. OF DOWNWARDS BLT.
	SOS	S,4(SMB)		;DECREMENT FIRST FREE POINTER.
	ADDI	S,(SMB)			;ABSOLUTE POINTER TO FIRST FREE.
	CAILE	S,(W)			;SKIP BLT IF UNNECESSARY. (LAST C4 SYM)
	BLT	W,-1(S)			;MOVE SOME FULLVS DOWN.
	SETZM	(S)			;ZERO A NEW WORD OF FREE SPACE.
	MOVE	S,11(SMB)
	ADDI	S,-2(SMB)		;POINTER TO LAST CLASS4 SYMBOL
SYMDL1:	CAML	R,S			;ABOVE THE DELETED SYMBOL?
	JRST	SYMDL2			;NO. EVERYTHING'S BEEN FIXED.
	SOS	1(S)			;ADJUST A POINTER TO FULLV SPACE.
	SUBI	S,2
	JRST	SYMDL1			;LOOP THRU C4 SYMBOLS ABOVE DELETED SYM.

SYMDL2:	MOVE	S,5(SMB)		;POINTER TO FIRST C1 SYMBOL.
	ADDI	S,(SMB)			;ABS. POINTER TO FIRST C1 SYMBOL.
	MOVEI	W,(R)
	SUBI	W,(S)			;CALCULATE NUMBER OF WORDS TO MOVE.
	MOVSI	S,377777(W)		;CONTROL COUNT IN LH.
	HRRI	S,-1(R)			;LAST SOURCE WORD IN RH.
	JUMPLE	W,SYMDL3		;JUMP IF THERE'S NOTHING TO MOVE.
	POP	S,2(S)			;MOVE STUFF UPWARDS
	JUMPL	S,.-1			;LOOP
SYMDL3:	SETZM	2(S)			;CLEAR TWO WORDS THAT WERE VACATED.
	SETZM	1(S)
	MOVEI	S,2			;ADJUST CLASS POINTERS.
	MOVEI	R,5(SMB)		;C1 POINTER.
SYMDL4:	ADDM	S,(R)			;ADJUST CLASS POINTER.
	ADDI	R,1			;ADVANCE TO NEXT CLASS.
	SOJG	T,SYMDL4		;DECREMENT COUNT.  LOOP UNTIL DONE.
	MOVE	S,[2,,2]
	ADDM	S,SYMRNG		;ADJUST SYMRNG TO ACCOUNT FOR FEWER SYMS.
	POPJ	P,

;INSERT SYMBOL.  THE SYMBOL NAME IS IN SYM, VALUE IN DEFV.
SYMINS:	MOVE	T,DEFV			;GET THE VALUE
	PUSHJ	P,CCLASS		;GET THE CORRESPONDING CLASS NUMBER.
	MOVEI	T,2			;ASSUME WE NEED TWO WORDS FOR STORAGE.
	CAIN	R,4			;CLASS4?
	MOVEI	T,3			;FOR CLASS4 WE NEED THREE WORDS.
	MOVE	S,5(SMB)		;FIRST CLASS1 ADDRESS.
	SUB	S,4(SMB)		;FIRST FREE SPACE ADDRESS.
	CAIGE	S,(T)			;ENOUGH SPACE LEFT FOR DEFINITION?
	JRST	ERR			;NO ROOM.
	JRST	@.(R)			;SET UP FOR DIFFERENT CLASSES.
	SYMI1
	SYMI2
	SYMI3
	SYMI4

SYMI3:	MOVE	R,7(SMB)
	MOVE	S,10(SMB)
	MOVE	T,DEFV
	HLRZM	T,TEMDDT
	JRST	SYMI1B

SYMI2:	MOVE	R,6(SMB)
	MOVE	S,7(SMB)
	JRST	SYMI1A

SYMI1:	MOVE	R,5(SMB)
	MOVE	S,6(SMB)
SYMI1A:	MOVE	T,DEFV
	MOVEM	T,TEMDDT
SYMI1B:	ADDI	R,(SMB)
	ADDI	S,(SMB)
SYMI1C:	CAIG	S,(R)			;STILL ROOM LEFT?
	JRST	SYMI1D			;R POINTS TO FIRST LARGER SYMBOL
	HRRZ	W1,1(R)			;FETCH DATA
	CAML	W1,TEMDDT		;FOUND THE RIGHT PLACE YET?
	JRST	SYMI1D			;YES.  R POINTS TO LARGER SYMBOL
	ADDI	R,2
	JRST	SYMI1C

SYMI1D:	MOVE	S,5(SMB)		;ALL SYMBOLS BELOW R MUST MOVE DOWN.
	ADDI	S,(SMB)
	CAIL	S,(R)
	JRST	SYMI1E			;JUMP IF NO BLT NEEDED.
	HRLI	S,-2(S)
	MOVS	S,S
	BLT	S,-3(R)
SYMI1E:	MOVE	S,SYM
	TLO	S,GLOBAL
	MOVEM	S,-2(R)
	MOVE	S,TEMDDT
	HRRZM	S,-1(R)
	SKIPG	S,BLOCK			;IS BLOCK SET?
	SKIPL	S,PRGM			;NO. USE PRGM IF SET.
	DPB	S,[POINT 13,-1(R),12]	;STUFF BLOCK CODE INTO SYMBOL.
	MOVE	T,DEFV			;GET THE VALUE
	PUSHJ	P,CCLASS		;GET THE CORRESPONDING CLASS NUMBER.
SYMI5F:	MOVNI	S,2
	MOVEI	T,5(SMB)
SYMI1F:	ADDM	S,(T)
	ADDI	T,1
	SOJG	R,SYMI1F		;LOOP ADJUSTING CLASS ORIGINS
	MOVN	S,[2,,2]
	ADDM	S,SYMRNG		;UPDATE AOBJN POINTER FOR SEVAL.
	POPJ	P,

SYMI4:	MOVE	R,10(SMB)		;CLASS4
	MOVE	S,11(SMB)
	MOVE	T,DEFV
	MOVEM	T,TEMDDT
	ADDI	R,(SMB)
	ADDI	S,(SMB)
SYMI4C:	CAIG	S,(R)			;STILL ROOM LEFT?
	JRST	SYMI4D			;R POINTS TO FIRST LARGER SYMBOL
	MOVE	W1,@1(R)		;FETCH DATA
	CAML	W1,TEMDDT		;FOUND THE RIGHT PLACE YET?
	JRST	SYMI4D			;YES.  R POINTS TO LARGER SYMBOL
	ADDI	R,2
	JRST	SYMI4C

SYMI4D:	MOVE	S,5(SMB)		;ALL SYMBOLS BELOW R MUST MOVE DOWN.
	ADDI	S,(SMB)
	CAIL	S,(R)
	JRST	SYMI4E			;JUMP IF NO BLT NEEDED.
	HRLI	S,-2(S)
	MOVS	S,S
	BLT	S,-3(R)
SYMI4E:	MOVE	S,SYM
	TLO	S,GLOBAL
	MOVEM	S,-2(R)

	AOS	S,4(SMB)		;INCREMENT FREE POINTER
	ADDI	S,(SMB)			;GOBBLE A FREE LOCATION.
	MOVE	T,11(SMB)		;POINTER TO END OF EVERYTHING
	ADDI	T,-2(SMB)		;POINTER TO VERY LAST SYMBOL.
SYMI5A:	CAIGE	T,(R)			;IS THIS A BIG SYMBOL?
	JRST	SYMI5B			;NO.
	AOS	1(T)			;INCREMENT POINTER TO FREE SPACE
	MOVE	W1,-1(S)		;MOVE A FULLWORD VALUE UP.
	MOVEM	W1,(S)
	SUBI	T,2			;DECREMENT SYMBOL POINTERS
	SOJA	S,SYMI5A		;

SYMI5B:	MOVE	T,TEMDDT		;GET DATA
	MOVEM	T,(S)			;STUFF IT.
	SUBI	S,(SMB)			;CONVERT TO RELATIVE.
	HRLI	S,SMB			;SETUP INDEX FIELD
	SKIPG	T,BLOCK			;IS BLOCK SET?
	SKIPL	T,PRGM			;NO. USE PRGM IF SET.
	DPB	T,[POINT 13,S,12]	;STUFF BLOCK CODE INTO SYMBOL.
	MOVEM	S,-1(R)			;STUFF IN TABLE
	MOVEI	R,4			;CLASS 4
	JRST	SYMI5F			;FINISH IT.
;SEVAL SEVAL0 SEVAL1 SEVL1C SEVL1B SEVL1A SEVAL2 SEVAL3 SEVAL4 WCHBLK WCHBL1 GCLASS REVAL REVAL0

;	SEVAL	CONVERT SYMBOLIC NAME TO VALUE

;GIVEN SYMBOL NAME IN SYM.
;DIRECT RETURN IF UNKNOWN, PRINTING "M" IF AMBIGUOUS (MULTIPLE).
;SKIP RETURN WITH R=DIRECT POINTER TO RADIX50, T= VALUE.


↑SEVAL:	PUSH	P,BLOCK
	SKIPLE	T,TBLK			;ANY TEMP BLOCK SET?
	MOVEM	T,BLOCK			;YES.  USE IT.
	SETOM	TBLK			;BUT ONLY ONCE
	SKIPGE	R,SYMRNG
	PUSHJ	P,SEVAL0
	CAIA	
	AOS	-1(P)
	POP	P,BLOCK
	POPJ	P,

;ENTER HERE WITH R SETUP TO BE AOBJN POINTER TO SYMBOL PAIRS
SEVAL0:	SETZM	UNIQ			;POINTER TO A GLOBAL OR UNAVAILABLE LOCAL.
	SETZM	UNIQP			;POINTER TO BEST THING IN THE NEST SO FAR
	TLZ	F,600000		;INITIALIZE SOME FLAGS
SEVAL1:	MOVE	W2,(R)			;GET RADIX50 OF A SYMBOL
	TDNE	W2,W1			;SKIP UNLESS A REJECTED TYPE
	JRST	SEVAL2			;GET NEXT
	XOR	W2,SYM
	TLZ	W2,740000		;MASK OFF TYPE BITS
	JUMPN	W2,SEVAL2		;REJECT IF DIFFERENT
	MOVE	W2,(R)			;GET SYMBOL AGAIN.
	TLNE	W2,040000		;GLOBAL? 
	JRST	SEVL1A			;YES. IT'S GLOBAL.  SAVE POINTER TO IT.
	LDB	W2,[POINT 13,1(R),12]	;GET THE BLOCK NUMBER
	CAME	W2,PRGM			;SAME AS CURRENT PROGRAM?
	CAMN	W2,BLOCK		;OR SAME AS CURRENT BLOCK?
	JRST	SEVAL4			;YES. THIS IS THE VERY BEST.
	PUSHJ	P,WCHBLK		;SEE IF W2 IS IN PRESENT BLOCK NEST.
	JRST	SEVL1B			;NO. WRONG NEST OR WRONG PROGRAM!
	SKIPG	T,UNIQP			;WAS ANYTHING YET FOUND IN THE OPEN NEST?
	JRST	SEVL1C			;NO. WE NOW HAVE SOMETHING.
	LDB	T,[POINT 13,1(T),12]	;YES. GET BLOCK NUMBER OF PREVIOUS THING
	LDB	W2,[POINT 13,1(R),12]	;AND BN OF THIS ONE
	CAML	T,W2			;SKIP IF PREVIOUS B. CONTAINED IN THIS B.
SEVL1C:	HRRZM	R,UNIQP			;NEW ONE IS BETTER.  W2 .LT. T
	JRST	SEVAL2

SEVL1B:	SKIPGE	UNIQ			;IS THIS SET WITH A GLOBAL ALREADY?
	JRST	SEVAL2			;YES.  A GLOBAL IS A BETTER MATCH.
	SKIPE	UNIQ			;IS THIS SET WITH SOME UNAVAILABLE LOCAL
	JRST	SEVL1D			;Yes. We now have at least two.
	HRRZM	R,UNIQ			;SAVE FIRST UNAVAILABLE LOCAL.
	JRST	SEVAL2

;permit evaluation of an unavailable, multiple local name provided all defs agree
SEVL1D:	JUMPL	F,SEVAL2		;Jump if already have mul defs for locals
	PUSH	P,R			;don't complain of mul def if same values
	HRRZ	R,R
	PUSHJ	P,REVAL			;value of new one to T
	PUSH	P,T			;save the value
	HRRZ	R,UNIQ			;address of previous unavail local
	PUSHJ	P,REVAL
	CAME	T,(P)			;compare to current
	TLO	F,400000		;Different values with the same name
	SUB	P,[1,,1]
	POP	P,R
	JRST	SEVAL2

SEVL1A:	HRROM	R,UNIQ			;SAVE GLOBAL AS GLOBAL. 
SEVAL2:	ADD	R,[2,,2]
	JUMPL	R,SEVAL1
	SKIPG	R,UNIQP			;SKIP IF SYMBOL FOUND IN CURRENT NEST.
	SKIPGE	R,UNIQ			;NOT IN CURRENT NEST.  SKIP IF NOT GLOBAL
	JRST	SEVAL4			;GOOD MATCH!
	JUMPL	F,SEVAL3		;JUMP IF AMBIGUOUS OUTSIDE OF NEST
	JUMPN	R,SEVAL4		;JUMP IF UNAMBIGUOUS MATCH OUTSIDE NEST.
	POPJ	P,			;NOBODY HOME.

SEVAL3:	MOVEI	T,"M"			;MULTIPLY DEFINED OUTSIDE OF NEST.
	JRST	TOUT			;"M" FOR MULTIPLE. CALLER MAY TYPE "U" ?

SEVAL4:	HRRZ	R,R
	HRRZM	R,LASSYM		;SAVE ABSOLUTE POINTER TO SYMBOL
	PUSHJ	P,REVAL			;T← VALUE FROM POINTER IN R.
	JRST	CPOPJ1

;WCHBLK - CALL WITH W2 CONTAINING A BLOCK NUMBER.  SKIP RETURN IF
;W2 BELONGS TO CURRENTLY OPEN BLOCK NEST.  DIRECT RETURN OTHERWISE.
;CLOBBERS T.

WCHBLK:	SKIPGE	PRGM			;IS THERE A PROGRAM OPEN?
	POPJ	P,			;NO. THERE'S NOTHING IN CURRENT NEST!
	SKIPL	T,BLOCK			;IS THERE A BLOCK OPEN?
	JRST	WCHBL1			;YES.  FOLLOW IT UP THE TREE.
	CAMN	W2,PRGM			;NO BLOCK = NON-BS PRGM.
	AOS	(P)			;W2 MATCHES OPEN PRGM.
	POPJ	P,

WCHBL1:	CAMN	T,W2			;BLOCK INDICES MATCH?
	JRST	CPOPJ1			;YES.
	CAMN	T,PRGM			;BLOCK INDEX MATCHES PRGM?
	POPJ	P,			;YES, MEANING W2 ISN'T IN THE NEST.
	ADD	T,2(SMB)
	ADDI	T,(SMB)
	HRRZ	T,(T)			;GET LINK TO PARENT BLOCK
	JRST	WCHBL1			;AND LOOP.


;ABSOLUTE ADDRESS IN R, SMB SETUP.  RETURN CLASS NUMBER IN T
GCLASS:	MOVEI	T,4			;ASSUME CLASS 4
	SUBI	R,(SMB)			;MAKE RELATIVE.
	CAMGE	R,10(SMB)		;SKIP IF CLASS 4
	SUBI	T,1			;CLASS 3, 2 OR 1
	CAMGE	R,7(SMB)		;SKIP IF CLASS 3 OR 4
	SUBI	T,1			;CLASS 2 OR 1
	CAMGE	R,6(SMB)		;SKIP IF CLASS 2, 3, OR 4
	SUBI	T,1			;CLASS 1
	ADDI	R,(SMB)			;RESTORE TO ABSOLUTE
	POPJ	P,

;ABSOLUTE ADDRESS IN R.  RETURNS ABSOLUTE IN R, VALUE IN T.
REVAL:	PUSHJ	P,GCLASS		;CALCUALTE THE CLASS NUMBER
	XCT	REVAL0-1(T)		;DISPATCH TO THE CLASS EVALUATOR
	POPJ	P,

REVAL0:	HRRZ	T,1(R)
	HRRZ	T,1(R)
	HRLZ	T,1(R)
	MOVE	T,@1(R)
;CCLASS CCLAS1 SLOOK SLC2 SLC1 SLC1A SLC34 SLC34A SLC34B SLC34D SLC34C SLC43 SLC43A SLC3 SLC4 FNDSYM FNDSY1 FNDSY2 FNDSY3 FNDSY4 FNDSY5 FNDSY6 FNDSY7 FNDSY8 FNDSYC FNDSYB FNDSYA FNDSY9 FNDSYD FNDSYE FNDXT2 FNDSYF FNDSYG FNDSYH

;	SLOOK	CONVERT VALUE TO SYMBOLIC

CCLASS:	JUMPL	T,CCLAS1	;VALUE IN T TO CLASS NUMBER IN R.
	MOVEI	R,1
	CAIG	T,377777
	POPJ	P,		;CLASS 1
	CAIG	T,777777
	AOJA	R,CPOPJ		;CLASS 2
CCLAS1:	MOVEI	R,3
	TRNE	T,777777
	MOVEI	R,4		;CLASS 4
	POPJ	P,


;ENTER HERE WITH T CONTAINING A VALUE FOR WHICH A SYMBOL IS SOUGHT.
;IF A SYMBOL THAT MATCHES THE VALUE T EXACTLY IS FOUND, IT'S NAME WILL
;BE PRINTED AND THE DIRECT RETURN TAKEN.  IF NO EXACT MATCH IS FOUND,
;THE CLOSEST SYMBOL WHOSE VALUE HAS THE SAME SIGN AS C(T) AND IS SMALLER
;THAN C(T) WILL BE POINTED TO BY W1 AND THE SKIP RETURN TAKEN (T WILL CONTAIN
;THE NUMERIC DIFFERENCE).  IF NO MATCH AT ALL IS FOUND, DOUBLE SKIP RETURN.
;W1 WILL POINT TO 3 WORDS AT S.SYM, BEING THE NAME, THE VALUE, AND THE SYMBOL
;TABLE (ABSOLUTE) ADDRESS OF THE SYMBOL ENTRY.

↑SLOOK:	MOVEM	T,TEMDDT	;STORE VALUE SOUGHT.
	PUSHJ	P,CCLASS	;CALCULATE CLASS NUMBER
	JRST	@.(R)		;DISPATCH AS APPROPRIATE
	SLC1
	SLC2
	SLC34			;TRY CLASS 3 THEN, CLASS 4
	SLC43			;TRY CLASS 4, THEN CLASS 3

SLC2:	HRRZ	R,6(SMB)	;LOWER BOUND
	HRRZ	S,7(SMB)	;UPPER BOUND
	JRST	SLC1A

SLC1:	HRRZ	R,5(SMB)	;LOWER BOUND
	HRRZ	S,6(SMB)	;UPPER BOUND
SLC1A:	MOVE	T,[HRRZ W1,1(T)]
	MOVEM	T,FFETCH
	SETZM	C3FLG
	JRST	FNDSYM

SLC34:	PUSHJ	P,SLC3		;TRY 3 FIRST
	POPJ	P,		;WIN
	JRST	SLC34A		;STACK RESULT AND CALL SLC4.
	JRST	SLC4		;NOBODY HOME. JUST TRY CLASS 4

SLC34A:	MOVE	T,[S.SYM,,X.SYM]
	BLT	T,X.SYM+2	;SAVE RESULT.
	PUSHJ	P,SLC4		;TRY CLASS 4
	POPJ	P,		;THIS SHOULDN'T HAPPEN
	JRST	SLC34C		;COMPARE WITH PREVIOUS RESULT
SLC34B:	MOVE	T,[X.SYM,,S.SYM]
	BLT	T,S.SYM+2	;USE PREVIOUS RESULT.
SLC34D:	MOVE	T,TEMDDT
	SUB	T,S.SYM+1
	JRST	CPOPJ1

SLC34C:	MOVE	T,S.SYM+1
	CAMGE	T,X.SYM+1
	JRST	SLC34B		;USE OLD RESULT.
	JRST	SLC34D		;USE CURRENT RESULT.


SLC43:	PUSHJ	P,SLC4		;SEEK.
	POPJ	P,		;WIN.
	JRST	SLC43A		;STACK RESULT.
	JRST	SLC3		;LOSE. TRY CLASS 3

SLC43A:	MOVE	T,[S.SYM,,X.SYM]
	BLT	T,X.SYM+2	;SAVE RESULT.
	PUSHJ	P,SLC3
	POPJ	P,		;SHOULDN'T HAPPEN
	JRST	SLC34C		;GO COMPARE WITH SAVED RESULT.
	JRST	SLC34B		;USE SAVED RESULT.


SLC3:	HRRZ	R,7(SMB)	;LOWER BOUND
	HRRZ	S,10(SMB)	;UPPER BOUND
	MOVSS	TEMDDT
	SETOM	C3FLG
	MOVE	T,[HRRZ W1,1(T)]
	MOVEM	T,FFETCH
	PUSHJ	P,FNDSYM
	POPJ	P,		;SUCCESS.  SWAP TEMDDT AND RETURN.
	JRST	CPOPJ1
	JRST	CPOPJ2		;FAILURE.

SLC4:	HRRZ	R,10(SMB)	;LOWER BOUND
	HRRZ	S,11(SMB)	;UPPER BOUND
	MOVE	T,[MOVE W1,@1(T)]
	MOVEM	T,FFETCH
	SETZM	C3FLG
	PUSHJ	P,FNDSYM
	POPJ	P,
	JRST	CPOPJ1
	JRST	CPOPJ2


;ENTER HERE WITH R=LOWER BOUND, S=BEYOND UPPER BOUND,
;TEMDDT=VALUE SOUGHT (EXCEPT FOR CLASS3, WHERE IT IS SWAPPED)
;FFETCH=INSTRUCTION TO XCT TO GET DATA INTO W1, USING T AS DIRECT INDEX.
;DIRECT RETURN = WE PRINTED A NAME.
;1 SKIP = CLOSEST MATCH IS POINTED TO BY W1, T CONTAINS DIFFERENCE.
;2 SKIP = THERE IS NO CLOSEST MATCH.

FNDSYM:	SUBI	S,2		;ADJUST S TO POINT WITHIN RANGE.
	CAMLE	R,S		;COMPARE.
	JRST	FNDXT2		;HOPELESS.  RANGE IS EMPTY.
	ADDI	S,(SMB)
	ADDI	R,(SMB)
	MOVEI	T,(R)
	XCT	FFETCH		;FETCH DATA (LOWEST VALUE IN RANGE)
	CAMLE	W1,TEMDDT	;SKIP IF THERE'S SOME HOPE.
	JRST	FNDXT2		;NO WAY.  SMALLEST VALUE IS TOO LARGE.
	MOVEM	S,FNDHI		;SAVE ORIGINAL BOUNDS FOR LATER.
	MOVEM	R,FNDLO
	MOVEI	T,(S)
	XCT	FFETCH		;FETCH LARGEST VALUE
	CAMGE	W1,TEMDDT	;SKIP IF LARGEST VALUE INCLUDES SOUGHT VALUE.
	JRST	FNDSY3		;NO.  T POINTS TO LARGEST VAL. .LT. SOUGHT VALUE
	TRNN	R,1		;ODD OR EVEN?
	SKIPA	W1,[TRZA T,2]	;EVEN.
	MOVE	W1,[TRNN T,2]
	MOVEM	W1,TXCT		;INSTRUCTION TO ADJUST AVERAGE
FNDSY1:	MOVEI	T,(R)
	ADDI	T,(S)
	XCT	TXCT		;TEST RESULT
	SUBI	T,2		;  ADJUST IF NECESSARY.
	LSH	T,-1		;AVERAGE. (POINTS AT OR BELOW THE MIDDLE.)
	XCT	FFETCH		;FETCH DATA
	CAMN	W1,TEMDDT	;EXACT MATCH?
	JRST	FNDSY3		;YES!
	CAML	W1,TEMDDT	;MIDPOINT SMALL OR LARGE?
	JRST	FNDSY2		;LARGE - USE MIDPOINT AS HIGH BOUND.
	MOVEI	R,2(T)		;SMALL - USE MIDPOINT AS LOW BOUND.
	JRST	.+2
FNDSY2:	MOVEI	S,-2(T)		;USE MIDPOINT AS HIGH BOUND.
	CAMG	R,S
	JRST	FNDSY1		;UNTIL OVERLAP, LOOP.
	MOVEI	T,(S)		;MOVE POINTER TO T.
FNDSY3:	XCT	FFETCH		;T IS BEST POINTER.  EXPAND THE RANGE!
	MOVE	W2,W1		;SAVE BEST VALUE.
	MOVEI	S,(T)
FNDSY4:	MOVEI	R,(T)
	CAMG	R,FNDLO
	JRST	FNDSY5		;CAN'T MOVE DOWN ANYMORE.
	MOVEI	T,-2(R)
	XCT	FFETCH
	CAMN	W2,W1
	JRST	FNDSY4		;EXPAND NUMBER OF MATCHING SYMBOLS.
FNDSY5:	MOVEI	T,(S)
FNDSY6:	MOVEI	S,(T)
	CAML	S,FNDHI
	JRST	FNDSY7		;CAN'T MOVE UP ANY HIGHER.
	MOVEI	T,2(S)
	XCT	FFETCH
	CAMN	W2,W1
	JRST	FNDSY6
FNDSY7:	SETZM	UNIQ		;R AND S POINT TO GROUP OF EQUAL-VALUED SYMBOLS
	SETZM	UNIQP
FNDSY8:	CAMGE	S,R		;LOOK THRU ALL SYMBOLS OF SAME VALUE.
	JRST	FNDSYE		;DONE. 
IFN FTDMAP,<
	SKIPN DDTXCOR		;skip if DDT is mapped out
	JRST FNDS8A		;DDT is really in, use its symbols
	MOVN W2,EXMMAP		;see if we're examining DDT itself
	CAILE W2,1		;skip unless EXMMAP is -2 or less
	JRST FNDS8A		;examining DDT -- allow DDT's & ONCE's symbols
	LDB W2,[POINT 13,1(S),12] ;GET THE BLOCK NUMBER
	CAME W2,MDDBLK		;ignore symbols in MDDT's block
	CAMN W2,DDTBLK		;ignore symbols in DDT's block
	JRST FNDSY9		;ignore this symbol
;	CAME W2,P1EBLK		;ignore symbols in P1END's block
	CAMN W2,ONCBLK		;ignore symbols in ONCE's block
	JRST FNDSY9		;ignore this symbol
FNDS8A:
>;IFN FTDMAP
	MOVE	W2,(S)
	TLNE	W2,DELO+DELI	;IGNORE SYMBOLS WITH THESE BITS SET
	JRST	FNDSY9		;SYMBOL WAS SUPPRESSED.  IGNORE IT.
	TLNE	W2,040000
	JRST	FNDSYA		;SYMBOL IS GLOBAL
	LDB	W2,[POINT 13,1(S),12]	;GET THE BLOCK NUMBER
	CAME	W2,PRGM			;SAME AS CURRENT PROGRAM?
	CAMN	W2,BLOCK		;OR SAME AS CURRENT BLOCK?
	JRST	FNDSYD			;YES. THIS IS THE VERY BEST.
	PUSHJ	P,WCHBLK		;SEE IF W2 IS IN PRESENT BLOCK NEST.
	JRST	FNDSYB			;NO. WRONG NEST OR WRONG PROGRAM!
	SKIPG	T,UNIQP			;WAS ANYTHING YET FOUND IN THE OPEN NEST?
	JRST	FNDSYC			;NO. WE NOW HAVE SOMETHING.
	LDB	T,[POINT 13,1(T),12]	;YES. GET BLOCK NUMBER OF PREVIOUS THING
	LDB	W2,[POINT 13,1(S),12]	;AND BN OF THIS ONE
	CAML	T,W2			;SKIP IF PREVIOUS B. CONTAINED IN THIS B.
FNDSYC:	HRRZM	S,UNIQP			;NEW ONE IS BETTER.  W2 .LT. T
	JRST	FNDSY9

FNDSYB:	SKIPN	UNIQ			;IS THIS SET ALREADY?
FNDSYA:	HRRZM	S,UNIQ			;SAVE FIRST UNAVAILABLE LOCAL, ANY GLOBAL
FNDSY9:	SUBI	S,2
	JRST	FNDSY8

FNDSYD:	HRRZM	S,UNIQP
FNDSYE:	SKIPN	T,UNIQP			;IS THERE ANYTHING IN CURRENT BLOCK NEST?
	SKIPE	T,UNIQ			;ANYWHERE ELSE?
	JRST	FNDSYF			;GOT ONE.
	MOVEI	T,(S)			;NO SYMBOLS OF BEST VALUE WERE PRINTABLE!
	CAML	T,FNDLO			;OFF THE END YET?
	JRST	FNDSY3			;NO. EXPAND NEW RANGE.
					;SHIT! ALL SYMBOLS WERE SUPPRESSED.
FNDXT2:	SKIPE	C3FLG
	MOVSS	TEMDDT			;UNSWAP.
	JRST	CPOPJ2	


FNDSYF:	SETZM	SVFB			;ASSUME NO BLOCK NAME NEEDED.
	SKIPE	UNIQP			;WAS SYMBOL FOUND IN CURRENT NEST?
	JRST	FNDSYG			;YES.  NO BLOCK NAME NEEDED.
	MOVE	W1,(T)
	TLNE	W1,040000		;GLOBAL?
	JRST	FNDSYG			;YES.  WE NEED NO BLOCK NAME.
	LDB	W1,[POINT 13,1(T),12]	;GET BLOCK NUMBER
	MOVEM	W1,SVFB			;SAVE IT WHERE IT WILL BE PRINTED.
	ADD	W1,1(SMB)		;GET THE BLOCK NAME
	ADDI	W1,(SMB)
	MOVE	W1,(W1)
	TLNN	W1,740000		;BLOCK OR PROGRAM NAME?
	JRST	FNDSYG			;PROGRAM NAME.
	MOVE	W1,SVFB			;GET BLOCK INDEX AGAIN.
	ADD	W1,2(SMB)
	ADDI	W1,(SMB)
	HLRZ	W1,(W1)			;GET POINTER BACK TO PROGRAM NAME.
	CAME	W1,PRGM			;SAME AS OPEN PROGRAM?
	MOVEM	W1,SVFB			;NO. OUTPUT PROGRAM NAME & SYMBOL NAME.

FNDSYG:	MOVEM	T,S.SYM+2		;SAVE DIRECT POINTER TO SYMBOL.
	XCT	FFETCH
	MOVEM	W1,S.SYM+1		;SAVE VALUE.
	SKIPN	C3FLG
	JRST	FNDSYH
	MOVSS	TEMDDT
	MOVSS	S.SYM+1
FNDSYH:	MOVE	W1,(T)
	MOVEM	W1,S.SYM		;SAVE SYMBOL NAME.
	MOVEI	W1,S.SYM		;POINTER TO NAME.
	MOVE	T,TEMDDT		;GET THE SOUGHT VALUE
	SUB	T,S.SYM+1		;MINUS THE SYMBOL WE FOUND.
	JUMPE	T,SPT0			;JUMP IF WE HAVE EXACT MATCH
	TLO	F,400000		;ANNOUNCE WE FOUND ONE.
	JRST	CPOPJ1

;;BEND SYMSRT
;TEXI TEXI1A TEXI4 TEXI5 TEXI2 TEXI6 TEXI3 SIXBI1 SIXBIN SIXBI2

	SUBTTL	DDT - TEXT INPUT (ASCII AND SIXBIT)

;INPUT TEXT " SEEN.
;RECOGNIZED FORMS:
;	"<DELIM>TEXT<DELIM>	"/TEXT/		LEFT ADJUSTED ASCII INPUT
;	$"<DELIM>TEXT<DELIM>	$"/TEXT/	LEFT ADJUSTED SIXBIT INPUT
;	"CHR$			"A$		ONE RIGHT ADJUSTED ASCII CHR.
;	$"CHR$			$"A$		ONE RIGHT ADJUSTED SIXBIT CHR.
;	$$7"<DELIM>TEXT<DELIM>	$$7"/ABCDEFG/	LEFT ADJUSTED DELIMITED ASCIZ
;						  IN MULTIPLE WORDS
;	$$n"<DELIM>TEXT<DELIM>	$$6"/ABCDEFG/	LEFT ADJUSTED DELIMITED SIXBIT
;						  IN MULTIPLE WORDS - ENDS WITH
;						  A ZERO BYTE OR WORD.

TEXI:	PUSHJ	P,TEXIN		;GET FIRST CHARACTER TO T.
	MOVEM	T,SYL		;SAVE IT.
	MOVEI	W1,5		;ASSUME  ASCII
	MOVEI	TM1,0		;ACCUMULATE IT HERE (TM1 is T-1)
	PUSHJ	P,TEXIN		;GET SECOND CHARACTER.
	TLNE	F,CCF		;WAS IT $$" WE SAW?
	JRST	TEXI4		;YES - PERMIT ALTMODE AS FIRST CHR
	CAIE	T,33		;NOW, HAVE WE AN ALTMODE FOR THE SECOND CHR?
	JRST	TEXI5		;ASSEMBLE NORMALLY.
TEXI1A:	TLNN	F,CF		;ONE RIGHT ADJUSTED CHR.  SIXBIT REQUESTED?
	JRST	QUAN1		;NO.  SYL HAS RIGHT ADJUSTED ASCII
	MOVE	T,SYL
	TRZN	T,100		;TURN OFF 100 BIT
	TRZA	T,40		;100 BIT WAS OFF.  MAKE 40 BIT GO OFF.
	TRO	T,40		;100 BIT WAS ON.  COPY 100 BIT TO 40 BIT.
	ANDI	T,77
	MOVEM	T,SYL
	JRST	QUAN1

TEXI4:	MOVE	R,WRD2		;$$ TYPED.  GET NUMERIC ARG IF ANY.
	CAIE	R,7
	JRST	SIXBIN		;NOT $$7 - DO SIXBIT
	JRST	TEXI6

TEXI5:	TLNE	F,CF		;"<DELIM - NOW IN SYL><CHR NOW IN T>
	JRST	SIXBIN		;$" WAS TYPED.  DO IT FOR SIXBIT.
	SKIPA			;FIRST CHARACTER ALREADY IN T.
TEXI2:	PUSHJ	P,TEXIN
TEXI6:	CAMN	T,SYL
	SOJA	W1,TEXI3	;DELIMITER SEEN
	ROT	T,-7
IFN T-TM1-1,<.FATAL ACs TM1 and T are not contiguous as required here.>
	LSHC TM1,7
	SOJG	W1,TEXI2	;LOOP ACCUMULATING TEXT
	TLNN	F,CCF		;END OF WORD.  $$ SEEN?
	JRST	TEXI2		;NO.  LOOP UNTIL WE GET A DELIMITER.
	LSHC	TM1,-43		;MOVE VALUE INTO T.
	PUSH	P,F
	TLZ	F,CF
	TLO	F,QF
	PUSHJ	P,DEPRA		;DEPOSIT
	POP	P,F
	AOS	LLOCO
	MOVEI	TM1,0		;AND PREPARE TO ASSEMBLE THE NEXT.
	MOVEI	W1,5
	JRST	TEXI2

TEXI3:	LSHC	TM1,-43
	JUMPL	W1,QUAN1	;DEPOSIT AFTER IT'S BEEN SHIFTED ENOUGH
	LSH	T,7
	SOJA	W1,.-2

; SIXBIT TEXT INPUT

SIXBI1:	PUSHJ	P,TEXIN    	;INPUT SIXBIT
SIXBIN:	CAMN	T,SYL
	JRST	SIXBI2		;DELIMITER SEEN
	CAIL	T,"A"+40
	CAILE	T,"Z"+40
	JRST	.+2
	SUBI	T,40		;LOWER CASE TO UPPER CASE.
	ANDI	T,77
	TRC	T,40
	ROT	T,-6
IFN T-TM1-1,<.FATAL ACs TM1 and T are not contiguous as required here.>
	LSHC TM1,6
	SOJGE	W1,SIXBI1	;LOOP UNTIL FULL
	TLNN	F,CCF		;$$6" MODE?
	JRST	SIXBI1		;NO.  LOOP UNTIL DELIMITER SEEN
	MOVE	T,TM1
	PUSH	P,F
	TLZ	F,CF
	TLO	F,QF
	PUSHJ	P,DEPRA
	POP	P,F
	AOS	LLOCO
	MOVEI	TM1,0
	MOVEI	W1,5
	JRST	SIXBI1

SIXBI2:	MOVE	T,TM1
	JUMPL	W1,QUAN1
	LSH	T,6
	SOJA	W1,.-2
;BYTI BYTI4 BYTIM4 BYTIM5 BYTI1A BYTI3 BYTI3A SVBTI SVBTI1 SVBTI2 SVBTID

	SUBTTL	DDT - BYTE INPUT

;BYTE INPUT  $n%b1,b2,...,bn$
;IF n=0 THEN THE BYTE MASK, BMASK = $M+2, DEFINES THE BYTE SIZES.

BYTI:	TRZN	F,Q2F		;ALTMODE NUMBER TYPED?
	JRST	PERC		;NO. TREAT THIS AS A LETTER (PERCENT IN RADIX50)
	SETZM	SVBTI1		;ASSEMBLED WORD
	MOVEI	T,=36		;TOTAL NUMBER OF BITS
	MOVEM	T,SVBTI2
	MOVE	T+2,BMASK	;IN CASE OF "BYTE SIZE ZERO" - USING MASK
	MOVEI	T+1,BYTI1A	;ASSUME FIXED SIZE BYTES. - BYTE ASSEMBLY ROUTINE
	SKIPN	T,WRD2		;GET NUMBER OF BITS/BYTE
	SKIPA	T+1,[BYTIM4]	;USE BYTE MASK ASSEMBLY
	MOVEM	T,SVBTI		;SAVE BYTE SIZE
	MOVEM	T+1,SVBTID	;SET DISPATCH ADDRESS USED BY BYTI3
BYTI4:	PUSHJ	P,BYTI3		;INPUT A BYTE.  STORE BYTE.  SKIP IF TERMINATED
	JRST	BYTI4		;LOOP UNTIL A BYTE FOLLOWED BY ALTMODE IS SEEN
	MOVE	T,SVBTI1	;TERMINATES - GET WORD
	LSH	T,@SVBTI2	;SHIFT REST OF WAY
	JRST	QUAN1		;GO PUT IT AWAY

;BYTE DEPOSIT USING MASK.
BYTIM4:	SKIPG	SVBTI2		;ROOM FOR MORE?
	POPJ	P,		;NO, QUIT
	SETZM	SVBTI		;COUNT NUMBER OF BITS THIS POSITION
	SKIPL	T+2		;START WITH 1 BITS IN LEFT
	SETCA	T+2,0		;COMPLIMENT TO MAKE FIELD OF 1'S IN LEFT
BYTIM5:	LSH	T+2,1		;GET NEXT BIT
	ROT	T+1,-1		;MOVE ANOTHER BIT OF NUMBER TO LEFT END
	AOS	SVBTI		;SAVE COUNT
	SOSLE	SVBTI2		;CHECK TO SEE IF WORD FULL
	JUMPL	T+2,BYTIM5	;IS NEXT BIT PART OF SAME FIELD?
	MOVE	T,SVBTI1	;NO, GET WORD
	LSHC	T,@SVBTI	;SHIFT CORRECT NUMBER OF BITS
	MOVEM	T,SVBTI1	;AND SAVE AGAIN
	POPJ	P,		;RETURN

;BYTE DEPOSIT FOR FIXED SIZE BYTES.
BYTI1A:	MOVN	T+2,SVBTI	;GET SIZE
	ROT	T+1,(T+2)	;GET THAT MANY BITS INTO LEFT END
	MOVE	T,SVBTI1	;NOW THE PARTIALLY ASSEMBLED WORD
	MOVE	T+2,SVBTI	;SIZE
	CAMLE	T+2,SVBTI2	;MORE THAN WE NEED?
	MOVE	T+2,SVBTI2	;YES, TAKE SMALLER
	LSHC	T,(T+2)		;SHIFT BITS IN
	MOVEM	T,SVBTI1	;SAVE WORD
	MOVN	T+2,T+2		;UPDATE NUMBER OF BITS STILL NEEDED
	ADDM	T+2,SVBTI2
	POPJ	P,

;READ IN NUMBER.   CALL @SVBTID TO DEPOSIT.  SKIP RETURN WHEN TERMINATOR SEEN
BYTI3:	MOVEI	T+1,0	
BYTI3A:	PUSHJ	P,TEXIN		;NEXT CHR
	CAIN	T,33		;TERMINATOR?
	AOSA	(P)		;YES - SET SKIP RETURN FROM DEPOSIT ROUTINE
	CAIN	T,","		;SEPARATOR?
	JRST	@SVBTID		;CALL BYTE DEPOSIT ROUTINE.
	CAIL	T,"0"		;CHECK FOR DIGIT
	CAILE	T,"7"
	JRST	ERR
	IMULI	T+1,10
	ADDI	T+1,-"0"(T)
	JRST	BYTI3A

SVBTI:	0
SVBTI1:	0			;ASSEMBLED WORD
SVBTI2:	0
SVBTID:	0

;MULT DIVD ASSEM MINUS PLUS LPRN ACCF ACCCF SPACE SPAC1 RPRN RPRN1 CRN CRNRB CRF LCT TSPC

	SUBTTL	DDT - MORE OF THE WORD ASSEMBLER
;CAUTION!!! THIS CODE MUST APPEAR AFTER THE SYMBOL TABLE STUFF!

MULT:	TLOA F,PTF+MLF		;*
DIVD:	TLO F,DVF+PTF		;SINGLE QUOTE
	JRST L1

ASSEM:	JRST PLUS		;#
MINUS:	TLO F,MF
PLUS:	TLO F,PTF
	JRST LIS2

LPRN:	CAML P,[XWD LPDL-4,0]	;LEFT PARENTHESIS
	JRST ERR
	PUSH P,F		;RECURSE FOR OPEN PAREN
	PUSH P,WRD
	PUSH P,FRASE
	PUSH P,FRASE1
	AOS PRNC
	JRST LIS

INDIRECT:	HRLZI W,20		;@
	IORB W,WRD
	TLO F,QF
	JRST LIS2

ACCF:	MOVE R,T		;COMMA
	TLOE F,COMF	;A COMMA SEEN, WAS IT SECOND?
	JRST ACCCF	;YES, GO PROCESS
	ADD T,WRD	;GET TOTAL
	HRRM T,ACCCF	;AND SAVE
	HLLZ T,R	;GET LEFT HALF BACK
	LSH R,27
	SKIPE IOTFLG	;IS THIS AN IOT?
	LSH R,1		;THEN SHIFT ONE MORE
	ADD T,R
	ADDB T,WRD
	JRST SPACE+1
ACCCF:	MOVSI T,0	;MODIFIED TO BE LEFT HALF ON ,,
	MOVEM T,WRD
	JRST SPACE+1	;AND GO

SPACE:	TLNE F,QF
	TLO F,TIF
SPAC1:	TLZ F,MF+PTF
	JRST LIS1

RPRN:	TLNN F,QF		;)
	MOVEI T,0
	MOVS T,T
	SOSGE PRNC
	JRST ERR
	POP P,FRASE1
	POP P,FRASE
	POP P,WRD
	POP P,F
	TLNE F,PTF
	TLNE F,SF
	JRST RPRN1
	MOVEM T,SYL
	TLO F,QF+SF
	JRST L1RPR
RPRN1:	ADDB T,WRD
	TLO F,QF
	JRST L1RPR-1

CRN:	MOVEI T,15		;CARRIAGE RETURN
	JRST TOUT

IFE EDDT&1,<
CRNRB:	PUSHJ P,CRN
	MOVEI T,177
	JRST TOUT	>

↑CRF:	PUSHJ P,CRN
	MOVEI T,12		;LINE FEED
	JRST TOUT

LCT:
IFN EDDT&1,<	PUSHJ	P,TSPC	;EXEC DDT TYPES THREE SPACES INSTEAD OF TAB
		PUSHJ	P,TSPC>	;FALL INTO TSPC
IFE EDDT&1,<	MOVEI	T,11
		JRST	TOUT>

TSPC:	MOVEI T,40		;SPACE
	JRST TOUT
;LINEF LI0 LI1 LI2 VARRW DARRW CARR OCON OSYM SUPTYO SLASH SLAS2 SLAS1 ICON

	SUBTTL	DDT - REGISTER EXAMINATION LOGIC

LINEF:	PUSHJ	P,DEPRA		;NEXT REGISTER

IFE EDDT&1,<	PUSHJ	P,CRNRB
		JRST	.+2	>

LI0:	PUSHJ	P,CRF
	AOS	T,LLOC
LI1:	HRRZS	T
	HRRZM	T,LLOC
	HRRZM	T,LLOCO
	PUSHJ	P,PAD
	MOVEI	T,"/"
	TLNE	F,STF
	MOVEI	T,"!"
	PUSHJ	P,TOUT
LI2:	TLZ	F,ROF
	PUSHJ	P,LCT
	MOVE	R,LLOCO
	PUSHJ	P,FETCH
	 JRST	ERR
	TLO	F,ROF
	TLNE	F,STF
	JRST	DD2
	JRST	CONSYM		;RETURN IS A POPJ

VARRW:	PUSHJ P,DEPRA		;↑
	PUSHJ P,CRF
	SOS T,LLOC
	JRST LI1

IFN UEDDTS,<			;IN UEDDT, DOWN ARROW (CNTL A) MEANS 
				;CARRIAGE RETURN, PLUS WRITE ON L'SCOPE
DARRW:	MOVE R,LLOCO 		;PICK UP ADDRESS TO DEPOSIT
	PUSHJ P,DEPRA		;CLOSE REGISTER, ETC.
	JRST DD1		;RETURN TO MAIN LOOP

>;IFN UEDDTS

CARR:	PUSHJ P,DEPRA		;CLOSE REGISTER
	IFN EDDT&1,<JRST DD1>
	IFE EDDT&1,<JRST DD1.5>


OCON:	TROA F,LF1+CF1		;OPEN AS CONSTANT
OSYM:	TRZ F,CF1		;OPEN SYMBOLICALLY
	TROA F,LF1
SUPTYO:	TLOA F,STF		;SUPPRESS TYPEOUT
SLASH:	TLZ F,STF		;TYPE OUT REGISTER
	TLNN F,CF		;WAS $ USED?
	JRST SLAS2		;NO
	PUSHJ P,EFFECA		;TRY EFFECTIVE ADR
	JRST ERR		;WE LOST
SLAS2:	TLNN F,QF
	JRST SLAS1
	MOVE R,LLOC
	MOVEM R,SAVLOC	;SAVE FOR $CR ETC.
	HRRZM T,LLOC		;QUANTITY TYPED
SLAS1:	HRRZM T,LLOCO
	JRST LI2

ICON:	TLNN F,ROF	;REGISTER OPENED OR ERR
	JRST ERR
	PUSHJ P,DEPRS
	TLNN F,CF		;CHECK FOR ALTMODE
	JRST SLAS1
	PUSHJ P,EFFECA
	JRST ERR	;LOSE
	JRST SLAS1
;LTAB TAB TAB1 DEPRA EQUAL PSYM R50PNT SIXBP SIXBP1

;	LTAB, TAB, DEPRA, EQUAL, PSYM

LTAB:	MOVSS T		;SWAP HALVES FIRST
	CAIA		;DON'T DEPOSIT WITH SWAPPED HALVES
TAB:	PUSHJ P,DEPRS	;OPEN REGISTER OF Q
	TLNN F,CF
	JRST TAB1
	PUSHJ P,EFFECA
	JRST ERR
TAB1:	MOVEI T,-1(T)
	EXCH T,LLOC
	MOVEM T,SAVLOC		;AGAIN, SAVE IT
	HRROI T,700000
	PUSHJ P,TEXTT
	JRST LI0

DEPRA:	MOVE R,SAVLOC
	TLNE F,CF	;WAS THERE AN ALTMODE?
	EXCH R,LLOC	;RESTORE OLD LOC
	MOVEM R,SAVLOC	;AND SAVE THIS
	TLNE F,ROF		;REGISTER OPEN?
	TLNN F,QF		;YES. BEING CHANGED?
	JRST DEPRS		;NO.
	PUSHJ P,REMAUN		;REMOVE UNDEF SYMBOLS THAT WERE REFERENCED AT
	JRST DEPRS		;    THIS ADDRESS

EQUAL:	TLNE F,CF		;IF $=
	TRO F,EQF		;THEN REAL NUMERIC MODE
	TROA F,CF1		;= OUTPUT 1 REGISTER AS CONSTANT
PSYM:	TRZ F,CF1		;← OUTPUT SYMBOLIC
	TRO F,LF1		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
	PUSHJ P,CONSYM
	JRST RET

R50PNT:	LSH T,-36	;RADIX 50 SYMBOL PRINTER
	TRZ T,3
	PUSHJ P,TOC
	PUSHJ P,TSPC
	SETZM SVFB	;NO BLOCK NAME
	MOVEI W1,LWT	;SETUP FOR SPT
	JRST SPT

SIXBP:	MOVNI W2,6		;SIXBIT PRINTER
	MOVE W1,LWT
SIXBP1:	MOVEI T,0
	ROTC T,6
	ADDI T,40
	PUSHJ P,TOUT
	AOJL W2,SIXBP1
	POPJ P,
;JOBSET JOBST1 JOBST0 JOBST3 JOBST2 JOBST4 JOBSP2 JOBSET EP2DDT EP2DDM EP2DDN EP2DDR EP2DDL EP2DDP EP2DDX STROUT STROU1 TEXO HWRDS SFLOT SYMBOL CON UCON RELA ABSA BASECH BASE1 SEMIC

	SUBTTL	DDT - OUTPUT MODE CONTROL SWITCHES, UEDDT - JOBSET

;SET JOB NUMBER TO EXAMINE
IFN UEDDTS,<

JOBSET:	TLZE F,QF		;QUANTITY TYPED BEFORE THE $?
	JRST JOBST2		;YES.
	SKIPL T,WRD2
	CAMLE T,JOBMAX		;LEGAL JOB NUMBER?
	JRST UNDEF		;NO
	JUMPG T,JOBST0
	TLNE F,CCF		;$$¬ TYPED?
	JRST JOBSP2		;YES, GET P2'S SYMBOLS AND EXAMINE ITS CORE
	SETOM EXMMAP		;EXAMINE EXEC VIA EXPGT
JOBST1:	SKIPA R,[37]		;THIS IS EXEC JOBREL
JOBST0:	MOVEI R,44		;THIS IS LOSER JOBREL
	MOVEM T,EXJOBN
	PUSHJ P,FETCH
	 SETZ T,		;NOT FOUND
	MOVEM T,MEMSIZ		;THIS IS MAX LOC WE ARE LOOKING AT
	SKIPE EXJOBN		;FORCE SYSTEM SYMS IF LOOKING AT SYSTEM
	TLNN F,CCF		;DOES HE WANT USER'S SYMS?
	TDZA T,T		;NO
	SETO T,			;YES
	SKIPE P2EXM
	MOVEI T,-1		;0,,-1 MEANS USE P2'S SYMS
	SETZM P2EXM		;BUT DON'T DO IT AGAIN
	JUMPGE T,JOBST3		;JUMP IF WANT P1 OR P2 SYMS
	MOVEI R,210
	PEEK R,			;GET ADDRESS OF JBTSTS
	ADD R,EXJOBN		;ADD JOB NUMBER
	PEEK R,			;DON'T WANT TO LOOK AT JOBSYM IN UPPER SEG
	TLNE R,1000		;JSEG ON?
	JRST RET		;YES, KEEP OLD SYMBOLS (MAYBE FROM LOWER)
JOBST3:	EXCH T,EXSYMS
	CAMN T,EXSYMS		;CHANGING MODE?
	JUMPE T,RET		;NO, IF STAYING WITH EXEC SYMS, NO RE-INIT
	PUSHJ P,COPSYM		;SETUP SYMBOLS!!!
	SETZM GETFLG		;MAKE PROGRAM BE AUTO-OPENED
	JRST DDTB		;FIXUP SYMS!

JOBST2:	MOVE T,WRD		;GET THE SIGNED ARGUMENT - N$↑E TYPED.
JOBST4:	MOVEM T,EXMMAP		;SAVE IT (POSITIVE DENOTES PAGE NUMBER TO EXAMINE)
	MOVEI T,0
	JRST JOBST1

JOBSP2:	SETOM P2EXM#		;EXAMINING USING P2'S SYMBOLS
	MOVEI T,4000		;BASE OF P2'S MEMORY
	JRST JOBST4
>;IFN UEDDTS

IFN <EDDT&20>&<¬P2SYS>,<	;EDDT version
JOBSET:	MOVEI W1,[ASCIZ /↑E /]
	PUSHJ P,STROUT		;Do some echoing
	TLZE F,QF		;QUANTITY TYPED BEFORE THE $?
	JRST JOBST2		;YES, examine from that page up
	SKIPE T,WRD2		;Get arg after $
	JRST ERR		;Job examine not implemented (GT 0), or undef (LT 0)
	TLNE F,CCF		;$$¬ TYPED?
	JRST JOBSP2		;YES, RUN P2'S DDT
	SETOM EXMMAP		;$¬ MEANS EXAMINE EXEC VIA EXPGT
	JRST RET

JOBST2:	MOVE T,WRD		;GET THE SIGNED ARGUMENT, N$↑E TYPED.
	MOVEM T,EXMMAP		;SAVE IT (POSITIVE DENOTES PAGE NUMBER TO EXAMINE)
	JRST RET		;NEGATIVE MEANS USE MAP, -2 MEANS SEE DDT NOT SHADOW

JOBSP2:
IFE FTP2,<
	JRST ERR		;Yes, no P2
>;IFE FTP2
IFN FTP2,<
	SKIPE NOP2
	 JRST EP2DDP	;CAN'T
	MOVEI W1,[ASCIZ /   P2SYS not running (P2NUM zero). /]
	SKIPN P2NUM	;WARN USER IF P2 ISN'T RUNNING
	PUSHJ P,STROUT
	MOVE T,P1BPTX	;INITIAL VALUE FOR O/P BPT
	MOVEM T,P1BPTO	;START O/P BPT
	MOVE T,P1OCNT	;HOW MANY CHARS FIT IN BUFFER
	MOVEM T,P1FLGO	;START COUNT
	SETOM P1DDTF	;TELL P2 TO GO TO DDT
	MOVSI T,10	;HOW LONG TO WAIT
	SKIPE P1DDTF	;IS P2 IN DDT YET?
	SOJG T,.-1	;NO
	JUMPG T,EP2DDT
	MOVEI W1,[ASCIZ /
You'll have to get P2 into DDT manually.  /]
	PUSHJ P,STROUT
	SKIPE P1DDTF
	JRST .-1
EP2DDT:	MOVEI W1,[ASCIZ /
(Set P2TSUP to -1 to suppress typeout on P2 CTY.)
OK, you're in P2 EDDT.
/]
	PUSHJ P,STROUT

EP2DDM:	SKIPN P1CHRI	;DON'T LOSE A CHAR
	PUSHJ P,LISTEN	;USER WANT TO TYPE INPUT?
	 JRST EP2DDN	;ALREADY I/P FOR P2, OR NOTHING TYPED, TRY FOR OUTPUT
	CAIN T,5	;IS THIS ¬ TO GET OUT?
	JRST EP2DDX	;YES, LEAVE
	MOVEM T,P1CHRI	;GIVE CHAR TO P2
EP2DDN:	MOVE W2,P1BPTX	;IS THERE ANY OUTPUT WAITING?
	CAMN W2,P1BPTO	;(INITIAL BPT DIFFERENT FROM CURRENT BPT?)
	JRST EP2DDM	;NO, NO MORE TO DO
	MOVEI TT,0	;YES, FIRST FREEZE P2 OUTPUT
	EXCH TT,P1FLGO	;WAS IT ALREADY FROZEN?
	JUMPG TT,.-2	;NO, WAIT FOR THINGS TO SETTLE DOWN
	JUMPL TT,EP2DDL	;WE WAITED TOO LONG, P2 TURNED US OFF
	MOVE W1,P1BPTO	;OK, GET O/P BPT
	ADDI W1,P2VORG	;MAKE IT RELATIVE TO P2 ORIGIN
	IDPB TT,W1	;MAKE SURE OUTPUT STRING ENDS WITH A NULL
	MOVEI W1,P2VORG(W2)
	PUSHJ P,STROUT	;TYPE THE STUFF
EP2DDR:	MOVEM W2,P1BPTO	;RESTART O/P BPT
	MOVE TT,P1OCNT	;HOW MANY CHARS FIT IN BUFFER
	MOVEM TT,P1FLGO	;RESTART COUNT
	JRST EP2DDM

EP2DDL:	MOVEI W1,[ASCIZ / (lost some!) /]
	PUSHJ P,STROUT
	JRST EP2DDR

EP2DDP:	MOVEI W1,[ASCIZ /   NOP2 set, can't use P2 memory.
/]
	PUSHJ P,STROUT
	JRST RET

EP2DDX:	SETOM P1FLGO	;NO LONGER RUNNING P2
	MOVEI W1,[ASCIZ /↑E
P1 EDDT
/]
	PUSHJ P,STROUT
	JRST RET		;DONE
>;IFN FTP2

STROUT:	HRLI W1,440700		;MAKE BPT OF ADDRESS
STROU1:	ILDB T,W1		;TYPE TEXT STRING
	JUMPE T,CPOPJ
	PUSHJ P,TOUT
	JRST STROU1
>;IFN <EDDT&20>&<¬P2SYS>

TEXO:	MOVEI R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE T,WRD2
	CAIN T,6		;CHECK FOR $6T
	MOVEI R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN T,5		;CHECK FOR $5T
	MOVEI R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
	CAIN T,11		;CHECK FOR $9T
	MOVEI R,TEXTT9-HLFW	;SET MODE SWITCH FOR 9 BIT ASCII
	CAIN T,10		;CHECK FOR $8T
	MOVEI R,TEXTT8-HLFW	;SET MODE SWITCH FOR 8 BIT ASCII
HWRDS:	ADDI R,HLFW-TFLOT	;H
SFLOT:	ADDI R,TFLOT-PIN	;F
SYMBOL:	ADDI R,PIN-TOCC		;S
CON:	ADDI R,TOCC-FTOC	;C
UCON:	ADDI R,FTOC		;U
	HRRZ SCH,R
	JRST BASE1

RELA:	TRZE F,Q2F		;CHANGE ADDRESS MODE TO RELATIE
	JRST BASECH
	MOVEI R,PADSO-TOC
ABSA:	ADDI R,TOC		;A
	HRRZ AR,R
	JRST BASE1

BASECH:	MOVE T,WRD2		;$NR  CHANGE OUTPUT RADIX TO N, N greater than 1
	CAIGE T,2
	JRST ERR
	HRRZ ODF,T
BASE1:	MOVS S,[XWD SCHM,SCH]
	TLNN F,CCF
	JRST LIS1
	BLT S,ODFM	;WITH $$, MAKE MODES PERMANENT
	JRST RET

SEMIC:	MOVEM T,LWT		;SEMICOLON TYPES IN CURRENT MODE
	JRST (SCH)
;STR STR1 XEC BREAKA BREAKB BREAK1 BREAK2 RETB BRKNAM PROCEED PROC3 PROCD1 PROC0 PROC2

	SUBTTL	DDT - GO, EXECUTE, AND BREAKPOINT LOGIC

STR:	HRLI	T,254000	;$G.  LOAD JRST INSTRUCTION
	TLOE	F,QF		;WAS THERE AN ARGUMENT?
	JRST	STR1		;YES. USE IT.
IFN EDDT&1,<	HRR T,STARTA>	;LOAD TAPE START ADDRESS
IFE EDDT&1,<	HRR T,JOBSA>	;GET STARTING ADDRESS
	TRNN	T,-1		;WAS THERE ANY REASONABLE ARGUMENT FOUND?
	JRST	ERR		;NO.  DO NOTHING.
	JRST	XEC0		;EXECUTE THE JRST

STR1:	TLNE	F,CCF		;<ARG>$$G?
IFN EDDT&1,<	HRRM T,STARTA>	;YES.  STORE START ADDRESS
IFE EDDT&1,<	HRRM T,JOBSA>	;YES.  STORE START ADDRESS
	JRST	XEC0

XEC:	TLNE	F,QF		;NO ARG
	TLNN	T,777000	;OR ARG NOT INSTRUCTION
	JRST	$X		; therefore SINGLE STEP
	JRST	XEC0


↑BREAKA:PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
↑BREAKB:PUSHJ	P,CHKSYM	;RESET PRGM AND BLOCK IF SYMBOLS MOVED
	SOS	T,BCOM3
	HRRZS	T		;GET ADDR OF BREAKPOINT JUST HIT
	SUBI	T,B1ADR-4
	IDIVI	T,4
	HRRM	T,BREAK2	;WE WANT IT LATER
	MOVE	W1,BRKNAM-1(T)	;GET THE RIGHT JUNK
	PUSHJ	P,TEXT2		;AND PRINT
;<<<<<<< THESE BALANCE THE >'S IN THE NEXT FEW LINES
	MOVSI	W1,(<ASCIZ />/>)	;TYPE > FOR COND BREAK
	SKIPG	@BCOM2		;TEST PROCEED COUNTER
	MOVSI	W1,(<ASCIZ />>/>)	;TYPE >> FOR PROCEED COUNTER BREAK
	PUSHJ	P,TEXT2
	MOVE	T,BCOM
	HLLM	T,SAVPI		;SAVE PROCESSOR FLAGS
	MOVEI	T,-1(T)
	PUSHJ	P,PAD		;TYPE PC AT BREAK
	HRRZ	T,@BCOM3
	HRRM	T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ	T,@BCOM3
	JUMPE	T,BREAK1	;TEST FOR REGISTER TO EXAMINE
	PUSHJ	P,LCT		;PRINT TAB
	HLRZ	T,@BCOM3
	PUSHJ	P,LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	MOVSI	S,400000
BREAK2:	ROT	S,0		;WILL BE MODIFIED WITH BREAK NUM
	PUSHJ	P,LISTEN	;DONT PROCEED IF TTY KEY HIT
	 TDNN	S,AUTOPI	;DONT PROCEED IF NOT AUTOMATIC
	JRST	RETB		;TAKE A BREAK
	MOVEI	T,2		;COMPENSATE FOR SOS INSTRUCTION
	ADDB	T,@BCOM2
	JUMPL	T,PROCD1	;GO IF STILL LESS THAN
	ANDCAM	S,AUTOPI	;TURN OFF AUTOPI
RETB:	HRRZ	T,BCOM2		;BREAK.  SET UP TEXT STRING FROM BNSTR
	SKIPE	T,1(T)		;IS THERE A POINTER TO A STRING?
	HRLI	T,(<POINT 7,0>)	;YES. MAKE IT A BYTE POINTER
	MOVEM	T,STRING	;STUFF IT WHERE THE TTY READER WILL SEE IT
	JRST	RET

RADIX =10
BRKNAM:	FOR @% I←1,NBP
<	ASCII /$%I%B/
>
RADIX =8

PROCEED:TLNE	F,QF		;N$P	;PROCEED AT A BREAKPOINT
	JRST	PROC3		;QUANTITY TYPED
	MOVEI	T,1		;IF NO QUANTITY TYPED, USE 1
	TLNE	F,CCF		;IF $$P
	MOVSI	T,200000	;THEN VERY LARGE COUNT
PROC3:	TLNE	F,CCF		;AUTO PROCEED?
	MOVNS	T		;NEGATE
	MOVEM	T,@BCOM2	;STORE PROCEED COUNTER
	HRRZ	R,BCOM3
	PUSHJ	P,AUTOP
PROCD1:	PUSHJ	P,CRF
	PUSHJ	P,TTYLEV
PROC0:	HRRZI	R,XEC1		;* MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ	P,FETCH
	 JRST	BPLUP1		;ONLY GET HERE IF MEMORY SHRANK
	MOVEM	T,LEAV
	PUSHJ	P,INSRTB
	JRST	PROC2

↑PROC2:	MOVEI	W,100
	MOVEM	W,TEM1		;SETUP MAX LOOP COUNT
	JRST	IXCT5
;$X $X00 $X01 $X02 $X03 $XTBL

SUBTTL	SINGLE STEP CODE FROM DEC

COMMENT	\

	The following code is nearly identical with that distributed
by DEC

$X works as follows:
	$X executes a single instruction then increments the PC.
	   Operands of the instruction are printed out as they exist
	   after the instructions execution.
	  An extra linfeed indicates a skip or jump.  Finally, the
	  instruction now pointed at is printed in symbolic form.
	n$X does $X n times.
	$$X does $X until PC reaches its original state +1 or +2
	  without  printing anything.
	n$$X does n$X but only prints for the nth instruction

\


; Flags indicating things to print:

	FAC←←1			; 1 AC
	DFAC←←2			; 2 ACs
	FLG←←4			; Flags.
	IMM←←10			; Instruction is immediate mode.
	EA←←20			; Memory referencing.
	DEA←←40			; References 2 memory locs.
	FLA←←100		; Floating AC used
	FLE←←200		; Floating  memory used. 
	PFLG←←400		; on → PUSHx or POPx

$X:
IFE P2SYS,<
IFE EDDT&21-21,<
	SKIPLE EXMMAP		;Don't try to proceed while funny mapping
	SETOM EXMMAP		;Back to normal map use
>;IFE EDDT&21-21
>;IFE P2SYS
	TLNN	F,QF		; Any arg from the user ?
	JRST	.+3		; No.
	MOVEM	T,XTEM		; XTEM holds repetition count or
				;is negative for $$x without an arg.
	JUMPG	T,$X00
	HRRZ	T,PROC0
	MOVEM	T,LOCSAV
	SETOM	XTEM
	TLNN	F,CCF		; CCF on → $$ typed
	MOVNS	XTEM
$X00:	PUSHJ	P,CRF		; Give 'em a CRLF to start
$X01:	SOSN	XTEM		; Decrement & test counter
	TLZ	F,CCF		; Zap $$ flag to signal last iteration.
	TLZ	F,QF!CF!STF
	MOVEM	F,FLAGS		; Save flags since we wipe them out
	MOVEI	T,100		; Set max XCT depth
	MOVEM	T,XCTS
	HRRZ	R,PROC0		; RH(PROC0)=Adr of current instruction
	CAIN	R,XEC1		; Cant trace ourselves!
	JRST	ERR
	SKIPL	XTEM
	MOVEM	R,LOCSAV	; Save loc unless $$X
$X02:	PUSHJ	P,FETCH		; Get the instruction
	 JRST	ERR
$X03:	MOVEM	T,I.NST
	JSR	SWAP		; EXCH our ACs with the user's ACs
	MOVEM	T,SAV0
	MOVEI	T,@I.NST
	DPB	T,[POINT 23,I.NST,35]	; Store effective address
	HRRZM	T,I.NSTEA
	MOVE	T,SAV0
	JSR	SWAP		; Make us ourselves again.
	LDB	W1,[POINT 4,I.NST,12]; AC field.
	MOVEM	W1,I.NSTAC
	MOVSI	T,777000
	AND	T,I.NST
	HLRZ	F,T
	CAMLE	T,$XTBL(T)
	AOJA	T,.-1
	JRST	@$XTBL(T)


comment *
	Opcode dispatch table:
	   LH of entry contains largest opcode covered by that entry.
	   RH of entry contains address of routine to dispatch to.

	*

OPDEF	KAFIX	[247B8]	;STANFORD KA10 (AND 166) FIX INSTRUCTION

$XTBL:	SETZB	SET	; 400-403  SETZx
	ORCBB	CHECKI	; 404-473  All logical except SETx
	SETOB	SET	; 474-477  SETOx
	HLRES	CHEKIS	; 500-577  Hxxxx
	TSON	TESTS	; 600-677  Txxx
	777000,,IOTS	; 700-777  I/O
	0,,ERR		; 000
	037000,,USRUUO	; 001-037  LUUOS
	CALL	MONUAE	; 040      CALL
	INIT	MONINI	; 041      INIT
	CALLI	MONUAI	; 042-047  CALLI, SPCWAR, undefined
	TTCALL	MONUE	; 050-051  OPEN,TTCALL
	054000,,MONUAI	; 052-054  Undefined
	OUT	MONUE	; 055-057  RENAME,IN,OUT
	STATO	MONUI	; 060-061  SETSTS,STATO
	GETSTS	MONUE	; 062      GETSTS
	OUTBUF	MONUI	; 063-065  STATZ,INBUF,OUTBUF
	OUTPUT	MONUE	; 066-067  INPUT,OUTPUT
	USETO	MONUI	; 070-075  CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO
	ENTER	MONUE	; 076-077  LOOKUP,ENTER
	104000,,SETI	; 100-104  Undefined
	ADJSP	SETEA	; 105	   ADJSP (KL-10)
	107000,,SETI	; 106-107  Undefined
	DFDV	DFLT	; 110-113  DFAB,DFSB,DFMP,DFDV (KL-10)
	DDIV	DINT	; 114-117  DADD,DSUB,DMUL,DDIV (KL-10)
	DMOVN	DINT	; 120-121  DMOVE,DMOVN
	KIFIX	SETEA	; 122	   FIX
	EXTEND	IEXTND	; 123	   EXTEND (KL-10)
	DMOVNM	DINT	; 124-125  DMOVEM,DMOVNM
	FLTR	SETEA	; 126-127  FIXR,FLTR
	UFA	IUFA	; 130      UFA
	DFN	IDFN	; 131      DFN
	FSC	IFSC	; 132      FSC
	IBP	SKP 	; 133      IBP [or ADJBP (KL-10)]
	DPB	SETEA	; 134-137  xLDB,xDPB
	FDVRB	FLOAT	; 140-177  FADxx,FSBxx,FMPxx,FDVxx
	MOVMS	CHEKIS	; 200-217  MOVxx
	IMULB	CHECKI	; 220-223  IMULx
	DIVB	MULDIV	; 224-237  MULx,xDIVx
	LSH	SETI	; 240-242  ASH,ROT,LSH
	JFFO	IJFFO	; 243      JFFO
	LSHC	DBLI	; 244-246  ASHC,ROTC,LSHC
	KAFIX	SETI	; 247      FIX
	EXCH	SETEA	; 250      EXCH
	BLT	SETI	; 251      BLT
	AOBJN	IAOBJ	; 252-253  AOBJx
	JRST	IJRST	; 254      JRST
	JFCL	IJFCL	; 255      JFCL
	XCT	I.XCT	; 256      XCT
	MAP	SETEA	; 257	   MAP (KL-10)
	PUSHJ	IIPUSHJ	; 260      PUSHJ
	POP	IPUPO	; 261-262  PUSH,POP
	POPJ	IPOPJ	; 263      POPJ
	JSR	I.JSR	; 264      JSR
	JSP	I.JSP	; 265      JSP
	JSA	I.JSA	; 266      JSA
	JRA	IAOBJ	; 267      JRA
	SUBB	CHECKI	; 270-277  ADDx,SUBx
	CAIG	SETI	; 300-307  CAIxx
	CAMG	SETEA	; 310-317  CAMxx
	SOSG	JMPSKP	; 320-377  JUMPxx,SKIPxx,AOJxx,AOSxx,SOJxx,SOSxx
;MONUAI MONUI MONUAE MONUE MONINI XECDET MONIN1 INLINI USRUUO IUFA IDFN DFLT FLOAT FLOATI IJRST IJRST0 IJRST1 JRSPRC IJRST3 I.XCT IIXCT1 IIPUSHJ IPOPJ IPOPJ2 IPUPO IFSC I.JSA I.JSR I.JSR2 I.JSP I.JSR4 IJFFO JMPSKP IAOBJ IJFCL JMP1 SKP JUSTE DBLI DINT IEXTND TESTS IOTS JUSTI CHEKIS SET MULDIV CHECKI SETEA SETI DOIT SKIP% NOSKIP TELL NXTIT NXT0 $XQUIT NXT1 NXT2 PFLG0 DBL0 FAC0 FLG0 IMM0 IMM1 DEA0 EA0 EA2 EA6 PINST SWAP SWAPL

; MUUOs
DEFINE SKPEXC {PUSHJ P,XECDET}	; Assume that EDDT users are in EXEC mode.

IFN EDDT&1,<
MONUAI:	TLO	F,FAC		; Print AC
MONUI:	SKPEXC
	JRST	JUSTI
	JRST	USRUUO		; Trace MUUOs in EXEC mode.

MONUAE:	TLO	F,FAC
MONUE:	SKPEXC
	JRST	JUSTE
	JRST	USRUUO

MONINI:	SKPEXC
	JRST	MONIN1
	JRST	USRUUO

XECDET:	MOVSI	T,010000		; Test for user mode		*******
	TDNN	T,SAVPI
	AOS	(P)
	POPJ	P,
>; IFN EDDT&1

MONIN1:	MOVE	T,I.NST			; Here to interpret INITs
	MOVEM	T,INLINI
	AOS	R,PROC0			; Get first inline arg to INIT
	PUSHJ	P,FETCH
	 JRST	ERR
	MOVEM	T,INLINI+1
	AOS	R,PROC0
	PUSHJ	P,FETCH
	 JRST	ERR
	MOVEM	T,INLINI+2
	EXCH	F,FLAGS
	TLNN	F,CCF
	MOVEM	R,LOCSAV		; Only update original PC if not $$X
	MOVE	T,[JRST INLINI]
	MOVEM	T,I.NST
	JRST	DOITA

INLINI:	0
	0
	0
	JRST	DOITB
	JRST	DOITC

; LUUOs
USRUUO:	MOVEI	R,40
	EXCH	F,FLAGS
	MOVE	T,I.NST
	PUSHJ	P,DEP
	EXCH	F,FLAGS
	MOVE	T,[XCT 41]
	JRST	$X03			; Simulate the trap

IUFA:	TLOA	F,FLA!FLE!DFAC		; Floating point; uses 2 ACs
IDFN:	TLO	F,FLA!FLE		; Floating point + 1 AC
	JRST	SETEA

DFLT:	TLO	F,FLA!DEA!DFAC!FLE	;Dbl floating memory + double ac
	JRST	SETEA

; Here for floating point instructions.
FLOAT:	ANDI	F,7000
	CAIN	F,1000			; long mode ?
	TLOA	F,DFAC			; Yes; 2 ACs
	CAIN	F,5000			; Immediate mode ?
	TLOA	F,FLA!FLE!FAC!EA	; No; AC, E floating
FLOATI:	TLO	F,FLA!FLE!FAC!IMM	; Yes; AC, E immediate floating
	JRST	DOIT

IJRST:	TLO	F,IMM			; Print E
	TRNE	W1,2
	TLO	F,FLG			; Print flags if JRSTF
IJRST0:	PUSHJ	P,FETCH		; It's so f-----g hard to get at the flags!!!
	 JRST	ERR
	MOVE	W1,T
	LDB	R,[POINT 4,T,17]	; Index AC
	JUMPE	R,IJRST1
	MOVE	T,AC0(R)
	TLZ	T,37		; Clear I,X fields
	ADDI	T,(W1)
	TLZ	F,37
IJRST1:	MOVEI	R,(T)
	TLNE	W1,20
	JRST	IJRST0
; LH T has the flags to restore.
IFN EDDT&1,<
	SKPEXC
	JRST	IJRST3
	MOVE	W1,I.NSTAC
	TRNE	W1,1			; Jump to USER mode ?
	JRST	JRSPRC			; Yes, lose
	TRNE	W1,2			; JRSTF to USER ?
	TLNN	T,(1B5)
	JRST	IJRST3
JRSPRC:	EXCH	F,FLAGS			; Lose.
	TLZ	F,QF!CCF
	JRST	PROCD1			; Treat like $P
>

IJRST3:	HRRI	T,DOITB
	MOVEM	T,BCOM			; Store new PC word
	SOS	T,I.NST
	HRRM	T,PROC0
	HRRI	T,BCOM
	TLO	T,20
	MOVEM	T,I.NST			; JRST @BCOM now
	JRST	DOIT

I.XCT:	IFN EDDT&1,<DPB W1,[POINT 4,INSXCT,12]>; Make sure EXEC XCTs work right
	MOVE	F,FLAGS
	SOSG	XCTS
	JRST	ERR			; Too many XCTs.
	TLNE	F,CCF			; $$X ?
	JRST	IIXCT1
	HRRZ	T,I.NSTEA
	PUSHJ	P,PINST			; Print instruction
	PUSHJ	P,CRF
IIXCT1:	HRRZ	R,I.NSTEA
	JRST	$X02

IIPUSHJ:AOS	T,PROC0
	HLL	T,SAVPI			; PC word a normal PUSHJ would store
	MOVEM	T,I.NSTPC
	MOVSI	T,(1B4)
	ANDCAM	T,SAVPI			; Clear funny flag in PC wd.
	SOS	T,I.NST			; DOIT insists on incrementing the PC
	HRRM	T,PROC0
	HRLZI	T,(<PUSH>-<PUSHJ>)
	DPB	T,[POINT 5,I.NST,17]	; Clear AC,I fields
	JRST	IPOPJ2

IPOPJ:	EXCH	F,FLAGS
	HRRZ	R,AC0(W1)
	PUSHJ	P,FETCH
	 JRST	ERR
	EXCH	F,FLAGS
	HRRI	T,-1(T)			; DOIT increments the PC
	HRRM	T,PROC0
	HRLZI	T,(<POP>-<POPJ>)
IPOPJ2:	ADDM	T,I.NST			; PUSHJ→PUSH, POPJ→POP
	HRRZI	T,I.NSTPC		; PC word to PUSH if PUSHJ
	HRRM	T,I.NST
IPUPO:	TLOA	F,FAC!PFLG
IFSC:	TLO	F,FAC!FLA!IMM		; Floating AC, fixed immediate E
	JRST	DOIT

I.JSA:	AOS	T,PROC0
	HRL	T,I.NSTEA
	EXCH	T,AC0(W1)
	JRST	I.JSR2			; Use JSR code to store old AC

I.JSR:	AOS	T,PROC0
	HLL	T,SAVPI			; Make the PC word
	TLO	F,FAC
	MOVSI	W1,(1B4)
	ANDCAM	W1,SAVPI		; Clear funny bit in flags
I.JSR2:	TLO	F,EA
	EXCH	F,FLAGS
	HRRZ	R,I.NSTEA
	PUSHJ	P,DEP
	EXCH	F,FLAGS
	HRRZ	T,I.NSTEA
	AOJA	T,I.JSR4

I.JSP:	AOS	T,PROC0
	HLL	T,SAVPI
	MOVEM	T,AC0(W1)
	MOVSI	T,(1B4)
	ANDCAM	T,SAVPI			; Clear funny bit
	HRRZ	T,I.NSTEA
I.JSR4:	HRRM	T,PROC0
	TLC	F,FAC
	EXCH	F,FLAGS
	JRST	TELL			; Simulation complete; do printout

IJFFO:	TLO	F,DFAC			; 2 ACs
JMPSKP:	TRNE	F,10000
	JRST	SKP			; Skip class; no trouble
IAOBJ:	TLOA	F,FAC!IMM
IJFCL:	TLO	F,FLG
	MOVEI	T,JMP
	HRRM	T,I.NST			; Make jump to us if they jump
	JRST	DOIT

↑JMP1:	EXCH	T,I.NSTEA		; They jumped; now we've got to simulate
	HRRM	T,PROC0			;STORE EFFECTIVE ADDRESS OF JUMP
	EXCH	T,I.NSTEA
	JRST	TELL			;DO PRINTOUT (DON'T INCREMENT PROC0)

SKP:	JUMPN	W1,DOIT
JUSTE:	TLOA	F,EA
DBLI:	TLO	F,FAC!DFAC!IMM		; 2 ACs, immediate mode
	JRST	DOIT

DINT:	TLO	F,DFAC!DEA		;Dbl integer ins. (KL-10)
	JRST	DOIT

IEXTND:	JRST	SETEA			;KL-10 EXTEND instruction--nothing
					; special until somebody uses it.

TESTS:	TRNN	F,10000
	TLOA	F,FAC!IMM		; TRxx or TLxx
	TLO	F,FAC			; TDxx or TSxx
	JRST	DOIT

; I/O instructions
IFN EDDT&1,<
IOTS:	TRNE	W1,4			; Skip if BLKx or DATAx
	CAIN	W1,5			; Skip if not CONI
	TLOA	F,EA>
JUSTI:	TLO	F,IMM
	JRST	DOIT

CHEKIS:	TRC	F,3000
	TRCE	F,3000
	JRST	CHECKI			; Check for immediate mode
	JRST	SKP			; Self mode

SET:	ANDI	F,3000			; SETZx or SETOx come here
	CAIE	F,2000			; Skip if SETZM or SETOM
	TLO	F,FAC
	TRNE	F,2000			; Skip if not SETZM,SETZB,SETOM,SETOB
	TLO	F,EA
	JRST	DOIT

MULDIV:	ANDI	F,3000
	CAIE	F,2000			; Skip if to memory only
	TLO	F,DFAC
CHECKI:	TRNE	F,1000
	TRNE	F,2000
SETEA:	TLOA	F,FAC!EA		; Memory reference instruction
SETI:	TLO	F,FAC!IMM		; Immediate mode instruction
DOIT:	EXCH	F,FLAGS
	JRST	DOITA

IFE EDDT&1,<
	MONUI←←JUSTI
	MONUE←←JUSTE
	MONUAI←←SETI
	MONUAE←←SETEA
	MONINI←←MONIN1
	IOTS←←MONUI
>

↑SKIP%:	AOS	PROC0
↑NOSKIP:AOS	PROC0
TELL:
IFN EDDT&1,<
	MOVEI	T,
	DPB	T,[POINT 4,INSXCT,12]	; Zap AC field so EXEC XCTs only affect 1 instruction.
>
	MOVE	F,SAV0
	TLNE	F,CCF			; Don't print if $$X
	JRST	NXTIT
	EXCH	F,FLAGS
	PUSH	P,SCH			; Save current output mode
	TLNE	F,FLA			; Floating AC to print ?
	MOVEI	SCH,TFLOT
	TLNE	F,FAC
	PUSHJ	P,FAC0			; Print AC
	TLNE	F,DFAC
	PUSHJ	P,DBL0			; Print 2nd AC
	TLNE	F,FLG
	PUSHJ	P,FLG0			; Print the flags
	MOVE	SCH,(P)			; Restore old output mode.
	TLNE	F,FLE
	MOVEI	SCH,TFLOT		; Floating memory to print
;	TLNE	F,IMM
;	PUSHJ	P,IMM0			; Just print E in immediate mode
	TLNE	F,EA
	PUSHJ	P,EA0			; Print (E) if memory referencing instruction
	TLNE	F,DEA
	PUSHJ	P,DEA0			; Print 2nd memory word
	TLNE	F,PFLG
	PUSHJ	P,PFLG0			; Print stack word if PUSHx or POPx
	POP	P,SCH
	EXCH	F,FLAGS
	PUSHJ	P,CRF

; Test whether to continue; print next instruction if required.
NXTIT:	HRRZ	T,PROC0
	MOVEI	W1,1(T)
	HRRZM	W1,BCOM			; Store for $P
	HRRZ	W1,LOCSAV		; Old PC
	SKIPL	XTEM			; $$X with no argument ?
	JRST	NXT0			; No
	CAIE	T,1(W1)
	CAIN	T,2(W1)
	JRST	$XQUIT
NXT0:	PUSHJ	P,LISTEN		; Did he type anything ?
	 JRST	NXT1			; Nope
$XQUIT:	SETZM	XTEM
	TLZ	F,CCF
NXT1:	TLNE	F,CCF			; $$X ?
	JRST	NXT2			; Yes
	HRRZ	T,PROC0
	CAIE	T,1(W1)
	PUSHJ	P,CRF			; Extra CRLF → instruction skipped
	HRRZ	T,PROC0
	PUSHJ	P,PINST			; Print next instruction
	SKIPE	XTEM
	PUSHJ 	P,CRF
NXT2:	SKIPE	XTEM
	JRST	$X01
IFE EDDT&1,<	CLRBFI			; *** Done *** >;IFE EDDT&1
	JRST	DD2

; The sundry output routines
PFLG0:	MOVE	T,I.NSTAC
	HRRZ	T,AC0(T)		; Get adr of stack
	JRST	EA2
DBL0:	AOS	T,I.NSTAC
	TRZA	T,777760		; Modulo 20
FAC0:	MOVE	T,I.NSTAC
	JRST	EA2
FLG0:	PUSHJ	P,LCT			; Print TAB
	HLRZ	T,SAVPI
REPEAT 0,<
	JRST	IMM1
IMM0:	PUSHJ	P,LCT			; Print TAB
	HRRZ	T,I.NSTEA
	TLNE	F,FLE			; Floating memory operand ?
	MOVS	T,T			; Yes; immediate swaps halves
>; REPEAT 0
IMM1:	EXCH	F,FLAGS
	PUSHJ	P,CONSYM		; Type (T)
	JRST	EA6
DEA0:	AOSA	T,I.NSTEA
EA0:	MOVE	T,I.NSTEA		; Address of memory operand
EA2:	EXCH	F,FLAGS
	PUSH	P,T
	PUSHJ	P,LCT			; Print a TAB
	POP	P,T
	PUSHJ	P,LI1			; Print ADR/	CONTENTS
EA6:	EXCH	F,FLAGS
	POPJ	P,
PINST:	PUSH	P,SCH			; Save current output mode
	MOVEI	SCH,PIN			; Force symbolic output
	PUSHJ	P,LI1
	PUSHJ	P,LCT
	POP	P,SCH
	POPJ	P,

; SWAP swaps user's and DDT's ACs or vice-versa
SWAP:	0
	EXCH	0,AC0
	MOVEM	0,SAV0
	MOVE	0,[EXCH 1,AC0+1]
SWAPL:	XCT	0
	ADD	0,[XWD 40,1]
	TLNN	0,1000
	JRST	SWAPL
	MOVE	0,SAV0
	JRST	@SWAP
;IXCT4 IIXCT IXCT IXCT5 IXCT6 BPLUP BPLUP1 IINIT INITL

;INTERPRETATION

IXCT4:				;INTERPRET UUO
IFE EDDT&1,<	SUBI	T,041
		JUMPE	T,IINIT	;INIT UUO HAS TO BE DONE SPECIAL
		AOJGE	T,IXCT6	;JUMP IF SYSTEM UUO.  (DON'T INTERPRET) >
	MOVEM	R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI	R,41
	JRST	IXCT

;(INTERPRETAION OF EXECUTIVE XCT OF A PC-STORING JUMP WILL STORE WRONG PC)
IIXCT:					;HERE TO INTERPRET XCT.
IFN EDDT&1,<	JUMPN	W1,IXCT6	;JUMP IF EXECUTIVE XCT>
IXCT:	SOSL	TEM1			;COUNT LOOPS THRU INTERPRETER
	PUSHJ	P,FETCH
	 JRST	BPLUP			;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM	T,LEAV			;STORE INSTR. TO EXECUTE.
IXCT5:	LDB	T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIN	T,254			;JRST IS NORMAL
	JRST	IXCT6
	HRLZI	17,AC0			;SETUP ACS TO ALLOW EFFECT ADDRESS CALC.
	BLT	17,17
	MOVEI	T,@LEAV			;CALCULATE EFFECTIVE ADDRESS.
	DPB	T,[POINT 23,LEAV,35]	;STORE EFFECTIVE ADDRESS, CLEAR X AND @
	LDB	W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB	T,[POINT 9,LEAV,8]	;PICK UP INSTRUCTION FIELD
	MOVEI	P,PS			;AND GET A STACK
	CAIN	T,260
	JRST	IPUSHJ			;INTERPRET PUSHJ
	CAIN	T,264
	JRST	IJSR			;INTERPRET JSR
	CAIN	T,265
	JRST	IJSP			;INTERPRET JSP
	CAIN	T,266
	JRST	IJSA			;INTERPRET JSA
	MOVE	R,LEAV			;GET ENTIRE INSTR. (INCASE OF UUO OR XCT)
	TRNN	T,700
	JRST	IXCT4			;INTERPRET UUO
	CAIN	T,256
	JRST	IIXCT			;INTERPRET XCT (MAY BE EXEC EXECUTE)
IXCT6:	MOVE	W,LEAV			;FOR RESTORE TO XCT
	MOVEI	T,@BCOM			;GET RETURN ADR
	JRST	RESTORE

;BREAKPOINT PROCEED ERROR
BPLUP:	PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
BPLUP1:	JSR	SAVE
	 JFCL
	JRST	ERR

IFE EDDT&1,<			;INTERPRET INIT UUO
IINIT:	MOVE	T,LEAV
	MOVEM	T,INITL		;SET UP TO DO THE INIT HERE
	MOVEI	R,@BCOM		;THE LOC OF INIT+1
	PUSHJ	P,FETCH
	 JRST	BPLUP
	MOVEM	T,INITL+1
	ADDI	R,1
	PUSHJ	P,FETCH
	 JRST	BPLUP
	MOVEM	T,INITL+2
	MOVEI	T,2
	ADDM	T,BCOM		;INCREMENT RETURN ADR

INITL:	0			;INIT
	0			;DEVICE
	0			;BUFFERS
	SKIPA			;FAILURE RETURN
	AOS	BCOM		;SUCCESS - SKIP RETURN
	MOVEI	T,@BCOM		;GET RETURN ADR
	JRST	IJSR4		;AND MAKE LIKE A JSR
>;IFE EDDT&1
;IPUSHJ CPUSHP IJSA IJSR IJSR2 IJSR3 IJSR4 IJSP INSRTB INSRT1 INSRT3 REMOVB REMOV1

IPUSHJ:	DPB W1,[POINT 4,CPUSHP,12]	;STORE AC FIELD INTO A PUSH
	SETZM TEM3
	MOVE W,CPUSHP		;GET A PUSH INSTR
	MOVE T,LEAV
	JRST RESTR1

CPUSHP:	PUSH

IJSA:	MOVE T,BCOM		;INTERPRET JSA
	HRL T,LEAV
	EXCH T,AC0(W1)
	JRST IJSR2

IJSR:	MOVE T,BCOM		;INTERPRET JSR
	HLL T,SAVPI
IJSR2:	MOVE R,LEAV
	PUSHJ P,DEP
	AOSA T,LEAV
IJSR3:	MOVE T,LEAV
IJSR4:	MOVSI W,(<JFCL>)
	JRST RESTORE

IJSP:	MOVE W,BCOM		;INTERPRET JSP
	HLL T,SAVPI
	MOVEM W,AC0(W1)
	JRST IJSR3

;INSERT BREAKPOINTS

↑INSRTB:MOVE S,[JSR BP1]
INSRT1:	SKIPE R,B1ADR-BP1(S)
	PUSHJ P,FETCH
	 JRST INSRT3
	MOVEM T,B1INS-BP1(S)
	MOVE T,S
	PUSHJ P,DEP
INSRT3:	ADDI S,4
	CAMG S,[JSR BPN]
	JRST INSRT1
IFN EDDT&1,<
	POPJ P,
>;IFN EDDT&1
IFE EDDT&1,<
	JRST TTYRST		;RESTORE USER'S TTY'S ACT BITS AND CHARACTERISTICS
>;IFE EDDT&1

;REMOVE BREAKPOINTS

↑REMOVB:
IFN P2SYS,<
	MOVE T,P2NUM			;SAVE INITIAL P2NUM
	MOVEM T,SP2NUM			; SO WE'LL KNOW IF SYS WAS UP LATER ON
>;IFN P2SYS
	MOVEI S,BNADR
REMOV1:	MOVE T,B1INS-B1ADR(S)
	SKIPE R,(S)
	PUSHJ P,DEP
	SUBI S,4
	CAIL S,B1ADR
	JRST REMOV1
IFN EDDT&1,<
	JRST TTYRET
>;IFN EDDT&1
IFE EDDT&1,<
	JRST TTYSAV		;SAVE USER ACTIVATION TABLE AND LINE CHARACTERISTICS
>;IFE EDDT&1

;IN EXEC MODE, SAVE UP TTY STATUS
;IN USER MODE, DONE BY SAVE
;BPS BPS1 BPS2 BPS3 BPS4 BPS5 AUTOP

	SUBTTL	DDT - PROCESS BREAKPOINT COMMANDS

;ALL $B COMMANDS OF FORM <A>$<N>B

BPS:	TLZE F,QF
	JRST BPS1
	TRZE F,Q2F
	JRST BPS2
	MOVE T,[XWD B1ADR,B1ADR+1]
	SETZM  B1ADR
	BLT T,AUTOPI	;CLEAR OUT ALL BREAKPOINTS AND AUTO PROCEED REGESTER
	JRST RET

BPS1:	TRZN F,Q2F
	JRST BPS3
	MOVE R,T
	TRO F,2
BPS2:	MOVE T,WRD2
	CAIL T,1
	CAILE T,NBP
	JRST ERR
	IMULI T,4
	ADDI T,B1ADR-4
	TRZN F,ITF
	JRST MASK2
	EXCH R,T
	JRST BPS5

BPS3:	MOVEI R,B1ADR		;PROCESS THE A$B
BPS4:	HRRZ W,(R)
;;;	SKIPE (R)
	CAIN W,(T)
	JRST BPS5
	ADDI R,4
	CAIG R,BNADR
	JRST BPS4
;bkpt address not already in bkpt table
;now look for available bkpt slot
	MOVEI R,B1ADR
BPS4A:	SKIPN (R)
	JRST BPS5		;empty slot, use it
	ADDI R,4		;next slot
	CAIG R,BNADR
	JRST BPS4A		;loop
	JRST ERR		;can't have more bkpts

BPS5:	MOVEM T,(R)		;store new bkpt datum
	SETZM 1(R)
	SETZM 2(R)
	SETZM 3(R)
IFN EDDT&20,<
	MOVE	S,[CAIA]
	MOVEM	S,B1SKP-B1ADR(R)	;MAKE BREAK POINTS CONDITIONAL!
>
AUTOP:	SUBI R,B1ADR		;AUTO PROCEED SETUP
	IDIVI R,4
	MOVEI S,1
	LSH S,(R)
	ANDCAM S,AUTOPI
	TLNE F,CCF
	IORM S,AUTOPI
	POPJ P,

;DEPRS DEP XDEP DEP0 DPTHIX DPTHIC DPTEXL UDTDPE UDTDP0 UDTDP1 UDTDP2 UDEPLZ DEP1 FETCH XFETCH FETCH0 NOEXPE NOEXP2 EXPCHK EXPCH2 EXPCDD EXPEXM EXMHIX EXPXIT EXMHIC EXPEXL JEXM JEXM1 FIRARG ULIM ULIM1

	SUBTTL	DDT - FETCH AND DEPOSIT INTO MEMORY


DEPRS:	MOVEM	T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE	R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE	F,ROF		;WAS A REGISTER OPEN (SKIP IF NOT)
	TLNN	F,QF		;AND A QUANTITY TYPED?
	POPJ	P,		;NO REGISTER OPEN, OR NO QUANTITY TYPED.
DEP:
IFE UEDDTS,<	TRNN	R,777760	;IS ADDRESS ABOVE ACS?
		JRST	DEP1		;CHANGE THE ACS WE HAVE SAVED.
>;IFE UEDDTS

	PUSH	P,R
	PUSH	P,T
	HRRZ	R,R
	AOS	-2(P)
	PUSHJ	P,XDEP
	SOS	-2(P)
	POP	P,T
	POP	P,R
	POPJ	P,

XDEP:
IFE UEDDTS,<				;NOT UEDDT
	IFE EDDT&1,<			;USER DDT
		HRRZ	W,JOBREL	;CHECK FOR LOWER SEGMENT ADDRESS
		CAIL	W,(R)
		JRST	DEP0		;ADDRESS OK.
		ADDI	W,1		;FIRST ADDRESS ABOVE LOWER MAY BE IN UPPER
		CAIGE	W,400000	;COMPUTE FIRST ADDRESS IN UPPER.
		MOVEI	W,400000	;
		CAILE	W,(R)		;IS DESIRED ADDRESS ABOVE START OF UPPER?
		POPJ	P,		;ILLEGAL ADDRESS ABOVE LOWER, NOT IN UPPER
		HRRZ	W,JOBHRL	;GET LAST ADDRESS IN UPPER
		CAIL	W,(R)		;DEPOSIT IN BOUNDS?
DEP0:		MOVEM	T,0(R)		;STUFF IT.
		POPJ	P,
	>;IFE EDDT&1

	IFN EDDT&1,<			;EXEC DDT
	IFN FTDMAP!FTF2,<		;MAPPING EXEC DDT
					;F2 needs SWPDEP regardless of FTDMAP
		PUSHJ	P,SWPDEP	;SPECIAL MAPPING DEPOSIT ROUTINE.
		 POPJ	P,		;DEPOSIT DONE, OR LOST!
	>;IFN FTDMAP!FTF2
		HRRZ	W,JOBREL	;USE SYSTEM JOBREL FOR EXEC DDT
		CAIL	W,(R)		;DEPOSIT IN BOUNDS?
		MOVEM	T,0(R)		;STUFF IT.
		POPJ	P,
	>;IFN EDDT&1
>;IFE UEDDTS

IFN UEDDTS,<
	SKIPE	EXJOBN		;EX-DEP IN JOB??
	POPJ	P,		;YES, LOSE
	CAMG	R,MEMSIZ	;ADDRESS IN BOUNDS?
	SKIPN	SPCFLG		;YES. HAS PROGRAM BEEN REENTERED?
	JRST	UDEPLZ		;NO. LOSE.
	MOVEM	T,SPCWRD#	;SAVE DATA FOR SPACEWAR
	MOVEM	R,SPCADR#	;SAVE ADDRESS FOR SPACEWAR
	SKIPN MAINTM		;DON'T LOG CHANGES IF THE SYSTEM IS DOWN
	PUSHJ	P,LOGIT		;LOG INTO UEDDT.LOG
	GETPR2	T,		;GET OLD VALUE OF SECOND PROT/RELOC REGISTER
	PUSH	P,T		;SAVE IT
	MOVE	R,SPCADR	;GET ADDRESS WE'RE STORING INTO
	SKIPN	EXMMAP		;SKIP IF EXAMINE/DEPOSIT VIA EXPGT.
	JRST	UDTDP1		;EX/DEP IN PHYSICAL CORE
	LDB	T,[POINT 9,R,26]	;GET THE PAGE NUMBER OF REQUEST
	SKIPL	EXMMAP
	JRST	DPTHIC			;DEPOSIT IN HIGH PHYSICAL CORE.
	PUSHJ P,EXPCHK		;GET EXPGT ENTRY FOR THIS ADDR
	JUMPE T,UDTDPE		;JUMP IF NO EXPGT ENTRY FOR IT.
DPTHIX:	HRRZ	T,T
	LSH	T,5			;MOVE PAGE NUMBER OVER FOR GETHI
	IOR	T,[1,,20]		;1 PAGE, WRITEABLE.
	GETHI	T,			;ATTACH ONE PAGE AS HIGH-SEG
	 JRST	DPTEXL			;LOSE?
	ANDI	R,777			;LEAVE LOW BITS
	MOVE	T,SPCWRD		;GET THE WORD.
	MOVEM	T,400000(R)		;STUFF.
	JRST	UDTDP2			;AND EXIT

DPTHIC:	ADD	T,EXMMAP		;HERE IF EXMMAP IS POSITIVE.  ADD AS OFFSET
	JRST	DPTHIX

DPTEXL:	OUTSTR	[ASCIZ/GETHI failed for deposit
/]
	JRST	UDTDP2

UDTDPE:	OUTSTR [ASCIZ/ (No EXPGT entry; deposit not done.) /]
	JRST UDTDP2

UDTDP0:	HRRZ	T,R
	CAMLE	T,MEMSIZ
	JRST UDTDP2
	PUSHJ	P,PRSET
UDTDP1:	MOVEI	T,@PROFF
	CAMLE	T,PRMAX
	JRST	UDTDP0
	GETPR2	R,
	TLZ	R,1		;SET WRITEABLE
	SETPR2	R,
	 JFCL
	MOVE	R,SPCWRD	;GET THE DATA TO STORE.
	MOVEM	R,400000(T)
UDTDP2:	POP	P,T		;RESTORE OLD SETPR2
	SETPR2	T,
	 JFCL
	POPJ	P,

UDEPLZ:	OUTSTR	[ASCIZ/DEPOSIT NOT ENABLED!
/]
	POPJ	P,

>;IFN UEDDTS

DEP1:	MOVEM	T,AC0(R)
	POPJ	P,

FETCH:	PUSH	P,R		;SOME CALLERS WANT COUNTS IN THE LEFT
	AOS	-1(P)		;AND SOME ROUTINES BELOW WANT ONLY 18 BITS
	HRRZ	R,R
	PUSHJ	P,XFETCH
	SOS	-1(P)
	POP	P,R
	POPJ	P,

XFETCH:
IFE UEDDTS,<
    IFE EDDT&1,<
		HRRZ	T,JOBREL	;CHECK FOR LOWER SEGMENT ADDRESS
		CAIL	T,(R)
		JRST	FETCH0		;ADDRESS OK.
		ADDI	T,1		;FIRST ADDRESS ABOVE LOWER MAY BE IN UPPER
		CAIGE	T,400000	;COMPUTE FIRST ADDRESS IN UPPER.
		MOVEI	T,400000	;
		CAILE	T,(R)		;IS DESIRED ADDRESS ABOVE START OF UPPER?
		POPJ	P,		;ILLEGAL ADDRESS ABOVE LOWER, NOT IN UPPER
		HRRZ	T,JOBHRL	;GET LAST ADDRESS IN UPPER
		CAIGE	T,(R)		;DEPOSIT IN BOUNDS?
		POPJ	P,
FETCH0:		TRNN	R,777760	;AC REF?
		SKIPA	T,AC0(R)
		MOVE	T,0(R)		;GET IT.
		JRST	CPOPJ1
    >;IFE EDDT&1

    IFN EDDT&1,<
	IFN FTDMAP!FTF2,<		;F2 needs SWPEXM regardless of FTDMAP
		PUSHJ P,SWPEXM		;Maybe do examine, check EXMMAP
		 JRST CPOPJ1		;EXAMINE DONE, OR LOST
		 JFCL			;Map is off, or address is an AC
	>;IFN FTDMAP!FTF2
		HRRZ	T,JOBREL
		CAIGE	T,(R)
		POPJ	P,			;OUT OF BOUNDS
		TRNN	R,777760
		SKIPA	T,AC0(R)		;MAKE AC REFERENCE
		MOVE	T,(R)			;REFERENCE REAL CORE
		JRST	CPOPJ1
    >;IFN EDDT&1
>;IFE UEDDTS

IFN UEDDTS,<
	SKIPE	EXJOBN			;EXAMINING JOB?
	JRST	JEXM			;YES, DO IT!
	SKIPE	EXMMAP			;EXAMINE USING EXPGT?
	JRST	EXPEXM			;YES.
NOEXPE:	MOVEI	T,@PROFF
	CAMLE	T,PRMAX
	JRST	[HRRZ T,R
		CAMLE T,MEMSIZ
		POPJ P,
		PUSHJ P,PRSET
		JRST XFETCH]
	MOVE T,400000(T)
	JRST CPOPJ1

NOEXP2:	OUTSTR [ASCIZ/ (No EXPGT entry; examining physical core.) /]
	JRST NOEXPE

EXPCHK:	SKIPE T,EXPGT(T)	;DO WE ALREADY HAVE THIS EXPGT ENTRY?
	POPJ P,			;YES, RETURN IT
	MOVNI T,1
	SKIPE CDDTXC		;Skip if DDT isn't mapped out.
	CAMN T,EXMMAP		;Skip unless want to examine mapped EDDT
	CAIA
	JRST EXPCDD		;Find mapped DDTs page table in EDDT!
	LDB T,[POINT 9,R,26]	;NO, GET PAGE NUMBER BACK
EXPCH2:	PUSH P,R
	MOVEI R,(T)		;SAVE PAGE NUMBER
NOKL10,<
	CAIL T,600		;PAGE IN LAST PART OF MAP?
	ADD T,EXPPSB		;YES, ADJUST ADDRESS TO WITHIN PSB
>;NOKL10
	ADD T,EXPGTA		;ADD BASE OF EXPGT
	PEEK T,			;GET EXPGT ENTRY
	CAMGE R,SYSPAG		;IS THIS IN UNCHANGING PAGE?
	MOVEM T,EXPGT(R)	;YES, REMEMBER EXPGT ENTRY
	POP P,R
	POPJ P,

;Here if UEDDT's EXMMAP is -2 (or less).  See real DDT, even if mapped out.
EXPCDD:	LDB T,[POINT 9,R,26]	;NO, GET PAGE NUMBER BACK
	CAML T,SYSPAG		;SKIP IF THIS ADDRESS BELOW DDT AND SYMBOLS
	CAML T,DDTEPG		;SKIP IF THIS ADDRESS BEFORE END OF DDT/SYMBOLS
	JRST EXPCH2		;NOT IN DDT/SYMBOLS
	ADD T,ADDTMAP		;ADD BASE OF SAVED DDT PART OF EXPGT
	SUB T,SYSPAG		;DDTMAP STARTS WITH PAGE AT SYSPAG
	PEEK T,			;GET EXPGT ENTRY FROM DDTMAP IN UNMAPPED PART OF DDT
	POPJ P,

EXPEXM:	LDB	T,[POINT 9,R,26]	;GET THE PAGE NUMBER OF REQUEST
	SKIPL	EXMMAP			;SKIP IF EXAMINE VIA EXPGT.
	JRST	EXMHIC			;NO - EXAMINE HIGH PHYSICAL CORE.
	PUSHJ P,EXPCHK		;FIND EXPGT ENTRY
	JUMPE T,NOEXP2		;JUMP IF NO EXPGT ENTRY FOR IT.
EXMHIX:	PUSH	P,T
	GETPR2	T,
	EXCH	T,(P)			;OLD PR ON STACK. 
	HRRZ	T,T
	LSH	T,5			;MOVE PAGE NUMBER OVER FOR GETHI
	HRLI	T,1			;NUMBER OF PAGES
	GETHI	T,			;ATTACH ONE PAGE AS HIGH-SEG
	 JRST	EXPEXL			;LOSE?
	ANDI	R,777			;LEAVE LOW BITS
	MOVE	T,400000(R)		;FETCH DATA
EXPXIT:	EXCH	T,(P)
	SETPR2	T,
	 HALT	.
	POP	P,T
	JRST	CPOPJ1

EXMHIC:	ADD	T,EXMMAP		;HERE FOR EXAMINE HIGH PHYSICAL CORE.
	JRST	EXMHIX

EXPEXL:	OUTSTR	[ASCIZ/GETHI failed?
/]
	MOVEI	T,0
	JRST	EXPXIT


JEXM:	TRNE R,777760		;AC?
	JRST JEXM1
	MOVE T,[-1,,JOBPC↑]	;GET PC WORD
	MOVEM T,EXJOBN+1
	MOVEI T,EXJOBN
	JOBRD T,
	POPJ P,			;LOSE
	MOVE T,EXJWRD		;GET LOSERS PC
	TLNE T,10000		;USRMOD?
	ADDI R,20		;YES, AC'S ARE REALLY HERE
JEXM1:	HRROM R,EXJOBN+1	;SET ADDRESS AND WORDCOUNT OF 1
	MOVEI T,EXJOBN
	JOBRD T,		;EXAMINE LOSER CORE
	POPJ P,			;LOSE
	MOVE T,EXJWRD
	JRST CPOPJ1
>;IFN UEDDTS

FIRARG:	MOVEM T,DEFV
	TLO F,FAF
	JRST ULIM1
ULIM:	TLO F,SAF
	HRRZM T,ULIMIT
ULIM1:	TLNN F,QF
	JRST ERR
	JRST LIS0
;CONSYM LFPIN RFPIN PIN PIN1 PIN1A PI3A PI4 PI7 PI8 PI8A

	SUBTTL	DDT - PRINT INSTRUCTION.  PIN,LFPIN,RFPIN,CONSYM
CONSYM:	MOVEM T,LWT
	TRNN F,LF1
	JRST (SCH)		;PIN OR FTOC
	TRNE F,CF1
	JRST  FTOC

LFPIN:	JFCL
RFPIN:	JFCL			;FOR L AND V MODES (JUST SO THEY ARE NOT PIN)
↑PIN:	TLC	T,700000	;PRINT INSTRUCTION
	TLCN	T,700000
	JRST	INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND	T,[XWD 777000,0]
	JUMPE	T,HLFW
	PUSHJ	P,OPTYPE
PIN1:	MOVSI	T,777000
	AND 	T,LWT
	TRNN	F,ITF		;HAS INSTRUCTION BEEN TYPED?
	PUSHJ	P,LOOK		;NO, LOOK IN SYMBOL TABLE
	JRST	PIN1A		;WIN.
	JRST	HLFW		;INEXACT MATCH, OUTPUT AS HALFWORDS
	JRST	HLFW		;NO MATCH AT ALL

PIN1A:	TRO	F,NAF		;INSTRUCTION TYPED, ALLOW NEG ADDRESSES
	PUSHJ	P,TSPC
	LDB	T,[XWD 270400,LWT]	;GET AC FIELD
	JUMPE	T,PI4
	PUSHJ	P,PAD
PI3A:	MOVEI	W1,","
	PUSHJ	P,TEXT
IFE EDDT&1!UEDDTS,<INOU1:>
PI4:	MOVE W1,LWT
	MOVEI T,"@"
	TLNE W1,20		;CHECK FOR INDIRECT BIT
	PUSHJ P,TOUT
	HRRZ T,LWT
	LDB W,[XWD 331100,LWT]	;INSTRUCTION BITS
	CAIL W,240
	CAILE W,247
	JRST PI8
	TLNN W1,20	;INDIRECT
	CAIN W,<JFFO>⊗-33
	JRST PI8	;AND JFFO GET SYMBOLIC
	PUSHJ P,PADS3A
PI7:	TRZ F,NAF	
	LDB R,[XWD 220400,LWT]	;INDEX REGISTER CHECK
	JUMPE R,CPOPJ		;EXIT
	MOVEI T,"("
	PUSHJ P,TOUT
	MOVE T,R
	PUSHJ P,PAD
	MOVEI T,")"
	JRST TOUT		;EXIT

PI8:	CAIE	SCH,LFPIN	;IN ONE OF THE FLAG MODES?
	CAIN	SCH,RFPIN	;?
	JRST	RLFFLG		;YES.
PI8A:	PUSHJ	P,PAD
	JRST	PI7

;HLFW HLFW1 PAD PADSO PADS1A PADS3 PADS3A PADS3B PADS3C INOUT CKIOT

;	PRINT HALFWORDS, PRINT ADDRESS

HLFW:	HLRZ	T,LWT		;PRINT AS HALF WORDS
	JUMPE	T,HLFW1
	TRO	F,NAF		;ALLOW NEGATIVE
	PUSHJ	P,PAD
	MOVSI	W1,(<ASCII /,,/>)
	PUSHJ	P,TEXT2
HLFW1:	HRRZ	T,LWT

;PRINT ADDRESS
PAD:	JRST	(AR)		;PADSO OR PAD1
↑PADSO:	JUMPE	T,TOC2+1
	PUSHJ	P,LOOK
	POPJ	P,		;WIN.
	SKIPA	W2,1(W1)	;INEXACT MATCH
	JRST	PADS3		;NO MATCH AT ALL
	CAMGE	T,MXINC
	CAIGE	W2,60
	JRST	PADS3
	MOVEM	T,TEMDDT
	JUMPGE	F,TOC		;EXIT
	PUSHJ	P,SPT0
	MOVEI	T,"+"
PADS1A:	PUSHJ	P,TOUT
	HRRZ	T,TEMDDT
	JRST	TOC		;EXIT

PADS3:	MOVE	T,TEMDDT
PADS3A:	TRNE	F,NAF
	CAIGE	T,776000
	JRST	TOC
PADS3B:	CAMN	T,[-1,,0]
	JRST	PADS3C		;SPECIAL CASE THAT PRINTS WRONG
	MOVNM	T,TEMDDT
	MOVEI	T,"-"
	JRST	PADS1A

PADS3C:	MOVEI	T,"-"
	PUSHJ	P,TOUT
	MOVSI	T,1
	JRST	TOC

INOUT:	TLC	T,-1		;IS IT PERHAPS NEGATIVE
	TLCN	T,-1
	JRST	PADS3B		;LEFT HALF IS -1
	TLC	T,777000
	TLCN	T,777000	;THIS IS ALMOST AS GOOD
	JRST	HLFW		;PRINT AS A HALF WORD

IFE IOTLG,<	JRST	PIN1>	;PRINT AS INSTRUCTION

IFG IOTLG,<			;COMPILE ONLY IF THERE ARE DEVICES KNOWN
	MOVSI	R,-IOTLG	;GET LENGTH OF IOT DEVICE TABLE
	LDB	W2,[POINT 7,T,9]	;GET DEVICE NUMBER
	LSH	W2,2		;TIMES 4
CKIOT:	CAME	W2,IOTBL(R)	;THERE?
	AOBJN	R,CKIOT
	JUMPGE	R,PIN1		;PRINT AS AN INSTRUCTION
	PUSH	P,R		;SAVE INDEX TO IOTBL
	LDB	R,[POINT 3,T,12]
	DPB	R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	PUSHJ	P,OPTYPE	;TYPE OPCODE
	PUSHJ	P,TSPC		;TYPE SPACE
	POP	P,R		;GET INDEX TO IOTB2
	MOVEI	W1,IOTB2(R)	;GET POINTER TO RADIX50 OF THE DEVICE NAME
	PUSHJ	P,SPT1W		;PRINT RADIX50 OF 0(W1) WITHOUT TYPE BITS
	JRST	PI3A

>;IFG IOTLG
;MASK MASK2 MASK1 EFFEC WORD NWORD SEAR1A SEAR1 SEAR2 SEAR2A SEAR2C SEAR2B SERLPC SEAR3 SEAR4 EFFEC0 EFFECR EFFECA EFFEC1 EFFEC2 EFFEC3

	SUBTTL	DDT - $M, $N, $W, $E COMMANDS

MASK:	TLNE F,QF
	JRST MASK1
	MOVEI T,MSK
MASK2:	MOVEI W,1
	MOVEM W,FRASE1
	JRST QUAN1

MASK1:	MOVEM T,MSK
	JRST RET

EFFEC:	TLO F,LTF
	HRRZ T,T
WORD:	MOVEI R,322000-326000	;JUMPE-JUMPN
NWORD:	ADDI R,326000+40*T	;JUMPN T,
	HRLM R,SEAR2
	TLZN F,QF
	JRST ERR
	SETCAM T,WRD
	MOVSI T,FRASE-DENDDT-1		;PREVENT TYPE OUT OF DDT PARTS
	SETCMM FRASE(T)
	AOBJN T,.-1
	MOVE T,ULIMIT
	TLNE F,SAF
	TLO F,QF
	PUSHJ	P,SETUP1		;RETURNS R=-WC,,MA FOR SEARCH
	PUSHJ	P,CRF
SEAR1A:	MOVEI	T,1000			;LOOP COUNT
	MOVEM	T,SERLPC
SEAR1:	PUSHJ	P,FETCH	
	 JRST	SEAR2A
	TLNE F,LTF	;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST EFFEC0
	EQV T,WRD
	AND T,MSK
SEAR2:	JUMPE T,SEAR3		;OR JUMPN T, (INSTR IS CLOBBERED ABOVE)
SEAR2A:	SOSLE	SERLPC		;ONLY LISTEN TO TTY EVERY 1000 TIMES
	JRST	SEAR2C
	PUSHJ	P,LISTEN	;QUIT ON TELETYPE INPUT
	 CAIA
	JRST	SEAR2B		;A KEY WAS STRUCK.  QUIT NOW.
	MOVEI	T,2000
	MOVEM	T,SERLPC	;RESET LOOP COUNT.
SEAR2C:	CAMN R,[-1]	;LOSING AOBJN WILL SCREW THIS UP!!!!
	JRST SEAR2B	;END
	AOBJN R,SEAR1
	TLNE R,777777	;DID IT JUST GET TO 0 OR IS IT LARGER THAN 128K?
	JRST SEAR1	;BIG SEARCH
SEAR2B:	SETCMM LWT
	JRST DD1

SERLPC:	0

SEAR3:	PUSHJ P,FETCH
	 JRST ERR
	TLZ F,STF	;TURN OFF SUPRESS OUTPUT
	MOVEM R,TEM2
	MOVEM R,T
	PUSHJ P,LI1
	PUSHJ P,CRF
	SETCMM LWT
	SETCMM TEMDDT
	SETZM	SERLPC	;CLEAR LOOP COUNT.  LISTEN TO TTY AGAIN.
SEAR4:	MOVE R,TEM2
	JRST  SEAR2A

EFFEC0:	TLNE F,CCF	;DOUBLE ALTMODE?
	JRST EFFECR	;YES, NO @() CHECK -- RPH 5-12-73
	MOVEM R,TEM2
	PUSHJ P,EFFECA
	JRST SEAR4	;LOST ON EFF ADR CALC
	MOVE R,TEM2
EFFECR:	EQV T,WRD
	ANDI T,777777
	JRST SEAR2

EFFECA:	MOVEI W,100
	MOVEM W,TEMDDT
EFFEC1:	MOVE W,T
	LDB R,[POINT 4,T,17]	;GET IR FIELD
	JUMPE R,EFFEC2
	HRRZ T,AC0(R)
	ADD T,W
EFFEC2:	HRR R,T
	TLNN W,20		;INDIRECT BIT CHECK
	JRST EFFEC3
	SOSE TEMDDT
	PUSHJ P,FETCH
	 POPJ P,		;ERROR RETURN
	JRST EFFEC1

EFFEC3:	HRRZS T		;HALFWORD ONLY
	JRST CPOPJ1	;SKIP RETURN
;⊗ SETUP SETUP1 SETUP2 ZERO ZERO1 ZERO2 ZEROR

	SUBTTL	DDT - $$Z

SETUP:	TROA	F,R20F			;HERE FOR $Z ONLY
SETUP1:	TRZ	F,R20F
	TLNN	F,SAF
IFE UEDDTS,<	MOVE	T,JOBREL>
IFN UEDDTS,<	MOVE	 T,MEMSIZ>	;SYSTEM JOBREL PTR.
	HRRZ	T,T
	MOVEM	T,ULIMIT		;UPPER LIMIT
	HRRZ	R,DEFV			;R←LOWER LIMIT IF ONE WAS SUPPLIED
	TLNN	F,FAF
	MOVEI	R,0			;NO EXPLICIT LOWER LIMIT. USE ZERO
	CAML	R,ULIMIT
	JRST	ERR
IFE UEDDTS,<
IFE EDDT&1,<	;user DDT
	CAMG T,JOBREL		;upper limit in range?
	JRST SETUP2		;yes
	HRRZ W,JOBHRL		;GET LAST ADDRESS IN UPPER, or zero
	CAIG T,(W)		;no, upper limit within upper segment?
	CAIGE R,400000		;yes, skip if lower limit is in upper
	JRST ERR		;upper limit above upper seg, or limits in diff segs
>;IFE EDDT&1
IFN EDDT&1,<	;exec DDT
	CAMLE	T,JOBREL
	JRST	ERR			;upper limit is out of range
>;IFN EDDT&1
>;IFE UEDDTS
IFN UEDDTS,<	;UEDDT
	CAMLE	T,MEMSIZ
	JRST	ERR			;upper limit is out of range
>;IFN UEDDTS
SETUP2:	MOVEM	R,DEFV
	MOVEI	W,-1(R)			;RPH 3-17-72
	SUB	W,ULIMIT
	HRLM	W,R			;R←-WC,,FIRST ADDRESS.
	POPJ	P,

ZERO:	TLNN	F,CCF			;$$Z ?
	JRST	ERR			;NO ONE ALTMODE ISN'T ENOUGH.
	MOVE	W2,T			;VALUE TO SPREAD.
	TLNN	F,QF
	MOVEI	W2,0			;IF NONE, SPREAD ZERO
	HRRZ	T,ULIMIT
	PUSHJ	P,SETUP			;RETURNS R=-WC,,MA
ZERO1:	TRNE	R,777760		;STORE IN AC?
	JRST	ZERO2			;NO.
	MOVEM	W2,AC0(R)		;STORE IN OUR VERSION OF USER'S ACS.
	AOBJN	R,ZERO1			;LOOP WHILE IN AC
	JRST	DD1

ZERO2:	HRRZ	R,R			;ADDRESS OF NEXT WORD TO STORE INTO
	CAIGE	R,ZLOW
	MOVEI	R,ZLOW			;DON'T ZERO 20-ZLOW
	HRRZ	S,T			;UPPER LIMIT
	CAILE	S,DDTBEG-1
	MOVEI	S,DDTBEG-1
	CAML	S,R			;DON'T DO ANYTHING IF UPPER LESS THAN LOWER
	JSP	W,ZEROR			;S=HIGH, R=LOW.
	HRRZ	R,R
	CAIGE	R,DDTEND  		;DON'T ZERO OUT
	MOVEI	R,DDTEND  		;DDT
	HRRZ	S,T
	CAML	S,R
	JSP	W,ZEROR
	JRST	DD1

ZEROR:	HRL	R,R
	MOVEM	W2,(R)
	ADDI	R,1
	BLT	R,(S)
	JRST	(W)
;TOCC FTOC TOC TOCS TOCA TOC1 TOC3 TOC2 TOC4 TOC5 TOC6

	SUBTTL	DDT - OUTPUT ROUTINES  TOCC, FTOC, TOC, TOCA

TOCC:	TRO	F,EQF		;SET TO REAL NUMERIC MODE
FTOC:
TOC:	HRRZ	W1,ODF
	CAIN	W1,12
	JRST	TOC4
	TRZE	F,EQF		;REAL NUMERIC MODE?
	JRST	TOCA		;YES.
	CAIN	W1,10
	TLNN	T,-1		;IF RADIX NOT 10, OR LEFT HALF EMPTY
	JRST	TOCA		;PRINT
	HRRM	T,TOCS		;SAVE RIGHT HALF
	HLRZS	T
	PUSHJ	P,TOCA		;PRINT LEFT HALF
	MOVSI	W1,(<ASCII /,,/>)
	PUSHJ	P,TEXT2
TOCS:	MOVEI	T,0		;** RIGHT HALF MODIFIED
TOCA:	LSHC	T,-43
	LSH	W1,-1		;W1=T+1
TOC1:	DIVI	T,(ODF)
	HRLM	W1,0(P)
TOC3:	JUMPE	T,TOC2
	PUSHJ	P,TOCA
TOC2:	HLRZ	T,0(P)
	ADDI	T,"0"
	JRST	TOUT		;DOES POPJ TO TOC2 OR EXIT

TOC4:	MOVM W1,T
	JUMPGE T,TOC5
	MOVEI T,"-"
	PUSHJ P,TOUT
TOC5:	MOVEI T,0
	PUSHJ P,TOC1
TOC6:	MOVEI T,"."
	JRST TOUT
;TFLOT TFLOT1 FP1 FP1A FP3 FP3A FP4 FP4A FP4B

;FLOATING POINT OUTPUT

TFLOT:	MOVE A,T
	JUMPG A, TFLOT1
	JUMPE A,FP1A
	MOVNS A
	MOVEI T,"-"
	PUSHJ P,TOUT
	TLZE A,400000
	JRST FP1A
TFLOT1:	
	TLNN A, 400
	JRST FP7A	;UNNORMALIZED FLOATING PRINT AS DECIMAL

FP1:	MOVEI B,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4
FP1A:	MOVEI C,0

FP3:	MULI A,400
	ASHC B,-243(A)
	MOVE A,B
	SETZM TEM1
	PUSHJ P,FP7
	PUSHJ P,TOC6		;PRINT DECIMAL POINT
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:	MOVE T,W1
	MULI T,12
	PUSHJ P,FP7B
	SKIPE W1
	AOJL A,FP3A
	POPJ P,

FP4:	MOVNI C,6
	MOVEI W2,0
FP4A:	ASH W2,1
	XCT FCP(B)
	JRST FP4B
	FMPR A,@FCP+1(B)
	IORI W2,1
FP4B:	AOJN C,FP4A
	PUSH P,FSGN(B)
	PUSHJ P,FP3
	POP P,W1
	MOVE A,W2
	PUSHJ P,TEXT
;FP7 FP7A1 FP7B FP7A FP7A2 FT8 FT FT01 FCP FSGN TEXTT TEXT TEXT2 TEXTT9 TEXTT0

FP7:	JUMPE A,FP7A2
	IDIVI A,12
	AOS TEM1
	HRLM B,(P)
	JUMPE A,FP7A1
	PUSHJ P,FP7
FP7A1:	HLRZ T,(P)
FP7B:	ADDI T,260
	JRST TOUT
FP7A:	PUSHJ P,FP7
	MOVEI T,"."
	JRST TOUT	;PRINT WITH A .
FP7A2:	MOVEI T,"0"
	JRST TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0←←FT01+1

FCP:	CAMLE A, FT0(C)
	CAMGE A, FT(C)
	XWD C,FT0

FSGN:	ASCII .E-.
	ASCII .E+.

TEXTT:	MOVE W1,T
TEXT:	TLNN W1,774000		;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH W1,35		;OUTPUT ONE RIGHT JUST. CHR.
TEXT2:	MOVEI T,0
	LSHC T,7
	CAILE T,04		;EOT
	PUSHJ P,TOUT
	JUMPN W1,TEXT2
	POPJ P,

;RPH 7-29-72  TYPE OUT TTY INPUT BUFFERS
TEXTT9:	MOVE W1,T
TEXTT0:	MOVEI T,0
	LSHC T,11
	PUSH P,T
	LSH T,-7
	PUSH P,T
	SKIPA T,["↑"]
	PUSHJ P,TOUT
	SOSL (P)
	JRST .-2
	POP P,(P)
	POP P,T
	ANDI T,177
	SKIPE T
	PUSHJ P,TOUT
	JUMPN W1,TEXTT0
	POPJ P,

;REG 12-80 Type Out PDP-11, VAX, Press Text formats.  8-bit bytes left adjusted
TEXTT8:	MOVE W1,T			;The data item
TEXT81:	MOVEI T,0			;clear left register of pair
	LSHC T,10			;8 bits at a whack
	PUSH P,T			;save the character
	LSH T,-7			;keep only the high bit
	JUMPE T,TEXT82			;jump if there's no high bit
	MOVEI T,"↑"			;load T with ↑ character
	PUSHJ P,TOUT			;print ↑ if there was a high bit set.
TEXT82:	POP P,T				;the character
	ANDI T,177			;only 7-bits please
	SKIPE T
	PUSHJ P,TOUT			;print if not null
	JUMPN W1,TEXT81
	POPJ P,
;PSR PUNCH PUN2 PUN1 PBLK PBLK1 LOADER LOAD1 LOAD2 BLKEND PWRD PWRD2 FEED FEED1

	SUBTTL	EXEC DDT - PAPER TAPE MANIPULATIONS

IFE EDDT&3-3,<

;PUNCH SINGLE REGISTER  - CALLED BY $<CONTROL T>
PSR:	TLNN	F,ROF		;(NO REFS TO PSR???)
	JRST	ERR
	MOVEM	T,LWT
	PUSHJ	P,DEPRS
	HRRZM	R,DEFV		;R CONTAINS LLOCO
	MOVE	T,R
	JRST	PUN2

;PUNCH TAPE.  CALLED BY FIRST<LAST><CONTROL R>
PUNCH:	TLC	F,FAF+QF	;PUNCH CORE TO TAPE IN RANGE GIVEN
	TLCE	F,FAF+QF
	JRST	ERR		;ONE ARGUMENT MISSING
PUN2:	ADDI	T,1
	HRRZM	T,TEM1
	SUB	T,DEFV
	JUMPLE	T,ERR		;RANGE IS EMPTY

PUN1:	MOVEI	T,10
	PUSHJ	P,FEED
	HRRZ	R,DEFV
	IORI	R,37
	ADDI	R,1
	CAMLE	R,TEM1
	MOVE	R,TEM1
	EXCH	R,DEFV
	MOVE	T,R
	SUB	T,DEFV
	HRL	R,T
	JUMPGE	R,RET		;EXIT OF PUNCH

PBLK:	MOVE	T,R		;PUNCH ONE BLOCK
	SOS	W,T		;ADDRESS?
	PUSHJ	P,PWRD
PBLK1:	PUSHJ	P,FETCH
	 JRST	ERR
	ADD	W,T
	PUSHJ	P,PWRD
	AOBJN	R,PBLK1
	MOVE	T,W
	PUSHJ	P,PWRD		;CHECKSUM
	JRST	PUN1

;PUNCH A LOADER - CALLED BY $<CONTROL Q>
LOADER:	TLNE	F,QF		;THIS PUNCHES A LOADER ONTO THE TAPE
	JRST	ERR
	MOVEI	T,400
	PUSHJ	P,FEED
	MOVE	R,LOADE		;AOBJN POINTER TO LOADER
LOAD1:	MOVE	T,0(R)
	PUSHJ	P,PWRD
	AOBJN	R,LOAD1
	MOVEI	T,100
LOAD2:	PUSHJ	P,FEED
	JRST	RET

;PUNCH END BLOCK - CALLED BY ADDR$<CONTROL S>
BLKEND:	TLNN	F,QF		;PUNCH A BLOCK END ONTO TAPE
	MOVE	T,[JRST 4,DDT]	;NO ARGUMENT GIVEN
	TLO	T,254000	;SET JRST IN LEFT HALF OF ARGUMENT
	PUSH	P,T
	MOVEI	T,100
	PUSHJ	P,FEED
	POP	P,T
	PUSHJ	P,PWRD
	PUSHJ	P,PWRD		;EXTRA WORD FOR READER TO STOP ON
	MOVEI	T,500		;FEED SOME MORE
	JRST	LOAD2

PWRD:	MOVEI	W1,6		;PUNCH A WORD FROM T.  CHARACTER COUNT
PWRD2:	ROT	T,6
	CONSZ	PTPP,20
	JRST	.-1		;WAIT FOR NOT BUSY
	CONO	PTPP,50		;SET DONE AND BINARY MODE
	DATAO	PTPP,T		;SHIP A CHARACTER
	SOJG	W1,PWRD2	;LOOP THRU WORD
	POPJ	P,

FEED:	CONSZ	PTPP,20
	JRST	.-1		;WAIT FOR NOT BUSY
	CONO	PTPP,10		;SET DONE
	DATAO	PTPP,FEED1	;SEND A ZERO (ONLY 8 BITS COUNT)
	SOJN	T,FEED
FEED1:	POPJ	P,0


;LOADB BEG RD AA TBL1 TBL2 ADR LOADE

;	PAPER TAPE LOADERS

LOADB:	

IFE EDDT&10,<				;PDP-6/20-LOADER VERSION
DATAI PTRR,1
	XWD -1,-22
DATAI PTRR,2
	CONSO PTRR,10
DATAI PTRR,3
	JRST 2
MOVE 4,37
HRLI 4,710441                          ;DATAI PTRR,0(1)
DATAI PTRR,5
	AOJN 1,2
DATAI PTRR,6
	JRST -6(4)
JRST 2


MOVE 0,1
CONSO PTRR,10
JRST -21(4)
DATAI PTRR,0(1)
ROT 0,1
ADD 0,(1)
AOBJN 1,-21(4)
CONSO PTRR,10
JRST -13(4)
DATAI PTRR,1
CAME 1,0
JRST 4,-6(4)
CONSO PTRR,10
JRST -6(4)
DATAI PTRR,1
JUMPL 1,-22(4)
CONO PTRR,0
JRST 1

>


IFN EDDT&10,<
PHASE 0				;RIM10B CHECKSUM LOADER
	XWD -16,0
BEG:	CONO PTRR,60
	HRRI AA,10
RD:	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,@TBL1-RD+1(AA)
	XCT TBL1-RD+1(AA)
	XCT TBL2-RD+1(AA)
AA:	SOJA AA,
TBL1:	CAME CKSM,ADR
	ADD CKSM,1(ADR)
	SKIPL CKSM,ADR
TBL2:	JRST 4,BEG
	AOBJN ADR,RD
ADR:	JRST BEG+1
CKSM←←ADR+1

DEPHASE
>
LOADE:	XWD LOADB-.,LOADB
;VERIFY CORE CORE1 CORE2 VER2 VER3 RUNEND GETW GETW1 BLOCKS BLOCKQ BLK1 BLK2 BLK3

;VERIFY AND CORE (LOAD TAPE INTO CORE)

;VERIFY TAPE - CALLED BY $<CONTROL V>
;LOAD TAPE INTO CORE - CALLED BY $Y

VERIFY:	TLO F,LTF
CORE:	PUSHJ P,SETUP1		;LOAD TAPES INTO CORE
	CONO PTRR,60
CORE1:	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,T
	CAME T,LOADE-1		;WAIT TO SEE JRST 1
	JRST CORE1
	PUSHJ P,CRF
	PUSHJ P,BLOCKQ

CORE2:	PUSHJ P,GETW
	CAML R,DEFV
	CAML R,ULIMIT
	JRST VER3		;OUTSIDE OF LIMITS
	TLNE F,LTF		;VERIFY OR YANK?
	JRST VER2		;VERIFY
	PUSHJ P,DEP		;STUFF IN CORE
	JRST VER3

VER2:	MOVEM T,TEM2		;STORE TAPE WORD IN TEMP CELL
	PUSHJ P,FETCH		;GET WORD FROM CORE
	 JRST ERR
	MOVEM T,TEM3
	XOR T,TEM2
	AND T,MSK
	JUMPE T,VER3		;VERIFY OK.
	PUSH P,S
	PUSH P,R
	HRRZ T,R
	PUSHJ P,PAD		;PRINT ADDRESS
	MOVEI T,257		;SLASH
	PUSHJ P,TOUT
	PUSHJ P,LCT
	MOVE T,TEM3		;CORE CONTENTS
	PUSHJ P,CONSYM
	PUSHJ P,LCT
	MOVE T,TEM2		;TAPE CONTENTS
	PUSHJ P,CONSYM
	PUSHJ P,CRF
	POP P,R
	POP P,S
VER3:	PUSHJ P,LISTEN		;SEE IF HE WANTS TO STOP YET
	 AOJA R,CORE2
RUNEND:	PUSHJ P,BLOCKQ		;STOP.
	JRST .-1

GETW:	JUMPL S,GETW1
	PUSHJ P,BLOCKQ
GETW1:	MOVE T,1(S)
	AOBJP S,.+1
	POPJ P,0

BLOCKS:	CONO PTRR,60		;READ DATA BLOCKS
BLOCKQ:	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,W
	JUMPL W,BLK1
	MOVEM W,STARTA
	CONO PTRR,0		;TURN OFF READER
	JRST DD1
BLK1:	MOVEM W,W1
	TLC W,777740
	TLCE W,777740
	JRST ERR		;BLOCK TOO BIG
	ADDI W,1
	HRRZM W,R
	HRRI W,BUFF-1
	MOVEM W,S
BLK2:	CONSO PTRR,10
	JRST .-1
	BLKI PTRR,W
	JRST BLK3
	ADD W1,0(W)
	JRST BLK2
BLK3:	ADD W1,0(W)
	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,W
	CAMN W,W1
	POPJ P,0
	CONO PTRR,0		;CHECKSUM ERROR
	JRST 4,BLOCKS

;R CONTAINS RIGHT HALF OF FIRST LINE
;S CONTAINS (-WC,BUFF-1)

>;END OF PAPER TAPE DDT STUFF
;TTYRET TTY1 TTYLEV TEXIN KLLEV KLSRT

	SUBTTL	DDT - TTY I/O EXEC MODE

IFN EDDT&1,<

TTYRET:	SKIPE	KLFLG		;KL10?
	JRST	KLSRT		;SETUP DTE20
IFE EDDT&100,<
	MOVEI	T,3410
TTY1:	MOVEI	W2,40000
	CONSZ	TTYY,120
	SOJG	W2,.-1
	CONI	TTYY,SAVTTY
	DATAI	TTYY,W2
	HRLM	W2,SAVTTY
	CONO	TTYY,(T)
>; IFE EDDT&100
IFN EDDT&100,<
	CONI	SIX,SAVTTY
	CONO	SIX,TCHNG!RCHNG!RCLEAR
>; IFN EDDT&100
	POPJ	P,

↑TTYLEV:
IFE P2SYS,<
IFE EDDT&21-21,<
	SKIPLE EXMMAP		;Don't try to proceed while funny mapping
	SETOM EXMMAP		;Back to normal map use
>;IFE EDDT&21-21
>;IFE P2SYS
	SKIPE	KLFLG
	JRST	KLLEV
	MOVE	T,SAVTTY
IFE EDDT&100,<
	TRZ	T,160
	TRO	T,3600
	TRNE	T,10
	TRZ	T,200
	JRST	TTY1
>; IFE EDDT&100
IFN EDDT&100,<
	ANDI	T,TENA!<7⊗TPIASH>!RENA!<7⊗RPIASH>
	CONO	SIX,TCHNG!RCHNG(T)
	POPJ	P,
>; IFN EDDT&100


TEXIN:	PUSHJ	P,TIN		;GET CHARACTER
	TRNN	T,140		;SKIP IF CHARACTER HAS ALREADY BEEN ECHOED
	JRST	TOUT		;GO ECHO CHARACTER.
	POPJ	P,


;KL10/DTE20 ROUTINES

KLLEV:
IFN FTSCTY,<
	SKIPL SCNCTY		;Skip if no alternate CTY on scanner
	SKIPN SUPCTY		;Skip if suppressing duplicate output thru DTE
	CAIA
	SKIPN SUICTY		;Skip if suppressing input thru DTE
	CAIA
	POPJ P,			;Don't touch DTE, the better to debug it
>;IFN FTSCTY
	PUSH	P,0
	MOVEI	0,4400		;PREPARE TO SET TTY MONITOR MODE.
	SKIPE	KLTMON		;SKIP IF WE WEREN'T IN MONITOR MODE BEFORE.
	PUSHJ	P,DDTEXX	;RESTORE STATE OF MONITOR MODE.
	MOVEI	0,3000		;PRINT NORMAL.
	PUSHJ	P,DDTEXX
	POP	P,0
	POPJ	P,

KLSRT:
IFN FTSCTY,<
	SKIPL SCNCTY		;Skip if no alternate CTY on scanner
	SKIPN SUPCTY		;Skip if suppressing duplicate output thru DTE
	CAIA
	SKIPN SUICTY		;Skip if suppressing input thru DTE
	CAIA
	POPJ P,			;Don't touch DTE, the better to debug it
>;IFN FTSCTY
	PUSH	P,T
	PUSH	P,0
	MOVE	T,KEPTAD
	SETZM	DTCMD(T)	;NO COMMAND TO THE 11
	SETZM	DTF11(T)
	MOVEI	0,5400
	PUSHJ	P,DDTEXX	;GET STATE OF MONITOR TTY MODE
	MOVEM	0,KLTMON	;KL10 TTY MONITOR STATE
	MOVEI	0,5000
	PUSHJ	P,DDTEXX	;CLEAR MONITOR STATE
	MOVEI	0,3001		;FORCE TTY OUTPUT
	PUSHJ	P,DDTEXX
	POP	P,0
	POP	P,T
	POPJ	P,

>;IFN EDDT&1
;GETCH GETCH2 GETCH3 TIN TIN3 TIN2 TINSTR TIN4 TOUT NOTDEL TTYLEV FINOUT SPCBRK TTYSAV SETSPC SETSP2 TTYRST TTYRS2 POUTBF LISTEN LISTEN INBFF TTYRET TEXIN

	SUBTTL	DDT - TTY I/O USER MODE

IFE EDDT&1,<
GETCH:	SKIPN ACTALL		;IF SPECIAL ACTIVATION FEATURE IS DISABLED,
	SKIPE GOTALT		;OR IF LAST CHAR WAS ALTMODE OR DIGIT AFTER ALT,
	JRST GETCH2		;THEN READ A SINGLE CHAR FROM TTY
	INCHWL T		;OTHERWISE, WE WAIT FOR A LINE TO BE TYPED
	ANDI T,177
	JUMPN T,GETCH3
	JRST GETCH		;IGNORE NULLS AND EMODE 400S

GETCH2:	INCHRW T
	ANDI T,177		;FLUSH BUCKY BITS
	JUMPE T,GETCH2		;IGNORE NULLS AND EMODE 400S
	CAIL T,"0"		;DON'T CLEAR ALTMODE FLAG IS SEEING DIGIT
	CAILE T,"9"
	HLLZS GOTALT		;WE GOT THE SINGLE CMD CHAR AFTER ALTMODE
GETCH3:	CAIN T,175
	HLLOS GOTALT
	POPJ P,

TIN:	MOVE	T,POUTBF	;GET NEXT CHARACTER ROUTINE
	CAME	T,[POINT 7,INBFF]
	PUSHJ	P,FINOUT
	SKIPE	STRING
	JRST	TINSTR		;INPUT FROM STRING BYTE POINTER
	PUSHJ P,GETCH		;GET A CHAR FROM TTY
	CAIN	T,15
	INCHRS 1(P)		;THROW AWAY THE LF THAT FOLLOWS (if any)
	 JFCL
TIN3:	CAIE	T,176
	CAIN	T,175
	MOVEI	T,33		;CHANGE TO NEW ALT MODE
	CAIN	T,177
	JRST	WRONG
	JUMPN	T,CPOPJ		;RETURN NON-NULL CHARACTER
;	MOVE	T,[POINT 7,INBFF]
;	MOVEM	T,PINBFF
;	CALL	T,[SIXBIT /DDTIN/]
TIN2:	SETZM	STRING
	JRST	TIN

TINSTR:	ILDB	T,STRING	;READ FROM STRING
	JUMPE	T,TIN2		;ALL DONE
	CAIN	T,33		;NOT THIS ONE STUPID
	MOVEI	T,"$"		;DO IS AS $
	SKIPN	OUTRTN		;ARE WE ECHOING SPECIAL?
	JRST	TIN4		;NO.  ECHO NORMALLY
	PUSHJ	P,@OUTRTN
	JRST	TIN3

TIN4:	IDPB	T,POUTBF	;DUPLEX
	JRST	TIN3		;AND EAT

TOUT:	JUMPE	T,CPOPJ		;TEXT OUTPUT
	SKIPE	OUTRTN
	JRST	@OUTRTN		;USE OUTRTN IF SET
	CAIE	T,177		;IS IT THIS GODDAMN CHAR?
	JRST	NOTDEL		;NO
	SETO	T,
	GETLIN T
	TLNE	T,664000	;WILL HE IGNORE A 177?
	POPJ	P,		;NO, SKIP IT
	MOVEI	T,177		;CHANGE BACK TO 177
NOTDEL:	IDPB	T,POUTBF
	CAIE	T,12
	POPJ	P,
TTYLEV:
FINOUT:	MOVEI	T,0
	IDPB	T,POUTBF
	MOVE	T,[POINT 7,INBFF]
;	MOVEM	T,PINBFF
	MOVEM	T,POUTBF
;	CALL	T,[SIXBIT /DDTOUT/]
	OUTSTR	INBFF
	SETZM	INBFF
	POPJ	P,

;HERE TO SAVE USER'S LINE CHARACTERISTICS AND SPECIAL ACTIVATION TABLE BEFORE
;WE CHANGE THEM TO WHAT WE NEED FOR OPERATING.
SPCBRK←←100		;SPECIAL ACTIVATION MODE BIT
TTYSAV:	SETACT [USRACT,,DDTACT]	;SAVE USER'S ACTIVATION TABLE, SET UP OURS
	SETOM USRLCH	;GET USER'S LINE CHARACTERISTICS
	GETLIN USRLCH	;SAVE THEM
	MOVE T,USRLCH	;PREPARE TO TURN ON SPECIAL ACTIVATION MODE
SETSP2:	SETZM GOTALT	;FLAG LAST CHAR SEEN WASN'T ALTMODE
	AOJE T,CPOPJ	;DON'T SET LINE CHARACTERISTICS IF DETACHED
	TLO T,SPCBRK	;TURN ON SPECIAL ACTIVATION MODE
	SETLIN T
	POPJ P,

;THIS ENTRY HANDLES DDT MONITOR COMMAND AFTER DDT,CALL,SAVE,GET SEQUENCE.
;DON'T CLOBBER THE SAVED VALUES OF THE USER'S CHARACTERISTICS AND ACT TABLE,
;BUT MAKE SURE SPECIAL ACTIVATION MODE IS ON AND OUR TABLE IS IN EFFECT.
SETSPC:	AOS (P)		;ALWAYS TAKE SKIP RETURN -- ONLY CALLED FROM RDDTA
	SETACT [DDTACT]	;SET UP DDT'S ACTIVATION TABLE
	SETO T,		;GET OUR LINE CHARACTERISTICS IN PREPARATION
	GETLIN T	; FOR ENSURING SPECIAL ACTIVATION MODE IS ON
	JRST SETSP2	;FINISH UP SETTING SPECIAL ACTIVATION MODE

;RESTORE USER'S TTY'S SPECIAL ACTIVATION TABLE AND LINE CHARACTERISTICS
TTYRST:	HRROS GOTALT	;IF TRY TO READ CHAR NOW, ACTIVATE ON ANY CHAR
	MOVE T,USRLCH	;GET USER'S SAVED LINE CHARACTERISTICS
	AOJE T,TTYRS2	;DON'T SET CHARACTERISTICS UNLESS REALLY GOT 'EM
	SETLIN T	;RESTORE USER'S LINE CHARACTERISTICS
TTYRS2:	SETACT [USRACT]	;RESTORE USER'S ACTIVATION TABLE
	POPJ P,

;PINBFF:	POINT 7,INBFF
POUTBF:	POINT 7,INBFF

IFE UEDDTS,<
LISTEN:	INCHRS T
	 POPJ P,
	ANDI T,177	;FLUSH BUCKY BITS
	JUMPE T,LISTEN	;IGNORE NULLS
	CLRBFI
	JRST CPOPJ1
>;IFE UEDDTS

IFN UEDDTS,<
LISTEN:	POPJ P,		;DON'T WASTE TIME CHECKING TTY
>;IFN UEDDTS	RPH 7-30-72


INBFF:	BLOCK 31

TTYRET:	MOVE T,[POINT 7,INBFF]
	MOVEM T,POUTBF
;	MOVEM T,PINBFF
	SETZM  INBFF
	POPJ P,


TEXIN←←TIN
>;IFE EDDT&1
;PRFLAG PRFLG1 PRFLG2 PRFLG3 GETPTR FLGSLP LFTT RFTT FLGMOD FLGOUT FLGOU1 FLGOU2 RLFFLG

	SUBTTL	DDT - FLAG MODE OUTPUT

;PRINT IN FLAG MODE
PRFLAG:	HRLI	R,-=18		;SET FOR HALF WORD
	SETZM	FLGNUM#
	SETZM	EXFLAG#		;NO ! AND NO NUMERIC PART YET
PRFLG1:	TDNN	T,W1		;IS THE BIT SET?
	JRST	PRFLG3		;NO.
	SKIPN	(R)		;DOES IT HAVE A NAME?
	JRST	PRFLG2		;NOPE. SET BIT IN FLGNUM TO PRINT AS NUMBER
	PUSH	P,T
	PUSH	P,W1
	MOVEI	T,"!"
	SKIPE	EXFLAG		;SKIP IF NOTHING'S BEEN TYPED YET
	PUSHJ	P,TOUT
	MOVE	T,(R)
	PUSHJ	P,SPT1		;TYPE RADIX50
	SETOM	EXFLAG		;WE'LL NEED AN ! BEFORE NEXT PART
	POP	P,W1
	POP	P,T
	JRST	PRFLG3

PRFLG2:	IORM	W1,FLGNUM	;SAVE BIT AS PART OF THE NUMBER
PRFLG3:	LSH	W1,-1
	AOBJN	R,PRFLG1
	SKIPN	FLGNUM		;ANY NUMERIC PART LEFT OVER?
	POPJ	P,
	PUSH	P,T
	PUSH	P,W1
	MOVEI	T,"!"
	SKIPE	EXFLAG
	PUSHJ	P,TOUT
	MOVE	T,FLGNUM
	TRNN	T,-1		;CHECK TO SEE IF LEFT HALF
	MOVSS	T
	PUSHJ	P,TOCC
	POP	P,W1
	POP	P,T
	SETOM	EXFLAG		;FLAG THAT SOMETHING'S BEEN TYPED
	POPJ	P,

;SETUP SCH AND FLGPNT FOR $J, $L AND $V COMMANDS

GETPTR:	SKIPN	R,FLGPTR
	POPJ	P,
FLGSLP:	HRRZM	R,FLGPNT#	;STORE ADDRESS OF RADIX50 TABLE OF 36 WORDS
	TRNE	F,Q2F		;NUMBER TYPED?
	SOSGE	WRD2		;YES. DECREMENT COUNT (ZERO INDEXING)
	JRST	CPOPJ1
	HLRZS	R		;GET POINTER TO NEXT
	JUMPE	R,CPOPJ		;RETURN UNHAPPY IF NO NEXT
	SKIPE	R,(R)		;ADVANCE TO NEXT
	JRST	FLGSLP		;LOOP
	POPJ	P,		;THERE WAS NO NEXT.

LFTT:	SKIPA	SCH,[LFPIN]
RFTT:	MOVEI	SCH,RFPIN
	JRST	.+2
FLGMOD:	MOVEI	SCH,FLGOUT
	PUSHJ	P,GETPTR
	SETZM	FLGPNT
	JRST	BASE1

;OUTPUT ROUTINE FOR $J MODE
FLGOUT:	SKIPN	R,FLGPNT
	JRST	HLFW		;IF NO POINTER USE HALFWORD
	MOVSI	W1,400000	;SET FOR HIGH ORDER BIT
FLGOU1:	PUSHJ	P,PRFLAG
	JUMPE	W1,FLGOU2	;JUMP IF WE'VE DONE BOTH HALVES
	SKIPN	EXFLAG		;ANYTHING DONE IN LH?
	JRST	FLGOU1		;NOPE. DO RH.
	PUSH	P,T
	MOVEI	T,","
	PUSHJ	P,TOUT
	PUSHJ	P,TOUT		;TYPE ,,
	POP	P,T
	JRST	FLGOU1

FLGOU2:	SKIPE	EXFLAG		;WAS THERE SOMETHING PRINTED
	POPJ	P,		;YES, EXIT
	MOVEI	T,"0"		;NO, PRINT A 0
	JRST	TOUT

;OUTPUT ROUTINE FOR $L AND $V MODES
RLFFLG:	SKIPN	R,FLGPNT	;SCH HAS LFPIN OR RFPIN.  CALLED FROM PI8
	JRST	PI8A		;NONE THERE
	CAIN	SCH,RFPIN
	ADDI	R,=18		;START WITH RIGHT SIDE FLAGS
	MOVEI	W1,400000
	PUSHJ	P,PRFLAG
	PUSHJ	P,FLGOU2	;PRINT ZERO IF NOTHING WAS OUTPUT
	JRST	PI7
;BITO BITT BITT2 BITTM BITTM1 BITTM2 SVBT4 SVBTS SVBTS2 SVBT3 SVBT2

	SUBTTL	DDT - BYTE OUTPUT $nO
BITO:	MOVEI	R,BITT		;PATCH FOR BYTE OUTPUT WW 12-9-66
	HRRZI	AR,TOC
	TRZN	F,Q2F
	JRST	ERR		;NEEDED TO ALT-NUMBER-O
	MOVE	T,WRD2
	MOVEM	T,SVBTS		;SAVE BYTE SIZE
	MOVEI	T,=36
	IDIV	T,WRD2
	SKIPE	T+1
	ADDI	T,1
	MOVEM	T,SVBTS2	;NUMBER OF BYTES IN WORD
	HRRZ	SCH,R
	JRST	BASE1

BITT:	MOVE	T+1,T
	SKIPN	SVBTS		;0 IS MASK CONDITION
	JRST	BITTM
	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVEM	T+1,SVBT3
BITT2:	MOVEI T,0
	MOVE T+2,SVBTS
	LSHC T,(T+2)
	MOVEM T+1,SVBT3
	CAIE AR,PADSO
	PUSHJ P,FTOC
	CAIE AR,TOC
	PUSHJ P,PIN
	SOSG SVBT2
	POPJ P,
	MOVEI T,","
	PUSHJ P,TOUT
	MOVE T+1,SVBT3
	JRST BITT2


BITTM:	MOVEI T,=36	;SET OUTPUT COUNT
	MOVEM T,SVBT3
	MOVE T+2,BMASK	;GET MASK BITS
BITTM1:	MOVEI T,0	;SET TO SHIFT WORD
	SKIPL T+2	;START WITH 1 BITS
	SETCA T+2,
BITTM2:	LSHC T,1	;NEXT BIT
	LSH T+2,1	;SHIFT MASK
	SOSLE SVBT3	;ALL BITS GONE?
	JUMPL T+2,BITTM2	;PART OF SAME FIELD
	MOVEM T+2,SVBT2	;SAVE MASK
	MOVEM T+1,SVBT4	;AND PARTIAL MASK
	CAIE AR,PADSO	;DO PROPER OUTPUT
	PUSHJ P,FTOC
	CAIE AR,TOC
	PUSHJ P,PIN
	SKIPG SVBT3	;ANY MORE?
	POPJ P,		;NO, RETURN
	MOVEI T,","	;COMMA
	PUSHJ P,TOUT
	MOVE T+1,SVBT4	;GET WORD BACK
	MOVE T+2,SVBT2	;AND MASK
	JRST BITTM1	;PRINT NEXT FIELD

SVBT4:	0
SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0	;END OF PATCH  WW 12-9-66

;BDISP DISP

	SUBTTL	DDT - CHARACTER DISPATCH TABLE

BDISP:	POINT 12,DISP(R),11
	POINT 12,DISP(R),23
	POINT 12,DISP(R),35

DEFINE D(Z1,Z2,Z3)<((Z1-DDT)⊗=24)!((Z2-DDT)⊗=12)!(Z3-DDT)>

IFN EDDT&3-3,<			;ASSEMBLE IF NOT PAPER TAPE EXEC DDT
	PUNCH←←ERR
	PSR←←ERR
	BLKEND←←ERR
	LOADER←←ERR
	VERIFY←←ERR
	CORE←←ERR>

IFE UEDDTS,<
	DARRW←←ERR>

IFE UEDDTS!<EDDT&20>,<
	JOBSET←←ERR>

IFN P2SYS,<
	JOBSET←←ERR>


DISP:	
D ERR,DARRW,ERR			;NL  ↓  α
D ERR,ERR,JOBSET		; β  ∧  ¬
D ERR,ERR,VARRW			; ε  π  λ
D TAB,LINEF,ERR			;HT LF VT
D ERR,CARR,ERR			;FF CR  ∞
D ERR,ERR,LOADER		; ∂  ⊂  ⊃   CONTROL O,P,Q
D PUNCH,BLKEND,PSR		; ∩  ∪  ∀   CONTROL R,S,T
D WRONG,VERIFY,ERR		; ∃  ⊗  ↔   CONTROL U,V,W
D ERR,ERR,ERR			; _  →  ~
D CONTROL,ERR,LTAB		; ≠  ≤  ≥
D ERR,ERR,SPACE			; ≡  ∨ SP
D SUPTYO,TEXI,ASSEM		; !  "  #
D DOLLAR,BYTI,SETBLK		; $  %  &
D DIVD,LPRN,RPRN		; '  (  )
D MULT,PLUS,ACCF		; *  +  ,
D MINUS,PERIOD,SLASH		; -  .  /
D NUM,NUM,NUM			; 0  1  2
D NUM,NUM,NUM			; 3  4  5
D NUM,NUM,NUM			; 6  7  8
D NUM,TAG,SEMIC			; 9  :  ;
D FIRARG,EQUAL,ULIM		; <  =  >
D QUESTN,INDIRECT,ABSA		; ?  @  A
D BPS,CON,SYMD			; B  C  D
D EFFEC,SFLOT,STR		; E  F  G
D HWRDS,PILOC,FLGMOD		; H  I  J
D KILL,LFTT,MASK		; K  L  M
D NWORD,BITO,PROCEED		; N  O  P
D QUAN,RELA,SYMBOL		; Q  R  S
D TEXO,UCON,RFTT		; T  U  V
D WORD,XEC,CORE			; W  X  Y
D ZERO,OCON,ICON		; Z  [  \
D OSYM,VARRW,PSYM		; ]  ↑  ←

;LOWERCASE LETTERS ARE NEVER USED BY THE TIME WE GET HERE.
	SUBTTL DDT - OP DECODER

;REG 1/14/75  It seems like 10 bit bytes are actually used below.
;		Added FxxRI and TTYUUO.

;DESCRIPTION OF OP DECODER FOR DDT:
;
;         THE ENTIRE INSTRUCTION SET FOR THE PDP-6 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-6.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;     	THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;0-37(8):	THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INSTX N+1 GIVES THE NUMBER OF BITS IN INST; P GIVES THE
;	POSITION (FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;;	C(INST) = .010 101 100(2)
;
;	THE RESULT- D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT, 41-72(8)) ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.
;41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73(8)-777(8)     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE A-73(8)RD
;	        BYTE IN THE TABLE.
;
;Macros used to assemble the table TBL:
; 1.   "P" followed by a number assembles a dispatch byte.  The first 
;      digit is the position; the second digit is the size.
; 2.   "S" assembles a stop code.
; 3.   "G" followed by a symbolic name assembles a transfer to that
;      symbolically named byte.
; 4.   "T" followed by a string of letters (terminated by a comma)
;      assembles a string of bytes, each byte being one letter.
; 5.   "L" followed by a symbolic name labels the next byte with that
;      symbolic name.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;      THE MACHINE CODE FOR JRST IS 254
;          INST    0  1  0  1  0  1  1  0  0
;      THE INTERPRETER STARTS WITH THE FIRST BYTE IN THE TABLE (63↑).
;      THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;      2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;      HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33↑.  APPLYING
;      THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;      OVER:
;          1.  MV/
;               MOV      PRINTING TEXT
;          2.  MO/
;          3.  ML/
;          4.  DV/
;          5.  SH/
;
;      H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03↑ IS FOUND SO
;      4 BYTES ARE SKIPPED OVER:
;              EXC      PRINTING TEXT
;          1.  S3/
;              BL       PRINTING TEXT
;              T        PRINTING TEXT
;          2.  .
;          3.  AO/
;          4.  AOB/
;          NEXT, THE LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;	   T: A T IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;      THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A
;      TREE SEARCH METHOD IS USED.
;TBL

BEGIN OPDEFS

DEFINE P (A)
<OUTP A&70/2+A&7-1
>
DEFINE G (A)
<OUTP A+73
>
DEFINE T (A)
<FOR Bε<A> <OUTP "B"-40
>>
DEFINE S (Q)
<OUTP 40
>
DEFINE L (A)
<IFGE CLOC+73-2000,<PRINTX OPTABLE TOO LONG>
A←←CLOC
>

;TO GET THE EFFECT OF TWO PASSES, "TABLE" IS EXPANDED ONCE TO GET THE LABEL
;DEFINITIONS WITHOUT DATA GENERATION, THEN "OUTP" IS REDEFINED AND "TABLE"
;EXPANDED ONCE MORE.

DEFINE OUTP (A)
<CLOC←←CLOC+1
>
DEFINE BYT9 (A)
<FOR B⊂(A) <B
>>

DEFINE TABLE <
BYT9 <P 63,G %UUO,G %FLO,G %HAK,G %ACCP,G %BOOLE,T H,G %HWT,T T,G %ACBM>
BYT9 <P 21,G %BD,T CON,P 11,G %OI,T S,P 01,G %Z,G %O>
BYT9 <L %BD,P 01,T BLK,G %IO,T DATA,L %IO,P 11,G %I,G %O,L %OI,P 1,G %O,G %I>
BYT9 <L %UUO,P 51,S,P 32,G %U40,G %U50,G %U60,P 21,G %U703,P 11,G %USET>
BYT9 <P 1,T LOOKU,G %P,T ENTE,G %R,L %USET,T USET,P 1,G %I,G %O>
BYT9 <L %U40,P 3,G %U47,T INI,G %T,S,T SPCWA,G %R,S,S,S,L %U47,T CALL>
BYT9 <P 1,S,G %I,L %U60,P 21,G %U603,P 1,T IN,G %BPUT,T OUT,L %BPUT>
BYT9 <P 11,T BU,L %F,T F,S,T PU,G %T,L %U50,P 3,T OPE,G %N,T TTYUU,G %O,S,S,S>
BYT9 <T RENAM,G %E,T I,G %N,T OU,G %T,L %U603,P 1,G %U6062,T STAT>
BYT9 <P 11,L %O,T O,S,L %Z,T Z,S,L %U6062,P 11,T S,G %U62,T G,L %U62>
BYT9 <T ETST,G %S,L %U703,P 2,T CLOS,G %E,T RELEA,G %S,T MTAP,G %E>
BYT9 <T UGET,G %F>

BYT9 <L %FLO,P 51,G %BYTE,T F,P 32,T AD,G %A,T SB,G %A,T MP,G %A,T DV>
BYT9 <L %A,P 21,G %LMB,T R,G %IMB,L %LMB,P 2,S,L %L,T L,S,L %M,T M,S,L %B>
BYT9 <L %B,T B,S,L %BYTE,P 32,G %100,G %110,G %120>
BYT9 <P 3,T UF,G %PA,T DF,G %N,T FS,G %C,T IB,L %P,T P,S>
BYT9 <T I,G %LD,L %LD,T LD,G %B,T I,G %DP,L %DP,T DP,G %B>
BYT9 <L %110,T D,P 3,T FA,L %D,T D,S,T FS,G %B,T FM,G %P,T FDV,S>
BYT9 <T AD,G %D,T SU,G %B,T MUL,S,T DIV,S>
BYT9 <L %100,P 21,S,P 2,T JSY,G %S,T ADJS,G %P,S,S>
BYT9 <L %120,P 3,T DMOV,G %E,T DMOV,G %N,T FIX,S,T EXTEND,S>
BYT9 <T DMOVE,G %M,T DMOVN,G %M,T FIXR,S,T FLTR,S>

BYT9 <L %HAK,P 33,G %MV,L %MV,T MOV,G %MO,G %ML,G %DV,G %SH,G %H1>
BYT9 <G %JP,P 21,T ADD,G %IMB,T SU,L %BIMB,T B,L %IMB,P 2>
BYT9 <S,L %I,T I,S,G %M,G %B,L %MO,P 22,L %EIMS,T E,G %IMS,T S>
BYT9 <G %IMS,T N,G %IMS,T M,L %IMS,P 2,S,G %I,G %M,L %S,T S,S>
BYT9 <L %ML,P 21,T I,G %ML1,L %ML1,T MUL,G %IMB,L %DV,P 21,T I,G %DV1>
BYT9 <L %DV1,T DI,L %DV2,T V,G %IMB,L %H1,P 3,T EXC,G %S3,T BL,L %T>
BYT9 <T T,S,G %AO,L %AO,T AOBJ,G %AOB,T JRS,G %T,T JFC,G %L,T XC,G %T>
BYT9 <T MA,G %P,L %AOB,P 1,G %P,G %N,L %JP,P 3,G %PU,L %PU,T PUSH>
BYT9 <G %PUS,G %PO,L %PO,T POP,G %POP,T JS,L %R,T R,S,T JS,G %P>
BYT9 <T JS,L %PA,T A,S,T JR,G %PA,L %PUS,P 1,L %J,T J,S,S,L %POP>
BYT9 <P 1,S,G %J,L %SH,P 2,T A,G %S2,T ROT,G %S1,T L,L %S2,T S,L %S3>
BYT9 <T H,G %S1,P 21,T JFF,G %O,T KAFIX,S,L %S1,P 21,S,L %C,T C,S>

BYT9 <L %ACCP,P 42,T CA,G %CA1,G %SJ,T A,G %JS,T S,L %JS,T O,P 31>
BYT9 <T J,G %COMP,T S,G %COMP,L %CA1,P 31,T I,G %COMP,T M,G %COMP>
BYT9 <L %SJ,P 31,T JUM,G %PSJ,T SKI,L %PSJ,T P,L %COMP>
BYT9 <P 3,S,G %L,L %E,T E,S,T L,G %E,G %PA,T G,G %E,L %N,T N,S,T G,S>

BYT9 <L %HWT,P 51,G %HW1,P 21,T R,G %HW2,T L,L %HW2,T R,G %HW3,L %HW1>
BYT9 <P 21,T L,G %HW4,T R,L %HW4,T L,L %HW3,P 32,G %IMS,T Z,G %IMS,T O>
BYT9 <G %IMS,G %EIMS>

BYT9 <L %ACBM,P 31,G %AC1,P 1,T D,G %AC2,T S,G %AC2,L %AC1,P 1,T R>
BYT9 <G %AC2,T L,L %AC2,P 42,T N,G %EAN,T Z,G %EAN,T C,G %EAN,T O>
BYT9 <L %EAN,P 12,S,G %E,G %PA,G %N>

BYT9 <L %CB,T C,G %BIMB,L %BOOLE,P 24,G %ST,L %AN,T AND,G %B2,G %AN>
BYT9 <G %ST,G %AN,G %ST,T X,L %OR,T OR,G %B2,T I,G %OR,G %AN,T EQ>
BYT9 <G %DV2,G %ST,G %OR,G %ST,G %OR,G %OR,L %ST,T SET,L %B2>
BYT9 <P 24,T Z,G %IMB,G %IMB,L %CA,T C,G %TA,L %TM,T M,G %IMB,L %CM>
BYT9 <T C,G %TM,L %TA,T A,G %IMB,G %IMB,G %IMB,T C,G %BIMB,G %IMB,G %CA>
BYT9 <G %CA,G %CM,G %CM,G %CB,T O,G %IMB>>
;END OF THE DEFINITION OF "TABLE"

;EXPAND "TABLE" ONCE TO GET THE LABELS DEFINED.

CLOC←←0		;INITIALIZE LOCATION COUNTER.
XLIST
TABLE
LIST

;NOW REDEFINE "OUTP" TO CAUSE NEXT EXPANSION OF "TABLE" TO GENERATE DATA

DEFINE OUTP (A)
<BINRY←←BINRY⊗=10+A
BINC←←BINC-1
IFE BINC,<
BINRY⊗6
BINRY←←0
BINC←←3
>
CLOC←←CLOC+1
>

BINRY←←0
BINC←←3
CLOC←←0
↑TBL::		;CAUSE ACTUAL EXPANSION OF THE TABLE TO OCCUR HERE.
XLIST
TABLE
REPEAT BINC,<BINRY←←BINRY⊗=10>
IFN BINRY,<BINRY⊗6>
LIST

BEND OPDEFS
;PNTR INST CHP TXT SAVPDL BTAB OPEVAL OPTYPE DC1 DC2

PNTR:	INST		;POINTER TO BITS IN INST
INST:	0		;BINARY FOR INSTRUCTION
CHP:	0		;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK 2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:	0		;SAVE PUSH DOWN LIST POINTER

;TABLE USED TO GET NEXT BYTE POINTER FOR TRANSFER BYTE
BTAB:	POINT 10,TBL
	POINT 10,TBL,9
	POINT 10,TBL,19

OPEVAL:	MOVEI T,0		;EVALUATE FOR AN OP CODE
	IDPB T,CHP
	MOVEM P,SAVPDL
	TRZA F,OUTF
OPTYPE:	TRO F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	LSH T,-33
	MOVEM T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE T,[XWD 440700,TXT]
	MOVEM T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ F,ITF		;CLEAR INSTRUCTION TYPED FLAG
	SETZB  R,W1
	MOVE W2,BTAB
DC1:	ILDB T,W2		;GET NEXT BYTE IN TBL
	CAILE T,40
	CAIL T,73
	SOJGE R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG R,DC1		;SKIP OVER ALPHA TEXT WITHOUT COUNTING
	SUBI T,40
	JUMPE T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG T,DC2
	DPB T,[XWD 340500,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ T,-4
	AOS T
	DPB T,[XWD 300600,PNTR]
	TRNN F,OUTF
	JRST DC6		;FOR OPEVAL ONLY
	LDB R,PNTR		;GET # BYTES TO SKIP OVER
	JRST DC1

DC2:	HRREI T,-33(T)
	JUMPL T,DECT		;TYPE OUT A LETTER
	MOVE W1,T		;BYTE IS A TRANSFER
	IDIVI W1,3		;NUMBER OF BYTES/WORD IN TABLE.
	MOVE W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI W2,(W1)
	JRST DC1
;DECT DECX NOMAT NOMAT1 DC6 DC6AA DC6BB DC7 DC8

DECT:	TRNE F,OUTF
	JRST DC8	;TYPE OUT A LETTER
	ILDB W1,CHP	;GET NEXT INPUT LETTER
	CAIE W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST NOMAT	;DOESNT MATCH
	JRST DC1	;MATCHES, TRY NEXT

DECX:	TRNE F,OUTF	;STOP (CODE 40) HAS BEEN SEEN
	POPJ P,		;IF FOR OUTPUT, RETURN
	ILDB W1,CHP	;GET NEXT INPUT CHAR IF ANY
	JUMPE W1,DC7	;DOES # OF CHARS MATCH
NOMAT:	POP P,R		;NO, BACK UP AND TRY SOME MORE
	POP P,W2
	POP P,PNTR
	POP P,CHP
NOMAT1:	AOS R		;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB R,PNTR	;STUFF INTO ANSWER
	LDB R,PNTR
	JUMPN R,DC6AA	;IF =0, BYTE WAS TOO BIG
	CAME P,SAVPDL
	JRST NOMAT	;NOT AT TOP LEVEL
	POPJ P,		;UNDEFINED, FINALLY

DC6:	MOVEI R,0	;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB R,PNTR
DC6AA:	CAMN P,SAVPDL
	JRST DC6BB
	LDB T,-2(P)	;OLD VALUE OF PNTR
	CAME T,(P)
	JRST NOMAT1
DC6BB:	PUSH P,CHP
	PUSH P,PNTR
	PUSH P,W2
	PUSH P,R
	JRST DC1

DC7:	MOVE P,SAVPDL		;RESTORE PUSH DOWN POINTER
	MOVE T,INST
	LSH T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	TLC T,700000
	TLCE T,700000
	JRST CPOPJ1
	SETOM IOTFLG	;IT IS AN IOT
	LDB R,[POINT 3,T,8]
	DPB R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST CPOPJ1

DC8:	TRO F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI T,133(T)
	PUSHJ P,TOUT		;OUTPUT A LETTER
	SETZM  SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST DC1
;DDTPATCH BUFF

DDTPATCH:	BLOCK 10

IFE EDDT&3-3,<
BUFF:	BLOCK 40>
;UESTRT NODMAP COPSYM ESYMS XSCOP1 XSCOP2 P2SYMS P2NOCR P2DOWN P2NOSY P2LOSE P2SYM2 USYMS CSYMS UELP1 U2SYMS U2SYM2 NOCORE NOSYM1 EXCSYM EXMMAP EXSYMS EXJOBN EXJWRD EXPPSB EXPGTA EXPGT

	SUBTTL	UEDDT ROUTINES - COPSYM

IFN UEDDTS,<

UESTRT:	SETZM EXJOBN		;JOB WE ARE EXAMINING!
	SETZM EXSYMS		;START WITH P1 EXEC SYMBOLS
	SETZM P2EXM		;AND NOT P2'S
	SETOM EXMMAP
	MOVEI S,37
	PEEK S,
	MOVEM S,MEMSIZ#
	MOVE T,S
	ANDI S,MAXPR-1
	HRLZM S,PRSIZ#
	ANDI T,¬<MAXPR-1>
	MOVEM T,PRTOP#
	SETZM SYMSYS#
	SETZM SYMLUZ#
	MOVEI S,343
	PEEK S,
	HRRZM S,EXPGTA		;ADDRESS OF EXPGT
NOKL10,<HLRZM S,EXPPSB		;OFFSET OF PSB FROM EXPGT
>;NOKL10
	MOVEI S,265
	PEEK S,			;PEEK ADDRESS OF SYSTOP
	PEEK S,			;PEEK SYSTOP ITSELF
	MOVEM S,SYSTOP#
	LSH S,-9		;MAKE PAGE NUMBER
	MOVEM S,SYSPAG#
	MOVEI S,222		;LEGAL JOB NUMBER
	PEEK S,
	MOVEM S,JOBMAX#		;REMEMBER MAX JOB NUMBER
	MOVEI S,254
	PEEK S,			;ADDRESS OF MAINTMODE
	PEEK S,			;MAINTMODE
	MOVEM S,MAINTM#
	MOVEI S,162
	PEEK S,			;ADDRESS OF SYMLOC
	PEEK S,			;CONTENTS
	MOVEM S,CSYMLOC#
	MOVEI S,163
	PEEK S,			;ADDRESS OF DDTXCOR
	PEEK S,			;CONTENTS
	MOVEM S,CDDTXC#
	MOVEI S,164
	PEEK S,			;ADDRESS OF DDTMAP
	MOVEM S,ADDTMA#
	SKIPN CDDTXC		;IS EDDT MAPPED OUT?
	JRST NODMAP		;Nope
	HLRE T,CSYMLOC		;Get negative length of symbol table
	MOVN T,T		;Positive length
	ADD T,CSYMLOC		;End address of symbol table
	MOVEI T,777(T)		;Round up to whole page
	LSH T,-9		;Make it number of page following mapped DDT
	MOVEM T,DDTEPG#		;Remember for EXPCHK
NODMAP:	MOVEI T,0
	MOVEI P,PS
	PUSHJ P,PRSET
	MOVEI S,DDTEND
	HRRZ T,74
	CAIN T,DDT		;ARE WE "THE" DEBUGGER?
	MOVEM S,JOBFF		;FLUSH SYMS IF NOT BEING DEBUGGED
	PUSHJ P,COPSYM		;GET SOME SYMBOLS
	SETZM SPCFLG#
	JRST DDT

;Here is a copy of what is stored at exec 162, ff., for use by UEDDT
;162/	SYMLOC
;163/	DDTXCOR
;164/	DDTMAP
;165/	DDTA

COPSYM:	SETZM PRGM		;forget any old program that was open
	SETZM BLOCK		; and any old block -- getting new symbols
	SKIPGE EXSYMS		;WHOSE SYMBOLS ARE WE LOOKING FOR?
	JRST USYMS		;COPY USER'S SYMBOLS
IFE FTF2,<
	SKIPE EXSYMS		;ARE WE TRYING TO GET P2'S SYMBOLS?
	JRST P2SYMS		;YES
>;IFE FTF2
ESYMS:	SETZM EXSYMS		;COULDN'T GET USER OR P2 SYMBOLS, USE P1 SYMS
	SKIPE R,400036		;EXEC SYMBOL POINTER
	JRST CSYMS		;COPY THEM IN
	SETZM EXCSYM		;NO SYMBOLS YET!
	SKIPE R,400163		;Get pointer to DDTXCOR
	SKIPN 400000(R)		;SKIP IF DDT IS IN XTRA CORE
	HALT .
	MOVE R,400162		;POINTER TO SYMLOC
	MOVE R,400000(R)	;FETCH SYMLOC  - AOBJN POINTER TO SYMBOLS.
	SUB R,400165		;-DDTA = OFFSET ABOVE extra core starting address
	ADDI R,400000		;+400000 = OUR UPPER SEGMENT ADDRESS FOR FIRST SYM.
	HLRO T,R		;-WC OF SYMBOLS
	MOVN T,T		;+WC
	ADD T,JOBFF		;NEW JOBFF.
	IORI T,1777
	CORE T,
	JRST NOCORE
	HLRO W1,R		;-WC AGAIN.
	ADD W1,JOBREL		;STARTING ADDRESS FOR SYMBOLS - 1
	ADDI W1,1
	HLL W1,R		;AOBJN POINTER IN OUR CORE FOR NEW SYMS.
	MOVEM W1,EXCSYM
	MOVE T,400164		;ADDRESS OF DDTMAP (SAVED EXPGT PTRS)
PRINTX UEDDT should check to ensure DDT mapped physical pages are contiguous.
;It could do that if it had a pointer to DDTPGS, perhaps in LH 164.
	HRRZ T,400000(T)	;GET FIRST PAGE OF DDTA (ASSUME CONTIGUOUS!)
	JUMPN T,.+2
	HALT .			;OH WELL
	LSH T,5			;SHIFT FOR GETHI
	HRLI T,400		;ASK FOR 400 PAGES OF UPPER STARTING WHERE DDTA IS
;;;	MOVE 0,[400,,1000*40]	;400 PAGES STARTING AT PHYSICAL 1000000
;;;	GETHI 0,		;ATTACH HIGH CORE.
	GETHI T,		;ATTACH HIGH CORE.
	 HALT .			;LOSE SOMEHOW.
	SUB W1,[1,,1]		;FORM STACK.
XSCOP1:	PUSH W1,(R)		;FETCH HIGH CORE, STORE LOW CORE. INCREMENT LOWCOR
	AOBJN R,XSCOP1		;   POINTER, INCREMENT HIGH CORE POINTER.

REPEAT 0,<			;WE NOW ALWAYS PEEK AT THE REAL EXPGT
;THE FOLLOWING COPIES THE EXPGT INTO OUR CORE-IMAGE.
	LDB R,[POINT 14,EXPGTA,31]	;GET EXPGT PAGE NUMBER LSH 5
	HRLI R,1		;1 PAGE
	GETHI R,		;GET EXPGT AS PAGE 400
	 HALT .
	MOVSI R,-1000
XSCOP2:	MOVE W1,400000(R)
	MOVEM W1,EXPGT(R)	;COPY SYSTEM'S EXPGT
	AOBJN R,XSCOP2
>;REPEAT 0
	JRST PRSET		;RESET SETPR2.  RETURN VIA POPJ

IFE FTF2,<
;FROM $$¬ TO EXAMINE P2 WITH P2'S SYMBOLS
P2SYMS:	GETPR2 R,		;REMEMBER SETTING OF UPPER SEG MAP
	PUSH P,R
	P2UUO 5,		;GET P2 MEMORY AS OUR UPPER SEG, WRITE PROTECTED
	 JRST P2DOWN		;P2 MEMORY IS DOWN
	SKIPN R,400036		;GET POINTER TO SYMBOLS
	 JRST P2NOSY		;NO SYMBOLS
	PUSH P,[P2NOCR]		;IN CASE CAN'T GET ENOUGH CORE
	JRST CSYMS		;GET CORE FOR HOLDING SYMBOLS

P2NOCR:	OUTSTR [ASCIZ\Can't get enough core for P2 symbols.
\]
	JRST P2LOSE

P2DOWN:	OUTSTR [ASCIZ\P2 memory is down.
\]
	JRST P2LOSE

P2NOSY:	OUTSTR [ASCIZ\No P2 symbol pointer.
\]
P2LOSE:	POP P,T			;GET BACK SAVED PR2
	SETPR2 T,
	 HALT .			;CAN'T RESTORE MAP
	JRST ESYMS		;TRY TO GET EXEC SYMBOLS INSTEAD

;HERE AFTER GETTING CORE FOR P2
P2SYM2:	SUB P,[1,,1]		;FLUSH PHONY RETURN ADDR THAT WAS FOR ERROR
	HLRO T,W1		;NEGATIVE NUMBER OF WORDS
	MOVN T,T		;POSITIVE COUNT
	HRLI W1,400000(R)	;UPPER SEG ADDR OF FIRST WORD OF P2 SYMS
	ADDI T,(W1)		;ENDING ADDRESS PLUS ONE, IN OUR CORE IMAGE
	BLT W1,-1(T)
	POP P,T			;GET BACK SAVED OLD PR2
	SETPR2 T,		;RESTORE SIMULATED UPPER
	 HALT .			;CAN'T RESTORE MAP
	POPJ P,
>;IFE FTF2

USYMS:	MOVEI R,JOBSYM		;FROM $$n¬
	PUSHJ P,FETCH		;FETCH LOSER JOBSYM
	 SETZ T,		;COULDN'T GET IT
	JUMPE T,ESYMS		;IF NO SYMBOLS, TRY SYSTEM SYMS
	MOVE R,T
CSYMS:	HLRO T,R		;HERE WITH AOBJN POINTER TO SYMS IN R (FROM ESYMS)
	MOVNS T
	ADD T,JOBFF
	IORI T,1777
	CORE T,
	 JRST NOCORE
	HLRO W1,R
	ADD W1,JOBREL
	HLL W1,R
	ADDI W1,1
	MOVEM W1,EXCSYM
	SKIPGE EXSYMS		;SKIP IF P1 OR P2 SYMBOLS
	JRST U2SYMS
IFE FTF2,<
	SKIPE EXSYMS		;SKIP IF P1 SYMBOLS
	JRST P2SYM2
>;IFE FTF2
	PUSH P,EXMMAP
	SETZM EXMMAP		;FORCE PHYSICAL EXAMINE TO GET P1 SYMBOLS
	PUSH P,EXJOBN		;MIGHT BE DOING A $N¬ AFTER $$N¬
	SETZM EXJOBN		;FORCE FETCH TO GET DATA FROM SYSTEM
UELP1:	PUSHJ P,FETCH
	 SETZ T,		;STORE A 0
	MOVEM T,(W1)
	ADDI R,1
	AOBJN W1,UELP1
	POP P,EXJOBN		;RESTORE NUMBER OF JOB WE MIGHT BE EXAMINING
	POP P,EXMMAP		;RESTORE PREVIOUS STATE OF FLAG
	POPJ P,

U2SYMS:	HRRZ W2,EXCSYM		;ADDRESS IN UEDDT WHERE THEY GO
U2SYM2:	MOVE T,EXJOBN		;SET UP JOBRD BLOCK
	MOVE W1,R		;-# WORDS LEFT TO READ,,USER'S ADDRESS OF NEXT WORD
	CAMGE W1,[-2000,,]
	HRLI W1,-2000		;THIS IS THE MAXIMUM TRANSFER SIZE
	MOVEI S,T
	JOBRD S,
	 POPJ P,		;COULDN'T READ THEM ALL, TOO BAD
	HLRE T,W1		;- NUMBER TRANSFERRED
	MOVN T,T
	HRL T,T
	ADD R,T
	ADDI W2,(T)
	JUMPL R,U2SYM2
	POPJ P,

NOCORE:	OUTSTR [ASCIZ /CAN'T GET CORE/]
	POPJ P,

NOSYM1:	OUTSTR [ASCIZ /NO SYMBOLS ANYWHERE???/]
	POPJ P,

EXCSYM:	0
EXMMAP:	-1		;-1 TO EXAMINE THRU EXPGT, 0 FOR PHYS, +N FROM BASE PAGE N
EXSYMS:	0		;WHOSE SYMBOLS: USER (-1), P1 (0), P2(0,,777777)
EXJOBN:	0		;THIS IS A TABLE FOR JOBRD UUO.
	-1,,0		;CLOBBER RH TO USER'S ADDR. BEING EXAMINED
	EXJWRD		;POINTER TO WHERE TO STORE THE DATA THAT'S READ.
EXJWRD:	0

NOKL10,<
EXPPSB:	0		;OFFSET OF PSB FROM EXPGT
>;NOKL10
EXPGTA:	0		;ADDRESS OF EXPGT IN SYSTEM
EXPGT:	BLOCK	1000	;HERE'S OUR COPY OF THE EXPGT.
;DDTREN NOREN SYMPR PRSET PRLUZ PROFF LOGIT LOGIT0 LOGZ0 LOGOUT LOGZ LOGZ1 LOGLOS LOGDC2 LOGWRD LOGOCT LOGDEC LOGNUM LOGCHR LOGOK LOGSIX INLMES INLMS1 LOGCNT LOGPTR LOGADR LOGBUF LOGNAM LOGEXT LOGDAT LOGPPN

;	MORE UEDDT

ACWPRV←←40

DDTREN:	MOVEI T,0		;REENTER COMMAND
	GETPRV T,
	TLO T,ACWPRV
	SETPRV T,
	TLNN T,ACWPRV		;DOES HE HAVE ACW PRV?
	JRST NOREN
	SETOM SPCFLG
	SETZM SPCADR
	JRST DDT

NOREN:	OUTSTR[ASCIZ/SORRY, YOU CAN'T DO THAT!
/]
	JRST DDT

SYMPR:	HRRZ T,EXCSYM
	TRZ T,400000
PRSET:	ANDI T,¬<MAXPR-1>
	CAME T,PRTOP
	TLOA T,<MAXPR-1>&376001
	HLL T,PRSIZ
	SETPR2 T,
	JRST PRLUZ
	TLO T,1777
	HLRZM T,PRMAX#
	MOVNS T
	HRRM T,PROFF
	SKIPN SYMSYS
	POPJ P,
	ADD T,EXCSYM
	SETZM SYMLUZ
	MOVEI T,-400000(T)
	CAMLE T,PRMAX
	SETOM SYMLUZ
	POPJ P,

PRLUZ:	OUTSTR [ASCIZ /SETPR2 FAILED!
/]
	JRST 4,.

PROFF:	(R)

;LOG CHANGES MADE TO THE SYSTEM BY UEDDT
LOGIT:	INIT 17
	'DSK   '
	0
	POPJ	P,			;BARF
	MOVE	T,[' SSSYS']
	MOVEM	T,LOGPPN
	LOOKUP	LOGNAM
	JRST	LOGIT0
	EXCH	T,LOGPPN
	MOVS	T,T
	MOVN	T,T
	SOJL	T,LOGZ0			;JUMP IF FILE EMPTY
	LSH	T,-7
	ADDI	T,1			;CALCULATE RECORD NUMBER
	MOVEM	T,LOGPTR
	USETI	@LOGPTR
	IN	[IOWD 200,LOGBUF↔0]
	JRST	LOGOUT
	STATO	20000			;EOF IS OK.
	JRST	LOGLOS
	JRST	LOGOUT

LOGIT0:	HRRZ	T,LOGEXT
	JUMPN	T,LOGLOS		;BARF (WASN'T FILE NOT FOUND)
LOGZ0:	SETZM	LOGBUF
	SETZM	LOGPTR
	AOS	LOGPTR			;SET POINTER TO RECORD 1
LOGOUT:	HLLZS	LOGEXT
	SETZM	LOGDAT
	ENTER	LOGNAM
	JRST	LOGLOS			;CAN'T READ/ALTER THE FILE
	MOVE	R,[POINT 7,LOGBUF]	;LOOK FOR NULL BYTE AT END
LOGZ:	ILDB	T,R
	JUMPN	T,LOGZ
	ADD	R,[70000,,0]		;BACKUP WHEN WE SEE ONE
	PUSH	P,W1
	PUSH	P,W2
	GETPPN	W2,
	PUSHJ	P,LOGSIX		;PPN
	PUSHJ	P,INLMES
	ASCIZ	/	(/
	PJOB	W1,
	PUSHJ	P,LOGDEC		;JOB NUMBER
	PUSHJ	P,INLMES
	ASCIZ	/.)	TTY/
	SETO	W1,
	GETLIN	W1
	HRRZ	W1,W1
	PUSHJ	P,LOGOCT		;TTY LINE NUMBER
	MOVEI	W1,11
	PUSHJ	P,LOGCHR
	DATE	W1,
	IDIVI	W1,=31
	PUSH	P,W2
	IDIVI	W1,=12
	EXCH	W1,(P)
	PUSH	P,W1
	MOVEI	W1,1(W2)
	PUSHJ	P,LOGDC2		;DAY OF MONTH
	MOVEI	W1,"-"
	PUSHJ	P,LOGCHR
	POP	P,W1
	ADDI	W1,1
	PUSHJ	P,LOGDC2		;MONTH
	MOVEI	W1,"-"
	PUSHJ	P,LOGCHR
	POP	P,W1
	ADDI	W1,=64
	PUSHJ	P,LOGDEC		;YEAR
	MOVEI	W1," "
	PUSHJ	P,LOGCHR
	MSTIME	W1,
	IDIVI	W1,=1000*=60
	IDIVI	W1,=60
	PUSH	P,W2
	PUSHJ	P,LOGDC2		;HOURS
	POP	P,W1
	PUSHJ	P,LOGDC2		;MINUTES
	MOVEI	W1,11
	PUSHJ	P,LOGCHR
	HRRZ	W1,SPCADR
	PUSHJ	P,LOGOCT		;ADDRESS
	PUSHJ	P,INLMES
	ASCIZ	?/	?
	MOVE	W1,SPCADR
	PEEK	W1,			;GET OLD CONTENTS
	SETZM	LOGCNT
	PUSHJ	P,LOGWRD		;
	MOVEI	W1,11
	MOVE	W2,LOGCNT
	CAIGE	W2,8
	PUSHJ	P,LOGCHR
	PUSHJ	P,LOGCHR
	MOVE	W1,SPCWRD		;GET NEW CONTENTS
	PUSHJ	P,LOGWRD
	PUSHJ	P,INLMES
	ASCIZ/
/
	SETZ	W1,			;NULL BYTES TO FINISH WORD
LOGZ1:	PUSHJ	P,LOGCHR
	TLNE	R,760000		;FILL OUT WORD
	JRST	LOGZ1
	HRRZ	R,R
	SUBI	R,LOGBUF-1		;GET # OF WORDS
	MOVN	R,R
	MOVS	R,R
	HRRI	R,LOGBUF-1
	MOVEM	R,LOGADR
	USETO	@LOGPTR
	OUTPUT	LOGADR
	POP	P,W2
	POP	P,W1
	MOVE	T,SPCWRD
	MOVE	R,SPCADR
LOGLOS:	RELEASE
	POPJ	P,

LOGDC2:	CAIL	W1,=10
	JRST	LOGDEC
	PUSH	P,W1
	MOVEI	W1,"0"
	PUSHJ	P,LOGCHR
	POP	P,W1
	JRST	LOGDEC

LOGWRD:	HRLM	W1,(P)
	HLRZ	W1,W1
	PUSHJ	P,LOGOCT
	PUSHJ	P,INLMES
	ASCIZ	/,,/
	HLRZ	W1,(P)
LOGOCT:	SKIPA	T,[10]
LOGDEC:	MOVEI	T,=10
LOGNUM:	IDIV	W1,T
	HRLM	W2,(P)
	JUMPE	W1,.+2
	PUSHJ	P,LOGNUM
	HLRZ	W1,(P)
	ADDI	W1,60
LOGCHR:	CAME	R,[POINT 7,LOGBUF+177,34]	;END OF BUFFER?
	JRST	LOGOK			;NO
	USETO	@LOGPTR
	OUTPUT	[IOWD 200,LOGBUF↔0]
	MOVE	R,[POINT 7,LOGBUF]
	AOS	LOGPTR
LOGOK:	IDPB	W1,R
	AOS	LOGCNT
	POPJ	P,

LOGSIX:	JUMPE	W2,CPOPJ
	SETZ	W1,
	LSHC	W1,6
	ADDI	W1,40
	PUSHJ	P,LOGCHR
	JRST	LOGSIX

INLMES:	POP	P,W2
	HRLI	W2,(<POINT 7,0>)
INLMS1:	ILDB	W1,W2
	JUMPE	W1,1(W2)
	PUSHJ	P,LOGCHR
	JRST	INLMS1

LOGCNT:	0
LOGPTR:	0
LOGADR:	0
	0

LOGBUF:	BLOCK 201

LOGNAM:	'UEDDT '
LOGEXT:	'LOG   '
LOGDAT:	0
LOGPPN:	' SSSYS'
>;IFN UEDDTS

;KEEP IT ALL TOGETHER FOR MAPPING DDT.
;LIT AND VAR XLISTED FOR YOUR READING PLEASURE
XLIST
LIT
VAR
LIST

XP DDTEND,.
↑↑DDTEND←DDTEND

Comment ⊗	How to put up new SYS:DDT.DMP; How to debug UEDDT using RAID.

Putting up new SYS:DDT.DMP --

When DDT changes (or the UUO set changes), make sure SAIDFS.MID[CSP,SYS]
is up to date.  Its format is obvious.  Then just do
AL CSP,SYS
PRE SDDT/DD
SA SYS DDT
DEL SDDT.REL[CSP,SYS]


How to debug UEDDT, using RAID as the debugger --

Here's what you do.  Ignore the multiply defined globals that appear
both in DDT and in RAID.  Note that to start DDT (UEDDT, that is),
you can refer to its starting address as DDTDDT (since DDT is
multiply defined) to ensure getting the right location.  The LOADER
commands ensure that the symbols and RAID are loaded in the right places.

.AL S,SYS
.COM TTY:+DSK:DDT
Swapping to SYS:FAIL.DMP
 TTY:
UEDDTS←←1
αβ
   DDT
FAIL:  UEDDT 

Exit
↑C
.R LOADER
*%S%B%?DDT/V$
?$M        023105    000326 MUL. DEF. GLOBAL IN PROG.  RAID   FILE RAID.REL
?DDTEND    026534    011724 MUL. DEF. GLOBAL IN PROG.  RAID   FILE RAID.REL
?DDT       021525    001030 MUL. DEF. GLOBAL IN PROG.  RAID   FILE RAID.REL


LOADER 28 PAGES
24K MAX 531 WORDS FREE 

Exit
↑C
.SAVE UEDDT

;end of comment  ⊗
	SUBTTL	DDT User's Guide

COMMENT α	DDT User's Information

DDT is a program debugging aid that is loaded into the same core image as
the program being debugged.  DDT can be entered via the monitor DDT command
or by a program transfer to the external label DDT or by a program transfer
to the address contained in the right half of JOBDDT.

DDT can also be entered as a result of executing an instruction on which
a breakpoint has been set.

Once DDT has been entered the user may examine and modify the contents of
his accumulators and other memory locations.  To return to the execution
of the program an $P command (proceed from a breakpoint) or adr$G (start
execution at adr) may be used.  When DDT is entered via the DDT command,
the PC of the interrupted program is stored in JOBOPC.

If DDT is entered directly (e.g., JRST @JOBDDT or by DDT monitor cmd),
then $P will attempt to continue from the PC stored in JOBOPC if and
only if the user-mode bit (10000,,0) is on in the left half of JOBOPC.
Thus if a user program stores a user-mode PC in JOBOPC and then jumps
to DDT, the $P command will continue at the PC the program set up in JOBOPC.

In Exec DDT (EDDT), upon direct entry to DDT, $P will attempt to continue
at the PC stored in PROCPC (the PC from PROCPC is stored away upon entry
to DDT and PROCPC is zeroed so that DDT won't accidentally proceed from
the same PC twice without PROCPC having been set up again).

User DDT and UEDDT now use special activation mode in order to let the
user edit his command before he is finished with it.  This means that the
only characters that activate (and therefore cannot be edited) are those
characters that act as commands without the use of altmode.  (Also, some
illegal command characters activate immediately, and the DDT command
characters that activate will do so even when appearing inside a string
where they are not taken as commands.)  DDT also activates the first
character after an altmode (since that character is almost always a
command character), and if that character is a digit, every subsequent
character up through the first non-digit.  Finally, a backspace typed in
an empty line will activate.  If there is some situation in which DDT
fails to activate the end of a command, you can force DDT to activate by
typing any activator, such as altmode (and then you can abort the extra
character with backspace); if you find you have to do this a lot, you can
disable DDT's use of special activation mode by setting the cell $M-5
non-zero, in which case DDT will activate on every character.  Please
report to ME any situations in which DDT fails to activate upon a complete
command.


The following is a quick summary of DDT for people who already know how
to work DDT in general.  For further information, consult DEC documentation

General -
	$ = Altmode
	n = a number
	$n = a decimal number always!


Input modes

$n%	Input a list of n-bit octal bytes, separated by commas, terminated by $.
	If n=0 use the byte mask ($M+2) to define arbitrary byte boundaries

"<delimiter>text<delimiter>
	Left justified ascii text (up to five characters)  Note: to get CRLF
	entered you must type both CR and LF.  If more than five characters
	are typed, only the last five are used.

"<character>$
	Right justified ascii character.

$"<delimiter>text<delimiter>
	Left justified sixbit text (lower case typin converted to upper case).
	The last six (or fewer) characters are used.

$"<character>$
	right justified ascii character

$$7"<delimiter>text<delimiter>
	Left adjuseted ASCIZ string, five characters per word.

$$"<delimiter>text<delimiter> or $$n"<delimiter>text<delimiter>  (n not 7)
	Left adjusted sixbit string, six characters per word.  Ends with
	a zero byte or zero word.


Output modes
$A	Absolute

$C	Full word constant in current radix

$F	Floating point

$H	Halfword format

$nJ	Output in flag mode using the n-th flag table.
	Each flag table contains =36 radix50 flag names (flag name for
	bit 0 is first).  The first word in the list of flag tables is
	found by looking in $M+3 (FLGPTR).  Each word in the list of flag
	tables is a right-half pointer to a flag table and a left-half
	pointer to the next word in the list (a zero left half terminates).

$nL	Output right half of cell as left half flags using n-th flag table.
	This is suitable for looking at MOVSI or TLxx instructions.

$nO	Output cell in n-bit bytes
	If n=0 use the byte mask ($M+2) to define arbitrary byte boundaries

$R	Relocatable

$nR	Set typeout radix to n.

$S	Symbolic

$nT	n-bit text bytes.  If n is omitted output 7-bit ascii, left adjusted,
	except if the first byte is null, output one right adjusted character.
	If n is present it should be one of 5, 6, or 9: 6=sixbit, 5=radix50,
	9=Stanford ascii with bucky bits.  Other values of n presently print
	in 7-bit ascii.

$U	each halfword as numeric in the current radix, unless $10R in which
	case output full word in radix 10

$nV	Output right half of cell as right half flags using n-th flag table.
	This is suitable for looking at MOVEI or TRxx instructions.



Special Characters
addr/	open cell in current mode
addr[	open cell as a number in the current radix
addr]	open cell as symbolic
addr!	open cell and suppress typeout
addr\	open cell in current mode and don't change "."
CR	Closes and changes (if user typed a new value) the current cell.
LF	Like CR and opens .+1.
↑	Like CR and opens .-1.
TAB	Like CR then opens the cell pointed to by right side of current cell.
≥ (control ] on ttys)
	Closes and does NOT change the current cell then opens the cell
	pointed to by left side of current cell.
;	retype in current mode (usually following a temporary mode change)
=	retype like $U format (half word numeric in current radix)
$=	retype like $C format (full word numeric in current radix)
←	retype in symbolic mode.
?	typeout all undefined symbols


Searches

$M	Contains the search mask.  Put 1 bits in it where you want to look.

first<last>arg$E
	Effective address search for intructions pointing to arg in the 
	range first to last

first<last>arg$N
	Search for words NOT containing arg in the range first to last.

first<last>arg$W
	Search for words containing arg in the range first to last.

first<last>arg$$Z
	Write the value arg into all words in the range first to last.



Special values

.	(period) has the value of the current address

$I	(exec ddt) has the state of the PI system (CONI PI,)

$Q	Has the last value typed by ddt.  $$Q is the swapped value of $Q.

$nB	Address of the four words associated with breakpoint n.

	The first word contains the address of the breakpoint in the
	right half, and the address of the cell to open in the left
	half.

	The second word is the conditional instruction.  If this is zero, or
	if when exected it causes one skip, then the proceed counter
	is decremented and if it becomes non-positive, the breakpoint occurs.
	If the conditional instruction does not skip, no break is taken.
	If the conditional instructions skips twice, the break is taken
	regardless of the proceed counter.

	The third word is the proceed counter.

	If the fourth word is non-zero it is assumed to be the address of
	an ASCIZ string which will be used to set $M-1 (see below) to
	cause this string to be used for input instead of TTY input.

$M-5	(User DDT) If non-zero, DDT does terminal input by character instead
	of by using special activation mode and line input.  This shouldn't
	be necessary, but is available in case there is some instance in which
	DDT fails to make a command character activate.
$M-4	(EXEC DDT) If non-zero, DDT output goes to the LPT
$M-3	(EXEC DDT) Stores APR CONI bits here when DDT is entered
$M-2	If non zero, this points to a routine to be called to output
	each character.  The character to be output is in T (ac 5) and
	the routine should return via POPJ 3, without having clobbered
	any acs.
$M-1	If non zero is taken as a byte pointer to an ASCIZ string which
	is used instead of the TTY for input.
$M	Search mask
$M+1	Parameter for symbolic disassembly. If the value disassembed
	minus the best symbol is less than this number (MXINC) then
	the dissambler will print the symbol name plus the difference,
	if the difference is larger than this value, then the value
	being disassembled will be printed as a number.
$M+2	Byte input/output mask for $0% and $0O commands.
$M+3	First word in the list of flag tables. (See $F.)

Symbol manipulations

$D	Suppress the last symbol typed.  Retype the same value.

sym$K	Suppress output of the named symbol

sym$$K	Suppress input and output of this symbol

sym$:	Open the symbol table of the program named sym.

$:	Type a list of all program names.

sym:	Define sym to be the currently open location.

val<sym:
	Define sym to have value val.

sym$&	Open the symbol table of the block named sym in the currently
	open program.  Also accessible will be all symbols in blocks
	that contain the opened block.

$&	Type a list of all block names in the currently open program.

Program control

adr1(adr2)$nB
	Set breakpoint n at adr1.  When breakpoint is hit it will type the
	contents of adr2.  The n and (adr2) are optional.

adr1(adr2)$$nB
	Same as above except DDT will proceed from the breakpoint automatically.
	Auto proceed continues until typin is present when the breakpoint is
	hit (see $$P).

$B	remove all breakpoints

0$nB	remove breakpoint n.

adr$G	Start execution at adr.  If adr is omitted, execution starts at
	the location pointed to by the right half of JOBSA (in exec DDT
	the right half of STARTA is used instead of JOBSA).   If  JOBSA
	(STARTA) contains a zero starting address, $G with no  argument
	is illegal.  Incidently STARTA is located at DDTBEG+0.

adr$$G	Same as adr$G except  the argument is stored in the right  half
	of JOBSA (or STARTA) for subsequent $G commands.

$P	Proceed from breakpoint (or from PC that was in JOBOPC or PROCPC
	upon entry to DDT).

n$P	Proceed n times from this breakpoint

$$P	Proceed automatically until the typein is present at the breakpoint.

instr$X	Executes the instruction that was typed.  If no argument is given
	then the one instruction at the current breakpoint location is
	single-stepped.  Repetitions of $X cause subsequent instructions to
	be single stepped.  After single stepping, a $P command will return
	to the normal execution of the program.

Assembly operations

+-*'	are arithmetic operators

,	is a separator denoting ac or device field

,,	separates half-words

	numeric typin is octal except digits followed by a decimal point
	are radix 10, except if further digits following the point are
	typed, input is floating point.  Floating point number may be
	followed by E, an optional plus or minus, and an exponent.

()	swap the argument and add it into the assembled word.

@	Set bit 13 in the word being assembled.

blank	is a separator and adding operator in the word assembler.

sym&	sets block name to sym for the next symbol that's input.


Special commands only for UEDDT and/or EDDT:

↓	Like CR (except it used to deposit changes on the Librascope)

$n¬	(UEDDT only) Examine core image of Timesharing job n.
$$n¬	(UEDDT only) Examine core image of Timesharing job n using its symbols.
	[With the above two cmds, you cannot examine the job's upper segment.]

$¬ or $0¬	(UEDDT and EDDT) Examine the timesharing system, using the
	EXPGT to accomplish mapping.  Upon attempt to examine or deposit
	where there is no EXPGT entry, an error message is given, and only
	if you are just examining, physical memory will be examined instead.
	These commands set EXMMAP to -1 (like -1$¬ command, see below).

$$¬ or $$0¬ 	(EDDT only) Send P2 into EDDT and connect to it until ¬ is typed.

$$¬ or $$0¬	(UEDDT only) Examine P2 memory using P2's symbols.

n$¬	(UEDDT and EDDT)  This command sets EXMMAP to n, with the following
	effects.  If n is positive, examine physical core starting from
	page n.  If n is 0, examination will be by physical address (i.e.,
	first 256K of physical memory).  If n is negative, examination
	will be via the EXPGT; if n is -1, then references to the part of
	DDT and the symbols that can be mapped out (and in EDDT only,
	references to the part of the EXPGT corresponding to those mappable
	DDT pages) will instead reference what the system had there in its
	map (which may be DDT, if DDT is not mapped out); but if n is -2
	(or any negative value besides -1) then references to mappable DDT
	& symbols will actually reference DDT and the symbols (and in EDDT
	only, what DDT has in the EXPGT).  While DDT is mapped out, the
	pieces of the exec map needed to map DDT in are kept in DDTMAP.
	While DDT is mapped in, the pieces of the exec map needed to map
	the exec back in are kept in SYSMAP.  The mappable part of DDT
	starts at DDTA; the length in pages of mappable DDT is indicated by
	DDTPGS.  DDTPGS will be zero if DDT is not being mapped out.

Paper tape control (Special EXEC DDT version only)

$↑Q	(That's control-Q) Punch loader.
first<last$↑R
	Punch data from core range to tape.
addr$↑S	Punch addr as the starting address.
↑T	Punch currently open location as one tape data block
first<last$Y
	Read tape into core
first<last↑V
	Read tape and verify by comparing it with core.

	(These >>>> for matching the less-than-signs in this comment.)
end of comment α


IFN EDDT&1,<
IFN FTDMAP,<
	BEND MDDT mappable portion of DDT, whose symbols we avoid
>;IFN FTDMAP
>;IFN EDDT&1


IFE EDDT&1,<IFE UEDDTS!SAVESW,<END>
	IFN UEDDTS,<END UESTRT>
	IFN SAVESW,<END DDT>>
IFE EDDT&21-21,<BEND DDT>	;IF SYSTEM EXEC DDT
IFN EDDT&40,<END>
>;IFN <P2SYS&FTP2DDT>!<<¬P2SYS>&FTDDT>  (starts on page 2)
