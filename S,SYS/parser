COMMENT ⊗   VALID 00005 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	PARINT PARIN0 PARIX0 PARIN3
C00008 00003	PARCON PARN4A PARIN5 PARIN6 PARL0 PARL1 PARL1 PARL2 PARL2A PARL3 PARL5 PARL6 PARL7 PARIX1 PARTRP PARTR1 PARNZS PARSPU
C00020 00004	PARERF PARERA PARER1 PARR1B PARR1C PARR1A PARER2 PARER3 PARR3A PARR3B PARR3C PARR3D PARER4 PARR4A PARER5 PARER6 PARER8 PARVIR PARVI1 PARVI0 PARVIX
C00030 00005	TELNXM PARBUZ TELUSR TELUSN TELUSB TELUSA TELUS1 TELU1X TELU1Y TELU1Z TELUSC TELNXC TELUS2 TELUS3 TELUS4 MARKERR DSKFIX DSKFX1 PAREAR
C00040 ENDMK
C⊗;
;PARINT PARIN0 PARIX0 PARIN3

BEGIN PARSER ↔ SUBTTL PARSER - PARITY ERROR SERVICE ROUTINE

HISYS				;ASSEMBLE IN HIGH CORE

↑PARINT:CLRPCP (CH3PCP)			;FROM CH3, TURN OFF PREV CONTEXT PUBLIC
IFN FTF2,<
	PARSTS PARREG			;Save parity register as soon as possible
>;IFN FTF2
IFKL10,<SKIPE P1RFLG
	JRST PARIN0			;HERE FROM ERRINT, CH3 already set up
	EXCH TAC,KLUPT+KLPFPC		;HERE FROM APR CHANNEL FOR P1 PARITY ERROR
IFN FTXADR,<
	MOVEM TAC,APRCHL+1		;CH3+1 GETS ADDRESS OF PAGE FAULT
>;IFN FTXADR
IFE FTXADR,<
	MOVEM TAC,APRCHL		;CH3 GETS ADDRESS OF PAGE FAULT
>;IFE FTXADR
IFN FTKLB,<
	TLNE TAC,-1		;make sure error is from PC in section 0
	JRST PARNZS		;parity error from nonzero sect. shouldn't happen.
	MOVE TAC,KLUPT+KLPFFG	;get flags saved at time of fault
	HLLM TAC,APRCHL		;store with section 0 PC as PC word, in CH3
	HRRZ TAC,APRCHL		;get back fault PC
>;IFN FTKLB
	EXCH TAC,KLUPT+KLPFPC	;restore TAC, fault PC
>;IFKL10
↑PARIN0:MOVEM P,PARPSAV			;ASSUME WE HAVE NO AC'S.
	MOVE P,APRPDL			;GET A STACK.
	PUSHACS				;SAVE ALL THE AC'S
REPEAT 0,<
;CODE FROM HERE TO PARIX0 IS FOR GETHI UUO/PARITY ERROR SUPPRESSION HACK
	MOVE TAC,APRCHL			;PC
	CONSO PI,1B27*(1⊗(7-APRCHN)-1)	;Skip if PI in progress, APRCHN thru Ch.7
	TLNN TAC,USRMOD
	JRST PARIX0			;FROM EXEC, ACT NORMALLY
	MOVE TAC,JOB
	MOVE TAC,JBTPR2(TAC)
	ANDI TAC,14
	CAIN TAC,14
	JRST PARIX1			;PARITY ERROR SUPPRESSION HACK (GETHI)
PARIX0:
>;REPEAT 0 ;END OF GETHI/PARITY ERROR SUPPRESSION
	PUSH P,TIMDAT
	POP P,LASTDISASTER
	MOVEI PID,P1PID			;SET PROCESSOR IDENTIFICATION
	PUSHJ P,DISUSR			;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /PARITY/
	PUSHJ P,DISMES			;HERE FOR P1 PARITY ERROR
	ASCIZ /πππππPARITY ERROR./
	SKIPE P1RFLG
	JRST PARN4A			;FROM ERRINT
	PUSHJ P,DISMES
	ASCIZ /  PC = /
IFN FTXADR,<
	MOVE TAC,APRCHL+1
>;IFN FTXADR
IFE FTXADR,<
	MOVE TAC,APRCHL
>;IFE FTXADR
PARIN3:	MOVEM TAC,ERRPC			;SAVE ERROR PC.

;DROPS THROUGH
;PARCON PARN4A PARIN5 PARIN6 PARL0 PARL1 PARL1 PARL2 PARL2A PARL3 PARL5 PARL6 PARL7 PARIX1 PARTRP PARTR1 PARNZS PARSPU

SUBTTL  HERE WE SEARCH FOR REAL ERRORS.

PARCON←←1B19			;CONO APR, BIT FOR CLEARING PARITY ERROR FLAG
;DROPS THROUGH

IFN FTXADR,<
	PUSHJ P,DISOCH		;WRITE THE ERROR PC
>;IFN FTXADR
IFE FTXADR,<
	PUSHJ P,DISOCT		;WRITE THE ERROR PC
>;IFE FTXADR
PARN4A:
IFN FTF2,<
	PUSHJ P,DISMES
	  ASCIZ/ EMA = /
	LDB TAC,[POINT 21,PARREG,35]	;Address of error
	PUSHJ P,DISADR
	PUSHJ P,DISMES
	  ASCIZ/ ECC = /
	LDB TAC,[POINT 6,PARREG,13]	;ECC code
	PUSHJ P,DISLOC
;	PUSHJ P,DISCRLF		;AND A CRLF
	CONO PI,PARCON		;I think the F2 needs this
>;IFN FTF2
	PUSHJ P,DISCRLF		;AND A CRLF
	SETOM ERRLOC		;SET TO SIGNIFY NONE FOUND YET.
	SETOM LASLOS		;JOB NUMBER OF LAST LOSER FOUND.
IFN FTSUAI,<
	CONO CAR,ONYEL		;Turn on the Yellow light!
>;IFN FTSUAI
	SKIPE P1RFLG
	JRST PARIN5		;From ERRINT
	SETZM SYSERR		;ASSUME NO ERRORS SYSTEM CORE.
	MOVE TAC,ERRPC		;GET THE ERROR PC
	TLNN TAC,USRMOD		;USER MODE?
	SETOM SYSERR		;EXEC MODE. PROBABLE SYSTEM ERROR.
PARIN5:	SETZM ERRJOB		;ZERO OUR TABLE OF LOSING JOBS
IFG <<JOBN+37>/40>-1,<
	MOVE TAC,[ERRJOB,,ERRJOB+1] ;ERRJOB table uses 32. jobs (bits) per word
	BLT TAC,ERRJOB+<<JOBN+37>/40>-1 ;Clear whole table of losing jobs
>;IFG JOBN-40
;Search physical memory for parity errors
IFKL10,<PUSH P,KLUPT+KLPFNP
IFN FTKLB,<
	MOVEI TAC,PARTRP
>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,[PCU,,PARTRP]
>;IFE FTKLB
	MOVEM TAC,KLUPT+KLPFNP
	PUSHJ P,PAREAR		;First, set up KLEAR2 to actual error address
>;IFKL10
IFN FTF2,<
	PARSTS TAC		;Get current status
	CAME TAC,PARREG		;Same as when we interrupted?
	  JRST PARIN6		;  No, scan all of memory
	PUSHJ P,PARSPU		;Check for the spurious kind
	  JRST PARIN6		;  Not spurious kind, check everything
	LDB TAC,[POINT 21-9,PARREG,26]	;Just check page in question
	HRLI TAC,-1		;One page, only
	JRST PARL0		;Do just that page.
PARIN6:
>;IFN FTF2
	MOVSI TAC,-GOODPG	;-NUMBER OF PAGES,,PAGE 0
PARL0:	MOVEI DSER,(TAC)
	LDB DSER,COREP
	CAIN DSER,NXMCUS	;IS THIS NXM CORE USAGE CODE?
	JRST PARL2A		;THIS IS A NON-EX PAGE, SKIP IT
	MOVSI AC3,PWRT		;READ WRITE EXECUTE ACCESS
	HRRI AC3,(TAC)		;PHYSICAL PAGE NUMBER
	MOVEM AC3,EXPGT+PAREXP	;STORE IN EXEC PAGE TABLE
NOKL10,<
IFE FTF2,<
	CONO PAG,1			;FLUSH ARS
>;IFE FTF2
IFN FTF2,<
	DATAO PAG,PAREXP⊗9		;FLUSH PAGE MAP FOR PAREXP
>;IFN FTF2
>;NOKL10
IFKL10,<BLKO KLPAG,PAREXP⊗9		;FLUSH PAGE MAP FOR PAREXP
>;IFKL10
	MOVE TAC1,[-1000,,PAREXP⊗9]	;AOBJN WORD FOR ONE PAGE
NOKL10,<
PARL1:	MOVE 0,(TAC1)
	CONSZ PI,PARCON
	JRST PARL3			;JUMP ON PARITY ERROR
>;NOKL10
IFKL10,<
↑PARL1:	CAMA (TAC1)		;REFERENCE MEMORY, DON'T CLOBBER AC, SKIP IF NO ERR
	 JRST PARL3		;PAGE FAULT HANDLER RETURNS HERE ON AR/ARX PAR ERR
				; WITH GOOD PARITY NOW WRITTEN IN THE LOCATION
>;IFKL10
PARL2:	AOBJN TAC1,PARL1		;RETURN HERE AFTER ERROR
PARL2A:	AOBJN TAC,PARL0			;ADVANCE TO THE NEXT PAGE
	JRST PARL5			;ALL DONE.

PARL3:	PUSH P,TAC
	PUSH P,TAC1
NOKL10,<MOVEM 0,(TAC1)			;STORE GOOD PARITY 
	CONO PI,PARCON			;SHUT OFF ERROR INDICATORS
>;NOKL10
IFKL10,<MOVE 0,(TAC1)			;READ GOOD PARITY FOR PARERF
>;IFKL10
	DPB TAC,[POINT 13,TAC1,26]	;STORE PHYSICAL ADDRESS
	TLZ TAC1,777760			;FLUSH EXTRANEOUS BITS
	PUSHJ P,PARERF			;SERVICE THIS ERROR
	POP P,TAC1
	POP P,TAC
	JRST PARL2

PARL5:	SKIPL ERRLOC		;HAS THIS BEEN SET UP?
	JRST PARL6		;YES. WE MUST HAVE PRINTED SOMETHING
	AOS NPARIN		;COUNT INDETERMINATE ERRORS
IFE FTF2,<
	PUSHJ P,DISMES		;WE DIDN'T FIND ANY.
	ASCIZ /LOCATION INDETERMINATE
/
>;IFE FTF2
IFN FTF2,<
	PUSHJ P,DISMES		;WE DIDN'T FIND ANY.
	ASCIZ /NOT REPEATABLE
/
	LDB TAC1,[POINT 21-9,PARREG,35-9]	;Extract page number
	HRRM TAC1,EXPGT+PAREXP		;STORE IN EXEC PAGE TABLE
	DATAO PAG,PAREXP⊗9		;FLUSH PAGE MAP FOR PAREXP
	LDB TAC1,[POINT 9,PARREG,35]	;Fetch offset within page
	MOVE 0,PAREXP(TAC1)		;Fetch data
	LDB TAC1,[POINT 21,PARREG,35]	;Address of error
	PUSHJ P,PARERF		;Log what we got anyway and notify user
	PUSHJ P,PARSPU		;Don't check system if user and single ECC bit
>;IFN FTF2
;	\ / (skip)
	HRROS SYSERR		;CHECK THE SYSTEM.   DEPT. OF REDUNDANCY DEPT.
PARL6:	SETZM EXPGT+PAREXP
NOKL10,<
IFE FTF2,<
	CONO PAG,1		;CLEAR ARS
>;IFE FTF2
IFN FTF2,<
	DATAO PAG,PAREXP⊗9	;FLUSH PAGE MAP FOR PAREXP
>;IFN FTF2
>;NOKL10
IFKL10,<BLKO KLPAG,PAREXP⊗9	;CLEAR HARDWARE MAP
	POP P,KLUPT+KLPFNP	;RESTORE PAGE FAULT TRAP NEW PC
>;IFKL10
	PUSHJ P,ZSHAD		;ZERO SHADOW MEMORY IN CASE WE LOST THERE.
	 JFCL			;SKIPS IF NO FAST ACS
IFKL10,<
	SKIPE TAC1,KLEAR2	;EAR address still not marked in error?
	PUSHJ P,PARERA		;Yup, note an error at this address
>;IFKL10
	MOVE TAC,SYSERR		;ERROR IN SYSTEM CORE?
	JUMPGE TAC,PARL7	;JUMP IF ERROR WAS NOT IN SYSTEM
	PUSHJ P,SYSFIX		;JUST IN CASE WE NEED THIS
	 JFCL			;NO ERROR
	 JFCL			;ERROR AND DIDN'T FIX
				;ALL FIXED.
PARL7:	PUSHJ P,DISCRLF
PARIX1:
NOKL10,<CONO PI,PARCON		;TURN OFF PAR ERR FLAG
>;NOKL10
IFKL10,<CONI APR,TAC
	ANDI TAC,4407
	CONO APR,KLCLRF(TAC)	;CLEAR ERROR FLAGS
>;IFKL10
IFN FTSUAI,<
	CONO CAR,OFFYEL		;Turn off the Yellow light!
>;IFN FTSUAI
	POPACS			;RESTORE ALL THE AC'S THAT WE SAVED
	MOVE P,PARPSAV		;GET STACK BACK (OR WHATEVER WAS IN IT).
	SETZM P1RFLG		;IN CASE FROM ERRINT

	MTRCOF (CH3,P2NOCK)

IFN FTXADR,<
	XJEN APRCHL
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@APRCHL
>;IFE FTXADR

IFKL10,<
;GET HERE ON A PAGE FAULT DURING PARITY ERROR SCAN
PARTRP:	CONSZ PI,1B20-1B26⊗(7-APRCHN)	;In progress at higher level than APRCHN?
	HALT .				;PAGE FAULT FROM CH1 OR CH2!!!??
	LDB AC1,[POINT 5,KLUPT+KLPFW,5]	;GET FAILURE TYPE
	CAIE AC1,36
	CAIN AC1,37
	JRST PARTR1
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ \PAGE FAULT OTHER THAN AR/ARX PAR ERR AT PARTRP
\
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	HALT .-1

PARTR1:	AOS KLUPT+KLPFPC		;FORGIVE US...SEE PARL1
	DATAI KLPAG,DAT			;SAVE AC CONTEXT
	CONI PI,AC3
	ANDI AC3,PION
	TLZ DAT,300000
	MOVE AC1,DAT
	TLO AC1,700
	SYSPIFF
	DATAO KLPAG,AC1			;KEEP CURRENT CONTEXT, SET PREV TO 7
	XCTR XR,[MOVE AC2,0]		;GET GOOD PARITY DATA FROM AC BLK 7 REG 0
	DATAO KLPAG,DAT			;PUT AC CONTEXT BACK
	CONO PI,(AC3)			;PUT PION BACK THE WAY IT WAS
	HRRZ DAT,KLUPT+KLPFW
	MOVEM AC2,(DAT)			;STORE GOOD PARITY IN MEMORY
IFE FTKLB,<
	JRST 2,@KLUPT+KLPFPC
>;IFE FTKLB
IFN FTKLB,<
	XJRSTF KLUPT+KLPFFG		;restore flags/PC from double word

;Here if parity error has stored trap PC with nonzero section
PARNZS:	EXCH TAC,KLUPT+KLPFPC	;restore TAC, fault PC
	MOVEM P,PARPSAV		;ASSUME WE HAVE NO AC'S.
	MOVE P,APRPDL		;GET A STACK.
	PUSHACS			;SAVE ALL THE AC'S
	PUSHJ P,DISGST		;print time of error on CTY
	PUSHJ P,DISERR
	 [ASCIZ/Parity error from PC with Non-Zero Section Number!  PC = /]
	 DISARG OHS,KLUPT+KLPFPC
	 [ASCIZ/
Page Fail Word = /]
	 DISARG OHS,KLUPT+KLPFW
	 [ASCIZ/   Page Fail PC Flags = /]
	 DISARG OHS,KLUPT+KLPFFG
	 -1
	PUSHJ P,DISCRLF
	POPACS
	PUSHJ P,WDDTCAL
	MOVE P,PARPSAV		;restore P
	HALT .			;you tell me where to go next to get out
>;IFN FTKLB
>;IFKL10

IFN FTF2,<
;Here with parity register in TAC.  Decide whether it is significant or not.
;Skip if correctable.
PARSPU:	TLNE TAC,(77-1)⊗4	;ECC 01?
	TLNN TAC,(77-2)⊗4	;ECC 02?
	  JRST CPOPJ1		;  Yes, probably OK
	TLNE TAC,(77-4)⊗4
	TLNN TAC,(77-10)⊗4
	  JRST CPOPJ1
	TLNE TAC,(77-20)⊗4
	TLNN TAC,(77-40)⊗4
	  JRST CPOPJ1		;  Yes, probably OK
	POPJ P,			;We'd better look more carefully
>;IFN FTF2
;PARERF PARERA PARER1 PARR1B PARR1C PARR1A PARER2 PARER3 PARR3A PARR3B PARR3C PARR3D PARER4 PARR4A PARER5 PARER6 PARER8 PARVIR PARVI1 PARVI0 PARVIX

SUBTTL  HERE WHEN A REAL ERROR IS FOUND.

;HERE WHEN WE FIND AN ERROR IN CORE.  TAC1 HAS PHYSICAL ADDRESS AND 0 HAS GOOD DATA
PARERF:
IFKL10,<
	CAMN TAC1,KLEAR2	;IS THIS WHERE THE EAR POINTS?
	SETZM KLEAR2		;YES, DON'T NEED TO LIST EAR ADDR LATER
PARERA:
>;IFKL10
	MOVE TAC,ERRLOC		;REMEMBER OLD VALUE OF ERRLOC
	MOVEM 0,ERRDAT		;SAVE ERROR DATA
	MOVEM TAC1,ERRLOC	;SAVE PRESENT ERROR LOCATION
	JUMPGE TAC,PARER1	;JUMP IF THIS IS NOT THE FIRST TIME HERE.
	PUSHJ P,DISMES		;PUT OUT THE HEADING
IFE FTF2,<
	ASCIZ /   LOC         DATA     	RELOC    NAME(J)
/ >;IFE FTF2
IFN FTF2,<
	ASCIZ /   LOC        DATA      ECC RELOC    NAME(J)
/ >;IFN FTF2
PARER1:	AOS NPARER		;COUNT NUMBER OF PARITY ERRORS
	MOVE TAC,ERRLOC		;GET LOCATION
	PUSHJ P,DISADR		;WRITE LOCATION
IFN FTF2,<
	PUSHJ P,DISMES		;WRITE 2 SPACES
	ASCIZ /  /
>;IFN FTF2
IFE FTF2,<
	PUSHJ P,DISMES		;One space for F2 (we need more room for ECC)
	ASCIZ / /
>;IFE FTF2
IFKL10,<
	SKIPE TAC,ERRLOC
	CAME TAC,KLEAR2		;IS THIS THE EAR'S ADDRESS?
	JRST PARR1B		;NO, TYPE DATA NORMALLY
	PUSHJ P,DISMES		;Yes, then the data isn't known
	ASCIZ/(unknown data)/	;(Same text length as DISOCH makes.)
	JRST PARR1C

PARR1B:
>;IFKL10
	MOVE TAC,ERRDAT		;GET DATA
	PUSHJ P,DISOCH		;WRITE LOSING DATA AS OCTAL HALF WORDS
PARR1C:
IFE FTF2,<
	PUSHJ P,DISTAB		;PUT NEXT THING UNDER HEADING
>;IFE FTF2
IFN FTF2,<
	PUSHJ P,DISMES
	ASCIZ / /
	PARSTS TAC		;Get error bits
	PUSH P,TAC		;Save it while we check address
	TLZ TAC,777770
	CAME TAC,ERRLOC		;Is this our address?
	  JRST PARR1D		;  No, then we don't know the losing ECC
	LDB TAC,[POINT 6,(P),13]	;Print code
	MOVEI TEM,"0"		;Do we need a leading zero?
	TRNN TAC,70
	  PUSHJ P,DISTYO	;  Yes
	PUSHJ P,DISLOC		;Print ECC code
	JRST PARR1E
PARR1D:	PUSHJ P,DISMES
	ASCIZ /??/
PARR1E:	POP P,TAC
	PUSHJ P,DISMES
	ASCIZ / /
>;IFN FTF2
	LDB DSER,[POINT 13,ERRLOC,26]	;PAGE NUMBER OF ERROR (LOC = DSER)
	LDB J,COREP
	CAIGE J,JOBN		;IS THIS A SPECIAL CODE?
	JUMPG J,PARER4		;JUMP IF CORE IS ASSIGNED TO NORMAL JOB
PARR1A:	CAMN J,LASLOS		;SAME AS LAST LOSER?
	JRST DISCRLF		;YES. JUST TYPE A CRLF AND RETURN
	MOVEM J,LASLOS		;SAVE CODE FOR LAST LOSER
	JUMPG J,PARER2		;JUMP IF NOT UNASSIGNED CORE
	PUSHJ P,DISMES		;FOR UNASSIGNED CORE
	ASCIZ /UNUSED
/
	POPJ P,			;RETURN LOOK FOR MORE.

PARER2:	CAIE J,SYSCUS			;IS THIS THE SYSTEM?
	JRST PARER3			;NO. MUST BE FREE STORAGE.
	HRROS SYSERR			;REMEMBER TO CHECKSUM THE SYSTEM
	PUSHJ P,DISMES
	ASCIZ /SYS
/
	POPJ P,

PARER3:	CAIE J,IOBCUS		;IS THIS AN IO BUFFER?
	JRST PARR3A		;NO
	PUSHJ P,DISMES
	ASCIZ /IO
/
	POPJ P,

PARR3A:	CAIE J,FSCUS		;IS THIS FREE STORAGE?
	JRST PARR3B		;NO
	PUSHJ P,DISMES
	ASCIZ /FS
/
	POPJ P,

PARR3B:	CAIE J,P2MCUS		;IS THIS P2 MEMORY?
	JRST PARR3C		;NO
	PUSHJ P,DISMES
	 ASCIZ /P2 MEM
/
	POPJ P,

PARR3C:	CAIE J,PGTCUS		;IS THIS A PAGE TABLE?
	JRST PARR3D		;NO
	PUSHJ P,DISMES
	 ASCIZ /PG TBL
/
	POPJ P,

PARR3D:	PUSHJ P,DISMES		;UNKNOWN CORE USAGE CODE FROM CORTAB!
	 ASCIZ /UNKNOWN
/
	POPJ P,

PARER4:	PUSH P,J		;SAVE JOB NUMBER
	MOVE TAC,ERRLOC
	PUSHJ P,PARVIR		;GET VIRTUAL ADDRESS OF ERROR
	MOVEM TAC,RERLOC	;SAVE RELOCATED ERROR LOCATION.
	PUSHJ P,DISLOC		;TYPE 6 CHARACTERS
	MOVE J,(P)		;GET THE JOB NUMBER INTO J AGAIN
	CAMN J,LASLOS		;SAME AS LAST TIME?
	JRST PARR4A		;YES. DON'T TELL JOB NAME AGAIN
	MOVEM J,LASLOS		;REMEMBER FOR NEXT TIME
	PUSHJ P,DISTAB		;TYPE A TAB FOR SEPARATION
	MOVE J,(P)		;MAKE SURE NO ONE CLOBBERS J.
	PUSHJ P,DISJOB		;TYPE JOB NUMBER(JOB NAME)
PARR4A:	PUSHJ P,DISCRLF
IFN FTF2,<
	PARSTS TAC		;Get error bits
	PUSH P,TAC		;Save it while we check address
	TLZ TAC,777770
	CAME TAC,ERRLOC		;Is this our address?
	  SETOM (P)		;  No, make sure to warn user
	POP P,TAC
	PUSHJ P,PARSPU		;Is this error correctable?
	  SKIPA
	  JRST TPOPJ		;  Yes. "What me, worry?"
>;IFN FTF2
	MOVE J,(P)		;RESTORE J (AGAIN) 
	MOVE TAC,JBTSTS(J)	;GET THE JOB STATUS WORD
	TLNN TAC,JSEG		;IS THIS REALLY AN UPPER?
	JRST PARER8		;NO, JUST A SIMPLE LOWER.
	PUSHJ P,MARKERR		;HAS THIS UPPER LOST BEFORE (OR IS IT FIXABLE)?
	 JRST TPOPJ		;YES. DON'T TELL LOWERS AGAIN
	MOVEI TAC,400000	;IN CASE OF A SEGMENT
	ADDM TAC,RERLOC		;ADD 400000 TO RELOCATED ERROR ADDRESS
	MOVEI J,JOBN-1		;FOR ALL THE JOBS IN THE WORLD....
PARER5:	LDB TAC,PSEGN		;GET THE JOB NUMBER OF THIS GUY'S UPPER
	CAME TAC,(P)		;SAME AS THIS UPPER?
	SOJG J,PARER5		;NO.
	JUMPLE J,PARER6		;JUMP IF NO MORE USERS OF THIS UPPER
 	PUSH P,J		;SAVE THIS JOB ON THE STACK
	PUSHJ P,TELUSR		;TELL A LOWER SEGMENT.
	POP P,J
	SOJG J,PARER5		;DECREMENT J AND LOOK FOR MORE.
PARER6:	POP P,J			;GET THE NUMBER OF THIS UPPER.
	MOVE TAC,PRJPRG(J)	;GET A RIDICULOUS NAME
	MOVEM TAC,JOBNAM(J)	;SAVE IT AS THE JOB NAME
	POPJ P,			;NO ONE WILL ATTACH TO THIS AGAIN.

PARER8:	PUSHJ P,TELUSR		;TELL THE USER ABOUT WHAT BEFELL HIM
	JRST TPOPJ		;ADJUST STACK AND RETURN.

;CONVERT PHYSICAL ADDRESS IN TAC INTO VIRTUAL ADDRESS, J HAS JOB NUMBER
PARVIR:	PUSH P,TAC1
	PUSH P,AC1
	LDB TAC1,[POINT 13,TAC,26]	;GET PHYSICAL PAGE NUMBER
	PUSH P,TAC1
	ANDI TAC,777
	HLLZ TAC1,JBTPAG(J)
	MOVN TAC1,TAC1			;- # PAGES
IFE FTMPP2,<	SKIPN AC1,JBTMAP(J)	>
IFN FTMPP2,<	PUSHJ P,JOBMAP		>	;GET EXEC VIRTUAL UPMP #
	 JRST PARVI0
	LSH AC1,9
	PUSH P,AC1
	HRR TAC1,AC1			;AOBJN POINTER TO PAGE TABLE
PARVI1:	HRRZ AC1,(TAC1)			;GET PAGE MAP ENTRY
	CAME AC1,-1(P)
	AOBJN TAC1,PARVI1
	JUMPGE TAC1,PARVI0		;DIDN'T FIND IT
	SUB TAC1,(P)			;GET RELATIVE PAGE NUMBER INTO RH OF TAC1
	LSH TAC1,9
	TROA TAC,(TAC1)
PARVI0:	MOVEI TAC,0
PARVIX:	SUB P,[2,,2]
	POP P,AC1
	POP P,TAC1
	POPJ P,
;TELNXM PARBUZ TELUSR TELUSN TELUSB TELUSA TELUS1 TELU1X TELU1Y TELU1Z TELUSC TELNXC TELUS2 TELUS3 TELUS4 MARKERR DSKFIX DSKFX1 PAREAR

SUBTTL  TELL THE USER ABOUT THE ERROR

;Here when user ref'd non-ex memory, probably after doing weird GETHI uuo.
;Stop user or give him a NXM interrupt.  Datum will be physical address of NXM.
;Called from ERRINT in KLSER, in CH3.
IFKL10,<
↑TELNXM:MOVE J,JOB		;Error happened at user level for current job
	PUSHJ P,DSKFIX		;CLEAR GOBIT IF DISK ACTIVE
	PUSHJ P,PAREAR		;FIGURE OUT PHYSICAL ADDRESS OF NXM
	MOVEM TAC1,RERLOC	;REMEMBER PHYSICAL ADDRESS AS DATUM OF ERROR
	MOVEI TAC,NXM		;MAYBE GIVE USER NXM INTERRUPT
	SETOM GOTNXM		;SET FLAG TO MAKE TYPEOUT SAY NXM, NOT PARITY ERR
	JRST TELUSN		;OTHERWISE LOOK LIKE PARITY ERROR
>;IFKL10

PARBUZ:	JRST .			;BUZZ HERE UNTIL CH7 INTERRUPTS

;Tell user about parity error.
TELUSR:	PUSHJ P,MARKERR		;MARK THIS JOB HAS ERROR
	 POPJ P,		;HE'S BEEN TOLD BEFORE.
	PUSHJ P,DSKFIX		;REPAIR GOBIT
	MOVSI TAC,INTPAR	;PICKUP PARITY ERROR ENABLE BIT
TELUSN:	TDNE TAC,JBTMSK(J)	;MASKED OFF
	TDNN TAC,JBTIEN(J)	;IS THIS USER ENABLED FOR THIS?
	JRST TELUS1		;NO. TELL HIM AND STOP HIM
	CAMN J,JOB
	SKIPN INTACT
	JRST .+2
	JRST TELUS1		;CAN'T TAKE ANOTHER INTERRUPT
	IORM TAC,JBTIRQ(J)	;SET PARINT BIT FOR THIS USER
	SETOM INTREQ		;REQUEST A USER INTERRUPT
	MOVE TAC1,RERLOC	;GET THE RELOCATED ADDRESS OF ERROR
	MOVEM TAC1,INTDTM(J)	;SAVE IT FOR THIS USER.
	CONSZ PI,1B27⊗(7-APRCHN);CHANNEL 3?
	JRST TELUSB		;NO.  DON'T WORRY ABOUT DISMISSING TO CH7
	SETZM GOTNXM		;Giving interrupt, so definitely no NXM msg
NOKL10,<MOVEI TAC1,PARBUZ
>;NOKL10
IFKL10,<MOVE TAC1,[PCU,,PARBUZ]
>;IFKL10
IFN FTXADR,<
	EXCH TAC1,APRCHL+1
>;IFN FTXADR
IFE FTXADR,<
	EXCH TAC1,APRCHL
>;IFE FTXADR
	TLNN TAC1,USRMOD
	JRST TELUSA
	MOVEM TAC1,USAVPC	;HIS ACTUAL OLD PC
TELUSB:	CONO PI,4000+1⊗(7-CLKCHN);REQUEST INTERRUPT ON CLOCK CHANNEL
	HLLOS CLKFLG
	POPJ P,

TELUSA:
IFN FTXADR,<
	EXCH TAC1,APRCHL+1	;PUT BACK THE PC, IT WAS EXEC MODE
>;IFN FTXADR
IFE FTXADR,<
	EXCH TAC1,APRCHL	;PUT BACK THE PC, IT WAS EXEC MODE
>;IFE FTXADR
	JRST TELUSB

;USER NOT ENABLED FOR PARITY ERROR.  STOP HIM!
TELUS1:	MOVE TAC,JBTLIN(J)
	AOJE TAC,TELU1X		;JUMP IF DETACHED JOB
	SKIPN TAC,TTYTAB-1(TAC)	;-1 BECAUSE OF AOJE
	JRST TELU1X		;NO DDB (?)
	MOVSI AC3,PTLIP		;CLEAR PTLOAD-IN-PROGRESS BIT
	ANDCAM AC3,DEVIOS(TAC)
TELU1X:	HRRZ TAC,RERLOC
	HLRZ AC3,JBTPAG(J)	
	LSH AC3,9
	SUBI AC3,1		;PROTECTION OF JOB
	CAILE TAC,(AC3)		;LOWER OR UPPER?
	TLO TAC,400000		;FLAG UPPER
	MOVEM TAC,INTDTM(J)	;SAVE DATUM FOR LATER
	HRLI J,TELUSC		;CLOCK LEVEL ROUTINE TO COMPLETE OUR WORK
	SYSPIFF
	IDPB J,CLKQ		;USE 1-TICK DPYSER CLOCK QUEUE
	SYSPIN
	ANDI J,-1		;JOB NUMBER ONLY.
	CONSZ PI,1B27⊗(7-APRCHN);CHANNEL 3?
	CAME J,JOB		;YES. IS THIS THE CURRENT JOB?
	JRST TELU1Y		;NOT CURRENT JOB OR NOT CH3
NOKL10,<MOVEI TAC1,PARBUZ
>;NOKL10
IFKL10,<MOVE TAC1,[PCU,,PARBUZ]
>;IFKL10
IFN FTXADR,<
	EXCH TAC1,APRCHL+1
>;IFN FTXADR
IFE FTXADR,<
	EXCH TAC1,APRCHL
>;IFE FTXADR
	TLNN TAC1,USRMOD
	JRST TELU1Z		;OOPS. CAN'T STOP HIM IN EXEC MODE
	MOVEM TAC1,USAVPC	;HIS ACTUAL OLD PC FOR CH7
TELU1Y:	JRST STOP1

TELU1Z:
IFN FTXADR,<
	EXCH TAC1,APRCHL+1	;MUST DISMISS BACK TO EXEC MODE
>;IFN FTXADR
IFE FTXADR,<
	EXCH TAC1,APRCHL	;MUST DISMISS BACK TO EXEC MODE
>;IFE FTXADR
	JRST TELU1Y

;HERE AT CLOCK LEVEL TO FINISH FLUSHING LOSER
TELUSC:	MOVEI J,(DAT)
	PUSHJ P,TTYERR		;GET THE USER'S TTY
	AOSN GOTNXM		;Skip unless this is really a NXM
	JRST TELNXC		;Different message for NXM, of course
	SKIPGE INTDTM(J)	;IN LOWER?
	JRST TELUS2		;NO. IT IS IN THE UPPER
	PUSHJ P,INLMES		;STUFF DATA INTO TTY
	ASCIZ /Parity error in your core image at location /
	JRST TELUS3

;Here at clock level to tell loser of NXM
TELNXC:	PUSHJ P,INLMES
	ASCIZ /? NXM reference to non-ex physical location /
	MOVE TAC,INTDTM(J)	;Get phys location
	PUSHJ P,OCTPNT		;Print it in octal
	MOVE TAC,NXMPC		;Get back PC at time of NXM
	PUSHJ P,PCP		;Print PC
	JRST TELUS4

TELUS2:	PUSHJ P,INLMES
	ASCIZ /Parity error in your upper segment at location /
TELUS3:	HRRZ TAC,INTDTM(J)	;GET THE RELOCATED ERROR
	PUSHJ P,OCTPNT		;TELL HIM THE LOCATION.
TELUS4:	PUSHJ P,PRCRCC		;Print CR, ↑C, and dot
	PUSHJ P,TTYSTR		;START THE USER'S TTY TYPING
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JLOG		;LOGGED IN?
	POPJ P,			;YES. LEAVE NOW.
	JRST ESTOP		;NO. KILL THE PHANTOM

;CALL THIS ROUTINE TO SEE IF HE NEEDS TO BE TOLD
;WILL TRY TO REPEAT SWAPIN IF POSSIBLE

MARKERR:				;PUSHJ HERE TO MARK JOB IN J AS HAVING ERROR.
	MOVEI TAC,(J)			;GET JOB NUMBER
	MOVEI TAC1,0
	LSHC TAC,-5
	ROT TAC1,5
	MOVEI AC3,1
	ROT AC3,-20(TAC1)		;ROTATE TO AN UNUSUAL POSITION
	TDNE AC3,ERRJOB(TAC)		;IS THIS BIT SET ALREADY?
	POPJ P,				;YES.
	IORM AC3,ERRJOB(TAC)		;NO. SET IT
	MOVE TAC,RERLOC
	HLRZ AC3,JBTPAG(J)	
	LSH AC3,9
	SUBI AC3,1			;PROTECTION OF JOB
	CAIG TAC,(AC3)			;CAN'T FIX HIS UPPER HERE
	SKIPE STIME(J)			;NOW SEE IF THE SWAPPER CAN FIX IT
	JRST CPOPJ1			;MODIFIED SINCE SWAPIN
	HLRZ TAC,JBTSWP(J)
	JUMPE TAC,CPOPJ1		;NOT SWAPPED OUT YET
	SKIPN XJOB(J)
	AOS XJOB
	AOS XJOB(J)			;THIS SHOULD MAKE IT GET SWAPPED
	POPJ P,

;CLEAR GOBIT SO JOB DOESN'T HANG.  (CALLED ALSO FOR SWAP READ ERROR)
↑DSKFIX:SKIPA DDB,[DSKDDB]		;INITIALIZE SCAN
DSKFX1:	ANDCAM TAC1,DEVIOS(DDB)		;FLUSH ACTIVE BITS
	PUSHJ P,STOPC2			;(CLKSER). LOCATE ACTIVE DSK DDB FOR JOB
	JRST DSKFX1			;FLUSH GOBIT, CONTINUE SCAN
	POPJ P,				;NO MORE ACTIVE DSK DDBS

IFKL10,<
PAREAR:	SETZB TAC1,KLEAR2		;Assume no saved EAR value
	EXCH TAC1,KLEAR			;Get saved error address register
	JUMPE TAC1,CPOPJ		;Return quick if no EAR saved
	LDB TAC,[POINT 2,TAC1,1]	;Get offset of error within 4-wd block
	TRZ TAC1,3			;Flush low bits
	ADDI TAC1,(TAC)			;Make actual error address
	TLZ TAC1,777760			;Clear non-address bits
	MOVEM TAC1,KLEAR2		;Remember for suppressing duplicate msg
	POPJ P,
>;IFKL10

BEND PARSER
