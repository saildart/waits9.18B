COMMENT ⊗   VALID 00178 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00017 00002	III DISPLAY PACKAGE - D. POOLE - NOV 1968
C00020 00003	PBAKCL GRBAKB GRVECB SIZSBU POSSBU LHCSBU GHCSBU LEWRBP LEWRBT LEWJBP HLINES HGLTCH BDUNIT BD300 BD1200 BD2400 BD4800 BD9600 B10000 BDMAX DMBAUD BDDFT BDDFT PCDFT PADDFT NGSIII NGSDD NGSDM NLSIII NLSDM NLSDD NLSDD YPIII YPDD YPDM NDDSPQ YLINE HGTIII HGTDD HGTDD HGTDM MAXLIN MINLIN MAXCOL MINCOL OUTNUM LINELN DDLINELN DDLINELN CBLKBT TBLKBT FBLKBT
C00027 00004	DWPINI DWPERR DPYATL
C00030 00005	DPYMAK DPYM0 DPYM0A DPYM1
C00034 00006	DPYMNG DPYMGS DPYM3
C00041 00007	 DPYXIT DPYXTL DPYM9 SCNFFJ SCNONJ
C00047 00008	DPYM4 DPYM5 DPYM6 DPYM7 DPYM8 PPSET
C00050 00009	DPYM2 DDWIPE DDMAP DDMAP1 DDMAP3
C00054 00010	 DPYKIL DPYK00 DPYKI8 DPYK4A DPYKI4
C00060 00011	DMCLRU CLKFLS CLKFL1 CLKFL2
C00063 00012	SPIONJ DPYKI2 DPYKI3 DPYKL1 DPNONO DPNOT4
C00066 00013	 TPTINT TPTIN2 TPTIN3 DPKSTR DPKST2 DPKRLP DPKROL DPNODP DPNOT3 DPYKML
C00071 00014	DPYK12 DPYK11 DPYKFS DPYKF1 DPYKF2 DPYKF3
C00075 00015	DPYKS7 DPYKS9 DPYKI9 DPYK9 DPYKI7 DPYKI6 SCLOCK SCLOC2 CLRLED DPYKER
C00080 00016	DPYINT NOSTOP L6 L5 L3 DPYXIT
C00083 00017	DPERR DPENNX NOADDR NOMBSY NODPLK L8 L9
C00087 00018	L2 L1 L1A L4 L7
C00089 00019	PPINIT PPI1 PPI3 -- PAGE PRINTER STUFF
C00093 00020	 PPINNP PPFXT
C00097 00021	PPFSGE CGETFS UGFS2 UGETFS CGIVFS UGIVFS GETQ UGETF2 UGETF1 UGETF3 UGETF4
C00102 00022	BELOW IS THE PROTOTYPICAL P. OF P. CONTROL BLOCK.
C00109 00023	DTYO DPYTYO TYO0
C00112 00024	TYO5 TYO1 TYO2 TYO7 DELNOW IIILED IIILE2
C00117 00025	TYO4 PR1TAB PR1TB1
C00119 00026	PRCR PRCR3 PRCR2 PUT2CH PUTCH1 PUT2C3 PUT2C4 PUT2C2
C00122 00027	PR1ECR PR1EC1 PR1EC3 SETLL
C00125 00028	PR1EC2 PR1EOL PR1EO2 PREOGL
C00127 00029	EXTBUF L2 L1 GBLK
C00131 00030	GLITCH GLTCH1 GLTCH3 GLTCH9 PR1EL4 ADJSIZ CNTWRP GLTCH8 GLTCH4 GLTCH5 GLTCH7 GLTCH6
C00135 00031	EOLSET EOLSE2 EOLSE3
C00138 00032	GLNADR GLNAD1 GLNAD2 GLNAD3 GLNAD4 GLNAD6
C00139 00033	GLNAD5 GLNAD7 HELPX
C00141 00034	POSLIN POSLDD POSLDM POSLD2 POSLII
C00143 00035	FBLK FB1 PR1FRE PR1ER2
C00146 00036	PR1ER3 PR1ERR PR1ER1
C00149 00037	PPOUT SETRST PPRST
C00151 00038	ERRP2 ERRP3
C00152 00039	PPFND1 PFL2 PPFND PPFER
C00156 00040	PPREL PPREL2 PPREL3 PPREL4 PPSEL0 CLKREL
C00161 00041	PPSELU PPSEL PPSELN PPSELX
C00164 00042	PPACT0 PPACT PACTL1 PACTL2 PACTL3 PACTL4
C00168 00043	PPWAIT PPWAT2 APSCON HPWAIT HPWAID
C00172 00044	PPYPOS PPYPO1 PPYPO4 REFPAG PPYPO6 PPYPO3
C00175 00045	PPYPO2 PPYPO5 PPYPDN PPYPDM
C00178 00046	PPERS
C00181 00047	DMERS PTMOVE PTMOV1 PTMOV2 PTMOV3 PTMOV4
C00184 00048	PPXSIZ PPX1 PPX2 PPXERR
C00188 00049	DPYCLK CLKL1 CLKRTN DDFSER
C00193 00050	WHOQUE WHOQ2 WHOQ4 WHOQ3 WHOQ4 WHOQ1 WHORPT
C00199 00051	WHOQDM WHOQD2
C00202 00052	FREE GETFS POPAJ CLKWAT ARRRGH
C00204 00053	PRGFND PRGF1 PRGF2 PRGF3 PRGFER PRGFE1 DDFND
C00207 00054	PPIOT
C00208 00055	DPYCLR DPYRST PPCLR PPC1 PPC3 PPC2 PPC4 PPCLRX
C00214 00056	WHONOW PPNST2 PPNSET PPNST1 SETPHD PPGSET PPGST2 PPGST1 DMNORM
C00217 00057	PPLSET PPYSET PPYS2 PPYDD PPYDM PPYS3 PPYIII
C00220 00058	PPHLD PPHLD1 PPHLD2 AC1CLK
C00222 00059	PPSPY PPSPY2 PPINFO PPSPIE PPINF1 PPSPY1 PPLNCT
C00230 00060	LEYPOS CURSET FOOFRL FREEL
C00233 00061	DMUPG0 DMUPG DMUPG2 DMUPG3 DMUPGE CHASER CHASEM CHASE3 FREEZE RSTFRZ
C00244 00062	 DMUWHO DMUDUN DMUCLK DMUCER DMUCL2 DMUUUO DMUUU2
C00248 00063	QDMPP QDMGLC QDMERS QDM
C00251 00064	UPSIII UPGRIN UPGIOT T2 PBSZ SIZE PGWC PGSA PGNP UPGRNS L1
C00257 00065	LOOP UPCHK UPCHK1 UPGTB SPECOP DONE UPREL UPREL1 UPRERR UWC0
C00264 00066	SPCIII SPCDD SPCGRN GRSLM DDCMD JLINK SPCC1 SPCC2 GSLCHK GSLCH1 SPCJMS SPCILM
C00268 00067	SPCTBL SELCHK LOOPS DCHNOK
C00270 00068	ADRRST ADROP ILLAD ILL1 ILLJMS HLTOP UPGER1
C00273 00069	DDUPG DDCWL DDCINC DDUIII DDGRIN
C00277 00070	DDWAIT APRONJ UPGQ
C00281 00071	DDSCHN
C00284 00072	CHKAD CHKAC1 CHKAC2 CHKAC3 CHKAC4 CHKADR
C00287 00073	CHAD MYCHN ILLCHN
C00289 00074	PGSET PGSETA PGSET1 PGSET2 PGSL1
C00292 00075	DPYERR DPYER1
C00294 00076	UPGMVM UPGMOV UPGMV
C00297 00077	PGIOT PGMAX PGSEL VPGACT PGACT PGACL PGAC1
C00300 00078	PGCLR PGCLR1 PGINFO PGCLP PGSZ PGCNT PGXLP
C00303 00079	DPYTY1 DPYERT DPYTYP DPYTY4 DPYTY5 DPYTY2 DPYTY6 DPYTY3
C00307 00080	DPYTL1 DPYTL0 DPYTL2 DPTL2A DPTL2B
C00311 00081	DPYTL3 DPYTL4 DPYTER
C00313 00082	STAR0 STAR IISTAR
C00316 00083	DMSTAR DMSTA2 UNHDM CHASPP CHASP3 CHASP4
C00319 00084	UNHOLD UNHIII
C00322 00085	DPTDD DPTDDK DPYTLN DPYTIM DPYTL5
C00324 00086	QDMCLK QDMR QDMR1 QDMR2
C00328 00087	DMNXBK DMNONX DMNON3 DMNON2 DMNON4
C00331 00088	DMNON5 DMNON6 DMNON7 DMNOQB DMNOHD DMQGLC DMXSIZ DMPPST STRTEX
C00335 00089	DMSHFT DMSHF0 DMSHF1 DMSHF2 DMSHF3 DMSHF4
C00339 00090	DMSHF5 GLTCHX GLTCHZ DMSTHD
C00343 00091	START RESET ENB LOSENB DAMMIT DDUSRM DDNXM USUAL FIELD INT LOSE
C00345 00092	QLINE QFIELD QHPOS QLINK QWAKE QCOUNT QTIME QINSTR QPDL QPDL2 QACCT QLENGTH QFLAGS QTAKR QDMCNT QXY QLINK QWAKE QCOUNT QFREE QINSTR QXYLOC QPUTR QTEXT QTEXTL
C00349 00093	QDDR DOXFR
C00353 00094	QDD1 NOPAGE
C00356 00095	DPTDL DPYTLX AC2CLK
C00360 00096	LEERS LEERSN RFPCS LEERS2 LEERS3 LEPGC LEPGC2
C00363 00097	REFLIX REFLINE REFLN2
C00366 00098	LECLRS LECLR2 LECLR3 LECLR4
C00370 00099	LERFP LERFPW Q2BLCK LERFP1
C00373 00100	GET2Q LERELE PPCLB
C00375 00101	LERDM LEPDM LEPDM0 LEPDM4 LEPDM1
C00379 00102	DMFORC LEPDM2 LEPDM5 LEPDM3 TBDONE INDONE LEPDMC
C00385 00103	USFLUS USFLU3 PPFLUS PPFLU3 PPFLU2 DMFLUS DMFLU2 DMFLU3
C00389 00104	DMLED0 DMLED5 DMLED DMLED4 DMLED9 DMLED7 STRTDM STRTD2
C00394 00105	DMNDDB DMEOSL
C00396 00106	DPLEDR DPLED DPLED2 DPLED3 DPLEVS
C00400 00107	DPLEOK DPLGC1 DPLGC2
C00403 00108	NOLETX DPTL14 DPLGCP
C00406 00109	DPTLE1 DPTL1A DPTL1B DPTL1C DPTL1D
C00410 00110	DPTLE6 DPTLE9 DPTLE7 DPTLE2 DPTLE8 DPTL11 DPTLE3
C00413 00111	DPTLE4 DPTL12 DPTLE5 - EVERYBODY COMES HERE TO EXIT
C00415 00112	DPWT DPWT1 DPWT2
C00418 00113	DPEOSL
C00420 00114	DPEC DPEOPC DPEC1 DPEC2
C00422 00115	DPWPC DPWPC1 DPWPC2 DPWC DPWB
C00425 00116	QBLOCK QBLK QBLDBG REQBLK QGRFLS
C00431 00117	QBLCLK QBLCLC QBLGO
C00435 00118	QBL1 CNXTFR QBL6 QBL7
C00438 00119	QOOB GIVQB QBLERR WAKEQ
C00441 00120	QBL3 MAKFRM QBL4
C00444 00121	QBL8 QBL5 QBL9 QBLXIT
C00446 00122	DDQCHK DDQCH1 DDQCH4 DDQCE3 DDQCE2
C00448 00123	DDQCE1 DDCKR1 DDCKR3 DDCHER DDTSCH DDTSC2 DDTSC1
C00450 00124	DDTSE4 DDTSE3 DDTSE2 DDTSE1 DDCKR2
C00452 00125	SCPIER QBNODD QBNOD2
C00456 00126	GGRPH G1COM G2COM
C00457 00127	DDSTRT NEWFRM SCNLOP
C00461 00128	RESCAN DDEXIT
C00463 00129	DDREQ DDREQ1 DDREQ3 DDREQ2 PPWAKE USWKLE
C00466 00130	DMDEQ DEQ DEQWAK PPWAK2 DEQ2
C00469 00131	DEQ1 GIVQ DEQERR
C00471 00132	PPXFR
C00476 00133	PPXFR1 PPXFR2 PPXFR3 PPXFR4 ILLPP
C00478 00134	ERASE CWAIT
C00483 00135	CURSOR CURNOR CURREL CDX CURS2 CURS1
C00489 00136	CURERR CMAKE CMAKE1 CMAKE2
C00492 00137	LEXFR LEXFR4 LEXNOR LEXREL
C00497 00138	LEXFR1 LEXFR2 LEXFR3
C00499 00139	WSE WSENOR WSEREL WHOWRT WHOWR2 WHOWR4 WHOWR3 WHOWR5 WHOWR1
C00505 00140	POG POG0 POG1 POGCLK  -  USER DATA DISC PROGRAM
C00509 00141	PPSTAR POGX1 POGX2
C00512 00142	ISYNCU ISYNC DDISM DDINT DDINT2
C00516 00143	DDNX DDINT1 DDCMR DDCLK DDIXIT DDIXI1
C00519 00144	 DDILL DDILL2
C00521 00145	GSENDC GSEND1 GSEND2 GSENDZ GSENDY
C00524 00146	GRNSIM GRNSI1 GRNLOP
C00527 00147	GRSDSP GRNILL GRNJM0 GRNJMP GHALT WLVW ISABS WSVW IIISV GSHV GCOM1 GCOM2 GRNPAR GRNPDS $GMSEL $GMSII
C00537 00148	GPCHK GPTAB GPWID GPLDC GPWGD GPWAC GPLER GPLEA GPLEB GPLEC GPLLR GPLLA GPLLB GPLLC
C00543 00149	GCDD GCDSP CG6 CG0 CG1 GCMPM GCCSND GGRAPH CG2 CG7 CG3 CG4 CG5 CG4COM
C00551 00150	MAKEV MKVRTN VVIS ADDIN
C00555 00151	GRNCHR STALE CLOOP SNDIT SPCRET NOTYET GR177 GC177 GC11 GC15 GCEOLD GCCEOL GCCEO2 GCCEO3 GC12 SNDSPC GTXLP
C00564 00152	DDLNK DDALST DDBADB DDKILL DDANYW DDSMSK DDUSR DUSRMK DTTUSR DTTL0 DSPUSR DDUSR2 DDAVLU DDDETU DDPRVT DDELNK DDCLST DDGBIT DDSBIT DDGMOD DDUSET VDOP VDPERM VDABSO VDXBIT
C00568 00153	DDINI DDINI1 DDINI3 DDINI2
C00571 00154	DDAVST DDLIST VDSYNC
C00574 00155	DDCHAN DDCDSP DDAREL DDARL1
C00577 00156	DDUSRT DDCREL DDCRL1 DDREL DDQNTA DDQER4 DDQER3 DDQER2 DDQFIX DDREL2 DDQDET
C00585 00157	DDCGET DDAGE1 DDCG1 DDAGE3 DDAGET DDAGE2 DDGET2 DDGET3
C00589 00158	DDFLSH DDFL00 DDFLS0 DDFL01 DDFLS3 DDFLS2 DDFLS4 DDFL99 DDFLS7 DDFLS8 DDFL88 DDFLS9 DDFLSX FINDDD FINDD1 FINDDL FINDD2 FINDD3 FINDDF FINDDN FINDDQ
C00596 00159	DDCHEK DDCSGT DDSGET DDCFND
C00598 00160	DDCSST DDSSET VDBIT VDSTR1
C00601 00161	VDSTRU VDSTU1 VDSTU2 VDOUT VDOUT1 VDOUT2 VDOUT3
C00603 00162	VDOUP0 VDOUTP VDOUP1 VDOUP2
C00605 00163	VDSMAP VDMAP1 VDMP1A
C00609 00164	VDMAP2 VDMAP3 VDMP30 VDMP31 VDGTIE VDMP32 VDMAP5 VDMAP4 VDDSP VDSTIE VDSTI1
C00612 00165	VDSET VDIOR VDIOR1 VDACM VDRST VDRST1
C00614 00166	VDNORM VDRST2 VDNOR2 VDNOR3
C00616 00167	VDWCHK VDWCHL VDWOK VDWLUZ VDCCHK VDCCK0 VDCCK1 VDCCK5 VDCCK4 VDCCK2 VDCCK3 VDCCHK VDCCK0 VDCCK1 VDCCK2 VDCCK3
C00620 00168	BEGIN WHOSER  ↔ SUBTTL WHO LINE GENERATOR 	WHOINI
C00624 00169	WDMPTY NWHOTX NWHOKL NWHOTX WHOSER WHODO9 WHODO8 WHOD8A WHOEGR WHOIII WHODO WHODO9 WHODO8 EXTRDM WHOPTY WHOPT2 EXTRGR EXTRDD EXTRG2 EXTRA0 EXTRA1 WHODOE
C00636 00170	WHODO4 WHODO3 WHODO2 WHODO5 WHODO1 WHOD1A DMWOK
C00640 00171	WHOCLR WHODM WHODM2 DMUSLN DMUSL3 DMUSL4 DMWCHK DMWCH3
C00644 00172	WHOSIX WHOSXX WSDPAD WSDPD3 WSDPD2 WSDPD0 WSDNUL WSDDEC WSDOCT WSDPD1 WPER2D W0PD2 DECPDF WHPRNT
C00648 00173	 WHITTY WHIOWQ WHIOW2 WHIOW3 ALWAYS ALWA01 ALWA00 ALWAY3 NOIDLE DOIDLE ALWY3A ALWY3B XTALL NOXTIM NOXTM1 DOTIME WHOTIM WHRMIN WMIN LNGMIN
C00659 00174	WHOTTY WHOSET WHOLIN
C00664 00175	WLRET1 WLRET RTMPER NOIDL2 XTMPER XTMPR1 NOXPER WALIAS
C00671 00176	WHOSYS NMTRNL NONULL TEMPOK CENTOK WHOSY1 WHOII0 DMCNTL D12LPA D12LPB WRUN1 WRUN2 WRUN2A
C00686 00177	WHODDC WHODD2 WHONOQ WHODD5 WHODD3 WHOGRL
C00689 00178	WHOFI3 WHOFI2 WHFGRN WHFCUR WHFDD WHFDD WHFDM WHFIII WHOFIL WHFIL2 SHOWIT SHOWI2
C00697 ENDMK
C⊗;
SUBTTL III DISPLAY PACKAGE - D. POOLE - NOV 1968
COMMENT ⊗ 
	THESE ARE THE GLORIOUS, WORLD-SAVING III DISPLAY
ROUTINES.  FOR THEIR FIRST TRICK, THEY WILL IMPERSONATE
W. F. WEIHER, THUS STARTING THE PROGRAM ON A NOTE OF
LIGHT HUMOR.

⊗
BEGIN DPYSER

IFE FTF2,<	;Different no-op from most places.  LINED/WHOSER use different one.
DISNOP←←14	;ACTUALLY RST, BUT A GOOD NOP WITH ALL BITS OFF.
>;IFE FTF2
IFN FTGRIN,<
GMSEL←←30	; GRINNELL MODE SELECT - UPSIII AND UPGRIN IN LH
>;IFN FTGRIN

DEFINE ERMS (X) {JSA J,ERRP
POINT 7,[ASCIZ ⊗X
⊗]
}

GLOBAL DDTAB,JB2SWP,HOMEPT	;STUPID FAIL

IFE FTGRIN,<
↑POSOFF←←1	;Offset from wholine starting address of positioning word.
↑RETOFF←←3	;Offset from wholine starting address and system wholine return addr
		;Allows RETOFF-1 words of display cmds plus one jump word
↑STRTCL←←2	;DD text column number where CR positions us
>;IFE FTGRIN

IFN FTGRIN,<
↑GWCOFF←←0	;Offset from wholine starting address of channel/subch select
↑DLTOFF←←2	;Offset from wholine starting address of delta-X/-Y word
↑POSOFF←←3	;Offset from wholine starting address of positioning word.
↑RETOFF←←5	;Offset from wholine starting address of system wholine return addr
		;Allows RETOFF-1 words of display cmds plus one jump word
↑STRTCL←←1	;Text column number where CR positions us
>;IFN FTGRIN
;PBAKCL GRBAKB GRVECB SIZSBU POSSBU LHCSBU GHCSBU LEWRBP LEWRBT LEWJBP HLINES HGLTCH BDUNIT BD300 BD1200 BD2400 BD4800 BD9600 B10000 BDMAX DMBAUD BDDFT BDDFT PCDFT PADDFT NGSIII NGSDD NGSDM NLSIII NLSDM NLSDD NLSDD YPIII YPDD YPDM NDDSPQ YLINE HGTIII HGTDD HGTDD HGTDM MAXLIN MINLIN MAXCOL MINCOL OUTNUM LINELN DDLINELN DDLINELN CBLKBT TBLKBT FBLKBT

;BYTE POINTERS
↑PBAKCL:
IFE FTGRIN,<
	POINT 1,DDCW(AC2),5	;DD bit on means dark background
>;IFE FTGRIN
IFN FTGRIN,<
	POINT 1,GRCW2(AC2),8	;Grinnell bit off means dark background
GRBAKB←←4*G.WMB			;LH value of background bit
GRVECB←←4*G.WMV			;LH value of vector (¬rectilinear) bit
>;IFN FTGRIN

; BYTE POINTERS INTO BITS THAT SAY SIZE SET BY USER OR UUO

SIZSBU:	POINT 1,GWORD(DDB),0	; IF 1, SAYS LINES/GLITCH OR GLITCHES/PAGE SET BY USER LAST
POSSBU:	POINT 1,GWORD(DDB),1	; SAYS Y-POS. SET BY USER COMMAND (RATHER THAN UUO)
LHCSBU:	POINT 1,GWORD(DDB),2	; SAME FOR LINE HOLD COUNT
GHCSBU:	POINT 1,GWORD(DDB),3	; SAME FOR GLITCH HOLD COUNT
LEWRBP:	POINT 1,GWORD(DDB),4	; 1 if line editor has wrapped around since PPINFO
↑LEWJBP:POINT 1,GWORD(J),4	; same bit, different byte pointer for LINED
LEWRBT←←20000			; LH bit to match LEWRBP/LEWJBP
HLINES:	POINT 9,GWORD(DDB),17	; POINTS TO NUMBER OF LINES BEFORE HOLDING
HGLTCH:	POINT 9,GWORD(DDB),26	; POINTS TO NUMBER OF GLITCHES BEFORE HOLDING
;	POINT 9,GWORD(DDB),35	; CHAR WHICH ACTIVATED LINED

;DM PADDING/BAUD RATE DATA
↑BDUNIT←←=50		;MINIMUM SIGNIFICANCE IN STORED BAUD RATE FOR DM PADDING
↑BD300←←=300/BDUNIT	;STORED VALUES FOR VARIOUS BAUD RATES USED IN 
↑BD1200←←=1200/BDUNIT	; PADDING CALCULATIONS AND INITIALIZATION
↑BD2400←←=2400/BDUNIT
↑BD4800←←=4800/BDUNIT
↑BD9600←←=9600/BDUNIT
↑B10000←←=10000/BDUNIT	;USED FOR CONVERTING MSEC DM EXECUTION TIMES
↑BDMAX←←777		;MAX (CONVERTED) BAUD RATE
↑DMBAUD:POINT 9,PADCNT(TAC1),26	; BAUD RATE USED FOR DM PADDING CALCULATIONS

;Default value for RH of PADCNT cell: baud rate for padding; pad char.
IFE FTLLL,<
↑BDDFT←←BD1200	;default padding baud rate
>;IFE FTLLL
IFN FTLLL,<
↑BDDFT←←BD9600	;default padding baud rate
>;IFN FTLLL
↑PCDFT←←1	;default padding char
↑PADDFT:BYTE(9)0,0,BDDFT,PCDFT

; NORMAL VALUES FOR THE PAGE PRINTER

NGSIII←←14	; GLITCHES/PAGE FOR III DISPLAYS
IFE FTGRIN,<	; GRINNELL USES DMNORM TO FIGURE GLITCHES/PAGE
NGSDD←←4	; GLITCHES/PAGE FOR DD DISPLAYS
>;IFE FTGRIN
NGSDM←←7	; GLITCHES/PAGE FOR DM DISPLAYS
NLSIII←←2	; LINES/GLITCH FOR III
NLSDM←←3	; LINES/GLITCH FOR DM
IFN FTGRIN,<
NLSDD←←NLSDM	; MUST BE SAME AS DM, SO THAT DMNORM CAN BE USED FOR GRINNELL
>;IFN FTGRIN
IFE FTGRIN,<
NLSDD←←11	; LINES/GLITCH FOR DD
>;IFE FTGRIN
YPIII←←600	; Y-POSITION FOR III
YPDD←←660	; Y-POSITION FOR DD (line 4 of 40.)
YPDM←←526	; Y-POSITION FOR DM (line 4 of 24.)
↑NDDSPQ←←60	;# SPARE DD/DM QUEUE BLOCKS (TIRED OF BEING SCREWED -REG)
↑YLINE←←4	; Screen line number for default Y position, all displays

↑HGTIII←←=42	;Number of lines on screen for III (slightly arbitrary)
IFE FTGRIN,<
HGTDD←←=40	;Number of lines on screen for DD
>;IFE FTGRIN
IFN FTGRIN,<
HGTDD←←=42	;Number of lines on screen for Grinnell
>;IFN FTGRIN
↑HGTDM←←=24	;Number of lines on screen for DM (default type of DM)

↑MAXLIN←←=62	;Maximum allowable size of DPYHGT (number of lines on screen)
↑MINLIN←←=8	;Minimum   "

;If you change MAXCOL, don't forget to extend the TABSET message in CACDAT.
↑MAXCOL←←=96	;Maximum allowable size of DPYWID (number of columns on screen)
↑MINCOL←←=16	;Minimum   "

OUTNUM←←1	;THIS MANY BLOCKS AT ONCE GET PUT ON DISK. (HA HA)
↑LINELN←←=88	;NO. OF CHARS. PER LINE FOR III
IFE FTGRIN,<
DDLINELN←←=84	; SAME AS ABOVE FOR DATA DISC
>;IFE FTGRIN
IFN FTGRIN,<
DDLINELN←←=73	; SAME AS ABOVE FOR GRINNELL
>;IFN FTGRIN
;DMLINELN←←=80	; SAME FOR DATAMEDIA
CBLKBT←←1	;MAGIC CODE BITS FOR THE (HO, HO) RELOCATING GARBAGE COLLECTOR.
TBLKBT←←4
FBLKBT←←2
;DWPINI DWPERR DPYATL
COMMENT ⊗  THE FOLLOWING IS SYSTEM START TIME INITIALIZING CODE.
 	MUCH OF IT IS IN TEMPORARY FORM.
⊗

↑DWPINI:
IFE FTF2,<
	SKIPE IIIOFF		;SUPPRESSING III TODAY?
	TDZA AC1,AC1		;YES.  FLUSH CONSZ INSTRUCTION
	MOVEI AC1,400000	;NO. SET CONDITION BIT IN DPYCON
	HRRM AC1,DPYCON
	MOVEI TAC,DPYNUM
	MOVEM TAC,DRUNCT	;INIT. PTR. TO NEXT DPY TO RUN.
>;IFE FTF2
IFN FTDD!FTGRIN,<
	MOVEI AC1,2		;INITIALIZE COMMON DD CURSOR BUFFER
	MOVEM AC1,DDCURS+CURB	;BY PROPAGATING A ZERO GRAPHICS WORD DOWN IT
	MOVE AC1,[DDCURS+CURB,,DDCURS+CURB+1]
	BLT AC1,DDCURS+CURB+LCURB-1 ;ALL THE WAY
	HRLOI TAC,377777
	MOVEM TAC,DDCNT
>;IFN FTDD!FTGRIN
	SETZM FSWTHD		;CLEAR FS WAIT LIST.
	SETZM FSWT2H		;AND THE WAIT LIST WAIT LIST.
IFN FTDD!FTGRIN,<
	SETZM DDSTART		; CLEAR ALL THE DATA DISK FLAGS
	SETZM DDRUN
>;IFN FTDD!FTGRIN
IFE FTF2,<
	SETZM STRTBL		; ZERO OUT ALL THE IMPORTANT TABLES
	MOVE TAC,[XWD STRTBL,STRTBL+1]
	BLT TAC,RSTTBL+DPYNUM-1
>;IFE FTF2
	MOVE TAC,[POINT 36,CLKQUE-1,35]
	MOVEM TAC,CLKQ		;INIT. CLOCK QUEUE PTR.
	MOVE TAC,[IOWD LCPDL,CLKPD]	;..ALSO CLOCK PDL.
	MOVEM TAC,DPYPDL
IFE FTF2,<
	MOVSI TAC,770000	; RESTORE AVAILABLE MESSAGES
	HLLM TAC,DPYAVL+1
	HLLM TAC,WHOSEL		; SYSTEM WHO LINE FOR ALL AVAILABLE IIIS
	MOVSI TAC,77		; DESELECT EVERYONE
	HLLM TAC,DPYHLD		; HOLDING MESSAGE TOO
	CONO DDD,10
	PUSHJ P,DDINI
>;IFE FTF2
IFN FTGRIN,<
	CONO GRN,0		; CLEAR INTERRUPT ENABLINGS
>;IFN FTGRIN
	JRST WHOINI

DWPERR:	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CATASTROPHIC ERROR FROM DPYSER
/
DPYATL:	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCA
	HALT .
;DPYMAK DPYM0 DPYM0A DPYM1
; DPYMAKE MAKES UP A DISPLAY PROGRAM HEADER WITH LINE EDITOR BUFFER. IT EXPECTS
; THE LINE NUMBER IN TAC1. PRESERVES ALL OTHER ACCUMULATORS. SKIPS ON SUCCESS.
; ON FAILURE, WILL PLANT A CLOCK REQUEST AND TRY TO GET ONE LATER.

↑DPYMAK:SKIPE LETAB(TAC1)	; DO WE ALREADY HAVE A PROGRAM HEADER?
	JRST CPOPJ1		; YES, GIVE SUCCESS RETURN
	PUSH P,TAC
	PUSH P,DAT
	PUSH P,DDB
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	HLRO TAC,LINTAB(TAC1)	;-1 IN LH MEANS NOT DD, RH HAS LINE BITS
	HLL TAC1,LINTAB(TAC1)
IFN FTDD!FTGRIN,<
	TLNN TAC1,DDDLIN
	JRST DPYM1
>;IFN FTDD!FTGRIN
IFN FTGRIN,<
	MOVEI TAC,-DDL0(TAC1)	;For now, store Grinnell number instead of DD chan
>;IFN FTGRIN
IFE FTF2,<
	MOVSI TAC,DTTUSR-DTTL0(TAC1) ;UNHIDDEN TTY STATUS
	SKIPN AC1,DDSPCH	;want special channel?
	JRST DPYM0		;nope
	SETZM DDSPCH		;yup, make sure doesn't happen again
	HRRI TAC,(AC1)		;set channel number we want
	PUSHJ P,DDCGET		;request it
	 JRST DPYXTL		;lost
	JRST DPYM0A		;resume normal operation

DPYM0:	PUSHJ P,DDAGET		;FIRST MAKE SURE WE HAVE A CHANNEL FOR DD
	 JRST DPYXTL		;GO DIRECTLY TO JAIL
DPYM0A:	ANDI TAC,-1		;LEAVE ONLY DD CHANNEL NUMBER (RH)
>;IFE FTF2
DPYM1:	MOVEI AC3,DHFS
	PUSHJ P,SFSGET
	 JRST DPYM8
	HRRZ DDB,AC1
	SETZM (AC1)		; FIRST, ZERO THE THING OUT
	HRLZ AC2,AC1
	HRRI AC2,1(AC1)
	MOVE AC3,AC1
	BLT AC2,DPYLEN-1(AC3)
	MOVEI AC2,DISRST!60	; NOW SET UP THE STARTUP WORD TO RESTORE THE POSITION VECTOR
	HRLI AC2,PRGSAV(AC1)	; THAT WAS STORED LAST TIME THE DPY WAS STOPPED
	MOVEM AC2,(AC1)
	HRLI AC2,LEB+1(AC1)	; THE LINE EDITOR DOES THIS TOO
	MOVEM AC2,LEPPV+4(AC1)
	SETZM LEB(AC1)
	HRLI AC2,LEB(AC1)	; SET UP THE LINE EDITOR CALL
	HRRI AC2,DISJMS
	MOVEM AC2,LEJMS(AC1)
	HRRI AC2,DISJMP		; FILL UP THE LINE EDITOR BUFFER WITH RETURN JUMPS
	MOVEM AC2,LEBUF(AC1)
	HRLI AC2,WHOCALL(AC1)	; MAKE RESTART POINT JUMP BACK TO WHO LINE CALL
	MOVEM AC2,RTJMP(AC1)
	HRLI AC2,LEBUF(AC1)	; NOW BLT THE RETURN JUMP ALL OVER THE
	HRRI AC2,LEBUF+1(AC1)	; LINE EDITOR BUFFER.
	BLT AC2,LEHPOS-1(AC1)
	MOVSI AC3,(TAC)		; DD CHANNEL OR, IF NOT DD, BIT INDICATING DPY TYPE
	HRRI AC3,(TAC1)		; TTY LINE NUMBER
	MOVEM AC3,PRGNUM(DDB)
;DPYMNG DPYMGS DPYM3

IFN FTRANGE,<
	SETZM DMBEG(DDB)	;Don't suppress any user program output
	MOVEI AC3,-1
	MOVEM AC3,DMEND(DDB)
>;FTRANGE
	MOVE AC2,DPYDFT		;Get pointer to default display-type block
	SKIPN DPYDES(TAC1)	;And use that default if no type set up
	MOVEM AC2,DPYDES(TAC1)	;This shouldn't really ever happen....
IFN FTGRIN,<
	TLNN TAC1,DDDLIN	;Is this a Grinnell?
	JRST DPYMNG		;No
	MOVE AC3,GRELSZ(TAC)	;Get default character pixel width and scanline hgt
	HLRZM AC3,DCHWID(DDB)	;Store pixel width in dpy hdr
	HRRZM AC3,DCHHGT(DDB)	;Store scanline height
	HLRZ AC2,GRNDIM(TAC)	;Get pixel/scanline count for this Grinnell
	IDIV AC2,DCHWID(DDB)	;Divide by width of each char
	SUBI AC2,1		;Leave one unused column on left of screen
	MOVEM AC2,DPYWID(DDB)	;That's the number of chars that fit on a line
	HRRZ AC2,GRNDIM(TAC)	;Get scanlines/screen count for this Grinnell
	IDIV AC2,DCHHGT(DDB)	;Divide by height of a text line
	MOVEM AC2,DPYHGT(DDB)	;That's the number of text lines that fit on screen
	JRST DPYMGS

DPYMNG:
>;IFN FTGRIN
IFE FTGRIN,<
	MOVEI AC3,DDLINELN	;Line length on DD
	TLNE TAC1,DISLIN
	MOVEI AC3,LINELN	;For III
	TLNE TAC1,DMLIN
>;IFE FTGRIN
	HLRZ AC3,DPCSIZ(AC2)	;For variable display, get default from DPC block
	MOVEM AC3,DPYWID(DDB)
IFE FTGRIN,<
	MOVEI AC3,HGTDD		;DD screen height
	TLNE TAC1,DISLIN
	MOVEI AC3,HGTIII	;III height
	TLNE TAC1,DMLIN
>;IFE FTGRIN
	HRRZ AC3,DPCSIZ(AC2)	;For variable display, get default from DPC block
	MOVEM AC3,DPYHGT(DDB)	;Set up size of display's screen
DPYMGS:	PUSHJ P,PPINIT		;GET PAGE PRINTER SET UP FOR EACH DPY.
	 JRST DPYM7
	PUSHJ P,PPSET
IFN FTDD!FTGRIN,<
	TLNE TAC1,DDDLIN
	JRST DPYM2		; DO SPECIAL DD STUFF (GET CHANNEL & ERASE IT)
>;IFN FTDD!FTGRIN
IFE FTF2,<
	TLNE TAC1,DMLIN
>;IFE FTF2
	JRST DPYM4		; Now go initialize DM output queues
IFE FTF2,<
	MOVNI AC3,-DPYL0(TAC1)	; MUST BE A III
	MOVE AC2,[BYTE (12)0,7777,DISSEL]
	MOVEM AC2,PSELC(DDB)
	MOVSI AC2,400040	; NOW MAKE UP SELECT WORD
	LSH AC2,(AC3)		; PUT A BIT IN THE FIRST TWO 12-BIT FIELDS
	XOR AC2,[77770000]	; COMPLEMENT THE SECOND FIELD
	IORI AC2,DISSEL
	MOVEM AC2,PSELA(DDB)	; AND THIS IS OUR SELECT WORD
	MOVEM AC2,PSELB(DDB)	; AND OUR SPARE SELECT WORD
	AND AC2,[77B5]		; MASK OUT ALL BUT SELECT BIT
	ANDCAM AC2,DPYAVL+1	; DESELECT THIS CONSOLE FROM AVAILABLE MESSAGE
	ANDCAM AC2,WHOSEL	; DESELECT THIS CONSOLE FROM SYSTEM WHOLINE
	LSH AC2,-=12		; PUT BIT IN 'RESET' FIELD
	IORM AC2,DPYAVL+1	; BE SURE TO RESET THIS CONSOLE TOO
	IORM AC2,WHOSEL		; BE SURE TO RESET THIS CONSOLE TOO
	MOVE AC2,[LVW (-5,-14)]	; MAKE A CURSOR FOR THE LINE EDITOR
	MOVEM AC2,LEPPV+1(DDB)
	MOVE AC2,[LVW (12,0)]
	MOVEM AC2,LEPPV+2(DDB)
	MOVE AC2,[LVW (-5,14)]
	MOVEM AC2,LEPPV+3(DDB)
	MOVE AC2,[LVW (0,0,I)]	; NOW A NULL VECTOR FOR THE LEFT MARGIN
	MOVEM AC2,LELMARG(DDB)
>;IFE FTF2
; MORE INITIALIZE CODE FOR A NEW PROGRAM-LINED-BUFFER THING
DPYM3:
IFE FTGRIN,<
	MOVNI AC1,24000/BLKSIZ	; 24000 WORDS MAXIMUM TOTAL PROGRAMS
>;IFE FTGRIN
IFN FTGRIN,<
	MOVNI AC1,100000/BLKSIZ	; 64K WORDS MAXIMUM TOTAL PROGRAMS
>;IFN FTGRIN
	MOVEM AC1,BLKTOT(DDB)	;HOW MANY MORE BLOCKS EACH USER GETS.
	MOVEI AC1,DISNOP
	MOVEM AC1,WHOCALL(DDB)	;NO WHO LINE YET.
	MOVEM AC1,LEPOS(DDB)	; NORMAL VERTICAL POSITION
	SETZM LEYVAL(DDB)	;No special position for line editor from LEYPOS
	MOVEM AC1,PGCALL(DDB)	;NO PG'S.
	MOVEM AC1,LEPPV(DDB)
	MOVEI AC1,400000
	MOVEM AC1,PRGACT(DDB)	;P OF P 0 ACTIVE.
	MOVEM AC1,USRACT(DDB)
	MOVEI AC1,3		; BUMP NUMBER OF SPARE FREE BLOCKS
	ADDM AC1,DPYFS+SPFSN
	ADDM AC1,SPFSNT
	SETOM GLHCNT(DDB)	;Clear current count to automatic holding
	MOVSI AC1,377777	;LARGE POSITIVE NUMBER
	MOVEM AC1,LHCNT(DDB)	;LOT OF LINES TO COUNT TILL AUTOMATIC HOLDING
	SETZM GWORD(DDB)	;Disable automatic holding, clear all the bits
	MOVSI AC1,400000
	MOVEM AC1,NEVECT(DDB)	;Null is the default ESC for NOEDIT ttys
;⊗ DPYXIT DPYXTL DPYM9 SCNFFJ SCNONJ

; NOW SET UP THE POINTERS IN THE TABLES TO GET THE DP STARTED
; AND STOPPED ON THIS PROGRAM

	HRL AC2,DDB		; NOW INITIALIZE ALL THE APPROPRIATE TABLES
	HRRI AC2,DISJMP		; THIS LITTLE JUMP GOES TO DPYTAB
	HRLI AC3,PRGSTP(DDB)
	HRRI AC3,DISJMS		; THIS LITTLE JUMP GOES TO STPTBL
	HRLI AC1,PSELB(DDB)
	HRRI AC1,DISJMP		; AND THIS LITTLE JUMP WENT WEE WEE WEE
	MOVEI DAT,LETAB(TAC1)	;Give the header a pointer to
	MOVEM DAT,LETBPT(DDB)	; its LETAB entry.
setom ledmz(ddb)	;set up the demilitarized zone to show up overflow bugs
PRINTX LEDMZ(DPY HDR) should be flushed when LE overflow bugs are fixed for good.
	MOVEI DAT,PSELA(DDB)
	SYSPIFF		; ALL THE WAY INTO RSTTBL
	SKIPE LETAB(TAC1)	; DID SOMEONE SNEAK IN UNDER US?
	JRST DPYM5
	HRRZM DDB,LETAB(TAC1)	; INITIALIZE LINE EDITOR TABLE TOO
	SYSPIN
IFN FTDD!FTGRIN,<
	TLNE TAC1,DMLIN
>;IFN FTDD!FTGRIN
	JRST DPYM9		;Erase DM screen and start tty
IFE FTF2,<
	TLNN TAC1,DISLIN
	JRST DPYXIT		;THAT'S ALL FOR DD
	MOVE TAC,[LVW -777,YPIII,I,A,2,2]
	MOVEM TAC,LEDPOS(DDB)	;Set up position word for III line editor
	MOVEM DAT,SELTBL-DPYL0(TAC1)
	MOVEM AC3,STPTBL-DPYL0(TAC1)	;IN THIS ORDER
	MOVEM AC1,PRGSTP(DDB)
	MOVEM AC1,RSTTBL-DPYL0(TAC1)	;WE SHOULDN'T NEED
	MOVEM AC2,STRTBL-DPYL0(TAC1)	;TO KEEP PI'S OFF
>;IFE FTF2
DPYXIT:	AOS -6(P)		;WE HAVE WON
DPYXTL:	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,DDB
	POP P,DAT
	POP P,TAC
	POPJ P,

DPYM9:	PUSH P,J
	MOVEI J,(DDB)		;Dpy header address into J for LEPDM2
	SETZM DMFLAG(J)		;Clear all the flags
	MOVE TAC,PADCNT(TAC1)	;MAKE SURE PADDING CHAR ISN'T NULL
	TRNN TAC,377		;IF NO PADDING CHAR SPECIFIED,
	MOVE TAC,PADDFT		; USE DEFAULT PADDING RATE AND CHAR
	MOVEM TAC,PADCNT(TAC1)	;STORE FOR THIS NEW DM
	PUSH P,CHR
	SETZM DMFLAG(J)		;No init done yet
	OFFSCN			;LEPDM2 expects scanner off and turns it on
	PUSHJ P,LEPDM2		;Erase DM screen
	POP P,CHR
	POP P,J
	JRST DPYXIT

↑SCNFFJ:AOSGE SCNCNT
	JSR SCNBUG		;OOPS, IT WAS -2 OR LESS
	PUSH P,AC1
	CONSZ PI,PION		;Maybe here with PI system already off
	SKIPA AC1,[CONO PI,PION]
	MOVSI AC1,(<JFCL>)
	PUSH P,AC1		;Save state of PI system
	SYSPIFF
	CONO PI,SCNOFF!PIOFF	;TURN OFF SCANNER AND REMEMBER WHAT WE DID
	EXCH TAC,OFSPDL		;KEEP PDL OF PLACES WHERE SCANNER WAS WANTED OFF
	PUSH TAC,-2(P)		;PUT OUR RET ADDR INTO OFSPDL
	EXCH TAC,OFSPDL
	POP P,AC1
	XCT AC1			;Restore state of PI system
	POP P,AC1
	POPJ P,

↑SCNONJ:PUSH P,AC1
	CONSZ PI,PION		;Maybe here with PI system already off
	SKIPA AC1,[CONO PI,PION]
	MOVSI AC1,(<JFCL>)
	PUSH P,AC1		;Save state of PI system
	SYSPIFF
	EXCH P,OFSPDL
	ADJSP P,-1
	EXCH P,OFSPDL
	SKIPGE SCNCNT
	JSR SCNBU3
	POP P,AC1
	XCT AC1			;Restore state of PI system
	POP P,AC1
	SOSGE SCNCNT
	CONO PI,SCNON		;TURN ON SCANNER IF NO ONE STILL WANTS IT OFF
	POPJ P,
;DPYM4 DPYM5 DPYM6 DPYM7 DPYM8 PPSET

DPYM5:	SYSPIN
IFE FTF2,<
	TLNE TAC1,DDDLIN
	JRST DPYM6
>;IFE FTF2
	PUSHJ P,DPYKFS		;III OR DM -- JUST RET FS
	JRST DPYXIT

IFE FTF2,<
DPYM6:	HRRZM DDB,DPRLSF(DDB)	;DD - DEFER FS RET FOR DDWIPE
	MOVSI TAC,DTTUSR-DTTL0(TAC1)
	HLR TAC,PRGNUM(DDB)
	PUSHJ P,DDREL		;BUT GIVE BACK CHNL NOW
	JRST DPYXIT
>;IFE FTF2

DPYM7:	PUSHJ P,DPYKF2		;RET HDR
	AOSA DPYMF2		;COUNT DPYMAKE FAILURES, TYPE 2 (NO PP FS)
DPYM8:	AOS DPYMF1		;COUNT DPYMAKE FAILURES, TYPE 1 (NO DPY HDR FS)
IFE FTF2,<
	JUMPL TAC,DPYXTL	;JUMP if not DD (see HRLO at DPYMAK)
	HRLI TAC,DTTUSR-DTTL0(TAC1)
	PUSHJ P,DDREL		;RELEASE DD CHNL
>;IFE FTF2
	JRST DPYXTL

↑PPSET:	HRRZM DDB,HEDPTR(AC1)	;MAKE PP0 CONT. BLK. POINT AT HEADER.
	HRLI AC1,DISJMP		;ASSEMBLE JMP TO PP 0.
	MOVSM AC1,PPCALL(DDB)	;HAVE HEADER CALL THE PP.
	HRRZM AC1,CURPP(DDB)	;MAKE P OF P 0 THE CURRENT ONE.
	MOVE AC3,DPYWID(DDB)	;GET DISPLAY WIDTH
	MOVEM AC3,LNLNGT(AC1)	;STORE IN PP
	MOVNM AC3,DPHPOS(AC1)	;STORE REMAINING LENGTH OF CURRENT LINE TOO
	MOVEI AC3,PPCALL+1(DDB)	;RETURN ADDR. TO HEADER FROM PP.
	HRLM AC3,PPRJMP(AC1)	;PUT IN PP RETURN JMP.
	POPJ P,

DPYM4:	MOVEI AC1,DMLEPT-QLINK(DDB)	;Make each DM output
	HRL AC1,AC1			; queue header point to itself
	MOVEM AC1,DMLEPT(DDB)
	MOVEI AC1,DMSPPT-QLINK(DDB)
	HRL AC1,AC1
	MOVEM AC1,DMSPPT(DDB)
	MOVEI AC1,DMPPPT-QLINK(DDB)
	HRL AC1,AC1
	MOVEM AC1,DMPPPT(DDB)
	MOVEI AC1,DMUSER-QLINK(DDB)
	HRL AC1,AC1
	MOVEM AC1,DMUSER(DDB)
	MOVEI AC1,DMWHO-QLINK(DDB)
	HRL AC1,AC1
	MOVEM AC1,DMWHO(DDB)
	SETOM DMUSXY(DDB)		;No user-specified X-Y position for cursor
	JRST DPYM3
;DPYM2 DDWIPE DDMAP DDMAP1 DDMAP3

IFN FTDD!FTGRIN,<	;Whole page

;GETTING NEW DATA DISC CHANNEL. FIRST DESELECT AVAILABLE MSG,
;THEN ERASE CHANNEL, THEN SELECT CONSOLE TO CHANNEL.

DPYM2:	MOVE AC2,AVLBIT
	OFFSCN			;TURN OFF SCANNER CHANNEL
	ANDCAB AC2,VDPRM-DDL0(TAC1)
	MOVEM AC2,VDTMP(DDB)
	ONSCN			;TURN ON SCANNER CHANNEL
	HRLI DDB,DDWIPE
	SYSPIFF
	IDPB DDB,CLKQ
	SYSPIN
	JRST DPYM3

;HERE AT CLOCK LEVEL (CAN'T CALL QBLOCK FROM CH5) FOR DD TO ERASE NEW CHANNEL
DDWIPE:	SKIPE DDB,DPRLSF(DAT)
	JRST DPYKFS		;DPYMAKE WAS ABORTED - RET FS NOW
	PUSHJ P,GETQ
	HRRZ AC2,CURPP(DAT)
	ADDI AC2,PPENQ
	MOVEM AC2,QCOUNT(AC1)
	AOS (AC2)		;WILL HOLD UP BOTH DPLED & DPYTYP
	HRLI DAT,DDMAP
	MOVEM DAT,QWAKE(AC1)
	JRST LEERS3

;HERE AFTER ERASE IS FINISHED. NOW THAT CHANNEL IS CLEAN, WE LET HIM SEE IT.
DDMAP:
IFE FTGRIN,<
	HLRZ AC1,PRGNUM(DAT)	;DD CHANNEL NUMBER
	HRRZ TAC,PRGNUM(DAT)	;TTY LINE NUMBER
	PUSHJ P,VDBIT		;GET BIT FOR DD CHANNEL INTO AC3
	OFFSCN			;TURN OFF SCANNER CHANNEL
	IORM AC3,VDTMP(DAT)
	IORM AC3,VDPRM-DDL0(TAC)
	LDB DAT,[DDQREQ+TAC,,LSTESC] ;GET RESPONSIBLE TTY
	PUSHJ P,FINDDF		;FIND A FREE DD TO MAP/TIE NON-RESPONSIBLE DDS TO
	MOVSI AC3,-DDNUM	;PULL BACK NON-RESPONSIBLE DDS FROM OUR NEW DD
DDMAP1:	CAIN DAT,DDL0(AC3)	;IS THIS THE RESPONSIBLE TTY?
	JRST DDMAP2		;YES, SEE IF HE'S MAPPED TO AVAILABLE DD
	CAMN TAC,VDTIE(AC3)	;IS THIS DD TIED TO OUR NEWLY IN-USE DD?
	MOVEM AC1,VDTIE(AC3)	;YES, TIE HIM SOMEWHERE FREE
	LDB AC2,[POINT PUNITS,LINTAB+DDL0(AC3),35]
	CAIN AC2,(TAC)		;IS THIS GUY MAPPED TO OUR NEWLY IN-USE DD?
	DPB AC1,[POINT PUNITS,LINTAB+DDL0(AC3),35] ;MAP HIM SOMEWHERE FREE
DDMAP3:	AOBJN AC3,DDMAP1
	ONSCN			;TURN ON SCANNER CHANNEL
	SUBI TAC,DDL0
	PUSHJ P,VDOUTP		;PROPAGATE VDOUT TO ALL MAPPERS
	MOVEI DAT,DDL0(TAC)
>;IFE FTGRIN
IFN FTGRIN,<
	HRRZ DAT,PRGNUM(DAT)	;TTY LINE NUMBER
>;IFN FTGRIN
	JRST DPYTYP		;IN CASE PP XFER WAS FLUSHED

IFE FTGRIN,<
DDMAP2:	LDB AC2,[POINT PUNITS,LINTAB(DAT),35] ;GET TTY HE'S NOW MAPPED TO
	SKIPE LETAB(AC2)	;IS HE MAPPED TO A FREE TTY?
	JRST DDMAP3		;NO, LEAVE HIM ALONE
	DPB TAC,[POINT PUNITS,LINTAB(DAT),35] ;YES, MAP HIM HERE
	MOVEM TAC,VDTIE-DDL0(DAT) ;ALSO TIE HIM HERE
	JRST DDMAP3
>;IFE FTGRIN

>;IFN FTDD!FTGRIN	;Whole page
;⊗ DPYKIL DPYK00 DPYKI8 DPYK4A DPYKI4

; ENTER HERE AT CLOCK LEVEL WITH LINE NUMBER IN TAC TO FLUSH A DPY HEADER.
↑DPYKIL:MOVE AC1,LINTAB(TAC)
	TLNN AC1,DISLIN!DDDLIN!DMLIN
	JRST DPYKER
	SKIPE AC1,LETAB(TAC)
	SETZM LECLIN(AC1)	; CLEAR FLAG THAT SAYS CLOCK REQUEST IS IN
	SKIPE AC2,TTYTAB(TAC)	;Don't do anything unless TTYSER either is through
	TLNE AC2,KILTTY!KILDPY	;  or wants this tty made a non-display
	SKIPN AC1,LETAB(TAC)	;Get dpy header
	POPJ P,			;No dpy here after all, or don't want to touch it
	JUMPE AC2,DPYK00	;Jump if already no TTY DDB
	TLNE AC2,KILDPY		;If becoming non-display, OK even if TTY in use
	JRST DPYK00		;Skip tty-in-use test
	MOVE AC2,DEVMOD(AC2)	;Don't kill if TTY is still assigned!
	TRNE AC2,ASSCON!ASSPRG
	POPJ P,			;TTY still in use
;Keep scanner off until we have cleared LETAB now
DPYK00:	OFFSCN			;Don't let anything change till we clear LETAB
	SKIPE LEACT(AC1)	; HAS THE LINE EDITOR BEEN ACTIVE RECENTLY?
	JRST DPYKS9		; YES, WAIT SOME MORE
	SKIPN LEENQ2(AC1)	; IF HE'S REFRESHING OR HELPING,
	SKIPE LEENQ(AC1)	; OR IF HIS LINE EDITOR IS IN THE QUEUE
	JRST DPYKS7		; PLANT ANOTHER CLOCK REQUEST TO KEEP US AROUND
	SKIPN LECLK(AC1)	; IF WE HAVE CLOCK REQ FOR LINE EDITOR (DPLED),
	SKIPE DPTYCL(AC1)	; OR IF HAVE CLK REQ FOR PAGE PRINTER (DPYTYP),
	JRST DPYKS7		; THEN WAIT A LITTLE AND TRY AGAIN
	SKIPE NPPXFR(AC1)	; IF WE HAVE ANY PP XFERS QUEUED AT ALL,
	JRST DPYKS7		; THEN WAIT
	HLRZ AC2,PPCALL(AC1)	; OR IF HE HAS ANY PIECE OF PAPER QUEUED
DPYKI8:	SKIPN PPNQT(AC2)	; Any special xfers queued?
	SKIPE PPENQ(AC2)	; ANYTHING IN QUEUE?
	JRST DPYKS7		; Yes, come back later
	HRRZ AC2,PPLINK(AC2)	; PICK UP POINTER TO NEXT PIECE OF PAPER CONTROL BLOCK
	JUMPN AC2,DPYKI8	; LOOP BACK IF ANY
	JUMPL AC1,CLRLED	; If anything in line editor, send out a CLEAR char
	HRRZ DDB,AC1		; DPY HEADER ADDRESS
	HLL DDB,LINTAB(TAC)	; GET BITS INDICATING TYPE OF DISPLAY
IFN FTDD!FTGRIN,<
	PUSHJ P,PGCLR		; CLEAR ANY AND ALL PIECES OF GLASS
>;IFN FTDD!FTGRIN
	TLNN DDB,DMLIN
	JRST DPYKI3
	HRRZ TAC1,DMLEPT(DDB)	;Make sure all DM queues are empty
	HRRZ AC2,DMSPPT(DDB)
	CAIN TAC1,DMLEPT-QLINK(DDB)
	CAIE AC2,DMSPPT-QLINK(DDB)
	JRST DPYKI4		;Not empty, wait a tick and check again
	HRRZ TAC1,DMPPPT(DDB)
	HRRZ AC2,DMUSER(DDB)
	CAIN TAC1,DMPPPT-QLINK(DDB)
	CAIE AC2,DMUSER-QLINK(DDB)
	JRST DPYKI4		;Not empty, wait a tick and check again
	HRRZ TAC1,DMWHO(DDB)
	CAIE TAC1,DMWHO-QLINK(DDB) ;wholine queue empty?
	JRST DPYKI4		;Not empty, wait a tick and check again
	SKIPL DMUSXY(DDB)	;Any user-specified position?
	JRST DPYKI2		;Yes, probably can't happen, kill dpy hdr now
	CAIL TAC,DCANUM		;is this a hung up phone line?
	JRST DPYK4A		;not DCA line
	MOVE AC2,DCATAB(TAC)	;see if phone line is hung up
	TDNN AC2,[DCACAR,,DCAPRM] ;if still here, wait
	JRST DPYKI2		;phone line is hung up, kill now
DPYK4A:	TLNE DDB,PTYLIN		;don't wait for PTY that's gone away
	TLNE DDB,PTYUSE		;PTY here, is it still in use?
	SKIPA AC2,CVP(DDB)	;Vertical position of LE cursor
	JRST DPYKI2		;PTY that's no longer in use, kill now
	SKIPLE DMQKCT(DDB)	;quicky buffer empty?
	JRST DPYKI4		;Not empty, wait a tick and check again
	SOJL AC2,DPYKI2		;LE counts lines from 1 but DM counts from 0
	CAML AC2,DPYHGT(DDB)	;Is the vertical position on the screen?
	JRST DPYKI2		;No, kill dpy hdr (should have been reset by now)
	HRL AC2,CHP(DDB)	;Horizontal position of LE cursor
	CAMN AC2,DMXY(DDB)	;Is cursor already there?
	JRST DPYKI2		;All empty, now flush dpy header
DPYKI4:	ONSCN			;Not empty, wait a tick and check again
	PUSHJ P,DPYKI7		;Plant clock req to come back a tick later
	MOVEI DAT,(AC1)		;For STRTDM
	JRST STRTDM		;Start tty (eg, PJOB cmd doesn't start created tty)
;DMCLRU CLKFLS CLKFL1 CLKFL2

;Routine to flush clock request that would have cleared user run flag for DM prog.
;Clobbers only TAC.  Here from DMUPG and DPYRST, either in CH7 or at UUO level,
;after calling CHASEM or DDWAIT to make sure no user display program still going.
DMCLRU:	SETZM UCOUNT(DDB)	;Don't let user's run flag be cleared later!
	MOVEI TAC,(DDB)		;Dpy header is datum of clock request
	HRLI TAC,DMUCLK		;Flush this DM's clock request for DMUCLK, if any
	;Fall into CLKFLS
;Routine to remove requests from DPYSER's clock queue.  Searches queue for
;request(s) matching that in TAC and changes each's dispatch address to
;CPOPJ.  It is the callers responsibility to make sure no similar clock
;request is planted while this routine is working.
CLKFLS:	SKIPN @CLKQ		;ANY REQUESTS IN THE CLK QUEUE ?
	POPJ P,			;NO. SEE HOW LITTLE TIME WE HAVE WASTED !!
	PUSH P,AC1		;SAVE AN AC
	HRRZ AC1,CLKQ		;GET PTR. TO CURRENT END OF QUEUE.
CLKFL1:	CAME TAC,(AC1)		;IS THIS THE CLOCK REQUEST WE WANT TO FLUSH?
	JRST CLKFL2		;NO
	HRLI TAC,CPOPJ		;TURN DISPATCH ADDRESS INTO NO-OP ROUTINE
	EXCH TAC,(AC1)		;CHANGE CLOCK REQUEST TO NO-OP
CLKFL2:	SUBI AC1,1		;NOW GET PTR. TO NEXT LOWER REQUEST IN CLOCK QUEUE
	CAIL AC1,CLKQUE		;ARE WE AT BOTTOM OF QUEUE ?
	JRST CLKFL1		;NO. BACK FOR MORE.
	POP P,AC1		;RESTORE
	POPJ P,
;SPIONJ DPYKI2 DPYKI3 DPYKL1 DPNONO DPNOT4

SPIONJ:	SYSPIN
	JRST SCNONJ		;Now turn on scanner channel and return

DPYKI2:	PUSH P,TAC
	PUSHJ P,DMCLRU		;Clear UCOUNT and flush our clk req for DMUCLK
	POP P,TAC
DPYKI3:	SYSPIFF
	SKIPE AC2,TTYTAB(TAC)	;Don't do anything unless TTYSER either is through
	TLNE AC2,KILTTY!KILDPY	;  or wants this tty made a non-display
	SKIPN LETAB(TAC)	;Any dpy header?
	JRST SPIONJ		;No dpy here after all, or don't want to touch it
	SETZM LETAB(TAC)
IFN FTLCLDM,<
	MOVE TAC1,TAC		;Sigh, following byte ptrs want line number in LINE
	MOVSI AC2,NEHTFL	;Zero RH byte, plus hold-toggle flag
	DPB AC2,NEMBPT		;Zero the no-edit quoting mode
	DPB AC2,NESBPT		;Zero no-edit state flags
	SKIPGE EDITKY(TAC)	;Skip if not a no-edit keyboard
	ANDCAM AC2,EDITKY(TAC)	;Turn off hold-toggle mode
>;IFN FTLCLDM
IFE FTF2,<
	JUMPGE DDB,DPYKL1	; JUMP UNLESS III
	SETZM RSTTBL-DPYL0(TAC)
	SETZM STPTBL-DPYL0(TAC)
	SETZM STRTBL-DPYL0(TAC)
>;IFE FTF2
DPYKL1:	SYSPIN
	PUSH P,DDB
	SKIPN DDB,TTYTAB(TAC)
	JRST DPNOT4		;No DDB (shouldn't happen)
	TRNN DDB,-1		;Is there really a DDB pointer?
	JRST DPNONO		;No, this ain't supposed to happen!!
	TLNE DDB,KILDPY		;Don't flush DDB if just want to become non-display
	JRST DPNODP		;Becoming non-display
	PUSH P,IOS
	PUSH P,TAC
	MOVE IOS,DEVIOS(DDB)
	MOVE TAC1,TAC		;Line number
	HLL TAC1,LINTAB(TAC1)
	PUSHJ P,TTYKL5		;Flush TTY DDB now and TURN ON SCANNER
	POP P,TAC
	POP P,IOS
	JRST DPNOT3

DPNONO:	PUSHACS
	HRRZ TAC,TAC
	PUSH P,TAC
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/NO TTY DDB AT DPYKIL BUT TTYTAB NON-ZERO FOR TTY/]
	DISARG LOC,<-1(P)>
	[ASCIZ/
/]
	-1
	SUB P,[1,,1]
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	SETZM TTYTAB(TAC)
DPNOT4:	ONSCN
	JRST DPNOT3
;⊗ TPTINT TPTIN2 TPTIN3 DPKSTR DPKST2 DPKRLP DPKROL DPNODP DPNOT3 DPYKML

;Call with TTY line number in TAC (sorry) and DDB in DDB to interrupt
;job on TTY and controlling job if PTY for TTY status change.
;Clobbers AC1.

↑TPTINT:MOVSI AC1,INTTTC	;Interrupt on Terminal-Type-Change
	PUSH P,J
IFE FTIP,<
	CAIL TAC,PTYL0		;IS IT A PTY?
	SKIPN J,PTYJOB-PTYL0(TAC)
	JRST TPTIN2		;NOT A PTY OR NO CONTROLLING JOB
>;IFE FTIP
IFN FTIP,<
	CAIGE TAC,PTYL0		;Is it a PTY?
	JRST TPTIN2		;No
	SKIPE PTYIMP-PTYL0(TAC)	;Is it an IMP PTY?
	PUSHJ P,TPTIMP		;Yes, go tell IMPSER
	SKIPN J,PTYJOB-PTYL0(TAC) ;Is there a controlling job?
	JRST TPTIN2		;No
>;IFN FTIP
	TDNN AC1,JBTIEN(J)
	JRST TPTIN2
	IORM AC1,JBTIRQ(J)
	TDNE AC1,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, RUN INTERRUPTS
TPTIN2:	PUSH P,DDB
	SKIPN DDB,TTYTAB(TAC)
	JRST TPTIN3		;NO DDB
	LDB J,PJOBN		;Get job number of TTY user
	JUMPE J,TPTIN3
	TDNN AC1,JBTIEN(J)	;Is the user enabled for this interrupt?
	JRST TPTIN3		;No
	IORM AC1,JBTIRQ(J)	;Yes, request the interrupt
	TDNE AC1,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, RUN INTERRUPTS
TPTIN3:	POP P,DDB
	JRST POPJJ

;Output tty-no-dm string for this type of display.  Call with line nbr in TAC.
;Skips unless no DDB for this tty or isn't a DM.
;Enter at DPKSTR from FIXITY in IMPSER.  Enter at DPKST2 from DPKROL below.
↑DPKSTR:MOVE AC1,LINTAB(TAC)	;Don't do this unless a display
	TLNE AC1,DMLIN		;skip if not a display
DPKST2:	SKIPN DDB,TTYTAB(TAC)	;Should still be a DDB here...
	POPJ P,
	MOVSI TAC1,TTYFIL	;With TTY NO DM you get free TTY NO FILL!
	ANDCAM TAC1,LINTAB(TAC)
	SKIPN AC2,DPYDES(TAC)	;Get pointer to Display Descriptor Table
	MOVE AC2,DPYDFT		;Whaddayamean there isn't one??  Use default.
	HRRZ AC1,DPCNDM(AC2)	;Get address of dpy-specific TTY NO DM string
	HRLI AC1,441000		;Make 8-bit byte pointer
	HLRZ AC2,DPCNDM(AC2)	;Get byte count for TTY NO DM string
	SOJL AC2,CPOPJ1		;Jump if null string
	OFFSCN			;no TTY interrupts while filling output buffer
DPKRLP:	ILDB CHR,AC1		;Get next 8-bit char
	PUSHJ P,PUTCRS		;Put char directly into output buffer
	SOJGE AC2,DPKRLP	;Jump back if more to do
	ONSCN
	JRST CPOPJ1

;Finish TTY NO DM cmd, outputting spcl string for this display type.
DPKROL:	PUSH P,TAC		;Save line number
	PUSHJ P,DPKST2		;send tty no dm string for this dpy
	 JRST TPOPJ		;no DDB
	PUSHJ P,INLMES
	ASCIZ/
*** Non-display service ***
/
	PUSHJ P,TYPGO		;Now start output
	POP P,TAC		;Line nbr, restore and use to restore LINTAB
	POPJ P,

;Here if we want to make this display (DM) into a non-display. Scanner is off.
DPNODP:	MOVSI TAC1,DMLIN
	ANDCAM TAC1,LINTAB(TAC)	;No longer a display now
	PUSHJ P,TPTINT		;TTY and PTY status interrupt
	ONSCN
	MOVE DDB,(P)		;Get back dpy hdr address and display-type bit
	TLNE DDB,DMLIN
	PUSHJ P,DPKROL		;Output TTY NO DM string for this terminal
DPNOT3:	POP P,DDB
	MOVSI TAC1,KILDPY
	ANDCAM TAC1,TTYTAB(TAC)	;All done making this a non-display
	HRRZ AC2,DDB		;DPY HEADER ADDRESS
	MOVE J,JOBNM1
DPYKML:	CAIN AC2,@DPYMAP(J)
	SETZM DPYMAP(J)		;CLEAR GUY MAPPED TO US BY PROGRAM
	SOJG J,DPYKML

	;FALL THRU TO NEXT PAGE
;DPYK12 DPYK11 DPYKFS DPYKF1 DPYKF2 DPYKF3

	PUSHJ P,DPYKFS		;GIVE ALL THE CORE BACK
IFE FTF2,<
	JUMPL DDB,DPYK11	;JUST DIDDLE SELECT FOR III
>;IFE FTF2
IFN FTDD!FTGRIN,<
	TLNN DDB,DDDLIN
>;IFN FTDD!FTGRIN
	POPJ P,			;AGAIN DM'S SEEM TOO EASY
IFN FTDD!FTGRIN,<
	OFFSCN
	MOVSI AC3,-DDNUM	;SEE IF WE WERE HOME DD FOR SOME DD
	MOVEI AC2,0		;NEW VALUE OF HOME FOR ANY SUCH DDS
DPYK12:	LDB AC1,[HOMEPT+DDL0(AC3)]
	CAIN AC1,(TAC)		;WERE WE HIS HOME?
	DPB AC2,[HOMEPT+DDL0(AC3)] ;YES, BUT WE AREN'T ANY MORE
	AOBJN AC3,DPYK12
	ONSCN
>;IFN FTDD!FTGRIN
IFN FTGRIN,<
	POPJ P,
>;IFN FTGRIN
IFE FTF2,<
	SUBI TAC,DDL0		;MAKE IT DD NUMBER, ARG FOR VDOUTP
	HLRZ AC1,PRGNUM(DDB)	;DD CHANNEL NUMBER
	PUSHJ P,VDBIT		;MAKE A MASK BIT FOR THIS CHANNEL
	ANDCAM AC3,VDPRM(TAC)	;REMOVE DD LINE'S CHANNEL FROM HIS MAP
	MOVE AC3,AVLBIT
	IORM AC3,VDPRM(TAC)	;ADD IN THE AVAILABLE CHANNEL
	PUSHJ P,VDOUTP		;MAKE GUY GOING AVAILABLE SEE AVAILABLE MESSAGE
	MOVSI TAC,DTTUSR-DTTL0+DDL0(TAC) ;ARGUMENT FOR DDREL (OLD USE CODE)
	HLR TAC,PRGNUM(DDB)	;DD CHANNEL NUMBER
	JRST DDREL		;RELEASE THE DD CHANNEL
>;IFE FTF2

IFE FTF2,<
DPYK11:	MOVNI TAC,-DPYL0(TAC)	; NEGATIVE OF III NUMBER
	MOVSI AC1,400000	; PUT A BIT IN THE CONSOLE SELECT POSITION
	LSH AC1,-=12(TAC)	; PUT IT IN THE RESET PART FIRST
	ANDCAM AC1,DPYAVL+1	; DON'T RESET US
	ANDCAM AC1,WHOSEL	; DON'T RESET US FOR WHOLINE EITHER
	LSH AC1,=12		; PUT IT IN THE SELECT POSITION
	IORM AC1,DPYAVL+1	; SELECT THIS CONSOLE
	IORM AC1,WHOSEL		; SELECT THIS CONSOLE FOR SYS WHO LINE
	POPJ P,			; BYE NOW.
>;IFE FTF2

DPYKFS:	MOVNI AC2,3
	MOVEI AC3,DPYFS
	PUSHJ P,SFSREL		;GIVE BACK SPARE TEXT BLOCKS
	HLRZ DAT,PPCALL(DDB)
	JUMPE DAT,DPYKF2	;NO PAGE PRINTER
DPYKF1:	MOVE AC1,FBLKPT(DAT)
	PUSHJ P,FREEL		;RELEASE TEXT BLOCKS
	HRRZ AC1,PTB(DAT)
	JUMPE AC1,.+2
	PUSHJ P,FSGIVE		;& LINE POINTER TABLE
	MOVE AC1,DAT
	HRRZ DAT,PPLINK(DAT)	;GET POINTER TO NEXT P. OF P.
	PUSHJ P,UGIVFS		;BECAUSE THIS ONE'S GOING AWAY
	JUMPN DAT,DPYKF1	;KEEP GOING IF MORE
DPYKF2:	SKIPE AC1,DMFS(DDB)
	PUSHJ P,FSGIVE		;Return any special FS used by DM
	MOVEI AC2,(DDB)		;Get dpy hdr where CLRNED wants it
	OFFSCN
	PUSH P,TAC		;Preserve line number (DPYKILL) or whatever
	PUSHJ P,CLRNED		;Release variable char macro blocks (does ONSCN)
	POP P,TAC
DPYKF3:	MOVEI AC1,(DDB)
	JRST UGIVFS		;NOW RETURN HEADER
;DPYKS7 DPYKS9 DPYKI9 DPYK9 DPYKI7 DPYKI6 SCLOCK SCLOC2 CLRLED DPYKER
; WE GET HERE TO PLANT ANOTHER CLOCK REQUEST TO COME BACK
; LATER TO TRY AND KILL THE DAMN THING.

DPYKS7:	ONSCN
	JRST DPYKI7

DPYKS9:	ONSCN
DPYKI9:	SETZM LEACT(AC1)	; CLEAR THE ACTIVE FLAG
↑DPYK9:	SKIPN AC3,DDQDLY	;Get delay in case giving someone channel from queue
	MOVEI AC3,=15*=60	;Normally wait 15 seconds before killing display
	HRRZ AC2,PRGNUM(AC1)	;Get line number
	MOVE AC2,TTYTAB(AC2)	;See if we really just want to make into a non-dpy
	TLNN AC2,KILDPY		;Only wait one tick to try again to make non-DM
	TLOA AC3,$DPYKIL
↑DPYKI7:MOVE AC3,[$DPYKIL,,1]	;Wait one tick and check again
	LSH TAC,=12		; SHIFT LINE NUMBER OVER TO DATA POSITION
	ADD TAC,AC3		; HAVE US COME BACK HERE IN 1 TICK
	SETO AC2,		; SET FLAG SAYING THERE IS A CLOCK REQUEST IN
	EXCH AC2,LECLIN(AC1)
	JUMPL AC2,DPYKI6	; IF THERE ALREADY IS A CLOCK REQUEST IN, DON'T BOTHER TO SET ANOTHER
	CLKENQ(TAC)		;Plant clk req
	POPJ P,

;Here we try to speed up TTY NO DM, in case there was already a clock
;request in (for say 15 secs from now) to kill the dpy hdr, for instance if
;the user had just logged out.  Note that if we're from DPYKIL having to
;wait, we won't get here because LECLIN will have been zero.
DPYKI6:	ANDI AC3,7777		;Just clock delay we want
	CAIE AC3,1		;Want to wait one tick?
	POPJ P,			;No, not here from TTYNDM
	PUSHJ P,SCLOCK		;Search clock queue for request matching TAC
	 HRRM TAC,(AC3)		;Stuff new (shorter time) into clk req in queue
	POPJ P,

;Routine to search clock queue (not DPYSER's, but CLKSER's own) for clock
;request matching that in TAC (not counting the tick count in low 12 bits).
;Takes direct return with pointer to clock req in AC3 if found.  Otherwise skips.
;Clobbers AC2,AC3 only.
SCLOCK:	HRRZ AC3,CLOCKP		;GET END OF LIST
SCLOC2:	CAIG AC3,CIPWT-1	;END YET?
	JRST CPOPJ1		;YES, take failure return
	MOVE AC2,(AC3)		;Get clk req from queue
	XOR AC2,TAC		;Compare with clk req of interest
	TRZ AC2,7777		;Ignore time portion of req
	JUMPE AC2,CPOPJ		;Jump if matches
	SOJA AC3,SCLOC2

;Here with scanner PI channel off.
CLRLED:	SKIPE DDB,TTYTAB(TAC)	;Set up tty ddb
	TRNN DDB,-1
	JRST SCNONJ		;How can we not have a ddb?
	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,STLNAC		;Set up LINE
	MOVEI CHR,10044		;Send a CLEAR character
	SETZB UCHN,DSER		; with no bits
	PUSHJ P,KBDEDP		;Pretend user typed it
	JRST SCNONJ

; THIS ROUTINE PRINTS AN ERROR MESSAGE WHEN THE GIVEN
; LINE NUMBER IS NOT A DISPLAY

DPYKER:	PUSH P,TAC		; SAVE THE ILL NUMBER
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /DPYKIL/
	PUSHJ P,DISERR		; GIVE OUR ERROR MESSAGE
	[ASCIZ /NON-DISPLAY LINE NUMBER AT DPYKILL - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	POP P,TAC
	POPJ P,
;DPYINT NOSTOP L6 L5 L3 DPYXIT

IFE FTF2,<	;Whole page

;HERE ARE THE INTERRUPT ROUTINES FOR RUNNING THE DP.

↑DPYINT:

BEGIN DPYINT

DPCONB←←40	;THE CONTINUE BIT FOR THE DP
DPNULL←←0
DPNXM←←2000	;THE NON-EX MEM BIT
DPINT←←4000	;INTERRUPT REQUEST
DPSTOP←←200	;SET NOT RUNNING
DPCHK←←400	;ERROR CHECK FLAG

	CONSZ DPY,7
	JRST L10
	SETZM DSFLAG		;IF HERE FROM CLOCK, FLUSH CLOCK FLAG
IFKL10,<SKIPL PFPARF
	CONO PI,20020		;AND CLEAR INITIATED INT IF NOT GOING TO PARSER
>;IFKL10
L10:

;	CONSO DPY,400000	;IS IT REALLY STOPPED ?
;	JRST DPYXIT		;NO. 
	EXCH TAC,DRUNCT		;GET NO. OF DPY WHICH HAS BEEN ON.
	JUMPL TAC,L1A
	SKIPN STPTBL(TAC)	;STOP HIM HERE ONLY IF HE HAS A STOP TABLE
	JRST NOSTOP
	MOVEM TAC1,@SELTBL(TAC)
IFN 0,<
	MOVS TAC1,STPTBL(TAC)
	SETZM (TAC1)		;Clear the saved PC
REJMS:
>;IFN 0
	DATAO DPY,STPTBL(TAC)	;MAKE DP RECORD ITS STATE IN RIGHT DPY HDR AT PRGSTP
IFN 0,<
	ROT 44			;I don't know, just wait a little
	SKIPN (TAC1)		;Did the DP store anything?
	JRST REJMS		;No!  Tell it again
>;IFN 0
	CONI DPY,TAC1		;SAVE CURRENT SELECTION FOR NEXT TIME
	HRRI TAC1,DISSEL
	EXCH TAC1,@SELTBL(TAC)
NOSTOP:	CONSZ DPY,DPNXM!DPCHK	;HIT A NON-EX MEM OR ERROR CHECK?
	JRST DPERR		;YES, PROCESS IT
L6:	SOJL TAC,L1		;NEXT PRGM TO RUN. (6 PRGMS ALWAYS ARE RUNNING)
L5:
;	CONSO DPY,400000	;MAKE SURE HE FINISHED STOPPING
;	JRST L5
	SKIPE RSTTBL(TAC)	;DOES HE WANT TO START FROM THE FRONT ?
	JRST L2			;YES.
	SKIPN STRTBL(TAC)	;IS THERE A PROGRAM THERE?
	JRST L7
	DATAO DPY,STRTBL(TAC)	;NO.  START HIM AT NORMAL PLACE TO RESUME
L3:	EXCH TAC,DRUNCT		;PUT THINGS BACK.
	ROT 44
	CONO DPY,DPCONB+DPYCHN+740000+1000	;START DP AND CLEAR MASKS.
DPYXIT:

	MTRCOF (CH3,P2NOCK)

IFN FTXADR,<
	XJEN DPYCHL		;RETURN TO WHOMEVER.
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@DPYCHL		;RETURN TO WHOMEVER.
>;IFE FTXADR

>;IFE FTF2	;Whole page
;DPERR DPENNX NOADDR NOMBSY NODPLK L8 L9

IFE FTF2,<	;Whole page

;HERE WE HAVE AN ERROR - - PRINT A MESSAGE AND CHECK THE SYSTEM!
DPERR:	EXCH P,APRPDL		;GET A STACK
	PUSHACS			;GET US SOME AC'S
	MOVEI PID,P1PID
	MOVEM TAC,SAVTAC	;SAVE DP #
	CONI DPY,DPCNI		;GET SOME BITS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /DPERR/
	PUSHJ P,DISERR
	[ASCIZ/DP ERROR.  DPY# = /]
	DISARG LOC,SAVTAC
	[ASCIZ/  CONI BITS = /]
	DISARG OCH,DPCNI
	-1
	MOVE AC3,DPCNI		;See if we got a NXM
	TRNN AC3,DPNXM		;NXM bit on?
	JRST DPENNX		;No
	PUSHJ P,DISMES
	 ASCIZ/  NXM  /
DPENNX:	MOVE AC3,SAVTAC
	SKIPN AC3,STPTBL(AC3)
	JRST NOADDR
	HLRZS AC3
	HLRZ AC3,(AC3)		;GET MA
	PUSHJ P,DISERR
	[ASCIZ/    MA = /]
	DISARG LOC,AC3
	-1
NOADDR:	PUSHJ P,DISMES
	 ASCIZ/   MPX CONI = /
	CONI MPX,TAC		;Get MPX bits to see if it is losing
	PUSH P,TAC
	PUSHJ P,DISLOC		;Print 'em
	POP P,TAC
	TRNN TAC,MBUSY		;MPX maybe have BUSY stuck on?
	JRST NOMBSY
	PUSHJ P,DISMES
	 ASCIZ/  BUSY/
NOMBSY:	PUSHJ P,DISCRL
	PUSHJ P,CHKNOW		;CHECK SYSTEM FOR CLOBBERAGE
	MOVE TAC,DPCNI
	TRNN TAC,DPNXM		;Pause in DDT if DP NXM
	JRST NODNXM		;No NXM
	PUSHJ P,DISFLUSH	;FORCE OUT THE REST
	PUSHJ P,WDDTCALL	;AND CALL DDT
	JRST NODPLK

NODNXM:	DEBCHECK(NOPOPACS)	;CALL DDT IF HAVE SEEN TOO MANY OF THESE
NODPLK:	PUSHJ P,ZSHAD		;ZERO SHADOW ACS, IN CASE III GETS THERE
	 JFCL			;May skip
	MOVE TAC,DPCNI
	TRNE TAC,DPNXM		;Did we see a NXM?
	CONO MPX,20000		;Yes, reset the MPX for good measure
	MOVEI TAC,DPYNUM-1	;RESTART ALL DISPLAYS
L8:	SKIPN DDB,LETAB+DPYL0(TAC)
	JRST L9			;IF NONE THERE, LOOP
	HRLI AC1,PSELB(DDB)	;ARRANGE TO RESTART AT TOP AGAIN
	HRRI AC1,DISJMP
	MOVEM AC1,RSTTBL(TAC)
	MOVEM AC1,PRGSTP(DDB)	;Clobber old continue PC to really restart
				; at beginning, in case DATAO DPY,STPTBL loses!
L9:	SOJGE TAC,L8		;GET THEM ALL!
	POPACS			;GET BACK AC'S
	EXCH P,APRPDL		;AND WHATEVER WAS IN P
	JRST L6			;AND DO NEXT GUY

>;IFE FTF2	;Whole page
;L2 L1 L1A L4 L7

IFE FTF2,<	;Whole page

; DP INTERRUPT CODE - RESTART PROGRAM, LOOP AROUND OF NEXT DPY, STOP DP, SET AVAILABLE MESSAGE

L2:	DATAO DPY,RSTTBL(TAC)	;START GUY AT BEGINNING OF HIS PRGM.
	SETZM RSTTBL(TAC)	;...THIS TIME ONLY.
	JRST L3

L4:	CONO DPY,DPNULL		;SHUT DOWN THE DP.
	EXCH TAC,DRUNCT
	JRST DPYXIT

L7:	SKIPE DPYARN		;HAS THE 'CONSOLE AVAILABLE' MESSAGE GONE OUT YET?
	JRST L6			;YES
	SETOM DPYARN		;NO, IT WILL.
	DATAO DPY,[DPYAVL,,DISJMP]
	JRST L3			;GO START UP DP AND LEAVE

L1:	DATAO DPY,[COMIII,,DISJMP]	;HERE IF DRUNCT WAS 0, PUT OUT WHO LINES
	JRST L3

L1A:	AOJN TAC,L1C		;HERE IF DRUNCT WAS NEG, JUMP IF WAS -2
	LDB TAC,[POINT 6,DPYHLD,5]	;WAS -1, HOLDING MSG NOT YET OUT
	JUMPN TAC,L1B		;NEED TO RUN HOLDING MESSAGE
L1C:	MOVEI TAC,DPYNUM-1	;WE'VE RUN 'EM ALL.
	SETZM DPYARN		;NOTE THAT THEY HAVE ALL BEEN RUN
	AOSE DSFLAG		;HAS CLOCK TICKED ?
	AOJA TAC,L4		;NO. IT'S NOT YET TIME TO START OVER.
	JRST L5

L1B:	MOVNI TAC,2		;DRUNCT ← -2
	DATAO DPY,[DPYHLD,,DISJMP]
	JRST L3

BEND DPYINT

>;IFE FTF2	;Whole page
;PPINIT PPI1 PPI3 -- PAGE PRINTER STUFF

COMMENT ⊗	THIS IS THE ABODE OF THE FEARSOME PAGE PRINTER.  IT ALLOWS
EACH LUCKY USER (IF HE IS OBEDIENT) TO HAVE UP TO 16 PIECES OF PAPER (OR
REASONABLE FACSIMILE THEREOF), ON ANY OF WHICH HE CAN TYPE AND DRAW IN
DIVERSE WAYS, AND WHICH CAN BE ROLLED BACKWARD AND FORWARD AND DISPLAYED
SEPARATELY OR IN ARBITRARY COMBINATION WITH OTHER DISPLAYS.
    EACH PIECE OF PAPER CONSISTS OF A LINKED SET OF BLKS FROM FREE STORAGE
AND ONE CONTROL BLOCK, ALSO FROM FREE STORAGE. THE CONTROL BLOCK IS LINKED
TO THE PROGRAM HEADER AND TO THE CONTROL BLOCKS FOR ANY OTHER PIECES OF
PAPER BELONGING TO THE SAME PROGRAM. ⊗

; WE GET HERE MOSTLY IF A REQUEST FOR FREE STORAGE FOR THE PAGE PRINTER FAILS
PPI3:	HRRZ AC1,CBLKPT(DAT)	; RETURN FIRST PIECE OF TEXT
	PUSHJ P,FSGIVE
PPI1:	HRRZ AC1,DAT		; AND RELEASE CONTROL BLOCK ITSELF
	PUSHJ P,FSGIVE		; TAKE ERROR RETURN FROM PPINIT
	POPJ P,			; PLEASE DON'T OPTIMIZE!

;INITIALIZE A PAGE PRINTER WITH PIECE OF PAPER 0.
;CALL WITH MAIN DD CHANNEL IN TAC, OR IF NOT DD, WITH LINE BITS IN TAC RH (NOTE RH)
;Also, dpy hdr address must be in DDB.
PPINIT:	PUSHJ P,PPFSGE		;GET A BLOCK OF FREE STORAGE.
	 POPJ P,		; NO FREE STORAGE, GIVE ERROR RETURN
	HRR AC3,AC2		;MAKE BLT POINTER.
	HRRZ DAT,AC2
	HRLI AC3,PPMODL
	BLT AC3,BLKSIZ-1(AC2)	;INIT THE CONTROL BLK BY COPYING PROTOTYPE INTO IT
	PUSHJ P,PPFSGE		;GET A FREE STORAGE BLOCK FOR FIRST PART OF PRGM
	 JRST PPI1		; NO FS, RELEASE PREVIOUS BLKS, TAKE ERROR RETURN
	MOVEM AC2,CBLKPT(DAT)	;MAKE IT CURRENT BLOCK...
	MOVEM AC2,FBLKPT(DAT)	;.. AND FIRST BLOCK IN CORE...
	MOVEM AC2,TBLKPT(DAT)	;... AND TOP BLK BEING DISPLAYED.
	HRRM AC2,PPTR1(DAT)	;MAKE BYTE POINTER FOR TYPING POINT
	SOS PPTR1(DAT)		; ONE BEFORE BOTTOM OF BLOCK.
	HRLM AC2,TPJMP(DAT)	;FIX UP JMP TO PRGM IN CONTROL BLOCK
	HRLI AC3,TPJMP+1(DAT)	;RETURN ADDR FROM PRGM TO CONTROL BLK
	HRRI AC3,DISJMP
	MOVEM AC3,(AC2)		;PUT RETURN JMP IN FIRST WORD OF PRGM.
	HRLZM DAT,PPLINK(AC2)	;BACKWARD LINK OF PRGM POINTS TO CONTROL BLOCK
	SETZM PPLINK(DAT)	;ONLY ONE CONTROL BLOCK.
	MOVE AC3,[DDDLIN,,POSLDD]
	TRNE TAC,DISLIN
	MOVE AC3,[DISLIN,,POSLII]
	TRNE TAC,DMLIN
	MOVE AC3,[DMLIN,,POSLDM]
	MOVEM AC3,PPDPY(DAT)	; STORE BITS FOR DISPLAY TYPE AND POSLIN SUBROUTINE
;⊗ PPINNP PPFXT

	MOVEI AC3,LPFS		; GET SOME FREE STORAGE FOR THE
	PUSHJ P,SFSGET		; LINE POINTER TABLE
	 JRST PPI3
	MOVEM AC1,PTB(DAT)	; SAVE ADDRESS OF BEGINNING OF BLOCK
	ADDI AC1,=20		; BUMP ADDRESS TO VISIBLE SCREEN PART
	HRRM AC1,PTRB(DAT)
	MOVE AC2,PPTR1(DAT)	; INITIALIZE FIRST WORD OF POINTER TABLE
	ADDI AC1,YLINE-1	; Starting on 4th line of screen
	MOVEM AC2,(AC1)		; TO POINT TO FIRST OF TEXT
	MOVEM AC2,1(AC1)	; SAME FOR DD
	TRNE TAC,DISLIN
	JRST PPFXT		; DONE FOR III
	MOVEI AC1,YLINE		; Start on line 4
	MOVEM AC1,VPOS(DAT)
	MOVEM AC1,LLW(DAT)
	MOVEM AC1,GLW(DAT)
	MOVEI AC1,NLSDD		; DEFAULT NUMBER OF LINES/GLITCH FOR DD
	TRNE TAC,DMLIN
	MOVEI AC1,NLSDM		; DEFAULT L/G FOR DM
	MOVEM AC1,DEL(DAT)
	MOVEM AC1,DELCNT(DAT)
IFE FTF2,<	;GRINNELL USES DMNORM JUST LIKE DM DOES
	MOVEI AC1,NGSDD		; DEFAULT NUMBER OF GLITCHES/SCREEN FOR DD
	TRNE TAC,DMLIN
>;IFE FTF2
	PUSHJ P,DMNORM		; GET DEFAULT GLITCHES/SCREEN FOR DM INTO AC1
	MOVEM AC1,PGSIZ(DAT)	; STORE GLITCHES/SCREEN
	SETZM DDSAV(DAT)	; CLEAR EXTRA SAVED WORDS
IFN FTDD,<
	MOVE AC1,[CW 1,46,2,0,3,2]
	DPB TAC,[POINT 8,AC1,15]
>;IFN FTDD
IFN FTGRIN,<
	MOVE AC1,DCHWID(DDB)	;Get char width in pixels
	DPB AC1,[POINT 10,GRCW4(DAT),15] ;Store X pos in LEA command
	DPB AC1,[POINT 10,GRCW3(DAT),15] ;Store delta-X per char
	MOVE AC1,GRCHAN(TAC)	;Get LDC and LSM commands to select right screen
>;IFN FTGRIN
	MOVEM AC1,DDCW(DAT)
	SKIPN AC2,CURPP(DDB)	;any previous PP set up?
	JRST PPINNP		;no, must be new dpy
	LDB AC1,PBAKCL		;get DD color bit of previous PP
	MOVE AC2,DAT		;make PBAKCL point to new PP
	DPB AC1,PBAKCL		;copy old color to new PP
PPINNP:	MOVE AC2,DPYHGT(DDB)	;Get display height
	MOVEM AC2,PPSHGT(DAT)	;Store in PP
	MOVE AC2,DPYWID(DDB)	;Get display width
	MOVEM AC2,LNLNGT(DAT)	;Store as PP line length
	MOVNM AC2,DPHPOS(DAT)	; INITIALIZE THE HORIZONTAL POSITION COUNTER
	MOVE AC1,[LVW -777,YPDD,I,A,2,2]
	TRNE TAC,DMLIN
	MOVE AC1,[LVW -777,YPDM,I,A,2,2]
	MOVEM AC1,PPOSV(DAT)
	LDB AC1,[POINT 11,AC1,21] ;INITIAL Y POSTION IS GUARANTEED POSITIVE!!!
	HRRM AC1,PPYVAL(DAT)	;INITIALIZE 18-BIT VALUE OF Y POSITION
	SETZM TPJMP+1(DAT)
	SETZM TPJMP+2(DAT)
IFN FTDD,<
	MOVE AC1,[CW 3,2,4,0,5,0]
	MOVEM AC1,DDCW2(DAT)
>;IFN FTDD
PPFXT:	MOVE AC1,DAT
	JRST CPOPJ1
;PPFSGE CGETFS UGFS2 UGETFS CGIVFS UGIVFS GETQ UGETF2 UGETF1 UGETF3 UGETF4
; FREE STORAGE HANDLER FOR PAGE PRINTER

PPFSGE:	MOVE AC2,AC1
	MOVEI AC3,PPFS
	AOS (P)
	PUSHJ P,SFSGET
	 SOS (P)
	EXCH AC2,AC1
	POPJ P,

;;UGETFS IS FOR GETTING FREE STG. AT UUO LEVEL (INCLUDING SPW LEVEL)
; CGETFS AND CGIVFS ARE ONLY CALLED BY UPG, (AT UUO LEVEL OR SPW LEVEL) TO COUNT THE
; TOTAL NUMBER OF BLOCKS IN A USERS COMBINED DISPLAY PROGRAMS
; CGETFS EXPECTS THE DPY HEADER ADDRESS IN DDB

;CGIVFS must use wait list for III FS, lest III still running
;
;On F2, if we are called from UUO level, we would rather wait for free storage
;than take from the spares list.  This is flagged in DPYFS (CACDAT).
;
;In either case, we never want to go to CLKWAT from user mode.
CGETFS:	AOSA BLKTOT(DDB)
UGFS2:	PUSHJ P,CLKWAT		;WAIT FOR SOME FS TO APPEAR.
↑UGETFS:MOVEI AC3,DPYFS		;;GET A BLOCK OF FREE STG
	PUSHJ P,SFSGET
	  SKIPE AC1,SPWUUF	;WE ARE AT CLOCK LEVEL AND THERE'S NO FREE STG.
	POPJ P,
	SKIPN AC1,INTACT	;AT USER INTERRUPT LEVEL
	CONSZ PI,77000		;OR REGULAR INTERRUPT LEVEL, BUT NOT CLOCK LEVEL?
	 JRST UGETF4		; TAKE FAILURE RETURN
	CONSZ PI,77400		;USER MODE?
	 JRST UGFS2		; NO, WAIT AT CLOCK LEVEL
	MOVEI AC3,BLKSIZ	;GET STANDARD SIZE BLOCK
	JRST UGETF1		;THIS ONE WILL WAIT!

; ROUTINE TO RELEASE FREE STORAGE BLOCKS
; CGIVFS EXPECTS THE DPY BLOCK HEADER ADDRESS IN DDB

CGIVFS:
IFN FTF2,<
	SOS BLKTOT(DDB)		;DECR. COUNT OF USED BLOCKS...
	PUSHJ P,FSGIVE		; DON'T OPTIMISE
	POPJ P,
>;IFN FTF2
IFE FTF2,<
	SOS BLKTOT(DDB)		;DECR. COUNT OF USED BLOCKS...
>;IFE FTF2
↑UGIVFS:SYSPIFF
	MOVE AC2,FSWT2H		;FREE THE BLOCK IN AC1.
	HRRZM AC1,FSWT2H
	HRRM AC2,PPLINK(AC1)
	SYSPIN
	AOS FSW2C
	POPJ P,

;GET A DD Q BLOCK
↑GETQ:	PUSH P,AC3
	MOVE AC3,[SETZ DDFS]	;NO SKIP
	PUSHJ P,SFSGET
	POP P,AC3
	POPJ P,

; UGETF1 IS LIKE ALL THE OTHERS EXCEPT THAT IT GOES DIRECTLY TO THE
; STANDARD F.S. ROUTINES, RATHER THAN USING THE SPARE LIST.  IF WE
; FAIL TO GET FREE STORAGE AND WE CAN'T WAIT (SPACEWAR, USER INT.),
; THEN RETURN -1. (MAYBE THE USER WON'T MISS ONE TIC OF DISPLAY.)

UGETF2:	PUSHJ P,CLKWAT		;At clock level.  Wait a tic and try again
UGETF1:	SKIPN AC1,SPWUUF	;Can we wait?
	SKIPE AC1,INTACT
	 JRST UGETF3		;  No, allow failure return
	PUSHJ P,FSGET		;Get free storage at user or interrupt level
	 SKIPA AC1,[-1]		;  Failed, perhaps return -1
	POPJ P,
	CONSO PI,77000		;Are we at interrupt level?
	 JRST UGETF2		;  No, must be clock level.
	POPJ P,

; Special case for spacewar mode or user interrupt level
UGETF3:	PUSHJ P,FSGETU		;Get free storage but don't wait
UGETF4:	 SETO AC1,		;  Failure return
	POPJ P,
;BELOW IS THE PROTOTYPICAL P. OF P. CONTROL BLOCK.
;The typical block is defined for the III displays.  Others get various
;cells changed after the prototype is copied to FS.

DEFINE X (A,B) {A←.-PPMODL
		B
		}
PPMODL:  

X PPOSV←,{LVW  -777,YPIII,I,A,2,2}	;POS VECTOR
X ↑TPJMP←, DISJMP	;JMP TO FIRST BLOCK OF PAGE BEING DISPLAYED.
	LVW (7,-17,I)	;NOW DRAW THE CURSOR.  DD EXECUTE sometimes placed here.
	LVW -5,-10	;DD always halts here.
IFE FTGRIN,<
 X ↑DDCW←,<LVW 12,0>	;For DD, this gets a CW 1,46,2,0,3,2
 X DDCW2←,<LVW -5,10>	;For DD, this gets a CW 3,2,4,0,5,0
>;IFE FTGRIN
IFN FTGRIN,<
 X ↑DDCW←,<GW G.LDC,0,G.LSM,0>      ;Channel and subchannel masks inserted here
 X GRCW2←,<GW G.LWM,G.WMV,G.LUM,12> ;Write mode and update mode for Grinnell
 X GRCW3←,<GW G.LEB,GRESIZ,G.LLB,0> ;Set delta-X and -Y for each char.
 X GRCW4←,<GW G.LEA,GRESIZ,G.LLA,0> ;Set initial X and Y positions (stored later)
>;IFN FTGRIN
X PPJMP←,<LVW (-7,7,I)>	;For DD and Grinnell, a jump to text is placed here.
X ↑PPRJMP←, DISJMP	;JMP BACK TO HEADER OR ON TO NEXT CONT. BLK.

X HEDPTR←,0		;POINTER BACK TO PRGM HEADER.
X OUTCNT←,OUTNUM	;BLOCKS REMAINING BEFORE DISK OUTPUT.
X ↑PPNO←,0		;NO. OF THIS P. OF P.
X ↑DPHPOS←,-LINELN	;CHARS. LEFT BEFORE END OF THIS LINE.
X CNT1←,0		;CHARS. REMAINING  BEFORE EXTENSION NEEDED.
X PPTR1←,{POINT 7,0,35}	;CURRENT POINTER FOR PRINTING ON THIS PIECE OF PAPER.
X SPTR1←,0		; SAVED POINTER FOR ZEROING OUT SPACE BEFORE CR
X WCNT←,-INITWC		;FREE WORDS LEFT IN CURRENT BLOCK.
X CBLKPT←,0		;BOTTOM OF CURRENT BLOCK.
X ↑TBLKPT←,0		;FIRST BLOCK CURRENTLY DISPLAYED (AT TOP OF SCREEN)
X FBLKPT←,0		;FIRST BLOCK STILL IN CORE.
X DEL←,2		; NO. OF LINES IN A GLITCH.
X DELCNT←,2		;LINES REMAINING IN CURRENT GLITCH.
X GLCNT←,1		;CURRENT SIZE OF PAGE IN GLITCHES.
X PGSIZ←,14		;NOMINAL SIZE OF PAGE IN GLITCHES.
X PTBEG←,0		; INCREMENT INTO LINE POINTER TABLE
X DDSPT←,0		;POINTS TO SAVED WORD FROM FIRST REFRESHED LINE (DD)
X DDSAV←,0		;SAVED WORD FROM FIRST REFRESHED LINE (DD)
	0
X ↑VPOS←,0		;LINE NUMBER OF CURRENT LINE (ON III, RELATIVE TO PP TOP)
X LLW←,0		;LAST LINE WRITTEN (AS VPOS, GLW, RELATIVE TO PP TOP ON III)
X PTRB←,<XWD AC3,0>	;POINTS TO TABLE OF BYTE POINTERS TO THE FIRST OF EACH LINE (DD)
X PTB←,0		; ACTUAL TABLE ADDRESS
X VP←,0			; VERTICAL POSITION ARGUMENT TO QDD
X SC←,0			; ARGUMENT TO QDD FOR COUNT FIELD ADDRESS
X DPYCHR←,0		; FLAG SAYING AT LEAST ONE CHARACTER HAS BEEN TYPED
X LSTCHR←,12		; LAST CHARACTER DEPOSITED INTO BUFFER
X FAKELF←,0		; -1 IF DTYO HAS JUST INVENTED A LF FOR DPYTYP
X GLW←,0		; GREATEST LINE WRITTEN, FOR ERASING WHEN WE GLITCH
X ↑PPDPY←,0		; LH IS BIT TELLING DISPLAY TYPE, RH IS POSLIN SUBROUTINE
X GLTCH←,0		; FLAG THAT SAYS THE PAGE PRINTER HAS GLITCHED
X PPINV←,0		; FLAG INDICATING PAGE PRINTER POINTERS ARE BEING MODIFIED
X PPENQ←,0		; NUMBER OF TASKS THIS PAGE PRINTER HAS IN THE DD QUEUE
X PPNQT←,0		; COUNT DOWN FOR NON-PAGE PRINTER REQUESTS
X PPVIRG←,-1		; INDICATES VIRGIN PAGE PRINTER
X DMLAST←,0		;Byte pointer to last character queued from this PP
X DMPPXY←,0		;X-Y position for next char output on this PP
X DMGLCH←,0		;Minus number of lines of glitching needed for this PP on DM
X PPYVAL←,YPIII		;Y position for PP, in DPYPOS format
X PPSHGT←,HGTIII	;Height of screen in text lines
X ↑LNLNGT←,LINELN	;LINELENGTH FOR THIS GUY.
;Don't put any cells after LNLNGT because BLKSIZ is defined below from LNLNGT.

; ALL DISPLAY PROGRAM SPACE IS TAKEN FROM A FREE
;  STORAGE AREA CONSISTING OF FIXED SIZE BLOCKS.  THE
; FOLLOWING PARAMETERS RELATE TO THOSE BLOCKS.

↓BLKSIZ←←<<LNLNGT+5+1>!<TRIVIAL-1>>-1	;BLOCK SIZE. THIS IS ARBITRARY, BUT ≥36
↑BLKSIZ←←BLKSIZ
↑PPLINK ←← BLKSIZ-1	;LINKS IN LAST WD OF BLK: XWD BACK,FORWARD
↓BLKBTS ←← PPLINK-1	;MAGIC TYPE BITS FOR BLK GO HERE.
↓GCINFO ←← BLKBTS-1	;INFO FOR THE (HYPOTHETICAL) GARBAGE COLLECTOR
FSBSIZ←←BLKSIZ-2	;BLKSIZ FOR OUTSIDE WORLD.
↑FSLINK←←PPLINK
↓CNT←←GCINFO-2		;MAX. NO. OF 'GLITCHES' PER PAGE.
INITWC←←GCINFO-2	;THIS MANY WORDS/BLOCK AVAILABLE FOR PROGRAM.
;DTYO DPYTYO TYO0

;DTYO--CHARACTER IN CHR, DAT POINTS TO P.OF P. CONTROL BLOCK.
;DPYTYO IS CALLED FROM LINED TO ECHO INPUT CHARACTERS AND THEIR CONTROL BITS
;DTYO IS CALLED FROM DPYTYP AT CLOCK LEVEL WITH A CHARACTER FROM THE OUTPUT BUFFER

;THESE ROUTINES PLACE CHARACTERS IN THE DISPLAY'S PIECE OF PAPER TEXT BLOCKS
;DDB MUST POINT TO DPY HEADER

↑↑DPYTYO:
	MOVE DAT,CURPP(DDB)	; PICK UP POINTER TO PAGE PRINTER CONTROL BLOCK
	HLL DAT,DDB		; PUT IN DISPLAY BITS
↑DTYO:	MOVE AC1,LSTCHR(DAT)	; PICK UP LAST CHARACTER TYPED
	TLNN DAT,DDDLIN
	JRST .+3
	CAIN AC1,177		; LAST CHAR A DELETE ON A DD?
	JRST DELNOW		; YES, <DELETE><CHR> IS A SINGLE NORMAL GRAPHIC.
	JUMPE CHR,CPOPJ		;DON'T PRINT NULLS.
	JUMPGE AC1,TYO0		;JUMP UNLESS THE LAST THING WE DID WAS INVENT CRLF.
	CAIN CHR,15		;A CR AFTER WE INVENTED A CRLF?
	POPJ P,			;YES. SUPPRESS IT.
	MOVEI AC1,12		;MAKE IT LOOK LIKE THE LAST CHARACTER WAS LF.
	MOVEM AC1,LSTCHR(DAT)	;SET IT.
	CAIN CHR,12		;CHARACTER IS LF?
	POPJ P,			;YES. SUPPRESS THAT TOO.
				;NOW IT LOOKS LIKE NORMAL CHARACTER, LSTCHR SET.
TYO0:	SETOM DPYCHR(DAT)	; NOTE THAT ANOTHER CHARACTER HAS BEEN PUT INTO PP
	CAIN CHR,15		; IS IT A CR ?
	JRST PR1ECR		; YES, GO SERVICE IT
	JUMPL DAT,TYO1		; IF III, WE CAN SKIP ALL THIS BULLSHIT
	CAIE AC1,12		; WAS LAST CHARACTER A LF?
	JRST TYO1		; NO
;ON DD OR DM, FIRST CHARACTER AFTER LF
	MOVE AC1,DPHPOS(DAT)	; WELL, ARE WE AT THE BEGINNING OF THE LINE?
	ADD AC1,LNLNGT(DAT)
	JUMPE AC1,TYO4		; YES, THERE MUST HAVE BEEN A CR FIRST.
	PUSH P,CHR		; SAVE OUR CHARACTER
	PUSH P,AC1		; SAVE THE COUNT (I.E., COLUMN NUMBER.)
	SETZ CHR,
	DPB CHR,SPTR1(DAT)	; REPLACE LF WITH NULL
	MOVEI CHR,15
	PUSHJ P,PUT2CH		; Put in CR, making sure there is room for LF
	MOVEI CHR,12		; PUT OUR LF BACK
	SOS VPOS(DAT)
	PUSHJ P,PUTCH1
	PUSHJ P,EOLSET		; STORE THE POSITION OF OUR NEWLY MOVED LF
;FALL THRU TO NEXT PAGE
;TYO5 TYO1 TYO2 TYO7 DELNOW IIILED IIILE2

;FELL THRU FROM PREVIOUS PAGE
	MOVEI CHR,40		;TYPE A BUNCH OF SPACES TO SIMUALTE A BARE LF.
TYO5:	PUSHJ P,PUTCH1		;SEND A SPACE.
	SOSLE (P)		;DECREMENT THE SPACE COUNT.
	JRST TYO5		;LOOP SPACING.
	SUB P,[1,,1]		;ADJUST STACK TO REMOVE SPACE COUNT.
	POP P,CHR		;RESTORE CHARACTER. FALL INTO TYO1
TYO1:	CAIN CHR,12		; OR A  LINE FEED ?
	JRST PR1EOL		;YES.
	JUMPL DAT,TYO2		; IF III, JUST PUT THE CHARACTER IN THE BUFFER
	MOVE AC1,DPHPOS(DAT)	; ARE WE AT THE LEFT MARGIN?
	ADD AC1,LNLNGT(DAT)
	JUMPN AC1,TYO2		; NO
	MOVE AC1,LSTCHR(DAT)	; YES, WAS LAST CHARACTER A LF?
	CAIN AC1,12
	JRST TYO2
	PUSH P,CHR		; NO, PUT ONE IN!
	MOVEI CHR,12
	PUSHJ P,PUTCH1
	SOS LHCNT(DDB)		;DECREMENT LINE COUNTDOWN FOR AUTO HOLDING
	PUSHJ P,EOLSET		; STORE LINE POINTER
	SOSG DELCNT(DAT)	; TIME TO GLITCH YET?
	PUSHJ P,PREOGL		; YES, DO IT.
	POP P,CHR
TYO2:	CAIN CHR,11		; TAB?
	PUSHJ P,PR1TAB		; YES, GO EXPAND IT.
	PUSHJ P,PUTCH1		; PUT CHARACTER INTO BUFFER
TYO7:	MOVEM CHR,LSTCHR(DAT)	; SAVE LAST CHARACTER
	TLNN DAT,DDDLIN
	JRST .+3
	CAIN CHR,177		;IS THIS A DELETE?
	JRST .+3		;YES. FOR DD AVOID CHANGING THE H.POSITION.
	AOSL DPHPOS(DAT)	;UPDATE HORIZONTAL POS.
	JRST PRCR		;OVER END OF LINE..  INSERT CR LF.
IFN FTDD,<
	PUSHJ P,IIILED		;Position line editor if on III
	MOVE AC1,[CW 0,0,3,2,3,2]
	TLNE DAT,DDDLIN		; IF WE ARE A DD
	MOVEM AC1,TPJMP+1(DAT)	; AND THE LINE DOESN'T END WITH CRLF, PUT IN AN EXECUTE
>;IFN FTDD
	POPJ P,

;DD. LAST CHARACTER WAS A DELETE. THIS CHARACTER WILL MAKE AN ORDINARY GRAPHIC.
DELNOW:	PUSHJ P,PUTCH1		;PUT CHARACTER IN BUFFER
	IORI CHR,200		;MAKE IT SPECIAL SO WE WON'T COMPARE EQUAL TO IT
	JRST TYO7

;Here to update display position of III line editor at end of current PP.
;Call with DDB pointing to dpy hdr, DAT pointing to PP of interest.
;Clobbers only AC1.
IIILED:
IFE FTF2,<
	SKIPN III(DDB)
	POPJ P,			;Do nothing if not on III
	HRRZ AC1,CURPP(DDB)
	CAIE AC1,(DAT)
	POPJ P,			;Not current PP
	PUSH P,AC3
	MOVE AC3,VPOS(DAT)	;Get current line number, relative to top of PP
	IMUL AC3,[-30B21]	;Times adjustment per line
	ADD AC3,[-10B21]	;Move LE display down 1/3 line
	ADD AC3,PPOSV(DAT)	;Add in saved position word (for top of PP)
	MOVE AC1,DPHPOS(DAT)	;Get number of columns left on last line
	ADD AC1,LNLNGT(DAT)	;Make it into X-position in columns
	IMULI AC1,14		;Times adjustment per column
	SUBI AC1,777		;Plus position of left margin
	DPB AC1,[POINT 11,AC3,10] ;Put into III position word
	MOVEM AC3,LEDPOS(DDB)	;Put position word into dpy hdr
	POP P,AC3
>;IFE FTF2
	POPJ P,
;TYO4 PR1TAB PR1TB1

;HERE ON DD OR DM IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
;CURRENT CHAR IS NOT A CR
TYO4:	CAIE CHR,12		; IS THIS CHARACTER A LF?
	JRST TYO2		; NO, JUST DUMP THE CHARACTER IN THE BUFFER
	PUSHJ P,PR1EC2		; YES, PUT IN A SPACE AND A CR AND A LF
	MOVEI CHR,12		; AND THEN A LF
	MOVEM CHR,LSTCHR(DAT)
	POPJ P,

;WE GET HERE TO PRINT SPACES FOR A TAB
PR1TAB:	SETCM AC1,DPHPOS(DAT)	;GET CURRENT HORIZONTAL POSITION.
	SUB AC1,LNLNGT(DAT)	; MAKE TABS START IN COLUMN 8
	ANDI AC1,7		;GET NO. OF SPACES TO NEXT MULTIPLE OF 8 BOUNDARY.
	ADDM AC1,DPHPOS(DAT)	;UPDATE HIM.
	TLNE DAT,DMLIN		;DATAMEDIA DISPLAY?
	POPJ P,			;YES, IT HAS HARDWARE TABS! (WHICH WE HAVE SET)
	PUSH P,AC1		;PUT COUNT OF EQUIVALENT SPACES ON STACK
	PUSHJ P,PUTCH1		;FIRST PRINT THE TAB.
	MOVEI CHR," "		;NOW OUTPUT RIGHT NUMBER OF SPACES.
PR1TB1:	PUSHJ P,PUTCH1		;NOW EMIT A SPACE.
	SOSL (P)		;..AND SOME MORE, IF APPROPRIATE.
	JRST PR1TB1
	MOVEI CHR,11		;WE WILL FINISH OFF WITH ANOTHER TAB.
	SUB P,[1,,1]		;DISCARD COUNT FROM STACK
	POPJ P,
;PRCR PRCR3 PRCR2 PUT2CH PUTCH1 PUT2C3 PUT2C4 PUT2C2

;STICK A CRLF IN TO BREAK UP LONG LINES
PRCR:	SKIPL WCNT(DAT)		;Any spare words in this buffer?
	JRST PRCR2		;No, see if room for 2 chars in this last word
PRCR3:	MOVEI CHR,15		;PRINT A CR.
	PUSHJ P,PUTCH1
	MOVEI CHR,12		;NOW INVENT A LINE FEED.
	PUSHJ P,SETLL		; RESET DPHPOS
	PUSHJ P,PR1EOL		;GO DO THE END-OF-LINE BIT
	SETOM LSTCHR(DAT)	;FLAG THAT WE INVENTED CRLF HERE.
	POPJ P,			;(DPYTYP WILL WAIT FOR LINE BEFORE SENDING MORE)

;Last char of long line and CRLF must all be in same buffer for DM at least.
PRCR2:	MOVE AC1,CNT1(DAT)	;Get number of bytes left + 1
	CAILE AC1,2
	JRST PRCR3		;Room still for at least 2 more chars
	LDB CHR,PPTR1(DAT)	;Get back last char
	SETZ AC1,
	DPB AC1,PPTR1(DAT)	;And replace it in buffer with a null
	PUSHJ P,PUT2C3		;Get new buffer and stick in last char
	JRST PRCR3		;Now put CRLF into new buffer

;Here to make sure there is room in current buffer for at least 2 chars (CRLF)
PUT2CH:	SKIPL WCNT(DAT)		;Any spare words in this buffer?
	JRST PUT2C2		;No
PUTCH1:	SOSG CNT1(DAT)		;Print CHR without special character checking
PUT2C3:	PUSHJ P,EXTBUF		;GO EXTEND BUFFER, OR GET NEW ONE IF NEEDED
	IDPB CHR,PPTR1(DAT)
IFN FTDDLOSS,<
PUT2C4:	CAIN CHR,15		;Insert CR after CR
	TLNN DAT,DDDLIN
	POPJ P,
	MOVEI CHR,400015	;Avoid recursion with CR after THIS cr
	PUSHJ P,PUTCH1		;Put out extra CR
	MOVEI CHR,15		;Restore CR in case someone wants it
>;IFN FTDDLOSS
	POPJ P,

;We are now in last word of buffer--see if there is room in this word for 2 chars
PUT2C2:	SOS AC1,CNT1(DAT)	;Decrement count of unused room in buffer
	SOJLE AC1,PUT2C3	;Jump if not enough room
	IDPB CHR,PPTR1(DAT)	;Room for at least 2 chars in this word--put in one
IFN FTDDLOSS,<
	JRST PUT2C4
>;IFN FTDDLOSS
IFE FTDDLOSS,<
	POPJ P,
>;IFE FTDDLOSS
;PR1ECR PR1EC1 PR1EC3 SETLL

;Here on CR
PR1ECR:	JUMPL DAT,PR1EC1	; IIIs are simple
	TLNE DAT,DDDLIN		; IS THIS A DD?
	SETZM TPJMP+1(DAT)	; YES, LINE ENDS WITH CRLF, SO KILL THE EXECUTE
	MOVEI AC1,12		; WAS THE LAST CHARACTER A LF
	CAME AC1,LSTCHR(DAT)
	JRST PR1EC1
	MOVN AC3,DPHPOS(DAT)	; PICK UP THE HORIZONTAL POSITION
	CAMN AC3,LNLNGT(DAT)	; ARE WE AT THE BEGINNING OF THE LINE?
	JRST PR1EC2		; YES, NO NEED FOR ANY MORE CR'S, BUT PUT IN SPACE
	SOS VPOS(DAT)
	SETZ AC1,
	DPB AC1,SPTR1(DAT)	; Put a NULL in over the LF
	PUSHJ P,SETLL		; RESET DPHPOS
	MOVEI CHR,15
	PUSHJ P,PUT2CH		; Put in CR, making sure there is room for LF
	MOVEI CHR,12
	PUSHJ P,PUTCH1		; STICK THE LF IN
	MOVEM CHR,LSTCHR(DAT)	; SAVE IT
	JRST EOLSET		; DO THE END-OF-LINE BIT

;Here on any CR on III or on CR after non-LF on DD or DM
PR1EC1:	MOVN AC3,DPHPOS(DAT)	; NOW (SIGH) SEE IF WE ARE AT THE LEFT MARGIN!
	CAMN AC3,LNLNGT(DAT)
	POPJ P,			; IF SO, FLUSH THIS CR
	PUSHJ P,SETLL		; RESET DPHPOS
	PUSHJ P,IIILED		; Position line editor if on III
	JUMPL DAT,PUTCH1	; Don't invent LFs on III--let him overtype lines
PR1EC3:	PUSHJ P,PUT2CH		; Put in the CR, making sure there is room for LF
	SETOM LSTCHR(DAT)	; Flag that we invented a LF
	MOVEI CHR,12
	JRST PR1EO2

;INITIALIZE LENGTH OF THE LINE AT CR.
SETLL:	MOVN AC1,LNLNGT(DAT)	;GET -LINELENGTH.
	MOVEM AC1,DPHPOS(DAT)	;RESET HORIZONTAL POS.
	POPJ P,
;PR1EC2 PR1EOL PR1EO2 PREOGL

;GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN ON DD OR DM
PR1EC2:	MOVEI CHR,40		; PRINT A SPACE SO THE LINE WILL GET ERASED
	TLNE DAT,DDDLIN
	PUSHJ P,PUTCH1		;ONLY NEED SPACE ON DD
	MOVEI CHR,15
	JRST PR1EC3

; HERE ON LF
PR1EOL:	TLNE DAT,DDDLIN		; IS THIS A DD?
	SETZM TPJMP+1(DAT)	; YES, NO NEED FOR AN EXECUTE AT END OF BUFFER
	MOVEM CHR,LSTCHR(DAT)	; SAVE THIS CHARACTER
PR1EO2:	PUSHJ P,PUTCH1		;PUT IN LF
	SOS LHCNT(DDB)		;DECREMENT LINE COUNTDOWN FOR AUTO HOLDING
	PUSHJ P,EOLSET		;SET VERTICAL POSITION AND SAVE BYTE PTR
	PUSHJ P,IIILED		;Position line editor if on III
	SOSLE DELCNT(DAT)	;ARE WE AT THE TOP OF A GLITCH ?
	POPJ P,			;NO. GO BACK.
PREOGL:	MOVE AC3,DEL(DAT)	;GET NO. OF LINES PER GLITCH..
	MOVEM AC3,DELCNT(DAT)	;.. AND INIT. THE COUNT.
	AOS AC1,GLCNT(DAT)	;UPDATE SIZE OF PAGE.
	CAMG AC1,PGSIZ(DAT)	;IS IT TOO BIG ?
	POPJ P,			; NOT YET.
	PUSHJ P,GLITCH		;YES, MOVE IT UP SOME
	JRST IIILED		;NOW UPDATE LINE EDITOR POSITION IF III
;EXTBUF L2 L1 GBLK

BEGIN EXTBUF	;MAKE MORE ROOM IN THE DISPLAY BUFFER.

↑EXTBUF:
	EXCH AC1,PPTR1(DAT)	;GET BYTE POINTER.
L2:	MOVN AC2,WCNT(DAT)	;HOW MANY WORDS LEFT IN THIS BLOCK ?
	JUMPE AC2,GBLK		;IF NONE, GET A NEW BLOCK.
	CAILE AC2,10		;IF FEWER THAN 8, USE THAT  NO.
	MOVEI AC2,10		;..ELSE USE 8 WORDS.
	ADDM AC2,WCNT(DAT)	;DECREMENT THE COUNT.
	MOVE AC3,AC2
	ASH AC3,2		;MULTIPLY BY 5 RAPIDLY.
	ADD AC3,AC2
	MOVEM AC3,CNT1(DAT)	;THAT'S THE NEW CHAR. COUNT, FOLKS.
	MOVE AC3,1(AC1)		;PICK UP THE JMP AT CURRENT END OF BUFFER..
	ADDI AC1,1(AC2)		;GET NEW POS. FOR IT...
	MOVEM AC3,(AC1)		;.. AND PUT IT THERE.
	MOVEI AC3,1		;MANUFACTURE A NULL CHAR. WORD...
L1:	SUBI AC1,1		;AND FILL THE NEWLY AVAILABLE AREA OF THE
	MOVEM AC3,(AC1)		;BUFFER WITH IT.
	SOJG AC2,L1
	SUBI AC1,1
	TLZ AC1,760000		;BUG FIX REG RPH 24 JUL 72
	EXCH AC1,PPTR1(DAT)	;RESTORE THINGS TO THEIR RIGHTFUL PLACES.
	POPJ P,

GBLK:  ;;GET ANOTHER BLOCK FROM FREE STORAGE FOR PRGM.
	AOSLE BLKTOT(DDB)	;INC. HIS COUNT OF BLOCKS USED.
	PUSHJ P,FBLK		;OOPS, TOO MANY. FREE SOME.
	PUSHJ P,GETFS		;GET ANOTHER BLOCK FROM FREE STORAGE.
	JUMPL AC2,GBLKFA	;WE DON'T KNOW HOW TO RECOVER IF WE CAN'T GET FS
	HRR AC1,AC2		;MAKE THE BYTE PTR. POINT THERE.
	EXCH AC2,CBLKPT(DAT)	;UPDATE CURRENT BLK. PTR (AND GET OLD ONE).
	MOVEI AC3,CBLKBT	;GC BIT FOR 'CURRENT PP BLOCK'...
	ANDCAM AC3,BLKBTS(AC2)	;..TURN IT OFF IN OLD BLOCK.
	MOVEM AC3,BLKBTS(AC1)	;.. AND PLACE IN NEW ONE.
	MOVE AC3,GCINFO(AC2)	;GIVE NEW BLK. SAME GC CODE AS
	MOVEM AC3,GCINFO(AC1)	; OLD ONE.
	MOVNI AC3,INITWC	;SET UP NO. OF FREE WORDS IN NEW BLOCK.
	MOVEM AC3,WCNT(DAT)
	MOVE AC3,INITWC(AC2)	;PICK UP RETURN JMP FROM END OF OLD BLK..
	MOVEM AC3,(AC1)		;.. AND PUT IN FIRST WORD OF NEW ONE.
	HRRM AC1,PPLINK(AC2)	;MAKE FORWARD LINK OF OLD ONE POINT AT NEW ONE.
	HRLM AC1,INITWC(AC2)	;MAKE JMP AT END OF OLD ONE POINT AT NEW ONE.
	HRLZM AC2,PPLINK(AC1)	;BACKWARD LINK OF NEW ONE TO OLD ONE...
	SOJA AC1,L2		;JIGGLE NEW BYTE PTR. A BIT AND PROCEDE.

GBLKFA:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /Couldn't get FS at EXPBUF! /
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,FDDTCA
	HALT .

BEND EXTBUF.
;GLITCH GLTCH1 GLTCH3 GLTCH9 PR1EL4 ADJSIZ CNTWRP GLTCH8 GLTCH4 GLTCH5 GLTCH7 GLTCH6

; WE GET HERE UPON GLITCHING.
; IN THIS CASE, WE SEE IF THERE ARE ANY BLOCKS ABOVE THE
; CURRENT SCREEN. IF SO, WE CAN FREE THEM UP.

GLITCH:	SOS GLHCNT(DDB)		; BUMP COUNT OF GLITCHES TO GO UNTIL HOLD
GLTCH1:	MOVN AC3,DEL(DAT)	; MOVE POINTERS DOWN BY THIS AMOUNT
	TLNE DAT,DMLIN		; Count negative of number of lines of
	ADDM AC3,DMGLCH(DAT)	;    glitches to do on DM later
	SETOM GLTCH(DAT)	; MARK THE FACT THAT WE HAVE GLITCHED
	SETOM PPINV(DAT)	; NOTE THAT POINTERS ARE BEING CHANGED
	ADDM AC3,VPOS(DAT)	; UPDATE VERTICAL POSITION BY NUMBER OF LINES IN GLITCH
	PUSHJ P,PTMOVE		; MAGIC CIRCULAR ROUTINE
	SETZM PPINV(DAT)	; POINTERS ARE OK NOW
GLTCH3:	SKIPE III(DDB)		;VPOS IS RELATIVE TO TOP OF PP ON III
	TDZA AC3,AC3		;SO TOP OF SCREEN IS ZERO
	PUSHJ P,POSLIN		; PICK UP LINE NUMBER OF TOP OF PAGE
	CAMLE AC3,VPOS(DAT)	; IS THERE ANYTHING ON THE SCREEN AT ALL?
	MOVE AC3,VPOS(DAT)	; NOT YET, USE LAST POSITION WRITTEN IN
	PUSHJ P,GLNADR		; GET ADDRESS OF TEXT
	HRRZ AC1,TBLKPT(DAT)	; PICK UP THE POINTER TO THE CURRENT FIRST PAGE
	MOVEI AC3,BLKSIZ-1(AC1)	; GET ADDRESS OF END OF THAT BLOCK
	CAIL AC2,(AC1)		; NOW, ARE WE INSIDE THAT FIRST BLOCK?
	CAILE AC2,(AC3)
	JRST GLTCH5		; NO, FREE UP SOME BLOCKS
	ADDI AC2,1		; MAKE POINTER TO TOP OF PAGE
GLTCH9:	HRLM AC2,TPJMP(DAT)	; POINT JUMP TO THERE
PR1EL4:	SOS AC1,GLCNT(DAT)	;IS IT SMALL ENOUGH NOW ?
ADJSIZ: CAMLE AC1,PGSIZ(DAT)
	JRST GLITCH		;NO. GLITCH IT SOME MORE.
	POPJ P,

CNTWRP: MOVEI AC3,CNT		;WRAP A POINTER AROUND THE GLITCH TABLE.
	MOVEM AC3,@-2(AC2)
	JRST (AC2)

GLTCH8:	ONSCN
	SUB P,[1,,1]
GLTCH4:	PUSHJ P,PR1FRE		; GO FREE UP AT LEAST ONE
	JRST GLTCH3		; SEE IF WE CAN DO SOME MORE

GLTCH5:	TLNN DAT,DMLIN		;If DM, make sure no queued refs to top block
	JRST GLTCH4
	PUSH P,AC2		;Save pointer to top line of PP for PPSAV on DMs
	OFFSCN
	HRRZ AC3,DMPPPT(DDB)	;Examine queued xfers for text block used
	JRST GLTCH6

GLTCH7:	HRRZ AC3,QLINK(AC3)	;Look at next xfer
GLTCH6:	CAIN AC3,DMPPPT-QLINK(DDB)	;End of queue?
	JRST GLTCH8		;Yes
	MOVE AC2,QFLAGS(AC3)	;Get flags for xfer
	TRNN AC2,DMATXY		;Is this a text xfer?
	JRST GLTCH7		;No
	HRRZ AC2,QTAKR(AC3)	;Get address from byte pointer
	CAIL AC2,(AC1)
	CAILE AC2,BLKSIZ-1(AC1)	;Is byte pointer into top block?
	JRST GLTCH7		;No
	ONSCN			;Yes, don't free any blocks this time
	POP P,AC2		;Restore pointer to top line of PP
	AOJA AC2,GLTCH9		;Make it point to actual text
;EOLSET EOLSE2 EOLSE3

; THESE ARE UTILITY ROUTINES USED BY THE PAGE PRINTER
; THIS FIRST ROUTINE IS CALLED AT THE END OF THE LINE THAT
; GOES OFF THE SCREEN ON DATA DISK. WE REPACK THE WORD
; SUCH THAT THE POINTER POINTS TO THE NEXT WORD. THIS WAY
; THE I-LEVEL ROUTINES CAN REPLACE THE ENTIRE WORD WITH
; A JUMP INTO THE PAGE PRINTER CONTROL BLOCK TO KEEP IT
; FROM READING MORE TEXT WHICH WOULD BE OFF THE SCREEN.

EOLSET:	MOVE AC1,PPTR1(DAT)	; PICK UP POINTER TO LF
	MOVEM AC1,SPTR1(DAT)	; SAVE IT
	TLNE DAT,DDDLIN		; ON DD?
	SETZM TPJMP+1(DAT)	; SINCE TEXT ENDS WITH A CRLF, NO EXECUTE IS NEEDED
	LDB AC1,[POINT 6,PPTR1(DAT),5]
	SUBI AC1,1		; ARE THERE ANY SPACES LEFT IN THE WORD?
	IDIVI AC1,7		; THIS GETS NUMBER OF CHARACTERS LEFT IN AC1
	JUMPE AC1,EOLSE3	; IF NONE LEFT, GO ON.
	PUSH P,AC1		; PUT IN THAT MANY NULLS
	SETZ CHR,
EOLSE2:	PUSHJ P,PUTCH1		; FILL OUT WORD WITH NULLS.
	SOSLE (P)		; ENOUGH?
	JRST EOLSE2		; NO, GO DO ANOTHER ONE.
	SUB P,[XWD 1,1]
EOLSE3:	MOVE AC3,VPOS(DAT)	; WE ARE NOW ON THE NEXT LINE. BUMP VERTICAL POSITION COUNTER.
	ADDI AC3,1		; DON'T BUMP IN CORE UNTIL WE HAVE POINTER PLANTED
	CAMLE AC3,GLW(DAT)	; IS THIS FURTHER DOWN THAN THE PRESENT MAXIMUM LINE WRITTEN?
	MOVEM AC3,GLW(DAT)	; YES, BUMP NUMBER OF MAXIMUM LINE WRITTEN
	PUSHJ P,GLNADR		; PICK UP POINTER INTO LINE TABLE
	MOVE AC2,PPTR1(DAT)	; NOW PICK UP THE POINTER
	MOVEM AC2,@PTRB(DAT)	; PUT IT INTO LINE POINTER TABLE INDEXED BY LINE NUMBER
	AOS VPOS(DAT)		; NOW UPDATE VERTICAL POSITION
	MOVEI CHR,12		; FAKE UP SOMETHING FOR ERRP (AGGG!)
	POPJ P,
;GLNADR GLNAD1 GLNAD2 GLNAD3 GLNAD4 GLNAD6

; HANDY ROUTINE TO GET POINTER TO TEXT FROM LINE NUMBER IN AC3
; RETURNS POINTER IN AC2.

GLNADR:	ADD AC3,PTBEG(DAT)	; ADD IN INCREMENT
GLNAD2:	CAMGE AC3,[-=20]	; UNDERFLOW?
	JRST GLNAD1		; YES, BOOST IT
GLNAD4:	CAIL AC3,=60		; OVERFLOW?
	JRST GLNAD3		; YES, BRING IT BACK INTO RANGE
	HRRZ AC2,PTRB(DAT)	; PICK UP POINTER
	SUBI AC2,=20
	CAME AC2,PTB(DAT)	; IS IT WHAT IT IS SUPPOSED TO BE?
	JRST GLNAD5		; NO, ERROR
GLNAD6:	HRRZ AC2,@PTRB(DAT)	; PICK UP POINTER
	POPJ P,

GLNAD1:	ADDI AC3,=80
	JRST GLNAD2

GLNAD3:	SUBI AC3,=80
	JRST GLNAD4
;GLNAD5 GLNAD7 HELPX

; WE GET HERE IF THE POINTERS DON'T AGREE

GLNAD5:	PUSHACS
	PUSH P,HEDPTR(DAT)	;SAVE PTR TO DPY HDR
	PUSH P,PTB(DAT)
	PUSH P,PTRB(DAT)
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /PTRB disagrees with PTB.  PTRB = /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	 ASCIZ/   PTB = /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	 ASCIZ/   Dpy Hdr = /
	MOVE TAC,(P)
	PUSHJ P,DISLOC
	MOVE TAC,(P)
	CAML TAC,SYSTOP		;reasonable FS address?
	CAML TAC,FSTOP
	JRST GLNAD8		;nope
	PUSHJ P,DISMES
	 ASCIZ/   TTY = /
	POP P,TAC
	HRRZ TAC,PRGNUM(TAC)	;get line number from dpy hdr
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	DEBCHECK(POPACS)	;maybe stop system
	HRRZ AC2,PTB(DAT)	; PICK UP THE (HOPEFULLY) CORRECT POINTER
	CAML AC2,SYSTOP
	CAML AC2,FSTOP
	JRST GLNAD7
	ADDI AC2,=20
	HRLI AC2,AC3		; SET TO INDEX BY AC3
	MOVEM AC2,PTRB(DAT)
	JRST GLNAD6

GLNAD7:	HRRZ AC2,PTRB(DAT)
	SUBI AC2,=20
	CAML AC2,SYSTOP
	CAML AC2,FSTOP
	JRST HELPX
	HRRZM AC2,PTB(DAT)
	JRST GLNAD6

GLNAD8:	PUSHJ P,DISMES
	 ASCIZ/ (from HEDPTR, also clobbered)/
HELPX:	PUSHJ P,DISMES
	ASCIZ /  I can't fix it, can you?
/
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCALL
	HALT .
;POSLIN POSLDD POSLDM POSLD2 POSLII

; ROUTINE TO CONVERT THE POSITION VECTOR INTO A DATA DISC,
; III, OR DATAMEDIA LINE NUMBER FROM 1 TO N, DEPENDING ON DISPLAY.

POSLIN:	LDB AC3,[POINT 11,PPOSV(DAT),21]
	TRNE AC3,1⊗=10		; EXTEND SIGN BIT
	IOR AC3,[-1⊗=10]	; BY ORING IN BITS
	JRST @PPDPY(DAT)	; GO TO SELECTED ROUTINE (BELOW)

POSLDD:	IMULI AC3,=20		; DD
	ASH AC3,-=9		; THIS GIVES A NUMBER FROM -=19 TO =20
	MOVNS AC3		; FOR DD, ASCENDING LINE NUMBERS GO DOWN THE SCREEN
	ADDI AC3,=20		; WE NOW HAVE A NUMBER FROM 1 TO =40 IN AC3
	POPJ P,

POSLDM:	HRRE AC3,PPYVAL(DAT)	;GET SIGNED Y POSITION SAVED WITH MORE BITS
↑POSLD2:			;ENTER HERE WITH LINE EDITOR Y POSITION IN AC3
POSLII:	IMULI AC3,=12		; III ONLY HAS 24 LINES ON THE SCREEN
	ASH AC3,-=9
	MOVNS AC3
	ADDI AC3,=12
	POPJ P,
;FBLK FB1 PR1FRE PR1ER2

FBLK:	PUSH P,AC1		;FREE SOME BLOCKS FROM P.P.
FB1:	MOVE AC1,GLCNT(DAT)
	SKIPLE BLKTOT(DDB)	;DID WE FREE ENOUGH BLOCKS ?
	CAIG AC1,1		;LESS THAN 1 GLITCH ON SCREEN ?
	JRST POPAJ		;YES. RESTORE AC1 AND RETURN.
	PUSHJ P,GLITCH		;MOVE PAPER ONE GLITCH.
	PUSHJ P,IIILED		;Set up new line editor position if III
	TLNE DAT,DMLIN		;If DM, then GLITCH may not have freed a block
	SKIPG BLKTOT(DDB)
	JRST FB1
	PUSHACS
	PUSH P,BLKTOT(DDB)	;Number of extra blocks used
	HRRZ TAC1,PRGNUM(DDB)	;Line number
	PUSH P,TAC1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /DM ON TTY/]
	DISARG LOC,<-1(P)>
	[ASCIZ / USING /]
	DISARG DEC,<-2(P)>
	[ASCIZ / EXTRA PP TEXT BLOCK(S).
/]
	-1
	SUB P,[2,,2]
	POPACS
	JRST POPAJ

PR1FRE: MOVE AC2,TBLKPT(DAT)	;WE HAVE FINISHED WITH ANOTHER BLOCK. GET PTR. TO IT.
	MOVEI AC1,TBLKBT	;CODE BIT FOR GC MEANING 'TOP BLK OF PAGE'
	ANDCAM AC1,BLKBTS(AC2)	;TURN IT OFF IN OLD TOP BLK.
	HRRZ AC2,PPLINK(AC2)	;GET FORWARD PTR. (TO NEW TOP BLK.)
	CAML AC2,SYSTOP
	CAML AC2,FSTOP
	JRST PR1ERR		; GROSS ERROR!
PR1ER2:	MOVEM AC2,TBLKPT(DAT)
	IORM AC1,BLKBTS(AC2)
	SOSG OUTCNT(DAT)	;HAVE WE ENOUGH UNUSED BLOCKS FOR A DISK OUTPUT ?
	PUSHJ P,PPOUT		;YES. GET RID OF THEM.
	POPJ P,
;PR1ER3 PR1ERR PR1ER1

PR1ER3:	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /
FIND A WIZARD OR RELOAD
/
	PUSHJ P,DISFLU
	PUSHJ P,DDTCALL
	POPACS
	HALT AUTOLOAD

PR1ERR:	HRRZ AC3,PRGNUM(DDB)
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /Bad PPLINK(TBLKPT(PP)) = /]
	DISARG LOC,<AC2-20(P)>	;Print PPLINK that points out of FS
	[ASCIZ /, for TTY/]
	DISARG LOC,<AC3-20(P)>	;Print TTY number
	[ASCIZ/, DpyHdr = /]
	DISARG LOC,<DDB-20(P)>	;Dpy hdr addr
	[ASCIZ/, PP#/]
	DISARG LOC,<PPNO(DAT)>	;PP number (assuming DISERR doesn't clobber DAT)
	[ASCIZ/ = /]
	DISARG LOC,<DAT-20(P)>	;Piece of paper addr
	[ASCIZ/, TBLKPT = /]
	DISARG LOC,<TBLKPT(DAT)> ;PP block we wanted to free up
	-1
	POPACS
	MOVEI AC1,=20*=40/INITWC	;Maybe we can get back to the Top block
	MOVE AC3,CBLKPT(DAT)		; from the Current block
PR1ER1:	MOVEI AC2,(AC3)		;Remember block we're backing up from
	HLRZ AC3,PPLINK(AC3)	;Get backward pointer
	CAML AC3,SYSTOP
	CAML AC3,FSTOP
	JRST PR1ER3		;Not valid FS pointer, give up
	CAME AC3,TBLKPT(DAT)	;Does this point back to Top block?
	SOJG AC1,PR1ER1		;No, keep backing up for awhile
	JUMPLE AC1,PR1ER3	;Give up if tried enough backing
	MOVE AC3,TBLKPT(DAT)	;Aha!  Get addr of top block
	HRRM AC2,PPLINK(AC3)	;Make top blk point to one pointing back to it
	MOVEI AC1,TBLKBT	;Make block after top blk the new top block
	PUSHACS
	PUSHJ P,DISMES
	 ASCIZ/  FIXED IT!/	;I hope
	PUSHJ P,DISCRLF
	DEBCHECK(POPACS)	;Call DDT only if debugging
	JRST PR1ER2
;PPOUT SETRST PPRST

;WE GET HERE WHEN IT IS TIME TO OUTPUT PART OF A PIECE OF PAPER TO THE DISK.
PPOUT: 	MOVEI AC3,OUTNUM	;NO. OF BLOCKS TO PUT OUT.
	MOVEM AC3,OUTCNT(DAT)	;RESET IT.
	MOVE AC1,FBLKPT(DAT)	;POINTER TO FIRST BLK IN CORE.
	SKIPA AC2,AC1
	HRRZ AC2,PPLINK(AC2)	;GO TO NEXT BLOCK.
	SOJG AC3,.-1		;GO TO LAST BLOCK TO BE OUTPUT.
;;SINCE CROCKISH R. SAUNDERS HAS NO DISK CODE YET, WE JUST RETURN THE BLOCKS TO FREE STORAGE.
	HRRZ AC3,PPLINK(AC2)	;NEXT BLK.
	HRRZM AC3,FBLKPT(DAT)	;MAKE FBLKPT POINT TO NEW FIRST BLOCK IN CORE.
	HRLM DAT,PPLINK(AC3)	;MAINTAIN REV LINK
	SETZM PPLINK(AC2)	;ZERO LINK IN LAST BLOCK TO BE FREED.
↑SETRST:PUSHJ P,FREEL		;FREE THE BLOCKS.
IFE FTF2,<
	SKIPN III(DDB)		;IS IT AN III?
	POPJ P,			;NO.
PPRST:	HRRZ AC3,PRGNUM(DDB)	;GET TTY NUMBER
	MOVEI AC2,PSELB(DDB)	;YES. INVENT A RESTARTING JMP FOR IT AND
	HRLI AC2,DISJMP		; PLACE IN RSTTBL SO PRGM WILL GET STARTED AT
	MOVSM AC2,PRGSTP(DDB)	;Clobber old continue PC to really restart
	MOVSM AC2,RSTTBL-DPYL0(AC3)	;AT ITS BEGINNING NEXT TIME.
>;IFE FTF2
	POPJ P,
;ERRP2 ERRP3

;A SIMPLE MESSAGE PRINTER. JSA J,ERRP WITH
;BYTE PTR. TO TEXT FOLOWING THE JSA .

↑ERRP2:	PUSHACS			;SAVE ALL OUR ARGUMENTS
	HLRZ DAT,PPCALL(DDB)	;GET P OF P 0.
	HLL DAT,DDB		;COPY OVER THE DISPLAY-TYPE BIT
	MOVE J,JOB
	PUSHJ P,PPCLR		;RESET THE PAGE PRINTER
	MOVE J,-17+J(P)
	MOVE TAC,(J)		;GET BYTE POINTER TO MESSAGE.
ERRP3:	OFFSCN			;TURN OFF SCANNER CHANNEL
	ILDB CHR,TAC		;GET NEXT CHRARACTER
	PUSHJ P,DTYO		;TYPE A CHAR.
	ONSCN			;TURN ON SCANNER CHANNEL
	JUMPN CHR,ERRP3		;LOOP UNTIL FIRST NULL CHAR.
	POPACS
	JRA J,1(J)
;PPFND1 PFL2 PPFND PPFER

;;HERE ARE UUO LEVEL ROUTINES FOR MANIPULATING THE PAGE PRINTER.

;;THESE ROUTINES ARE ENTERED WITH STANDARD UUO LEVEL
;; SETUP OF AC'S UUO AND J, WITH
;; DDB (≡DEVDAT) POINTING TO DPY PROGRAM HEADER.


;;PPFIND FINDS PIECE OF PAPER INDICATED BY (UUO); CREATES IT IF NECESSARY.
;; RETURNS WITH DAT POINTING TO P. OF P. CONTROL BLOCK.

PPFND1:	HLL DAT,DDB		;PICK UP DISPLAY-TYPE BIT
	HLRZ AC2,PPCALL(DDB)	;GET PTR. TO FIRST P. OF P.
	HRRZ TAC,UUO		;NO. OF PIECE WE ARE LOOKING FOR.
	CAIL TAC,20		;BETTER NOT BE TOO HIGH.
	JRST PPFER		;LOSE, LOSE.
PFL2:	HRRM AC2,DAT		;LOOK AT NEXT P. OF PAPER.
	CAMN TAC,PPNO(DAT)	;IS IT THE ONE WE WANT ?
	POPJ P,			;YES.
	HRRZ AC2,PPLINK(DAT)	;GET LINK TO NEXT ONE.
	JUMPN AC2,PFL2		;LOOP IF THERE IS A NEXT ONE.
	POPJ P,

PPFND:	PUSHJ P,PPFND1		;FIND INDICATED P OF P.
	JUMPN AC2,CPOPJ1	;RETURN IF IT EXISTS.
	PUSH P,PRGNUM(DDB)	;save line number in case dpy hdr goes away
	PUSH P,DAT		; SAVE POINTER TO LAST PROGRAM HEADER
	PUSH P,TAC		; SAVE NUMBER OF DESIRED PIECE OF PAPER
	HLRE TAC,PRGNUM(DDB)	; PICK UP DD CHANNEL OR DISPLAY-TYPE BIT FOR PPINIT
	PUSHJ P,PPINIT		; MAKE A NEW PIECE APPEAR.
	 JSP UUO,DWPERR		; NOT THERE, GHASTLY ERROR
	POP P,PPNO(AC1)		;MAKE IT HAVE RIGHT NO.
	POP P,DAT		; GET BACK POINTER TO LAST PIECE OF PAPER
	POP P,AC3		;get back line number
	HRRZ AC3,LETAB(AC3)	;get current dpy hdr
	CAIE AC3,(DDB)		;same dpy hdr as before?
	POPJ P,			;no, abort everything, dpy hdr may have gone away
	HRRM AC1,PPLINK(DAT)	;LINK IT TO OTHER PIECES.
	HRLZM DAT,PPLINK(AC1)	;PUT IN ITS BACKWARD LINK.
	HRRZM DDB,HEDPTR(AC1)	;GIVE IT PTR. TO PRGM. HEAD.
	MOVE AC3,DPYWID(DDB)	;GET DISPLAY WIDTH
	MOVEM AC3,LNLNGT(AC1)	;STORE IN PP
	MOVNM AC3,DPHPOS(AC1)	;STORE REMAINING LENGTH OF CURRENT LINE TOO
	MOVE AC3,PPRJMP(DAT)	;GET LINKING (I. E. RETURN) JMP FROM LAST P OF P...
	MOVEM AC3,PPRJMP(AC1)	;GIVE IT TO NEW PIECE...
	HRLM AC1,PPRJMP(DAT)	;.. AND MAKE LAST PIECE CALL NEW ONE.
	MOVEM AC1,DAT
	HLL DAT,DDB		; PUT IN TYPE BITS
	JRST CPOPJ1

PPFER:	;PRINT H. S. MESSAGE.
	ERMS {ILLEGAL PIECE OF PAPER}
	JRST UUOERR		;NOW GIVE STANDARD JUNK AND STOP JOB.
;PPREL PPREL2 PPREL3 PPREL4 PPSEL0 CLKREL

;Here from PPREL UUO
PPRELU:	PUSHJ P,PPREL		;Call real routine
	 POPJ P,		;Dpy hdr went away, don't care
	POPJ P,			;Done

;Release piece of paper whose number is in UUO. 
;Takes skip return unless dpy hdr (in DDB) goes away while we're waiting,
;in which case the direct (error) return is taken and our
;caller better not continue to use the ptr that is in DDB!
PPREL:	TRNN UUO,-1		;FLUSH PP WHOSE NUMBER IS IN UUO (RIGHT)
	JRST CPOPJ1		;BUT NOT IF IT'S PP ZERO
	PUSHJ P,PPFND1		;FIND P OF P
	JUMPE AC2,CPOPJ1	;SAVE SOME TIME IF THERE IS NONE
	PUSH P,DDB
	PUSH P,PRGNUM(DDB)	;save line number in case dpy goes away
	PUSHJ P,PPWAIT		;WAIT FOR ANY TYPEOUT TO FINISH BEFORE FLUSHING PAGE
	POP P,AC2		;get back line number
	POP P,DDB		;get back dpy hdr
	HRRZ AC2,LETAB(AC2)	;get line's dpy hdr ptr to see if DDB is still valid
	CAIE AC2,(DDB)		;same dpy hdr?
	POPJ P,			;no, probably old dpy hdr went available, stop now!
	AOS (P)			;OK, dpy hdr didn't go away, guaranteed success now
	PUSHJ P,PPFND1		;NOW SEE IF P OF P IS STILL THERE
	JUMPE AC2,CPOPJ		;RETURN IF NOT.
	MOVE AC1,PPLINK(DAT)	;SIGH.  GET FWD AND BWD LINKS FROM CTRL. BLK.
	TRNE AC1,-1		;UNLESS CTRL. BLK IS LAST ONE,
	HLLM AC1,PPLINK(AC1)	;..UPDATE BWD LINK OF NEXT ONE.
	MOVSS AC1
	HLRM AC1,PPLINK(AC1)	;NOW FWD LINK OF PREVIOUS ONE (AREN'T LINKED LISTS FUN ?)
	MOVE AC3,PPRJMP(DAT)	;TAKE LINKING JMP FROM THIS BLK...
	MOVEM AC3,PPRJMP(AC1)	;..AND GIVE IT TO PREVIOUS ONE.
	JUMPL DAT,PPREL3	; DON'T ERASE IF III, WILL BE DONE AUTOMATICALLY
	HRRZ AC3,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	SKIPN PPVIRG(DAT)	; DON'T ERASE A VIRGIN PP
	CAIN AC3,DISNOP		; IS IT REALLY A JUMP?
	JRST PPREL3		; NO, DON'T ERASE NON-ACTIVATED PP BEING RELEASED
	PUSHJ P,POSLIN		; GET FIRST LINE NUMBER OF PAGE
	PUSH P,AC3
	PUSH P,GLW(DAT)		; ERASE ALL THE WAY TO THE LAST LINE
;;	SOS (P)		;why leave last line not erased! "line editor there"?
	PUSHJ P,PPERS
	SUB P,[XWD 2,2]		; NORMALIZE THE STACK
PPREL3:	MOVEM DDB,PPLINK(DAT)	;SINCE WE ARE LINKED OUT, WE CAN USE THIS TO
			 	;SAVE DDB IN CASE OF A CLOCK CALL LATER
PPREL4:	MOVE DDB,PPLINK(DAT)	;MAKE SURE DDB IS SET UP
	SKIPN PPENQ(DAT)	;ANYTHING HAPPENING HERE?
	SKIPE PPNQT(DAT)
	JRST CLKREL		;YES, DON'T RELEASE IT UNTIL IT IS DONE
	MOVE AC1,DAT		;NOW FREE THE CTRL BLK.
	PUSHJ P,CGIVFS
	MOVE AC1,FBLKPT(DAT)	;ALSO FREE THE PROGRAM BLOCKS.
	PUSHJ P,FREEL
	HRRZ AC1,PTB(DAT)	;GIVE BACK TABLE OF END OF LINE POINTERS
	PUSHJ P,FSGIVE
PPREL2:	HRRZ AC1,DAT
	CAME AC1,CURPP(DDB)	;HAVE WE JUST DELETED SELECTED P OF P ?
	POPJ P,			;NO
PPSEL0:	MOVEI UUO,0		;YES. SELECT PP 0.
	JRST PPSELN		;(no waiting, dpy hdr can't go away)

CLKREL:	HRLI DAT,PPREL4
	JRST DPYTIM
;PPSELU PPSEL PPSELN PPSELX

;;PPSEL <N>  MAKES P. OF P. <N> THE CURRENT ONE AND TURNS IT ON.

;Here for PPSEL uuo.
PPSELU:	PUSHJ P,PPSEL		;select PP
	 POPJ P,		;dpy hdr went away while waiting, don't care
	POPJ P,			;OK

;Select PP given in UUO and take skip return unless dpy hdr disappears while
;we're waiting, in which case we take direct (error) return and our caller
;better not continue to use DDB, which is now invalid.
PPSEL:	PUSHJ P,PPWAIT		; WAIT FOR TYPEOUT TO FINISH
	PUSHJ P,PRGFND
	 POPJ P,		; NO DPY HERE, JUST IGNORE
	AOS (P)			;still have dpy hdr, guaranteed success
PPSELN:	MOVEI AC1,PPACT		;ASSUME WE WANT TO CALL PPACT
	TRZE UUO,400000		;THIS BIT ON IN PP NUMBER MEANS DON'T CALL PPACT
	MOVEI AC1,PPACT0	;NO CHANGE TO ACTIVATED PP'S THIS TIME
	PUSH P,AC1		;ADDRESS OF ROUTINE TO RETURN TO
	PUSHJ P,PPFND		;LOCATE P. OF P. INDICATED BY UUO.
	 JRST PPSELX		;must have been creating PP when dpy hdr went away
	HRRZM DAT,CURPP(DDB)	;MAKE IT THE CURRENT ONE.
	PUSHJ P,IIILED		;Set up new line editor position if III
	MOVEI UUO,400000	;PREPARE TO ACTIVATE IT,
	MOVN TAC,PPNO(DAT)	; BY GENERATING PARAM. FOR
	LSH UUO,(TAC)		; CALL ON PPACT.
	POPJ P,

;Here when dpy hdr went away whil inside PPFND.  Must have been trying to
;create a new PP from PPSEL uuo, so we just get out quickly.
PPSELX:	ADJSP P,-1		;flush "POPJ address" we just stacked
	POPJ P,			;and return, w/out calling PPACT/0
;PPACT0 PPACT PACTL1 PACTL2 PACTL3 PACTL4

;;PPACT X TURNS P OF P'S ON AND OFF ACCORDING TO BITS IN X;
;;  BIT N+18 CORRESPONDS TO P. OF P. N.

;GET TO PPACT0 TO INSURE THAT NEW PP'S, WHICH ARE NOT ACTIVATED, HAVE CORRECT
;VALUE IN TPJMP.  GET THERE FROM PPSEL 400000+PP# WHERE PP# IS NEW.
PPACT0:	MOVE UUO,PRGACT(DDB)	;USE OLD PP ACTIVATION BITS
PPACT:	MOVEI AC1,DISJMP	;JMP OPCODE FOR DPY.
	MOVEI AC2,DISNOP
	HLRZ AC3,PPCALL(DDB)	;GET FIRST P OF P.
PACTL1:	MOVE TAC,UUO		;MAKE COPY OF THE X BITS.
	ROT TAC,@PPNO(AC3)	;GET BIT FOR THIS P OF P INTO 18.
	HRRM AC2,TPJMP(AC3)	;ASSUME BIT IS OFF.
	TRNE TAC,400000		;IS IT ?
	HRRM AC1,TPJMP(AC3)	;NO. ACTIVATE THE P OF P.
	MOVE TAC1,PRGACT(DDB)	; PICK UP CURRENT ACTIVATION BITS
	ROT TAC1,@PPNO(AC3)	; PUT BIT FOR THIS PP IN B18
	XOR TAC1,TAC		; ARE THEY DIFFERENT?
	TRNE TAC1,400000
	JRST PACTL2		; YES, MARK AS VIRGIN IF APPEARING, ELSE ERASE
PACTL3:	HRRZ AC3,PPLINK(AC3)	;GET NEXT P OF P HEADER.
	JUMPN AC3,PACTL1	;LOOP IF THERE IS ONE.
	TRZ UUO,1		;Clear the suppress-erasure bit
	HRRM UUO,PRGACT(DDB)	;ALL DONE. RECORD NEW STATE OF ACTIVATION.
	POPJ P,

PACTL2:	TRNN TAC,400000		; NOW, ARE WE APPEARING OR DISAPPEARING?
	JRST PACTL4		; DISAPPEARING, GO ERASE SCREEN
	SETOM PPVIRG(AC3)	; APPEARING, NOTE A VIRGIN SCREEN
	TLNE DDB,DMLIN
	SETZM DMLAST(AC3)	; Note that there is nothing on PP
	JRST PACTL3

PACTL4:	TRNN UUO,1		;Skip if supressing erasure of deselected PPs
	SKIPE PPVIRG(AC3)	; IS THERE ANYTHING THERE?
	JRST PACTL3		; NO, NOTHING TO ERASE (III ALWAYS GETS OUT HERE)
	PUSH P,DAT		; SAVE PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE DAT,AC3		; MAKE US THE ONE
	PUSHJ P,POSLIN		; GET BOUNDS OF PAGE IN LINE NUMBERS
	PUSH P,AC3		; THAT IS FIRST LINE
	PUSH P,GLW(DAT)		; CURRENT LINE IS LAST LINE
;;	SOS (P)		;why leave last line not erased! "line editor there"?
	PUSHJ P,PPERS		; CAUSE ERASURE TO HAPPEN
	SUB P,[XWD 2,2]
	MOVE AC3,DAT		; PUT PAGE PRINTER CONTROL BLOCK ADDRESS BACK
	POP P,DAT
	MOVEI AC1,DISJMP
	MOVEI AC2,DISNOP
	JRST PACTL3
;PPWAIT PPWAT2 APSCON HPWAIT HPWAID

; ROUTINE TO WAIT FOR TYPEOUT TO FINISH

↑PPWAIT:CONSZ PI,77400		;CAN'T DO THIS AT INTERRUPT LEVEL
	 POPJ P,
	PUSHJ P,HPWAIT		;WAIT FOR OUTPUT BUFFER TO EMPTY FIRST
	 POPJ P,		;can't wait, or waited and DDB disappeared!
	MOVE J,JOB		;J MAY BE CLOBBERED BY DDTWAT
PPWAT2:	LDB TAC,PUNIT		;GET LINE NUMBER
	SKIPE TAC,LETAB(TAC) 	;GET DPY HEADER
	SKIPG NPPXFR(TAC)	;ANY PP TRANSFERS GOING?
	POPJ P,			;NO
	OFFSCN			;DON'T LET DM CHANNEL IN
IFE FTGRIN,<
	CONO PI,APROFF		;DON'T LET DD CHANNEL IN
>;IFE FTGRIN
IFN FTGRIN,<
	CONO PI,GRNOFF		; DON'T LET GRINNELL IN
>;IFN FTGRIN
	SKIPG NPPXFR(TAC)	;CHECK AGAIN
	JRST APSCON		;MUST HAVE JUST FINISHED, TURN APR AND SCN ON
	MOVEM J,JPPWAT(TAC)	;INDICATE THAT WE'RE WAITING FOR PP COUNT DOWN
	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE		;PUT US INTO IOWQ
IFE FTGRIN,<
	CONO PI,APRON
>;IFE FTGRIN
IFN FTGRIN,<
	CONO PI,GRNON
>;IFN FTGRIN
	ONSCN
	LDB TAC,PUNIT		;save line number
	PUSH P,TAC
	PUSHJ P,WSCHED		;WAIT A BIT
	POP P,TAC		;get back line number
	HRRZ TAC,TTYTAB(TAC)	;get line's current DDB
	CAIN TAC,(DDB)		;did it change?
	JRST PPWAT2		;AND THEN CHECK AGAIN
	POPJ P,			;Yes, don't wait any more, DDB no longer valid!

APSCON:
IFE FTGRIN,<
	CONO PI,APRON
>;IFE FTGRIN
IFN FTGRIN,<
	CONO PI,GRNON
>;IFN FTGRIN
	JRST SCNONJ		;RESTORE SCANNER CHANNEL AND RETURN

;Wait for tty output buffer to be absolutely empty (here only at UUO level).
;Skips when empty.
;Takes direct (error) return if can't wait or if job is detached.
↑HPWAIT:MOVE J,JOB
	MOVE DDB,JBTLIN(J)	;FIND GUY'S TTY.
	CAME DDB,[-1]		; IS HE DETATCHED?
	SKIPN DDB,TTYTAB(DDB)	; GET TTY DDB, DOES HE EXIST?
	POPJ P,			; HMM. WELL, BE THAT WAY!
	SKIPN SPWUUF		;CAN'T WAIT AT SPACEWAR LEVEL
	SKIPN JBTPAG(J)		;IN CASE OF KJOB (I.E., NO CORE), WE CAN'T WAIT
	POPJ P,
	MOVEI TAC,TTOCHR	;MAKE SURE OUTPUT BUFFER IS EMPTY
	CAMG TAC,TTOBUF+FCTR(DDB)
	JRST CPOPJ1		;empty
	MOVE IOS,[IOW,,IOACT]	;SET DEVICE ACTIVE (TTY), waiting for output
	IORB IOS,DEVIOS(DDB)	;(TTYIOW is presumably off)
;This label used only by bugtrap in SCHEDU
↑HPWAID:PUSHJ P,DDTWAT		;wait for typeout, skip if DDB goes away
	 JRST HPWAIT		;CHECK AGAIN BECAUSE WE CAN BE AWAKENED PREMATURELY
	JRST HPWAIT		;Find new DDB
;PPYPOS PPYPO1 PPYPO4 REFPAG PPYPO6 PPYPO3

;;PPYPOS Y MAKES THE CURRENT P OF P START AT Y COORD. Y.
PPYPOS: SETZ AC1,
	DPB AC1,POSSBU		; NOTE Y-POSITION SET BY UUO
	PUSHJ P,POSLIN		; GET LINE NUMBER OF CURRENT LINE
	PUSH P,AC3		; AND PUSH IT
	PUSH P,GLW(DAT)		; SAVE BOTTOM OF PAGE
PPYPO1:	SETOM PPINV(DAT)	; NOTE POINTERS ARE BEING CHANGED
	DPB UUO,[POINT 11,PPOSV(DAT),21] ;PUT NEW Y COORD. INTO POSITION VECTOR
	HRRM UUO,PPYVAL(DAT)	;SAVE MORE BITS IN CASE IS DM
	JUMPL DAT,PPYPO6	; THAT'S ALL IF III, VPOS IS RELATIVE TO PP
	PUSHJ P,POSLIN		; NOW PICK UP NEW 1ST LINE OF PAGE
	MOVE AC1,AC3
	MOVE AC2,AC3
	MOVN AC3,-1(P)
	ADD AC3,AC1		; UPDATE VERTICAL POSITION
	JUMPE AC3,PPYPO3	; IF NO DIFFERENCE, WE DON'T HAVE TO MOVE LINE POINTER TABLE
	MOVEM AC2,LLW(DAT)	; MAKE SURE WE START AT THE LOGICAL TOP OF PAGE
	PUSHJ P,PTMOVE		; MOVE POINTERS
	ADDM AC3,VPOS(DAT)
	SETZM PPINV(DAT)	; NOTE POINTERS ARE VALID NOW
	JUMPN AC3,PPYPO2	; IF WE ARE MOVING DOWN, WE HAVE TO ERASE EXPLICITLY
PPYPO4:	SUB P,[XWD 2,2]		; OTHERWISE, WE CAN PRETEND WE ARE GLITCHING
REFPAG:	JUMPL DAT,IIILED	; IF III, JUST UPDATE LINE EDITOR POSITION
	PUSH P,DAT		; SAVE THE POINTER TO THE PAGE PRINTER CONTROL BLOCK
	HRRZ DAT,HEDPTR(DAT)	; PUT DPY PROGRAM HEADER ADDRESS IN DAT
	PUSHJ P,LERFP		; GET IT DONE AUTOMATICALLY.
	POP P,DAT		; GET BACK OUR PAGE PRINTER CONTROL BLOCK ADDRESS
	POPJ P,

PPYPO6:	PUSHJ P,IIILED		;Set up new line editor position if III
PPYPO3:	SUB P,[XWD 2,2]		; RESTORE THE STACK
	SETZM PPINV(DAT)	; POINTERS ARE OK NOW
	POPJ P,
;PPYPO2 PPYPO5 PPYPDN PPYPDM

; WE GET HERE WHEN THE APPEARANCE OF THE PAGE HAS CHANGED ENOUGH
; SO THAT THE PAGE HAS TO BE REFRESHED.
; HERE ONLY FOR DD OR DM.
PPYPO2:	ADDM AC3,GLW(DAT)	; UPDATE THE NUMBER OF THE LAST LINE WRITTEN
	HRRZ AC1,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	SKIPN PPVIRG(DAT)	; DON'T ERASE A VIRGIN SCREEN!
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	JRST PPYPO4		; NO, DON'T WRITE ON IT
	MOVE AC2,(P)		; PICK UP FINISHING LINE OF TRANSFER
	SUB AC2,-1(P)		; GET LENGTH OF PAGE MINUS 1
	MOVM AC1,AC3		; GET MAGNITUDE OF TRAVEL
	CAML AC1,AC2
	JRST PPYPO5		; IF TRAVEL LARGER THAN PAGE, ERASE ENTIRE PAGE
	TLNE DDB,DMLIN		;If any overlap on DM, just slide PP to new position
	JRST PPYPDM		; by using ADD-ROW or DELETE-ROW chars
	SUB AC2,AC1		; OTHERWISE, ERASE ONLY NON-OVERLAPPED PART
	MOVN AC1,AC2
	SKIPG AC3		; IF GOING UP,
	JRST PPYPDN		; THEN ERASE FROM THE MIDDLE DOWN TO THE BOTTOM
	ADDM AC1,(P)
	SOS (P)
PPYPO5:	PUSHJ P,PPERS
	JRST PPYPO4

PPYPDN:	ADDM AC2,-1(P)
	JRST PPYPO5

PPYPDM:	SUB P,[2,,2]		;Flush data
	SETZ AC1,		;So we can see if DMSHFT queues anything
	EXCH DAT,UUO		;Put PP pointer into UUO for next routine
	PUSH P,DAT
	SETOM DPYCHR(UUO)	;Force line editor to be redrawn by DPYTLX
	MOVSI DAT,DPYTYP
	HRRZ TAC1,PRGNUM(DDB)
	MOVM TAC,AC3		;Indicate need to move more than PP size text
	PUSHJ P,DMSHFT		;Move text up or down with glitching routine
	POP P,DAT
	EXCH DAT,UUO
	JRST DMPPST		;Start output if anything queued
;PPERS

; ROUTINE TO ERASE PARTS OF DATA DISK SCREEN or Datamedia screen
; CALL WITH STARTING LINE OF ERASURE AT -2(P)
; ENDING LINE AT -1(P)

PPERS:	PUSHJ P,GETQ		; GET A TASK BLOCK (DM needs one, DD needs two)
IFN FTDD!FTGRIN,<
	TLNE DDB,DMLIN
>;IFN FTDD!FTGRIN
	JRST DMERS		; Different routine for DM
IFN FTDD!FTGRIN,<
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE
	POP P,TAC		; GET BACK THE ADDRESS OF THE FIRST ONE
	MOVE AC2,-2(P)		; PICK UP STARTING LINE OF TRANSFER
	MOVE AC3,-1(P)		; AND ENDING LINE OF TRANSFER
	CAMGE AC3,AC2		; IF THE FINISHING LINE IS ABOVE THE STARTING LINE . . .
	MOVE AC3,AC2		; THEN ONLY ERASE ONE LINE
	HRLM AC2,QLINE(AC1)	; MAKE THIS THE STARTING LINE NUMBER OF THE ERASURE
	HRLM AC2,QLINE(TAC)
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(TAC)
	HRLM DDB,(AC1)		; PUT IN DPY HEADER ADDRESS
	HRLM DDB,(TAC)
	MOVEI AC2,ERASE		; CALL THE ERASE CODE
	HRRM AC2,(AC1)
	HRRM AC2,(TAC)
	SETZM QFIELD(TAC)	; MAKE THE FIRST TASK GO OUT ON THE FIRST FIELD
	SETOM QFIELD(AC1)	; AND THE SECOND TASK GO OUT ON THE SECOND FIELD
	MOVEI AC2,PPNQT(DAT)
	MOVEM AC2,QCOUNT(TAC)
	MOVEM AC2,QCOUNT(AC1)
	MOVEI AC3,2
	ADDM AC3,(AC2)		; INCREMENT COUNT FOR TWO XFERS IN QUEUE
	SETZM QWAKE(TAC)	; NOTE THAT WE DON'T CARE TO BE AWAKENED
	SETZM QWAKE(AC1)
	PUSH P,TAC		; SAVE THE ADDRESS OF ONE OF THE BLOCKS
	PUSHJ P,QBLOCK		; QUEUE THE BLOCK
	POP P,AC1		; GET BACK THE ADDRESS OF THE OTHER
	PUSHJ P,QBLOCK		; QUEUE IT UP TOO--DON'T OPTIMIZE!!!!!
	POPJ P,
>;IFN FTDD!FTGRIN
;DMERS PTMOVE PTMOV1 PTMOV2 PTMOV3 PTMOV4

;Routine to erase lines on DM screen
DMERS:	MOVEI AC3,CHASTE	;Make it erase each line encountered
	HRL AC3,DDB
	MOVEM AC3,QFLAGS(AC1)
	SOS AC3,-2(P)		;First line to be erased, normalized for DM
	MOVEM AC3,QXY(AC1)
	MOVE TAC,-1(P)		;Ending line number
	SUB TAC,AC3		;Number of lines to erase
	JUMPG TAC,.+2
	MOVEI TAC,1		;Ending line above beginning, so erase just one line
	MOVEM TAC,QDMCNT(AC1)	;We better be able to erase that many lines!
GLOBAL DMMAXG			;GRRRR
IFG MAXLIN-DMMAXG,<.FATAL Increase DMMCNT in CACDAT or reduce MAXLIN in DPYSER.>
	MOVE AC3,[440700,,DMLFS] ;Put out that many LFs
	MOVEM AC3,QTAKR(AC1)
	SETZM QWAKE(AC1)	;Don't wake anyone up
	MOVEI AC2,PPNQT(DAT)
	MOVEM AC2,QCOUNT(AC1)	;Count erase requests in special count cell
	AOS PPNQT(DAT)
	MOVEM DAT,QPUTR(AC1)	;Save PP pointer in block for PPFLUS
	PUSHJ P,QDMERS		;Queue xfer, counting it in NPPXFR
	JRST STRTEX		;Start output

; HERE IS A ROUTINE TO MOVE THE LINE POINTER TABLE AROUND
; IN A CIRCULAR FASHION, SO AS NOT TO LOSE ANY POINTERS.
; CALL WITH NUMBER OF LINES TO BE MOVED IN AC3. NEGATIVE
; MEANS SCREEN IS MOVING UP, POSITIVE MEANS IT IS MOVING DOWN.
; NUMBER IS ASSUMED TO BE -=79 TO =79

PTMOVE:	PUSH P,AC3		; SAVE COUNT
	MOVNS AC3
	ADD AC3,PTBEG(DAT)	; ADD IN TO CURRENT INCREMENT
PTMOV2:	CAIL AC3,=80		; IS THE INCREMENT OUT OF RANGE?
	JRST PTMOV1		; YES, BRING IT BACK IN
PTMOV4:	SKIPGE AC3		; SAME FOR NEGATIVE
	JRST PTMOV3
	MOVEM AC3,PTBEG(DAT)
	POP P,AC3
	POPJ P,

PTMOV1:	SUBI AC3,=80
	JRST PTMOV2

PTMOV3:	ADDI AC3,=80
	JRST PTMOV4
;PPXSIZ PPX1 PPX2 PPXERR

;;PPXSIZ <N>B26 ! <M>  SETS CURRENT P OF P TO HAVE N GLITCHES OF M LINES.
PPXSIZ: SETZ AC1,
	DPB AC1,SIZSBU		; NOTE THAT PAGE SIZE SET BY UUO
	MOVE AC1,GLCNT(DAT)	; PICK UP NUMBER OF GLITCHES SO FAR ON THIS PAGE
	IMUL AC1,DEL(DAT)	; MULTIPLY BY NUMBER OF LINES IN PER GLITCH
	SUB AC1,DELCNT(DAT)	; ADD IN NUMBER OF LINES SO FAR IN LAST GLITCH
	PUSH P,AC1		; AND SAVE THIS
	LDB AC1,[POINT 9,UUO,26];NO. OF GLITCHES REQUESTED.
	LDB AC2,[POINT 9,UUO,35];NO. OF LINES/GLITCH.
	CAMN AC1,PGSIZ(DAT)	;Is number of glitches changing?
	CAME AC2,DEL(DAT)	;Or size of each glitch?
	JRST .+2		;Yes
	JRST POPAJ		;No change, POP AC1 and return
	IMUL AC2,AC1		;TOTAL SIZE OF REQUESTED PAGE, IN LINES.
	CAIG AC2,1		; MUST END UP 2 OR MORE LINES LONG
	JRST PPX1
	CAIG AC2,MAXLIN		;MORE THAN MAXIMUM ALLOWABLE NUMBER OF LINES?
	CAILE AC1,CNT		;TOO MANY GLITCHES ?
	JRST PPXERR		;YES. LOSE.
PPX2:	MOVEM AC1,PGSIZ(DAT)	;UPDATE GLITCHES/PAGE
	DPB UUO,[POINT 9,DEL(DAT),35]	;UPDATE GLITCH SIZE.
	IMUL AC1,DEL(DAT)	; LINES IN NEW PAGE
	EXCH AC1,(P)		; GET NUMBER OF LINES ON OLD PAGE INTO AC1
	SUBM AC1,(P)		; OLD NUMBER OF LINES - NEW NUMBER = EXTRA LINES
	IDIV AC1,DEL(DAT)	; SEE HOW MANY NEW GLITCHES THAT MAKES
	SUB AC2,DEL(DAT)	; MAKE INTO NUMBER OF LINES TO GO
	MOVNM AC2,DELCNT(DAT)	; SET NUMBER OF LINES TO GO IN CURRENT GLITCH
	ADDI AC1,1		; Make it go from 1 to PGSIZ
	MOVEM AC1,GLCNT(DAT)	; THIS IS OUR NEW GLITCH COUNT
	PUSHJ P,ADJSIZ		;.. AND GO ADJUST TO NEW SIZE by glitching if needed
	POP P,TAC		;FOR DM, NUMBER OF EXTRA LINES NEEDING SHIFTING
	TLNN DAT,DMLIN		;Don't redraw whole screen on DM	
	JRST REFPAG		; REFRESH NEW PAGE
	MOVE UUO,DAT		;Current PP pointer and display bit
	HRRZ AC1,TPJMP(UUO)
	SKIPE DMGLCH(UUO)	;Any glitching now needed?
	CAIN AC1,DISNOP		;Yes, is PP active?
	POPJ P,			;No
	PUSHJ P,PPHLD2		;Unhold us
	MOVSI DAT,DPYTYP	;Wakeup routine for QDMGLC
	HRRZ TAC1,PRGNUM(DDB)	;Data for clock req
	SETOM DPYCHR(UUO)	;Make sure DPYTLX redraws line editor
	SETZ AC1,		;Indicate no DM output queued yet
	AOJGE TAC,DMXSIZ
	SETZ TAC,		;No extra lines
	JRST DMXSIZ		;Now shift screen as needed

PPXERR:	CONSZ PI,77400
	JRST POPAJ
	ERMS {ILLEGAL PAGE SIZE SPEC.}
	JRST UUOERR

PPX1:	MOVEI UUO,2		; GIVE HIM A MINIMUM SIZE PAGE
	MOVEI AC1,1
	JRST PPX2
;DPYCLK CLKL1 CLKRTN DDFSER

;;CLKSER	;THIS IS DPYSER'S OWN PRIVATE CLOCK QUEUER.

↑DPYCLK:  ;HERE FROM CLKSER EVERY TICK.
	HGMAC(35)
IFN FTDDFSBUG,<
	SKIPE AC1,DDFS
	CAML AC1,SYSTOP
	CAML AC1,FSTOP
	PUSHJ P,DDFSER
>;IFN FTDDFSBUG

	SKIPE AC1,FSWTHD	;ANYTHING IN THE FREE STG. WAIT LIST ?
	PUSHJ P,FREE		;YES. GO PUT IT ON FREE STG. LIST.
	SYSPIFF		;...PEOPLE MAY USE FSWT2H AT INT. LEVEL...
	MOVE AC1,FSWT2H		;MOVE THINGS UP FROM THE SECOND-LEVEL WAIT LIST.
	MOVEM AC1,FSWTHD
	SETZM FSWT2H
	SYSPIN
	MOVE AC1,FSW2C
	MOVEM AC1,FSWC
	SETZM FSW2C
	HGMAC(36)
IFN FTDD!FTGRIN,<
	SKIPLE WHOPTR		; Is new wholine ready for some DD?
	PUSHJ P,WHOQUE		; YES, QUEUE UP A REQUEST
>;IFN FTDD!FTGRIN
	SKIPE AC3,WHDMPT	; Any new wholine request for DM?
	PUSHJ P,WHOQDM		; Yes, queue up a xfer
	SETZM WHDMPT
	SKIPE AC3,DMWQNX	; Any extra DM wholine request to do?
	PUSHJ P,WHOQDM		; Yes, queue it
	SETZM DMWQNX
	HGMAC(37)
	MOVEM P,BUGDPL		;*****SAVE FOR DPYPDL BUG TRAP
	EXCH P,DPYPDL		;YES. GET OUR OWN PDL.
	SETOM CLKLVL		;FLAG THAT WE ARE AT CLOCK LEVEL.
	AOSN WTFLG		;ARE WE IN A WAIT ?
	POPJ P,			;YES. RETURN TO THE WAITING ROUTINE.
	SKIPN @CLKQ		;ANY REQUESTS IN THE CLK QUEUE ?
	JRST CLKRTN		;NO. SEE HOW LITTLE TIME WE HAVE WASTED !!
	HRRZ TAC,CLKQ		;GET PTR. TO CURRENT END OF QUEUE.
	MOVEM TAC,CLKQTMP	;SAVE IT.
CLKL1:	SYSPIFF		;NO INTERRUPTS, PLEASE.
	MOVE DAT,@CLKQ		;GET LAST REQUEST FROM QUEUE.
	SOS CLKQ		;MOVE POINTER BACK BY 1.
	EXCH DAT,(TAC)		;PICK UP THE REQUEST WE ARE SERVICING..
	SYSPIN		;(DIDN'T SEE A THING, DID YOU ?)
	MOVEM DAT,SVDPDT	;*****SAVE DAT FOR BUG TRAP
	HLRZ TAC,DAT
	PUSHJ P,(TAC)		;..AND SERVICE IT, ALREADY.
	MOVE TAC,BUGDPL		;*****
	CAME TAC,DPYPDL		;*****
	JRST DPDLBG		;*****ROUTINE STEPPED ON DPYPDL
DPDLB1:	HGMAC(37)		;IN CASE SERVICE ROUTINE CHANGED HGCODE
	SOS TAC,CLKQTMP		;NOW GET PTR. TO NEXT LOWER ONE..
	CAIL TAC,CLKQUE		;ARE WE AT BOTTOM OF QUEUE ?
	JRST CLKL1		;NO. BACK FOR MORE.
CLKRTN: EXCH P,DPYPDL		;PUT BACK THE RIGHT PDL.
	SETZM CLKLVL		;NO LONGER IN CLOCK LEVEL CODE.
	POPJ P,

DPDLBG:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /DPYPDL CLOBBERED AT DPYCLK
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	MOVE TAC,BUGDPL		;WHO KNOWS WHAT CLOBBERAGE LURKS IN THE HEART
	MOVEM TAC,DPYPDL	;OF WDDTCA
	JRST DPDLB1

IFN FTDDFSBUG,<
DDFSER:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ/DDFS CLOBBERED at DPYCLK.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	SYSPIN
	POPJ P,

;CALL HERE BY PUTTING A <JRST DDFSCK> IN BRKPAT
;AND ENABLING ADDRESS BREAK ON DDFS
DDFSCK:	SKIPE AC1,DDFS
	CAML AC1,SYSTOP
	CAML AC1,FSTOP
	JRST BRKERR
	MOVEM TAC,DDFSPC	;SAVE PC OF GUY WRITING NOW
	JRST BRKXIT
>;IFN FTDDFSBUG
;WHOQUE WHOQ2 WHOQ4 WHOQ3 WHOQ4 WHOQ1 WHORPT

IFN FTDD!FTGRIN,<	;Whole page

; THIS ROUTINE QUEUES UP ANOTHER DATA DISC WHO LINE REQUEST.
; ONLY ONE LINE IS QUEUED UP EVERY 12. TIX OR SO.
; CALLED FROM DPYCLK WHEN WHOPTR IS GREATER THAN 0

WHOQUE:
IFE FTGRIN,<
	MOVNI AC3,2
>;IFE FTGRIN
IFN FTGRIN,<
	MOVNI AC3,1		;GRINNELL HAS ONLY ONE TRANSFER GET TO WHOWRT
>;IFN FTGRIN
	EXCH AC3,WHOPTR		;PICK UP NUMBER OF WHO LINE JUST UPDATED
				;SET WHOPTR TO -2 TO AVOID RE-ENTERING HERE.
				;WHOWRT WILL AOS WHOPTR FOR EACH FIELD DONE.
				;WHOPTR=0 ALLOWS WHOSER TO MAKE A NEW WHO LINE
	MOVEI DAT,0		; NO FS ADR IN CASE WE'RE DOING AVAILABLE MESSAGE
IFE FTGRIN,<
	CAIN AC3,DDAVLU		; AVLCHN FLAG
	JRST WHOQ3
>;IFE FTGRIN
	SKIPN AC2,LETAB(AC3)	; PICK UP ADDRESS OF DPY PROGRAM HEADER
	JRST WHOQ4		; LEAVE IF NONE THERE, maybe do Grinnell avl msg
	SKIPN DAT,FRETAB(AC3)	; PICK UP ADDRESS OF WHO DATA
	JRST WHOQ1		; LEAVE IF NONE
IFE FTVBEEP,<
	MOVE AC2,CURPP(AC2)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
IFN FTGRIN,<
	MOVE AC1,GRCW2(AC2)	; Make mode setting commands correspond to page
	MOVEM AC1,GRCW2-DDCW(DAT)	; printer modulo visual beep
>;IFN FTGRIN
	MOVE AC1,DDCW(AC2)	; PICK UP COMMAND WORD
>;IFE FTVBEEP
IFN FTVBEEP,<
	LDB AC1,[POINT 1,VBEEP(AC2),35]	; Beep in progress?
	ANDI AC1,1		; Background complements by low order bit of count
IFN FTGRIN,<
	ROT AC1,-11
	MOVE AC2,CURPP(AC2)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
	XOR AC1,GRCW2(AC2)	; Make mode setting commands correspond to page
	MOVEM AC1,GRCW2-DDCW(DAT)	; printer modulo visual beep
	MOVE AC1,DDCW(AC2)	; PICK UP COMMAND WORD
>;IFN FTGRIN
IFE FTGRIN,<
PRINTX Is this really the right way to flash a DD who line?
	ROT AC1,-6
	XOR AC1,DDCW(AC2)	; PICK UP COMMAND WORD
>;IFE FTGRIN
>;IFN FTVBEEP
	MOVEM AC1,(DAT)		; PLACE IT IN THE WHO CODE
WHOQ2:	PUSHJ P,GETQ
	MOVEM AC3,QHPOS(AC1)	; SAVE THE DPY NUMBER HERE
	HRLI DAT,WHOWRT
	MOVSM DAT,(AC1)
	SETZM QFIELD(AC1)	;ON FIELD ZERO
	MOVE AC2,[1,,3]		;USES TOP THREE LINES
IFE FTGRIN,<
	CAIN AC3,DDAVLU
	MOVE AC2,AVLLN
>;IFE FTGRIN
	MOVEM AC2,QLINE(AC1)
	SETZM QCOUNT(AC1)
IFE FTF2,<
	PUSH P,AC3		;SAVE THE DPY NUMBER
	PUSHJ P,QBLK		;QUEUE UP THIS FIELD'S WORTH.
	PUSHJ P,GETQ
	POP P,QHPOS(AC1)	;STORE THE DPY NUMBER
	MOVSM DAT,(AC1)
	SETOM QFIELD(AC1)	;FIELD 1
	MOVE AC2,[1,,3]
	CAIN AC3,DDAVLU
	MOVE AC2,AVLLN
	MOVEM AC2,QLINE(AC1)
	SETZM QCOUNT(AC1)
>;IFE FTF2
	PUSHJ P,QBLK		;DON'T OPTIMIZE!!!!!!
	POPJ P,

IFN FTGRIN,<
;Here if this Grinnell isn't in use.  Output available msg unless suppressed.
WHOQ4:	SKIPE GRASUP-DDL0(AC3)	;Avail msg suppressed?
	JRST WHOQ1		;Yes, forget it
	HRLI AC3,-1		;No, flag this Grinnell to get avail msg
>;IFN FTGRIN
WHOQ3:	SKIPN WHOJOB		;IS THERE A MINI-WHO PHANTOM?
	JRST WHOQ2		;NO, WE HAVE TO DO IT OURSELF
IFE FTGRIN,<
WHOQ4:
>;IFE FTGRIN
WHOQ1:	SETZM WHOPTR		;HERE TO FLUSH THE WHO LINE REQUEST
	POPJ P,			;WHOPTR MUST BE CLEARED.

IFN FTVBEEP,<
; ENTER HERE AT CLOCK LEVEL WITH LINE NUMBER IN TAC TO FLASH A WHO LINE
↑WHORPT:SKIPN J,LETAB(TAC)	;Get structure for WHO line
	  POPJ P,		;  Display went away!
	MOVE DAT,LINTAB(TAC)	;Setup line characters so it knows what kind of
				;  WHO line to make (i.e. Grinnell/DD)
	PUSH P,TAC		;Save line number out of paranoia
	PUSHJ P,REWHO		;Now, force update of WHO line
	POP P,TAC
	SOSG VBEEP(J)		;Any flash cubes left?
	  POPJ P,		;  Shucks, oh well
IFN FTF2,<
	SETZM WHOTX		;Wake up WHOSER, we want this much sooner than
				;  an F2 would normally do it.
>;IFN FTF2
	LSH TAC,=12		;Shift into datum position
	ADD TAC,[XWD $WHORPT,JIFSEC/4]	;Come back in 1/4 sec.
	CLKENQ (TAC)
	POPJ P,
>;IFN FTVBEEP

>;IFN FTDD!FTGRIN	;Whole page

;WHOQDM WHOQD2

;Here for DM wholine to be queued, with line number in AC3.
WHOQDM:	SKIPE TEM,FRETAB(AC3)	; PICK UP ADDRESS OF WHO DATA
	SKIPN DAT,LETAB(AC3)	; PICK UP ADDRESS OF DPY PROGRAM HEADER
	POPJ P,			; LEAVE IF NONE THERE
	HRLI DAT,NOEEOL!TRUNCA	;Don't erase old lines and don't wrap around
;	LDB AC3,[POINT 17,AC3,17] ;Get number of text words to suppress
;	SUBI AC3,WLINK-WTEND	  ; minus number of text words there are
	JUMPGE AC3,WHOQD2	;Jump if user line hasn't changed
	PUSHJ P,GETQ		;Get a queue block for user line
	MOVSM DAT,QFLAGS(AC1)
	MOVEI TEM,WTEND(TEM)	;Address of text of user line
	HRLI TEM,440700
	MOVEM TEM,QTAKR(AC1)
	MOVEI AC2,(WLINK-WTEND)*5 ;Length of user line in chars
	MOVEM AC2,QDMCNT(AC1)
	MOVEI AC2,1
	MOVEM AC2,QXY(AC1)	;Start at left margin on second line
	SETZM QCOUNT(AC1)	;Don't wake anyone when done
	MOVEI AC2,DMWHO-QLINK(DAT)
	PUSHJ P,QDM		;Queue up the user line first
WHOQD2:	PUSHJ P,GETQ		;Get a queue block for system line
	MOVSM DAT,QFLAGS(AC1)
	MOVE AC2,[440700,,COMWHO]
	MOVEM AC2,QTAKR(AC1)
	MOVEI AC2,LCOMDM*5-LCOMNL-2 ;Length of system wholine in chars less CRLF
	MOVEM AC2,QDMCNT(AC1)
	SETZM QXY(AC1)		;Upper left corner
	SETZM QCOUNT(AC1)	;Don't wake anyone over this xfer
	MOVEI AC2,DMWHO-QLINK(DAT)
	PUSHJ P,QDM		;And now queue the system line
	JRST STRTDM		;Start TTY
;FREE GETFS POPAJ CLKWAT ARRRGH

; ROUTINE TO FREE AN ENTIRE LIST OF BLOCKS, LINKED UP THROUGH PPLINK
; ENTER WITH TOP OF LIST IN TAC

FREE:	JUMPE AC1,CPOPJ
	CAML AC1,SYSTOP
	CAML AC1,FSTOP
	POPJ P,
	HRRZ TAC,PPLINK(AC1)	;GET LINK BEFORE GIVING BACK FREE STORAGE
	PUSHJ P,SFSGIV
	DPYFS
	MOVE AC1,TAC		;LOOP FOR NEXT BLOCK
	JRST FREE

GETFS:	PUSH P,AC1
	PUSHJ P,UGETFS		;GET A BLOCK OF FREE STG. (IN AC2).
	MOVE AC2,AC1
↑POPAJ:	POP P,AC1
	POPJ P,

CLKWAT:	CONSO PI,77000		;Better only be in channel 7!
	CONSO PI,00400
	 JRST ARRRGH
IFN FTSCNBUG <	;Let's catch it here if we can
	SKIPL SCNCNT		;We only care if it's left off
	 JSR CH7CHK
>;IFN FTSCNBUG
	MOVEM 17,SVAC+17
	MOVEI 17,SVAC		;SAVE ALL AC'S.
	BLT 17,SVAC+16
IFN FT17P,<
	MOVE 17,SVAC+17		;restore this AC (P!)
>;IFN FT17P
	SETOM WTFLG		;SET WAIT FLAG FOR CLK SERVICE.
	PUSHJ P,CLKRTN		;GO AWAY FOR A TICK.
	MOVSI 17,SVAC		;RESTORE THEM.
	BLT 17,17
	POPJ P,

ARRRGH:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /AT CLKWAT BUT NOT IN CLKCHN!!!!!
/
	PUSHJ P,DISFLU
;;	SKIPN DEBMOD
;;	JRST AUTOLO
	POPACS
	PUSHJ P,DDTCAL
;;	JRST .-1	;BETTER NOT RETURN WITH POPJ
	JRST 4,AUTOLO
;PRGFND PRGF1 PRGF2 PRGF3 PRGFER PRGFE1 DDFND

;;UUO LEVEL UTILITY ROUTINES AND DISPATCHERS.

;;PRGFND  FINDS DPY PRGM FOR JOB IN J.

PRGF2:	TLNE DDB,PTYLIN			;IS THIS A PTY ?
	TLNE DDB,IMPBIT			;AND NOT AN ARPA PTY AT THAT?
	JRST CPOPJ1			;NO, ERROR
	SKIPN DDB,PTYJOB-PTYL0(DDB)	;GET JOB WHICH OWNS PTY.
	JRST CPOPJ1			;NO JOB--MAY HAVE JUST RELEASED PTY
	SKIPA DDB,JBTLIN(DDB)		;USE HIS DPY, IF ANY.
PRGF1:	MOVE DDB,JBTLIN(J)		;GET 'TTY' LINE NO. FOR JOB., IF ANY.
	CAMN DDB,[-1]
	JRST CPOPJ1			;DETACHED, LOSE
	HLL DDB,LINTAB(DDB)
	TLNN DDB,DISLIN!DDDLIN!DMLIN	; IS THIS A DPY OF SOME SORT?
	JRST PRGF2			; NO, MAYBE IT'S A PTY--LOOK UP CHAIN
	HRRZ DDB,LETAB(DDB)		;GET PTR. TO PRGM HEADER.
PRGF3:	HLRZ AC1,PPCALL(DDB)		; GET POINTER TO PP 0
	HLL DDB,PPDPY(AC1)		; PICK UP DISPLAY-TYPE BIT
	POPJ P,

PRGFND:	SKIPN DDB,DPYMAP(J)		;IS GUY CONNECTED TO SOMEONE ELSE'S DPY?
	PUSHJ P,PRGF1			;NO. FIND ONE OF HIS OWN.
	 JRST CPOPJ1			;SUCCESS RETURN
PRGFER:	CONSO PI,77400			;WHAT LEVEL ARE WE?
	POPJ P,				;IF AT UUO LEVEL, ERROR RETURN
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES			;OTHERWISE, DISASTER
	ASCIZ /ILLEGAL JOB NUMBER AT PRGFND NOT AT UUO LEVEL
/
	JRST DPYATL

DDFND:	PUSHJ P,PRGFND		; USE PRGFND
	 CAIA
	JRST CPOPJ1
	CAIE UCHN,3		; DDFND CALLED ONLY FROM PGIOT WITH UCHN SETUP
	POPJ P,			; ONLY THE DD UUO IS LEGAL FROM A NON-DISPLAY
	MOVEI AC3,DPYLEN
	PUSHJ P,UFSGET
	MOVE DDB,AC1
	SETOM DPRLSF(DDB)
	SETOM PRGNUM(DDB)
	SETZM PRGCNT(DDB)	; CAN'T BE ANY OVERLAP IN PROGRESS - RPH 10-5-72
	HRLI DDB,DDDLIN		; PUT IN DISPLAY-TYPE BIT (DD)
	JRST CPOPJ1		; SUCCESS
;PPIOT

;;MORE GENERAL UUO ROUTINES.

↑PPIOT:	PUSHJ P,PRGFND		;FIND APPROPRIATE DPY PRGM.
	 POPJ P,		;IGNORE IF NOT DISPLAY
	MOVE DAT,CURPP(DDB)	;GET PTR. TO CURRENT P OF P.
	HLL DAT,DDB		; PUT IN FLAG BIT
	CAIG UCHN,MPPIOT	;DOES FUNCTION EXIST ?
	JRST @PPIOTX(UCHN)	;YES.
	JRST UUOERR

DEFINE UUOS{FOR X IN(<PPSEL,,PPSELU>,PPACT,<DPYPOS,,PPYPOS>,<DPYSIZ,,PPXSIZ>
,<PPREL,,PPRELU>,PPINFO,LEYPOS,PPHLD,<CURSOR,,CURSET>)}

PSHSYS
LOSYS

UUOMAC PPIOTX,PPIOT
MPPIOT←←UUOCNT-1

POPSYS
;DPYCLR DPYRST PPCLR PPC1 PPC3 PPC2 PPC4 PPCLRX

;RESET DPY, CLEARS PP AND POG. (UUO LEVEL)

↑DPYCLR:JUMPE UCHN,DPYRST	;NON-ZERO AC FIELD MEANS SELECT OTHER DPY.
	JSP AC3,FNDJOB		;GET JOB NO. (FNDJOB IS IN MAIL-UUOCON).
	EXCH DAT,J		;PRETEND IT'S OURS.
	PUSHJ P,PRGFND		;FIND ASSOCIATED DPY PRGM.
	 POPJ P,		;SHOULDN'T LOSE ANY MORE THAN ANYONE ELSE
	MOVEM DDB,DPYMAP(DAT)	;ENTER IN OUR TABLE.
	POPJ P,			;WE WILL NOW USE OTHER GUY'S DPY PRGM.

↑DPYRST:SETZM DPYMAP(J)
	PUSHJ P,CLRIMG		;CLEAR TTY IMAGE MODE
	PUSHJ P,PRGF1		;FIND DPY PRGM FOR JOB IN J.
	 TDZA UCHN,UCHN		;FOUND.  SET UP ARG FOR RSTFRZ.
	POPJ P,			;NO PRGM.
	PUSHJ P,RSTFRZ		;UNFREEZE THE DM QUEUES IF DM
	TLNE DDB,DMLIN
	PUSHJ P,CHASEM		;Flush any of our user program xfers still going
	CONSO PI,77400		;Can't wait at clock level
	PUSHJ P,DDWAIT		;Wait for any DD/DM xfers to finish (mainly DD)
	PUSHJ P,PRGF1		;in case waited, make sure dpy hdr still there
	 CAIA
	POPJ P,			;gone!
	TLNE DDB,DMLIN
	PUSHJ P,DMCLRU		;Flush clock request for DMUCLK, zero UCOUNT
IFN FTDD!FTGRIN,<
	PUSH P,J
	PUSHJ P,PGCLR		;FIRST FLUSH ALL PIECES OF GLASS (CLOBBERS J)
	POP P,J
>;IFN FTDD!FTGRIN
↑PPCLR:	PUSH P,PRGACT(DDB)	;Remember former PP activation state
	MOVEI UUO,17		;NOW ALL PIECES OF PAPER EXCEPT 0.

; PPREL SELECTS P OF P 0 (UUO←0) IF IT RELEASES A P OF P
;   WHICH IS CURRENTLY SELECTED, AND NOT 0, SO.....
	PUSH P,UUO		;PPREL MAY CLOBBER UUO.
PPC1:	PUSHJ P,PPREL		;RELEASE P OF P.
	 JRST PPCLRX		;dpy hdr went away while waiting! abort now.
	SOSE UUO,(P)		;NEXT
	JRST PPC1		;YES
	HLL DAT,DDB		; PUT IN BIT FOR DISPLAY TYPE
	MOVEM DDB,(P)		; SAVE PROGRAM HEADER ADDRESS
	PUSHJ P,PPSEL		;SELECT P OF P 0.
	 JRST PPCLRX		;dpy hdr went away while waiting! abort now.
	POP P,DDB		;Dpy header and bits
	MOVE UUO,DDB
	EXCH UUO,(P)		;Save dpy header on stack--old PP act bits in UUO
;Enter here from PPNST2 to redraw screen on BRK N
PPC3:	TRNE UUO,400000		;Was PP 0 on before?
	JRST PPC2		;Yes, don't redraw it now
	SETOM PGSIZ(DAT)	;Make PPXSIZ redraw screen (DD, III)
	TLNN DDB,DMLIN
	JRST PPC2
	SETZM DMLAST(DAT)	;Make sure whole screen gets redrawn on DM
	SETOM GLTCH(DAT)	;Force redrawing of screen on DM
;Enter here from PPNSET, called from ESC N & BRK N commands to redraw current PP
PPC2:	SETOM DMUSXY(DDB)	;Return cursor to normal position on DM
IFN FTRANGE,<
	SETZM DMBEG(DDB)	;DON'T SUPPRESS ANY USER PROGRAM DM OUTPUT
	MOVEI UUO,-1
	MOVEM UUO,DMEND(DDB)
>;FTRANGE
	MOVE DDB,(P)		; PICK UP PROGRAM HEADER
	SETZ UUO,		; CLEAR LINE EDITOR POSITION
	PUSHJ P,LEYPOS
	SETZ UUO,
	PUSHJ P,PPHLD		; RESET HOLDING STATUS
	MOVEI UUO,YPDD		; DATA DISC DEFAULT Y POSITION
	TLNE DDB,DMLIN
	MOVEI UUO,YPDM		; DATAMEDIA DEFAULT Y POSITION
	TLNE DDB,DISLIN
	MOVEI UUO,YPIII		; III DEFAULT Y POSITION
	PUSHJ P,PPYPOS
	POP P,DDB
IFE FTF2,<
	MOVEI UUO,NGSIII*1000+NLSIII	;DEFAULT GLITCH AND SCREEN SIZE FOR III
	TLNN DDB,DMLIN
	JRST PPC4
>;IFE FTF2
	PUSHJ P,DMNORM		;GET DEFAULT GLITCHES/SCREEN FOR DM INTO AC1
	LSH AC1,9		;(GRINNELLS GET HERE TOO)
	MOVEI UUO,NLSDM(AC1)
IFE FTF2,<
PPC4:	TLNN DDB,DDDLIN
>;IFE FTF2
	JRST PPXSIZ		;NOT DD, JUST SET SCREEN DEFAULTS AND BE DONE
IFE FTF2,<
	MOVEI UUO,NGSDD*1000+NLSDD
	PUSHJ P,PPXSIZ
	HRRZ TAC,PRGNUM(DDB)
	SUBI TAC,DDL0
	PUSHJ P,VDRST1		;EXTRA VIDEO DIDDLING FOR DD
	JRST VDOUT
>;IFE FTF2

PPCLRX:	ADJSP P,-2		;Flush two piece of data from stack, and return
	POPJ P,
;WHONOW PPNST2 PPNSET PPNST1 SETPHD PPGSET PPGST2 PPGST1 DMNORM

;Clock level routines to carry out line editor escape commands.

;Here to refresh wholine after some escape command has erased the screen.
;Clobbers AC1,AC2,AC3,TAC,J and LH DAT.
WHONOW:	MOVE J,DAT              ;DPY HDR to J for LINED
	MOVE AC1,PRGNUM(DAT)	;TTY line number
	HLL DAT,LINTAB(AC1)     ;Get line characteristics
	OFFSCN                  ;Off in case we flush DM wholine queue
	PUSHJ P,REWHO           ;Call LINED to force wholine back out quickly
	JRST SCNONJ

;Here after erase done by BRK N.
PPNST2:	PUSHJ P,WHONOW		; REFRESH WHOLINE NOW
	TDZA UUO,UUO		; FORCE REDRAWING PP
↑PPNSET:MOVEI UUO,400000	;Enter here from ESC N--redraw only if necessary
	PUSHJ P,SETPHD		; SET UP DDB AND DAT PROPERLY
	PUSH P,[PPNST1]		;Routine to call after PPC3
	PUSH P,DDB
	JRST PPC3		;Normalize size and position of current PP

PPNST1:	SETO AC1,		; MARK SIZE AND Y-POSITION SET BY USER
	DPB AC1,SIZSBU
	DPB AC1,POSSBU
	POPJ P,

SETPHD:	HRRZ DDB,DAT		; PUT PROGRAM HEADER ADDRESS IN DDB
	MOVE DAT,CURPP(DDB)
	HLL DDB,PPDPY(DAT)	; GET BIT INDICATING DISPLAY TYPE
	HLL DAT,DDB
	POPJ P,

;Here from ESC G to set number of glitches on screen
↑PPGSET:PUSHJ P,SETPHD
IFE FTF2,<
	MOVEI AC3,NGSDD
	TLNE DAT,DISLIN
	MOVEI AC3,NGSIII
	TLNN DAT,DMLIN
	JRST PPGST2
>;IFE FTF2
	PUSHJ P,DMNORM		; GET DEFAULT NUMBER OF GLITCHES FOR DM INTO AC1
	MOVEI AC3,(AC1)
PPGST2:	SKIPN UUO,LEARG(DDB)	; PICK UP NUMBER OF GLITCHES REQUESTED
	MOVE UUO,AC3		; NO ARG, USE DEFAULT
	LSH UUO,=9		; PUT IN LH OF RH
	ADD UUO,DEL(DAT)
PPGST1:	PUSHJ P,PPXSIZ		; SET IT
	SETO AC1,
	DPB AC1,SIZSBU		; NOTE SIZE WAS SET BY USER
	POPJ P,

DMNORM:	MOVE AC1,DPYHGT(DDB)	; GET SCREEN SIZE ON DM
	SUBI AC1,3		; LESS WHOLINE AND HOLDING LINES
	IDIVI AC1,NLSDM		; DIVIDED BY LINES/GLITCH IS DEFAULT GLITCHES/SCR
	POPJ P,
;PPLSET PPYSET PPYS2 PPYDD PPYDM PPYS3 PPYIII

; CALLED FROM <ESC>L IN LINE EDITOR. SETS LINES/GLITCH

↑PPLSET:
	PUSHJ P,SETPHD
	MOVEI AC3,NLSDD
	TLNE DAT,DISLIN
	MOVEI AC3,NLSIII
	TLNE DAT,DMLIN
	MOVEI AC3,NLSDM
	MOVE UUO,PGSIZ(DAT)	;Maintain number of glitches per screen
	LSH UUO,=9		; w/old number in lh of RH
	SKIPN AC2,LEARG(DDB)
	MOVE AC2,AC3
	ADD UUO,AC2		;Lines per glitch in rh of RH
	JRST PPGST1

; CALLED FROM <ESC>Y IN LINE EDITOR. SETS Y POSITION

↑PPYSET:
	PUSHJ P,SETPHD
	MOVE UUO,LEARG(DDB)
	JUMPL DDB,PPYIII
	TLNE DDB,DMLIN
	JRST PPYDM
PPYDD:	MOVEI AC3,YPDD
	LSH UUO,7
IFN AC1-UUO-1,<.FATAL ACs UUO and AC1 are not contiguous as required here.>
	IDIV UUO,[-5]
PPYS3:	ADDI UUO,1000
PPYS2:	CAIL UUO,1000
	MOVEI UUO,(AC3)		;SET TO NORM ON ZERO (NULL) ARG
	PUSHJ P,PPYPOS
	SETO AC1,
	DPB AC1,POSSBU
	POPJ P,

PPYIII:	MOVEI AC3,YPIII
	IMUL UUO,[-30]		;Calculate III distance to given line
	ADDI UUO,YPIII+30*YLINE	;Add position of line above "top" of screen
	JRST PPYS2

PPYDM:	MOVEI AC3,YPDM		;Pick up default Y-position for Datamedia
	LSH UUO,7		;Convert line number to number from -1000 to 1000
IFN AC1-UUO-1,<.FATAL ACs UUO and AC1 are not contiguous as required here.>
	IDIV UUO,[-3]		; by multiplying by -2000/=24 and adding 1000
	JRST PPYS3
;PPHLD PPHLD1 PPHLD2 AC1CLK

; SET PAGE PRINTER HOLD COUNTS. GIVE LINE COUNT IN BITS 18-26 AND
; GLITCH COUNT IN 27-35. HIGH ORDER BIT OF FIELD ON MEANS DO NOT SET.

PPHLD:	SETZ AC1,
	TRNE UUO,1B18		; DOES HE WANT TO SET LINE COUNT?
	JRST PPHLD1		; NO, SKIP IT
	DPB AC1,LHCSBU		; NOTE SET BY UUO
	LDB AC2,[POINT 8,UUO,26];used to say 25 instead of 26--ME 8-19-73
	DPB AC2,HLINES		; SET INTO PROGRAM HEADER
	SKIPG AC2		; ZERO MEANS DON'T HOLD AT ALL
	MOVSI AC2,377777	; WHICH IS SIGNIFIED BY POSITIVE INFINITY
	MOVEM AC2,LHCNT(DDB)	; START IT GOING NOW
PPHLD1:	TRNE UUO,1B27		;used to say 1b26--ME 8-19-73
	JRST PPHLD2		; NOW GO UNHOLD US
	DPB AC1,GHCSBU
	LDB AC2,[POINT 8,UUO,35]
	DPB AC2,HGLTCH
	SKIPN AC2
	SETO AC2,
	MOVEM AC2,GLHCNT(DDB)
PPHLD2:	SETZ AC1,
	EXCH AC1,DPHOLD(DDB)
	JUMPE AC1,CPOPJ
	HRRZ AC1,PRGNUM(DDB)
	HRLI AC1,UNHOLD
↑AC1CLK:SYSPIFF
	IDPB AC1,CLKQ
	SYSPIN
	POPJ P,
;PPSPY PPSPY2 PPINFO PPSPIE PPINF1 PPSPY1 PPLNCT

; THIS ROUTINE GIVES THE USER A NICE LITTLE TABLE OF DATA ABOUT HIS
; PAGE PRINTER. THE TABLE IS =20 WORDS LONG. THE FIRST WORD IS
; XWD <POG ACT BITS>,<PP ACT BITS> WHICH ARE IN PPACT OR PGACT FORMAT.
; THE SECOND WORD IS THE NUMBER OF THE PIECE OF PAPER CURRENTLY SELECTED.
; THE THIRD WORD IS THE LINE EDITOR POSITION IN THE RH, BIT ZERO IS
; THE PAGE COLOR, AND BIT 1 SAYS WHETHER <ESC>C HAS BEEN TYPED SINCE YOU
; LAST GAVE THIS UUO, BIT 2 IS ON IF YOU ARE A DATA DISK DISPLAY.
; THE FOURTH THROUGH THE 19.TH WORDS ARE XWD <Y-POS>,<NG*1000+LPG> WHERE
; NG IS THE NUMBER OF GLITCHES AND LPG IS THE NUMBER OF LINES PER GLITCH.
; THIS IS CLEVERLY ARRANGED SO THAT A PPYPOS UUO WITH THE ARGUMENT
; IN THE LH OF THIS WORD FOLLOWED BY A PPXSIZ WITH THE ARGUMENT IN
; THE RH OF THIS WORD COMPLETELY RESTORES THAT PAGE.
; THE 20TH WORD IS A COPY OF GWORD. B0 MEANS PAGE PRINTER SIZE SET LAST
; BY USER COMMAND RATHER THAN BY UUO, B1 FOR Y-POSITION, B2 FOR LINE HOLD COUNT,
; AND B3 FOR GLITCH HOLD COUNT. BITS 9-17 HAVE THE ACTUAL LINE HOLD COUNT
; AND BITS 18-25 HAVE THE ACTUAL GLITCH HOLD COUNT. ZERO IF NOT BEING USED.

↑PPSPY:	HRR UUO,TAC		;VERSION OF PPINFO FOR ANOTHER JOB'S DPY
	HLRE J,TAC		;ARG IS JOB#,,OUTPUT BLOCK ADDR
	JUMPLE J,PPSPY1		; OR - LINE # IN LH (-0 IS 0 AND GETS TTY0)
	CAIL J,JOBN
	POPJ P,
	MOVE AC1,JBTSTS(J)
	TLNN AC1,JNA
	POPJ P,
	PUSHJ P,PRGF1		;USE PRGF1 TO OUTFLANK DPYMAP HACK IN PRGFND
PPSPY2:	 SKIPA DAT,CURPP(DDB)	;PRGF1 SKIP RETURNS ON FAILURE
	POPJ P,			;NO DISPLAY
	HLL DAT,DDB
	SETO AC3,		;FLAG THAT WE'RE DOING PPSPY UUO
	AOSA (P)		;OK, SET SKIP RETURN AND DROP THROUGH
PPINFO:	SETZ AC3,		;FLAG THAT WE'RE DOING PPINFO UUO
	MOVE AC1,PRGACT(DDB)	;PICK UP HIS ACTIVATION BITS
	XCTR XW,[MOVEM AC1,(UUO)]
	MOVE AC1,PPNO(DAT)	;GET CURRENT PIECE OF PAPER NUMBER
	XCTR XW,[MOVEM AC1,1(UUO)]
REPEAT 0,< ;DON'T DELETE THIS CODE -- IT MIGHT COME BACK SOMEDAY SOON
	LDB AC1,[POINT 11,LEPOS(DDB),21]
	TRNE AC1,1⊗=10		;EXTEND SIGN BIT
	IORI AC1,-1⊗=10
>;REPEAT 0
	HRRZ AC1,LEYVAL(DDB)	;GET 18-BIT LINE EDITOR Y-POSITION FROM LEYPOS
	MOVE AC2,DAT		;Load pointer to PP for next byte pointer to use
	LDB AC2,PBAKCL		;Get background color bit (using (AC2))
IFN FTDD,<
	TRNE AC2,1		;DD bit on means dark background
>;IFN FTDD
IFE FTDD,<
	TRNN AC2,1		;Grinnell bit off means dark background
>;IFE FTDD
	TLO AC1,(1B2)		;Set dark background bit for uuo
	MOVE AC2,GWORD(DDB)	;PICK UP GARBAGE DUMP WORD
	XCTR XW,[MOVEM AC2,=19(UUO)]
	JUMPN AC3,PPSPIE	;Jump if doing PPSPY UUO
	HRRI AC2,0		;prepare to clear LE-wrapped bit, if it was on
	TLNE AC2,LEWRBT		;don't clear if was off, avoid timing race
	DPB AC2,LEWRBP		;clear line-editor-has-wrapped-recently bit in GWORD
	EXCH AC3,LECC(DDB)	;Get ESC C flag and clear it in dpy hdr
	SKIPE AC3
	TLO AC1,(1B1)		;Flag ESC C done since last PPINFO UUO
PPSPIE:	MOVSI AC2,DDDLIN!DMLIN!DISLIN
	AND AC2,DDB		;SET ONLY APPROPRIATE DISPLAY BIT IN AC2
	IOR AC1,AC2
	TLNE AC2,DMLIN		;Can't have done FREEZE unless DM
	MOVE AC2,DMFLAG(DDB)
	TRNE AC2,NOINTR
	TLO AC1,1		;Tell him that a FREEZE is in effect
	XCTR XW,[MOVEM AC1,2(UUO)]
	ADDI UUO,3
	MOVSI AC1,(UUO)		;ZERO OUT THE RESET OF THE TABLE
	HRRI AC1,1(UUO)
	XCTR XW,[SETZM (UUO)]
	XCTR XBLTRW,[BLT AC1,17(UUO)] ;BLT USER TO USER, MAKING ZEROES
	HLRZ AC1,PPCALL(DDB)	;POINTER TO FIRST PAGE PRINTER CONTROL BLOCK
PPINF1:
REPEAT 0,< ;DON'T DELETE THIS CODE -- IT MIGHT COME BACK SOMEDAY SOON
	LDB AC2,[POINT 11,PPOSV(AC1),21]
	TRNE AC2,1⊗=10		;SPREAD SIGN BIT ALL DOWN WORD
	IOR AC2,[-1⊗=10]
>;REPEAT 0
	HRRZ AC2,PPYVAL(DAT)	;GET 18-BIT POSITION VALUE IN CASE THIS IS A DM
	LSH AC2,=9		;MOVE IT OVER
	ADD AC2,PGSIZ(AC1)	;PUT IN THE NUMBER OF GLITCHES
	LSH AC2,=9
	ADD AC2,DEL(AC1)	;AND THE NUMBER OF LINES PER GLITCH
	MOVE AC3,PPNO(AC1)	;PICK UP THE PIECE OF PAPER NUMBER
	ADD AC3,UUO
	XCTR XW,[MOVEM AC2,(AC3)] ;GIVE HIM THE WORD
	HRRZ AC1,PPLINK(AC1)	;LINK TO NEXT PAGE PRINTER CONTROL BLOCK
	JUMPN AC1,PPINF1	;LOOP AROUND IF THERE IS ONE
	POPJ P,

PPSPY1:	MOVM J,J		;NEGATIVE ARG TO PPSPY IS LINE #
	CAIL J,TTPLEN		;LEGAL LINE NUMBER?
	POPJ P,			;NOPE
	MOVE DDB,LINTAB(J)
	TLNN DDB,DISLIN!DDDLIN!DMLIN
	POPJ P,
	HRRZ DDB,LETAB(J)
	JUMPE DDB,CPOPJ		;NO DPY HEADER
	PUSHJ P,PRGF3		;SETS UP DISPLAY-TYPE BIT IN DDB
	JRST PPSPY2

;CALLED FROM TTYSER (TTYTLK FOR TALK COMMAND CHECKING) WITH TTY LINE NUMBER IN
;TAC1 (=LINE), RETURN TAC=0 IF NOT A DPY, OTHERWISE TAC=# OF LINES IN CURRENT PP
;IF CURRENT PP IS DEACTIVATED, RETURN TAC=-1

↑PPLNCT:SKIPN TAC,LETAB(TAC1)	;IS THIS LINE A DPY?
	POPJ P,			;NO, RETURN 0
	PUSH P,TAC1		;SAVE LINE NUMBER
	MOVE TAC1,CURPP(TAC)	;GET CURRENT PP BLOCK
	MOVE TAC,PGSIZ(TAC1)	;GLITCHES/PAGE
	IMUL TAC,DEL(TAC1)	;TIMES LINES/GLITCH
	HRRZ TAC1,TPJMP(TAC1)
	CAIN TAC1,DISNOP	;Is this PP activated?
	MOVNI TAC,1		;NO
	POP P,TAC1
	POPJ P,			;RETURN PP SIZE
;LEYPOS CURSET FOOFRL FREEL

; THIS IS THE ROUTINE FOR A UUO WHICH SETS YOUR LINE EDITOR'S VERTICAL
; POSITION. THE EFFECTIVE ADDRESS OF THE UUO IS SAID POSITION IN
; PPYPOS FORMAT. Y-POSITION OF ZERO IS VERBOTTEN AND MEANS RETURN TO
; THE BOTTOM OF THE PAGE PRINTER.

↑LEYPOS:MOVE AC1,[BYTE (11)<-777>,0(3)0,0(2)1,2(3)3]
	TRNN UUO,-1		; IS THE POSITION ZERO?
	SKIPA AC1,[DISNOP]	; YES, PUT A NO-OP IN
	DPB UUO,[POINT 11,AC1,21]
	MOVEM AC1,LEPOS(DDB)	; PUT IT IN BEFORE THE LINE EDITOR CALL
	TRZ UUO,400000		;THIS BIT USED FOR MAKING A NON-ZERO VALUE
	TRNE UUO,200000		;THIS IS THE SIGN BIT, EXTEND IT
	TRO UUO,400000
	HRRM UUO,LEYVAL(DDB)	;REMEMBER 18-BIT VALUE OF POSITION
	JUMPL DAT,CPOPJ		;THAT'S ALL IF III
	SETO AC1,		; QUEUE UP A LINE EDITOR REQUEST TO GET IT REPOSITIONED
	EXCH AC1,LECLK(DDB)
	JUMPN AC1,CPOPJ
	HRR AC1,DDB
	HRLI AC1,DPLED
	JRST AC1CLK		;Plant clock request from AC1

;Command to leave DM cursor at explicit X-Y location whenever LE is empty.
;Negative arg means no special place; LH is col, RH is line, each from 0 to max-1.
CURSET:	TLNN DDB,DMLIN		
	POPJ P,			;Gotta be DM
	XCTR XR,[MOVE AC1,(UUO)];Get X-Y position word.
	MOVEM AC1,DMUSXY(DDB)	;Save in dpy header
	MOVE DAT,DDB
	JRST STRTDM		;Start output to ensure getting cursor positioned.

;;FREEL FREES A LIST OF BLOCKS POINTED TO BY AC1, AND UPDATES
;; THE USER'S BLKTOT.  

FOOFRL:	HRRZ AC1,UUO
	PUSHJ P,FSGIVE
	HRRZ AC1,TAC1
	JUMPE AC1,CPOPJ
FREEL:	HRRZ AC3,PPLINK(AC1)	;GET CDR OF LIST.
	PUSHJ P,CGIVFS		;FREE CAR OF LIST.
	MOVEM AC3,AC1
	JUMPN AC1,FREEL		;FREE CDR.
	POPJ P,
;DMUPG0 DMUPG DMUPG2 DMUPG3 DMUPGE CHASER CHASEM CHASE3 FREEZE RSTFRZ

DMUPG0:	PUSHJ P,FSGIVE			;return FS we got after waiting
	POPJ P,				;dpy hdr changed, don't do display output

;Here from UPGIOT only.
DMUPG:	XCTR XR,[MOVE AC1,(UUO)]	;Get flag word and pointer to program
	TLNE AC1,CHASTE			;Want to flush any previous program of ours?
	PUSHJ P,CHASEM			;Yes, do it first
	PUSH P,PRGNUM(DDB)		;save line number
	PUSHJ P,DDWAIT			;Wait for any previous program(s) to finish
	POP P,AC1			;get back line number
	HRRZ AC1,LETAB(AC1)		;get current dpy hdr
	CAIE AC1,(DDB)			;same dpy hdr?
	POPJ P,				;no, abort uuo, dpy hdr may have gone away
	HLRZ AC1,UCOUNT(DDB)		;See if user flag set from prev prog
	JUMPE AC1,DMUPG2
	HRRZ AC2,UCOUNT(DDB)		;Address of user's flag
	PUSHJ P,DMCLRU			;Flush clock request for DMUCLK, zero UCOUNT
	CAIN AC1,(J)			;Make sure same job--might have CFORKed
	XCTR XW,[SETZM (AC2)]		;Clear user run flag from prev dpy prog
DMUPG2:	XCTR XR,[SKIPGE AC1,(UUO)]	;Skip unless overlapped mode requested
	XCTR XW,[SETZM 2(UUO)]		;Initialize run flag and write check it
	XCTR XR,[SKIPG AC3,1(UUO)]	;LENGTH OF PRGM.
	POPJ P,				;Length 0 means just wait for previous xfer
	SETZM PRGJMP(DDB)		;Clear flag that says waiting for xfer
	ADDI AC1,-1(AC3)
	XCTR XR,[MOVE AC2,(AC1)]	;Address check end of program
	CAIL AC3,NBS*PBSZ		;Is display program too big?
	JRST DMUPGE			;Yes
	PUSH P,PRGNUM(DDB)		;Save line number
	PUSHJ P,FSGET			;Get FS block to hold whole program
	 JFCL				;UUO level--can't lose
	POP P,TEM			;get back line number, may have waited
	HRRZ TEM,LETAB(TEM)		;get current dpy hdr
	CAIE TEM,(DDB)			;same dpy hdr?
	JRST DMUPG0			;no, give back FS, abandon uuo
	XCTR XR,[HRLZ TEM,(UUO)]	;STARTING ADDR. OF PRGM.
	HRR TEM,AC1			;Gonna BLT the program into FS
	HRLI AC1,440700
	PUSH P,AC1
	XCTR XR,[MOVE AC3,1(UUO)]	;Get length again
	ADDI AC1,-1(AC3)		;Final address of BLT
	XCTR XBLTR,[BLT TEM,(AC1)]	;Dpy program into Free Storage
	PUSHJ P,GETQ			;Get DD block for queueing transfer
	SETZM QXY(AC1)			;No assumed X-Y position
	IMULI AC3,5			;Number of chars
	MOVEM AC3,QDMCNT(AC1)
	POP P,QTAKR(AC1)		;Byte pointer for ch 5 unpacking text
	XCTR XR,[HLRZ TAC,(UUO)]	;Get user flags
	TRNE TAC,400000			;Overlapped mode?
	XCTR XW,[AOSA 2(UUO)]		;Yes, count a transfer running
	TDZA AC2,AC2			;No
	MOVEI AC2,2(UUO)
	MOVEM AC2,QPUTR(AC1)		;Address of user's run flag, if any
	HRRZ AC2,QTAKR(AC1)
	HRLI AC2,DMUDUN			;Routine to call when xfer done--returns FS
	TRNE TAC,DMATXY			;Want to flush wholine after xfer?
	HRLI AC2,DMUWHO			;Yes
	MOVEM AC2,QFREE(AC1)		;Address of FS block to return later
	TRNN TAC,DMXLE			;User want to suppress LE during this task?
	JRST DMUPG3			;No
	MOVEI AC2,LEWAIT		;Yes, turn this bit on
	IORM AC2,DMFLAG(DDB)		;Suppress Line Editor starting now
	SKIPA AC3,[JRST USWKLE]		;Restore LE when task done
DMUPG3:	MOVSI AC3,(<CAIA>)		;Normal instruction to XCT when task done
	ANDI TAC,DMUMSK			;Mask of legally set user flags
	IORI TAC,DMXCAL!DMUXFR		;Flag to call routine in QFREE LH when done
	HRL TAC,DDB
	MOVEM TAC,QFLAGS(AC1)		;Dpy header address,,user flags
	MOVEI AC2,PRGCNT(DDB)		;PICK UP ADDRESS OF COUNT FIELD
	MOVEM AC2,QCOUNT(AC1)
	AOS PRGCNT(DDB)			;Set up our wakeup counter
	MOVEM J,QWAKE(AC1)		;Job to wake up
	MOVSM J,QXYLOC(AC1)		;Mark this as our xfer--for easy flushing
	MOVEI AC2,DMUSER-QLINK(DDB)	;Address of header for DM user prog queue
	PUSHJ P,QDM0			;Queue up the xfer (AC3 is instruction)
	MOVEI DAT,(DDB)
	PUSHJ P,STRTDM			;Start DM output
	XCTR XR,[SKIPL (UUO)]		;Overlapped mode?
	JRST DDWAIT			;No--wait for xfer to finish
	POPJ P,				;Yes

DMUPGE:	JSP TAC,UUOMES			;Here from DMUPG above with big length
	ASCIZ /DM-type display program too big, UUO/

;Here from RESET when not calling DPYRST.  Make sure that if we're on a PTY, the
;PTY's owner's DM doesn't still have a DM display program of OURS running on it.
;Make sure also that no clock request for DMUCLK will reference our core image
;via UCOUNT of the owner DM.
↑CHASER:PUSHJ P,PRGF1			;See if there is a display up PTY chain
	 TLNN DDB,DMLIN			;Yes.  If really a DM, fall into CHASEM.
	POPJ P,				;Nope
	HLRZ TAC,UCOUNT(DDB)		;Is there a clock request to clear
	CAIN TAC,(J)			; run flag in our core image?
	SETZM UCOUNT(DDB)		;Yes, flush it before core image disappears
;Here from DMUPG above or from DPYRST (or fell in from CHASER above).
;Flush all of our job's requests from user queue.
CHASEM:	OFFSCN				;Don't let anything change while we think.
IFN FTDDFSBUG,<SCPICK> ; CHECK PI STATUS
	SKIPA TAC,DMUSER(DDB)		;Get pointer to first entry in queue
CHASE3:	POP P,TAC
	ANDI TAC,-1
	CAIN TAC,DMUSER-QLINK(DDB)	;Does this pointer point to header?
	JRST SCNONJ			;Yes, all done
	PUSH P,QLINK(TAC)		;Remember pointer to next queue entry
	MOVE AC1,QFLAGS(TAC)		;Get flag word
	HLRZ AC2,QXYLOC(TAC)		; and owner of request
	CAIN AC2,(J)			;Our job number?
	TRNN AC1,DMXCAL			;One of ours?
	JRST CHASE3			;No
	HRRZ AC1,QFREE(TAC)		;Address of FS block containing user prog
	PUSHJ P,FSGIVE
	SKIPE AC2,QPUTR(TAC)		;Get address of user's run flag, if any
	PUSHJ P,DMUUUO			;Clear user flag if in current core image
	PUSHJ P,DMDEQ			;Dequeue this entry.
	MOVE TAC,DMFLAG(DDB)
	TLZE TAC,USERGO			;Was user running just now, uninterruptibly?
	SETOM DMXY(DDB)			;Yes, who knows where cursor was left!
	MOVEM TAC,DMFLAG(DDB)		;Make sure USERGO is now off
	JRST CHASE3

;UUO TO PREVENT ANY OUTPUT TO DISPLAY EXCEPT BY USER PROGRAM UPGIOT
;CALL:	FREEZE 1,	;TO FREEZE THE QUEUE
;CALL:	FREEZE 0,	;TO UNFREEZE THE QUEUE
;ONLY LOW ORDER BIT OF AC FIELD IS EXAMINED TO DISTINGUISH THESE CASES
;OTHER AC FIELD BITS RESERVED FOR FUTURE USE
↑FREEZE:PUSHJ P,PRGFND		;GET DPY HDR INTO DDB
	 POPJ P,		;NOT A DISPLAY
RSTFRZ:	TLNN DDB,DMLIN		;DMS ONLY
	POPJ P,			;NOT A DM
	MOVEI TAC,NOINTR	;FLAG INDICATING NOTHING GOES OUT BUT USER XFERS
	MOVE TAC1,DMFLAG(DDB)	;SAVE OLD COPY OF BIT
	TRNN UCHN,1		;LOW ORDER BIT OF AC FIELD GIVES OUR NEW VALUE
	ANDCAM TAC,DMFLAG(DDB)	;CLEAR THE BIT
	TRNE UCHN,1
	IORM TAC,DMFLAG(DDB)	;SET BIT PREVENTING ALL BUT USER PROGRAM XFERS
	XOR TAC1,DMFLAG(DDB)	;SEE IF WE CHANGED THE BIT
	TRNN TAC1,NOINTR
	POPJ P,			;DIDN'T CHANGE
	PUSH P,J		;BIT CHANGED, SO NOW WE FLUSH ALL THE QUEUES
	PUSH P,[POPJJ]
	MOVE DAT,DDB		;DPY HDR FOR LEPDM1
	JRST LEPDM1		;FLUSH ALL THE QUEUES NOW
;⊗ DMUWHO DMUDUN DMUCLK DMUCER DMUCL2 DMUUUO DMUUU2

;Here in CH5 when user dpy program has finished or in CH7 from ESC C via USFLUS
;Can't clobber RH TAC or RH J or DAT.
;Enter at DMUDUN normally.  Enter at DMUWHO to also flush wholine queue entries
DMUWHO:	PUSH P,TAC
	MOVEI AC2,DMWHO(J)	;Pointer to wholine queue for this DM
	OFFSCN
	PUSHJ P,DMFLUS		;User program wants wholine flushed
	ONSCN
	PUSHJ P,DMFORC		; but at least force out whole user line next time
	POP P,TAC
DMUDUN:	HRRZ AC1,QFREE(TAC)	;Address of FS block containing user prog
	PUSHJ P,FSGIVE
	SKIPLE AC1,QWAKE(TAC)	;Job number
	SKIPN AC2,QPUTR(TAC)	;Any run flag?
	POPJ P,			;No
	CAIL AC1,JOBN		;Legal job number?
	POPJ P,
	HRL AC2,AC1		;<JOB>,,<RUN FLAG ADDRESS>
	MOVEM AC2,UCOUNT(J)	;Into dpy header for clock routine.
	HRLI J,DMUCLK
	SYSPIFF
	IDPB J,CLKQ
	SYSPIN
	POPJ P,

;Here in CH7 to see if user is in core and clear his run flag if so.
DMUCLK:	HLRZ J,UCOUNT(DAT)	;Get job number from dpy header
	JUMPE J,CPOPJ
	CAIGE J,JOBN		;Reasonable job number?
	JRST DMUCL2
	PUSHJ P,BUGTRP		;No, this isn't supposed to happen
	POPJ P,

DMUCER:	PUSHACS
	PUSH P,PRGNUM(DAT)
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/Job /]
	DISARG DCP,J
	[ASCIZ/ gone at DMUCLK, attempt to clear DM user run flag for TTY/]
	DISARG LOC,<-1(P)>
	-1
	PUSHJ P,DISCRL
	ADJSP P,-1
	DEBCHECK(POPACS)
	SETZM UCOUNT(DAT) 	;Forget about run flag
	POPJ P,

DMUCL2:	MOVE AC1,JBTSTS(J)	;Get job status
	TLNN AC1,JNA		;Any job here now?
	JRST DMUCER		;No!
	TLNE AC1,SWP		;Job in core?
	JRST DPYTIM		;Swapped out, replant clock request
	PUSHJ P,MAPSET		;Set up map to access job's core
	HRRZ AC2,UCOUNT(DAT)	;Address of user's flag
	SETZM UCOUNT(DAT)	;We are about to be done with run flag
	JRST DMUUU2		;finish by clearing user's flag

;Enter here at UUO level from DMUPG or DPYRST, both via CHASEM, to clear user flag.
;Also here in CH7 from ATTACH command (FATT1) doing a DPYRST; in this case, we
;have to avoid referencing user core, since map isn't (necessarily) set up.
DMUUUO:	CONSZ PI,77400		;skip if at UUO level
	POPJ P,			;must be CH7 from ATTACH command (FATT1/DPYRST)
DMUUU2:	HLRZ AC1,JBTPAG(J)	;See if user's flag address is still legal
	LSH AC1,9		;Make number of pages into number of words
	CAMGE AC2,AC1
	XCTR XW,[SETZM (AC2)]	;Clear his flag
	POPJ P,
;QDMPP QDMGLC QDMERS QDM

;QDM is general routine to add an entry at the end of any queue (DM).
;Pointer to header needed in AC2, pointer to new queue entry in AC1.
;QDMPP is routine used by page printer.
;QDMGLC is routine used by DM glitching

QDMPP:	SKIPL LEPOS(DDB)		;Is LE in PP?
	SETOM LETXC(DDB)		;Yes, redraw LE 'cause PP has stepped on it
QDMGLC:	MOVEM UUO,QPUTR(AC1)		;Save ptr to PP in xfer block
	MOVEM DAT,QWAKE(AC1)		;Address of clock req to DPYTYP or DPYERT
	HRRM TAC1,QWAKE(AC1)		;Put in line number
	HRLM DDB,QFLAGS(AC1)		;Dpy header
	MOVEI AC2,PPENQ(UUO)		;Cell to count down when done
	MOVEM AC2,QCOUNT(AC1)
	AOS PPENQ(UUO)			;Count it up now
QDMERS:	MOVEI AC2,DMPPPT-QLINK(DDB)	;Address of queue header
	AOS NPPXFR(DDB)			;COUNT A PP TRANSFER IN PROGRESS
	MOVEI AC3,NPPXFR(DDB)
	TLOA AC3,(<SOSN>)		;PREPARE TO COUNT DOWN PP TRANSFERS
↑QDM:	MOVSI AC3,(<CAIA>)
QDM0:	MOVEM AC3,QINSTR(AC1)		;Enter here from DMUPG, with AC3 set up
	OFFSCN				;Don't let scanner get in and diddle queue
	MOVS AC3,QLINK(AC2)		;Get pointer to end of queue
IFN FTDDFSBUG,<
	SCPICK		 ; CHECK PI STATUS
	TRNE AC3,-1
	TLNN AC3,-1
	JRST QDMERR
	TRNE AC1,-1
	TRNN AC2,-1
	JRST QDMERR
>;FTDDFSBUG
	HRRM AC1,QLINK(AC3)		;Make last entry point forw to new one
	HRL AC3,AC2
	MOVSM AC3,QLINK(AC1)		;Insert forw and back ptrs in new entry
	HRLM AC1,QLINK(AC2)		;Make header point back to new entry
	JRST SCNONJ

IFN FTDDFSBUG,<
QDMERR:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ/DM QUEUES SCREWED UP AT QDM.
LINK TO QUEUE HEADER IN AC2.  POINTER TO ENTRY BEING QUEUED IN AC1.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	SYSPIN
	JRST SCNONJ
>;FTDDFSBUG
;UPSIII UPGRIN UPGIOT T2 PBSZ SIZE PGWC PGSA PGNP UPGRNS L1

;;UPGIOT IS THE DEMOCRATIC UUO WHICH ALLOWS ALL MEN,
;; HOWEVER HUMBLE THEIR STATION (PROVIDED IT IS A DISPLAY),
;; TO RUN THEIR VERY OWN DISPLAY PROGRAMS.

;UPGIOT flags in LH of first word of header (RH points to user program)
IFN FTGRIN,<
UPSIII←←2	;Run this program on III simulator for Grinnell
UPGRIN←←4	;Run this program on Grinnell (simulator for Grinnell)
		;If neither of above bits is on, run on DD simulator (default)
>;IFN FTGRIN

↑UPGIOT:	BEGIN UPG
    ↑↑PBSZ←←CNT       ;DPY INSTRS /BLOCK.
    SIZE←←=17
    PGWC←←0
    PGSA←←1
    PGNP←←2

IFE FTDD!FTGRIN,<
	PUSHJ P,PRGFND
	 POPJ P,		;NOT A DISPLAY
	JRST DMUPG		;RUN DM PROGRAM
>;IFE FTDD!FTGRIN
IFN FTDD!FTGRIN,<	;Rest of page
	PUSHJ P,PGSET		;GET REQUESTED P OF G .
	 POPJ P,		;NO SUCH DPY, LEAVE NOW
IFN FTGRIN,<
	MOVEM J,CURPG(DDB)	; SAVE IT NOW
>;IFN FTGRIN
	TLNE DDB,DMLIN
	JRST DMUPG		;RUN DM PROGRAM
IFE FTGRIN,<
	TLNE DDB,DDDLIN
	JRST DDUPG		;RUN DD PROGRAM (unless simulating Grinnell or III)
>;IFE FTGRIN
IFN FTGRIN,<
	PUSHJ P,DDWAIT		;WAIT FOR PREV XFER, IF ANY
	MOVE J,CURPG(DDB)	;Clobbered by DDWAIT
	XCTR XR,[SKIPGE AC1,(UUO)]	; PICK UP ADDRESS OF USER BUFFER
	XCTR XW,[SETZM 2(UUO)]		; INIT XFER IN PROGRESS FLAG IF USED
	XCTR XR,[SKIPG AC2,1(UUO)]	; PICK UP WORD COUNT OF BUFFER
	JRST UPREL			;THAT WAS EASY
UPGRNS:
>;IFN FTGRIN
;Must be III now (or a Grinnell)
	MOVEM J,CURPG(DDB)
	XCTR XR,[HRLZ TEM,(UUO)]	;STARTING ADDR. OF PRGM.
IFN FTGRIN,<
	XCTR XR,[HLLZ TAC,(UUO)]	; PICK UP FLAGS
	MOVEM TAC,PGFLAG(DDB)		; SAVE FLAGS IN PROGRAM HEADER
	MOVEM UUO,PGUUO(DDB)		; SAVE COPY OF UUO ITSELF
>;IFN FTGRIN
	XCTR XR,[MOVM AC3,1(UUO)]	;LENGTH OF PRGM.
IFN FTGRIN,<
	ADDI AC3,1		; BUMP BY ONE FOR MODE SELECTION
>;IFN FTGRIN
	CAIL AC3,NBS*PBSZ	;IS PIECE OF GLASS GOING TO BE TOO BIG ?
	JRST UPGTB
	HRLZM AC3,UCHN		;SAVE WC IN LEFT OF UCHN, MAKE RIGHT HALF 0 FOR NOW.
	MOVEI TAC,PBSZ-1+PGNP(AC3)
	IDIVI TAC,PBSZ		; FIND OUT HOW MANY BLOCKS THIS PROGRAM WILL CONSUME
	MOVEI DSER,(TAC)	; DSER ← NUMBER OF BLOCKS
	SUB TAC,SIZE(J)		;HOW BIG IS THIS PG NOW ? (J HAS POG ADDR)
	ADD TAC,BLKTOT(DDB)	;THIS IS HOW MUCH IT GROWS.
	JUMPG TAC,UPGER1	;IS USER OVER HIS ALLOTMENT ?
	HRREI TAC,-1(DSER)	;SAVE IT.
	SETZM SIZE(J)		;...SEE FOLLOWING INSTR.
	MOVEI TAC1,DISNOP	;SEE FOLLOWING INSTR...
IFE FTGRIN,<
	JUMPE AC3,UPREL1	;IF WC IS 0, RELEAS PAGE.
>;IFE FTGRIN
IFN FTGRIN,<
	CAIG AC3,1		; IS USER'S WC=0?
	 JRST UPREL1		; YES, RELEASE POG
>;IFN FTGRIN
	MOVEI AC3,NBS+2		; NICE BIG PIECE
	PUSHJ P,UGETF1		;GET BLOCK FOR THE RELOCATION TABLE.
	JUMPL AC1,CPOPJ		;IF WE ARE AT SPACEWAR LEVEL AND NO FREE STG., JUST RETURN.
	MOVEM AC1,UUO
	MOVEI TAC1,0
	TLOA UUO,TAC		;MAKE UUO AN INDEXED POINTER TO REL. TBL.
L1:	MOVEM AC1,TAC1		;SAVE LOC. OF THIS BLOCK.
	PUSHJ P,CGETFS		;GET A BLOCK OF FREE STG.
	JUMPL AC1,FOOFRL	;GO AWAY IF SPACEWAR AND NO FREE STG.
	MOVSM AC1,@UUO		;ENTER IN RELOCATION TABLE.
	MOVEM TAC1,PPLINK(AC1)	;LINK TO PREVIOUS BLOCK.
	SOJGE TAC,L1		;GET REST OF BLOCKS NEEDED.
	MOVEM DSER,SIZE(J)	;UPDATE SIZE OF THIS PG.
	MOVN TAC1,UCHN		;LENGTH OF USERS CODE.
IFN FTGRIN,<
	SUB TEM,[1,,0]		;STARTING ADDR-1 (LEAVE ROOM FOR MODE SELECT)
>;IFN FTGRIN
	HLR TAC1,TEM		;STARTING ADDR.
	HRR UCHN,UUO		;BOTTOM OF RELOCATION TABLE.

>;IFN FTDD!FTGRIN
;LOOP UPCHK UPCHK1 UPGTB SPECOP DONE UPREL UPREL1 UPRERR UWC0

IFN FTDD!FTGRIN,<

	HLRZ DSER,(UUO)
	ADD UCHN,[PGNP,,0]
	HLRZM UCHN,PGWC(DSER)
	HLRZM TEM,PGSA(DSER)
IFN FTGRIN,<
	AOS PGSA(DSER)		; MAKE IT TRUE - FLUSH EXTRA WD FOR MODE SEL
>;IFN FTGRIN
	ADD DSER,[-PBSZ+PGNP,,PGNP]
IFN FTGRIN,<
	MOVE AC1,PGFLAG(DDB)	; PICK UP FLAG WORD
	MOVEI 0,GMSEL		; DO A MODE SELECT
	HLL 0,AC1		; INSERT FLAGS
	PUSHJ P,UPCHK1		; PUT IN FLAG WORD
	  JRST UWC0		; NO MORE WORDS? MONITOR ERROR
	MOVE AC1,PGFLAG(DDB)	; PICK UP FLAG WORD
	MOVEI 0,DISNOP		; Put a NOP in the case we think we're a III
	TLNN AC1,UPSIII		; SIMULATING III? THEN SKIP FIRST WORD
	  JRST LOOP
>;IFN FTGRIN
IFE FTGRIN,<
	SETZ 0,			;11/19/74  ME  DON'T CHECK THE FIRST WORD OF PROG
>;IFE FTGRIN
	PUSHJ P,UPCHK1		; SUBSTITUTE OUR FIRST WORD
	 JRST DONE		; END OF USER PROGRAM?
LOOP:	PUSHJ P,UPCHK		; CHECK USER WORD
	 JRST DONE		; END OF USER PROGRAM
	JRST LOOP		; NOT END - LOOP BACK FOR NEXT

UPCHK:	XCTR XR,[MOVE (TAC1)]	;PICK UP WORD FROM PRGM.
UPCHK1:	TRNN 3			;DOES IT NEED EXAMINING ?
	 PUSHJ P,SPECOP		;YES, IT IS A POTENTIALLY DANGEROUS INSTR.
				; TRNN CATCHES OPS ASCII AND VECTOR
	MOVEM (DSER)		;STORE THE INSTR.
	AOBJP TAC1,CPOPJ	;AT END OF PGM. ?
	AOBJN DSER,CPOPJ1		;NO. END OF BLOCK ?
	MOVE 1(UCHN)		;YES. GET START OF NEXT ONE.
	HRRI DISJMP		;FORM JMP INSTR. TO IT.
	MOVEM (DSER)		;PLACE AT END OF LAST BLOCK.
	ADD [1,,0]		;MAKE JMP GO TO 2ND WORD OF NEW BLOCK..
	MOVEM 1(DSER)		;...IN CASE THERE IS A TSS WHICH SKIPS..
	HLR DSER,1(UCHN)		;GET START OF CURRENT BLOCK.
	HRLI DSER,-PBSZ		;LENGTH OF BLOCK.
	AOJA UCHN,CPOPJ1	;GO FILL NEXT BLOCK.

UPGTB:	ERMS {PIECE OF GLASS TOO BIG.}
	POPJ P,
	
SPECOP:	LDB AC1,[POINT 3,0,33]	;GET OPCODE.
IFE FTGRIN,<
	JRST @SPCTBL(AC1)	;DO APPROPRIATE THING.
>;IFE FTGRIN
IFN FTGRIN,<
	MOVE TAC,PGFLAG(DDB)
	TLNE TAC,UPSIII		; III PROGRAM?
	 JRST @SPCIII(AC1)	; YES
	TLNE TAC,UPGRIN		; GRINNELL PROGRAM?
	 JRST @SPCGRN(AC1)	; YES
	JRST @SPCDD(AC1)	; OTHERWISE IS DD PROGRAM
>;IFN FTGRIN

DONE:
IFE FTGRIN,<
	MOVE TAC1,(UUO)		;START OF BLOCK 0 OF PRGM.
	ADD TAC1,[PGNP,,DISJMP]
>;IFE FTGRIN
IFN FTGRIN,<
	HRLZI TAC1,1(J)		; MAKE IT JUMP TO NEXT POG
	ADDI TAC1,DISJMP
>;IFN FTGRIN
	MOVEM TAC1,1(DSER)	;MAKE END OF PGM JMP BACK TO START.
	MOVEM TAC1,2(DSER)
IFN FTGRIN,<
	MOVE TAC1,(UUO)		;SAVE START OF BLOCK 0 OF PRGM.
>;IFN FTGRIN
	HRRZ AC1,UUO		;NOW RELEASE THE RELOC. TABLE.
	PUSHJ P,FSGIVE
IFE FTGRIN,<
	HRRI TAC1,DISJSR	;JSR TO START OF PGM.
	JRST UPREL1
>;IFE FTGRIN
IFN FTGRIN,<
	ADD TAC1,[PGNP,,DISJMP]	; RELEASE PREVIOUS PROGRAM AND ENTER NEW PROGRAM
	PUSHJ P,UPREL1		; INTO PIECE OF GLASS TABLE (PGCALL)
	MOVE UUO,PGUUO(DDB)	; PICK UP ORIGIONAL UUO AGAIN
	JRST DDSCHN		; QUEUE UP POG XFR
>;IFN FTGRIN

;Release a piece of glass.  DDB points to the LETAB entry and J to the entry
;in the piece of glass table.  If called at UPREL1, TAC1 is what to replace
;the old entry with, usually some kind of jump to a display program.
↑UPREL:	MOVEI TAC1,DISNOP	;FREE A PIECE OF GLASS.
↑UPREL1:HLRZ AC1,PGCALL(DDB)	; III FALLS IN HERE
	SUBI AC1,(J)		;GET NEG POG #
	MOVSI AC2,400000
	LSH AC2,(AC1)		;MAKE PGACT BIT
	TRNE TAC1,20
	IORM AC2,PRGACT(DDB)	;IS JSR - MARK ACTIVE
	TRNN TAC1,20
	ANDCAM AC2,PRGACT(DDB)	;IS NOP - MARK INACTIVE
	EXCH TAC1,(J)		;EXCHANGE FOR OLD ONE.
	HLRZS AC1,TAC1		;GET START OF OLD PRGM.
	JUMPE TAC1,CPOPJ	;RETURN IF NO OLD PRGM.
	SUBI AC1,PGNP		;FREE THE OLD PRGM, AND FIX PRGM TO RESTART AT TOP.
IFN FTGRIN,<
	CAML AC1,SYSTOP		;VALID F.S. BLOCK ADDRESS?
	CAML AC1,FSTOP
	JRST UPRERR		;NO - COMPLAIN
>;IFN FTGRIN
	JRST SETRST

IFN FTGRIN,<
UPRERR:	PUSHACS
	PUSHJ P,DISUSR
	 SIXBIT /UPREL1/
	PUSHJ P,DISERR
	DISARG STR,[ASCIZ /About to release a non-ex piece of glass
/]
	-1
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCALL
	POPJ P,		; PRETEND NOTHING THERE
>;IFN FTGRIN

; MONITOR ERROR - WC WAS REALLY 0

UWC0:	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF MSG ON CTY
	 SIXBIT /UPGIOT/
	PUSHJ P,DISERR
	DISARG STR,[ASCIZ /Dropped out of UPG loop unexpectedly
/]
	-1
	POPACS
	JRST DONE		; PRETEND NOTHING HAS HAPPENED

>;IFN FTDD!FTGRIN	;Whole page
;SPCIII SPCDD SPCGRN GRSLM DDCMD JLINK SPCC1 SPCC2 GSLCHK GSLCH1 SPCJMS SPCILM

; THIS IS THE SPECIAL INSTRUCTION DISPATCH FOR GRINNELLS

IFN FTGRIN,<
;;SPCTBL IS DISPATCH TABLE FOR HANDLING SPECIAL DPY INSTRS.

SPCIII:	JRST JLINK	;0 - HALT
	JRST SPCJMS	;4 - JMS
	JRST SPCILM	;10 - SELECT
	JRST SPCILM	;14 - RST
	JRST ADROP	;20 - JMP
	JRST SPCJMS	;24 - JSR OR SAVE
	JRST GRSLM	;30 - SET MODE (III, DD, OR GRIN)
	JRST SPCILM	;34 - RST (AGAIN.)

SPCDD:	JRST JLINK	;0 - HALT
	JRST DDCMD	;4 - COMMAND WORD
	JRST DDCMD	;10 - COMMAND WORD (BAD FORM)
	JRST DDCMD	;14 - COMMAND WORD
	JRST ADROP	;20 - JMP
	JRST DDCMD	;24 - COMMAND WORD
	JRST GRSLM	;30 - SET MODE (III, DD, OR GRIN)
	JRST DDCMD 	;34 - COMMAND WORD

SPCGRN:	JRST JLINK	;0 - HALT
	JRST SPCC1	;4 - ONE COMMAND
	JRST SPCILM	;10 - CURRENTLY UNINTERPRETED
	JRST SPCC2	;14 - TWO COMMANDS
	JRST ADROP	;20 - JMP
	JRST SPCC1	;24 - ONE COMMAND (AGAIN)
	JRST GRSLM	;30 - SET MODE (III, DD, OR GRIN)
	JRST SPCC2 	;34 - TWO COMMANDS (AGAIN)

GRSLM:	HLLM 0,PGFLAG(DDB)	; SET MODE - STORE FLAGS FOR SPCCHK TO SEE
	POPJ P,

DDCMD:	POPJ P,		; HAVE TO DO SOMETHING HERE

JLINK:	HRLI 0,1(J)	; JUMP TO NEXT POG
	HRRI 0,DISJMP	; LINK POGS TOGETHER THIS WAY
	POPJ P,		; THERE IS A HALT IN THE DPY HEADER AFTER ALL THIS
 
SPCC1:	LDB AC1,[POINT 4,0,3]	; EXTRACT OPCODE
	PUSHJ P,GSLCHK		; CHECK IT
	DPB AC1,[POINT 4,0,3]	; PUT IT BACK EITHER SAME OR NOP
	POPJ P,

SPCC2:	PUSHJ P,SPCC1		; DO SAME FOR FIRST OP
	LDB AC1,[POINT 4,0,19]	; THEN FOR SECOND
	PUSHJ P,GSLCHK
	DPB AC1,[POINT 4,0,19]
	POPJ P,

; THIS ROUTINE CHECKS A GRINNEL OP FOR VALIDITY
; CURRENTLY, WE ONLY CHECK FOR CHANNEL OR SUBCHANNEL MASK

GSLCHK:	CAIE AC1,1
	CAIN AC1,10
	JRST GSLCH1
	POPJ P,

GSLCH1:	MOVE TAC,JOB
	MOVE TAC,JBTPRV(TAC)
	TLNE TAC,UPGPRV			;RETURN QUICK IF HE HAS THE PRIV
	POPJ P,				;HE HAS THE PRIVILEGE
	MOVEI AC1,G.NOP⊗-=12		; MAKE IT INTO A NOP
	POPJ P,

SPCJMS:	PUSHJ P,DPYERR
	ERMS {JSR/JMS/RST NOT LEGAL}
	JRST ILL1

SPCILM:	PUSHJ P,DPYERR
	ERMS {ILLEGAL INSTRUCTION IN GRINNELL PROGRAM}
	JRST ILL1
>;IFN FTGRIN
;SPCTBL SELCHK LOOPS DCHNOK

IFN FTDD,<

;;MORE OF UPG. FOR III

;;SPCTBL IS DISPATCH TABLE FOR HANDLING SPECIAL DPY INSTRS.

SPCTBL:	JRST HLTOP	;HALT
	JRST ILLJMS	;JMS
	JRST SELCHK
	JRST ADRRST	;RST (NO BITS ON -- NOOP) (DCS-5/29/70)
	JRST ADROP	;JMP
	JRST ADROP	;JSR OR SAVE
	JRST SELCHK
	JRST ADROP 	;RST (AGAIN.)

SELCHK:	MOVE TAC,JOB
	MOVE TAC,JBTPRV(TAC)
	TLNE TAC,UPGPRV			;RETURN QUICK IF HE HAS THE PRIV
	POPJ P,				;HE HAS THE PRIVILEGE
	MOVE TAC,[<77770010>⊗DPYNUM]	;DESELECT ANYONE.
	MOVEI AC2,DPYNUM-1		;DPY'S ONLY.
	PUSH P,TAC1
LOOPS:	LSH TAC,-1			;SHIFT MASK.
	SKIPN AC3,TTYTAB+DPYL0(AC2)	;POINTER TO DPY DDB.
	JRST DCHNOK			;SELECT OK!
	MOVE TAC1,DEVMOD(AC3)
	LDB AC3,[POINT JOBNSZ,DEVJBN(AC3),JOBNPS] ;GET # OF JOB THAT HAS THAT DPY.
	TDNE TAC1,[XWD TTYATC,ASSCON!ASSPRG]
	CAMN AC3,JOB			;THIS ONE?
DCHNOK:	TLO TAC,400000			;SELECT BIT.
	SOJGE AC2,LOOPS
	POP P,TAC1
	MOVSI AC2,400000		;GET A BIT.
	MOVN AC3,PRGNUM(DDB)		;TTY NUMBER (DPYL0 TO DPYL0+DPYNUM-1)
	LSH AC2,DPYL0(AC3)
	TDO TAC,AC2			;MAKE SURE HE GETS HIS OWN.
	AND TAC
	POPJ P,

>;IFN FTDD	;Whole page
;ADRRST ADROP ILLAD ILL1 ILLJMS HLTOP UPGER1

IFN FTDD,<

; RST WITH NO PARAM BITS ON IS A NOOP -- ALLOW ANY ARGUMENT
; TO APPEAR UNCHANGED IN THE LEFT HALF

ADRRST:	TRNN 60			;SIZE OR [X,Y] FIELDS ON?  (DCS-5/29/70)
	 POPJ P,		; NO, LEAVE IT ALONE	   (DCS)
>;IFN FTDD

IFN FTDD!FTGRIN,<
;CALL ADROP WITH THE FOLLOWING
;	0/	<ADDRESS TO CHECK>,,<ANYTHING>
;	TEM/	<USER BASE ADDRESS>,,<ANYTHING>
;	UCHN/	<LENGTH OF USER BUFFER>,,<ANYTHING>
;	UUO/	TAC,,<ADDRESS OF RELOCATION TABLE>
;	TAC1/	<ANYTHING>,,<ADDRESS TO TYPE OUT ON ERROR>

ADROP:	SUB TEM			;AN ADDRESSABLE INSTR. UNRELOCATE IT.
	CAML UCHN		;ADDRESS TOO HIGH ?
	JRST ILLAD		;YUP.
	JUMPL 0,ILLAD		;JUMP IF ADDRESS TOO LOW
	ADD 0,[XWD PGNP,0]	; SKIP OVER HEADER WORDS
	HLRE AC1,0		; PICK UP ADDRESS
	IDIVI AC1,PBSZ		; GET # BLOCKS AND DISPLACEMENT INTO LAST BLOCK
	HRL 0,AC2		; USE DISPLACEMENT INTO BLOCK PLUS ADDRESS OF BLOCK
	MOVE TAC,AC1
	ADD @UUO		;ADD IN RIGHT RELOCATION.
	JUMPGE AC1,CPOPJ	;WAS ADDRESS TOO SMALL ?
ILLAD:	PUSHJ P,DPYERR		;ILLEGAL ADDRESS IN DPY INSTR.
	ERMS {ILLEGAL INSTR. ADDRESS.}
ILL1:	MOVEI DISNOP		;REPLACE OFFENDING INSTR. WITH NOP.
	POPJ P,

IFE FTGRIN,<
ILLJMS:	PUSHJ P,DPYERR
	ERMS {JMS NOT LEGAL; USE JSR.}
	JRST ILL1

HLTOP:	MOVE (UUO)		;REPLACE HLT WITH RETURN JMP.
	ADD [XWD PGNP,DISJMP]
	POPJ P,
>; IFE FTGRIN

UPGER1:	ERMS {TOTAL DPY BUFFER SPACE EXCEEDED.}
	POPJ P,

>;IFN FTDD!FTGRIN	;Whole page
;DDUPG DDCWL DDCINC DDUIII DDGRIN

IFN FTDD!FTGRIN,<	;FIRST FEW LINES, THEN FTDD REST OF PAGE

; DATA DISC PROGRAM HANDLER
; SENDS THE PROGRAM DIRECTLY OUT OF LOSER CORE IN EXEC MODE

;EXTENDED FEATURES:
;BIT 0 OF HEADER WD 0 means OVERLAPPED XFER (RETURNS WITHOUT WAITING)
; IN THIS MODE HEADER WD 2 ≠ 0 means XFER GOING.
; DPYOUT ALWAYS WAITS FOR PREV XFER, SO DPYOUT WITH WC=0 WILL
; WAIT FOR BUFFER TO BE AVAIL.
;BIT 1 OF HEADER WD 0 means DOUBLE FIELD MODE, WHICH DOES XFER
; TWICE - ONCE ON EACH FIELD. HEADER WD 3 SHOULD POINT TO WORD
; OF BUFFER CONTAINING (ONLY) LOW-ORDER LINE ADDRESS SELECT
; AS 3RD COMMAND BYTE. THIS BYTE WILL BE ADJUSTED TO APPROP
; FIELD ON EACH XFER.

;Here from UPGIOT on a DD or from DDUPG UUO directly.
DDUPG:	SKIPE DDOFF		; DO WE HAVE A DATA DISC TODAY
	POPJ P,			; NO, SPEAK NO EVIL!
>;IFN FTDD!FTGRIN
	PUSH P,PRGNUM(DDB)	;save line number (of -1 if "detached" hdr)
	PUSHJ P,DDWAIT		;WAIT FOR PREV XFER, IF ANY
	POP P,AC1		;get back line number
	CAMN AC1,[-1]		;if detached hdr, can't have gone away
	JRST DDUPG2
	HRRZ AC1,LETAB(AC1)	;get current dpy hdr
	CAIE AC1,(DDB)		;same dpy hdr?
	POPJ P,			;nope, abort uuo now, dpy hdr may have gone away
DDUPG2:	XCTR XR,[SKIPGE AC1,(UUO)]	; PICK UP ADDRESS OF USER BUFFER
	XCTR XW,[SETZM 2(UUO)]		; INIT XFER IN PROGRESS FLAG IF USED
	XCTR XR,[SKIPG AC2,1(UUO)]	; PICK UP WORD COUNT OF BUFFER
	  POPJ P,			;THAT WAS EASY
IFN FTGRIN,<
	PUSHJ P,PGSET		;GET REQUESTED P OF G .
	  POPJ P,		;NO SUCH DPY, LEAVE NOW
	JRST UPGRNS		; GO BREAK UP PROGRAM INTO BLOCKS
>;IFN FTGRIN
IFN FTDD,<
	ADDI AC2,-1(AC1)	; MAKE POINTER TO LAST WORD
	XCTR XR,[SKIPE (AC2)]	;DON'T CLOBBER IF OK (MIGHT BE UPPER)
	XCTR XW,[SETZM (AC2)]	; PUT A HALT THERE AT THE END OF THE BUFFER
	MOVEI AC3,10		; WE WILL LOOK IN THIS FAR FOR A CHANNEL SELECT
DDCWL:	XCTR XR,[MOVE AC2,(AC1)]; PICK UP WORD OF PROGRAM
	LDB TAC,[POINT 3,AC2,35]
	CAIN TAC,4		; IS IT A COMMAND WORD?
	JRST CHKAD		; YES, SEE IF IT HAS A CHANNEL SELECT IN IT
DDCINC:	ADDI AC1,1		; BUMP POINTER INTO USER CORE
	SOJG AC3,DDCWL		; BUMP COUNT OF DEPTH AND LOOP BACK
	HLRZ TAC,PRGNUM(DDB)	; NO CHANNEL SELECT, SEE IF WE CAN SEND TO HIS OWN SCREEN
	TRNN TAC,DISLIN!DMLIN
	JRST DDSCHN		; ON DD, OK, USE HIS MAIN CHANNEL
	JRST ILLCHN		; SORRY, YOU ARE NOT ON A DD

>;IFN FTDD
;DDWAIT APRONJ UPGQ

↑↑DDWAIT:
IFN FTGRIN,<
	MOVE J,JOB		; CLOBBERED BY PGSET
>;IFN FTGRIN
	SKIPN PRGCNT(DDB)
	POPJ P,			;NOTHING GOING ON
	MOVEI AC3,400000
	MOVE AC1,PRGNUM(DDB)	;GET DISPLAY TYPE BIT
	TLNE AC1,DMLIN
	JRST DMWAT		;must disable different PI channel for DM output
	MOVNI AC2,DIOWQ		;QUEUE IF DISPLAY IS DATA DISC
IFE FTGRIN,<
	CONO PI,APROFF		;don't let the output finish right after test
>;IFE FTGRIN
IFN FTGRIN,<
	CONO PI,GRNOFF
>;IFN FTGRIN
	SKIPN PRGCNT(DDB)
	JRST APRONJ		;MUST HAVE JUST FINISHED
	MOVEM AC2,JOBQUE(J)
	IORM AC3,PRGJMP(DDB)	;TELL PI ROUTINES TO WAKE US
IFE FTGRIN,<
	CONO PI,APRON
>;IFE FTGRIN
IFN FTGRIN,<
	CONO PI,GRNON
>;IFN FTGRIN
DMWAT2:	SKIPGE JBTLIN(J)
	JRST WSCHED		;AVOID RETESTING IF DETACHED (HEADER WILL GO AWAY)
	PUSHJ P,WSCHED		;WAIT FOR IT
	JRST DDWAIT		;THEN CHECK AGAIN TO BE SURE

DMWAT:	MOVNI AC2,IOWQ		;FOR DM, ALLOW IT TO BE SWAPPED OUT
	OFFSCN			;don't let output finished right after test
	SKIPN PRGCNT(DDB)
	JRST SCNONJ		;MUST HAVE JUST FINISHED
	MOVEM AC2,JOBQUE(J)
	IORM AC3,PRGJMP(DDB)	;TELL PI ROUTINES TO WAKE US
	ONSCN
	JRST DMWAT2

APRONJ:
IFE FTGRIN,<
	CONO PI,APRON
>;IFE FTGRIN
IFN FTGRIN,<
	CONO PI,GRNON
>;IFN FTGRIN
	POPJ P,

IFN FTDD!FTGRINN,<	; REST OF PAGE

UPGQ:	HRLM DDB,(AC1)			;LOAD UP TASK BLOCK WITH PROGRAM HEADER
	MOVEI AC2,POG			;DISPATCH TO USER PROGRAM SERVICE
	HRRM AC2,(AC1)
	MOVEI AC2,PRGCNT(DDB)		;PICK UP ADDRESS OF FAKE COUNT FIELD
	MOVEM AC2,QCOUNT(AC1)
	MOVEM TAC,QHPOS(AC1)		;STORE LINE SEL ADDR,,RUN FLAG ADDR
	TRNE TAC,-1
	XCTR XRW,[AOS (TAC)]		;COUNT USER'S FLAG - A TRANSFER IS RUNNING
	AOS PRGCNT(DDB)			;AND FOR US
IFN FTGRIN,<
	MOVE J,JOB			; NOT SET UP IN GRINNELL SYSTEM
>;IFN FTGRIN
	MOVEM J,QWAKE(AC1)
	MOVE AC2,[1,,50]		;ACT LIKE IT WILL TAKE ENTIRE SCREEN
	MOVEM AC2,QLINE(AC1)
IFN FTDD,<
	AOS JBTGLU(J)			;LOCK US IN CORE.
IFN FTSTAT,<PUSHJ P,GLUSTT>
>;IFN FTDD
	PUSHJ P,QBLK			;DON'T OPTIMIZE!!!!!
	POPJ P,

>;IFN FTDD!FTGRIN
;DDSCHN

IFN FTDD!FTGRIN,<	; WHOLE PAGE

; HERE WE ARE, READY TO SET THE CHANNEL ADDRESS OF HIS DATA DISC PROGRAM

DDSCHN:
IFN FTDD,<
	MOVE AC1,[CW 1,47,3,1,2,0]
	DPB TAC,[POINT 8,AC1,23]
	MOVEM AC1,PRGCW(DDB)		;PUT IN COMMAND WORD WITH CHANNEL SELECT
	XCTR XR,[MOVE AC2,(UUO)]	;ADDRESS OF THE USER'S DPY PROGRAM
	PUSHJ P,CHKADR			;ADDRESS CHECK
IFN FTDDDM,<
	XCTR XR,[MOVE AC2,(UUO)]	;CHKADR CLOBBERS AC2
>;IFN FTDDDM
	HRLI AC2,DISJMP
	MOVSM AC2,PRGJMP(DDB)		;PUT IN JUMP TO USER'S PROGRAM
>;IFN FTDD
	MOVEI TAC,0
	XCTR XR,[SKIPL (UUO)]		;OVERLAPPED MODE?
	JRST UPGQ0			;NO
	XCTR XRW,[MOVES 2(UUO)]		;BE SURE WE CAN WRITE HERE
	MOVEI TAC,2(UUO)		;TAC←RELATIVE ADDRESS OF THE "RUN" FLAG
UPGQ0:	PUSHJ P,GETQ
IFN FTDD,<
	XCTR XR,[MOVE AC3,(UUO)]
	TLNN AC3,200000			;DOUBLE FIELD MODE?
	JRST UPGQ1			;NO
	XCTR XR,[HRRZ AC2,3(UUO)]	;ADR OF WORD WITH LINE SELECT
	XCTR XRW,[MOVES (AC2)]		;CHECK WRT ACCESS HERE
>;IFN FTDD
UPGQ1:
	NOCACHE (CSHDD)

;THIS DIDN'T WORK BECAUSE, WHEN THE DPY PROGRAM IS RUN IN "TWO FIELD" MODE, THE
;SYSTEM COMES AROUND TO COMPLEMENT THE LOW ORDER LINE SELECT BIT, AND CHANGES IT
;IN THE CACHE, BUT NOT IN CORE!

;	MTRON (MTRSWP)
;	CONSZ KLPAG,600000		;SKIP IF CACHE IS OFF
;	BLKO CCA,			;CACHE IS ON.  VALIDATE CORE
;	CONSZ APR,SWEEPB		;WAIT FOR SWEEP BUSY TO FALL.
;	JRST .-1
;	MTROFF (MTRSWP)

IFE FTGRIN,<
	TLNN AC3,200000			;DOUBLE FIELD MODE?
	JRST UPGQ2			;NO.
	HRLI TAC,(AC2)			;RELATIVE ADDR OF THE LINE SELECT WORD
	PUSH P,AC1
	PUSHJ P,GETQ			;WILL NEED 2 Q BLKS
	SETOM QFIELD(AC1)
	PUSHJ P,UPGQ
	POP P,AC1
>;IFE FTGRIN
UPGQ2:	SETZM QFIELD(AC1)
	PUSHJ P,UPGQ
	XCTR XR,[SKIPL (UUO)]		;OVERLAPPED?
	JRST DDWAIT			;NO - WAIT
	POPJ P,				;YES - RETURN

>;IFN FTDD!FTGRIN
;CHKAD CHKAC1 CHKAC2 CHKAC3 CHKAC4 CHKADR

IFN FTDD,< 	;This whole page under IFN FTDD

; GET HERE TO LOOK AT A USER'S COMMAND WORD AND SEE IF THERE IS A CHANNEL SELECT
CHKAD:	LDB TAC,[POINT 3,AC2,26]
	CAIN TAC,2		;IS IT A CHANNEL SELECT?
	JRST CHKAC1		;YES, SEE IF IT IS LEGAL.
	LDB TAC,[POINT 3,AC2,29]
	CAIN TAC,2
	JRST CHKAC2
	LDB TAC,[POINT 3,AC2,32]
	CAIN TAC,2
	JRST CHKAC3
	JRST DDCINC

CHKAC1:	LDB TAC,[POINT 8,AC2,7]
CHKAC4:	PUSHJ P,CHAD
	JRST DDSCHN

CHKAC2:	LDB TAC,[POINT 8,AC2,15]
	JRST CHKAC4

CHKAC3:	LDB TAC,[POINT 8,AC2,23]
	JRST CHKAC4

CHKADR:	HLRZ AC3,JBTPAG(J)	;CHECK USER ADR
	LSH AC3,9
	CAIG AC3,(AC2)
	JRST CHKADU		;PAST LOWER - TRY UPPER
IFE FTDDDM,<
	HRRZ AC3,JBTPAG(J)
CHKADX:	LSH AC3,9
	ADD AC2,AC3
IFN FTHPSG,<
	TLNE AC2,17		;CHECK TO MAKE SURE ADDRESS IS LOW ENOUGH.
	JRST UUOERR
>;IFN FTHPSG
>;IFE FTDDDM
	POPJ P,

CHKADU:	TRZN AC2,400000		;SKIP IF UPPER SEGMENT ADDRESS.
	JRST UUOERR		;CAN'T BE UPPER
	TRZE AC3,400000		;SKIP UNLESS LOWER LARGER THAN 128K
	SUBI AC2,1(AC3)		;SUBTRACT LOWER'S SIZE
	LDB AC3,PSEGN
	JUMPE AC3,UUOERR	;NO UPPER
	HLRZ AC3,JBTPAG(AC3)
	LSH AC3,9
	CAIG AC3,(AC2)
	JRST UUOERR		;TOO BIG
IFE FTDDDM,<
	LDB AC3,PSEGN
	HRRZ AC3,JBTPAG(AC3)
	JRST CHKADX
>;IFE FTDDDM
IFN FTDDDM,<
	POPJ P,
>;IFN FTDDDM
;CHAD MYCHN ILLCHN

;This whole page under IFN FTDD

;CHANNEL ADDRESS CHECKING. HE CAN WRITE ON HIS OWN SCREEN,
;OR ON ANY CHANNEL HE OWNS, OR ON ANY FREE CHANNEL.

CHAD:	JUMPE TAC,MYCHN		;GIVE HIM HIS OWN FOR 0
	ANDI TAC,37
	MOVEI AC1,(TAC)
IFE FTF2,<
	PUSHJ P,DDCHEK		;SEE WHO OWNS THIS CHANNEL (AC1)
	 POPJ P,		;FREE CHANNEL
	 CAIA			;SOMEONE ELSE'S CHANNEL
	POPJ P,			;HE OWNS IT
>;IFE FTF2
IFN FTF2,<
PRINTX DDUPG simulating DD programs and checking write access are not finished.
>;IFN FTF2
	MOVE AC1,JBTPRV(J)
	MOVE AC2,DDTAB(TAC)
	TLNN AC2,DDANYW		;MAYBE OWNER SAYS IT'S OK
	TLNE AC1,UPGPRV
	POPJ P,			;HE CAN WRITE ANYWHERE WITH THE PRIVILEGE
MYCHN:	HLRZ TAC,PRGNUM(DDB)	;GIVE HIM HIS OWN CHANNEL (IF ANY)
	TRNN TAC,DISLIN!DMLIN	;IS HE ON A DD?
	POPJ P,			;YES, OK
	SUB P,[1,,1]		;FLUSH RETURN FROM CHAD
ILLCHN:	MOVEI AC1,(DDB)
	SKIPE DPRLSF(DDB)
	PUSHJ P,FSGIVE		;MAKE SURE THE PHONY HEADER GETS RETURNED
	PUSHJ P,TTYFUW
	PUSHJ P,INLMES
	ASCIZ /ILLEGAL DD CHANNEL.
/
	JRST TYPGO

>;IFN FTDD	;Last of several whole pages
;PGSET PGSETA PGSET1 PGSET2 PGSL1

IFN FTDD!FTGRIN,<	;Whole page

;;PGSET  SETS UP REQUESTED PIECE OF GLASS.
; RETURNS POINTER TO DPY HEADER AND DISPLAY TYPE BITS IN DDB
; RETURNS POINTER TO PROGRAM CALL IN J
;  (= DISNOP OR DISJMP IN PRG HEADER TO POG IN UCHN)

↑PGSET:	PUSHJ P,PRGFND		;FIND USER'S DPY PGM. - PUT PTR & BITS IN DDB
	 POPJ P,		;NO DISPLAY HERE
IFN FTGRIN,<
	TLNE DDB,DMLIN
	 JRST CPOPJ1
>;IFN FTGRIN
IFE FTGRIN,<
	JUMPGE DDB,CPOPJ1	;JUMP UNLESS III
>;IFE FTGRIN
PGSETA:
	HLRZ J,PGCALL(DDB)	;PTR. TO PG HEADER.
	JUMPE J,PGSET1		;IF NONE, START FROM SCRATCH.
	CAMLE UCHN,LSTPG(DDB)	;DOES THIS PG ALREADY "EXIST" ?
	JRST PGSET2		;NO. GO EXTEND THE HEADER.
	ADDI J,(UCHN)		;YES. MAKE J POINT AT
	JRST CPOPJ1		;THE CALLING INSTR. FOR IT.

PGSET1:	PUSHJ P,CGETFS		;GET BLOCK TO USE FOR PG HEADER.
	JUMPL AC1,CPOPJ		;  WE COULDN'T GET ONE AT SPACEWAR LEVEL
	MOVEM AC1,J
	SETOM LSTPG(DDB)	;NO PG'S EXIST YET.
	HRLI TAC1,PGCALL+1(DDB)	;INVENT RETURN JMP TO PGM HEADER.
	HRRI TAC1,DISJMP
	MOVEM TAC1,(J)		;PUT IN FIRST WORD OF PG HEADER.
	HRLI J,DISJMP
	MOVSM J,PGCALL(DDB)	;FIX CALL ON PG HEADER.
PGSET2:	MOVEI TAC1,DISNOP	;EXTEND ACTIVE PART OF PG HEADER.
	ADD J,LSTPG(DDB)	;GET LAST CURRENT PAGE.
	MOVE AC2,UCHN
	EXCH AC2,LSTPG(DDB)
	SUB AC2,LSTPG(DDB)	;NO. OF PLACES TO EXTEND.
	HRLI J,(AC2)		;MAKE AOBJN WORD.
	MOVE AC2,1(J)		;GET RETURN JMP.
PGSL1:	MOVEM AC2,2(J)		;PUT RTN JMP FARTHER UP.
	MOVEM TAC1,1(J)		;PUT NOP WHERE IT USED TO BE.
	SETZM SIZE+1(J)		;THIS PG IS NOW 0 SIZE.
	AOBJN J,PGSL1
	JRST CPOPJ1

>;IFN FTDD!FTGRIN	;Whole page
;DPYERR DPYER1

IFN FTDD!FTGRIN,<	;Whole page

; THIS IS THE DPY ERROR ROUTINE. IT TYPES OUT THE PC IN TAC1 ON
; THE DISPLAY.

DPYERR:	PUSH P,DAT
	PUSH P,TEM
	PUSH P,TAC1
	JSA J,ERRP		;DO THIS SO NO TERMINATING CRLF
	POINT 7,[ASCIZ/$$ USER DPY ERROR AT /]
	HRR AC1,(P)		;GET ADDRESS WHERE ERROR OCCURRED
	MOVEI AC2,6
DPYER1:	HRRZS AC1
	LSH AC1,3		;GET ONE OCTAL DIGIT.
	TLO AC1,60
	LDB CHR,[POINT 7,AC1,17]
	PUSH P,AC1		; SAVE ALL OUR RELEVANT DATA
	PUSH P,AC2
	MOVE DAT,CURPP(DDB)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	HLL DAT,DDB		; PUT IN BIT INDICATING TYPE OF DISPLAY
; N.B. - THIS IS A BUG. IF DTYO HAS TO EXTEND THE BUFFER, IT WILL HAVE
; TO CLAIM FREE STORAGE. IF THE SPARE LIST IS EXHAUSTED, IT WILL HAVE TO
; WAIT. IT CAN'T WAIT WITH SCANNER OFF . . . QED. PRESUMABLY THERE ARE
; ENOUGH SPARES AROUND TO PREVENT THAT . . .
	OFFSCN			;TURN OFF SCANNER CHANNEL
	PUSHJ P,DTYO		;PRINT A DIGIT
	ONSCN			;TURN ON SCANNER CHANNEL
	POP P,AC2
	POP P,AC1
	SOJG AC2,DPYER1
	ERMS {}
	POP P,TAC1
	POP P,TEM
	POP P,DAT
	POPJ P,

>;IFN FTDD!FTGRIN	;Whole page
;UPGMVM UPGMOV UPGMV

IFN FTDD!FTGRIN,<	;Whole page
IFN FTGRIN,<
PRINTX UPGMVM and friends must queue up xfr
>;IFN FTGRIN

↑↑UPGMVM:PUSHJ P,UPGMV		;DO 'MOVEM' INTO P OF G: TAKE CARE OF PRELIMINARIES.
	POPJ P,			;IGNORE IF NO CAN DO
	TRNN 3			;IF THING BEING STORED IS A COMPLICATED DPY INSTR.,
	PUSHJ P,SPECOP		; THEN CHECK AND RELOCATE IT.
	MOVSS DAT		;GET RELOCATED ADDRESS OF THE UPGMVM.
	MOVEM (DAT)		;DO THE STORE.
	POPJ P,

↑↑UPGMOV:PUSH P,UCHN		;DO A 'MOVE' FROM THE CURRENT P OF G.
	PUSHJ P,UPGMV		;LET SOMEBODY ELSE DO THE REAL WORK !
	TDZA DAT,DAT		;RETURN 0 IF NO CAN DO
	JRA DAT,.+1		;HO, HO, HO.  SEE THE CLEVER PROGRAMMER.
	POP P,UCHN		; P1ULOC DOESN'T HAVE OUR UUO ANY MORE, MUST SAVE CHANNEL NUMBER OURSELVES
	XCTR XW,[MOVEM DAT,(UCHN)]	;PUT RESULT IN USER'S AC.
	POPJ P,

UPGMV:	PUSHJ P,PRGFND		;COMMON ROUTINE FOR UPGMOV AND UPGMVM. FIND PRGM.
	 POPJ P,		;NO DPY, NO MOVY
	JUMPGE DDB,CPOPJ	;NO III, NO NOTHING
	SKIPE J,CURPG(DDB)	;GET CURRENTLY SELECTED P OF G.
	SKIPN SIZE(J)		;MAKE SURE IT EXISTS.
	POPJ P,
	XCTR XR,[MOVE DAT,(UCHN)]	;PICK UP CONTENTS OF USER'S AC.
	MOVS DSER,(J)		;GET PTR. TO THE P OF G.
	SUBI DSER,PGNP		;MAKE IT POINT TO THE DESCRIPTOR WORDS.
	HRLZ TEM,PGSA(DSER)	;STARTING ADDR. (IN USER CORE) OF P OF G.
	HRLZ UCHN,PGWC(DSER)	;LENGTH OF P OF G.
	HRLZ UUO		;ADDRESS OF THE 'MOVE' OR 'MOVEM'.
	MOVE UUO,[XWD TAC,TBL]	;PREPARE TO GENERATE A BLOCK MAP FOR
	HRLZM DSER,(UUO)		;THE P OF G. (PUT IN BOTTOM PTR.).
	SKIPE DSER,PPLINK(DSER)	;GET NEXT BLOCK, IF ANY.
	AOJA UUO,.-2		;PUT IT IN MAP.
	HRRI UUO,TBL		;MAKE UUO POINT TO MAP.
	HLRZ TAC1,0		;PRINT THIS ADDRESS IN EVENT OF ERROR!
	PUSHJ P,ADROP		;NOW RELOCATE AND CHECK ADDR. OF MOVE.
	EXCH DAT,0		;PUT OPERAND (IF 'MOVEM') INTO 0.
	JRST CPOPJ1

>;IFN FTDD!FTGRIN	;Whole page
;PGIOT PGMAX PGSEL VPGACT PGACT PGACL PGAC1

↑↑PGIOT:
IFE FTDD!FTGRIN,<
;The UUO names below are defined so they can be assembled, even when no-ops.
PGSEL::PGACT::PGCLR::DDUPG::PGINFO::	;Make these defined for UUO table.
	POPJ P,			;No-op for now, especially for PGACT 0
>;IFE FTDD!FTGRIN
IFN FTDD!FTGRIN,<
	CAIL UCHN,PGMAX		;GENERAL P OF G SERVICE IOT.
	JRST UUOERR
	PUSHJ P,DDFND		;FIND A PROGRAM HEADER (UCHN =3 GUARANTEES ONE)
	 POPJ P,		;IGNORE IF NO DISPLAY
IFE FTF2,<	;On F2, Grinells will use these III routines.
	JUMPL DDB,@PGDSP(UCHN)	;IF III, DISPATCH NOW
	CAIGE UCHN,3		;ONLY ONES LEGAL FOR DD CURRENTLY
	POPJ P,			;ALL THE OTHERS DON'T MAKE SENSE.
>;IFE FTF2
	JRST @PGDSP(UCHN)
>;IFN FTDD!FTGRIN

DEFINE UUOS{FOR X IN(PGSEL,PGACT,PGCLR,DDUPG,PGINFO)}

PSHSYS
LOSYS

UUOMAC PGDSP,PGIOT
PGMAX←←UUOCNT

POPSYS

IFN FTDD!FTGRIN,<
PGSEL:	HRRZ UCHN,UUO		;SELECT THE P OF G INDICATED BY THE ADDR. FIELD.
	CAIL UCHN,20		;IS IT LEGAL ?
	JRST UADERR
	PUSHJ P,PGSETA		;FIND THE P OF G.
	 POPJ P,		;SHOULD NEVER GET HERE, BUT PGSETA SKIP RETURNS
	MOVEM J,CURPG(DDB)	;MAKE IT THE CURRENTLY SELECTED ONE.
	POPJ P,

↑↑VPGACT:MOVEI DDB,(DAT)	;HERE ON CLK RQ FROM VDSTR
	HLRZ UUO,PRGACT(DDB)	;THIS MAKES THE PROGRAM AGREE WITH THE BITS
PGACT:	HLRZ J,PGCALL(DDB)
	JUMPE J,CPOPJ
	HRLM UUO,PRGACT(DDB)
	MOVE TAC,LSTPG(DDB)
	MOVEI AC1,DISNOP
	MOVEI AC2,DISJSR
PGACL:	SKIPN SIZE(J)
	JRST PGAC1
	HRRM AC1,(J)
	TRNE UUO,400000
	HRRM AC2,(J)
PGAC1:	ROT UUO,1
	SOJL TAC,CPOPJ
	AOJA J,PGACL
>;IFN FTDD!FTGRIN
;PGCLR PGCLR1 PGINFO PGCLP PGSZ PGCNT PGXLP

IFN FTDD!FTGRIN,<	;Whole page, except BEND

;;PGCLR FLUSHES ANY PIECES OF GLASS A LOSER MAY HAVE.  DDB SHOULD BE SET UP POINTING TO PRGM HEADER.
↑PGCLR:	SETZM CURPG(DDB)
	HLRZ J,PGCALL(DDB)	;GET PTR. TO PG HEADER BLK.
	JUMPE J,CPOPJ		;IF NONE, GO AWAY.
PGCLR1:	PUSHJ P,UPREL		;FREE A PIECE OF GLASS. (SEE ABOVE.)
	SOSL LSTPG(DDB)		;HAVE WE GOT ALL THE PG'S ?
	AOJA J,PGCLR1		;NO. GET SOME MORE.
	MOVEI UCHN,DISNOP	;TURN OFF CALL ON THE PG HEADER.
	EXCH UCHN,PGCALL(DDB)
	HLRZ AC1,UCHN		;PTR. TO HEADER.
	JRST CGIVFS		;FREE THE PG HEADER BLOCK.

; PGINFO UUO GETS INFORMATION FROM THE SYSTEM ABOUT THE USER'S PIECES
; OF GLASS. IT IS GIVEN IN A 17. WORD TABLE. THE FIRST WORD IS
; XWD <POG ACTIVE BITS>,<PP ACTIVE BITS> IN PPACT AND PGACT FORMAT.
; THE NEXT 16. WORDS, ONE WORD FOR EACH POG, IS XWD <WORD COUNT>,<STARTING ADDRESS>

PGINFO:	MOVE AC1,PRGACT(DDB)	; PICK UP THE ACTIVATION BITS
	XCTR XW,[MOVEM AC1,(UUO)]
	ADDI UUO,1
	HLRZ AC1,PGCALL(DDB)	; PICK UP ADDRESS OF UPG CONTROL BLOCK
	SETZ AC3,
	JUMPE AC1,PGXLP		; JUMP IF NO POGs IN USE -- ME 5/26/75
PGCLP:	HLRZ CHR,(AC1)		; PICK UP ADDRESS OF FIRST BLOCK OF CODE
	JUMPE CHR,PGSZ		; IF NOTHING THERE, CLEAR WORD IN TABLE
	HRRZ AC2,PGSA-PGNP(CHR)	; PICK UP THE STARTING ADDRESS
	HRL AC2,PGWC-PGNP(CHR)	; AND THE WORD COUNT
	XCTR XW,[MOVEM AC2,(UUO)]
	JRST PGCNT

PGSZ:	XCTR XW,[SETZM (UUO)]
PGCNT:	ADDI UUO,1		; BUMP POINTER INTO USER'S TABLE
	ADDI AC3,1		; AND COUNT OF NUMBER OF POGS SEEN
	CAMG AC3,LSTPG(DDB)	; ARE WE PAST THE LAST?
	AOJA AC1,PGCLP		; NO, LOOP BACK
PGXLP:	CAILE AC3,17		; ARE WE DONE?
	POPJ P,			; YES, LEAVE
	XCTR XW,[SETZM (UUO)]
	ADDI AC3,1		; AND COUNT
	AOJA UUO,PGXLP		; BUMP POINTER AND LOOP

>;IFN FTDD!FTGRIN	;Whole page

BEND UPG
;DPYTY1 DPYERT DPYTYP DPYTY4 DPYTY5 DPYTY2 DPYTY6 DPYTY3

;;DPYTYP IS CALLED AT CLOCK LEVEL TO TYPE SOME CHRS. FROM A 
;; TTY OUTPUT BUFFER ONTO A DISPLAY.  DAT CONTAINS LINE NUMBER.

DPYTY1:	MOVSI TAC1,DISLIN!DDDLIN!DMLIN
	TRNN DAT,-1⊗PUNITS	; LEGAL LINE NUMBER?
	TDNN TAC1,LINTAB(DAT)	; YES, BUT IS IT A DISPLAY?
	JRST DPYTER		; NO, GIVE ERROR MESSAGE
	SKIPN DDB,TTYTAB(DAT)	; PICK UP DEVICE DATA BLOCK ADDRESS
	POPJ P,			; IF NONE, LEAVE NOW, NO CHARACTERS TO TYPE
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
↑DPYERT:
	HRRI DAT,TTIBUF(DDB)	; PICK UP INPUT BUFFER ADDRESS
	HRLI DAT,DPYTY1		; MAKE US COME BACK TO THIS ROUTINE IF WE HAVE TO WAIT
	JRST DPYTY4

↑DPYTYP: HGMAC(34)
	MOVSI TAC1,DISLIN!DDDLIN!DMLIN
	TRNN DAT,-1⊗PUNITS	; LEGAL LINE NUMBER?
	TDNN TAC1,LINTAB(DAT)	; YES, BUT IS IT A DISPLAY?
	JRST DPYTER		; NO, GIVE ERROR MESSAGE
	HRLI DAT,DPYTYP		; COME BACK TO HERE IF WE HAVE TO WAIT
	SKIPN DDB,TTYTAB(DAT)	; IS THERE A DDB THERE?
	POPJ P,			; NO, NOT MUCH TO DO NOW!
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
	HRRI DAT,TTOBUF(DDB)	; PICK UP OUTPUT BUFFER ADDRESS
DPYTY4:	MOVEI DSER,(DDB)	;PRESERVE A COPY OF DDB ADDR.
	HRRZ DDB,LETAB(TAC1)	;FIND DPY FOR THIS JOB.
	JUMPN DDB,DPYTY2	; IF WE HAVE A BLOCK, OK
DPYTY5:	PUSHJ P,DPYMAKE		; OTHERWISE, TRY TO MAKE ONE
	 JRST DPYTLN		; NO ONE HOME, LOSE LOSE (PLANT CLOCK REQ FOR LATER)
	AOS NDPMAK		; BUMP NUMBER OF TIMES WE HAD TO DO THIS
	HRRZ DDB,LETAB(TAC1)	; GET POINTER TO HEADER WE JUST MADE
DPYTY2:	MOVNI IOS,12		;TYPE NO MORE THAN 12 CHARS/TICK ON III
	SKIPE UUO,CURPP(DDB)	;TYPE ON CURRENTLY SELECTED P OF P.
	JRST DPYTL1
DPYTY6:	PUSH P,DAT		; SAVE THE OUTPUT BUFFER ADDRESS
	HLRE TAC,PRGNUM(DDB)	; PICK UP DD CHAN OR DISPLAY-TYPE BIT
	PUSHJ P,PPINIT		; SEE IF WE CAN GET A PAGE PRINTER
	 JRST DPYTY3		; NO, COME BACK NEXT TICK AND TRY AGAIN
	PUSHJ P,PPSET		; YES, INITIALIZE IT
	HRRZ UUO,CURPP(DDB)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	POP P,DAT		; GET BACK TTY OUTPUT BUFFER ADDRESS
	JRST DPYTL1

DPYTY3:	POP P,DAT
	JRST DPYTLN		;PLANT CLOCK REQ. FOR LATER.
;DPYTL1 DPYTL0 DPYTL2 DPTL2A DPTL2B

; HERE AT CLOCK LEVEL WITH DAT SET TO
; THE TTY BUFFER AND UUO POINTING TO THE PAGE PRINTER CONTROL BLOCK

DPYTL1:	MOVE AC1,DEVIOS(DSER)
	TRNE AC1,10
	TRNE AC1,6		;CHECK FOR IMAGE MODE 10 OR 11
	JRST DPYTL0
	SETZM DPTYCL(DDB)	;Clear flag saying we are in DPYTYP--only used by DM
	POPJ P,			;DO NOTHING IF IMAGE MODE 10 OR 11

DPYTL0:	HLL UUO,PPDPY(UUO)	; GET BITS INDICATING DISPLAY TYPE
	SKIPE DPHOLD(DDB)	; ARE WE IN HOLD MODE?
	JRST STAR		; YES, PRINT STARS AND GO AWAY
	SKIPE PPENQ(UUO)	; DO WE CURRENTLY HAVE ANYTHING IN THE QUEUE?
	JRST DPYTL5		; YES, PLANT CLOCK REQ. TO COME BACK NEXT TICK.
				;   (FOR SOME REASON, REFLIX ZEROS QWAKE)
	SETZ AC1,		;No DM output queued yet
	TLNE UUO,DMLIN
	PUSHJ P,DMNOHD		;Force out any previously set up glitches now.
DPYTL2:	OFFSCN			;AVOID EMBARASSING CONFUSION OVER EMPTY BUFFER
DPTL2A:	PUSHJ P,GETCHO		; GET A CHARACTER
	JUMPE CHR,DPYTLX	; BUFFER EMPTY
	ANDI CHR,177		;BH 1/9/78 JUST IN CASE SOMEHOW IN IMAGE MODE
	SKIPL LSTCHR(UUO)	;IF DTYO HAS JUST INVENTED A LF, LET IT DO THE WORK
	SKIPL FAKELF(UUO)	;DID DTYO INVENT LF FOR US LAST TIME?
	JRST DPTL2B		;NO. BEHAVE NORMALLY
	CAIN CHR,15		;YES. CR'S GET FLUSHED NOW.
	JRST DPTL2A
	SETZM FAKELF(UUO)	;NO FAKED LF FOR US NOW
	CAIN CHR,12		;FLUSH FIRST REAL LF AFTER FAKE ONE
	JRST DPTL2A
DPTL2B:	JUMPE CHR,DPTL2A	;BH 1/9/78 JUST IN CASE SOMEHOW IN IMAGE MODE
	PUSH P,CHR		; SAVE THE CHARACTER
	EXCH DAT,UUO		; GET PP CONTROL BLOCK ADDRESS IN DAT
	PUSHJ P,DTYO		; SEND THE CHARACTER OUT
	EXCH DAT,UUO
	POP P,CHR
	SKIPGE AC1,LSTCHR(UUO)	;DID DTYO INVENT A LF FOR US?
	MOVEI CHR,12		;YES. PRETEND WE WERE THE ONE WHO ASKED FOR LF.
	MOVEM AC1,FAKELF(UUO)	;REMEMBER NEXT TIME IF DTYO INVENTED LF THIS TIME
	ONSCN			;TURN ON SCANNER CHANNEL
	SKIPLE LHCNT(DDB)	;ARE WE SUPPOSED TO HOLD NOW?
	JRST DPYTL3		; NO, GO ON
	LDB AC1,HLINES		; YES, RESET HOLD COUNT
	JUMPG AC1,.+2		;REDUNDANT CHECK TO MAKE SURE HOLDING IS ENABLED
	MOVSI AC1,377777	;IT ISN'T, DON'T LET IT HAPPEN AGAIN!!
	MOVEM AC1,LHCNT(DDB)
	JRST STAR0
;DPYTL3 DPYTL4 DPYTER

DPYTL3:	SKIPE GLTCH(UUO)	; GLITCH TIME?
	SKIPE GLHCNT(DDB)	; YES, IS IT TIME TO HOLD?
	JRST DPYTL4
	LDB AC1,HGLTCH		; YES, RESET COUNT
	MOVEM AC1,GLHCNT(DDB)
	JRST STAR0

DPYTL4:	JUMPGE UUO,DPTDD	; IF DD OR DM, GO TO SPECIAL ROUTINE
;*** RPH PATCH TO SLOW DOWN OUTPUT OF BLANK LINES
	CAIE CHR,12
	CAIN CHR,15
	JRST DPYTLN
;*** END SLOW DOWN PATCH
	AOJN IOS,DPYTL2		; OTHERWISE, COUNT DOWN AND LOOP BACK
	JRST DPYTLN		; AND PUT IN ANOTHER CLOCK REQUEST IF TOO MANY CHARACTERS THIS TICK

; ROUTINE TO TYPE CTY ERROR MESSAGE ON ILLEGAL LINE NUMBER

DPYTER:
REPEAT 0,<  ;Maybe we don't wait for the DPYTYP requests to disappear on NO DM.
	PUSH P,DAT
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL LINE NUMBER AT DPYTYP - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	POP P,DAT
>;REPEAT 0
	POPJ P,
;STAR0 STAR IISTAR

; ROUTINE TO TYPE STAR ON LINE THREE WHEN TYPEOUT IS HELD UP

STAR0:	HRRZ AC1,TPJMP(UUO)	; FIRST, IS THE P OF P INACTIVE?
	CAIE AC1,DISNOP
	TLNN UUO,DMLIN		;Or is it not a DM?
	JRST STAR		;Yes, hold now
	HLLOS DPHOLD(DDB)	;Tell QDMR to hold after queueing current xfers
	JRST QDMR

STAR:	SETOM DPHOLD(DDB)
IFN FTDD!FTGRIN,<
	JUMPL UUO,IISTAR	; SEPARATE ROUTINE FOR III
	TLNN UUO,DDDLIN
>;IFN FTDD!FTGRIN
	JRST DMSTAR		; ALSO DIFFERENT ROUTINE FOR DM
IFN FTDD!FTGRIN,<
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; PICK UP ONE FOR THE OTHER FIELD
	MOVE AC2,(P)		; GET THE ADDRESS OF THE FIRST ONE BACK
	HRLI UUO,PPSTAR		; SET UP DISPATCH TO ROUTINE THAT DRAWS STAR ON LINE THREE
	MOVSM UUO,(AC1)		; SET IT IN FIRST TASK BLOCK
	MOVSM UUO,(AC2)		; AND IN SECOND ONE
	SETZM QCOUNT(AC1)	; DON'T WAKE ANYBODY UP ABOUT THIS
	SETZM QCOUNT(AC2)
	SETZM QFIELD(AC1)	; FIRST FIELD OF ERASURE
	SETOM QFIELD(AC2)	; SECOND FIELD
	MOVE AC3,[XWD 3,3]	; TELL QBLOCK WHERE TO QUEUE THIS REQUEST
	MOVEM AC3,QLINE(AC1)
	MOVEM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK		; NOW QUEUE UP THE REQUESTS
	POP P,AC1
	PUSHJ P,QBLOCK		; DON'T OPTIMIZE!!!!!
	POPJ P,

IISTAR:	MOVE AC1,PSELB(DDB)	; PICK UP GUY'S SELECT WORD
	AND AC1,[77B5]		; MASK OUT ALL BUT HIS SELECT BIT
	IORM AC1,DPYHLD		; SELECT HIM FOR THE MASSAGE
	LSH AC1,-=12		; MOVE OVER TO DESELECT FIELD
	ANDCAM AC1,DPYHLD
	POPJ P,
>;IFN FTDD!FTGRIN
;DMSTAR DMSTA2 UNHDM CHASPP CHASP3 CHASP4

DMSTAR:	PUSHJ P,GETQ
	MOVE AC2,[440700,,DMSTR];Byte pointer to holding message.
	MOVEM AC2,QTAKR(AC1)
	MOVEI AC2,NOEEOL	;Avoid erasing whole line 
	MOVEI AC3,LDMSTR*5	;Number of characters in holding message.
DMSTA2:	MOVEM AC3,QDMCNT(AC1)
	HRRM AC2,QFLAGS(AC1)
	HRLM DDB,QFLAGS(AC1)
	MOVEI AC2,2		;Third line, first column
	MOVEM AC2,QXY(AC1)
	SETZM QCOUNT(AC1)	;Don't wake anyone up
	MOVEI AC2,DMSPPT-QLINK(DDB)	;Queue this xfer in special queue
	PUSHJ P,QDM
	MOVEI DAT,(DDB)		;Dpy header
	JRST STRTDM		;Make sure he see this message

UNHDM:	SETZM DPTYCL(DDB)	;Clear flag saying DPYTYP is running
	PUSHJ P,GETQ
	MOVE AC2,[440700,,[BYTE (7)27]] ;Just one erase to eol char
	MOVEM AC2,QTAKR(AC1)
	MOVEI AC2,DMQUOT	;Quote this whole xfer
	MOVEI AC3,1		;Number of characters in this xfer
	JRST DMSTA2

;Here to flush all regular PP text xfers from PP queue.
CHASPP:	OFFSCN			;Don't let anything change while we think.
	SKIPA TAC,DMPPPT(DDB)	;Get pointer to first entry in queue
CHASP3:	POP P,TAC
	ANDI TAC,-1
	CAIN TAC,DMPPPT-QLINK(DDB) ;Does this pointer point to header?
	JRST SCNONJ		;Yes, all done
	PUSH P,QLINK(TAC)	;Remember pointer to next queue entry
	CAME UUO,QPUTR(TAC)	;Is it for this PP?
	JRST CHASP3		;No
	MOVE AC1,QFLAGS(TAC)	;Get flag word
	TRNN AC1,QUO177		;Is it a PP text xfer?
	JRST CHASP4		;No, might be a glitch or erasure
	SETZM QWAKE(TAC)	;Don't plant clock request when dequeueing
	SETZM DPTYCL(DDB)	; but allow future clock requests to DPYTYP
	PUSHJ P,DMDEQ		;Dequeue this entry.
	JRST CHASP3		;Note that we don't call routine in LH(QFREE)

CHASP4:	TRZ AC1,DMXCAL		;Don't let any glitch here call GLTCHX
	MOVEM AC1,QFLAGS(TAC)	; because we have reset DMPPXY already.
	JRST CHASP3
;UNHOLD UNHIII

; ROUTINE, CALLED FROM CLOCK CALL WITH LINE NUMBER IN DAT, TO CONTINUE PAGE PRINTER

↑UNHOLD:HRLI DAT,DPYTYP		; SET UP TO COME BACK TO PRINT ROUTINE IF DONE
	MOVSI TAC1,DISLIN!DDDLIN!DMLIN
	TRNN DAT,-1⊗PUNITS	; IS THE LINE NUMBER LEGAL?
	TDNN TAC1,LINTAB(DAT)	; YES, BUT IS IT A DISPLAY?
	JRST DPYTER		; NO, TYPE ERROR MESSAGE
	SKIPN DDB,TTYTAB(DAT)	; IS THERE A TTY DDB?
	POPJ P,			; NO, FORGET IT.
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
	HRRI DAT,TTOBUF(DDB)	; PICK UP OUTPUT BUFFER ADDRESS
	MOVEI DSER,(DDB)	; COPY THE DEVICE DATA BLOCK POINTER
	HRRZ DDB,LETAB(TAC1)	; GET DPY HEADER
	JUMPE DDB,DPYTY4	; IF NO PROGRAM HEADER, NO STAR TO ERASE
	SKIPN UUO,CURPP(DDB)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
	JRST DPYTY6		; IF NONE, GO MAKE ONE UP
	HLL DDB,PPDPY(UUO)	; GET BITS TO DISTINGUISH TYPES OF DISPLAYS
	HLL UUO,DDB
IFN FTDD!FTGRIN,<
	JUMPL UUO,UNHIII
	TLNE UUO,DMLIN
>;IFN FTDD!FTGRIN
	JRST UNHDM		; DATAMEDIA DISPLAY
IFN FTDD!FTGRIN,<
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE FOR THE OTHER FIELD
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST ONE
	SETZM QFIELD(AC1)	; SEND IT OUT ON ONE FIELD
	SETOM QFIELD(AC2)	; THE OTHER ON THE OTHER
	MOVE AC3,DDB		; COPY DPY HDR ADDRESS
	HRLI AC3,ERASE		; DISPATCH TO THE ERASURE ROUTINE
	MOVSM AC3,(AC1)		; SET THAT IN DISPATCH ADDRESS
	MOVSM AC3,(AC2)
	SETZM QCOUNT(AC1)	; DON'T WAKE ANYBODY UP
	SETZM QCOUNT(AC2)
	MOVE AC3,[XWD 3,3]	; ERASE LINE 3
	MOVEM AC3,QLINE(AC1)
	MOVEM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK
	POP P,AC1
	PUSHJ P,QBLOCK
	JRST DPYTL1

UNHIII:	MOVE AC1,PSELB(DDB)
	AND AC1,[77B5]
	ANDCAM AC1,DPYHLD
	LSH AC1,-=12
	IORM AC1,DPYHLD
	JRST DPYTL1
>;IFN FTDD!FTGRIN
;DPTDD DPTDDK DPYTLN DPYTIM DPYTL5

; COME HERE FOR DATA DISK TO SEE IF IT IS END OF LINE OR GLITCH TIME.

DPTDD:	TLNN UUO,DMLIN		; DON'T STOP DM JUST BECAUSE OF END OF LINE
	CAIE CHR,12		; IS THIS END OF DD LINE?
	SKIPE GLTCH(UUO)	; OR HAS THE PAGE PRINTER GLITCHED ON DD OR DM?
	JRST DPTDDK		; YES, QUEUE UP A REQUEST AND LEAVE
	JRST DPYTL2		; OTHERWISE, PUT IN ANOTHER CHARACTER

DPTDDK:	HRRZ AC1,TPJMP(UUO)	; FIRST, IS THE P OF P ACTIVE?
	CAIN AC1,DISNOP
	JRST DPYTL2		; NO, JUST EMPTY THE BUFFER
IFN FTDD!FTGRIN,<
	TLNN UUO,DMLIN
	JRST QDDR		; DATA DISC
>;IFN FTDD!FTGRIN
	JRST QDMR		; DATAMEDIA

↑DPYTL5:TLNE UUO,DMLIN		;DMs do the right thing and don't need this clk req
	POPJ P,
↑DPYTLN:HRR DAT,TAC1		; PUT IN LINE NUMBER AS DATUM
↑DPYTIM:SYSPIFF
	IDPB DAT,CLKQ		;PUT IN CLOCK REQUEST.
	SYSPIN
	POPJ P,
;QDMCLK QDMR QDMR1 QDMR2

QDMCLK:	PUSHJ P,SCNONJ		;Turn scanner channel back on
	JRST DPYTLN		;Plant clock req now

;Here at clock level with ch 5 on.
;LH DAT has routine to wakeup (DPYTYP or DPYERT).
;RH TAC1 has data for that routine (line nbr)
;DDB has dpy header, UUO has PP control block address.
;DDB, UUO, and DAT are all preserved.
;TAC1 is clobbered by STRTDM, but only to line.bits,,line.number
QDMR:	SETZM GLTCH(UUO)	;We'll put out any needed glitches now
	SKIPE TAC,DMLAST(UUO)	;Get byte pointer to first char to be output
	JRST QDMR2
	PUSHJ P,CHASPP		;Flush any queued PP text xfers since we redraw all
	EXCH DAT,UUO		;POSLIN and GLNADR want PP pointer in DAT
	PUSHJ P,POSLIN		;Get number of first line of PP
	JUMPG AC3,.+2
	MOVEI AC3,1		;PP above screen, start at top of screen
	MOVEM AC3,DMPPXY(DAT)	;Set up cursor position for output (LH≡X=0)
	OFFSCN			;Don't let LE glitch us while we thinking
	PUSHJ P,GLNADR		;Get address of text of first line
	EXCH DAT,UUO
	SETZM DMGLCH(UUO)	;No glitches needed now
	SOS AC3,DMPPXY(UUO)	;Normalize cursor position for DM
	CAML AC3,DPYHGT(DDB)	;PP start below screen?
	JRST QDMCLK		;Yes, flush xfer, plant clk req now
	HRLI AC2,440700
	AOS TAC,AC2		;It was really address of LF ending previous line
	HRRZ AC2,(TAC)		;Get RH of first significant word in buffer
	CAIE AC2,DISJMP		;End of text in this buffer?
	JRST QDMR1		;No (assume text word--don't think it can be 0)
	HLR TAC,(TAC)		;Get destination of jump--next buffer perhaps
	MOVE AC2,(TAC)		;Now look at new first significant buf word
	TRNN AC2,1		;Is it a text word?
	JRST QDMCLK		;No, this must be virgin PP--no text in it
QDMR1:	MOVEM TAC,DMLAST(UUO)	;Now we have pointer to real text word.
	ONSCN
QDMR2:	SETZ AC1,		;No queue block ready yet
	CAMN TAC,PPTR1(UUO)	;Have we caught up with Page Printer PUTR?
	JRST DMNOQB		;Better be true that LH(PPTR1) is never 440700!
	LDB AC2,[360600,,TAC]	;Get position field of byte ptr
	IDIVI AC2,7		;Number of bytes to be output from current word
	OFFSCN			;Don't let LE call DTYO while we examine buffer
	MOVEI AC3,1
	TDNE AC3,1(TAC)
	AOJA TAC,.-1		;Count number of ASCID words following
	MOVE AC3,TAC
	SUB AC3,DMLAST(UUO)	;Number of full words
	IMULI AC3,5		;Number of bytes
	ADD AC2,AC3		;Total bytes to be output in this block
	JUMPE AC2,DMNXBK	;None, skip to next PP text block
;DMNXBK DMNONX DMNON3 DMNON2 DMNON4

	PUSHJ P,GETQ		;Get block for a queue entry
	MOVEM AC2,QDMCNT(AC1)	;Store output byte count
;We later subtract from QDMCNT the number of nulls in bytes at end of the block.
	MOVE AC2,DMLAST(UUO)
	MOVEM AC2,QTAKR(AC1)	;And output byte pointer
	MOVEI AC2,DMATXY!CHASTE!QUO177	;Interpret 177s as normal char,
	MOVEM AC2,QFLAGS(AC1)	; erase old line, and update DMPPXY
	MOVEI AC2,DMPPXY(UUO)
	MOVEM AC2,QXYLOC(AC1)	;Pass address of word containing cursor position
	SETZM PPVIRG(UUO)	;No longer virgin PP
DMNXBK:	MOVEI AC3,1
	HRRZ AC2,1(TAC)		;Get dpy word that had low-order bit off
	CAIE AC2,DISJMP		;Is this a display jump instruction?
	JRST DMNONX		;No, end of text
	HLRZ AC2,1(TAC)		;Get destination address of jump
	TDNN AC3,(AC2)		;Is this a text word?
	JRST DMNONX		;No
	ONSCN
	MOVEI TAC,(AC2)
	HRLI TAC,440700
	MOVEM TAC,DMLAST(UUO)	;Set up initial byte pointer
	JUMPE AC1,QDMR2		;Got a xfer ready?
	PUSHJ P,QDMPP		;Yes, queue it in PP queue
	JRST QDMR2		;Now queue up xfer for next block

DMNONX:	MOVE AC2,PPTR1(UUO)
	MOVEM AC2,DMLAST(UUO)	;Save pointer to last text char queued
	JUMPE AC1,DMNON7	;Jump if no queue entry byte count to fix
	MOVEI AC2,0		;Count null bytes to flush
DMNON3:	CAME AC3,(TAC)		;Is this word full of nulls?
	JRST DMNON2
	SUBI AC2,5		;Yes, count 5 nulls to uncount
	SOJA TAC,DMNON3

DMNON2:	SKIPE AC3,(TAC)		;Get last word of text to count its nulls
DMNON4:	TRNE AC3,376
	JRST DMNON5
	LSH AC3,-7
	SOJA AC2,DMNON4
;DMNON5 DMNON6 DMNON7 DMNOQB DMNOHD DMQGLC DMXSIZ DMPPST STRTEX

DMNON5:	ADDM AC2,QDMCNT(AC1)	;Uncount the nulls
	MOVE AC3,DPHPOS(UUO)
	ADD AC3,LNLNGT(UUO)	;See what horiz. position is.
	JUMPE AC3,DMNON6	;Ok if at left margin
	MOVE AC2,LSTCHR(UUO)
	CAIN AC2,12		;Does PP end with a bare LF?
	SOS QDMCNT(AC1)		;Yes, don't transmit the LF
DMNON6:	PUSHJ P,QDMPP		;Now queue final text xfer
DMNON7:	ONSCN
DMNOQB:	SKIPG DPHOLD(DDB)	;Time to hold after these xfers?
	JRST DMNOHD		;No
	PUSHJ P,GETQ		;Yes, enter a null xfer request to set DPHOLD
	SETZM DPHOLD(DDB)	;But don't hold yet
	MOVEI AC2,DMXCAL!QUO177	;QUO177 allows CHASPP to flush this xfer
	MOVEM AC2,QFLAGS(AC1)
	MOVEI AC2,DPHOLD(DDB)
	HRLI AC2,DMSTHD		;Routine to set DPHOLD
	MOVEM AC2,QFREE(AC1)
	SETZM QDMCNT(AC1)	;No chars to xfer
	PUSHJ P,QDMGLC		;Queue this null request in PP queue
DMNOHD:	SKIPL AC2,DMGLCH(UUO)	;Any glitches to force out now?
	JRST DMPPST		;No
	MOVN AC3,PGSIZ(UUO)	; - number of glitches per screen
	IMUL AC3,DEL(UUO)	; * number of lines per glitch = - lines/screen
	CAMLE AC2,AC3		;Want to glitch whole PP size or more?
	JRST DMQGLC		;No
	MOVEM AC3,DMGLCH(UUO)	;Yes, limit to number of lines in PP
	PUSHJ P,CHASPP		;Yes, flush all PP text xfers
;Since we're glitching whole PP, would be faster and better to just erase whole PP,
;but for now we'll do it the easy way
	SETZM DMLAST(UUO)	;And force out whole PP next time
DMQGLC:	SETZ TAC,		;Just move normal size PP
DMXSIZ:	SETZ AC3,		;PPXSIZ enters here to force out needed glitches
	EXCH AC3,DMGLCH(UUO)	;Move screen text up by amount needed to glitch
	PUSHJ P,DMSHFT		;Shift DM screen up to glitch
DMPPST:	JUMPE AC1,CPOPJ		;If we didn't queue anything, quit now
STRTEX:	EXCH DAT,DDB		;Dpy header into DAT for STRTDM
	PUSH P,DSER		;DPYTYP has TTY DDB in DSER, preserve for DPYDON
	PUSHJ P,STRTDM		;Start DM tty
	POP P,DSER
	EXCH DAT,DDB		;Restore things
	POPJ P,
;DMSHFT DMSHF0 DMSHF1 DMSHF2 DMSHF3 DMSHF4

;PPYPOS calls this to shift screen; DMQGLC and DMXSIZ call this to glitch.
;AC3 has number of lines to shift screen by; this can be greater than DMMAXG.
;TAC has extra lines (besides PP) to shift.
DMSHFT:	HRRZ AC2,TPJMP(UUO)
	CAIN AC2,DISNOP		;Is this PP activated?
	POPJ P,			;No, don't queue this glitch
	PUSH P,AC3		;Save number of lines to move by
DMSHF0:	MOVM AC3,(P)		;Enter here to do "left over" amount of shifting
	CAIG AC3,DMMAXG		;Need more shifting than we can do at one time?
	JRST DMSHF1		;No
	MOVEI AC3,DMMAXG	;Yes, do max amount
	SKIPG (P)
	MOVNI AC3,DMMAXG
	SUBM AC3,(P)		;Put minus amount we will do later on stack
	MOVNS (P)		;Make it real amount
	PUSH P,[DMSHF0]		;Make us return immediately to queue more
	PUSH P,AC3		;This is amount we will do now (max amount)
DMSHF1:	EXCH DAT,UUO
	PUSHJ P,POSLIN		;Get number of first line of PP into AC3
	EXCH DAT,UUO
	SUBI AC3,1		;Normalize it for DM
	MOVE AC2,PGSIZ(UUO)	;Number of glitches in PP
	IMUL AC2,DEL(UUO)	; * size of each glitch = number of lines in PP
	ADD AC2,AC3		; + line before first = last line of PP
	ADD TAC,AC2		;Add into "extra" lines needing shifting
	JUMPL TAC,DMSHF5	;Jump if whole xfer is above screen
	SKIPL AC2,(P)
	SUB AC3,AC2		;Moving down, do it from above new 1st line of PP
;Flushing next two instructions will flush "25th line" when it comes up.
	CAML TAC,DPYHGT(DDB)
	JRST DMSHF4
	SKIPG AC2,(P)
	ADD TAC,AC2
DMSHF4:	CAML AC3,DPYHGT(DDB)
	JRST DMSHF5		;Whole xfer is below screen
	JUMPGE AC3,DMSHF3	;Jump unless xfer starts above screen
	SETZ AC3,		;Start from top of screen
DMSHF3:	PUSHJ P,GETQ		;Get a queue block for glitching request
	MOVEM AC2,QFREE(AC1)	;Amount to adjust DMPPXY by when xfer finishes
DMSHF2:	MOVMM AC2,QDMCNT(AC1)	;Number of chars to output
	MOVEM AC3,QXY(AC1)	;Set up cursor position for output (LH≡X=0)

;FALL THRU TO NEXT PAGE
;DMSHF5 GLTCHX GLTCHZ DMSTHD

	SKIPG (P)
	SKIPA AC3,[440700,,DELRS] ;Moving up, put out DELETE-ROW chars in ID mode
	MOVE AC3,[440700,,DMLFS]  ;Moving down, put out ADD-ROW chars in ID mode
	MOVEM AC3,QTAKR(AC1)
	MOVEI AC3,GLTCHX	;Call GLTCHX when done, to fix DMPPXY
	HRLM AC3,QFREE(AC1)
	MOVEI AC3,DMQUOT!IDON!DMXCAL	;Quote all output chars, be in ID mode,
	MOVEM AC3,QFLAGS(AC1)		; and call indicated routine when done
	MOVEI AC3,DMPPXY(UUO)
	MOVEM AC3,QXYLOC(AC1)	;Pass address of DMPPXY for updating when done
	PUSHJ P,QDMGLC		;Queue the glitch in PP queue
	CAML TAC,DPYHGT(DDB)	;Is last line of PP before last line on screen?
	JRST DMSHF5		;No, this is easy case
	PUSHJ P,GETQ		;Must move text below PP back up or down
	MOVEM TAC,QXY(AC1)
	SKIPG AC2,(P)
	SKIPA AC3,[440700,,DMLFS] ;Moved up, use ADD-ROWs to move other stuff down
	MOVE AC3,[440700,,DELRS]  ;Moved down, use DELETE-ROWs to move stuff up
	MOVEM AC3,QTAKR(AC1)
	MOVMM AC2,QDMCNT(AC1)	;Number of chars to output
	MOVEI AC3,DMQUOT!IDON	;Quote all output chars and be in ID mode
	MOVEM AC3,QFLAGS(AC1)
	PUSHJ P,QDMGLC		;Queue second half of glitching
DMSHF5:	SUB P,[1,,1]		;Flush data from stack
	POPJ P,

;Here in ch5 when glitching xfer has just finished.  Fix up DMPPXY.
GLTCHX:	SKIPGE LEPOS(J)		;Is line editor in PP?
	JRST GLTCHZ		;No (MAYBE WE SHOULD MAKE SURE IT REALLY ISN'T)
	HRRE AC2,QFREE(TAC)	;Yes, we just moved it too
	ADDM AC2,DMLEXY(J)	;Adjust Line Editor position too
	ADDM AC2,CVP(J)		; and LE cursor position
GLTCHZ:	HRRE AC2,QFREE(TAC)	;Get negative of number of lines in glitch
	ADDB AC2,@QXYLOC(TAC)	;Add into DMPPXY
	POPJ P,

;Here when xfer that caused automatic holding has finished.
DMSTHD:	HRRZ AC2,QFREE(TAC)	;Get address of DPHOLD cell
	SETOM (AC2)		;Hold now
	MOVE DAT,QWAKE(TAC)
	SETZM QWAKE(TAC)	;Don't let DMDEQ plant request
	JRST DPYTIM		;Plant clock req for DPYTYP to force out stars
;START RESET ENB LOSENB DAMMIT DDUSRM DDNXM USUAL FIELD INT LOSE

SUBTTL DATA DISK SERVICE ROUTINE - JAM, DEC. 1970

; THESE ROUTINES ARE CALLED BY THE FOLLOWING IN APRINT
;	SOSGE DDCNT
;	JRST DDCLK
;	SKIPE DDSTART
;	JRST DDSTRT
;APRADD:
; THE DATA DISK ROUTINES KNOW ALL ABOUT THE PAGE PRINTER
; AND THE PIECE OF GLASS MECHANISM. TRANSFERS ARE STARTED
; BY PLACING AN ADDRESS IN THE QUEUE WITH THE LEFT HALF GIVING
; THE TYPE OF TRANSFER.

; HERE ARE THE DD HARDWARE BITS
; CONO BITS

START←←100	; STARTS TRANSFER
RESET←←10	; RESETS INTERRUPT BIT
ENB←←40		; INTERRUPT ENABLE
LOSENB←←400	; ENABLE LATE FLAG INTERRUP
DAMMIT←←20	; MAKES TRANSFER GO OUT ON SPECIFIC FIELD
DDUSRM←←1000	; USER MODE, ALLOWS ONLY ONE CHANNEL SELECT
DDNXM←←2000	; NON-EX MEM FLAG
USUAL←←START!ENB!LOSENB!DAMMIT!APRCHN

; CONI BITS
FIELD←←40	; FIELD BIT
INT←←20		; INTERRUPT BIT
LOSE←←200	; LATE FLAG
;QLINE QFIELD QHPOS QLINK QWAKE QCOUNT QTIME QINSTR QPDL QPDL2 QACCT QLENGTH QFLAGS QTAKR QDMCNT QXY QLINK QWAKE QCOUNT QFREE QINSTR QXYLOC QPUTR QTEXT QTEXTL

; DD TASKS ARE QUEUED UP IN SMALL BLOCKS IN THE FOLLOWING FORM:

		; FIRST WORD CONTAINS XWD <RELEVANT DATA BLOCK>,<ROUTINE>
QLINE←←1	; XWD <STARTING LINE #>,<ENDING LINE #>
QFIELD←←2	; 0 FOR EVEN FIELD, -1 FOR ODD FIELD
QHPOS←←3	; XWD <HPOS1>,<HPOS2> FOR CURSOR TRANSFERS. ZERO ERASES CURSORS.
QLINK←←4	; LINKAGE WORD. XWD <BACKWARD LINK OR 0>,<FORWARD LINK OR 0>
QWAKE←←5	; CONTAINS JOB NUMBER TO WAKE UP, OR CLOCK REQUEST TO PLANT
QCOUNT←←6	; ADDRESS OF WORD TO DECREMENT WHEN THIS TASK DONE. WHEN ZERO, WAKE UP VIA QWAKE WHOMEVER
QTIME←←7	; COUNT DOWN OF NUMBER OF FAILURES
QINSTR←←10	; INSTRUCTION TO XCT WHEN DEQUEING BLOCK (COUNTS DOWN NPPXFR)
QPDL←←11	; QBLK AND QBLOCK PUT CALLER'S ADDRESS HERE FOR DEBUGGING
QPDL2←←12	;  AND NEXT HIGHER ADDRESS FROM STACK HERE ALSO FOR DEBUGGING
QACCT←←13	;UPTIME WHEN BLOCK GOT QUEUED -- FOR FIGURING TIME BEFORE DONE
↑QLENGTH←←14	; LENGTH OF A TASK BLOCK
;If you change QLENGTH over FS boundary, then change QTEXTL below too.

;DMs use same size block for queued transfer requests, with (some) different names

↑QFLAGS←←0	; LH: dpy header address.  RH: flags for xfer.
↑QTAKR←←1	; byte pointer for unpacking text being output
↑QDMCNT←←2	; byte count for same
↑QXY←←3		; X-Y position of cursor for next character
↑QLINK←←QLINK	; <backward link>,,<forward link>   Neither link is ever zero.
↑QWAKE←←QWAKE	; Number of job to wake up, or clock request to plant (just like DD)
↑QCOUNT←←QCOUNT	; Address of system word to decrement when this task done (like DD)
↑QFREE←←7	; In Line Editor xfer: # of free bytes.
		; In User xfer: <routine to call when done>,,<FS block addr>
↑QINSTR←←QINSTR	; DEQ (DD dequeueing routine) is used also by DM and XCTs this word
		; For User xfers suspending line editor, this contains JRST USWKLE.
↑QXYLOC←←11	; LE & PP: Absolute ptr to X-Y position word for next char
		; In User xfer: <job making this entry>,,0
↑QPUTR←←12	; In Line Editor xfer: byte pointer. In User xfer: addr of user flag
		; In PP queue: address of PP control block
↑QTEXT←←13	; Location of first word available for actual text being queued
↑QTEXTL←←20-2-QTEXT	; Number of words available at QTEXT to end of block
;QDDR DOXFR

IFN FTDD!FTGRIN,<	;Whole page

; CLOCK LEVEL QUEING SCHEME. PLANTS TASKS IN QUEUE AND LEAVES.
; LAST TASK TO FINISH PLANTS CLOCK REQUEST TO TRANSFER MORE DATA.

QDDR:	MOVE AC3,VPOS(UUO)	; PICK UP VERTICAL POSITION
	SUBI AC3,1		; DON'T GO ALL THE WAY TO THE CURRENT LINE
	MOVEM AC3,VP(UUO)	; STORE IT
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ADDRESS OF FIRST TASK BLOCK
	PUSHJ P,GETQ		; GET ANOTHER TASK BLOCK
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST TASK BLOCK TOO
	HRR DAT,TAC1		; PUT IN LINE NUMBER AS DATUM OF CLOCK REQUEST
	MOVEM DAT,QWAKE(AC1)	; PUT THE OUTPUT BUFFER ADDRESS AS WAKEUP WORD
	MOVEM DAT,QWAKE(AC2)
	MOVEI AC3,PPENQ(UUO)	; COUNT US DOWN ON THE PAGE PRINTER COUNTER
DOXFR:	AOS (AC3)		; BUMP TASK COUNT BY TWO
	AOS (AC3)
	SETZM PPVIRG(UUO)	; NOTE THAT SOMETHING HAS GONE OUT ON THIS PIECE OF PAPER
	MOVEM AC3,SC(UUO)	; SAVE THE COUNT ADDRESS, IF ANY, FOR FUTURE REFERENCE
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	SETZM QFIELD(AC1)	; SEND ONE OUT ON ONE FIELD
	SETOM QFIELD(AC2)	; AND THE OTHER OUT ON THE OTHER
	HRLM UUO,(AC1)
	HRLM UUO,(AC2)		; SAVE PAGE PRINTER CONTROL BLOCK ADDRESS AS DATA BLOCK ADDRESS
	MOVEI AC3,PPXFR		; PICK UP ADDRESS OF I-LEVEL SUBROUTINE
	HRRM AC3,(AC1)		; PLACE IT IN ROUTINE ADDRESS POSITION
	HRRM AC3,(AC2)
	SKIPN GLTCH(UUO)	; IS THIS A WHOLE SCREEN TRANSFER?
	JRST DPTDL		; NO, JUST DO ONE LINE
	SETZM GLTCH(UUO)	; WE ARE DONE GLITCHING
	EXCH DAT,UUO		; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	PUSHJ P,POSLIN		; GET LINE NUMBER OF FIRST LINE OF TRANSFER
	EXCH DAT,UUO
	CAML AC3,VPOS(UUO)	; IS THERE REALLY A PAGE HERE?
	JRST NOPAGE		; NO!
	HRLM AC3,QLINE(AC1)
	HRLM AC3,QLINE(AC2)	; THAT WILL BE STARTING LINE NUMBER ON BOTH FIELDS
	MOVE AC3,VP(UUO)	; PICK UP NUMBER OF LAST LINE OF TRANSFER
	HRRM AC3,QLINE(AC1)	; THIS WILL BE ENDING LINE NUMBER
	HRRM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK		; QUEUE UP FIRST TASK
	POP P,AC1		; GET ADDRESS OF SECOND TASK BACK
	PUSHJ P,QBLOCK		; QUEUE IT UP
>;IFN FTDD!FTGRIN
;QDD1 NOPAGE

IFN FTDD!FTGRIN,<	;Whole page

; WE GET HERE AT CLOCK LEVEL IN THE MIDDLE OF QUEUEING UP A WHOLE SCREEN REQUEST.
; WE HAVE PUT IN THE TEXT REQUESTS AND ARE NOW GOING TO PUT IN THE ERASURE
; REQUEST.

	MOVE AC2,VP(UUO)	; FIRST, IS THERE ANYTHING TO DO?
	MOVEM AC2,LLW(UUO)	; UPDATE LAST LINE WRITTEN
	CAML AC2,GLW(UUO)
	POPJ P,			; NO, WE ARE DONE
	PUSHJ P,GETQ
	PUSH P,AC1		; GET ANOTHER TASK BLOCK AND SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ONE FOR EACH ERASURE FIELD
	MOVE AC3,(P)		; GET BACK ADDRESS OF FIRST ONE
	HRLM DDB,(AC1)		; PUT IN DPY HEADER ADDRESS
	HRLM DDB,(AC3)
	MOVEI AC2,ERASE		; WE WILL CALL THE ERASE CODE
	HRRM AC2,(AC1)
	HRRM AC2,(AC3)
	MOVEM DAT,QWAKE(AC1)	; PUT THE CLOCK REQUEST WORD IN
	MOVEM DAT,QWAKE(AC3)
	MOVE AC2,SC(UUO)	; PICK UP COUNT ADDRESS
	MOVEM AC2,QCOUNT(AC1)	; COUNT DOWN THROUGH IT.
	MOVEM AC2,QCOUNT(AC3)
	SETZM QFIELD(AC1)	; SEND THEM OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC3)
	MOVE AC2,GLW(UUO)	; ERASE TO THE LAST LINE WRITTEN
	HRRM AC2,QLINE(AC1)
	HRRM AC2,QLINE(AC3)
	MOVE AC2,VP(UUO)	; ERASE FROM THE CURRENT POSITION
	MOVEM AC2,GLW(UUO)	; UPDATE LAST LINE WRITTEN
	HRLM AC2,QLINE(AC1)
	HRLM AC2,QLINE(AC3)
	SKIPN SC(UUO)		; IS THERE A COUNT ADDRESS?
	JRST QDD1		; NO, DON'T INCREMENT IT!
	AOS @SC(UUO)		; YES, BUMP IT TWICE
	AOS @SC(UUO)
QDD1:	PUSHJ P,QBLOCK		; QUEUE UP THE FIRST ONE
	POP P,AC1
	PUSHJ P,QBLOCK		; AND THE SECOND ONE--DON'T OPTIMIZE!!!!!
	POPJ P,

; WE GET HERE IF THERE REALLY ISN'T ANYTHING ON THE PAGE

NOPAGE:	PUSHJ P,WAKEQ		; WAKE UP ANYONE WHO'S THERE
	PUSHJ P,GIVQB		; JUST RETURN EVERYTHING TO FREE STORAGE.
	POP P,AC1
	PUSHJ P,WAKEQ
	JRST GIVQB

>;IFN FTDD!FTGRIN
;DPTDL DPYTLX AC2CLK

IFN FTDD!FTGRIN,<

; WE GET HERE TO QUEUE UP A ONE LINE REQUEST.

DPTDL:	MOVE AC3,LLW(UUO)	; PICK UP LINE NUMBER
	CAMLE AC3,VP(UUO)	; IS THIS PAST WHERE WE ARE SUPPOSED TO BE?
	MOVE AC3,VP(UUO)	; YES, USE OUR ARGUEMENT
	HRLM AC3,QLINE(AC1)	; STORE THIS
	HRLM AC3,QLINE(AC2)
	MOVE AC3,VP(UUO)	; END UP ON LINE THE CALLER REQUESTED
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(AC2)
	MOVEM AC3,LLW(UUO)	; AND THIS IS NOW THE LAST LINE WRITTEN
	PUSHJ P,QBLOCK		; PUT THIS BLOCK IN THE QUEUE
	POP P,AC1		; GET BACK ADDRESS OF SECOND BLOCK
	PUSHJ P,QBLOCK		; QUEUE IT UP TOO--DON'T OPTIMIZE
	POPJ P,

>;IFN FTDD!FTGRIN

; WE GET TO THIS ROUTINE WHEN THE BUFFER IS EMPTY.  SCANNER IF OFF.

DPYTLX:	JUMPL UUO,DPYDON	; III DISPLAYS CAN GO ON TO TTYSER NOW
	SETZM DPTYCL(DDB)	;Clear flag saying we are in DPYTYP--only used by DM
	SKIPE GLTCH(UUO)	; Make sure we update screen if glitched
	JRST .+3
	SKIPN DPYCHR(UUO)	; HAS AT LEAST ONE CHARACTER BEEN TYPED?
	JRST DPYDON		; NO, EXIT
	SETZM DPYCHR(UUO)	; CLEAR TYPEOUT FLAG
	MOVN AC1,DPHPOS(UUO)	; PICK UP HORIZONTAL POSITION POINTER
	PUSH P,DAT		; SAVE TTY BUFFER ADDRESS
	HRR DAT,UUO		; PUT PAGE PRINTER CONTROL BLOCK ADDRESS IN DAT FOR REFLIX
	MOVE AC2,LLW(UUO)	; SEE IF PAGE PRINTER IS UP TO DATE
	CAMN AC2,VPOS(UUO)	; COMPARE LAST LINE WRITTEN WITH VERTICAL POSITION
	CAME AC1,LNLNGT(UUO)	; IF NOT AT COLUMN ZERO,
	JRST .+2		; NEED TO PUT IN REQUEST
	SKIPE GLTCH(UUO)	; NEED TO GLITCH? SOLVES THE SINGLE LINE GLITCH BUG.
	PUSHJ P,REFLIX		; PUT IN A SINGLE LINE REQUEST, WHICH MAY DRAW SCREEN
	SETZM GLTCH(UUO)	;Clear glitch flag in case DM PP is deactivated
	POP P,DAT
	HRRZ AC1,HEDPTR(UUO)	; PICK UP POINTER TO DPY PROGRAM HEADER
	MOVSI AC2,DPLED		; MAKE A POINTER TO THE LINE EDITOR QUEUE ROUTINE
	HRR AC2,AC1		; AND MAKE IT INTO A CLOCK REQUEST WORD
	SETO AC3,		; SEE IF LINE EDITOR CLOCK FLAG IS SET
	EXCH AC3,LECLK(AC1)	; IF NOT SET, SET IT NOW
	JUMPL AC3,DPYDON	; IF ALREADY IN, LEAVE NOW
	PUSHJ P,AC2CLK		; NOT IN, PLANT CLOCK REQUEST
	JRST DPYDON

↑AC2CLK:SYSPIFF		; STOP THE WORLD!
	IDPB AC2,CLKQ		; PUT IN THE CLOCK REQUEST
	SYSPIN
	POPJ P,
;LEERS LEERSN RFPCS LEERS2 LEERS3 LEPGC LEPGC2

; THIS ROUTINE QUEUES UP AN ERASURE REQUEST FOR THE LINE EDITOR <ESC>C COMMAND

;Here from ESC C.
↑LEERS:	HRLI DAT,WHONOW		;Refresh wholine when done
	JRST LEERS2

;Here from BRK N.
↑LEERSN:PUSH P,DAT
	HRRZ DDB,PRGNUM(DAT)	;GET LINE NUMBER OUT OF DPY HDR, SO WE CAN
	HLLZ DDB,LINTAB(DDB)	; GET BIT INDICATING DPY TYPE.
	HRR DDB,DAT		;PTR TO DPY HEADER FOR PPSEL
	PUSHJ P,PPSEL0		;SELECT AND ACTIVATE P OF P NO. 0 (no waiting!)
	POP P,DAT
	TLCA DAT,LEERSN≠PPNST2	;CHANGE CLK RQ TO CALL PPNST2 to normalize & redraw screen
↑RFPCS:	HRLI DAT,LERFPW		;Here from BRK P--LERFPW redraws screen
LEERS2:
IFN FTDD!FTGRIN,<
	SKIPE III(DAT)		;Enter here only from LEERS above
	JRST LEPGC		;Use special erase routine for III
>;IFN FTDD!FTGRIN
	SETOM LECC(DAT)		;Flag ESC C done on DD or DM
	MOVE AC3,PRGNUM(DAT)	;Get display bit or DD channel number
IFN FTDD!FTGRIN,<
	TLNE AC3,DMLIN
>;IFN FTDD!FTGRIN
	JRST LEPDM		;DM routine to erase screen
IFN FTDD!FTGRIN,<
	MOVEI AC2,LEENQ2(DAT)	;Use this count cell for DD
	AOS LEENQ2(DAT)
	PUSHJ P,GETQ		; GET A TASK BLOCK
	MOVEM AC2,QCOUNT(AC1)
	MOVEM DAT,QWAKE(AC1)
LEERS3:	MOVE AC2,[XWD 1,=40]
	MOVEM AC2,QLINE(AC1)
	SETZM QFIELD(AC1)	; START ON FIELD ZERO
	HRLM DAT,(AC1)		; GIVE IT DPY PROGRAM HEADER ADDRESS
	MOVEI AC2,WSE		; GO TO THE ERASURE ROUTINE
	HRRM AC2,(AC1)
	SETOM LEVP(DAT)		;TELL DPLED OUR CURSORS BIT THE DUST
	SETOM LECVP(DAT)
	MOVEI DDB,(DAT)		; QBLOCK EXPECTS DPY HEADER IN DDB
	PUSHJ P,QBLOCK		; PUT IT IN THE QUEUE--DON'T OPTIMIZE!!!!
	POPJ P,

LEPGC:	HLRZ TAC,DAT
	PUSH P,DAT
	PUSHJ P,(TAC)		;DO PP STUFF FIRST
	POP P,DAT
LEPGC2:	MOVEI DDB,(DAT)
	JRST PGCLR
>;IFN FTDD!FTGRIN
;REFLIX REFLINE REFLN2

; THE LINE EDITOR PLANTS A CLOCK REQUEST TO REFLINE WHEN IT
; IS DONE TRANSFERRING A LINE INTO THE PAGE PRINTER BUFFER.
; WE SEND OUT THE LINE IT HAS JUST TRANSFERRED.

;Here from DPYTLX for DD and DM.
REFLIX:	HRRZ AC1,TPJMP(DAT)	;Pick up jump to text
	CAIN AC1,DISNOP		;Is it really a jump?
	POPJ P,			;No, don't queue anything
IFN FTDD!FTGRIN,<
	TLNE UUO,DMLIN
>;IFN FTDD!FTGRIN
	JRST QDMR		;Use DM routine for queueing xfers
IFN FTDD!FTGRIN,<
	MOVEI AC3,PPENQ(DAT)	;HERE TO QUEUE TASK FOR PAGE PRINTER
	JRST REFLN2

;Here only for Data Disc.
REFLINE:MOVE DDB,HEDPTR(DAT)
	MOVEI AC3,PPNQT(DAT)	;QUEUE TASK FOR LE. USE "OTHER COUNT DOWN CELL"
	HRRZ AC1,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	POPJ P,			; NO, DON'T BOTHER
REFLN2:	PUSH P,AC3		;SAVE ADDRESS OF COUNT DOWN CELL
	PUSHJ P,GETQ		; GET US A TASK BLOCK
	EXCH AC1,(P)		;(ICK) SAVE AC1 (ADDR OF TASK BLOCK) ON TOP OF STACK
	PUSH P,AC1		;SAVE ADDRESS OF COUNT DOWN CELL IN NEW STACK TOP
	PUSHJ P,GETQ
	MOVE AC2,-1(P)		;GET THE FIRST TASK BLOCK ADDRESS
	MOVE AC3,VPOS(DAT)	; PICK UP VERTICAL POSITION
	MOVEM AC3,VP(DAT)	; SAVE THIS AS ARGUMENT FOR QDD
	POP P,AC3		;SET ADDRESS OF THE COUNT-DOWN CELL IN AC3
	HRRZ UUO,DAT		; IT EXPECTS THE PAGE PRINTER ADDRESS IN UUO
	SETZM QWAKE(AC1)	; DON'T WAKE UP ANYBODY
	SETZB DAT,QWAKE(AC2)
	JRST DOXFR		; USE QDDR TO DO ALL THIS
>;IFN FTDD!FTGRIN
;LECLRS LECLR2 LECLR3 LECLR4

;CLOCK LEVEL ROUTINE TO CLEAR CURRENT PP BY OUTPUTTING ENOUGH LFS.
↑LECLRS:MOVEI DDB,(DAT)		;DPY HDR
	HRRZ DAT,CURPP(DDB)	;CURRENT PP
	MOVE AC1,HEDPTR(DAT)
	CAIE AC1,(DDB)
	JRST PPCLB		;SOMETHING IS ROTTEN IN DENMARKSER
	HRRZ AC1,PRGNUM(DDB)	;GET LINE NUMBER
	HRRZ AC2,TTYTAB(AC1)	;GET DDB ADDRESS
	JUMPE AC2,CPOPJ		;HOW CAN THERE NOT BE A DDB?
	PUSH P,DEVIOS(AC2)	;SAVE COPY OF TPMON
	MOVE AC1,LINTAB(AC1)	;BUT TURN OFF SAVED TPMON IF THE
	TLNE AC1,TLKRNG		; TTY IS IN A TALK RING
	SETZM (P)		;IN TALK RING -- PRETEND NOT IN MONITOR MODE
	PUSH P,DAT		;PRESERVE PP POINTER
	MOVEI DAT,TTOBUF(AC2)	;ADDRESS OF BUFFER TO ZERO OUT
	OFFSCN
	PUSHJ P,ZERBUF		;ZERO UNUSED PART OF OUTPUT BUFFER
	POP P,DAT
	HLL DAT,PPDPY(DAT)	;GET DISPLAY-TYPE BIT
	JRST LECL2A

LECLR2:	MOVE AC1,DELCNT(DAT)	;ARE WE NOW AT FIRST LINE OF A GLITCH?
	CAMN AC1,DEL(DAT)	;WELL, ARE WE?
	JRST LECLR4		;YES
LECL2A:	MOVEI CHR,15		;NO, OUTPUT A CR TO THE PIECE OF PAPER
	PUSHJ P,DTYO
	MOVEI CHR,12		;NOW OUTPUT A LF
	PUSHJ P,DTYO
	JRST LECLR2		;LOOP UNTIL WE GET TO FIRST LINE OF A GLITCH

LECLR3:	PUSHJ P,GLTCH1		;GLITCH THE SCREEN
LECLR4:	MOVE AC1,GLCNT(DAT)	;NUMBER OF GLITCHES NOW ON SCREEN
	SOJG AC1,LECLR3		;LOOP BACK UNLESS ONLY ONE GLITCH LEFT
	POP P,AC1		;GET BACK SAVED DEVIOS
	MOVEI CHR,"."
	TLNE AC1,TPMON		;TTY IN MONITOR MODE? (ALREADY CLEARED IF TLKRNG ON)
	PUSHJ P,DTYO		;OUTPUT A DOT SINCE TTY IS IN MONITOR MODE
	PUSHJ P,IIILED		;Re-position line editor if is III
	JUMPL DAT,SCNONJ	;IIIS ARE EASY
	TLNN DAT,DMLIN
	JRST LECLR5		;DD
	EXCH DDB,DAT		;DPY HDR INTO DAT FOR ONE ROUTINE
	PUSHJ P,PPFLUS		;FLUSH ANY QUEUED PP XFERS ON DM
	EXCH DDB,DAT
	SETZM DMLAST(DAT)	;MAKE WHOLE PP REDRAWN ON DM
LECLR5:	ONSCN
	PUSHJ P,POSLIN
	PUSH P,AC3		;STARTING LINE OF ERASE
	MOVE AC1,PGSIZ(DAT)	;NUMBER OF GLITCHES
	IMUL AC1,DEL(DAT)	;TIMES LINES/GLITCH = LINES/SCREEN
	ADDI AC1,-1(AC3)	;PLUS STARTING LINE - 1 GIVES US THE
	PUSH P,AC1		; ENDING LINE OF ERASE
	HLL DDB,DAT		;DISPLAY BIT FOR PPERS
	PUSHJ P,PPERS		;ERASE WHOLE PP
	SUB P,[2,,2]		;FLUSH DATA
	SETZB AC1,DMGLCH(DAT)	;FLUSH QUEUED GLITCHES ON DMS
	EXCH AC1,DPHOLD(DDB)	;CLEAR HOLD FLAG
	HRRZ DAT,PRGNUM(DDB)	;GET LINE NUMBER DATUM FOR UNHOLD AND DPYTYP
	JUMPE AC1,DPYTYP	;JUMP IF WE WEREN'T HOLDING
	JRST UNHOLD		;SCREEN OUTPUT WILL START AFTER WE UNHOLD
;LERFP LERFPW Q2BLCK LERFP1

; HERE LIES A ROUTINE TO QUEUE UP A WHOLE PAGE TRANSFER WHEN NOT GLITCHING

↑LERFP:	TDZA AC2,AC2		;FLAG NO CALL TO REDRAW WHOLINE
LERFPW:	SETO AC2,		;WANT TO REDRAW WHOLINE
	MOVEI DDB,(DAT)
IFE FTF2,<
	SKIPE III(DAT)
	JRST PPRST		;RESTART PROG IF III
>;IFE FTF2
	HRRZ UUO,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE AC1,HEDPTR(UUO)
	CAIE AC1,(DAT)
	JRST PPCLB		;CURPP IS CLOBBERED OR SOMETHING
	SKIPE AC2
	PUSHJ P,WHONOW		;REQUEST REDRAWING OF WHOLINE
	HRRZ AC1,TPJMP(UUO)	; PICK UP JUMP TO TEXT
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	POPJ P,			; NO, FORGET IT
	HLL UUO,PPDPY(UUO)	; GET DISPLAY-TYPE BIT
IFN FTDD!FTGRIN,<
	TLNN UUO,DDDLIN
>;IFN FTDD!FTGRIN
	JRST LERDM		;DATAMEDIA
IFN FTDD!FTGRIN,<
	SKIPE PPENQ(UUO)	; IS THERE ANYTHING IN THE PAGE PRINTER'S QUEUE?
	JRST LERFP1		; YES, IT WILL GET CAUGHT LATER
	SETZM PPVIRG(UUO)	; NO LONGER A VIRGIN PIECE OF PAPER
	JSP AC3,GET2Q
	MOVEI AC3,LEENQ2(DAT)
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	MOVEI AC3,2
	ADDM AC3,LEENQ2(DAT)
	HRR AC3,DAT
	HRLI AC3,LERELE
	MOVEM AC3,QWAKE(AC1)
	MOVEM AC3,QWAKE(AC2)
	HRLM UUO,(AC1)		; PUT IN ADDRESS OF PAGE PRINTER CONTROL BLOCK
	HRLM UUO,(AC2)
	MOVEI AC3,PPXFR		; THE I-LEVEL SUBROUTINE ADDRESS
	HRRM AC3,(AC1)
	HRRM AC3,(AC2)
	EXCH DAT,UUO		; PICK UP THE NUMBER OF THE LINE AT THE TOP OF THE PAGE
	PUSHJ P,POSLIN
	EXCH DAT,UUO
	HRLM AC3,QLINE(AC1)	; PUT IN THAT AS OUR STARTING LINE NUMBER
	HRLM AC3,QLINE(AC2)
	MOVE AC3,VPOS(UUO)	; PICK UP THE CURRENT POSITION OF THE BOTTOM OF THE PAGE
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(AC2)
Q2BLCK:	PUSHJ P,QBLOCK		; QUEUE THEM UP
	POP P,AC1
	PUSHJ P,QBLOCK		; QUEUE UP THE LAST TASK AND LEAVE
	POPJ P,			; DON'T OPTIMIZE!!

LERFP1:	SETOM GLTCH(UUO)	; FORCE THE PAGE PRINTER TO REFRESH NEXT TIME AROUND
	POPJ P,
>;IFN FTDD!FTGRIN
;GET2Q LERELE PPCLB

IFN FTDD!FTGRIN,<

GET2Q:	PUSHJ P,GETQ		; OTHERWISE, GET A TASK BLOCK TO DO IT OURSELVES
	PUSH P,AC1
	PUSHJ P,GETQ
	HRRZ AC2,(P)
	SETZM QFIELD(AC1)	; SEND THESE OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC2)
	JRST @AC3

>;IFN FTDD!FTGRIN

;REFRESH LINE EDITOR
LERELE:	EXCH DAT,J
	OFFSCN			;TURN OFF SCANNER CHANNEL SINCE QLETXT CALLS DMFLUS
	PUSHJ P,QLETXT		;QLETXT IS IN LINED
	ONSCN			;TURN ON SCANNER CHANNEL
	EXCH DAT,J
	POPJ P,

PPCLB:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CURPP CLOBBERED AT LERFP OR LECLRS
/
	DEBCHECK(POPACS)	;CALL DDT IF DEBUGGING
	POPJ P,
;LERDM LEPDM LEPDM0 LEPDM4 LEPDM1

;Here from LERFP to redraw whole PP
LERDM:	SETZM DMLAST(UUO)	;Make it type out whole page
	PUSHJ P,PPHLD2		;Unhold us
	HRRZ AC1,TPJMP(UUO)	;Is PP active?
	CAIN AC1,DISNOP
	POPJ P,			;No
	MOVSI DAT,DPYTYP	;Wakeup routine for QDMR
	HRRZ TAC1,PRGNUM(DDB)	;Data for clock req
	SETOM DPYCHR(UUO)	;Make sure DPYTLX redraws line editor
	JRST QDMR		;Now queue up whole page request

;Here from LEERS2 to do ESC C on DM.
;LH(DAT) is routine to call after erasure w/RH(DAT) preserved (dpy header).
LEPDM:	OFFSCN			;Don't let ch5 in while we flush the queues
	PUSHJ P,LEPDM0		;Flush the queues and put dpy hdr in J
	PUSH P,DAT		;Save dpy header
	PUSHJ P,LEPDM2		;Erase screen, setup tabs, turn on scanner
	HLRZ AC1,DAT		;Possible routines: WHONOW, PPNST2, LERFP
	PUSHJ P,(AC1)		;Call clock level routine now instead of later
	POP P,DAT		;Dpy header for STRTDM
	JRST STRTDM

LEPDM0:	SETZM DMQKCT(DAT)	;First flush the quicky buffer
	SETZM RPTCNT(DAT)	;Flush any repeat count
	MOVEI AC2,DMWHO(DAT)
	PUSHJ P,DMFLUS		;Flush entries in WHO queue
	MOVE J,DAT		;Dpy hdr for DMFORC, DMUDUN (USFLUS), & LEPDM2
	PUSHJ P,DMFORC		;Make whole wholine get redrawn next time
	PUSHJ P,USFLUS		;Flush user queue
	PUSHJ P,PPFLUS		;Flush page printer queue
	MOVEI AC2,DMSPPT(DAT)
	PUSHJ P,DMFLUS		;Flush special xfer queue
	MOVEI AC2,DMLEPT(DAT)
	PUSHJ P,DMFLUS		;Flush line editor queue
	HRRZ AC1,PRGNUM(DAT)	;Get line number
	SKIPN AC1,DPYDES(AC1)	;Get pointer to dpy desc table
	POPJ P,			;Huh, there isn't one?
	MOVE AC2,DPCABT(AC1)	;Get number of bytes of output abort seq
	HLRZM AC2,DMQKCT(DAT)	;Output the abort seq thru the quicky buffer
	HRLI AC2,441000		;Make byte pointer to output abort seq
	MOVEM AC2,DMQKPT(DAT)	;Place as quicky buffer pointer
	MOVE AC2,DPCABM(AC1)	;Get modes that abort seq clears
	ANDCAM AC2,DMFLAG(DAT)	;Remember that they're cleared now
	POPJ P,

;Here at clock level for EDIT-CLEAR to flush DM queues.
↑LEPDM4:HRRZ TAC1,PRGNUM(DAT)	;Get line number from dpy hdr
	MOVSI AC1,INTFOP	;Interrupt for flushing output
	CAIL TAC1,PTYL0		;Is this a PTY?
	PUSHJ P,PTINTC		;Yes, request interrupt if enabled
↑LEPDM1:OFFSCN			;Here from CLRIMG, PTYRL2 and RSTFRZ.
	PUSHJ P,LEPDM0		;Flush all the DM queues
	JRST SCNONJ
;DMFORC LEPDM2 LEPDM5 LEPDM3 TBDONE INDONE LEPDMC

;Routine to force whole user wholine to be drawn next time
↑DMFORC:MOVE AC2,PRGNUM(J)
	SKIPE AC1,FRETAB(AC2)	;Any wholine storage?
	HRROS WTEND(AC1)	;Yes, force user part of wholine to be updated
	POPJ P,

;Enter here from DPYMAKE at DPYM9 and from LEPDM (for ESC C), w/dpy header in J
;If from DPYM9, then INIDUN is off; if from LEPDM, then the DMQKxx's are set up.
LEPDM2:	MOVE AC1,PRGNUM(J)	;Get line number
	SETZM RPTCNT(J)		;Flush any repeat count for output
	HRRZS PADCNT(AC1)	;Flush any left-over padding
	SETZM DMXY(J)		;Now at upper left corner
	MOVE AC1,PRGNUM(J)	;Get TTY line number
	SKIPN AC2,DPYDES(AC1)	;Get pointer to Display Descriptor Table
	MOVE AC2,DPYDFT		;Whaddayamean there isn't one??  Use default.
	MOVEM AC2,DPYDES(AC1)	;Store in case wasn't one there before
	MOVE AC1,DMFLAG(J)	;See if terminal needs full initialization
	TRNE AC1,INIDUN		;Skip if haven't yet initialized
	JRST LEPDMC		;Just clear the screen
	MOVEI AC1,DMSTAY	;Bits that get left on (indicate hardware type)
	ANDM AC1,DMFLAG(J)	;Note that all DM modes are off
	MOVE AC1,DPCINI(AC2)	;Get ptr to initialization string
	HLRZM AC1,DMQKCT(J)	;Set up quicky count
	HRLI AC1,(<POINT 8,0>)	;Make it a byte pointer
	MOVEM AC1,DMQKPT(J)	;Set up quicky output byte pointer
LEPDMC:	MOVE AC1,DPCERB(AC2)	;Get modes cleared by erase screen
	ANDCAM AC1,DMFLAG(J)	;Note that they are cleared
	PUSHJ P,GETQ		;Get a queue entry for flagging init done
	MOVE AC2,[440700,,[BYTE(7)37]] ;Byte pointer to output a clear screen
	MOVEM AC2,QTAKR(AC1)	;This way we get automatic padding calculation
	MOVEI AC2,1
	MOVEM AC2,QDMCNT(AC1)	;Just one cmd to output
	MOVEI AC2,DMQUOT!DMXCAL	;Quote the one cmd and call routine when done
	HRL AC2,J		;Dpy hdr
	MOVEM AC2,QFLAGS(AC1)
	MOVSI AC2,INDONE	;Routine to call when done
	MOVEM AC2,QFREE(AC1)
	SETZM QCOUNT(AC1)	;Don't wake anybody up over this trivial task
	SETZM QXY(AC1)		;Upper left corner
	MOVEI AC2,DMSPPT-QLINK(J)
	PUSHJ P,QDM		;Queue screen clearing in special queue
	MOVE AC2,PRGNUM(J)	;Get TTY line number
	MOVE AC2,LINTAB(AC2)
	TLNE AC2,TBXPND		;Does this DM have "hardware" tabs?
	JRST SCNONJ		;No, no use setting them then
	MOVE AC2,DMFLAG(J)	;Are the tabs already set?
	TRNE AC2,TBSSET		;Skip if not
	JRST SCNONJ		;Yes, don't bother setting them again.
↑LEPDM3:PUSHJ P,GETQ		;TTY TABS command enters here to set tabs on DM.
	MOVE AC2,[440700,,TABSET]
	MOVEM AC2,QTAKR(AC1)
	MOVEI AC2,LTABSE*5
	MOVEM AC2,QDMCNT(AC1)	;Number of chars in request.
	MOVEI AC2,DMQUOT!DMXCAL!TRUNCA ;Quote all, call routine when done, no X wraparound
	HRL AC2,J		;Dpy header
	MOVEM AC2,QFLAGS(AC1)
	MOVSI AC2,TBDONE	;Routine to call when done
	MOVEM AC2,QFREE(AC1)
	SETZM QCOUNT(AC1)	;Don't wake anybody up over this trivial task
	SETZM QXY(AC1)		;Upper left corner
	MOVEI AC2,DMSPPT-QLINK(J)
	PUSHJ P,QDM		;Queue tab setting in special queue
	JRST SCNONJ

;Here in ch5 when tab setting xfer has finished.
↑TBDONE:HRRZ AC1,PRGNUM(J)	;Get line number
	MOVE AC1,LINTAB(AC1)	;Get line bits
	MOVEI AC2,TBSSET
	TLNN AC1,TBXPND		;Does this guy really have tabs?
	IORM AC2,DMFLAG(J)	;Yes, tabs have now been set.
	POPJ P,

;Here in ch5 when initialization (or ESC C) screen clearing has finished.
;The INIDUN bit is left unset until here to make sure that if the user
;types ESC C while the init string is going out, this flag won't have
;been invalidly set, since ESC C flushes all output, including any
;init string that may be going out.
INDONE:	MOVEI AC2,INIDUN	;Flag initialization done
	IORM AC2,DMFLAG(J)
	JRST QLETXT		;Force line editor to be redrawn, now erase done
;USFLUS USFLU3 PPFLUS PPFLU3 PPFLU2 DMFLUS DMFLU2 DMFLU3

;Here to flush user queue, planting clock req to clear user flag if necessary
;Call with dpy header in J because DMUDUN expects it there
USFLUS:	SKIPA TAC,DMUSER(J)	;Get pointer to first entry in queue
USFLU3:	POP P,TAC
	ANDI TAC,-1
	CAIN TAC,DMUSER-QLINK(J);Does this pointer point to header?
	POPJ P,			;Yes, all done
	PUSH P,QLINK(TAC)	;Remember pointer to next queue entry
	PUSHJ P,DMUDUN		;Call user-program-done routine (needs J)
	PUSHJ P,DMDEQ		;Dequeue this entry.
	MOVE TAC,DMFLAG(J)
	TLZE TAC,USERGO		;Was user running just now, uninterruptibly?
	SETOM DMXY(J)		;Yes, who knows where cursor was left!
	MOVEM TAC,DMFLAG(J)	;Make sure USERGO is now off
	JRST USFLU3

;Here to flush PP queue, updating DMPPXY for any PP with text in queue
PPFLUS:	SKIPA TAC,DMPPPT(DAT)	;Get pointer to first entry in queue
PPFLU3:	POP P,TAC
	ANDI TAC,-1
	CAIN TAC,DMPPPT-QLINK(DAT) ;Does this pointer point to header?
	POPJ P,			;Yes, all done
	PUSH P,QLINK(TAC)	;Remember pointer to next queue entry
	MOVE AC2,QPUTR(TAC)	;Get pointer to PP control block
	MOVE AC1,DPHPOS(AC2)	;Get current horizontal position
	ADD AC1,LNLNGT(AC2)	;Make it non-negative
	MOVSM AC1,DMPPXY(AC2)	;That's X position to continue from
	MOVE AC1,VPOS(AC2)	;Get current vertical position
	SUBI AC1,1		;Normalize for DM
	HRRM AC1,DMPPXY(AC2)	;That's Y position to continue from
PPFLU2:	PUSHJ P,DMDEQ		;Dequeue this entry.
	JRST PPFLU3		;Note that we don't call routine in LH(QFREE)

;Routine to dequeue all the entries in any particular DM queue.
;Call with pointer to queue header word in AC2.
↑DMFLUS:PUSH P,AC2		;Save pointer to actual header word
	SUBI AC2,QLINK		;Make value for matching pointer to header
	PUSH P,AC2
	JRST DMFLU2

DMFLU3:	PUSHJ P,DMDEQ
DMFLU2:	HRRZ TAC,@-1(P)		;Get pointer to first entry now in queue
	CAME TAC,(P)
	JRST DMFLU3
	SUB P,[2,,2]		;Back to header--all done
	POPJ P,
;DMLED0 DMLED5 DMLED DMLED4 DMLED9 DMLED7 STRTDM STRTD2

;Here from clock request because couldn't get free storage
DMLED0:	MOVE J,DAT
	OFFSCN			;Turn off scanner channel
	SETZM DMCLK(DAT)
	PUSHJ P,DMLED		;Expects dpy header in J
	JRST SCNONJ

;Here if we couldn't get free storage for copy of LE buffer--try again later
DMLED5:	SETO AC3,
	EXCH AC3,DMCLK(DAT)
	JUMPL AC3,CPOPJ		;Request already in
	HRLI DAT,DMLED0
	JRST DPYTIM		;Plant clock request from DAT

;J and DAT point to dpy header
;UUO points to current PP
;X-Y is specified by LELINE(DAT) and PPHPOS(DAT)
;Get here at clock level to redraw whole Line Editor on DM
DMLED:	MOVEI AC2,DMLEPT(J)
	PUSHJ P,DMFLUS		;Make sure nothing is in line editor queue
	HRRZ TAC1,PRGNUM(DAT)	;TTY number
	SKIPGE LETAB(TAC1)	;Editor not initialized?
	SKIPG FCPOS(DAT)	;No, editor empty?
	JRST DMLED7		;Yes, just queue up erasure request
	SKIPE AC1,DMFS(DAT)	;Got free storage for copy of line editor text?
	JRST DMLED4		;Yes
	MOVEI AC3,BUFL+1	;No, get some; extra word for positioning cursor
	PUSHJ P,FSGET
	 JRST DMLED5		;Replant clock request
	MOVEM AC1,DMFS(DAT)	;Remember where it is
DMLED4:	HRLI AC1,LEBUF(DAT)	;Address of actual text
	MOVE AC2,AC1
	BLT AC1,BUFL-1(AC2)	;Copy line editor text into FS
	PUSHJ P,GETLEQ
	SETZM QFREE(AC1)	;Don't let anyone stuff text in this block
	MOVE AC2,DMFS(DAT)	;Get back the address of copy of LE text
	HRLI AC2,440700
	MOVEM AC2,QTAKR(AC1)
	MOVEI AC3,1
	TDNE AC3,(AC2)		;Is this a text word?
	AOJA AC2,.-1		;Yup
	MOVEI AC3,177		;Tell TTYSER we are quoting next character
	IDPB AC3,AC2
	MOVEI AC3,14
	IDPB AC3,AC2
	MOVE AC3,CHP(DAT)	;Get cursor horiz pos
	XORI AC3,140
	IDPB AC3,AC2
	MOVE AC3,CVP(DAT)	;Get cursor vert pos
	SUBI AC3,1		;Normalize for DM
	XORI AC3,140
	IDPB AC3,AC2
	SUB AC2,DMFS(DAT)
	MOVEI AC2,(AC2)
	IMULI AC2,5
	ADDI AC2,4		;The LF was followed by 177,FF,X,Y
	MOVEM AC2,QDMCNT(AC1)	;Number of bytes to output
	MOVSI AC2,CHASTE!DMATXY!BETWEE!DMXLE ;Make sure old lines gets erased
DMLED9:	MOVEM AC2,DMLEFL(J)	
	MOVE AC2,LELINE(DAT)
	SUBI AC2,1		;Normalize line number for DMXMT
	HRL AC2,PPHPOS(DAT)
	MOVEM AC2,DMLEXY(DAT)	;Store X-Y position where DMXMT will see it
	SETZM LETXC(DAT)	;Note text is now up to date
↑STRTDM:HRRZ TAC1,PRGNUM(DAT)	;Get line number
	HLL TAC1,LINTAB(TAC1)	; and line bits
	PUSH P,DDB
	HRRZ DDB,TTYTAB(TAC1)	;Get tty DDB address
	JUMPN DDB,STRTD2	;Jump if there is one
	PUSHJ P,DDBSRC		;None there, make one
	JRST DMNDDB
STRTD2:	PUSH P,DAT
	PUSHJ P,TYPT2		;Start tty if necessary
	POP P,DAT		;Restore dpy header
	POP P,DDB		; and whatever
	POPJ P,

DMLED7:	MOVEI CHR,EEOL
	PUSHJ P,QUODMC		;Put out a quoted char to DM
	MOVSI AC2,DMATXY!BETWEE!DMXLE ;Flags needed
	JRST DMLED9		;Now start up DM, if necessary
;DMNDDB DMEOSL

DMNDDB:	POP P,DDB
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /AT STRTDM TO START DM TYPEOUT BUT NO TTY DDB, AND CAN'T MAKE ONE.
LINE NUMBER IN TAC1.  DPY HEADER IN DAT.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	POPJ P,

;Here to erase previous extra lines no longer used by LE, w/number of CRLFs in AC3
DMEOSL:	PUSH P,AC3
	PUSHJ P,GETQ
	POP P,AC3
	MOVEI AC2,CHASTE
	HRL AC2,J
	MOVEM AC2,QFLAGS(AC1)
	ADD AC3,LELINE(DAT)	; ADD IN VERTICAL POSITION
	MOVEM AC3,QXY(AC1)	; This will start at next line since DM=LE-1
	MOVE AC3,LEVP(DAT)	; PICK UP LAST VERTICAL POSITION
	ADD AC3,LENCRS(DAT)	; Make it number of last line formerly used by LE
	SUB AC3,QXY(AC1)	; Number of lines to erase
	MOVEM AC3,QDMCNT(AC1)
	MOVE AC3,[440700,,DMLFS];Put out appropriate number of plain LFs
	MOVEM AC3,QTAKR(AC1)
	SETZM QCOUNT(AC1)	;Don't wake anyone when done
	MOVEI AC2,DMSPPT-QLINK(J)
	JRST QDM		;Queue it in special queue
;DPLEDR DPLED DPLED2 DPLED3 DPLEVS

; HERE IS THE MIGHTY LINE EDITOR AND CURSOR GENERATOR.
; THIS ROUTINE SINGLEHANDEDLY SENDS OUT LINE EDITOR TRANSFERS, LINE EDITOR
; ERASURES, ALL CURSORS AND ALL CURSOR ERASURES.

DPLEDR:
JFCL;	PUSHJ P,BUGTRP		;DON'T OPTIMIZE -- WANT TO KNOW WHERE FROM
	POPJ P,

;Here only for DD and DM displays.
↑DPLED:	HGMAC(33)
	SKIPE LEENQ(DAT)	; DO WE HAVE SOMETHING IN THE QUEUE ALREADY?
	POPJ P,			; YES, THIS ISN'T SUPPOSED TO HAPPEN!
	HRRZ UUO,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	HLL UUO,PPDPY(UUO)	;Get display type bit
	TLNN UUO,DDDLIN!DMLIN
	 JRST DPLEDR		;NON-DISPLAY (OR III) AT DPLED
	SKIPE DPHOLD(DAT)	;Don't wait forever if holding
	TLNN UUO,DMLIN		; and on DM
	JRST DPLED2
	OFFSCN
	MOVEI AC1,3
	MOVEM AC1,LELINE(DAT)	;Display line editor on holding line
	MOVEI AC1,LDMSTR*5+1
	MOVEM AC1,PPHPOS(DAT)
	JRST DPLEOK

DPLED2:	SKIPN DPYCHR(UUO)	;If more PP output waiting, wait for it
	SKIPE PPENQ(UUO)	; IS THERE ANYTHING IN THE PAGE PRINTER QUEUE?
	SKIPGE LEPOS(DAT)	;PP is busy, but ignore if LEYPOS in effect
	JRST .+2		;PP not busy or line editor specially positioned
	JRST DPYTIM		;COME BACK LATER
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE AC1,VPOS(UUO)	; ASSUME WE ARE GOING IN THE USUAL POSITION
	MOVEM AC1,LELINE(DAT)
	MOVE AC1,DPHPOS(UUO)
	ADD AC1,LNLNGT(UUO)
	MOVEM AC1,PPHPOS(DAT)	;INITIALLY ASSUME LINE EDITOR X = PP X
	SKIPL AC3,LEPOS(DAT)
	JRST DPLEVS
	TLNE UUO,DMLIN
	JRST [	HRRE AC3,LEYVAL(DAT)	;GET 18-BIT Y POSITION FROM LEYPOS
		PUSHJ P,POSLD2	;CONVERT TO LINE NUMBER
		JRST DPLED3]
	LDB AC3,[POINT 11,AC3,21]
	TRNE AC3,1⊗=10		; EXTEND SIGN BIT
	IOR AC3,[-1⊗=10]
	PUSHJ P,@PPDPY(UUO)	;Convert to non-negative line number
DPLED3:	MOVEM AC3,LELINE(DAT)
	SETZB AC1,PPHPOS(DAT)	;NOW LINE EDITOR X IS ALWAYS ZERO
DPLEVS:	HRRZ AC3,PRGNUM(DAT)	;Get line number
	SKIPGE LETAB(AC3)	;Anything in line editor?
	SKIPGE LEPOS(DAT)	;Yes, line editor in normal position in PP?
	JRST DPLEOK		;No
	MOVE AC2,LELINE(DAT)	;Starting line of LE
	MOVE AC3,AC2
	ADD AC2,NCRS(DAT)	; + number of extra lines used by LE
;FALL THRU TO NEXT PAGE
;DPLEOK DPLGC1 DPLGC2

	CAMG AC3,DPYHGT(DAT)	;Does LE start off screen?
	CAMG AC2,DPYHGT(DAT)	;Does whole LE appear on screen?
	JRST DPLEOK		;Yes
	PUSHJ P,DPYTIM		;No, come back later
	MOVE DDB,DAT		;Set up ACs for GLITCH
	MOVE DAT,UUO
	PUSHJ P,PPHLD2		;Unhold if necessary
	PUSHJ P,GLITCH		;Glitch now
	MOVE UUO,DAT
	MOVSI DAT,DPYTYP	;Wakeup routine for queued xfers
	HRRZ TAC1,PRGNUM(DDB)	;Line number is datum for DPYTYP
	ONSCN
	HRRZ AC1,TPJMP(UUO)	; Is the PP active?
	CAIN AC1,DISNOP
	POPJ P,			; No, don't do anything
IFN FTDD!FTGRIN,<
	TLNN UUO,DMLIN
	JRST QDDR		; DATA DISC
>;IFN FTDD!FTGRIN
	JRST QDMR		; DATAMEDIA

DPLEOK:	MOVEI AC3,LEENQ(DAT)	; GET ADDRESS OF COUNT WORD
	MOVEM AC3,SC(UUO)	; USE IT TO COUNT DOWN OUR TASKS
	MOVE AC3,PRGNUM(DAT)	; PICK UP DPY NUMBER
	SKIPG J,LETAB(AC3)	; IS THE LINE EDITOR CURRENTLY INITIALIZED??
	JRST DPLGCP		; YES, GET ITS POSITION FROM THE CHARACTER COUNT
	TLNN J,NOCRBT		;Don't suppress erasure if he typed CLEAR
	SKIPL LEPOS(DAT)	;Is vertical pos of LE specified by user?
	JRST DPLGC2		;No
	HRRZ AC2,TTYTAB(AC3)	;Get tty DDB address
	JUMPE AC2,DPLGC2	;If none, can't be suppressing erasures
	MOVE AC2,ACTMOD(AC2)	;Get special activation table bits
	TRNE AC2,SUPERS		;Suppressing erasures?
	TLO UUO,SUPER2		;Yes, flag it to our routines here
DPLGC2:	MOVEM AC1,CHP(DAT)	; SAVE THE HORIZONTAL POSITION
	MOVE AC1,LELINE(DAT)
DPLGC1:	MOVEM AC1,CVP(DAT)	; AND THE VERTICAL POSITION
;HERE WE HAVE SET UP THE CURSOR POSITION SO WE START ON THE DECISION TREE
	MOVE AC1,LELINE(DAT)	; GET VERTICAL POSITION
	JUMPLE AC1,NOLETX	;If above screen, don't draw text
	TLNN UUO,SUPER2		;If suppressing erasure of old text, 
	CAMLE AC1,DPYHGT(DAT)	; or if LE is below screen,
	JRST NOLETX		; then don't do anything to text
;FALL THRU TO NEXT PAGE
;NOLETX DPTL14 DPLGCP

	CAMN AC1,LEVP(DAT)	; HAS THE VERTICAL POSITION OF THE LINE EDITOR CHANGED?
	JRST DPTLE1		; NO, SEE IF ANYTHING ELSE HAS CHANGED.
IFN FTDD!FTGRIN,<
	TLNE UUO,DMLIN
>;IFN FTDD!FTGRIN
	JRST DPTL12		; Just redraw text if on DM
IFN FTDD!FTGRIN,<
	PUSHJ P,DPEC		; ERASE THE LINE EDITOR CURSOR
	PUSHJ P,DPEOPC		; ERASE THE PAGE PRINTER CURSOR
	PUSHJ P,DPWT		; WRITE OUT THE TEXT AGAIN.
	MOVE AC1,CVP(DAT)	; PICK UP CURSOR POSITION
	CAMN AC1,LELINE(DAT)	; IS IT THE SAME AS THE PAGE PRINTER POSITION?
	JRST DPTL14		; YES, WRITE OUT BOTH CURSORS ON THE SAME LINE
	PUSHJ P,DPWC		; NO, WRITE OUT THE LINE EDITOR CURSOR
	PUSHJ P,DPWPC		; THEN WRITE OUT THE PAGE PRINTER CURSOR
	JRST DPTLE5		; GO UPDATE STATE OF HISTORY TO REFLECT OUR TRANSFERS.
>;IFN FTDD!FTGRIN

; GET HERE IF THE LE IS ENTIRELY OFF THE SCREEN

NOLETX:	MOVEM AC1,LEVP(DAT)
	SUBI AC1,1		;Normalize line number for DMXMT
	HRL AC1,PPHPOS(DAT)
	MOVEM AC1,DMLEXY(DAT)	;Store X-Y position where DMXMT will see it
	SETZM LETXC(DAT)
	SETZM LEMISS(DAT)
	MOVE AC1,NCRS(DAT)
	MOVEM AC1,LENCRS(DAT)
	JRST DPTL1C

IFN FTDD!FTGRIN,<
DPTL14:	PUSHJ P,DPWB		; SAME LINE, WRITE OUT BOTH CURSORS AT ONCE
	JRST DPTLE5
>;IFN FTDD!FTGRIN

DPLGCP:	ADD AC1,LEHPOS(DAT)	; ADD IN LINE EDITOR CURSOR HORIZONTAL POSITION
	JUMPE AC1,DPLGC2	; IF NO DISTANCE INTO LINE, SET POSITIONS TO ZERO
	IDIV AC1,LNLNGT(UUO)	; CONVERT TO NUMBER OF LINES AND DISPLACEMENT INTO LAST LINE
	ADD AC1,LELINE(DAT)	; ADD IN STARTING LINE NUMBER
	MOVEM AC2,CHP(DAT)	; THE REMAINDER IS THE HORIZONTAL POSITION
	JRST DPLGC1		; AND WE NOW HAVE IT ALL!
;DPTLE1 DPTL1A DPTL1B DPTL1C DPTL1D
; WE GET HERE IF THE VERTICAL POSITION OF THE LINE EDITOR HAS NOT CHANGED.
; WE CHECK IF ANYTHING ELSE ABOUT THE LINE MIGHT HAVE CHANGED.

DPTLE1:	JUMPGE J,DPTL1D		;DON'T BOTHER CHECKING EMPTY EDITOR
	MOVE AC1,PPHPOS(DAT)
	EXCH AC1,LSTHP(DAT)
	CAMN AC1,LSTHP(DAT)	;SEE IF LE HAS MOVED HORIZONTALLY
	JRST DPTL1A		;NO
	EXCH DAT,UUO		;LEFIX expects display bit in LH of DAT
	PUSHJ P,LEFIX		;YES - RECALCULATE TABS & LONG-LINE CRLFS
	EXCH DAT,UUO
	SETOM LETXC(DAT)	;TEXT NOW NEEDS WRITING
DPTL1A:	SKIPA AC3,NCRS(DAT)	; WE GET HERE IF THE VERTICAL POSITION IS THE SAME
DPTL1D:	MOVE AC3,NCRS(DAT)	;Empty LE means no extra CRLFs
	CAMGE AC3,LENCRS(DAT)	; NOW HAS THE LINE SHRUNK ANY?
	PUSHJ P,DPEOSL		; YES, ERASE LINES PAST FIRST ONE.
DPTL1C:
IFN FTDD!FTGRIN,<
	TLNE UUO,DMLIN		; No explicit xfers needed for cursor
	JRST DPTL1B		; Just see if need to output text
IFN FTGRIN,<
	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID THE LINE EDITOR MISS A BEAT?
	 PUSHJ P,DPWT		; YES, RESTORE THE TEXT
>;IFN FTGRIN
	MOVE AC1,CVP(DAT)	; PICK UP CURSOR VERTICAL POSITION
	CAME AC1,LECVP(DAT)	; HAS THE CURSOR VERTICAL POSITION CHANGED?
	JRST DPTLE2		; YES, SEE HOW MUCH AND WHERE IT IS NOW.
	MOVE AC1,CHP(DAT)	; IF THE VERTICAL POSITION IS THE SAME,
	CAME AC1,LECHP(DAT)	; THEN HOW ABOUT THE HORIZONTAL POSITION?
	JRST DPTLE3		; DIFFERENT, GO SEND OUT A NEW ONE.
	MOVE AC1,PPHPOS(DAT)	;SEE IF PP CURSOR MOVED
	CAME AC1,LEHP(DAT)
	JRST DPTLE6		; YES, GO SEND IT OUT AGAIN
>;IFN FTDD!FTGRIN
DPTL1B:	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID THE LINE EDITOR MISS A BEAT DUE TO AN INVALID BUFFER?
IFN FTGRIN,<
	JRST DPTLE3		; YES, SEND OUT CURSOR AND TEXT AGAIN
>;IFN FTGRIN
IFE FTGRIN,<
	JRST DPTL12		; YES, SEND OUT THE TEXT AGAIN
>;IFE FTGRIN
	SETZM LECLK(DAT)	; NO, NOTHING AT ALL TO DO!
	MOVE AC1,NCRS(DAT)	; Number of CRLFs in line display has been corrected
	MOVEM AC1,LENCRS(DAT)	; This may fix the E problem of spurious LE erasures
	TLNE UUO,DMLIN
	PUSHJ P,STRTDM		;Start the DM to ensure proper cursor positioning
	JRST SCNONJ
;DPTLE6 DPTLE9 DPTLE7 DPTLE2 DPTLE8 DPTL11 DPTLE3

IFN FTDD!FTGRIN,<	;Whole page

; LINE EDITOR DECISION TREE. WE GET HERE IF THE LINE EDITOR CURSOR HAS NOT
; MOVED, BUT THE PAGE PRINTER CURSOR HAS(???)

DPTLE6:	MOVE AC1,CVP(DAT)	; ARE THE TWO CURSORS ON THE SAME LINE?
	CAME AC1,VPOS(UUO)
	JRST DPTLE7		; NO, THEY CAN BE SENT OUT SEPARATELY.
DPTLE9:	PUSHJ P,DPWB		; YES, SEND OUT BOTH
	JRST DPTLE4

DPTLE7:	PUSHJ P,DPWPC		; WRITE OUT THE PAGE PRINTER CURSOR ALONE
	JRST DPTLE4		; DO TEXT CHECK AND LEAVE

DPTLE2:	MOVE AC1,LELINE(DAT)	; WE COME HERE IF THE CURSOR VERTICAL POSITION HAS CHANGED
	CAME AC1,LECVP(DAT)	; IS THE OLD VERTICAL POSITION THE SAME AS THE PAGE PRINTER?
	PUSHJ P,DPEC		; NO, ERASE THE OLD CURSOR
	MOVE AC1,LELINE(DAT)	; PICK UP VERTICAL POSITION AGAIN
	CAMN AC1,CVP(DAT)	; IS IT THE SAME AS THE CURSOR POSITION?
	JRST DPTLE9		; YES, SEND OUT BOTH CURSORS
DPTLE8:	PUSHJ P,DPWPC		; NO, SEND OUT THE PAGE PRINTER'S
DPTL11:	PUSHJ P,DPWC		; SEND OUT THE LINE EDITOR CURSOR TOO
	JRST DPTLE4

DPTLE3:
IFN FTGRIN,<
	TLNE UUO,DMLIN		; No explicit xfers needed for cursor
	JRST DPTL12		; Just see if need to output text
>;IFN FTGRIN
	PUSHJ P,DPEC		; ERASE THE CURSOR
	MOVE AC1,LELINE(DAT)	; PICK UP THE VERTICAL POSITION
	CAMN AC1,CVP(DAT)	; IS IT THE SAME AS THE CURSOR POSITION
	JRST DPTLE9		; YES, SEND THEM BOTH OUT
	PUSHJ P,DPWC		; WRITE OUT OUR CURSOR
	MOVE AC1,PPHPOS(DAT)	;GET PP CURSOR POS
	CAME AC1,LEHP(DAT)	; IS IT THE SAME AS THE CURRENT POSITION?
	PUSHJ P,DPWPC		; NO, WRITE OUT ANOTHER PAGE PRINTER CURSOR
	JRST DPTLE4		; YES, NO NEED TO WRITE A NEW ONE

>;IFN FTDD!FTGRIN
;DPTLE4 DPTL12 DPTLE5 - EVERYBODY COMES HERE TO EXIT

IFE FTGRIN,<
DPTLE4:	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID I-LEVEL MISS DUE TO BUFFER INVALID?
>;IFE FTGRIN
DPTL12:	PUSHJ P,DPWT		; YES, QUEUE UP A TEXT REQUEST
IFN FTGRIN,<
DPTLE4:
>;IFN FTGRIN
DPTLE5:	MOVE AC1,LELINE(DAT)	; SAVE NEW STATE OF LINE EDITOR AND CURSORS
	MOVEM AC1,LEVP(DAT)
	MOVE AC1,PPHPOS(DAT)
	MOVEM AC1,LEHP(DAT)
	MOVE AC1,NCRS(DAT)	; NUMBER OF CRLFS IN LINE TOO
	MOVEM AC1,LENCRS(DAT)
	MOVE AC1,CVP(DAT)	; CURSOR VERTICAL POSITION
	MOVEM AC1,LECVP(DAT)
	SETZM LETXC(DAT)	; CLEAR THE FLAGS
	SETZM LEMISS(DAT)
	MOVE AC1,CHP(DAT)	; CURSOR HORIZONTAL POSITION
	MOVEM AC1,LECHP(DAT)
	JRST SCNONJ
;DPWT DPWT1 DPWT2

; THIS ROUTINE QUEUES UP A LINE EDITOR TEXT REQUEST

IFE FTDD!FTGRIN,<
DPWT:	JRST DMLED
>;IFE FTDD!FTGRIN
IFN FTDD!FTGRIN,<
DPWT:	TLNE UUO,DMLIN		; Use different routine for DM
	JRST DMLED
	PUSH P,DDB
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST ONE AGAIN
	MOVEI AC3,LEXFR		; CALL THE LINE EDITOR I-LEVEL ROUTINE
	HRRM AC3,(AC1)		; PUT IT IN THE DISPATCH ADDRESS OF EACH TASK BLOCK
	HRRM AC3,(AC2)
	MOVE AC3,LELINE(DAT)	; PICK UP VERTICAL POSITION OF LINE EDITOR BUFFER
	HRLM AC3,QLINE(AC1)	; START THE TRANSFER HERE
	HRLM AC3,QLINE(AC2)
	ADD AC3,NCRS(DAT)	; GET NUMBER OF LAST LINE OF TRANSFER
DPWT1:	HRLM DAT,(AC1)		; PUT IN ADDRESS OF DPY PROGRAM HEADER
	HRLM DAT,(AC2)
	HRRM AC3,QLINE(AC1)	; SET THAT AS LAST LINE
	HRRM AC3,QLINE(AC2)
	SETZM QFIELD(AC1)	; SEND OUT TASKS OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC2)
	HRLI DAT,DPLED		; MAKE UP A CLOCK REQUEST WORD
	MOVEM DAT,QWAKE(AC1)
	MOVEM DAT,QWAKE(AC2)
	SKIPN AC3,SC(UUO)	; IS THERE A COUNT WORD?
	JRST DPWT2		; NO, DON'T BOTHER
	AOS @SC(UUO)		; YES, BUMP IT TWICE
	AOS @SC(UUO)
DPWT2:	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	MOVEI DDB,(DAT)
	PUSHJ P,QBLOCK		; QUEUE UP THE FIRST ONE
	POP P,AC1		; GET THE ADDRESS OF THE SECOND ONE
	PUSHJ P,QBLOCK		; QUEUE IT UP TOO.
	POP P,DDB
	POPJ P,
>;IFN FTDD!FTGRIN
;DPEOSL

; THIS ROUTINE ERASES THE OLD SECOND LINE OF THE LINE EDITOR

IFE FTDD!FTGRIN,<
DPEOSL:	JRST DMEOSL
>;IFE FTDD!FTGRIN
IFN FTDD!FTGRIN,<
DPEOSL:	TLNE UUO,DMLIN
	JRST DMEOSL		;Different routine for DM
	PUSH P,DDB
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1
	PUSHJ P,GETQ
	MOVE AC2,(P)
	PUSH P,AC3		;Save number of CRLFs now
	MOVEI AC3,ERASE
	HRRM AC3,(AC1)
	HRRM AC3,(AC2)
	MOVE AC3,LELINE(DAT)	; PICK UP VERTICAL POSITION
	ADD AC3,(P)		; ADD IN LENGTH OF TRANSFER
	SUB P,[1,,1]
	ADDI AC3,1		; BUMP LINE NUMBER TO ONE PAST THE CURRENT LAST LINE
	HRLM AC3,QLINE(AC1)	; PUT THAT IN AS STARTING AND ENDING LINE
	HRLM AC3,QLINE(AC2)
	MOVE AC3,LEVP(DAT)	; PICK UP LAST VERTICAL POSITION
	ADD AC3,LENCRS(DAT)	; ADD IN LENGTH OF LAST TRANSFER
	JRST DPWT1
>;IFN FTDD!FTGRIN
;DPEC DPEOPC DPEC1 DPEC2

IFN FTDD!FTGRIN,<	;First of many consecutive pages

; THIS ROUTINE ERASES THE OLD CURSOR

DPEC:	SKIPA AC2,LECVP(DAT)	;OLD POSITION
DPEOPC:	MOVE AC2,LEVP(DAT)	;SAME THING FOR PP CURSOR
	JUMPL AC2,CPOPJ		;WARN'T NONE
	PUSHJ P,GETQ
DPEC1:	HRLM AC2,QLINE(AC1)	; PUT THAT IN AS STARTING LINE
;	ADDI AC2,1		; BUMP IT BY ONE
	HRRM AC2,QLINE(AC1)	; FOR PESSIMISM
	SETOM QHPOS(AC1)	; CLEAR THE HORIZONTAL POSITION, INDICATING CURSOR ERASURE
DPEC2:	SETZM QFIELD(AC1)	; GOING OUT ON FIELD 0
	HRLI DAT,DPLED
	MOVEM DAT,QWAKE(AC1)	; WAKE UP THE LINE EDITOR DECISION TREE WHEN DONE
	SKIPE AC3,SC(UUO)	; GET COUNTER ADDRESS, IF ANY
	AOS @SC(UUO)		; BUMP COUNT BY ONE
	MOVEM AC3,QCOUNT(AC1)
	HRLM DAT,(AC1)		; GIVE DPY HEADER ADDRESS TO DD INTERRUPT ROUTINE
	MOVEI AC3,CURSOR	; USE THE CURSOR SUBROUTINE
	HRRM AC3,(AC1)
	PUSH P,DDB
	MOVE DDB,DAT
	PUSHJ P,QBLOCK		; QUEUE UP THE REQUEST
	POP P,DDB
	POPJ P,
;DPWPC DPWPC1 DPWPC2 DPWC DPWB

;This whole page IFN FTDD!FTGRIN

; THESE ROUTINES QUEUE UP THE VARIOUS COMBINATIONS OF CURSORS THAT MAY ARISE.

DPWPC:	PUSHJ P,GETQ		; GET A TASK BLOCK FOR THE PAGE PRINTER'S CURSOR
	MOVE AC2,LELINE(DAT)	; GET IT'S VERTICAL POSITION
	MOVE AC3,PPHPOS(DAT)
DPWPC1:	SETOM QHPOS(AC1)	; CLEAR OUT ONE OF THE HORIZONTAL POSITION WORDS
DPWPC2:	HRLM AC2,QLINE(AC1)	; STORE THE STARTING LINE NUMBER OF THE TRANSFER
;	ADDI AC2,1		; FOR SAFETY, MAKE IT LOOK LIKE IT IS TWO LINES LONG
	HRRM AC2,QLINE(AC1)	; AND STORE THAT AS THE DESTINATION LINE NUMBER
	HRLM AC3,QHPOS(AC1)	; STORE THE HORIZONTAL POSITION
	JRST DPEC2		; FINISH QUEUEING UP THE BLOCK

; THIS ROUTINE QUEUES UP A LINE EDITOR CURSOR ONLY.

DPWC:	PUSHJ P,GETQ		; GET A TASK BLOCK
	MOVE AC2,CVP(DAT)	; PICK UP THE CURSOR VERTICAL POSITION
	MOVE AC3,CHP(DAT)	; GET THE HORIZONTAL POSITION
	JRST DPWPC1		; LET THE ABOVE ROUTINE DO ALL THE WORK

; THIS ROUTINE QUEUES UP A TRANSFER WITH TWO CURSORS ON THE SAME LINE

DPWB:	PUSHJ P,GETQ
	MOVE AC2,LELINE(DAT)
	MOVE AC3,CHP(DAT)	; PICK UP THE LINE EDITOR CURSOR'S HORIZONTAL POSITION
	HRRM AC3,QHPOS(AC1)	; PUT IT IN AS ONE OF THE HORIZONTAL POSITIONS INVOLVED
	MOVE AC3,PPHPOS(DAT)	;GET PP CURSOR POS
	JRST DPWPC2		; USE IT TOO.
;QBLOCK QBLK QBLDBG REQBLK QGRFLS

;This whole page IFN FTDD!FTGRIN

;QBLOCK	  HERE IS THE MAGIC SCHEDULING QUEUE ROUTINE
; IT IS CALLED WITH THE ADDRESS OF A TASK BLOCK IN AC1. SAID BLOCK
; MUST HAVE QLINE AND QFIELD SET, BECAUSE THE BLOCK IS MERGED INTO
; THE QUEUE STRUCTURE IN THE RIGHT PLACE ON THE BASIS OF THOSE DATA.

;   ∃ BLOCKS CALLED "FRAMES".  EACH FRAME HAS A POINTER TO A LIST OF ONE OR
; MORE TASK BLOCKS, ALL OF WHICH HAVE THE SAME FIELD (EITHER EVEN OR ODD).
; THE TASK BLOCKS ARE LISTED IN ASCENDING ORDER OF LINE NUMBER. IN GENERAL,
; THE LIST OF FRAMES ALTERNATES BY FIELD PARITY, THE EXCEPTION BEING 
; "MISSING" FRAMES.  FRAME BLOCK FORMAT IS:
;
; 		XWD 0,<POINTER TO NEXT FRAME, OR 0>
;	QLINE:	BITS 0-19 INDICATE WHICH LINES ARE USED BY TASK BLOCKS
;		  IN THIS FRAME.  BITS 0,1,2 FOR LINES 1&2,3&4,5&6, ETC.
;	QFIELD:	SAME AS IN A TASK BLOCK, 0 OR -1 FOR EVEN OR ODD FIELD.
;	QHPOS:	NOT USED
;	QLINK:	XWD 0,<ADDRESS OF 1ST TASK BLOCK>

QBLOCK:
IFN FTDDFSBUG,<
	HRRZ AC2,PRGNUM(DDB)	;GET LINE NUMBER
	CAIL AC2,DDL0
	CAIL AC2,DDL0+DDNUM	;BETTER BE DD LINE
	JRST QBNODD		;AHA, CAUGHT ONE!
	HRRZ AC2,LETAB(AC2)	;GET POINTER TO DPY HDR
	CAIE AC2,(DDB)		;IS IT VALID?
	JRST QBNOD2		;NO!!
>;FTDDFSBUG
	AOS NPPXFR(DDB)		;COUNT A PP TRANSFER IN PROGRESS
	MOVEI AC2,NPPXFR(DDB)
	TLOA AC2,(<SOSN>)	;PREPARE TO COUNT DOWN PP TRANSFERS
QBLK:	MOVSI AC2,(<CAIA>)	;WHOQUE AND UPGQ ENTER HERE
	MOVEM AC2,QINSTR(AC1)	;SAVE INSTRUCTION TO EXECUTE ON DEQUEING
IFN FTGRIN,<
;	SKIPE QFIELD(AC1)	;Don't queue second field for Grinnell
;	JRST QGRFLS		;Just uncount any cells and return the FS
>;IFN FTGRIN
	MOVE AC2,(P)		;RETURN ADDRESS
	MOVEM AC2,QPDL(AC1)	;STORE CALLER'S ADDRESS IN BLOCK FOR DEBUGGING
	MOVE AC2,-1(P)		;AND HIS RETURN ADDRESS (MAYBE)
	MOVEM AC2,QPDL2(AC1)	;ALSO STORED IN BLOCK FOR DEBUGGING
	MOVE AC2,UPTIME
	MOVEM AC2,QACCT(AC1)	;STORE UPTIME UPON QUEUEING
	HGMAC(32)
IFN FTDDBG,<
	CONI PI,LQBLPI
	MOVE AC2,LQBLPI
	TRNN AC2,77000		;IN PROG ON 1 THROUGH 6?
	JRST QBLDBG		;NO
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISMES
	ASCIZ /DD LOSSAGE /
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
QBLDBG:	MOVEM AC1,LQBLTB	;SAVE LAST TASK BLOCK QBLOCK CALLED WITH
	MOVE AC2,(P)
	MOVEM AC2,LQBLPP	;SAVE LAST TOP OF STACK
	MOVE AC2,DDSQ
	MOVEM AC2,LQBLSQ
>;FTDDBG
IFN FTGRIN,<
PRINTX Do we really want to retry Grinnell transfers???
>;IFN FTGRIN
	MOVEI AC2,10		; SET FOR 8 TIMES THROUGH
	MOVEM AC2,QTIME(AC1)	; BEFORE WE DECLARE IT A LOSING TRANSFER
REQBLK:	HRRZ AC2,(AC1)
	CAIL AC2,PPXFR
	CAILE AC2,PPSTAR
	JRST QBLERR
	HLRZ AC2,(AC1)
	CAML AC2,SYSTOP
	CAML AC2,FSTOP
	JUMPN AC2,QBLERR	; IF THERE IS SOMETHING THERE NOT IN FREE STORAGE, ERROR!
	SKIPN INTACT		; IS SOME WISEASS CALLING US AT USER INTERRUPT LEVEL?
	JRST QBLCLC		; NO, ALL IS WELL.
	HRLI AC1,QBLCLK		; YES, PUT IN A CLOCK REQUEST TO DO THIS TASK AT REAL CLOCK LEVEL
	JRST AC1CLK		;Plant clock request from AC1

IFN FTGRIN,<
;Here to discard queue entry for second field, since Grinnell doesn't need it.
QGRFLS:
;	XCT QINSTR(AC1)		;COUNT DOWN PP TRANSFER COUNT--SKIP UNLESS HIT ZERO
;	 JFCL			;COUNT JUST GOT DOWN TO ZERO, BUT DON'T WAKE ANYONE
;	SKIPE QCOUNT(AC1)	;IS THERE A COUNT WORD SOMEWHERE?
;	SOS @QCOUNT(AC1)	;YES, COUNT IT DOWN.
;	JRST GIVQ		;GIVE BACK THE QUEUE ENTRY'S FS
>;IFN FTGRIN
;QBLCLK QBLCLC QBLGO

;This whole page IFN FTDD!FTGRIN

; HERE WE SEE IF THE TASK IS AN EASY OUTSIDER.
; IF IT IS NOT, WE MAKE UP A MASK FOR THE NUMBER OF
; LINES IT COVERS.

QBLCLK:	HRRZ AC1,DAT		; PICK UP THE TASK BLOCK ADDRESS
QBLCLC:	PUSH P,TAC		; SAVE THE WORLD
	PUSH P,TAC1
	PUSH P,DAT
	PUSH P,UCHN
	PUSH P,CHR
IFN FTGRIN,<
	SKIPE QFIELD(AC1)	;Don't queue second field for Grinnell
	  JRST QOOB
>;IFN FTGRIN
	HLRE DAT,QLINE(AC1)	; PICK UP STARTING POSITION
	HRRE UCHN,QLINE(AC1)	; AND THE ENDING LINE NUMBER
	JUMPLE UCHN,QOOB	; IF ENDING LINE IS OUT OF BOUNDS, THIS IS AN EASY OUTSIDER
IFN FTGRIN,<
PRINTX QBLCLC doesn't check for starting below screen since doesn't know Grinnel hgt.
;QBLCLK is reached w/o pointer to DPY HDR, so can't find screen height!
;And QBLK doesn't ever have the dpy hdr to start with.  GRRRR.
>;IFN FTGRIN
IFN FTDD,<
	CAIG DAT,HGTDD		; OR IF STARTING LINE IS BELOW SCREEN . . .
>;IFN FTDD
	SKIPE DDOFF		; IF DD IS BEING MAINTAINED, PRETEND THE TRANSFER IS OUT OF BOUNDS
	JRST QOOB		; IS AN EASY OUTSIDER
	CAIG DAT,(UCHN)		; IS THE STARTING LESS THAN THE FINISHING?
	AOJA UCHN,QBLGO		;CAN'T MAKE NEXT LINE
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISMES
	ASCIZ /STARTING LINE LT FINISHING LINE AT QBLOCK
/
	POPACS
QBLGO:
IFN FTDD,<
	SETZ TAC,		; HERE WE MAKE A 20-BIT MASK, IN BITS
	SETO TAC1,		;	0-19 OF TAC, WHERE EACH BIT
	ADDI DAT,1		;	REPRESENTS 2 LINES, AND IS ON
	ADDI UCHN,1		;	IF EITHER LINE IS TO BE WRITTEN
	LSH DAT,-1
	LSH UCHN,-1
	SUBM DAT,UCHN
IFN FTDDSTAT,<			;ONLY IF COUNTING STATISTICS
	ADDM UCHN,NDDLCT	;COUNT  -(TOTAL NUMBER OF LINES QUEUED)
	AOS NDDXCT		;COUNT TOTAL NUMBER OF TRANSFERS QUEUED.
	CAML UCHN,[-2]
	AOS NDDL1C		;COUNT 1 AND 2 LINE TRANSFERS.
>;FTDDSTAT
	ROTC TAC,-1(UCHN)
	MOVN UCHN,DAT
	ROT TAC,1(UCHN)		; C(TAC) IS THE PROPER 20-BIT MASK
IFN FTDDBG,<
	MOVEM TAC,LQBLMS
>;FTDDBG
>;IFN FTDD
;QBL1 CNXTFR QBL6 QBL7

;This whole page IFN FTDD!FTGRIN

; HERE WE SCAN THE QUEUE SYSTEM LOOKING FOR A FRAME WITH SOME FREE LINES

QBL1:	MOVE DAT,QFIELD(AC1)	; WE WILL ENTER THE TASK ON ITS FIELD
	MOVE AC3,QLINE(AC1)	; MERGE BY LINE NUMBER
	MOVEI AC2,1		; SET THE FIELD SAVED WORD TO DIFFERENT FROM ANY LEGAL FIELD
	MOVEM AC2,DDLFD
	SETZB AC2,DDLST		; NOTE THAT THERE IS NO LAST FRAME
	EXCH AC2,DDQUE		; PICK UP (SHUDDER!) THE ENTIRE QUEUE STRUCTURE
	JUMPE AC2,QBL3		; IF THERE ISN'T ANY, MAKE UP ONE FROM SCRATCH.
	MOVEM AC2,DDSQ		; IF THERE IS ONE, SAVE IT FIRST.
CNXTFR:	CAME DAT,QFIELD(AC2)	; IS THIS FRAME ON THE RIGHT FIELD?
	JRST QBL4		; NO, MOVE ON TO NEXT FRAME
	TDNE TAC,QLINE(AC2)	; YES, IS THERE ROOM ON THIS FRAME?
	JRST QBL8		; NO, GO ON TO NEXT FRAME
	IORM TAC,QLINE(AC2)	; YES, MARK OUR LINES AS CLAIMED
QBL6:	HRRZ CHR,QLINK(AC2)	; PICK UP ADDRESS OF TASK LIST FOR THIS FRAME
	JUMPE CHR,QBL7		; NONE THERE, ANNEX OUR TASK
	MOVE AC2,CHR		; SAVE THIS TASK BLOCK ADDRESS FOR ANNEXATION PURPOSES
	CAMLE AC3,QLINE(AC2)	; NOW, DO WE GO ABOVE THIS BLOCK?
	JRST QBL6		; NO, TRY NEXT BLOCK
	HRRM AC2,QLINK(AC1)	; YES, LINK US IN BETWEEN THESE TWO BLOCKS
	HLRZ AC3,QLINK(AC2)	; PICK UP POINTER TO PREVIOUS TASK
	HRLM AC3,QLINK(AC1)	; MAKE OUR BACKWARD LINK POINT TO THE LAST BLOCK
	HRRM AC1,QLINK(AC3)	; MAKE THE LAST BLOCK POINT TO US
	HRLM AC1,QLINK(AC2)	; MAKE THE NEXT BLOCK'S REVERSE POINTER POINT TO US
	JRST QBLXIT		; PUT THE QUEUE STRUCTURE BACK AND LEAVE

QBL7:	HRRM AC1,QLINK(AC2)	; ANNEX US BY PUTTING OUR ADDRESS IN THE LAST BLOCK'S FORWARD POINTER
	HRLZM AC2,QLINK(AC1)	; AND POINT OUR REVERSE POINTER TO HIM
	JRST QBLXIT
;QOOB GIVQB QBLERR WAKEQ

;This whole page IFN FTDD!FTGRIN

; WE GET HERE IF THE TASK IS ENTIRELY OUT OF BOUNDS
QOOB:	XCT QINSTR(AC1)		;UNWIND THE COUNT
	 JFCL			;QINSTR SKIPS UNLESS COUNTING DOWN TO ZERO
	PUSHJ P,WAKEQ		;WAKE UP ANYONE WAITING.
	POP P,CHR		;RESTORE THE WORLD.
	POP P,UCHN
	POP P,DAT
	POP P,TAC1
	POP P,TAC
GIVQB:	JRST GIVQ

; WE GET HERE IF EITHER THE DISPATCH ADDRESS OR THE DATA BLOCK ADDRESS
; IS ILLEGAL.
QBLERR:	PUSH P,(AC1)
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL TASK AT QBLOCK - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	SUB P,[XWD 1,1]
	XCT QINSTR(AC1)		;COUNT DOWN NPPXFR IF APPROPRIATE
	 JRST GIVQ		;SINCE WE'RE IN CH7, HE CAN'T BE WAITING NOW
	JRST GIVQ		;QINSTR SKIPS UNLESS COUNTING DOWN TO ZERO

WAKEQ:	SKIPE QCOUNT(AC1)	; IS THERE A COUNT HERE?
	SOSLE @QCOUNT(AC1)	; PERHAPS WE HAVE TO GO THROUGH THE WAKEUP RITUAL?
	POPJ P,			; NOT YET.
	SKIPN AC2,QWAKE(AC1)	; YES WE DO. PICK UP WAKEUP WORD
	POPJ P,
	CAIL AC2,JOBN		; IS IT A JOB NUMBER?
	JRST AC2CLK		; NO, MUST BE A CLOCK REQUEST
	SKIPL JBTSTS(AC2)	; MAKE SURE HE IS STILL RUNABLE
	POPJ P,			; NO, LEAVE NOW
	MOVNI AC3,RUNQ		; PUT THAT JOB IN THE RUN QUEUE
	MOVEM AC3,JOBQUE(AC2)
	MOVEI AC3,QJOB(AC2)
	SYSPIFF
	SKIPE (AC3)
	JRST .+3
	EXCH AC3,QJOB
	HRROM AC3,@QJOB
	SYSPIN
	POPJ P,
;QBL3 MAKFRM QBL4

;This whole page IFN FTDD!FTGRIN

; WE GET HERE WHEN THERE IS NO QUEUE AT ALL.

QBL3:	PUSHJ P,MAKFRM		; MAKE UP A NEW FRAME HEADER
	MOVEM AC1,DDSQ		; MAKE THIS THE NEW QUEUE
	JRST QBLXIT		; RESTORE ACCUMULATORS AND LEAVE.

; HERE IS A ROUTINE TO MAKE UP A NEW FRAME HEADER AND PUT THE CURRENT
; BLOCK IN IT AS ITS ONLY TASK.

MAKFRM:	PUSH P,AC1		; SAVE THE TASK BLOCK ADDRESS
IFN FTDDBG,<
	MOVEM AC1,LSMFTB
	MOVEM TAC,LSMFMS
	MOVEM DAT,LSMFFD
>;FTDDBG
	AOS NDDFRM		; COUNT ONE MORE FRAME CREATION
	PUSHJ P,GETQ		; GET A BLOCK FOR THE FRAME HEADER
	SETZM (AC1)		; LINK IT TO NOWHERE FOR NOW.
	MOVEM TAC,QLINE(AC1)	; PUT IN OUR MASK AS THE INITIAL MASK FOR THE FRAME
	MOVEM DAT,QFIELD(AC1)	; STORE THE FIELD WORD AS THIS FRAME'S FIELD
	POP P,AC2		; GET BACK THE TASK BLOCK ADDRESS
	HRRZM AC2,QLINK(AC1)	; POINT THE FRAME HEADER TO US
	HRLZM AC1,QLINK(AC2)	; AND OUR BACKWARD POINTER TO THE FRAME HEADER
IFN FTDDBG,<
	MOVEM AC1,LSMFFM
>;FTDDBG
	POPJ P,

; WE GET HERE IF THIS FRAME HAS THE WRONG FIELD

QBL4:	CAME DAT,DDLFD		; DOES THE LAST FRAME ALSO HAVE THE WRONG FIELD?
	SKIPN DDLST		; YES, DO WE EVEN HAVE A LAST FRAME?
	JRST QBL5		; NO TO EITHER, MOVE ON TO NEXT FRAME
	PUSH P,AC2		; SAVE POINTER TO CURRENT FRAME
	PUSHJ P,MAKFRM		; MAKE UP A BRAND NEW AND DIFFERENT FRAME
	MOVEM AC1,@DDLST	; INSERT IT BETWEEN THESE TWO
	POP P,(AC1)		; POINT IT TO THE SUCCESSOR
	JRST QBLXIT
;QBL8 QBL5 QBL9 QBLXIT

;This whole page IFN FTDD!FTGRIN

; HERE IS A ROUTINE THAT MOVES ON TO THE NEXT FRAME, IF THERE IS NO NEXT
; FRAME, IT MAKES UP A FRAME AND ANNEXES IT ONTO THE FRAME LIST.

QBL8:	MOVEM DAT,DDLFD		; SAVE THE FIELD OF THE FRAME
	JRST QBL9

QBL5:	SETCAM DAT,DDLFD	; SAVE THE FIELD OF THE FRAME (OPPOSITE FROM US)
QBL9:	HRRZM AC2,DDLST		; SAVE THE ADDRESS OF THE LAST FRAME
	HRRZ AC2,(AC2)		; PICK UP ADDRESS OF NEXT FRAME
	JUMPN AC2,CNXTFR	; IF THERE IS ONE, GO CHECK IT OUT.
	PUSHJ P,MAKFRM		; OTHERWISE, MAKE UP A NEW FRAME HEADER
	HRRZM AC1,@DDLST		; LINK US ON TO THE FRAME LIST
QBLXIT:
IFN FTDDBG,<	PUSHJ P,DDQCHK	>
	MOVE AC2,DDSQ		; ALL DONE, PUT THE TASK QUEUE BACK
	MOVEM AC2,DDQUE
	AOS NDDQUE		; MARK ONE MORE IN THE QUEUE
	POP P,CHR		; RESTORE THE ACCUMULATORS
	POP P,UCHN
	POP P,DAT
	POP P,TAC1
	POP P,TAC
	SYSPIFF		; STOP THE WORLD WHILE WE START UP THE DATA DISC
	SKIPN DDRUN		; IS THE DISK RUNNING?
	SETOM DDSTART		; NO, START IT UP NEXT TICK
IFN FTGRIN,<
	CONO PI,GRNGEN		; MAKE SURE WE GET AN INTERRUPT
	CONO PI,GRNON
>;IFN FTGRIN
	SYSPIN
	POPJ P,
;DDQCHK DDQCH1 DDQCH4 DDQCE3 DDQCE2

;This whole page IFN FTDD!FTGRIN

IFN FTDDBG,<
;CHECK STATE OF DD QUEUE.  CALL BEFORE SETTING UP DDQUE FROM DDSQ
DDQCHK:	MOVEI DAT,DDSQ
DDQCH1:	SKIPN AC1,(DAT)
	POPJ P,
	CAML AC1,SYSTOP
	CAML AC1,FSTOP
	JRST DDQCE3		;ADDRESS OUT OF BOUNDS
	MOVSI CHR,-1
	TDNN CHR,(AC1)
	TDNE CHR,QLINK(AC1)
	JRST DDQCE1		;EXTRANEOUS BITS ON IN FRAME
;reg;	MOVEI CHR,77777
;	TDNE CHR,QLINE(AC1)
;	JRST DDQCE1		;EXTRANEOUS BITS IN QLINE
	SKIPE CHR,QFIELD(AC1)
	AOJN CHR,DDQCE2		;QFIELD NOT 0 OR -1
	HRRZ AC2,QLINK(AC1)	;POINTER TO TASK BLOCK
	JUMPE AC2,DDQCH4
	CAML AC2,SYSTOP
	CAML AC2,FSTOP
	JRST DDQCE3
	PUSHJ P,DDTSCH		;CHECK LIST OF TASK BLOCKS
DDQCH4:	MOVE DAT,AC1
	JRST DDQCH1

DDQCE3:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /FRAME BLOCK OR TASK BLOCK ADDRESS OUT OF BOUNDS /
	JRST DDCKR1

DDQCE2:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /QFIELD NOT ZERO OR ONE /
	JRST DDCKR1
;DDQCE1 DDCKR1 DDCKR3 DDCHER DDTSCH DDTSC2 DDTSC1

;This whole page IFN FTDD!FTGRIN

DDQCE1:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /EXTRANEOUS BITS ON /
DDCKR1:	PUSHJ P,DISMES
	ASCIZ /IN FRAME BLOCK AT /
	MOVE TAC,-17+AC1(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
PREVIOUS FRAME BLOCK AT /
	MOVE TAC,-17+DAT(P)
	PUSHJ P,DISLOC
DDCKR3:	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	POPACS			;SO WE DON'T HAVE TO LOOK HARD TO FIND THE AC'S
	PUSHJ P,WDDTCALL	
	JRST DDQCH4		;MAYBE IT'S POSSIBLE TO CONTINUE

DDCHER:	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISMES
	ASCIZ /DATA DISK QUEUE INCONSISTENT
/
	JRST @-17+CHR(P)

;CHECK TASK LIST POINTED TO BY AC2 , AC1 POINTS TO FRAME IT COMES FROM
DDTSCH:	PUSH P,AC1
DDTSC2:	HRRZ CHR,(AC2)		;ADDRESS OF TASK ROUTINE
	CAIL CHR,DWPINI
	CAIL CHR,WHOINI
	JRST DDTSE4
	SKIPE CHR,QFIELD(AC2)
	AOJN CHR,DDTSE1		;QFIELD NOT 0 OR -1
	HLRZ CHR,QLINK(AC2)	;BACKWARDS LINK
	CAIE CHR,(AC1)
	JRST DDTSE2		;BACKWARDS LINK IS WRONG
	HRRZ AC1,AC2
	HRRZ AC2,QLINK(AC2)	;GET FORWARD LINK
	JUMPE AC2,DDTSC1	;END OF LIST
	CAML AC2,SYSTOP
	CAML AC2,FSTOP
	JRST DDTSE3		;TASK LINK OUT OF BOUNDS
	JRST DDTSC2

DDTSC1:	POP P,AC1
	POPJ P,
;DDTSE4 DDTSE3 DDTSE2 DDTSE1 DDCKR2

;Last page IFN FTDD!FTGRIN

DDTSE4:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /TASK ROUTINE ADDRESS OUT OF RANGE /
	JRST DDCKR2

DDTSE3:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /FORWARD LINK OUT OF BOUNDS /
	JRST DDCKR2

DDTSE2:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /BACKWARS LINK WRONG /
	JRST DDCKR2

DDTSE1:	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /QFIELD NOT ZERO OR ONE /
DDCKR2:	PUSHJ P,DISMES
	ASCIZ /IN TASK BLOCK AT /
	MOVE TAC,-17+AC2(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
PREVIOUS TASK BLOCK (MAYBE FRAME BLOCK) AT /
	MOVE TAC,-17+AC1(P)
	PUSHJ P,DISLOC
	JRST DDCKR3
>;FTDDBG

>;IFN FTDD!FTGRIN
;SCPIER QBNODD QBNOD2

IFN FTESCCBUG!FTDDFSBUG,<
↑SCPIER:SYSPIFF
	PUSHACS
	CONI PI,TAC
	PUSH P,TAC
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/
DIDDLING SCANNER DATA NOT IN CH5 WITH CH5 ON.  PI CONI = /]
	DISARG OCT,<-1(P)>
	[ASCIZ /   IOS = /]
	DISARG OCT,<-21(P)>
	[ASCIZ /
CALLERS = /]
	DISARG LOC,<-22(P)>
	[ASCIZ /, /]
	DISARG LOC,<-23(P)>
	[ASCIZ /, /]
	DISARG LOC,<-24(P)>
	[ASCIZ /, /]
	DISARG LOC,<-25(P)>
	[ASCIZ /, /]
	DISARG LOC,<-26(P)>
	[ASCIZ /, /]
	DISARG LOC,<-27(P)>
	[ASCIZ /, /]
	DISARG LOC,<-30(P)>
	[ASCIZ /, /]
	DISARG LOC,<-31(P)>
	[ASCIZ /, /]
	DISARG LOC,<-32(P)>
	[ASCIZ /, /]
	DISARG LOC,<-33(P)>
	[ASCIZ /, /]
	DISARG LOC,<-34(P)>
	[ASCIZ /, /]
	DISARG LOC,<-35(P)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	SUB P,[1,,1]		;PI CONI
	POPACS
	PUSHJ P,WDDTCAL
	SYSPIN
	POPJ P,
>;FTESCCBUG!FTDDFSBUG

IFN FTDD!FTGRIN,<	;Continues for several pages now

IFN FTDDFSBUG,<
QBNODD:	SYSPIFF
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISERR
	[ASCIZ/
QBLOCK CALLED FOR NON-DATADISC LINE.
PRGNUM = LINE = /]
	DISARG LOC,<AC2-20(P)>
	[ASCIZ/
DPY HDR = DDB = /]
	DISARG LOC,<DDB-20(P)>
	[ASCIZ/
CALLERS = /]
	DISARG LOC,<-21(P)>
	[ASCIZ/, /]
	DISARG LOC,<-22(P)>
	[ASCIZ/, /]
	DISARG LOC,<-23(P)>
	[ASCIZ/, /]
	DISARG LOC,<-24(P)>
	[ASCIZ/, /]
	DISARG LOC,<-25(P)>
	[ASCIZ/, /]
	DISARG LOC,<-26(P)>
	[ASCIZ/, /]
	DISARG LOC,<-27(P)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCALL
	SYSPIN
	POPJ P,

QBNOD2:	SYSPIFF
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISERR
	[ASCIZ/
QBLOCK CALLED WITH INVALID DPY HEADER POINTER.
DPY HDR = DDB = /]
	DISARG LOC,<DDB-20(P)>
	[ASCIZ/
LETAB ENTRY (VIA PRGNUM(DDB)) = /]
	DISARG LOC,<AC2-20(P)>
	[ASCIZ/
CALLERS = /]
	DISARG LOC,<-21(P)>
	[ASCIZ/, /]
	DISARG LOC,<-22(P)>
	[ASCIZ/, /]
	DISARG LOC,<-23(P)>
	[ASCIZ/, /]
	DISARG LOC,<-24(P)>
	[ASCIZ/, /]
	DISARG LOC,<-25(P)>
	[ASCIZ/, /]
	DISARG LOC,<-26(P)>
	[ASCIZ/, /]
	DISARG LOC,<-27(P)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCALL
	SYSPIN
	POPJ P,			;NOW WE JUST PRAY, HAVING SUPPRESSED THE QUEUEING
>;FTDDFSBUG
;GGRPH G1COM G2COM

; GRINNELL OP CODES
; FIRST, INTERFACE OP CODES

IFN FTGRIN,<	; WHOLE PAGE

;DISJMP←←20	; STANDARD JUMP
GGRPH←←2	; GRAPHICS COMMAND
G1COM←←4	; SINGLE GRINNEL 16-B COMMAND IN HIGH-ORDER BITS
G2COM←←14	; 2 16-BIT COMMANDS

DEFINE G2W(A,B)<BYTE(16)A,B(4)G2COM>	; GENERATES TWO-COMMAND WORD
DEFINE G1W(A)<BYTE(16)A,0(4)G1COM>	; GENERATES ONE-COMMAND WORD

>;IFN FTGRIN
;DDSTRT NEWFRM SCNLOP

;This whole page IFN FTDD!FTGRIN

; HERE LIES THE INCREDIBLE INTERRUPT-LEVEL ROUTINES!  LET THE READER BEWARE.
↑DDSTRT:SETZM DDSTART
	SKIPN DDQUE		; IS THERE ANYTHING FOR US?
IFN FTDD,<
	JRST APRADD		; NO, LEAVE NOW
>;IFN FTDD
IFN FTGRIN,<
IFN FTXADR,<
	XJEN GRNCHL		; NO, DISMIS CHANNEL AND LEAVE
>;IFN FTXADR
IFE FTXADR,<
	JEN @GRNCHL		; NO, DISMIS CHANNEL AND LEAVE
>;IFE FTXADR
>;IFN FTGRIN
	SETOM DDRUN		; WE ARE NOW OFFICIALLY RUNNING.
IFN FTDD,<
	MOVEM TAC,DDSTAC	; SAVE THE ACCUMULATORS
	MOVEM AC1,DDSAC1
	MOVEM AC2,DDSAC2
	MOVEM AC3,DDSAC3
	MOVEM DAT,DDSDAT
	EXCH P,APRPDL		; GET US A PDL TOO
	MOVEI AC3,APRADD	; WE WILL RETURN TO APRINT WHEN WE ARE DONE
	MOVEM AC3,DDRET
>;IFN FTDD
IFN FTGRIN,<
	JSR GRNSAV
>;IFN FTGRIN
	MOVE AC1,DDQUE		; REMOVE THE FIRST FRAME FROM THE QUEUE ENTIRELY
NEWFRM:	MOVE AC2,(AC1)		; PICK UP THE ADDRESS OF THE NEXT FRAME
	MOVEM AC2,DDQUE		; MAKE IT THE NEW QUEUE
	MOVEM AC1,DDCURQ	; SAVE THIS ADDRESS AS OUR CURRENT FRAME
	HRRZ TAC,QLINK(AC1)	; PICK UP THE ADDRESS OF THE FIRST TASK IN THE FRAME
SCNLOP:	HRRZ AC2,QLINK(TAC)	; PICK UP THE ADDRESS OF THE NEXT TASK
	MOVEM AC2,DDNXT		; SAVE IT FOR FUTURE REFERENCE
	HLRZ DAT,(TAC)		; PICK UP THE DATA BLOCK ADDRESS
	HRRZ AC3,(TAC)		; AND THE ROUTINE ADDRESS
	CAIL AC3,DWPINI
	CAIL AC3,WHOINI
	CAIA			;LET'S NOT JUMP TO CONTUSIONS
	JRST (AC3)		; JUMP OFF TO THE ROUTINE
IFN FTDDBG,<
	PUSH P,CHR		;IN CASE WE WANT TO LOOK AT CHR
	MOVEI DAT,DDCURQ
	PUSHJ P,DDQCH1		;SHOULDN'T EVER RETURN (UNLESS WIZARD FIXED SOMETHING)
	POP P,CHR
>;FTDDBG
IFE FTDDBG,<
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /QBLOCK/
	PUSHJ P,DISERR
	[ASCIZ/
DD TASK ADDRESS OUT OF BOUNDS.  TASK ADDRESS = /]
	DISARG LOC,<AC3-20(P)>
	[ASCIZ/
BLOCK = /]
	DISARG LOC,<TAC-20(P)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCALL
>;NOT FTDDBG
	PUSHJ P,DEQ		;FLUSH THIS TRANSFER
	JRST RESCAN		;AND SEE IF WE CAN CONTINUE
;RESCAN DDEXIT

;This whole page IFN FTDD!FTGRIN

; ALL THE I-LEVEL ROUTINES RETURN TO HERE WHEN THEY ARE DONE

RESCAN:	SKIPE TAC,DDNXT		; IS THERE ANOTHER TASK IN THIS FRAME?
	JRST SCNLOP		; YES, SERVE IT NOW.
	HRRZ AC1,DDCURQ		; PICK UP THE FRAME HEAD WE WERE WORKING ON.
	HRRZ AC2,QLINK(AC1)	; SEE IF THERE ARE ANY TASKS LEFT ON IT.
	JUMPE AC2,DDEXIT	; NO, THEY MUST HAVE ALL SUCCEEDED
	HRLI AC2,DDREQ		; YES, PUT IN A CLOCK REQUEST TO REQUEUE THEM
	PUSHJ P,AC2CLK		; THIS WAY, THEY WILL GET TRIED AGAIN
DDEXIT:	PUSHJ P,GIVQ		; RELEASE THE FRAME HEADER
	SKIPE AC1,DDQUE		; SEE IF THERE IS ANOTHER FRAME
	JRST NEWFRM		; YES, DO IT.
	SETZM DDRUN		; NO, DIE QUIETLY
IFN FTDD,<
	CONO DDD,RESET		; CLEAR OUT THE BEAST
	MOVE TAC,DDSTAC		; RESTORE ALL OUR ACCUMULATORS
	MOVE AC1,DDSAC1
	MOVE AC2,DDSAC2
	MOVE AC3,DDSAC3
	MOVE DAT,DDSDAT
	EXCH P,APRPDL
	JSR DDRTN		; RETURN TO LOSER
>;IFN FTDD
IFN FTGRIN,<
	CONO GRN,0		; CLEAR OUT THE BEAST
	POPJ P,			; WE WENT THROUGH GRNSAV, SO WE RETURN LIKE THIS
>;IFN FTGRIN
;DDREQ DDREQ1 DDREQ3 DDREQ2 PPWAKE USWKLE

;Last page under IFN FTDD!FTGRIN

; THIS ROUTINE IS CALLED AT CLOCK LEVEL WITH A LIST OF TASKS THAT
; TIMED OUT OR LOST IN SOME OBSCURE WAY. WE JUST REQUEUE THEM AND
; TRY AGAIN.

DDREQ:	HRRZ AC1,DAT		; PICK UP THE TASK LIST
DDREQ1:	HRRZ DAT,QLINK(AC1)	; GET ADDRESS OF NEXT BLOCK ON LIST
	SOSG QTIME(AC1)		; HAVE WE TRIED TOO MANY TIMES
	JRST DDREQ2		; YES, DON'T REQUE IT.
	PUSHJ P,REQBLK		; REQUE THE TASK
DDREQ3:	JUMPE DAT,CPOPJ		; IF NO MORE TASKS, LEAVE
	MOVE AC1,DAT
	JRST DDREQ1

DDREQ2:	MOVE TAC,AC1
	PUSHJ P,DEQWAK		; WAKE UP CALLER
	JRST DDREQ3
>;IFN FTDD!FTGRIN	;Many pages

;HERE FROM DEQ TO SEE IF WE NEED TO WAKE UP A JOB WAITING AT PPWAIT
PPWAKE:	MOVE AC2,QINSTR(TAC)	;GET ADDRESS OF COUNT DOWN CELL
	SKIPG AC1,JPPWAT-NPPXFR(AC2)	;GET NUMBER OF JOB TO WAKE
	JRST PPWAK2		;NONE THERE
	SETZM JPPWAT-NPPXFR(AC2);CLEAR IT
	CAIGE AC1,JOBN		;MAKE SURE LEGIT JOB NUMBER
	SKIPL JBTSTS(AC1)	;DON'T REQUE IF JOB ISN'T RUNNABLE
	JRST PPWAK2		;FORGET IT
	PUSH P,J
	MOVE J,AC1
	MOVNI AC2,RUNQ		;PUT THIS JOB IN THE RUN QUEUE
	MOVEM AC2,JOBQUE(J)
	PUSHJ P,REQUE
	POP P,J
	SKIPE JOB		;IS THE NULL JOB RUNNING?
	JRST PPWAK2		;NO.
	SYSPIFF		;YES.  GIVE CHANNEL 7 A BIG KICK - FLUSH THE NULL
	PUSHJ P,STOP2		;JOB AND RUN US.  (STOP2 TURNS ON THE PI)
	JRST PPWAK2

;HERE VIA XCT OF JRST AT DEQWAK TO RE-ENABLE DM LINE EDITOR AFTER USER DPY PROG
USWKLE:	HLRZ AC2,QFLAGS(TAC)	;GET DPY HDR ADDRESS
	MOVEI AC1,LEWAIT	;BIT TO TURN OFF NOW
	ANDCAM AC1,DMFLAG(AC2)	;LET LINE EDITOR XFERS GET THROUGH NOW
	JRST PPWAK2
;DMDEQ DEQ DEQWAK PPWAK2 DEQ2

; THIS ROUTINE TAKES A TASK OUT OF THE QUEUE AND WAKES UP ANYONE IF
; IT IS SUPPOSED TO.

↑DMDEQ:
IFN FTDDFSBUG,< SCPICK > ;CHECK PI STATUS
↑DEQ:	MOVE AC2,QLINK(TAC)	;PICK UP ADDRESS OF SUCCESSOR
	TRNE AC2,-1		;IS THERE ANYONE HOME?
	HLLM AC2,QLINK(AC2)	;YES, MAKE REVERSE LINK OF SUCCESSOR POINT TO OUR PREDECESSOR
	MOVS AC2,AC2		;SAME DEAL FOR OTHER SIDE
	TRNE AC2,-1		;ANYONE HOME?
	HLRM AC2,QLINK(AC2)	;MAKE FORWARD LINK OF PREDECESSOR POINT TO SUCCESSOR
DEQWAK:	XCT QINSTR(TAC)		;COUNT DOWN PP TRANSFER COUNT--SKIP UNLESS HIT ZERO
	 JRST PPWAKE		;COUNT JUST GOT DOWN TO ZERO
PPWAK2:	SKIPE QCOUNT(TAC)	;IS THERE A COUNT WORD SOMEWHERE?
	SOSLE @QCOUNT(TAC)	;YES, COUNT IT DOWN.
	JRST DEQ1		;NO COUNT OR COUNT NOT EXPIRED
	SKIPN AC1,QWAKE(TAC)	;PICK UP WAKEUP WORD
	JRST DEQ1		;IF NONE THERE, DON'T BOTHER
	CAIGE AC1,JOBN		;IS IT A JOB NUMBER?
	JUMPG AC1,DEQ2		;JUMP IF THIS IS A JOB NUMBER
	SYSPIFF		;THIS MUST BE A CLOCK REQUEST.  PLANT IT.
	IDPB AC1,CLKQ
	SYSPIN
	JRST DEQ1

DEQ2:	SKIPL JBTSTS(AC1)
	JRST DEQ1		;DON'T REQUE IF JOB ISN'T RUNNABLE
	HLRZ AC2,(TAC)
	HRRE AC2,PRGJMP(AC2)	;CHECK WAIT FLAG
	JUMPGE AC2,DEQ1		;NOT WAITING FOR DPY.  DON'T REQUE.
	PUSH P,J
	MOVE J,AC1
	MOVNI AC2,RUNQ		;PUT THIS JOB IN THE RUN QUEUE
	MOVEM AC2,JOBQUE(J)
	PUSHJ P,REQUE
	POP P,J
	SKIPE JOB		;IS THE NULL JOB RUNNING?
	JRST DEQ1		;NO.
	SYSPIFF		;YES.  GIVE CHANNEL 7 A BIG KICK - FLUSH THE NULL
	PUSHJ P,STOP2		;JOB AND RUN US.  (STOP2 TURNS ON THE PI)
;FALL THRU TO NEXT PAGE
;DEQ1 GIVQ DEQERR

;FELL THRU FROM PREVIOUS PAGE

DEQ1:	MOVE AC1,TAC		;AC1←TASK BLOCK ADDRESS FOR SFSGIV
GIVQ:
IFN FTDDFSBUG,<
	PUSH P,AC2
;	HLRZ AC2,-1(AC1)
;	CAIE AC2,-1		;LH OF FS WORD BETTER BE -1
;	JRST DEQERR
	SKIPL -1(AC1)		;LH OF FS WORD BETTER BE NEGATIVE
	JRST DEQERR
	HRRZ AC2,-1(AC1)	;POINTER TO ENDING FS WORD
	CAIE AC2,16(AC1)	;PROPER SIZE BLOCK?
	JRST DEQERR
	MOVE AC2,(AC2)
	CAME AC2,[400020,,0]	;PROPER ENDING FS WORD?
	JRST DEQERR		;NO
	POP P,AC2
>;FTDDFSBUG
	PUSHJ P,SFSGIV
	DDFS
	POPJ P,

IFN FTDDFSBUG,<
DEQERR:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/
BAD FS BLOCK ARGUMENT TO GIVQ.  BLOCK = AC1 = /]
	DISARG OCT,<AC1-20(P)>
	[ASCIZ/
FS BEGINNING HALF WORD OR ENDING WHOLE WORD = /]
	DISARG OCT,<AC2-20(P)>
	[ASCIZ/
CALLERS = /]
	DISARG LOC,<-22(P)>
	[ASCIZ/, /]
	DISARG LOC,<-23(P)>
	[ASCIZ/, /]
	DISARG LOC,<-24(P)>
	[ASCIZ/, /]
	DISARG LOC,<-25(P)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	POP P,AC2
	PUSHJ P,WDDTCALL
	SYSPIN
	POPJ P,			;WE SIMPLY WON'T RETURN THE BLOCK TO SPARE FS LIST
>;FTDDFSBUG
;PPXFR

IFN FTDD!FTGRIN,<	;First of many pages

; PAGE PRINTER TRANSFERS

PPXFR:	SKIPG AC1,HEDPTR(DAT)	;LET'S SEE IF THIS IS A LEGAL PP
	JRST ILLPP
	CAML AC1,SYSTOP
	CAML AC1,FSTOP
	JRST ILLPP		;GARBAGEY HEADER ADR
IFN FTDD,<			;On Grinnell, it's two masks, too much trouble.
	HLRZ AC1,PRGNUM(AC1)
	LDB AC3,[241000,,DDCW(DAT)]
	CAIE AC1,(AC3)
	JRST ILLPP		;DD CHNL DOESN'T MATCH
>;IFN FTDD
	SETZM DDSAV(DAT)	; INITIALIZE THE SAVE WORD
	SKIPE PPINV(DAT)	; IS THE TEXT VALID?
	JRST PPXFR2		; NO, FLUSH THE TRANSFER
	PUSHJ P,POSLIN		; GET NUMBER OF FIRST LINE ON PAGE IN AC3
	HLRE AC1,QLINE(TAC)	; PICK UP FIRST LINE OF TRANSFER
	CAMG AC1,VPOS(DAT)	; IS FIRST LINE OF TRANSFER BELOW CURRENT SCREEN?
	CAMGE AC1,AC3		; OR ABOVE FIRST LINE OF SCREEN?
	JRST PPXFR2		; YES, ABORT TRANSFER
	HRRE AC1,QLINE(TAC)	; SAME FOR LAST LINE OF TRANSFER
	CAMG AC1,VPOS(DAT)
	CAMGE AC1,AC3
	JRST PPXFR2
	HLRE AC3,QLINE(TAC)	; PICK UP STARTING LINE NUMBER
	SKIPG AC3		; IF IT IS ABOVE SCREEN . . .
	MOVEI AC3,1		; USE TOP OF SCREEN AS FIRST LINE
	MOVEI AC1,-1(AC3)	; GET NORMALIZED LINE NUMBER
	PUSHJ P,GLNADR		; GET LINE ADDRESS FROM LINE NUMBER
	ADD AC2,[XWD DISJMP,1]	; BUMP PAST CRLF ON LAST LINE
	MOVSM AC2,PPJMP(DAT)	; PLACE JUMP TO TEXT IN CODE
IFN FTGRIN,<
	MOVNI AC1,1(AC1)	;Make line number range from -1 to -N
	ADD AC1,PPSHGT(DAT)	;Make line number from bottom, from N-1 to 0
	MOVE AC3,HEDPTR(DAT)	;Get pointer to dpy hdr
	IMUL AC1,DCHHGT(AC3)	;Times number of scanlines per line gives Y pos
	ADD AC1,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB AC1,[POINT 10,GRCW4(DAT),31] ;Store Y pos in LLA command
;The Initial-X and Delta-X are permanent in the PP at GRCW3/4, set by PPINIT.
>;IFN FTGRIN
IFN FTDD,<
	IMULI AC1,=12
	SKIPE QFIELD(TAC)	; CHECK THE FIELD
	IORI AC1,1		; PUT IT OUT ON THE ODD FIELD THIS TIME
	DPB AC1,[POINT 4,DDCW2(DAT),23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDCW2(DAT),15]
>;IFN FTDD
	HRRE AC3,QLINE(TAC)	; PICK UP FINISHING LINE OF TRANSFER
	CAMLE AC3,PPSHGT(DAT)	; IS IT OFF THE SCREEN?
	MOVE AC3,PPSHGT(DAT)	; YES, USE THE LAST LINE ON THE SCREEN
	CAMN AC3,VPOS(DAT)	; IS THIS THE SAME AS THE VERTICAL POSITION OF THE PAGE PRINTER
	JRST PPXFR4		; YES, NO NEED TO SAVE ANY WORDS.
	ADDI AC3,1		; BUMP LINE POINTER BY ONE TO GET TO THE END OF THIS LINE
	PUSHJ P,GLNADR		; PICK UP THE ADDRESS OF THE END OF THAT LINE
	MOVE AC1,(AC2)		; PICK UP THE WORD AT THE END OF THE LINE
	MOVEM AC2,DDSPT(DAT)	; SAVE THE POINTER TO THE SAVED WORD.
	MOVEM AC1,DDSAV(DAT)	; STORE IT IN THE PAGE PRINTER CONTROL BLOCK
	MOVSI AC1,DDSAV(DAT)	; PICK UP ADDRESS OF SAVED WORD
	HRRI AC1,DISJMP		; PLACE A JUMP TO IT WHERE IT WAS IN THE BUFFER
	MOVEM AC1,(AC2)
;PPXFR1 PPXFR2 PPXFR3 PPXFR4 ILLPP

;This whole page IFN FTDD!FTGRIN

	;Fell thru
PPXFR3:	MOVEI AC1,DDCW(DAT)	; PICK UP ADDRESS OF START OF TRANSFER
IFN FTDD,<
	CONO DDD,USUAL		; SET UP THE DATA DISC
	DATAO DDD,AC1		; SEND OUT THE ADDRESS
>;IFN FTDD
	DDTIME (PPXFR)		;DO SOME TIME ACCOUNTING FOR DD XFER
	PUSHJ P,ISYNC		; WAIT FOR IT
	 JFCL
	 JRST PPXFR1		; LOSE BIG, LEAVE THE TRANSFER IN THE QUEUE
PPXFR2:	PUSHJ P,DEQ		; WIN, TAKE THE TASK OUT OF THE QUEUE
PPXFR1:
IFN FTGRIN,<
Printx PPXFR1 - Should this "no erase" business really be here for Grinnell?
>;IFN FTGRIN
	MOVSI AC1,040000	; CLEAR THE 'NO ERASE' BIT IF WE SET IT
	ANDCAM AC1,DDCW(DAT)
	SKIPE AC1,DDSAV(DAT)	; RESTORE THE SAVED WORD, IF THERE IS ANY
	MOVEM AC1,@DDSPT(DAT)
	JRST RESCAN

PPXFR4:	MOVSI AC1,040000	; IF WE ARE AT THE BOTTOM OF THE SCREEN,
	CAMN AC2,VPOS(DAT)	; THEN DON'T ERASE THE REST OF THE LINE
	IORM AC1,DDCW(DAT)	; BECAUSE WE MIGHT BE ERASING PART OF THE LINE EDITOR
	JRST PPXFR3		; THE LINE EDITOR WILL ERASE THE REST OF THE LINE ITSELF

ILLPP:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /ILLEGAL PP AT PPXFR
/
	DEBCHECK(POPACS)	; CALL DDT IF DEBUGGING
	PUSHJ P,DEQ
	JRST RESCAN
;ERASE CWAIT

;This whole page IFN FTDD!FTGRIN

;HERE IS THE ERASE CODE.  GET HERE WITH DPY HEADER IN DAT.

ERASE:	HLRE AC2,QLINE(TAC)	; PICK UP STARTING ADDRESS
	SKIPG AC2		; IS IT ABOVE THE SCREEN?
	MOVEI AC2,1		; YES, START FROM LINE 1
IFE FTGRIN,<
	MOVEI AC1,-1(AC2)	; CONVERT IT TO HARDWARE FORM
	IMULI AC1,=12
	SKIPE QFIELD(TAC)	; WHAT FIELD DOES THIS GO OUT ON?
	IORI AC1,1		; ODD FIELD
	DPB AC1,[POINT 4,DDERRS+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDERRS+1,15]
>;IFE FTGRIN
	SKIPE AC1,CURPP(DAT)	; GET POINTER TO CURRENT PIECE OF PAPER
	MOVE AC1,DDCW(AC1)	; PICK UP FUNCTION SELECT
	MOVEM AC1,DDERRS	; USE IT FOR THE ERASURE
	HRRE AC1,QLINE(TAC)	; GET ENDING LINE NUMBER
	CAMLE AC1,DPYHGT(DAT)	; IF OFF THE BOTTOM OF THE SCREEN . . .
	MOVE AC1,DPYHGT(DAT)	; THEN USE THE NUMBER OF THE LAST LINE ON THE SCREEN
IFN FTGRIN,<
;AC2 now contains number of first text line to erase, AC1 number of last (bottom).
	SKIPN AC3,CURPP(DAT)	;GET CURRENT PP
	JRST CURERR		;How come we don't have a PP address?
	MOVE AC3,GRCW2(AC3)	;Get Grinnell cmd word including background color
	TLC AC3,GRBAKB		;Change background to make write look like erase
	TLZ AC3,GRVECB		;Use rectilinear graphics
	MOVEM AC3,DDERRB	;Store in display program
	MOVN AC3,AC1		;Get negative of last line number
	ADD AC3,DPYHGT(DAT)	;Get nbr of last line from bottom (0 is bottom line)
	IMUL AC3,DCHHGT(DAT)	;Make it negative scanlines from the bottom
	ADD AC3,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB AC3,[POINT 10,DDERRL,31] ;Store vertical position of bottom of rectangle
	SUBI AC1,-1(AC2)	;Number of text lines to be erased
	IMUL AC1,DCHHGT(DAT)	;Convert to scanline count
	SUBI AC1,1		;Convert to delta-Y of top scanline from bottom one
	DPB AC1,[POINT 10,DDERRD,31] ;Store delta-Y in program
	MOVE AC1,DCHWID(DAT)	     ;Get char width in pixels
	DPB AC1,[POINT 10,DDERRL,15] ;Store as left margin (text col 1)
	MOVNI AC1,-GRWMAX+1(AC1)     ;Figure delta-X to right margin in pixels
	DPB AC1,[POINT 10,DDERRD,15] ;Store delta-X of erase
	MOVEI AC1,DDERRS	;Address of beginning of program, for ISYNC
>;IFN FTGRIN
IFN FTDD,<
	SUB AC2,AC1		;NEGATIVE OF <NUMBER OF LINES TO BE ERASED - 1>
	ADD AC2,[XWD DISJMP,DDCRLF+HGTDD-1]
	MOVSM AC2,DDERRS+2	; JUMP TO THE POSITION IN THE ERASURES THAT CORRESPONDS TO THAT MANY LINES.
	CONO DDD,USUAL
	DATAO DDD,[DDERRS]
>;IFN FTDD
	DDTIME (ERASE)		;DO SOME TIME ACCOUNTING FOR DD XFER
CWAIT:	PUSHJ P,ISYNC
	 JFCL
	 JRST RESCAN		; LOSE BIG, JUST DO ANOTHER TASK
	PUSHJ P,DEQ		; WIN, TAKE US OUT OF THE QUEUE
	JRST RESCAN		; AND GO DO SOMETHING ELSE.
;CURSOR CURNOR CURREL CDX CURS2 CURS1

;This whole page IFN FTDD!FTGRIN

; CURSOR TRANSFERS--HERE IN CH 3 WITH DAT POINTING TO DPY HEADER

CURSOR:	CAML DAT,SYSTOP		;VALID DPY HEADER ADDRESS
	CAML DAT,FSTOP
	JRST CURERR		;INVALID DPY HEADER POINTER
	HRRZ AC2,PRGNUM(DAT)	; GET LINE NUMBER
	CAIL AC2,DDL0
	CAIL AC2,DDL0+DDNUM	; IS IT A VALID DD LINE NUMBER?
	JRST CURERR		; NO!
	HRRZ AC3,LETAB(AC2)	; GET POINTER TO DPY HDR
	CAIE AC3,(DAT)		; IS DPY HDR STILL VALID?
	JRST CURERR		; NO SUCH DPY HDR ANY MORE
	MOVE AC1,[POINT 36,CURZWD-1,35]
	MOVEM AC1,CZPNT		; INITIALIZE LIST OF WORDS IN CURSOR CODE WE USED
	SKIPN AC1,CURPP(DAT)	; GET CURRENT PP
	JRST CURERR		; NONE!!!
	MOVE AC1,DDCW(AC1)	; PICK UP COMMAND WORD WITH FUNCTION SELECT IN IT
IFN FTDD,<
	TLO AC1,002000		; MAKE IT A GRAPHICS WORD
>;IFN FTDD
	MOVEM AC1,DDCURS	; AND USE IT AS OUR SELECT WORD
	HLRE AC1,QLINE(TAC)	; PICK UP LINE NUMBER OF TRANSFER
	JUMPLE AC1,CDX		; IF OUT OF BOUNDS, FORGET IT
	CAMLE AC1,DPYHGT(DAT)	; IS IT OFF THE BOTTOM OF THE SCREEN?
	JRST CDX		; YES, RESTORE CURSOR CODE AND LEAVE
IFE FTGRIN,<
	IMULI AC1,=12
	SUBI AC1,2		; BACK UP THE LINE TO BEFORE THE NEXT TEXT
	DPB AC1,[POINT 4,DDCURS+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDCURS+1,15]
>;IFE FTGRIN
IFN FTGRIN,<
	SKIPN AC2,CURPP(DAT)	;GET CURRENT PP
	JRST CURERR
	MOVE AC2,GRCW2(AC2)	;Get Grinnell cmd word including background color
	MOVEM AC2,DDCURB	;Store in display program
	SUB AC1,DPYHGT(DAT)	;Get -N where N is text line number from 0 (bottom)
	IMUL AC1,DCHHGT(DAT)	;Make it negative number of scanlines from bottom
	SUBI AC1,2		;Back up the line number
	MOVN AC1,AC1		;And make it positive number of scanline just below text
;	MOVNI AC1,1(AC1)	;Make it positive number of scanline just below text
;	MOVNI AC1,2(AC1)	;Make it positive number of scanline just below text
;PRINTX Last text line on Grinnell can't have cursors under it.  Move everything up?
	ADD AC1,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB AC1,[POINT 10,DDCURL,31] ;Store vertical position of cursor
	MOVE AC1,DCHWID(DAT)	     ;Get char width in pixels
	DPB AC1,[POINT 10,DDCURL,15] ;Store as initial X position
>;IFN FTGRIN
	HLRE AC1,QHPOS(TAC)	; PICK UP FIRST HORIZONTAL POSITION
	SKIPL AC1		; IS THERE ANY?
	PUSHJ P,CMAKE		; YES, MAKE UP CODE FOR IT
	HRRE AC1,QHPOS(TAC)	; PICK UP SECOND HORIZONTAL POSITION
	SKIPL AC1		; IS THERE ANY?
	PUSHJ P,CMAKE		; YES, COMPILE IT.
IFN FTDDKLU,<
	SKIPE DDHELP		;Wanna relocate this xfer for losing DD?
	SKIPN AC1,PDDREL	;Get FS address to relocate to
	JRST CURNOR		;Nope
	HRLI AC1,DDCURS		;Source of blt
	MOVEI AC3,LDDCUR-1(AC1)	;End address of blt
	BLT AC1,(AC3)		;Copy program into FS
	CONO DDD,USUAL
	DATAO DDD,PDDREL	;Run DD program from FS
	JRST CURREL

CURNOR:
>;IFN FTDDKLU
IFN FTGRIN,<
	MOVEI AC1,DDCURS
>;IFN FTGRIN
IFN FTDD,<
	CONO DDD,USUAL
	DATAO DDD,[DDCURS]
>;IFN FTDD
IFN FTDDKLU,<
CURREL:
>;IFN FTDDKLU
	DDTIME (CURSOR)		;DO SOME TIME ACCOUNTING FOR DD XFER
	PUSHJ P,ISYNC
	 JFCL
	 JRST CURS2		; UNFORGIVABLE LOSSAGE, TRY AGAIN LATER
CDX:	PUSHJ P,DEQ		; REMOVE US FROM THE QUEUE
CURS2:	HRRZ AC1,CZPNT		; PICK UP POINTER TO CURSOR CODE ADDRESSES
	MOVEI AC2,2		; PICK UP A BLANK GRAPHICS WORD
CURS1:	CAIGE AC1,CURZWD	; ARE WE BACK TO THE START YET?
	JRST RESCAN		; YES, GO BACK FOR ANOTHER TASK
	MOVEM AC2,@(AC1)	; NO, CLEAR OUT THIS CURSOR
	SOJA AC1,CURS1		; BACK UP FOR THE NEXT ONE, IF ANY.
;CURERR CMAKE CMAKE1 CMAKE2

;This whole page IFN FTDD!FTGRIN

CURERR:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ/
At CURSOR or ERASE with ILLEGAL DPY HEADER or zero CURPP.  DPY HDR = DAT = /]
	DISARG LOC,<DAT-20(P)>
	[ASCIZ/
BLOCK = TAC = /]
	DISARG LOC,<TAC-20(P)>
	-1
	PUSHJ P,DISCRL
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	PUSHJ P,DEQ		;FLUSH THIS TRANSFER
	JRST RESCAN		; AND GO ON

; THIS ROUTINE MAKES UP THE CODE FOR A CURSOR.
CMAKE:
IFE FTGRIN,<
	IMULI AC1,6		; CONVERT TO NUMBER OF BITS FROM LEFT MARGIN
>;IFE FTGRIN
IFN FTGRIN,<
	IMUL AC1,DCHWID(DAT)	; CONVERT TO NUMBER OF BITS FROM LEFT MARGIN
>;IFN FTGRIN
	ADDI AC1,1		; THE UNIVERSAL FUDGE FACTOR STRIKES AGAIN!
	LDB AC2,[POINT 5,AC1,35]
	LSH AC1,-5		; IT IS NOW CONVERTED TO NUMBER OF WORDS AND BITS WITHIN LAST WORD
	ADDI AC1,DDCURS+CURB	; MAKE UP POINTER TO THE GRAPHICS WORD IN QUESTION
	IDPB AC1,CZPNT		; SAVE THIS ADDRESS SO WE CAN ZERO IT WHEN WE LEAVE
	PUSHJ P,CMAKE1		; SHIFT OVER A CURSOR
	MOVNS AC2
	LSH AC3,(AC2)
	ANDCMI AC3,17		; ZERO OUT POSSIBLE OVERFLOW INTO OPCODE
	IORM AC3,(AC1)		; PUT THOSE BITS INTO THE LOCATION WE CALCULATED
	CAMLE AC2,[-=26]	; IS THERE TWO WORDS WORTH?
	POPJ P,			; NO, RETURN NOW
	ADDI AC1,1		; YES, BUMP POINTER
	IDPB AC1,CZPNT		; AND SAVE IT
	PUSHJ P,CMAKE1		; MAKE UP ANOTHER CURSOR
	LSH AC3,=32(AC2)
	IORM AC3,(AC1)		; SET IT IN PLACE
	POPJ P,

;THIS SUBROUTINE REPLACES "MOVSI AC3,360000"
;ALSO "-=26" ABOVE USED TO BE "-=28", BUT OUR CURSOR IS BIGGER
;MAKE FUNNY-LOOKING CURSOR IF IN INCHRW
CMAKE1:	HRRZ AC3,PRGNUM(DAT)	;GET TTY LINE NUMBER
	SKIPN AC3,TTYTAB(AC3)	;GET DDB
	JRST CMAKE2		;I THINK THERE HAS TO BE A DDB BUT...
	MOVE AC3,DEVIOS(AC3)
	TLNE AC3,DDTM		;THIS BIT IS ON FOR INCHRW
	SKIPA AC3,[314000,,0]	;--  --
CMAKE2:	MOVSI AC3,360000	;----
	POPJ P,
;LEXFR LEXFR4 LEXNOR LEXREL

;This whole page IFN FTDD!FTGRIN

; LINE EDITOR TRANSFERS

LEXFR:	HRRZ AC1,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	SKIPN PPENQ(AC1)	; IF ANYONE THERE, ABORT THE TRANSFER
	SKIPE PPNQT(AC1)	; IS THERE ANYTHING NOT COUNTED IN THE QUEUE
	SKIPGE LEPOS(DAT)	;IF LEYPOS IN EFFECT, DON'T WAIT FOR PP OUTPUT
	SKIPE LEINV(DAT)	; IS THE BUFFER VALID?
	JRST LEXFR2		; NO, SET 'MISSED IT' FLAG AND QUIT
	HLRE AC1,QLINE(TAC)	; PICK UP LINE NUMBER
	JUMPLE AC1,LEXFR1	; IF STARTING LINE IS ABOVE SCREEN, FORGET IT
IFE FTGRIN,<
	SUBI AC1,1		; OTHERWISE WE WILL SHOW AS MUCH AS WE CAN
	IMULI AC1,=12		; CONVERT TO DD FLAVOR LINE ADDRESS
	SKIPE QFIELD(TAC)	; WHAT FIELD DOES THIS TRANSFER WANT TO GO TO?
	IORI AC1,1		; ODD FIELD, MAKE LINE ADDRESS ODD
	DPB AC1,[POINT 4,LEBFR+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,LEBFR+1,15]
>;IFE FTGRIN
IFN FTGRIN,<
	MOVE AC2,DPYHGT(DAT)	;Get height of display
	SUB AC2,AC1		;This way we count lines from bottom, from zero
	IMUL AC2,DCHHGT(DAT)	;Times scanlines per text line is Grin line
	ADD AC2,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB AC2,[POINT 10,LEBFRL,31] ;Store starting scanline
	MOVE AC2,DCHWID(DAT)	;Get char width in pixels
	DPB AC2,[POINT 10,LEBFRD,15] ;Store X-increment per char
>;IFN FTGRIN
	MOVE AC1,FCPOS(DAT)	; PICK UP NUMBER OF CHARACTERS IN BUFFER
	MOVE AC2,PRGNUM(DAT)	; GET DPY NUMBER
	SKIPL LETAB(AC2)	; IS THE LINE EDITOR INITIALIZED?
	SETZ AC1,		; NO, NO CHARACTERS IN IT
	JUMPN AC1,LEXFR3	; IF SOME CHARACTERS THERE, WE ARE SET.
	MOVE AC1,[ASCID /  
/]
	MOVEM AC1,LEBJMP	; IF NONE, CLEAR OUT THE LINE WITH A SPACE AND A CRLF
LEXFR4:	MOVE AC1,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE AC2,DDCW(AC1)	; GET FUNCTION SELECT WORD
	MOVEM AC2,LEBFR		; USE IT FOR US
	MOVEI AC2,STRTCL	;COLUMN OFFSET (Starting column number after CR)
	SKIPGE LEPOS(DAT)
	JRST .+3		;THAT'S THE POS IF LEYPOS IN EFFECT
	ADD AC2,DPHPOS(AC1)
	ADD AC2,LNLNGT(AC1)	;ELSE FOLLOW PP
IFN FTGRIN,<
	IMUL AC2,DCHWID(DAT)	;Column times pixels per col is X position
	DPB AC2,[POINT 10,LEBFRL,15] ;Store starting X position
	MOVE AC2,GRCW2(AC1)	;Get cmd including background select
	MOVEM AC2,LEBFRB	;Store for line editor
>;IFN FTGRIN
IFE FTGRIN,<
	DPB AC2,[POINT 8,LEBFR+1,7]
>;IFE FTGRIN
IFN FTDDKLU,<
	SKIPE DDHELP		;Wanna relocate this xfer for losing DD?
	SKIPN AC1,PDDREL	;Get FS address to relocate to
	JRST LEXNOR		;Nope
	HRLI AC1,LEBFR		;Source of blt
	MOVEI AC3,LLEBFR-1(AC1)	;End address of blt
	BLT AC1,(AC3)		;Copy program into FS
	CONO DDD,USUAL
	DATAO DDD,PDDREL	;Run DD program from FS
	JRST LEXREL

LEXNOR:
>;IFN FTDDKLU
IFN FTGRIN,<
	MOVEI AC1,LEBFR
>;IFN FTGRIN
IFN FTDD,<
	CONO DDD,USUAL		; START UP THE BEAST
	DATAO DDD,[LEBFR]	; AND AWAY WE GO . . .
>;IFN FTDD
IFN FTDDKLU,<
LEXREL:
>;IFN FTDDKLU
	DDTIME (LEXFR)		;DO SOME TIME ACCOUNTING FOR DD XFER
	PUSHJ P,ISYNC
	 JRST RESCAN
	 JRST RESCAN
	JRST LEXFR1		; WIN, DEQUEUE US AND LEAVE
;LEXFR1 LEXFR2 LEXFR3

;This whole page IFN FTDD!FTGRIN

; WE GET HERE WHEN THE TRANSFER IS DONE OR ABORTED.

LEXFR2:	SETOM LEMISS(DAT)	; NOTE THAT WE MISSED THIS TRANSFER DUE TO BUFFER INVALID
LEXFR1:	MOVE DAT,CURPP(DAT)	; DEQ TAKES POINTER TO PP BLOCK IN DAT
	PUSHJ P,DEQ		; REMOVE US FROM THE QUEUE
	HRRZ AC3,LLW(DAT)	; PICK UP LAST LINE TRANSFERRED
	CAME AC3,VPOS(DAT)	; IS THE PAGE PRINTER UP TO DATE?
	SKIPE PPENQ(DAT)	; YES, IS IT BUSY NOW?
	JRST RESCAN		; UP TO DATE OR BUSY
	HRLI DAT,REFLINE	; NOT UP TO DATE AND NOT BUSY, REFRESH ITS LINE
	SYSPIFF		; PLANT A CLOCK REQUEST
	IDPB DAT,CLKQ
	SYSPIN
	JRST RESCAN

LEXFR3:	MOVEI AC1,LEBUF(DAT)	; GET THE ADDRESS OF THE LINE EDITOR TEXT
	HRLI AC1,DISJMP		; MAKE A JUMP TO IT
	MOVSM AC1,LEBJMP	; AND PUT IT IN THE STARTUP CODE
	JRST LEXFR4
;WSE WSENOR WSEREL WHOWRT WHOWR2 WHOWR4 WHOWR3 WHOWR5 WHOWR1

;This whole page IFN FTDD!FTGRIN

; WHOLE SCREEN ERASURE AND AVAILABLE MESSAGE

WSE:	MOVE DAT,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
IFE FTGRIN,<
	MOVE AC2,DDCW(DAT)	; GET FUNCTION SELECT WORD
	MOVEI AC3,13		; MAKE IT INTO AN ERASE REQUEST
	MOVEM AC2,WSERC+1	; PUT DOWN NORMAL COPY FIRST
	TLNE AC2,(1B5)		; WHAT FLAVOR?
	IORI AC3,4
	DPB AC3,[POINT 8,AC2,7]
	MOVEM AC2,WSERC
>;IFE FTGRIN
IFN FTGRIN,<
	MOVE AC2,DDCW(DAT)	;Get channel select word
	MOVEM AC2,WSERC		;Store for erase
	MOVE AC2,GRCW2(DAT)	;Get background color
	MOVEM AC2,WSERCB	;Store for erase
>;IFN FTGRIN
IFN FTDDKLU,<
	SKIPE DDHELP		;Wanna relocate this xfer for losing DD?
	SKIPN AC1,PDDREL	;Get FS address to relocate to
	JRST WSENOR		;Nope
	HRLI AC1,WSERC		;Source of blt
	MOVEI AC3,LWSERC-1(AC1)	;End address of blt
	BLT AC1,(AC3)		;Copy program into FS
	CONO DDD,USUAL
	DATAO DDD,PDDREL	;Run DD program from FS
	JRST WSEREL

WSENOR:
>;IFN FTDDKLU
IFN FTGRIN,<
	MOVEI AC1,WSERC
>;IFN FTGRIN
IFN FTDD,<
	CONO DDD,USUAL
	DATAO DDD,[WSERC]
>;IFN FTDD
IFN FTDDKLU,<
WSEREL:
>;IFN FTDDKLU
	DDTIME (WSE)		; DO SOME TIME ACCOUNTING FOR DD XFER
	JRST CWAIT		; GO WAIT FOR TRANSFER AND LEAVE


; HERE IS THE WHO LINE ROUTINE.

WHOWRT:	MOVE AC1,QHPOS(TAC)	; PICK UP SAVED DPY NUMBER
IFE FTGRIN,<
	CAIE AC1,DDAVLU		;AVAILABLE CHANNEL?
	JRST WHOWR2		;NO
>;IFE FTGRIN
IFN FTGRIN,<
	TLNN AC1,-1		;WANT AVAILABLE MSG ON THIS GRINNELL SCREEN?
	JRST WHOWR2		;NO
>;IFN FTGRIN
	MOVEI DAT,AVLWHO	;GET PTR TO DD PROG
	MOVE AC1,AVLVP		;GET DD CW OR GRIN GW TO RANDOM POSITION ON SCREEN
IFN FTGRIN,<
	MOVEM AC1,POSOFF(DAT)	;PUT IN THE GRIN POSITION WORD
	MOVE AC2,QHPOS(TAC)	;Get TTY number again
	SKIPN LETAB(AC2)	;This Grinnell in use?
	SKIPE GRASUP-DDL0(AC2)	;No, but is its avail msg output suppressed?
	JRST WHOWR1		;Yes to one of these, don't put out avail msg
	MOVE AC1,GRCHAN-DDL0(AC2) ;Get select word for this screen
	MOVEM AC1,GWCOFF(DAT)	;Store screen select in program
	JRST WHOWR5
>;IFN FTGRIN
IFN FTDD,<
	JRST WHOWR3
>;IFN FTDD

WHOWR2:	SKIPN FRETAB(AC1)	; IS OUR FREE STORAGE STILL HERE?
	JRST WHOWR1		; NO, EXIT NOW
IFN FTDD,<
	MOVE AC1,WHFILE+1(DAT)
	TRNE AC1,1		;IF THIS WORD IS TEXT,
	JRST WHOWR4		;THEN NO LINE ADDRESS TO DIDDLE
	MOVE AC1,WHFDD+1
	SKIPE QFIELD(TAC)
	IORI AC1,1B23		;SET TO PROPER FIELD
	MOVEM AC1,WHFILE+1(DAT)
WHOWR4:	MOVE AC1,[CW 3,2,4,0,5,0]
WHOWR3:	SKIPE QFIELD(TAC)
	IORI AC1,1B23
	MOVEM AC1,POSOFF(DAT)	; PUT IT IN THE DD PROG (GRINNELL ALREADY HAS IT)
>;IFN FTDD
WHOWR5:	MOVEI AC1,RETOFF(DAT)	; PUT RETURN ADDRESS INTO SYSTEM WHO LINE DPY CODE
	HRLM AC1,DDDRET
IFN FTGRIN,<
	MOVEI AC1,(DAT)
>;IFN FTGRIN
IFN FTDD,<
	CONO DDD,USUAL
	DATAO DDD,DAT
>;IFN FTDD
	DDTIME (WHOWRT)		;DO SOME TIME ACCOUNTING FOR DD XFER
	PUSHJ P,ISYNC
	 JFCL
	 JFCL
IFN FTDD,<
	MOVE AC1,QHPOS(TAC)	; GET DPY NBR/AVL CODE BACK
	CAIE AC1,DDAVLU		; ARE WE DOING THE AVL CHN?
	JRST WHOWR1		; NO
	MOVSI AC2,20000		; YES, TURN OFF ERASE BIT IN CW
	ANDCAM AC2,(DAT)
>;IFN FTDD
WHOWR1:	PUSHJ P,DEQ
	AOS WHOPTR		;COUNT ANOTHER FIELD DONE.
	JRST RESCAN
;POG POG0 POG1 POGCLK  -  USER DATA DISC PROGRAM

;This whole page IFN FTDD!FTGRIN

POG:
IFN FTDD,<
	PUSH P,J
	HLRZ AC1,QHPOS(TAC)		;RELATIVE ADR OF CELL TO SET FIELD
	SKIPE AC1			;SKIP IF NONE
	PUSHJ P,POGX1
IFN FTDDDM,<
	MOVE J,QWAKE(TAC)
	PUSHJ P,DDMPXS			;SET UP MAPPIPLEXOR FOR USER MODE DD XFER
>;IFN FTDDDM
	POP P,J
>;IFN FTDD
IFN FTGRIN,<
	SKIPN AC1,CURPP(DAT)		; PICK UP A PAGE PRINTER BLOCK
	JRST POGRT			; NONE ?!?? PROBABLY MONITOR ERROR
	MOVE AC2,DDCW(AC1)		; PUT THIS STUFF IN POG HEADER
	MOVEM AC2,GPOGH			; THIS SETS UP THINGS LIKE CHAN. SEL.
	MOVE AC2,GRCW2(AC1)		; LEB, AND LLB
	MOVEM AC2,GPOGH+1		; FIELD, WRITE MODE, ETC
	MOVE AC2,GRCW3(AC1)
	MOVEM AC2,GPOGH+2
	MOVE AC2,GRCW4(AC1)
	MOVEM AC2,GPOGH+3
	MOVEI AC1,GPOGH
	PUSHJ P,ISYNC			; NOW RUN THIS THROUGH
	 JFCL				; ERROR
	 JFCL				; TIME OUT

REPEAT 0,<	; THIS IS DONE BY GMSEL PSEUDO-INSTRUCTION NOW
	MOVE AC1,PGFLAG(DAT)		; PICK UP SIMULATOR FLAGS
	TLNE AC1,UPSIII
	 SETOM GIII			; SIMULATING III
	TLNN AC1,UPGRIN!UPSIII		; DOING GRINNEL OR III?
	 SETOM GDD			; NO, MUST BE DATA DISC
>;REPEAT 0
	MOVEI AC1,PGCALL(DAT)		; PICK UP DISPATCH TO POG
>;IFN FTGRIN
IFN FTDD,<
	MOVEI AC1,PRGCW(DAT)		;ABSOLUTE ADDRESS OF START OF PROGRAM
	CONO DDD,USUAL!DDUSRM		;SET USER MODE BIT, ALLOWS FIRST CHN SEL
	DATAO DDD,AC1			;SEND IT OUT
>;IFN FTDD
	DDTIME (POG)			;DO SOME TIME ACCOUNTING FOR DD XFER
	PUSHJ P,ISYNCU			;WAIT FOR IT
	 JFCL				;DD ERROR
	 JFCL				;TIMED OUT
POGRT:	PUSH P,J
	MOVE J,QWAKE(TAC)
IFN FTDDDM,<
	PUSHJ P,DDMPXX			;TURN OF MAPPIPLEXOR MAPPING DATA DISK
>;IFN FTDDDM
IFN FTDD,<
	SOS JBTGLU(J)
IFN FTSTAT,< PUSHJ P,GLUSTT >
>;IFN FTDD
	HRRZ AC2,QHPOS(TAC)		;ADR OF USER'S COUNT CELL
	SKIPE AC2			;SKIP IF NONE.
	PUSHJ P,POGX2			;DECREMENT USER'S COUNT CELL
	MOVE AC2,PRGCNT(DAT)
	SOJG AC2,POG0			;JUMP IF THIS IS NOT THE LAST TRANSFER

	CACHE (CSHDD)

POG0:	POP P,J
	SKIPN DPRLSF(DAT)		;ARE WE A DETACHED JOB?
	JRST POG1			;NO, LEAVE
	MOVE AC2,PRGCNT(DAT)
	SOJG AC2,POG1			;JUMP IF THIS IS NOT THE LAST TRANSFER
	MOVEI AC1,(DAT)			;ADDRESS OF DPY PROGRAM HEADER TO GIVE BACK
	HRLI AC1,POGCLK			;(RETURN IT AT CLOCK LEVEL)
	SYSPIFF
	IDPB AC1,CLKQ
	SYSPIN
POG1:	PUSHJ P,DEQ			;REMOVE THE TASK
	JRST RESCAN

POGCLK:	HRRZ AC1,DAT			;RETURN PROGRAM HEADER ITSELF
	PUSHJ P,FSGIVE
	POPJ P,				;PLEASE DON'T OPTIMIZE!
;PPSTAR POGX1 POGX2

;This whole page IFN FTDD!FTGRIN

;ROUTINE TO PRINT 'PAGE PRINTER HOLDING' MESSAGE

PPSTAR:	MOVE AC1,DDCW(DAT)
IFN FTDD,<
	TLO AC1,40000		;TURN ON NO-ERASE BIT IN FUNCTION WORD
>;IFN FTDD
	MOVEM AC1,DDSTRS
IFN FTDD,<
	MOVEI AC1,0
	SKIPE QFIELD(TAC)
	MOVEI AC1,1		;SET LINE ADDRESS ODD
	DPB AC1,[POINT 1,DDSTRS+1,23]
	CONO DDD,USUAL
	DATAO DDD,[DDSTRS]
>;IFN FTDD
IFN FTGRIN,<
	MOVE AC1,GRCW2(DAT)	;Get Grinnell cmd specifying background
	MOVEM AC1,DDSTRB	;Store in program
	MOVE AC1,PPSHGT(DAT)	;Get screen height in text lines
	SUBI AC1,3		;Down to 3rd screen line (count from bottom)
	MOVE AC2,HEDPTR(DAT)	;Get pointer to dpy hdr
	IMUL AC1,DCHHGT(AC2)	;Convert to scanlines
	ADD AC1,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB AC1,[POINT 10,DDSTRL,31] ;Store in stars program
	MOVE AC1,DCHWID(AC2)	;Get char width in pixels
	DPB AC1,[POINT 10,DDSTRD,15] ;Store delta-X per char
	DPB AC1,[POINT 10,DDSTRL,15] ;Store initial X (skip one text col)
	MOVEI AC1,DDSTRS	;PROGRAM ADDRESS
>;IFN FTGRIN
	DDTIME (PPSTAR)		;DO SOME TIME ACCOUNTING FOR DD XFER
	JRST CWAIT

IFN FTDD,<
POGX1:	MOVE J,QWAKE(TAC)	;STORE CORRECT FIELD FOR 2-FIELD XFER
	PUSHJ P,MAPSET
	HLRZ AC1,QHPOS(TAC)
	HRLI AC1,140100		;MAKE BYTE PNTR TO FIELD BIT
	MOVE AC2,QFIELD(TAC)
	XCTR XDB,[DPB AC2,AC1]	;STORE FIELD
	POPJ P,			;RETURN, RESTORING MAP
>;IFN FTDD

POGX2:	PUSHJ P,MAPSET		;HERE TO DECREMENT USER'S COUNT CELL
	XCTR XRW,[SOS (AC2)]
	POPJ P,			;RETURN TO CALLER AFTER RESTORING MAP
;ISYNCU ISYNC DDISM DDINT DDINT2

;This whole page IFN FTDD!FTGRIN

; ALL TRANSFERS COME BACK TO HERE WHEN THEY ARE DONE OR TIMED OUT

;HERE IMMEDIATELY AFTER STARTING TRANSFER.
ISYNCU:	SKIPA AC3,[24]		; USER DD PROGRAM GETS LONGER TIMEOUT (slower mem)
ISYNC:	MOVEI AC3,6		; TIMEOUT IF NO INTERRUPT IN THIS MANY TIX
IFN FTGRIN,<
	POP P,GIDSP		; SEPARATE RETURN ADDRESS
>;IFN FTGRIN
IFE FTGRIN,<
	POP P,DDDSP		; SAVE RETURN ADDRESS
>;IFE FTGRIN
IFN FTGRIN,<
	HRRZM AC1,GRNADR	; STARTING ADDRESS FOR PROGRAM
>;IFN FTGRIN
	MOVEM AC3,DDCNT		; STORE IN THE COUNT WORD
	MOVEM DAT,DDCUR		; SAVE CONTROL BLOCK ADDRESS
	MOVEM TAC,DDCURT	; SAVE TASK BLOCK ADDRESS TOO.
IFN FTDDTIME,<
	MOVEM AC2,DDTYPE	;REMEMBER TYPE OF TASK
	MOVE AC1,UPTIME
	SUB AC1,QACCT(TAC)	;MINUS TIME WHEN TASK WAS QUEUED
	ADDM AC1,DDTOT(AC2)	;COUNT LENGTH OF TIME BEFORE XFER GOT STARTED
	CAMLE AC1,DDMAX(AC2)	;IS THIS THE LONGEST DELAY FOR THIS TYPE OF XFER?
	MOVEM AC1,DDMAX(AC2)	;YES
	AOS DDNBR(AC2)		;COUNT A TRANSFER OF THIS TYPE
>;IFN FTDDTIME
IFN FTGRIN,<
	JRST GRNSIM		; NOW GO SIMULATE EVERYTHING IN THE BOOK
>;IFN FTGRIN
DDISM:
IFN FTDD,<
	MOVE DAT,DDSDAT		; RESTORE ACCUMULATORS
	MOVE AC1,DDSAC1
	MOVE AC2,DDSAC2
	MOVE AC3,DDSAC3
	MOVE TAC,DDSTAC
	EXCH P,APRPDL		; RESTORE THE PDL
	JSR DDRTN		; AND RETURN TO WHEREVER
>;IFN FTDD
IFN FTGRIN,<
	POPJ P,			; RESTORE ACS AND DISMIS
>;IFN FTGRIN

↑DDINT:
IFN FTDD,<
	CLRPCP (CH3PCP)		;FROM CH3, TURN OFF PREV CONTEXT PUBLIC
	SKIPN DDRUN
	JRST DDILL
	MOVEM AC3,DDSAC3	; SAVE ONE ACCUMULATOR
	MOVEI AC3,DDIXIT	; MAKE US RETURN THROUGH CH3 NEXT TIME OUT
	MOVEM AC3,DDRET		; SO WE CAN RE-ENABLE THE CHANNEL
	MOVE AC3,DDDSP		; PICK UP RETURN ADDRESS
	EXCH PID,APRID		; PICK UP PROCESSOR IDENTIFICATION
	CONSZ DDD,DDNXM
	JRST DDNX
	CONSO DDD,LOSE		; DID DD MISS A WORD FROM MEMORY?
	JRST DDINT1		; NO, GO AHEAD
	AOS NDDLUZ		;COUNT A DD DATA MISS
DDINT2:	CONO DDD,RESET		; YES, STOP IT AMID-TRANSFER
	JRST DDCMR
>;IFN FTDD
IFN FTGRIN,<
	JSR GRNSAV		; DUMP ACS, GET A STACK
	MOVEI AC3,2		;ALL OK, GO ON
GRNGO:	ADD AC3,DDDSP		; PICK UP RETURN ADDRESS
	HRLOI AC2,377777	;SET COUNT TO MAXIMUM WHEN NO TRANSFER IN PROGRESS
	MOVEM AC2,DDCNT
	JRST (AC3)		;RETURN TO LOSER
>;IFN FTGRIN
;DDNX DDINT1 DDCMR DDCLK DDIXIT DDIXI1

;This whole page IFN FTDD!FTGRIN

; DATA DISC NON-EX MEM TYPEOUT, ACCUMULATOR SAVER, AND CLOCK TIMEOUT ROUTINES

IFN FTDD,<
DDNX:	AOS NDDNXM		;COUNT A DD NXM
IFN FTDDDM,<
	SKIPE MPXDDR		;WAS THIS EXPECTED FROM MPXINT?
	JRST DDINT2		;FOR NOW, JUST RESET DDD AND GIVE ERROR RETURN
>;IFN FTDDDM
	EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /DATA DISC NON-EX MEM
/]
	-1
	POPACS
	EXCH P,APRPDL
	JRST DDINT2


DDINT1:	ADDI AC3,2		;ALL OK, BUMP RETURN ADDRESS TO SUCCESS RETURN
DDCMR:	MOVEM DAT,DDSDAT	;SAVE THE REST OF THE ACCUMULATORS
	MOVEM TAC,DDSTAC
	MOVEM AC1,DDSAC1
	MOVEM AC2,DDSAC2
	EXCH P,APRPDL
IFN FTDDTIME,<
	MOVE AC2,DDTYPE		;GET BACK TYPE OF TASK JUST FINISHED
	MOVE TAC,DDCNT		;REMAINDER OF ALLOCATED TIME
	ADDM TAC,DDREST(AC2)	;REMEMBER TYPICAL UNUSED TIME
>;IFN FTDDTIME
	MOVE DAT,DDCUR		;PICK UP ADDRESS OF CONTROL BLOCK
	MOVE TAC,DDCURT		;PICK UP ADDRESS OF TASK BLOCK
	HRLOI AC2,377777	;SET COUNT TO MAXIMUM WHEN NO TRANSFER IN PROGRESS
	MOVEM AC2,DDCNT
	JRST (AC3)		;RETURN TO LOSER
>;IFN FTDD

;GET HERE IN CH3 FROM APRINT WHEN DDCNT HAS COUNTED DOWN
↑DDCLK:
IFN FTDD,<
	MOVEM AC3,DDSAC3	;STORE THIS ACCUMULATOR
	MOVEI AC3,APRADD	;MAKE US RETURN TO APRSER
	MOVEM AC3,DDRET		;NEXT TIME OUT
	MOVE AC3,DDDSP		;PICK UP RETURN ADDRESS
	ADDI AC3,1		;BUMP BY ONE TO NOTE THAT CLOCK TIMEOUT HAS HAPPENED
	CONO DDD,RESET		;TIMED OUT, MUST BE HUNG. CLEAR IT OUT.
	AOS NDDCLK		;COUNT A DD TIMEOUT
	JRST DDCMR

DDIXIT:	EXCH PID,APRID		;RESTORE PID
DDIXI1:

	MTRCOF (CH3,P2NOCK)

IFN FTXADR,<
	XJEN DPYCHL		;DISMISS
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@DPYCHL		;DISMISS
>;IFE FTXADR
>;IFN FTDD
IFN FTGRIN,<
	JSR GRNSAV
	MOVEI AC3,1		; NOTE TIMEOUT
	JRST GRNGO
>;IFN FTGRIN
;⊗ DDILL DDILL2

;This whole page IFN FTDD!FTGRIN

; WE GET HERE IF WE GET AN INTERRUPT FROM THE DATA DISK AND
; OUR MAGIC FLAG INDICATES THAT NO TRANSFER WAS IN PROGRESS.

DDILL:
IFN FTDD,<
	AOSE NDDILL		;print only once, but keep counting
	JRST DDILL2
	EXCH P,APRPDL		; GET A PUSHDOWN LIST
	PUSHACS
>;IFN FTDD
IFN FTGRIN,<
	JSR GRNSAV
>;IFN FTGRIN
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES		; GIVE HARDWARE PEOPLE NASTY MESSAGE!
IFN FTDD,<
	ASCIZ/Unexpected Data Disc interrupt!
/
	POPACS			; RESTORE OUR ACCUMULATORS
	EXCH P,APRPDL		; RESTORE P
DDILL2:	CONO DDD,RESET		; CLEAR ITS MIND
	JRST DDIXI1
>;IFN FTDD
IFN FTGRIN,<
	ASCIZ/Unexpected Grinnell Interrupt!!!
/
	POPJ P,
>;IFN FTGRIN
>;IFN FTDD!FTGRIN	;Last of many pages.
;GSENDC GSEND1 GSEND2 GSENDZ GSENDY

; MACROS FOR GRINNELL TRANSFERS

IFN FTGRIN,<	; WHOLE PAGE AND MANY PAGES TO COME

DEFINE GSCALE(AC) <	; CONVERTS III COORDINATE TO GRINNELL
	ASH AC,-1	; DROP IT DOWN TO 512X (NOT NECC FOR 1024X)
	ADD AC,GOFF	; MAKE IT UPPER LEFT ORIGIN
	AND AC,GMASK	; PICK OUT THE RIGHT BITS
>

DEFINE GSEND(AC) <
	MOVEM AC,GCOM		;Store command
	JSP AC1,GSENDC		;Send a command
>


;Call here with JSP AC1,GSENDC using GSEND macro defined above.
GSENDC:	MOVEM AC1,GSENDX	;Save return address
	CONSO GRN,100		; 0 - FIFO full?
	  JRST GSEND2		; 1 - No, send cmd now
	CONO GRN,10!GRNCHN	; 2 - ENABLE INTERRUPTS
	MOVEI AC1,GSEND1	; 3
	MOVEM AC1,DDDSP		; 4
	JRST DDISM		; 5 - RESTORE ACS AND RETURN
GSEND1:	 JFCL			; 6 - ERROR RETURNS
	 SETOM GTMO		; 7 - TIMEOUT ?!??
GSEND2:	DATAO GRN,GCOM		; 8 - SEND OUT NEXT COMMAND
	JRST @GSENDX		;Return

;Faster version that takes more space if thing to send is in an AC (or takes
;a literal
DEFINE GSENDF(MEM) <
IFIDN<MEM><AC1><
	MOVEM AC1,GCOM
	CONSZ GRN,100
	  JSP AC1,GSENDY
	DATAO GRN,GCOM
    JSP AC1,GSENDC		; USE STANDARD ROUTINE UNTIL FIFOs ARE FIXED
>;IFIDN
IFDIF<MEM><AC1><
	CONSZ GRN,100
	  JSP AC1,GSENDZ
	DATAO GRN,MEM
>;IFDIF
>;DEFINE GSENDF

GSENDZ:	MOVEM AC1,GCOM		;Save return address
	MOVE AC1,@(AC1)		;Fetch thing we wanted
	EXCH AC1,GCOM		;Get back return address and save thing to send
GSENDY:	AOJA AC1,GSENDC		;Minor variation
;GRNSIM GRNSI1 GRNLOP

; WHOLE PAGE UNDER IFN FTGRIN

; WE ENTER HERE FROM ISYNC WITH THE PROGRAM STARTING ADDRESS IN GRNADR
; THE ADDRESS OF THE CALLER OF ISYNC SHOULD BE IN GIDSP
; WE RETURN THROUGH GHALT ON THE NEXT PAGE

; THE WAY THIS THING WORKS MAY SEEM A BIT CURIOUS, BUT WE DO EVERYTHING
; IN III COORDINATES (ZERO AT THE CENTER, -1000,-1000 LOWER LEFT CORNER,
; 777,777 IS UPPER RIGHT CORNER). THE REASON IS THAT IT MAKES INTERPRETING
; III BUFFERS EASIER, AND IT ALSO PRESERVES THE 10-BIT COORDINATE SYSTEM
; FOR WHEN WE GET THE 1024X1024 SYSTEM IN AND WORKING.

; WE ASSUME THAT THIS IS DIRECT GRINNELL CODE, UNLESS GIII OR GDD IS ON,
; THEN WE ASSUME IT IS III OR DD CODE AND DO THE BEST WE CAN.

GRNSIM:	SETZ AC1,
	GSCALE(AC1)
	MOVEM AC1,GSEA
	ADDI AC1,G.LEA		; NORMALIZE THE DEVICE TO (0,0) (MIDDLE OF SCREEN)
	GSEND(AC1)

	SETZ AC1,
	GSCALE(AC1)
	MOVEM AC1,GSLA
	ADDI AC1,G.LLA
	GSEND(AC1)

	SETZM GVECS
	SETZM GFIII
	SETZM GLMODE
	SETZM GXPOS
	SETZM GYPOS
	SETZM GTMO

	SETZM GENX		; INITIALIZE DD SIMULATOR
	SETZM GNOSP
	SETOM GDARK
	SETZM GDHEI
	SETZM GDWID
	SETZM GTEXT
	SETZM GADD
	SETZM GNEEDC		; DON'T YET NEED CLEAR TO END OF LINE

; MAIN INTERPRETATION LOOP

GRNLOP:	MOVE AC2,@GRNADR	; PICK UP COMMAND WORD
	AOS GRNADR		; BUMP IT

	TRNE AC2,1		; TEXT WORD?
	JRST GRNCHR		; YES, HANDLE IT SEPARATELY

; FALLS INTO NEXT PAGE
;GRSDSP GRNILL GRNJM0 GRNJMP GHALT WLVW ISABS WSVW IIISV GSHV GCOM1 GCOM2 GRNPAR GRNPDS $GMSEL $GMSII

; WHOLE PAGE UNDER IFN FTGRIN

; PREVIOUS PAGE FALLS IN HERE
; HERE WE KNOW WE ARE NOT A CHARACTER WORD

	SETZM GLMODE
	LDB DAT,[POINT 3,AC2,34] ;Get opcode excluding low-order bit, which is off
	JRST @GRSDSP(DAT)	;Dispatch to appropriate routine

;Dispatch table for bits 32:34 of display word (B35=0)
GRSDSP:	GRNJM0		;0 is JUMP (20) or HALT (00)
	WSVW		;2 is short vector or graphics word
	GCOM1		;4 is one-command word or DD command word
	WLVW		;6 is long vector (if ¬DD simulator)
	GRNPAR		;10 is various mode-status setting things
	GRNLOP		;12 is a no-op
	GCOM2		;14 is two-command word, a DD command word, or a III nop
	WLVW		;16 is undefined, but some people think it is a long vector

;We'll keep this we're sure the system doesn't generate any bad stuff!
PRINTX This Illegal Display Opcode error should be flushed; users can do anything.
GRNILL:	MOVEM AC2,GTMP		; SAVE THE BAD WORD
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF MSG ON CTY
	 SIXBIT /GRNLOP/
	PUSHJ P,DISERR
	DISARG STR,[ASCIZ /Illegal Display Opcode.  Display word = /]
	DISARG OCH,GTMP
	DISARG STR,[ASCIZ /  Addr+1 = /]
	DISARG ADR,GRNADR	; HAS ALREADY BEEN INCREMENTED AT GRNLOP
	DISARG STR,[ASCIZ /
/]
	-1

;	PUSHJ P,DISFLU		; LET'S FORCE PRINTOUT, BUT NO STOP
	POPACS
;	PUSHJ P,WDDTCA
	JRST GRNLOP

;Here for opcode 0 or 20.
GRNJM0:	TRNN AC2,20		;20 is a jump
	JRST GHALT		;But 0 is a halt.
GRNJMP:	HLRZ DAT,AC2		; PICK UP ADDRESS (18B FOR NOW)
	MOVEM DAT,GRNADR
	JRST GRNLOP		; PICK UP NEW INSTRUCTION

GHALT:	MOVE DAT,DDCUR		;PICK UP ADDRESS OF CONTROL BLOCK
	MOVE TAC,DDCURT		;PICK UP ADDRESS OF TASK BLOCK
	HRLOI AC3,377777	;SET COUNT TO MAXIMUM WHEN NO TRANSFER IN PROGRESS
	MOVEM AC3,DDCNT
	SETZM GIII		; CLEAR MODE SELECTS
	SETZM GDD
	MOVE AC3,GIDSP		; PICK UP CALLER'S ADDRESS
	ADDI AC3,2		; ASSUME NORMAL RETURN
	SKIPE GTMO		; TIMEOUT?!??
	SUBI AC3,1		; YES, GIVE ERROR RETURN
	JRST (AC3)		; RETURN TO CALLER OF ISYNC

WLVW:	SKIPE GDD		;Long vector word only if Grinnell or III simulator
	JRST GRNILL		;Not legal in DD program
	LDB AC1,[POINT 11,AC2,10]
	TRNE AC1,2000		; PICK OUT X COORDINATE
	ORCMI AC1,1777		; AND EXTEND SIGN
	LDB TAC,[POINT 11,AC2,21]
	TRNE TAC,2000		; THIS IS Y COORDINATE
	ORCMI TAC,1777
	TRNE AC2,100		; ABSOLUTE VECTOR?
	JRST ISABS		; YES
	ADD AC1,GXPOS		; MAKE EVERYTHING ABSOLUTE
	ADD TAC,GYPOS
ISABS:	LDB DAT,[POINT 2,AC2,31]
	JRST MAKEV

WSVW:	SKIPE GIII		; SIMULATING III?
	  JRST IIISV		; YES - IS SHORT VECTOR WORD
	MOVEM AC2,GTMP		; SAVE IT
	SKIPN GDD		; SIMULATING DD?
	  JRST GRNGRF		; NO - ASSUME EB IS SET CORRECTLY
	MOVEI AC2,=8		; DD DOES IT DIRECTLY, 8 BITS PER BYTE
	CAMN AC2,GSEB		; IS IT CORRECT ALREADY?
	  JRST GRNGRF		;   YES - DON'T SET IT AGAIN.
	MOVEM AC2,GSEB		; REMEMBER WHAT WE SET IT TO
	ADDI AC2,G.LEB
	GSENDF AC2
GRNGRF:	LDB AC2,[POINT 8,GTMP,7]; GRINNELL AND DD BOTH HAVE GRAPHICS WORDS
	ADDI AC2,G.WGD		; WRITE GRAPHIC DATA
	GSENDF AC2
	LDB AC2,[POINT 8,GTMP,15]
	ADDI AC2,G.WGD		; WRITE GRAPHIC DATA
	GSENDF AC2
	LDB AC2,[POINT 8,GTMP,23]
	ADDI AC2,G.WGD		; WRITE GRAPHIC DATA
	GSENDF AC2
	LDB AC2,[POINT 8,GTMP,31]
	ADDI AC2,G.WGD		; WRITE GRAPHIC DATA
	GSENDF AC2
	MOVE AC1,GSEB		; PICK UP HORIZONTAL UPDATE
	ASH AC1,2		; MAKE IT FOR FOUR GRAPHICS BYTES
	MOVEI AC2,(AC1)
	AND AC2,GMASK		; ONLY 9 BITS PLEASE
	ADDM AC2,GSEA		; AND OUR IDEA OF THE EA REGISTER
	ASH AC1,1		; CONVERT TO III COORDINATES
	ADDM AC1,GXPOS		; AND UPDATE OUT POSITION
	JRST GRNLOP

IIISV:	LDB AC1,[POINT 7,AC2,6]
	TRNE AC1,100		; SIGN EXTEND IT
	ORCMI AC1,77
	LDB TAC,[POINT 7,AC2,13]
	TRNE TAC,100
	ORCMI TAC,77
	ADD AC1,GXPOS
	ADD TAC,GYPOS		; MAKE IT ABSOLUTE
	LDB DAT,[POINT 2,AC2,15]
	MOVEM AC2,GTMP
	SETOM GRTN		; SET UP COROUTINE
	JRST MAKEV		; MAKE UP FIRST VECTOR

GSHV:	SETZM GRTN
	LDB AC1,[POINT 7,GTMP,22]	; PICK OUT X COORDINATE
	TRNE AC1,100		; SIGN EXTEND IT
	ORCMI AC1,77		; IF NEGATIVE
	LDB TAC,[POINT 7,GTMP,29]
	TRNE TAC,100		; LIKEWISE FOR Y COORDINATE
	ORCMI TAC,77
	ADD AC1,GXPOS		; ADD INTO POSITION
	ADD TAC,GYPOS
	LDB DAT,[POINT 2,GTMP,31]
	JRST MAKEV		; GO GENERATE VECTOR

GCOM1:	SKIPE GDD		; SIMULATING DD?
	  JRST GCDD		; YES
	LDB AC1,[POINT 16,AC2,15]
	JSP AC3,GPCHK		; CHECK FOR CHANGING X/Y POSITION
	GSEND(AC1)
	JRST GRNLOP

GCOM2:	SKIPE GIII
	  JRST GRNLOP		; RESTORE - TREAT LIKE NOP FOR NOW
	SKIPE GDD
	  JRST GCDD
	LDB AC1,[POINT 16,AC2,15]
	MOVEM AC2,GTMP
	JSP AC3,GPCHK		; CHECK FOR CHANGING X/Y POSITION
	GSEND(AC1)
	LDB AC1,[POINT 16,GTMP,31]
	JSP AC3,GPCHK		; CHECK FOR CHANGING X/Y POSITION
	GSEND(AC1)
	JRST GRNLOP

; GRNPAR - OPCODE 10 - MULTI-PORPOISE OPCODE
; HAS SUB-OPCODE IN BITS 27-31, REST OF WORD IS DATA
; OP 0 - ILLEGAL (JUST TO KEEP JOKERS OUT)
; OP 1 - GMSEL - MODE SELECT, BITS IN LH (UPSIII AND UPGRIN BITS)
; OTHERS ILLEGAL FOR NOW

GRNPAR:	LDB DAT,[POINT 5,AC2,31]	; PICK UP SUB-OPCODE
	JRST @GRNPDS(DAT)		; DISPATCH

GRNPDS:	GRNILL ↔ $GMSEL ↔ GRNILL ↔ GRNILL	; 0-3
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 4-7
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 10-13
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 14-17
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 20-23
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 24-27
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 30-33
	GRNILL ↔ GRNILL ↔ GRNILL ↔ GRNILL	; 34-37

$GMSEL:	SETZM GIII	; RE-INITIALIZE MODE CELLS
	SETZM GDD
	TLNE AC2,UPSIII		; SWITCHING TO III MODE?
	 JRST $GMSII
	TLNN AC2,UPGRIN
	 SETOM GDD
	MOVE AC2,GLLWM
	TRNN AC2,G.WMA	; IS IT STILL ADDITIVE?
	 JRST GRNLOP	; NO, FORGET IT
	ANDCMI AC2,G.WMA	; MAKE IT REPLACEMENT
	MOVEM AC2,GLLWM
	GSEND(AC2)
	JRST GRNLOP

$GMSII:	SETOM GIII	; GOING TO III MODE
	SKIPE GFIII	; FIRST III OUTPUT?
	 JRST GRNLOP	; NO, ALL IS DONE
	GSENDF <[G.ERS]>	; YES, ERASE SCREEN
	SETOM GFIII	; NOTE FIRST IS DONE
	MOVE AC2,GLLWM
	TRNE AC2,G.WMA	; IS IT ADDITIVE?
	 JRST GRNLOP	; YES, NOTHING TO BE DONE
	ORI AC2,G.WMA	; MAKE IT ADDITIVE
	MOVEM AC2,GLLWM
	GSEND(AC2)
	JRST GRNLOP
;GPCHK GPTAB GPWID GPLDC GPWGD GPWAC GPLER GPLEA GPLEB GPLEC GPLLR GPLLA GPLLB GPLLC

; GPCHK - CALL WITH JSP AC3,GPCHK
; CHECKS FOR ROW/COLUMN POSITIONING AND UPDATES GXPOS/GYPOS ACCORDINGLY
; AC1 MUST BE SET UP TO 16-B GRINNELL COMMAND
; ASSUMES ALL OTHER ACCUMULATORS ARE VOLITILE

GPCHK:	LDB AC2,[POINT 6,AC1,25]	; PICK OUT GRINNELL OPCODE
	JRST @GPTAB(AC2)		; OPCODE DISPATCH

GPTAB:	GPWID  ↔ GPWID  ↔ GPWID  ↔ GPWID	; WID - WRITE IMAGE DATA
	GPLSM  ↔ GPLSM  ↔ GPLSM  ↔ GPLSM	; LSM - LOAD SUBCHANNEL MASK
	GPWGD  ↔ GPWAC  ↔ GPLWM  ↔ GPLUM	; WGD, WAC, LWM, LUM
	GPERS  ↔ GPERL  ↔ GPSLU  ↔ GPEGW	; ERS, ERL, SLU, EGW
	GPLER  ↔ GPLER  ↔ GPLEA  ↔ GPLEA	; LER, LEA
	GPLEB  ↔ GPLEB  ↔ GPLEC  ↔ GPLEC	; LEB, LEC
	GPLLR  ↔ GPLLR  ↔ GPLLA  ↔ GPLLA	; LLR, LLA
	GPLLB  ↔ GPLLB  ↔ GPLLC  ↔ GPLLC	; LLB, LLC
	GPLDC  ↔ GPLDC  ↔ GPLDC  ↔ GPLDC	; LDC
	GPNOP  ↔ GPNOP  ↔ GPNOP  ↔ GPNOP	; NOP
	GPSPD  ↔ GPSPD  ↔ GPSPD  ↔ GPSPD	; SPD
	GPLPA  ↔ GPLPA  ↔ GPLPA  ↔ GPLPA	; LPA
	GPNOP  ↔ GPNOP  ↔ GPNOP  ↔ GPNOP	; NOP ? UNSPECIFIED
	GPLPD  ↔ GPLPD  ↔ GPLPD  ↔ GPLPD	; LPD
	GPRPD  ↔ GPRPD  ↔ GPRPD  ↔ GPRPD	; RPD
	GPNOP  ↔ GPNOP  ↔ GPNOP  ↔ GPNOP	; NOP

GPWID:GPLSM:GPERS:GPERL:GPSLU:GPEGW:
GPLDC:GPNOP:GPSPD:GPLPA:GPLPD:GPRPD:
	JRST (AC3)	; RETURN WITHOUT COMMENT

GPLUM:	MOVEM AC1,GLLUM		; SAVE LAST "LOAD UPDATE MODE"
	JRST (AC3)		; RETURN

GPLWM:	MOVEM AC1,GLLWM		; SAVE LAST "LOAD WRITE MODE"
	JRST (AC3)

GPWAC:		; ALPHA AND GRAPHIC THE SAME SINCE UPDATE MODE IS THE SAME
GPWGD:	MOVE AC2,GSEB		; PICK UP HORIZONTAL UPDATE
	MOVEI DAT,(AC2)
	ADD DAT,GSEA		; *** ASSUME WE ARE IN EA←EA+EB UPDATE MODE ***
	AND DAT,GMASK
	MOVEM DAT,GSEA
	ASH AC2,1		; NOW CONVERT TO III COORDINATES
	ADDM AC2,GXPOS
	JRST (AC3)

GPLER:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	ADDM AC2,GSEA			; UPDATE EA
	ASH AC2,1			; JFCL FOR 1024X
	ADDM AC2,GXPOS			; BUMP X POSITION (SHOULD WRAP AROUND HERE)
	JRST (AC3)			; RETURN

GPLEA:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	MOVEM AC2,GSEA
	SUB AC2,GOFF			; CONVERT TO III COORDINATE
	ASH AC2,1			; NOP FOR 1024X SYSTEM (INVERSE OF GSCALE)
	MOVEM AC2,GXPOS			; SET X POSITION
	JRST (AC3)

GPLEB:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	MOVEM AC2,GSEB			; NOT CURRENTLY USED, BUT MAYBE LATER
	JRST (AC3)

GPLEC:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	MOVEM AC2,GSEC			; NOT CURRENTLY USED, BUT MAYBE LATER
	JRST (AC3)

GPLLR:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	ADDM AC2,GSLA			; UPDATE LA REGISTER
	ASH AC2,1			; JFCL FOR 1024X
					; SHOULD WE NEGATE THIS HERE?
	ADDM AC2,GYPOS			; BUMP Y POSITION (SHOULD WRAP AROUND HERE)
	JRST (AC3)			; RETURN

GPLLA:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	MOVEM AC2,GSLA			; UPDATE LA REGISTER
	SUB AC2,GOFF			; CONVERT TO III COORDINATE
	ASH AC2,1			; NOP FOR 1024X SYSTEM (INVERSE OF GSCALE)
					; SHOULD WE NEGATE THIS HERE?
	MOVEM AC2,GYPOS			; SET Y POSITION
	JRST (AC3)

GPLLB:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	MOVEM AC2,GSLB			; NOT CURRENTLY USED, BUT MAYBE LATER
	JRST (AC3)

GPLLC:	LDB AC2,[POINT 9,AC1,35]	; 10 FOR 1024X SYSTEM
	MOVEM AC2,GSLC			; NOT CURRENTLY USED, BUT MAYBE LATER
	JRST (AC3)
;GCDD GCDSP CG6 CG0 CG1 GCMPM GCCSND GGRAPH CG2 CG7 CG3 CG4 CG5 CG4COM

; WHOLE PAGE UNDER IFN FTGRIN

; INTERPRET DD COMMAND WORD (UGH!)

GCDD:	MOVEM AC2,GTMP
	LDB AC1,[POINT 3,GTMP,26]
	LDB AC2,[POINT 8,GTMP,7]
	JSP TAC,@GCDSP(AC1)
	LDB AC1,[POINT 3,GTMP,29]
	LDB AC2,[POINT 8,GTMP,15]
	JSP TAC,@GCDSP(AC1)
	LDB AC1,[POINT 3,GTMP,32]
	LDB AC2,[POINT 8,GTMP,23]
	JSP TAC,@GCDSP(AC1)
	JRST GRNLOP

GCDSP:	JRST CG0	; EXECUTE - WRITE LINE BUFFER ONTO DISC
	JRST CG1	; FUNCTION CODE - LOAD FUNCTION CODE REGISTER WITH DATA BYTE
	JRST CG2	; CHANNEL SELECT
	JRST CG3	; COLUMN SELECT
	JRST CG4	; HIGH ORDER LINE ADDRESS (H.O. 5 BITS)
	JRST CG5	; LOW ORDER LINE ADDRESS (L.O. 4 BITS)
	JRST CG6	; WRITE DIRECT
	JRST CG7	; LINE BUFFER ADDRESS

CG6:	JRST (TAC)	; WRITE DIRECTLY - ANYTHING BETTER TO DO HERE ?

;DD execute
CG0:	MOVEM TAC,GDDSR	; SAVE RETURN ADDRESS
PRINTX CG0: Should DD Execute really do a clear to end of line?
	JSP AC3,GCCEOL	; DO A CLEAR TO END OF LINE IF NEEDED
	JRST @GDDSR	; RETURN


CG1:	SETZM GDARK	; CHECK EACH OF THE BITS AND TOGGLE OUR SIMULATION
	TRNE AC2,4	; DARK/LIGHT - 0=DARK ON LIGHT, 1=LIGHT ON DARK (USUAL)
	SETOM GDARK	; SET TO DRAW DARKNESS

	SETZM GTEXT	; GRAPHICS/TEXT MODE
	TRNN AC2,1
	SETOM GTEXT	; CHANGES MEANINGS OF SEVERAL OF THE FOLLOWING BITS

	SKIPN GTEXT	; THUS, WE SHALL INTERPRET THEM SEPARATELY
	JRST GGRAPH

	SETZM GDHEI	; TEXT MODE
	TRNN AC2,40	; DOUBLE HEIGHT CHARACTERS?
	SETOM GDHEI

	SETZM GNOSP	; ASSUME CLEAR TO END OF LINE
	TRNE AC2,20
	SETOM GNOSP	; DON'T CLEAR TO END OF LINE

	SETZM GDWID	; DOUBLE WIDTH?
	TRNE AC2,10
	SETOM GDWID	; YES

; THE OTHERS ARE IRRELEVANT
; NOW SEND OUT GRINNELL COMMANDS TO DO ALL THAT

GCMPM:	MOVEI AC1,G.LWM
	SKIPN GDARK	; DARK ON LIGHT?
	IORI AC1,G.WMB	; YES
	SKIPE GADD	; ADDITIVE (RATHER THAN REPLACEMENT)?
	IORI AC1,G.WMA	; NO - REPLACEMENT
	SKIPE GDHEI	; DOUBLE HEIGHT?
	IORI AC1,G.WMH	; YES
	SKIPE GDWID	; DOUBLE WIDTH?
	IORI AC1,G.WMW	; YES
	MOVEM AC1,GLLWM	; SAVE IT
GCCSND:	MOVEM TAC,GDDSR
	GSEND(AC1)
	JRST @GDDSR
	
GGRAPH:	SETZM GADD	; ADDITIVE OR REPLACEMENT WRITES
	TRNE AC2,20
	SETOM GADD	; ADDITIVE

	SETZM GENX	; ERASE ON NEXT CHANNEL SELECT?
	TRNE AC2,10
	SETOM GENX	; YES
	JRST GCMPM	; NOW GENERATE APPROPRIATE COMMANDS

PRINTX CG2 - Need to convert DD chan. numbers into GRIN chan/subchan sel here

CG2:			; CHANNEL SELECT - NOT SURE WHAT TO DO HERE
	SKIPN GTEXT	; ASSUME FOR NOW THAT PROPER CHANNEL ALREADY SELECTED
	SKIPN GENX
	JRST (TAC)	; NOT IN GRAPHICS MODE AND ERASE NOT ENABLES
	SETZM GENX
	MOVEI AC1,GERS	; OTHERWISE, ERASE SCREEN TO PREVIOUSLY SELECTED BACKGROUND
	JRST GCCSND

CG7:		; SAME AS ANY RANDOM COLUMN SELECT???
CG3:	MOVEM TAC,GDDSR	; SAVE RETURN ADDRESS
	MOVEM AC2,GARG	; SAVE ARGUMENT
	JSP AC3,GCCEOL	; DO A CLEAR TO END OF LINE IF NEEDED
	MOVE TAC,GDDSR	; RESTORE RETURN ADDRESS
	MOVE AC2,GARG	; RESTORE ARGUMENT
	SUBI AC2,1	; COLUMN 1 IS LEFT MARGIN
	MOVEI AC1,GRGSIZ	; 8 PIXELS PER COLUMN IN GRAPHICS MODE
	SKIPE GTEXT		; IS IT TEXT MODE?
;	MOVEI AC1,GRESIZ	; THIS MANY FOR TEXT MODE (***COMPROMISE!***)
	MOVE AC1,GSEB		;Adjust by appropriate delta X, set by LEB cmd
	IMUL AC1,AC2
	AND AC1,GMASK		; MAKE IT JUST THESE MANY BITS
	MOVE AC2,AC1
	ASH AC2,1
	SUBI AC2,1000
	MOVEM AC2,GXPOS		; UPDATE HORIZONTAL POSITION
	MOVEM AC1,GSEA
	ADDI AC1,G.LEA
	JRST GCCSND

CG4:	MOVEM TAC,GDDSR	; SAVE RETURN ADDRESS
	MOVEM AC2,GARG	; SAVE ARGUMENT
	JSP AC3,GCCEOL	; DO A CLEAR TO END OF LINE IF NEEDED
	MOVE DAT,[POINT 5,AC1,31]
	JRST CG4COM

CG5:	MOVEM TAC,GDDSR	; SAVE RETURN ADDRESS
	MOVEM AC2,GARG	; SAVE ARGUMENT
	JSP AC3,GCCEOL	; DO A CLEAR TO END OF LINE IF NEEDED
	MOVE DAT,[POINT 4,AC1,35]
CG4COM:	MOVE TAC,GDDSR	; RESTORE RETURN ADDRESS
	MOVN AC1,GYPOS	; Y POSITION -777 TO 1000 AFTER MOVN
      SUBI AC1,21*2	; *** KLUDGE TO MAKE E POSITION SCREEN RIGHT ***
	ADDI AC1,777	; NOW 0 TO 1777
	LSH AC1,-1	; 0 TO 777 WITH ORIGIN AT UPPER LEFT CORNER
	MOVE AC2,GARG	; PICK UP BYTE AGAIN
	DPB AC2,DAT	; PLACE H.O. OR L.O. BYTE IN TO LINE ADDRESS
	XORI AC1,777	; MAKE IT INTO A GRINNELL LINE NUMBER
      SUBI AC1,21	; *** KLUDGE TO MAKE E POSITION SCREEN RIGHT ***
      ANDI AC1,777	; *** JUST 9 BITS ***
	MOVE AC2,AC1	; PUT GRINNELL LINE NUMBER INTO AC2
	SUBI AC2,400	; MAKE IT -400 TO 377
	ASH AC2,1	; NOW -1000 TO 777
	MOVEM AC2,GYPOS		; UPDATE HORIZONTAL POSITION
	MOVEM AC1,GSLA	; UPDATE SIMULATED LA REGISTER
	ADDI AC1,G.LLA	; POSITION US THERE
	JRST GCCSND
;MAKEV MKVRTN VVIS ADDIN

; WHOLE PAGE UNDER IFN FTGRIN

; III SIMULATOR - MAKE VECTOR WORDS
; ENTER WITH TYPE BITS IN DAT, 0 FOR VIS, 1 FOR POINT, 2 FOR INVIS
; AND WITH ABSOLUTE COORDS IN AC1 (X) AND TAC (Y)

MAKEV:	MOVEM AC1,GXPOS
	MOVEM TAC,GYPOS
	CAIN DAT,2		; INVISIBLE ?
	  JRST ADDIN
	JUMPE DAT,VVIS

	GSCALE(AC1)
	MOVEM AC1,GSEA		; SAVE SIMULATED POSITION
	ADDI AC1,G.LEA		; PUT BEAM THERE
	GSEND(AC1)
	SETZM GSEB		; CLEAR EB REGISTER
	MOVEI AC1,G.LEB
	GSEND(AC1)		; ZERO LENGTH VECTOR FOR GRINNELL TO MAKE POINT

	MOVE TAC,GYPOS		; PICK UP Y POSITION AGAIN (GSEND FLUSHES ACS)
	GSCALE(TAC)
	MOVEM TAC,GSLA		; SAVE SIMULATED REGISTER
	ADDI TAC,G.LLA		; AND THE SAME THING FOR THE LINE ADDRESS
	GSEND(TAC)
	SETZM GSLB		; CLEAR INCREMENT REGISTER - DO A SINGLE POINT
	MOVEI TAC,G.LLB!G.W
	GSEND(TAC)
MKVR:	SETOM GVECS		; NOTE THAT WE HAVE CLOBBERED LB AND EB
MKVRTN:	SKIPN GRTN
	  JRST GRNLOP
	JRST GSHV

VVIS:	GSCALE(AC1)		; CONVERT NEW X COORD TO GRIN. COORD
	SUB AC1,GSEA		; GET DIFFERENCE IN GRIN. COORDS
	AND AC1,GMASK		; 9-BITS ONLY, PLEASE
	MOVEI DAT,(AC1)		; SAVE DIFFERENCE
	ADD DAT,GSEA		; UPDATE COORDINATE
	AND DAT,GMASK		; BUT LEAVE ONLY 9 BITS
	MOVEM DAT,GSEA		; THIS WILL BE EA REGISTER AFTER VECTOR
	MOVEM AC1,GSEB		; NOTE THAT THIS GUY HAS BEEN CLOBBERED
	ADDI AC1,G.LEB		; SET THAT AS ELEMENT B (DELTA)
	GSEND(AC1)

	MOVE TAC,GYPOS		; PICK UP Y POSITION AGAIN (GSEND KILLS ACS)
	GSCALE(TAC)
	SUB TAC,GSLA		; SUBTRACT OFF WHERE WE ARE IN GRIN. COORDS
	AND TAC,GMASK
	MOVEI DAT,(TAC)
	ADD DAT,GSLA		; UPDATE SIMULATED LA REGISTER
	AND DAT,GMASK		; BUT LEAVE ONLY 9-BITS
	MOVEM DAT,GSLA
	MOVEM TAC,GSLB		; NOTE THAT THIS GUY HAS BEEN CLOBBERED
	ADDI TAC,G.LLB!G.W	; SET THAT AS ELEMENT B (DELTA)
	GSEND(TAC)
	JRST MKVR		; NOTE ON EXIT THAT WE HAVE CLOBBERED EB/LB REGS

ADDIN:	GSCALE(AC1)
	MOVEM AC1,GSEA		; SAVE SIMULATED POSITION
	ADDI AC1,G.LEA		; PUT BEAM THERE
	GSEND(AC1)

	MOVE TAC,GYPOS		; PICK UP Y POSITION AGAIN (GSEND KILLS ACS)
	GSCALE(TAC)
	MOVEM TAC,GSLA		; SAVE SIMULATED LA REGISTER
	ADDI TAC,G.LLA		; AND THE SAME THING FOR THE LINE ADDRESS
	GSEND(TAC)
	JRST MKVRTN
;GRNCHR STALE CLOOP SNDIT SPCRET NOTYET GR177 GC177 GC11 GC15 GCEOLD GCCEOL GCCEO2 GCCEO3 GC12 SNDSPC GTXLP

; LAST PAGE UNDER IFN FTGRIN

GRNCHR:	MOVEM AC2,GTMP		; SAVE WORD FULL OF CHRS (GSENDF BELOW CLOBBERS AC)
	MOVEI DAT,GSETCM
	EXCH DAT,GLMODE		; PUT US IN CHR MODE
	CAIN DAT,GSETCM		; WERE WE ALREADY THEREIN?
	 JRST STALE		; WAS ALREADY CHARACTER MODE
	SETZM G177

	SKIPN GVECS		; Have vectors messed things up?
	 JRST STALE		;   No.
; NOTE THAT THIS MAKES THE FOLLOWING GLITCH - IF THE USER IS DEPENDING
; ON VALUES OF LB AND EB THAT ARE DIFFERENT FROM THE OBVIOUS ONES (0 AND
; GRESIZ), THEN HE MUST GIVE HIS OWN LLB AND LEB INSTRUCTIONS AFTER VECTORS
; UNTIL WE FIGURE OUT HOW TO DO THAT HERE
	SETZM GVECS
	GSENDF <[G.LLB]>	; Move across the screen
	SETZM GSLB		; NOTE THAT LB IS NOW ZERO
	MOVEI AC1,GRESIZ	; PICK UP DEFAULT CHR WIDTH
	MOVE AC2,GLLWM		; PICK UP MOST RECENT WRITE MODE
	TRNE AC2,G.WMW		; DOUBLE WIDTH?
	 ASH AC1,1		; YES
	MOVEM AC1,GSEB		; REMEMBER WHAT WE SET IT TO
	ADDI AC1,G.LEB
	GSEND(AC1)
STALE:	MOVE DAT,[POINT 7,GTMP]
	MOVEM DAT,GPTR		; PICK OUT CHARACTERS ONE AT A TIME
	MOVEI AC1,5
	MOVEM AC1,GCCNT
CLOOP:	ILDB AC1,GPTR		; PICK UP CHARACTER
	JUMPE AC1,GCNULL	; FLUSH ALL NULLS
	CAIN AC1,177		; SPECIAL CHARACTER TESTS
	  JRST GC177		; ALL CARRIAGE CONTROL AND "SHADOW" CHR STUFF
	CAIN AC1,11
	  JRST GC11
	CAIN AC1,15
	  JRST GC15
	CAIN AC1,12
	  JRST GC12
SNDIT:	MOVE AC2,GSEB		; BUMP COLUMN BY CHARACTER WIDTH
	ASH AC2,1		; JFCL FOR 1024X SYSTEM
	ADD AC2,GXPOS
	CAILE AC2,1000		; WILL IT FIT?
	 JRST NOTYET		; NO, FLUSH CHR (SIMULATE DD TRUNCATION)
	MOVEM AC2,GXPOS		; UPDATE X POSITION
IFN FTSIMCHR,<
printx Still simulating lower case and SAIL character for Grinnell.
	CAIL AC1," "		; Is it a non-Model 33 Character
	CAILE AC1,"]"
	  JRST SNDSPC		;   Yes, watch special cases
>;IFN FTSIMCHR
	ADDI AC1,G.WAC		; WRITE ALPHANUMERIC CHARACTER
	GSEND(AC1)
IFN FTSIMCHR,<
SPCRET:
>;IFN FTSIMCHR
	SETOM GNEEDC		; NOW NEED CLEAR TO END OF LINE WHEN LINE DONE
NOTYET:	SETZM G177
GR177:	SOSLE GCCNT		; COUNT OVERFLOW?
	 JRST CLOOP		; NO, GO BACK FOR NEXT CHR
	JRST GRNLOP		; BACK TO INTERPRETATION LOOP

GC177:	SKIPE G177		; IF PRECEEDED BY 177, SEND SHADOW CHR
	 JRST SNDIT
	SETOM G177		; OTHERWISE, NEXT CHARACTER IS SHADOWN CHR
	JRST GR177

GCNULL:
GC11:	SKIPN G177
	 JRST GR177
	JRST SNDIT		; IF PRECEEDED BY 177, SEND SHADOW CHR

GC15:	SKIPE G177
	JRST SNDIT		; SHADOW CHARACTER
	JSP AC3,GCCEOL		; CLEAR TO END OF LINE IF NECESSARY
GCEOLD:	MOVE AC1,GSEB		; RESET TO LINE ORIGIN, SKIPPING ONE LEADING COLUMN
	MOVEM AC1,GSEA		; SAVE SIMULATED COLUMN NUMBER
	ADDI AC1,G.LEA		; SET X POSITION TO SECOND TEXT POSITION
	GSEND(AC1)
	MOVE AC1,GSEB		; START THIS FAR FROM LEFT MARGIN
	ASH AC1,1		; JFCL FOR 1024X SYSTEM
	SUBI AC1,1000		; MAKE INTO III COORD (-1000 IS COORD OF LEFT SIDE)
	MOVEM AC1,GXPOS
	JRST GR177

;Here to do a clear to EOL (for CR or LF, etc.).
GCCEOL:	SKIPN GNEEDC		; DO WE NEED A CLEAR TO END OF LINE?
	JRST (AC3)		; NO, THAT WAS EASY
	MOVEM AC3,GNEEDC	; REMEMBER RETURN ADDRESS
GCCEO2:	SKIPN AC1,GSEB		; SIMULATE CLEAR TO END OF LINE, ADD CHAR WIDTH
	  MOVEI AC1,GRESIZ	; *** SHOULDN'T HAPPEN BUT IT DOES ***
	MOVE AC2,AC1		; SAVE IT
	ASH AC1,1		; JFCL FOR 1024X SYSTEM
	ADD AC1,GXPOS		; GET X COORD OF END OF CHR YET TO GO OUT
	CAILE AC1,1000		; NOTE - AC1 HAS ALREADY BEEN UPDATED FOR WIDTH OF CHR.
	JRST GCCEO3		; OK, WE'VE REACHED THE RIGHT MARGIN
	MOVEM AC1,GXPOS

	ADDM AC2,GSEA		; UPDATE OUR IDEA OF THE EA REGISTER
	MOVEI AC1,G.WAC!40	; SEND A SPACE
	GSEND(AC1)
	JRST GCCEO2

GCCEO3:	MOVE AC3,GNEEDC		; GET RETURN ADDRESS
	SETZM GNEEDC		; CLEAR FLAG -- NO LONGER NEED CLEAR TO EOL
	JRST (AC3)		; RETURN

;Here for LF.
GC12:	SKIPE G177
	JRST SNDIT		; SHADOW CHARACTER
	JSP AC3,GCCEOL		; CLEAR TO END OF LINE IF NECESSARY
PRINTX GRNCHG ought to be settable somehow according to parameters being used.
	MOVN AC1,GRNCHG		; PICK UP CHARACTER HEIGHT
	ADDM AC1,GSLA		; UPDATE OUR IDEA OF THE LINE REGISTER
	ASH AC1,1		; JFCL FOR 1024X SYSTEM
	ADDM AC1,GYPOS		; REMEMBER NEW Y POSITION
	MOVN AC1,GRNCHG		; GET HEIGHT AGAIN
	ADDI AC1,G.LLR+GRWMAX	; MAKE NEGATIVE RELATIVE Y POSITION ADJUSTMENT
	GSEND(AC1)
	JRST GR177

IFN FTSIMCHR,<
;Simulate a character we don't have in PROM yet.
SNDSPC:	MOVEM AC1,GCTMP		;Save character
	GSENDF <[G.LLR+9]> 	;Adjust to top of character
	GSENDF <[G.LLB+=1024-1]>	;Move down the screen
	GSENDF <[G.LEB]>		;Set update mode to move vectically
	MOVE AC3,GCTMP		;Get Character back
;;	CAIL AC3," "		;Control character?
;;	  SUBI AC3,"↑"-" "	;  No, compress table
	MOVE AC1,AC3		;Avoid a multiply
	ROT AC3,2		;Fastest shift, i think
	ADD AC3,AC1
	HRLI AC3,-4		;Make an AOBJN pointer
GTXLP:	HLRZ AC1,GTXTAB(AC3)	;Get first row
	MOVEM AC3,GCTMP		;Save AOBJN pointer
	GSENDF AC1		;Send it
	MOVE AC3,GCTMP		;Restore AOBJN pointer
	MOVE AC1,GTXTAB(AC3)	;Get second row
	GSENDF(AC1)		;Send it
	MOVE AC3,GCTMP		;Restore AOBJN pointer
	AOBJN AC3,GTXLP		;Repeat to make a character
	HLRZ AC1,GTXTAB(AC3)	;Get (n-1)th row
	MOVEM AC3,GCTMP		;Save AOBJN pointer
	GSENDF AC1		;Send it
	MOVEI AC1,G.LEB		;Reset to normal character mode.
	IOR AC1,GSEB		; CHARACTER WIDTH IN PIXELS
	GSENDF AC1
	GSENDF <[G.LLB]>	;Restore to normal
	MOVE AC3,GCTMP		;Restore AOBJN pointer
	MOVE AC1,GTXTAB(AC3)	;Pick up last row
	GSENDF(AC1)		;Send it
	JRST SPCRET

;;.INSERT GTXTAB.FAI		;(The character table [omitting " " thru "]")
.INSERT GTXTAB.ALL		;(The character table [omitting " " thru "]")
>;IFN FTSIMCHR

>; IFN FTGRIN	;Last of several pages
;DDLNK DDALST DDBADB DDKILL DDANYW DDSMSK DDUSR DUSRMK DTTUSR DTTL0 DSPUSR DDUSR2 DDAVLU DDDETU DDPRVT DDELNK DDCLST DDGBIT DDSBIT DDGMOD DDUSET VDOP VDPERM VDABSO VDXBIT

;DEFINITIONS FOR DATA DISC ALLOCATION

DDLNK←←<600,,DDTAB>	;bits 30:35 are LINK OUT (job's channel list or free list)
DDALST←←<60600,,DDTAB>	;bits 24:29 are ALLOC LIST (PERMANENT)
↑DDBADB←←400000		;Bit 18 of DDTAB entry, marks bad channel
			;Set by "DET DDn" command, chan assigned only if no others.
↑DDKILL←←200000		;Bit 19 in DDTAB means "detach hard when going available"
			;Set by "DET DDn!" when DDn is already in use.
↑DDANYW←←200000		;bit 1 in DDTAB -- let anyone write
DDSMSK←←DDANYW!400000	;mask for user settable bits (400000 bit is privacy bit)

↑DDUSR←←<222000,,DDTAB>	;bits 2:17 are USER FLD
;Note: DUSRMK, DTTUSR and DSPUSR represent both LH values in DDTAB and RH values
;w.r.t. the DDUSR field (e.g., after that field has been LDB'd).  The user field
;is thus required to be right justified in the LH of DDTAB.
DUSRMK←←177777		;mask for user field (bits 2:17)
↑DTTUSR←←10000		;beginning user field value for channel owned by DD line
    ↑DTTL0←←0		;line represented by 0 user field of chan owned by DD line
↑DSPUSR←←20000		;beginning user field value for special channel
DDUSR2←←222000		;to set user & clear extra bits

    ;SPECIAL USER CODES
    ↑DDAVLU←←DSPUSR+0	;AVAILABLE CHANNEL
    ↑DDDETU←←DSPUSR+1	;Totally detached from system (e.g., from DET DD21! cmd).
↑DDPRVT←←430100		;Bit 0 in DDTAB is PRIVATE BIT (FOR LINED'S ESC H CMD)
↑DDELNK←←40		;LIST TERMINATOR (ZERO IS LEGAL VAL)
DDCLST←←<600,,JB2SWP>	;LIST OF CHANNELS OWNED BY JOB

DDGBIT←←100		;"GET" BIT IN UUO
DDSBIT←←200		;"STATUS" BIT IN UUO
DDGMOD←←50300		;WHOLE MODE FLD
DDUSET←←100000		;SPECIAL DDCHAN LETTING USER SET USE CODE

IFE FTF2,<

;DEFINITIONS FOR VIDEO SWITCH ROUTINES

VDOP←←330300		;OPCODE FLD FOR UUO
VDPERM←←400000		;"PERMANENT" BIT - MUST BE SIGN
↑VDABSO←←200000		;"ABSOLUTE" BIT - AFFECTS JUST GIVEN LINE DESPITE MAPPING
VDXBIT←←400		;"EXTRA CHANNEL" BIT

>;IFE FTF2
;DDINI DDINI1 DDINI3 DDINI2

IFE FTF2,<	;Whole page

;INITIALIZATION FOR DATA DISC ALLOCATION AND VIDEO SWITCH
DDINI:	SETOM DDTAB
	MOVE TAC,[DDTAB,,DDTAB+1]
	BLT TAC,DDTAB+DDELNK		;CLEAR TABLE FOR DUPLICATION TEST
	MOVEI TAC,40
	MOVEM TAC,DDFCNT	;INIT FREE CHNL COUNT
	MOVE TAC,[440600,,DDLIST]
	MOVEI AC2,DDELNK
DDINI1:	ILDB AC1,TAC
	SKIPL DDTAB(AC1)
	JRST 4,.		;OOPS - WE'VE BEEN HERE BEFORE
	MOVEM AC2,DDTAB(AC1)	;INITIALIZE DDTAB WITH ALLOC LIST & FREE LIST
	DPB AC1,[DDALST(AC2)]
	MOVEI AC2,(AC1)
	CAIE AC1,DDELNK
	JRST DDINI1
	MOVEI J,JOBN-1
	MOVEI TAC,
	DPB TAC,[DDCLST(J)]	;INIT JOB CHNL LISTS
	SOJG J,.-1
	SETZM DDQSIZ		;SET DD CHAN QUEUE COUNT FOR EMPTY
	SETOM DDQTAI		;SET DD CHAN QUEUE TAIL TO POINT AT HEADER
	SETZM DDQDLY		;NO DD CHANNEL BEING GIVEN FROM QUEUE RIGHT NOW
	MOVE TAC,AVLCH2		;alternate available channel
	SKIPE MAINTM		;in maintenance mode,
	MOVEM TAC,AVLCHN 	;  use alternate channel
	MOVSI TAC,DDAVLU	;USE FIELD FOR AVAIL CHANNEL
	HRR TAC,AVLCHN
	PUSHJ P,DDCGET		;GET CHN FOR AVAIL MSG
	 JRST 4,.
	MOVEI AC1,(TAC)
	PUSHJ P,VDBIT
	MOVEM AC3,AVLBIT
	MOVSI AC1,-DDNUM
DDINI2:	MOVEI AC2,DDL0(AC1)
	MOVEM AC2,VDTIE(AC1)	;MAP EVERYONE TO MSG
	MOVEM AC3,VDPRM(AC1)
	CONO VDS,DPYNUM(AC1)
	DATAO VDS,AC3
	AOBJN AC1,DDINI2
	DPB TAC,[POINT 8,AVLWHO,15]
IFN FTDDKLU,<
	MOVEI AC3,LDDREL	;Get some FS for relocating some DD xfers
	PUSHJ P,FSGET
	 JRST 4,.		;No FS!!  Come on, we just started the system
	MOVEM AC1,PDDREL	;Save pointer for later when we want it
>;IFN FTDDKLU
	POPJ P,

>;IFE FTF2
;DDAVST DDLIST VDSYNC

IFN FTDD!FTGRIN,<	;Whole page

;P2 HERE (FROM WHOSER) TO COMPUTE THE DD AVAILABLE MESSAGE

LOSYS

↑DDAVST:MOVEI AC2,1
IFE FTF2,<
	SKIPN DDFCNT		;ARE THERE ANY CHANNELS FREE?
	MOVE AC2,[DDUNMS,,DISJMP] ;NO MAKE UNAVAIL MESSAGE HAPPEN
>;IFE FTF2
	SKIPN MAINTMODE
	SKIPE TTYLOK
	MOVE AC2,[XWD DDDMES,DISJMP]
	MOVEM AC2,DDWMES
IFN FTGRIN,<
	HRRZ AC2,GRNDIM+1	;Get count of usable scanlines
	HRRZ AC1,GRELSZ+1	;Get line height
	IMULI AC1,4		;Available msg takes 4 lines
	SUBI AC2,(AC1)		;Adjusted amount of available scanlines
	MOVE AC1,TIME		;RANDOM NUMBER
	IDIVI AC1,(AC2)		;Get random scanline number into AC2
	ADD AC2,GRSKIP		;Move up by number of scanlines to avoid at bottom
	MOVEI AC1,(AC2)
	DPB AC2,[POINT 10,AVLVP,31] ;Store random vertical position
>;IFN FTGRIN
IFE FTGRIN,<
	MOVE AC1,TIME		;RANDOM NUMBER
	IDIVI AC1,300
	ADDI AC2,10
	MOVEI AC1,(AC2)
	DPB AC2,[150300,,AVLVP]	;STORE LOW ORDER PART
	LSH AC2,-3		;REMOVE LOW ORDER PART
	DPB AC2,[240500,,AVLVP]	;STORE HI PART
	IDIVI AC1,=6		;CONVERT RASTER LINE TO TEXT LINE (LOW-ORDER BIT NOT HERE)
	HRLI AC1,3(AC1)		;AVL MSG USES 4 DIFFERENT TEXT LINES
	MOVSM AC1,AVLLN
	MOVSI AC2,20000
	IORM AC2,AVLWHO		;TURN ON ERASE BIT TO FORCE ERASE BEFORE FIRST FIELD
>;IFE FTGRIN
	POPJ P,

IFN FTDD,<
DDLIST:	BYTE (6)17,37,36,35,34,33,32,31,30,27,25,24,23,3,15,7,22,11
	BYTE (6)6,4,12,26,5,13,2,14,10,1,20,21,16,0,DDELNK

↑VDSYNC:0↔11↔12↔13↔14↔15↔16↔7
>;IFN FTDD

HISYS

>;IFN FTDD!FTGRIN	;Whole page
;DDCHAN DDCDSP DDAREL DDARL1

IFE FTF2,<	;First of several pages

;ALL-PURPOSE DD CHANNEL DIDDLING UUO:
;AC31-35 = CHAN, AC30 means NO SPECIFIC CHAN (CONSOLE CHAN FOR STATUS)
;AC28-29: 0-RELEASE, 1-GET, 2-GET STATUS, 3-SET STATUS
;AC29=1 means FAILURE POSSIBLE, SKIP ON SUCCESS
;AC0 PRIVATE CHAN, SET ON GET OR SET STATUS
;REST OF LH READ-ONLY STATUS BITS, RETURNED ON SINGLE-CHAN OPS OR GETTING CHAN:
;AC 3-17 USE: 0=FREE, 1-JOBN-1=JOB N, 10000-17777=TTY N-10000, 20000-27777 SPECIAL
;	      30000-77777 RESERVED.

↑DDCHAN:MOVSI AC1,DEVPRV	;PRIVILEGED VERSION CAN SET ANY USE CODE
	TDNE AC1,JBTPRV(J)	;MUST HAVE DEV ACTIVE
	TLZN TAC,DDUSET		;AND MUST HAVE THIS BIT SET
	DPB J,[DDUSR2,,TAC]
	LDB AC1,[DDGMOD,,TAC]
	ANDCMI TAC,-40
	PUSHJ P,@DDCDSP(AC1)
	JRST STOTAC
	AOS (P)
	JRST STOTAC

DDCDSP:	DDCREL		;Release channel
	DDAREL		;Release all channels
	DDCGET		;Get channel
	DDAGET		;Get any channel
	DDSGET		;Get status
	DDCSGT		;Get own channel's status
	DDSSET		;Set status
	DDCSST		;Set own channel's status

;RELEASE ALL CHANS OWNED BY JOB (ALSO CALLED ON RESET)

↑DDAREL:PUSH P,TAC
	LDB TAC,[DDCLST(J)]
	SOJL TAC,TPOPJ
	HLL TAC,(P)
	MOVEI AC1,
	DPB AC1,[DDCLST(J)]	;CLEAR THE LIST HERE IN ONE SWELL FOOP
DDARL1:	LDB AC3,[DDLNK(TAC)]
	PUSHJ P,DDREL		;SO WE DON'T HAVE TO DO IT HERE
	HRRI TAC,(AC3)
	CAIE AC3,DDELNK
	JRST DDARL1
	JRST TPOPJ
;DDUSRT DDCREL DDCRL1 DDREL DDQNTA DDQER4 DDQER3 DDQER2 DDQFIX DDREL2 DDQDET

;This whole page IFE FTF2

↑DDUSRT: DDUSR(TAC)		;BYTE POINTER TO USE FIELD FOR DD IN TAC

;RELEASE CHANNEL C(TAC)

DDCREL:	LDB AC2,[DDLNK(TAC)]	;HERE CHAN BELONGS TO JOB
	LDB AC1,[DDCLST(J)]	;& MUST BE DELINKED FROM JOB'S LIST
	CAIN AC1,1(TAC)
	AOJA AC2,[	CAIL AC2,41
			MOVEI AC2,
			DPB AC2,[DDCLST(J)]
			JRST DDREL]
	SOJL AC1,DDREL
DDCRL1:	LDB AC3,[DDLNK(AC1)]
	CAIN AC3,(TAC)
	JRST [DPB AC2,[DDLNK(AC1)]↔JRST DDREL]
	MOVEI AC1,(AC3)
	CAIE AC1,DDELNK
	JRST DDCRL1
↑DDREL:	LDB AC1,DDUSRT		;ENTER TO JUST RELEASE CHANNEL, GET USE FIELD
	TSC AC1,TAC
	TRNE AC1,DUSRMK		;USER FIELD CLAIMED BY CALLER MUST MATCH REAL THING
	JRST DDREL2		;DOESN'T BELONG TO HIM
	MOVEI AC1,(TAC)
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVEI AC2,DDKILL	;bit meaning detach this channel hard
	TDNE AC2,DDTAB(AC1)	;Is chan waiting to be detached hard?
	JRST DDQDET		;Yes, don't bother freeing, just change use field.
	AOS AC2,DDFCNT
	CAIN AC2,1
	SETOM WHOKLU		;CHANGE TO AVAILABLE MESSAGE
	MOVSI AC2,DUSRMK	;MASK FOR WHOLE USER FIELD
	LDB AC1,[DDALST(AC1)]
	TDNE AC2,DDTAB(AC1)	;SCAN UP ALLOC LIST (ORDERED)
	JRST .-2
	LDB AC2,[DDLNK(AC1)]	;SO WE CAN PUT IN RIGHT PLACE IN FREE LIST
	DPB TAC,[DDLNK(AC1)]
	DPB AC2,[DDLNK(TAC)]
	HRRZS DDTAB(TAC)	;clear use field, hidden bit, and anywriter bit
;Now we check the DD channel wait queue to see if anyone wants this channel we freed
IFN FTF2,<
	JRST SCNONJ
>;IFN FTF2
IFE FTF2,<
	SKIPN DDSPCH			;skip if saving this channel for spcl user
	SKIPG DDQSIZ			;SKIP IF ANYONE WAITING IN DD CHAN QUEUE
	JRST SCNONJ
	LDB AC1,[DDQLNK,,LSTESC-1]	;GET FIRST IN QUEUE FROM DUMMY ENT.
	JUMPE AC1,DDQER2		;ERROR - NONEMPTY Q W/NO FIRST ENTRY
	LDB AC2,[DDQLNK+AC1,,LSTESC]	;GET NEXT IN QUEUE (IF ANY)
IFN FTESCCBUG,<
	CAIL AC1,DDL0			;BETTER BE A DD LINE
	CAIL AC1,DDL0+DDNUM
	JRST DDQER3			;NON-DD LINE AT HEAD OF DD QUEUE
	CAIL AC2,DDL0			;NEW FIRST ENTRY ALSO BETTER BE DD LINE
	CAIL AC2,DDL0+DDNUM
	JUMPN AC2,DDQER4		;NON-DD LINE WOULD BE NEW FIRST IN DD QUEUE
>;IFN FTESCCBUG
	DPB AC2,[DDQLNK,,LSTESC-1]	;LINK HEADER AROUND FIRST (DEQUEUE)
	PUSH P,AC3			;DDREL is supposed to preserve AC3
	PUSH P,TAC			;DDREL is supposed to preserve TAC
	JUMPN AC2,DDQNTA
	SETOM DDQTAI			;SET NULL TAIL POINTER, IF REMOVED LAST ENT.
DDQNTA:	LDB AC2,[DDQREQ+AC1,,LSTESC]	;GET Q REQ FIELD (TO BEEP)
	MOVEI TAC,0
	DPB TAC,[DDQLNK+AC1,,LSTESC]	;ZERO QUEUE LINK FIELD
	DPB TAC,[DDQREQ+AC1,,LSTESC]	;ZERO QUEUE REQ. FIELD
	SOS DDQSIZ
	PUSHACS				;GET SET TO SIMULATE BACKSPACE BEING TYPED
	MOVEI CHR,177			;Give him a backspace for more time to log
	MOVEI DSER,177			;Unshifted char
	MOVEI UCHN,0			;No bucky bits
	MOVE TAC1,AC2			;Get physical guy to pretend typed char
	HRRZ TAC,LINTAB(TAC1)
	DPB AC1,[POINT PUNITS,TAC,35]	;Line to pretend he's mapped to
	HRROM TAC1,PHYLIN		;Make phys guy responsible for new DD
	MOVEI AC1,=60*=60		;Initial delay (60 secs) before killing DD
	MOVEM AC1,DDQDLY		;Tell DPYK9 to use long kill delay
	PUSHJ P,ESCRET			;Go do it (scanner must be off, which it is)
	SETZM DDQDLY			;Go back to using normal DPYKIL delay
	ONSCN
	POPACS
	MOVE TAC,AC2			;WHO TO BEEP (ORIGINAL REQUESTOR)
	PUSHJ P,BEEPAW			;GO BEEP
	POP P,TAC			;Restore DD channel number
	POP P,AC3			;Restore something
	POPJ P,
>;IFE FTF2

IFN FTESCCBUG,<
DDQER4:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /Non-DD line is SECOND in DD wait queue: TTY/]
	DISARG LOC,<AC2-20(P)>
	-1
	PUSHJ P,DISCRLF
	JRST DDQFIX		;Fix things I hope

DDQER3:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /Non-DD line is FIRST in DD wait queue: TTY/]
	DISARG LOC,<AC1-20(P)>
	-1
	PUSHJ P,DISCRLF
	JRST DDQFIX		;Fix things I hope
>;IFN FTESCCBUG

DDQER2:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /DD CHANNEL WAIT QUEUE (LSTESC-1) IS EMPTY BUT ITS SIZE (DDQSIZ) IS NON-ZERO.
/
DDQFIX:	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
	SETZM DDQSIZ		;Fix things.  I hope the links are zero!
	SETOM DDQTAI		;Make tail pointer point to header
	JRST SCNONJ

DDREL2:	TLNN TAC,DTTUSR!DSPUSR	;TTY USER OR SPECIAL?
	POPJ P,			;JUST SOME LOSER, OR DDDETU ATTEMPT
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL DD RELEASE - TAC=/]
	DISARG OCT,<TAC-20(P)>
	[ASCIZ /
/]
	-1
	POPACS
	POPJ P,

DDQDET:	MOVEI AC1,DDDETU	;Use code for hard detached channel
	HRLM AC1,DDTAB(TAC)	;set use code, clear hidden bit and anywriter bit
	JRST SCNONJ
;DDCGET DDAGE1 DDCG1 DDAGE3 DDAGET DDAGE2 DDGET2 DDGET3

;This whole page IFE FTF2

;GET CHAN SPECIFIED BY TAC(31-35) IF FREE

↑DDCGET:HLLZ AC3,TAC
	MOVEI AC1,(TAC)
	MOVSI AC2,DUSRMK	;Mask for user field
	OFFSCN			;TURN OFF SCANNER CHANNEL
	TDNN AC2,DDTAB(AC1)	;Skip if DD channel is in use
	JRST DDCG1
	ONSCN			;TURN ON SCANNER CHANNEL
	HLL TAC,DDTAB(AC1)	;TELL HIM HOW HE LOST
	POPJ P,

;ENTER HERE FROM DDAGET IF FIRST FREE CHANNEL IS MARKED BAD - BH 5/23/75
DDAGE1:	LDB AC1,[DDLNK(AC1)]	;LOOK THROUGH FREE LIST FOR A GOOD CHANNEL
	CAIN AC1,DDELNK		;END OF LIST?
	JRST DDAGE3		;YUP, NO GOOD CHANNELS, GET THE BAD ONE
	TDNE AC2,DDTAB(AC1)	;AC2 HAS THE BAD CHANNEL BIT
	JRST DDAGE1		;KEEP LOOKING, THIS ONE BAD TOO
	MOVSI AC2,DUSRMK	;GOT ONE, SET UP FOR DDCG1
	HRRI TAC,(AC1)
DDCG1:	LDB AC1,[DDALST(AC1)]	;IT'S FREE - SCAN FOR GUY POINTING TO IT
	TDNE AC2,DDTAB(AC1)
	JRST DDCG1
	IORM AC3,DDTAB(TAC)
	LDB AC3,[DDLNK(TAC)]	;SO WE CAN LINK IT OUT
	DPB AC3,[DDLNK(AC1)]
	MOVEI AC1,(TAC)		;DD CHAN FOR DDGET2
	PUSHJ P,SETHDN		;COPY DD CHAN PRIVACY BIT TO TTY'S HIDDEN BIT
	ONSCN			;TURN ON SCANNER CHANNEL
	JRST DDGET2

DDAGE3:	MOVE AC1,DDFLST		;HERE IF ONLY BAD CHANS AVAILABLE
	JRST DDAGE2		;SO WE PUNT BACK INTO DDAGET

;GET ANY FREE CHAN

DDAGET:	HLLZ AC3,TAC
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE AC1,DDFLST
	CAIN AC1,DDELNK
	JRST SCNONJ		;Turn scanner channel back on and POPJ
	MOVEI AC2,DDBADB	;GET BAD CHANNEL BIT (BH 5/22/75)
	TDNE AC2,DDTAB(AC1)	;IS FIRST FREE CHAN BAD?
	JRST DDAGE1		;YES, TRY FOR A BETTER ONE
DDAGE2:	LDB AC2,[DDLNK(AC1)]
	MOVEM AC2,DDFLST
	IORM AC3,DDTAB(AC1)
	PUSHJ P,SETHDN		;COPY DD CHAN PRIVACY BIT TO TTY'S HIDDEN BIT
	ONSCN			;TURN ON SCANNER CHANNEL
	HRRI TAC,(AC1)
;COMMON CODE FOR BOTH FLAVORS OF GET. PUTS IN LIST IF GETTING FOR JOB.
;SETS AND ENFORCES PRIVACY BIT.
DDGET2:	SOSG DDFCNT
	SETOM WHOKLU			;SET NO CHANNELS LEFT MESSAGE
	TLNN TAC,DTTUSR!DSPUSR		;IF NOT USED BY TTY NOR SPECIAL, THEN
	AOJA AC1,[LDB AC2,[DDCLST(J)]	;OWNED BY JOB - ADD TO ITS LIST
		DPB AC1,[DDCLST(J)]
		SOJGE AC2,[SOJA AC1,DDGET3]
		SOJA AC1,.+1]
	MOVEI AC2,DDELNK
DDGET3:	DPB AC2,[DDLNK(AC1)]
	AOS (P)
	JUMPGE TAC,CPOPJ	;THAT'S ALL IF HE'S NOT PARANOID
	MOVEI AC1,(TAC)		;ELSE GO FLUSH SPIES ON THIS CHANNEL
	JRST DDFLSH
;DDFLSH DDFL00 DDFLS0 DDFL01 DDFLS3 DDFLS2 DDFLS4 DDFL99 DDFLS7 DDFLS8 DDFL88 DDFLS9 DDFLSX FINDDD FINDD1 FINDDL FINDD2 FINDD3 FINDDF FINDDN FINDDQ

;This whole page IFE FTF2

;ROUTINE TO THROW ALL SPIES OFF PRIVATE CHANNEL WHOSE NUMBER IS IN AC1.
;CLOBBERS UCHN AND AC1, AND THROWS NON-RESPONSIBLE MAPPERS OFF ALSO.

↑DDFLSH:PUSHJ P,VDBIT		;GET BIT FOR THIS CHANNEL INTO AC3
	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,DAT
	LDB TAC1,[DDUSR(AC1)]
	SETZB UCHN,DAT
	CAIL TAC1,DTTUSR	;BH 12/8/74 IF CHAN IS IN USE AS TTY
	CAIL TAC1,DTTUSR-DTTL0+TTPLEN ;Redundancy: make sure legal TTY number
	JRST DDFL00		;BH (DSPUSR+ SPECIALS DON'T COME HERE)
	MOVEI UCHN,DTTL0-DTTUSR(TAC1) ;BH THEN UCHN IS LINE #
	LDB DAT,[DDQREQ+UCHN,,LSTESC] ;TTY RESPONSIBLE FOR THIS LINE
DDFL00:	MOVSI TAC,-DDNUM-DPYNUM	;INCLUDE "SHADOW" CHANNELS HERE
DDFLS0:	TDNE AC3,VDMAP(TAC)	;HERE WE SCAN THE UNTIED MAPS
	CAIN DAT,DDL0(TAC)	;IS THIS PHY TTY RESPONSIBLE FOR THIS LOG LINE?
	JRST DDFL01
	ANDCAM AC3,VDMAP(TAC)
	PUSHJ P,VDOUT1		;OUTPUT THIS ONE UNTIED GUY'S REDUCED VIDEO
DDFL01:	TDNE AC3,VDPRM(TAC)	;HERE WE SCAN THE PERM MAPS
	CAIN TAC1,DTTUSR-DTTL0+DDL0(TAC) ;DON'T FLUSH FROM TIED MAP FOR PHYS TTY ITSELF
	JRST DDFLS3
	PUSHJ P,VDSTR1		;FLUSH FROM TMP AND PRM MAP AND PROPAGATE TO
	 ANDCAM AC3,VDTMP(AC2)	; EVERYONE TIED TO THIS GUY
DDFLS3:	AOBJN TAC,DDFLS0
	MOVSI TAC,-DDNUM
;HERE TO DDFLS4 WE REFERENCE TAC AS LOGICAL DD LINE NUMBER (-DDL0)
DDFLS2:	SKIPE AC2,LETAB+DDL0(TAC) ;HERE WE SCAN THE TEMP MAPS
	CAIN TAC1,DTTUSR-DTTL0+DDL0(TAC) ;DON'T FLUSH FROM TIED MAP FOR PHYS TTY ITSELF
	JRST DDFLS4
	TDNN AC3,VDTMP(AC2)
	JRST DDFLS4
	ANDCAM AC3,VDTMP(AC2)
	PUSHJ P,VDOUTP
;HERE TO DDLFS9 WE REFERENCE TAC AS PHYSICAL DD TERMINAL NUMBER (-DDL0)
DDFLS4:	JUMPE UCHN,DDFLS9	;IF CHAN IS USED AS TTY, ALSO CHECK KBD MAP
	CAIN DAT,DDL0(TAC)	;IF IT'S THE RESPONSIBLE TTY FOR HIDDEN LINE,
	JRST DDFLS9		;THEN IGNORE
	LDB AC2,[POINT PUNITS,LINTAB+DDL0(TAC),35] ;WHAT HE'S MAPPED TO
	CAIE AC2,(UCHN)		;SKIP IF MAPPED TO HERE
	JRST DDFLS7		;NOT MAPPED, SEE IF TIED
DDFL99:	MOVEI AC2,DDL0(TAC)	;GET HIS OWN TERMINAL NUMBER
	OFFSCN
	PUSHJ P,FINDDD		;FIND SOME DD TO MAP HIM TO
	DPB AC1,[POINT PUNITS,LINTAB+DDL0(TAC),35] ;AND MAP HIM THERE
	ONSCN
	JRST DDFLS8		;TIE HIM TO HIMSELF TOO

DDFLS7:	CAME UCHN,VDTIE(TAC)	;TIE TO SELF IF TIED BUT NOT MAPPED HERE
	JRST DDFL88		;NOT TIED, SEE IF HOME IS HERE
	LDB AC1,[POINT PUNITS,LINTAB+DDL0(TAC),35] ;TIE TO PLACE MAPPED
	CAIL AC1,DDL0
	CAIL AC1,DDL0+DDNUM
	JRST DDFL99		;NOT MAPPED TO ANY DD, MAP AND TIE HIM TO ONE
DDFLS8:	MOVEM AC1,VDTIE(TAC)	;TIE HIM WHERE HE'S MAPPED
	PUSHJ P,VDOUT1		;REALLY GRONK THE VIDEO SWITCH
DDFL88:	LDB AC1,[HOMEPT+DDL0(TAC)] ;SEE IF WE'RE HIS HOME
	MOVEI AC2,0		;NON-DD TO MAKE HIS HOME IF SO
	CAIN AC1,(UCHN)		;HOME HERE?
	DPB AC2,[HOMEPT+DDL0(TAC)] ;YES, BUT NOT ANY MORE
DDFLS9:	AOBJN TAC,DDFLS2
DDFLSX:	POP P,DAT
	POP P,TAC1
	JRST TPOPJ

;HERE WITH SCN OFF (OR IN SCN CHN) TO FIND A DD RESPONSIBLE TO THE ONE IN AC2.
;LH OF AC2 SHOULD BE ZERO TO INCLUDE DDS FROM WAIT QUEUE, OR -1 TO IGNORE THEM.
;RESULT RETURNED IN AC1.  AC2 IS CLOBBERED.
;ESCAPE M ENTERS AT FINDDD TO FIND NEW HOME DD LINE.
;BREAK R ENTERS AT FINDD1 WITH AC1 CONTAINING CURRENT MAPPED DD.
↑FINDDD:MOVEI AC1,DDL0-1	;START AT BEGINNING OF DATA DISCS
↑FINDD1:TLZ AC2,377777		;JUST LEAVE SIGN BIT SET AS FLAG
	PUSH P,AC2		;REMEMBER PHYS TTY (KEYBOARD) AND FLAG
	SUB P,[1,,1]		;NOW WE CAN RETURN WITH POPJ
	JRST FINDD2

FINDDL:	LDB AC2,[DDQREQ+AC1,,LSTESC]
	CAIN AC2,@1(P)		;ARE WE RESPONSIBLE FOR THIS DD?
	JSP AC2,FINDDQ		;YUP
FINDD2:	CAIGE AC1,DDL0+DDNUM-1	;IS THIS THE LAST DD?
	AOJA AC1,FINDDL		;NO
	MOVEI AC1,DDL0		;YES, WRAP AROUND AND LOOK SOME MORE
FINDD3:	LDB AC2,[DDQREQ+AC1,,LSTESC]
	CAIN AC2,@1(P)		;ARE WE RESPONSIBLE FOR THIS DD?
	JSP AC2,FINDDQ		;YES
	CAIGE AC1,DDL0+DDNUM-1	;IS THIS THE LAST DD AGAIN?
	AOJA AC1,FINDD3		;NO, LOOK SOME MORE
↑FINDDF:MOVEI AC1,DDL0		;WELL THEN, FIND A FREE DD
	SKIPE LETAB(AC1)	;FIND HIM A FREE DD
↑FINDDN:AOJA AC1,.-1		;THERE BETTER BE ONE!!!  (SHOULD BE 27 OR MORE)
	POPJ P,			;HERE'S ONE

FINDDQ:	SKIPN LETAB(AC1)	;IS THIS DD IN USE?
	SKIPL 1(P)		;NO, MUST BE IN QUEUE--WANT THAT TYPE OF DD?
	POPJ P,			;RETURN THIS DD LINE NUMBER IN AC1
	JRST (AC2)		;NO, LOOK SOME MORE
;DDCHEK DDCSGT DDSGET DDCFND

;This whole page IFE FTF2

;SEE IF THIS GUY CAN HACK THIS DD CHAN (AC1)
;0 SKIPS FREE. 1 SKIP LOSE. 2 SKIPS HE'S GOT IT.
DDCHEK:	LDB AC2,[DDUSR(AC1)]
	JUMPE AC2,CPOPJ
	AOS (P)
;	HRRE AC3,JBTLIN(J)
	PUSH P,TAC
	PUSH P,DSER
	HRRE TAC,JBTLIN(J)
	SUBI TAC,DDL0		;Make line number relative to first DD
	MOVEI DSER,0		;Flag that TAC contains logical DD number
	AOS -2(P)		;Assume VDCCK0 wins
	PUSHJ P,VDCCK0		;See is we have access to this DD channel
	 SOS -2(P)		;Failed
	POP P,DSER
	POP P,TAC
	POPJ P,

;GET STATUS & # OF CONSOLE CHAN, AC UNCHANGED IF NONE (NOT DD)
DDCSGT:	PUSHJ P,DDCFND
	 POPJ P,
			;FALL THRU

;GET STATUS OF CHAN TAC(31-35)
DDSGET:	HLL TAC,DDTAB(TAC)
	POPJ P,

;FIND CONSOLE CHAN FOR JOB

DDCFND:	MOVE AC1,JBTLIN(J)
	TLNN AC1,DDDLIN
	POPJ P,
	JUMPL AC1,CPOPJ		;DETACHED
	HRRZ AC1,LETAB(AC1)
	HLR TAC,PRGNUM(AC1)	;PRETEND HE USED HIS CHAN AS ARG (PRESERVE LH)
	JRST CPOPJ1
;DDCSST DDSSET VDBIT VDSTR1

;This whole page IFE FTF2

;SET STATUS OF CONSOLE CHANNEL

DDCSST:	PUSHJ P,DDCFND
	 POPJ P,
			;FALL THRU

;HERE HE CAN SET THE STATUS OF A CHANNEL IF IT'S HIS

DDSSET:	MOVEI AC1,(TAC)
	PUSHJ P,DDCHEK
	 POPJ P,		;FREE CHANNEL CAN'T HAVE STATUS SET
	 POPJ P,		;SAME FOR SOMEONE ELSE'S CHANNEL
	MOVSI AC3,DDSMSK
	OFFSCN			;TURN OFF SCANNER CHANNEL
	ANDCAM AC3,DDTAB(AC1)
	AND AC3,TAC
	IORB AC3,DDTAB(AC1)
	PUSHJ P,SETHDN		;COPY DD CHAN PRIVACY BIT TO TTY'S HIDDEN BIT
	ONSCN			;TURN ON SCANNER CHANNEL
	HLL TAC,AC3
	AOS (P)
	JUMPL TAC,DDFLSH	;IF PRIVATE CHANNEL, FLUSH LOSERS
	POPJ P,

;ROUTINE TO COPY DD CHAN PRIVACY BIT TO TTY's HIDDEN BIT.  DD CHAN IS IN AC1.
SETHDN:	PUSH P,AC2
	LDB AC2,[DDUSR(AC1)]	;GET USER FIELD
	CAIL AC2,DTTUSR
	CAIL AC2,DTTUSR-DTTL0+DDL0+DDNUM
	JRST SETHD2		;NOT A DD'S MAIN CHANNEL
	PUSH P,AC3
	LDB AC3,[DDPRVT+AC1,,DDTAB] ;GET PRIVACY BIT
	DPB AC3,[PHIDDN+AC2,,LSTESC-DTTUSR+DTTL0] ;SET OR CLEAR HIDDEN BIT
	POP P,AC3
SETHD2:	POP P,AC2
	POPJ P,

;MAKES UP BIT (AC3) FROM DD CHAN (AC1)
↑VDBIT:	MOVNI AC2,(AC1)
	MOVSI AC3,400000
	LSH AC3,(AC2)
	POPJ P,

;THIS ROUTINE UPDATES BOTH PERMANENT & TEMPORARY (IF EXISTENT) MAPS
;WITH INTS OFF TO AVOID INCONSISTENT STATES
;TAC=CONSOLE #, @(P) IS DIDDLE INSTRUCTION
VDSTR1:	MOVEI AC2,VDPRM-VDTMP(TAC)
	OFFSCN			;TURN OFF SCANNER CHANNEL
	XCT @(P)		;DIDDLE PERMANENT MAP
	HRRZ AC2,TAC
	CAIL AC2,DDNUM		;SHADOW CHANNEL?
	JRST VDSTR3		;YES, NO TEMP MAP (NOR LETAB ENTRY)
	SKIPE AC2,LETAB+DDL0(TAC)
	XCT @(P)		;TEMP MAP, IF ANY
VDSTR3:	ONSCN			;TURN ON SCANNER CHANNEL
	JRST VDOUP0
;VDSTRU VDSTU1 VDSTU2 VDOUT VDOUT1 VDOUT2 VDOUT3

;This whole page IFE FTF2

;SET EITHER TEMPORARY OR PERMANENT MAPPING, DETERMINED BY
;SIGN BIT OF DSER (CALLED FROM VDSMAP ROUTINES)

VDSTRU:	TLNE DSER,VDABSO!VDXBIT
	JRST VDSTU1		;DO TO VDMAP IF ABSOLUTE
	JUMPL DSER,VDSTR1
	SKIPN AC2,LETAB+DDL0(TAC)
	JRST CPOPJ1
	XCT @(P)
	MOVSI AC3,400000
	IORM AC3,LETBPT(AC2)	;INDICATE TEMP MAP IN EFFECT
	JRST VDOUP0

VDSTU1:	OFFSCN			;TURN OFF SCANNER CHANNEL
	TLNE DSER,VDXBIT
	JRST VDSTU2
	MOVEI AC1,0		;THIS WILL BE VDTIE ENTRY
	JUMPL DSER,.+2		;IF TEMPORARY,
	MOVSI AC1,400000	;  SET FLAG IN VDTIE
	PUSHJ P,VDESAD
VDSTU2:	MOVEI AC2,VDMAP-VDTMP(TAC)
	XCT @(P)
	TLNN DSER,VDXBIT
	MOVEM AC1,VDTIE(TAC)
	ONSCN			;TURN ON SCANNER CHANNEL
	AOS (P)			;DROPS INTO VDOUT

;OUTPUTS CURRENT MAPPING (TEMPORARY, IF EXISTENT, ELSE PERMANENT)
;FOR CONSOLE C(TAC)
↑VDOUT:	JUMPL TAC,CPOPJ		;NO III'S HERE
VDOUT1:	HRRZ AC2,VDTIE(TAC)
	JUMPE AC2,VDOUT2
	SKIPE LETAB(AC2)
	SKIPA AC2,LETAB(AC2)
	SKIPA AC2,VDPRM-DDL0(AC2)
	MOVE AC2,VDTMP(AC2)
VDOUT3:	OFFSCN			;TURN OFF SCANNER CHANNEL
	CONO VDS,DPYNUM(TAC)	;WRAPS AROUND (SHADOW) IF TAC GREATER THAN DDNUM
	DATAO VDS,AC2
	JRST SCNONJ

VDOUT2:	MOVE AC2,VDMAP(TAC)
	JRST VDOUT3
;VDOUP0 VDOUTP VDOUP1 VDOUP2

;This whole page IFE FTF2

VDOUP0:	AOS (P)
↑VDOUTP:HRRZ AC2,TAC
	CAIL AC2,DDNUM		;SHADOW CHANNEL?
	POPJ P,			;YES, CAN'T BE ANYONE TIED TO THIS DD
	PUSH P,AC1		;NO, PROPAGATE TO EVERYONE TIED TO THIS DD
	PUSH P,AC3
	MOVEI AC3,DDL0(TAC)	;MAKE LINE NUMBER
	MOVSI AC1,-DDNUM	;LOOK THRU TABLE FOR PEOPLE TIED TO US
	SKIPN AC2,LETAB+DDL0(TAC)
	SKIPA AC2,VDPRM(TAC)	;WE ARE NOT IN USE--SHOW OUR PERMANENT MAP (NO TMP)
	MOVE AC2,VDTMP(AC2)	;WE ARE IN USE--SHOW OUR TEMP MAP TO EVERYONE
VDOUP1:	CAME AC3,VDTIE(AC1)	;THIS GUY TIED TO US?
	JRST VDOUP2		;NOPE
	OFFSCN			;TURN OFF SCANNER CHANNEL
	CONO VDS,DPYNUM(AC1)	;SHOW HIM OUR MAP
	DATAO VDS,AC2
	ONSCN			;TURN ON SCANNER CHANNEL
VDOUP2:	AOBJN AC1,VDOUP1	;LOOK FOR MORE DDs TIED TO US
	POP P,AC3
	POP P,AC1
	POPJ P,
;VDSMAP VDMAP1 VDMP1A

;This whole page IFE FTF2

;ALL-PURPOSE VDS DIDDLING UUO:  VDSMAP
;RH(AC)=ADR
;AC11-17 = TTY#, 0 means OWN CONSOLE
;AC9=1 means USE "SHADOW" CHAN INDICATED BY AC10-17
IFG PUNITS-8,<.FATAL PUNITS is too big for line field byte in VDSMAP UUO.>
;AC0=1 means PERMANENT CHANGE, 0 means TEMP CHANGE (GOES AWAY ON RESET)
;AC1=1 means AFFECT UNTIED MAP OF PHYSICAL TTY.  PRIVILEGED OP.
;    0 means AFFECT TEMP OR PERM MAP OF LINE.
;FINAL STATUS (TEMP/PERM PER AC0) STORED IN AC, -1 IF TTY NOT DD.
;AC6-8 = OPCODE:
;	0 - NOP, NEVER SKIPS, USEFUL FOR GETTING STATUS ALONE
;	1 - SET MAP FROM C(ADR), SKIPS IF ENTIRELY SUCCESSFUL (NO PRIVACY PROBLEM)
;	2 - IOR MAP FROM C(ADR), SET ANALOG IF ≠0. SKIPS ON COMPLETE SUCCESS.
;	3 - ANDCAM MAP FROM C(ADR), CLEAR ANALOG IF ≠0. FAILS ONLY ON BAD TTY #.
;	4 - RESET MAP. IN TEMP MODE THIS RESETS TEMP←PERM. IN PERM MODE PERM MAP
;			IS SET TO MAIN CHANNEL ALONE. FAILS ONLY ON BAD TTY #.
;	5 - GET LINE TIED TO.  NEVER SKIPS, RETURNS VDTIE ENTRY FOR TERMINAL
;	6 - TIE PHYSICAL TTY TO LINE IN AC RH (OR KBD-MAPPED LINE IF AC RH 0)
;	7 - ILLEGAL. CURRENTLY NO-OP.

↑VDSMAP:
	LDB AC1,[VDOP,,TAC]
	CAIL AC1,NVDOPS
	POPJ P,
	MOVE DSER,TAC
	CAIN AC1,6		;IF OP IS 6 (SET VDTIE),
	TLOA DSER,VDABSO	; SET BIT TO AFFECT PHYSICAL TTY
	XCTR XR,[SKIPA DAT,(TAC)]; AND DON'T USE AC RH AS A MASK
	MOVEI DAT,(TAC)		;  BUT AS IMMEDIATE OPERAND INSTEAD
	LDB TAC,[POINT PUNITS,TAC,17] ;Get TTY line number
	TLNE DSER,VDXBIT
	JRST VDMAP5
	JUMPN TAC,.+2
	HRRE TAC,JBTLIN(J)
	SUBI TAC,DDL0
	CAIGE TAC,DDNUM
	JUMPGE TAC,.+2
	JRST VDMAP4
	SKIPL VDDSP(AC1)
	JRST VDMAP2
	TLNE DSER,VDABSO
	JRST VDMP1A		;MUST BE PRIVILEGED TO HACK ABSOLUTE TTYS
	SKIPA AC2,JBTLIN(J)
VDMAP1:	MOVE AC2,JBTLIN(AC2)
	CAMN AC2,[-1]		;DETACHED?
	JRST VDMP1A
	CAIN TAC,-DDL0(AC2)
	JRST VDMAP2		;LET HIM BY IF IT'S HIS CHAN
	TLNE AC2,PTYLIN
	SKIPN AC2,PTYJOB-PTYL0(AC2)	;OR IF IT'S HIS VIA SOME PTY CHAIN
VDMP1A:	SKIPA AC2,JBTPRV(J)
	JRST VDMAP1
	TLNE AC2,UPGPRV		;OR IF HE HAS THE MAGIC PRIVILEGE
	JRST VDMAP2
	TLNE DSER,VDABSO
	JRST VDMAP3		;LOSE IF ABSOLUTE BIT AND NO UPG
	MOVE AC2,[TTYATC,,ASSCON+ASSPRG]
	SKIPE DDB,TTYTAB+DDL0(TAC)
	TDNN AC2,DEVMOD(DDB)
	JRST VDMAP2		;OR IF IT'S FREE
	LDB AC2,PJOBN
	CAIE AC2,(J)
	JRST VDMAP3
				;FALL THRU TO VDMAP2 IF HE OWNS THE CONSOLE
;VDMAP2 VDMAP3 VDMP30 VDMP31 VDGTIE VDMP32 VDMAP5 VDMAP4 VDDSP VDSTIE VDSTI1

;This whole page IFE FTF2

VDMAP2:	HLL TAC,VDDSP(AC1)
	TLZ TAC,400000		;DON'T CONFUSE VDOUT, after all we're not a III
	PUSHJ P,@VDDSP(AC1)	;VDSTIE DEPENDS ON AOS (P) AT .+2
	TLNE TAC,200000		;DON'T SKIP IF NOT REQUESTED
	AOS (P)			;NOTE THIS BIT WAS CLEARED BY ANY FAILURE
VDMAP3:	TLNE DSER,VDXBIT!VDABSO
	JRST VDMP31
	TLNN DSER,VDPERM	;GIVE HIM APPROPRIATE FLAVOR OF STATUS
VDMP30:	SKIPN DAT,LETAB+DDL0(TAC)
	SKIPA TAC,VDPRM(TAC)
	MOVE TAC,VDTMP(DAT)
	JRST STOTAC

VDMP31:	HRRZ DAT,VDTIE(TAC)	;HE WANTS STATUS FOR PHYSICAL TTY
	JUMPE DAT,VDMP32	;UNTIED, GET VDMAP
	MOVEI TAC,-DDL0(DAT)	;TIED, GET TEMP (IF ANY) MAP OF WHO HE'S TIED TO
	JRST VDMP30

VDGTIE:	POP P,(P)		;FLUSH RETURN ADDRESS
	SKIPA TAC,VDTIE(TAC)
VDMP32:	MOVE TAC,VDMAP(TAC)
	JRST STOTAC

VDMAP5:	ADDI TAC,DDNUM		;HERE TO MAP "SHADOW" CHANNELS
	CAIGE TAC,DPYNUM+DDNUM
	JRST VDMAP2
VDMAP4:	XCTR XW,[SETOM (UUO)]	;NOT DD - USE POSSIBLE BUT UNLIKELY VALUE TO FLAG THIS.
	POPJ P,

VDSTIE:	CAIL TAC,DDNUM		;SET VDTIE: MUSTN'T BE SHADOW CHANNEL
	POPJ P,
	JUMPN DAT,VDSTI1	;JUMP IF EXPLICIT LINE GIVEN
	LDB DAT,[POINT PUNITS,LINTAB+DDL0(TAC),35]
VDSTI1:	CAIL DAT,DDL0		;SEE IF IN RANGE
	CAIL DAT,DDL0+DDNUM
	POPJ P,
	AOS (P)			;SUCCESS
	MOVEM DAT,VDTIE(TAC)	;ALL OK, SET VDTIE
	JRST VDOUT1

VDDSP:	CPOPJ
	600000,,VDSET
	600000,,VDIOR
	600000,,VDACM
	600000,,VDRST
	VDGTIE			;FUNCTION 5 RETURNS VDTIE
	400000,,VDSTIE		;FUNCTION 6 SETS VDTIE
NVDOPS←←.-VDDSP
;VDSET VDIOR VDIOR1 VDACM VDRST VDRST1

;This whole page IFE FTF2

VDSET:	PUSHJ P,VDWCHK
	PUSHJ P,VDSTRU
	 MOVEM DAT,VDTMP(AC2)
	POPJ P,

VDIOR:	TRNN DAT,17
	JRST VDIOR1
	MOVEI AC3,17
	PUSHJ P,VDSTRU	;CLEAR ANALOG HERE SO THESE DON'T GET OR'ED
	 ANDCAM AC3,VDTMP(AC2)
VDIOR1:	PUSHJ P,VDWCHK
	PUSHJ P,VDSTRU
	 IORM DAT,VDTMP(AC2)
	POPJ P,

VDACM:	TRNE DAT,17
	TRO DAT,17	;ANYTHING IN ANALOG FIELD CLEARS IT ALL
	PUSHJ P,VDSTRU
	 ANDCAM DAT,VDTMP(AC2)
	POPJ P,

VDRST:	TLZ DSER,VDABSO
	JUMPL DSER,VDNORM
VDRST1:	HRRZ AC2,TAC
	CAIGE AC2,DDNUM		;SHADOW CHANNEL?
	SKIPN AC2,LETAB+DDL0(TAC) ;NO
	POPJ P,
	OFFSCN			;TURN OFF SCANNER CHANNEL
	MOVE AC3,VDPRM(TAC)
	MOVEM AC3,VDTMP(AC2)	;SET TEMP MAP FROM PERM
	ONSCN			;TURN ON SCANNER CHANNEL
	JRST VDRST2
;VDNORM VDRST2 VDNOR2 VDNOR3

;This whole page IFE FTF2

↑VDNORM:
	HRRZ AC2,TAC
	CAIGE AC2,DDNUM		;SHADOW CHANNEL?
	SKIPN AC2,LETAB+DDL0(TAC) ;NO
	SKIPA AC1,AVLCHN
	HLRZ AC1,PRGNUM(AC2)	;GET NORMAL CHANNEL OF ARG (MAPPEE)
	PUSHJ P,VDBIT
	PUSHJ P,VDSTR1		;ALWAYS TREAT AS PERMANENT REGARDLESS OF DSER
	 MOVEM AC3,VDTMP(AC2)	;  (WHICH IS USED BY ESC/BREAK N CODE IN LINED)
VDRST2:	HRRZ AC2,TAC
	CAIL AC2,DDNUM		;SHADOW CHANNEL?
	POPJ P,			;YES
	MOVSI AC3,400000
	SKIPE AC2,LETAB+DDL0(TAC)
	ANDCAM AC3,LETBPT(AC2)	;INDICATE NO TEMP MAP IN EFFECT
	MOVSI AC2,-DDNUM
	MOVEI AC1,DDL0(TAC)
VDNOR2:	SKIPL VDTIE(AC2)
	JRST VDNOR3
	LDB AC3,[POINT PUNITS,LINTAB+DDL0(AC2),35]
	CAIN AC3,(AC1)
	MOVEM AC1,VDTIE(AC2)
VDNOR3:	AOBJN AC2,VDNOR2
	JRST VDOUTP
;VDWCHK VDWCHL VDWOK VDWLUZ VDCCHK VDCCK0 VDCCK1 VDCCK5 VDCCK4 VDCCK2 VDCCK3 VDCCHK VDCCK0 VDCCK1 VDCCK2 VDCCK3

;This whole page IFE FTF2

;ROUTINE TO BLESS BITS ABOUT TO BE TURNED ON FOR PRIVACY VIOLATION
;LOSING BITS ARE FLUSHED, AND SKIP FLAG IS CLEARED
VDWCHK:	MOVSI AC1,-40
VDWCHL:	JUMPGE DAT,VDWOK
	SKIPL DDTAB(AC1)
	JRST VDWOK
;	HRRE AC3,JBTLIN(J)
	PUSHJ P,VDCCHK		;TRYING TO LOOK AT PRIVATE CHAN, SEE IF IT'S OK
	 JRST VDWLUZ		;NO, FLUSH THIS CHAN'S BIT IN THE MASK
VDWOK:	ROT DAT,1
	AOBJN AC1,VDWCHL
	ROT DAT,4
	TRNN DAT,17
	POPJ P,
	LDB AC1,[300,,DAT]
	IOR DAT,VDSYNC(AC1)
	POPJ P,

VDWLUZ:	TLZ DAT,400000		;FLUSH PRIVATE CHANNEL FROM MASK
	TLZ TAC,200000		;FLAG AN ERROR
	JRST VDWOK

;Routine to see if we have access to a DD channel.
;AC1/ DD channel number
;DSER/ VDABSO,,0 bit on if we are showing this channel to absolute TV monitor (TAC)
;TAC/ Either (1) Absolute number (line number - DDL0) of TV monitor to see chan
;     or     (2) Logical DD line (line number - DDL0) of DD line to see chan
;J/ job number of job requesting access (or zero if TTY is requesting access)
↑VDCCHK:LDB AC2,[DDUSR(AC1)]	;Get channel use field
VDCCK0:	TRNE AC2,DTTUSR!DSPUSR	;Skip if channel belongs to some job
	JRST VDCCK2		;Belongs to DD line or is special
VDCCK1:	CAIN J,0(AC2)		;Does channel belong to us?
	JRST CPOPJ1		;Yes
	HRRE AC2,JBTLIN(AC2)	;Get TTY line that the DD's owner job is on
	JUMPL AC2,CPOPJ		;Give up if job is detached
VDCCK5:	TLNN DSER,VDABSO	;Are we showing this DD chan to absolute TV monitor?
	JRST VDCCK4		;No
	LDB AC3,[DDQREQ+AC2,,LSTESC] ;Yes, get TTY responsible for owner line
	CAIN AC3,DDL0(TAC)	;Is TV monitor the responsible TTY?
	JRST CPOPJ1		;Yes
VDCCK4:	HLL AC2,LINTAB(AC2)	;Get characteristics of owner line
	TLNN AC2,PTYLIN		;If it's a PTY, we'll check its controlling job(s)
	JRST VDCCK3		;Otherwise, check if we're showing DD to owner line
	MOVE AC2,PTYJOB-PTYL0(AC2) ;Get PTY's controlling job
	JRST VDCCK1		;See we are the controlling job

VDCCK2:	TRNE AC2,DSPUSR		;Skip if DD channel is owned by DD line
	POPJ P,			;DD channel is special
	SUBI AC2,DTTUSR-DTTL0	;Calculate owner DD line number
	JRST VDCCK5		;Check responsibility for DD line

VDCCK3:	TLNE DSER,VDABSO	;Are we showing DD chan to a DD line?
	POPJ P,			;No
	MOVEI AC2,(AC2)		;Flush line characteristics from LH
	CAIN AC2,DDL0(TAC)	;Is that DD line the chan's owner somehow
	AOS (P)			;Yes, access granted
	POPJ P,

>;IFE FTF2	;Last of many pages

BEND DPYSER
BEGIN WHOSER  ↔ SUBTTL WHO LINE GENERATOR ;	WHOINI
;R. HELLIWELL--6/APR/70

COMMENT ⊗
	THIS ROUTINE ALLOWS EACH LUCKY OWNER OF A DISPLAY
TO HAVE ONE LINE OF "WHO" INFORMATION ON HIS SCREEN AT ANY TIME
IT USES THE LINE EDITOR FOR ACTIVATION IN THE FOLLOWING MANNER.

	<ESC>W
	TO DISPLAY THE WHO LINE FOR THE JOB ATTACHED TO THIS DPY.

	<ESC><N>W
	TO DISPLAY THE WHO LINE FOR JOB N ON THIS DPY.

	<BREAK>W
	STOP THE WHO LINE.

LOOK FOR CODE IN THE LINE EDITOR AROUND THE LABEL "ESCW".
See also WHOQUE and WHOQDM in DPYSER.
WHOSER IS CALLED FROM CLKINT.
⊗


IFE FTF2,<	;NOTE: DPYSER (MAIN PART) USES DIFFERENT NO-OP!
DISNOP←←12		;GOOD NO-OP WITH NO BITS.
>;IFE FTF2

;AC'S USED
;WHO IS FOR DPY # AND JOB STATUS WORD.
;TAC, TAC1, AC2, AND DAT ARE SORT OF TEMPORARY
;AC1 LOCATION OF FREE STORAGE BUFFER.
;AC3 BYTE POINTER TO FREE STORAGE, INDEXED BY AC1
;J CONTAINS JOB NUMBER OF WHO LINE.

;WHOPTR = 0 means LINE IS FREE.
;	= LINE NUMBER means LINE IS WAITING TO HAVE WHOLINE QUEUED
;	= -2 OR -1 means LINE HAS BEEN QUEUED and has 2 or 1 fields left to go out.

;Macro to count bytes in system wholine from 0 to 79+n (decimal)
;(where n is number of nulls imbedded).
;Converts count to byte pointer pointing at previous real byte
;(ready for DPB WHOSBP(A+1) or MOVE AC3,WHOSBP(A) and IDPB AC3).
DEFINE WHOSBP(A) <[POINT 7,COMWHO+<<A-1>/5>,<-1+7*<A-5*<<A-1>/5>>>]>

WHO←TEM			;DPY INDEX AT TOP LEVEL.

↑WHOINI:SETOM AVLFST	;THIS IS AOSN'ED TO DECIDE TO WRITE ON AVLCHN ONCE
IFE FTSUAI,<
	MOVE AC3,WHOSBP(=72)
	MOVEI TEM,0
	MOVEI TAC,11
	IDPB TEM,AC3
	SOJG TAC,.-1	;Flush temperature part from F2's system wholine
	MOVE AC3,WHOSBP(=8)
	IDPB TEM,AC3
	IDPB TEM,AC3	;Flush 1200/1200-300/150/110 dialup count from wholine
>;IFE FTSUAI
	PUSHJ P,WHOSYS		;INITIALIZE SYSTEM WHOLINE
	SETOM WHOKLU		;THIS MAKES WHOSER PUT THE MSG OUT
	POPJ P,
;CELLS FORMERLY CLEARED HERE ARE ALL BETWEEN SYSBEG AND SYSEND AND
;THUS GET ZEROED AT SYSINI
;WDMPTY NWHOTX NWHOKL NWHOTX WHOSER WHODO9 WHODO8 WHOD8A WHOEGR WHOIII WHODO WHODO9 WHODO8 EXTRDM WHOPTY WHOPT2 EXTRGR EXTRDD EXTRG2 EXTRA0 EXTRA1 WHODOE

LOSYS		;BOTH PROCESSORS GET HERE

IFE FTF2,<
WDMPTY←←2	;Check a PTY (or extra) DM every 2 regular DMs, must be power of 2
NWHOTX←←JIFSEC/(6*DPYNUM) 	;Do fast part of each III wholine every 1/6 sec
NWHOKL←←=60*JIFSEC/(NWHOTX*DPYNUM) ;Number of DD wholines done between movements
				   ;of the available message (60 seconds).
>;IFE FTF2
IFN FTF2,<
NWHOTX←←<7*JIFSEC>/<SCNNUM+DDNUM> ;About 7 secs per wholine update -- the timing
				  ;  comments below do NOT apply for F2.
NWHOKL←←=60*JIFSEC/NWHOTX	  ;Number of wholines done between movements
				  ;of the available message (60 seconds).
>;IFN FTF2

Comment ⊗

NWHOTX is the number of ticks (60th of a sec) between WHOSER activations.
The interval between wholine updates for each display type (III, DD and
DM), is proportionate to NWHOTX.  The cell WHOTX contains the count down
until the next WHOSER activation.

On each activation of WHOSER, one III wholine is done (fast part).  Once
each time all of the III fast parts have been done, one DD wholine is
done.  The DDs are done by DD channel number, so there are =32 of them to
consider.  One of the DDs is the available channel, which is updated only
if the WHOPHN job isn't running.

Each time a DD is done, a normal DM (non-PTY) is done.  Every fourth time
a DD is done, a PTY DM or any extra DM is done.

Extra wholines are those done immediately (or very soon) after a user
types ESC n W.  They are done specially for DMs and DDs, but not for IIIs,
which are updated fast enough not to need speedier service.  For DDs,
WHOSER checks for and does one extra DD wholine for each regular DD
wholine done.  This means an extra DD wholine should be displayed within
1/6 second of the ESC n W.  For DMs, one extra is checked for and done
each time a PTY wholine would be done, which is 1/4 as often as DDs; so an
extra DM should be done within 4/6 sec of the ESC n W.  Of course, if
there are lots of extra wholines to be done, then some of them will be
delayed.

			should be			experiment shows
III wholine fast part:	1/6 second
III wholine slow part:  2/3 sec = 4*(1/6) sec
DD wholine updates:	5 1/3 sec = 32*(1/6) sec		5.7 secs
Regular DM updates:	7 5/6 sec = (48/32)*(5 1/3) sec		8.4 secs
PTY DM updates:		10 sec = (15/32)*4*(5 1/3) sec		10.7 secs
Extra DD wholine done:	1/6 sec
Extra DM wholine done:	2/3 sec = 4*(1/6)

This is all subject to change if any one of SCNNUM (=48) or PTYNUM (=15)
or DDNUM (=32) changes.  If DPYNUM (2) changes, then to first order
approximation, the timings will remain the same for all displays, since
the WHOSER activation interval is based on DPYNUM.

Also, both DD and DM wholine activity can be slowed down by any DD wholine
not going out before the next one would be calculated (i.e., if the instr
at WHODO9-1 jumps).  Experimentally, it has been observed that about 4%
of the DD wholines are late enough going out to postpone the next wholine,
causing about a 4% increase in the update times.  The actual update times
observed show about a 7% increase for some reason. -- ME 19 Jan 80

end of comment ⊗


↑WHOSER:
;	MOVE DAT,TIME
;	TOT DAT,BARGE
;	TRNE DAT,1		;EVEN TIC?
;	POPJ P,			;NO, SKIP IT.
	SOSLE WHOTX		;Time to think about wholines?
	POPJ P,			;Nope
	MOVEI DAT,NWHOTX	;Reset counter
	MOVEM DAT,WHOTX		;Tick count till next time

	MOVEI AC1,0
	EXCH AC1,FREWAT				
	SKIPE AC1		;WAITING TO GIVE BACK FREE STORAGE?
	PUSHJ P,FSGIVE		;YES. DO IT.
IFN FTF2,<
WHODO9:	SOSLE WHOKLU		;COUNT DOWN TO AVL MSG SHIFT
	JRST WHOD8A
IFN FTDD!FTGRIN,<
	PUSHJ P,DDAVST		;THIS MOVES AVAILABLE MESSAGE
>;IFN FTDD!FTGRIN
	SKIPN J,WHOJOB		;IS THERE A MINI-WHO PHANTOM?
	JRST WHODO8		;NO
	MOVSI AC1,INTTTI	;GIVE HIM AN ESC I INTERRUPT IF DESIRED
	TDNE AC1,JBTIEN(J)	;IS HE ENABLED FOR IT?
	PUSHJ P,TTINT		;YES, DO IT.
WHODO8:	MOVEI AC1,NWHOKL	;Number of WHODOs before next shift of avl msg
	MOVEM AC1,WHOKLU	;Shift again in about a minute
WHOD8A:	SOSGE WHO,WHDDNXT	;Which TTY is next for wholine
	PUSHJ P,WHOSYS		;END OF TTYs.  RECALCULATE SYSTEM LINE.
	PUSHJ P,EXTRDM		;Do an "extra" DM wholine or check for a PTY DM
IFN FTGRIN,<
	PUSHJ P,EXTRGR		;Think about doing an extra Grinnell wholine now
	 JRST [	PUSHJ P,WHODOE	;Got an extra DD, do it (WHDDNXT has been AOSed)
		JRST WHOEGR ]	;Store number for WHOQUE
	MOVE WHO,WHDDNXT	;Get back current line number for wholine
	HLL WHO,LINTAB(WHO)	;Get characteristics bits
	TLNE WHO,DMLIN
>;IFN FTGRIN
IFE FTGRIN,<
	MOVE WHO,WHDDNXT	;Get back current line number for wholine
>;IFE FTGRIN
	JRST WHODM2		;Check for a normal DM wholine
IFN FTGRIN,<
	TLNN WHO,DDDLIN
	POPJ P,			;Not a display, I guess, forget it
	SKIPE WHOPTR		;Don't think about next wholine if last not out yet
	JRST EXTRG2		;Re-AOS WHDDNXT so we'll re-try this one next time
	PUSHJ P,WHODO1		;Generate Grinnell wholine
WHOEGR:	HRRZM WHO,WHOPTR	;SET TO FLAG WHOQUE.
	POPJ P,
>;IFN FTGRIN
>;IFN FTF2
IFE FTF2,<
;WE DO WHO LINES FOR 5 III DISPLAYS IN 10. TICKS, THEN
;ON THE 12.TH  TICK WE DO ONE DD LINE AND THE OTHER III.
WHOIII:	SOSL WHO,WHONXT		;NEXT GUY TO DO.
	JRST WHODO5		;JUMP IF THERE'S ANOTHER III TO DO
WHODO:	MOVE TAC,DDOFF		;DATA DISC IS OFF?
	JUMPN TAC,WHODO9	;JUMP IF DD IS OFF.
	MOVE TAC,WHOPTR		;DD WHO LINE STILL BUSY?
	JUMPN TAC,WHODO2	;IF SO, LEAVE EARLY.
WHODO9:	SOSLE AC1,WHOKLU	;COUNT DOWN TO AVL MSG SHIFT
	JRST WHODO4
	PUSHJ P,WHODDC		;Update count of DD channels in use
	PUSHJ P,DDAVST		;THIS MOVES AVAILABLE MESSAGE
	SKIPN J,WHOJOB		;IS THERE A MINI-WHO PHANTOM?
	JRST WHODO8		;NO
	MOVSI AC1,INTTTI	;GIVE HIM AN ESC I INTERRUPT IF DESIRED
	TDNE AC1,JBTIEN(J)	;IS HE ENABLED FOR IT?
	PUSHJ P,TTINT		;YES, DO IT.
WHODO8:	MOVEI AC1,NWHOKL	;Number of WHODOs before next shift of avl msg
	MOVEM AC1,WHOKLU	;Shift again in about a minute
	MOVEI WHO,DDAVLU	;WHOKLU SET, SERVICE AVLCHN NOW
	JRST WHODO3
>;IFE FTF2

EXTRDM:	MOVE AC3,[-LDMWQ,,DMWQ]	;Aobjn ptr to table of DM extra wholine requests
	SKIPE DMWQNX
	POPJ P,			;Last wholine requested not done yet
	PUSHJ P,EXTRA0		;Find an extra DM
	 PUSHJ P,WHODOE		;Got one, do it unless DM's wholine busy
	  JRST WHOPTY		;Didn't find extra, or its wholine busy
	HRLI WHO,400000		;Flag P1 to queue both lines of DM wholine
	MOVEM WHO,DMWQNX	;Extras and PTYs use this cell
	POPJ P,

WHOPTY:	SOS WHO,NXTPTY		;Look for next PTY to give wholine
	CAIL WHO,PTYL0
	JRST WHOPT2
	MOVEI WHO,PTYL0+PTYNUM-1
	MOVEM WHO,NXTPTY
WHOPT2:	PUSHJ P,WHODO1		;Skips for DM if ready for new wholine
	 POPJ P,		;DM's wholine is busy, or no job or dpy hdr
	PUSHJ P,DMUSLN		;See if user line has changed
	MOVEM WHO,DMWQNX	;Tell DPYCLK to queue up this DM's wholine
	POPJ P,

IFN FTGRIN,<
EXTRGR:	SKIPE WHOPTR		;Don't try to do extra Grin if last Grin wholine
	JRST CPOPJ1		; isn't done yet.
>;IFN FTGRIN
IFN FTDD!FTGRIN,<
EXTRDD:	MOVE AC3,[-LDDWQ,,DDWQ]
	PUSHJ P,EXTRA0		;Find an extra DD
>;IFN FTDD!FTGRIN
EXTRG2:	 AOSA WHDDNXT		;Don't forget to do someone next time
	AOS (P)			;No extras
	POPJ P,

;HERE TO FIND AN EXTRA WHOLINE TO DO.
EXTRA0:	MOVEI WHO,0
EXTRA1:	EXCH WHO,(AC3)
	JUMPN WHO,CPOPJ		;Got an extra line's wholine to do
	AOBJN AC3,EXTRA1
	JRST CPOPJ1		;No extras

WHODOE:	HRROS (P)		;Flag that we're doing an extra
	JRST WHOD1A
;WHODO4 WHODO3 WHODO2 WHODO5 WHODO1 WHOD1A DMWOK

IFE FTF2,<
GLOBAL DDUSR

WHODO4:	TRNN AC1,WDMPTY-1	;Check DM extras or PTY DM wholine every nth DD
	PUSHJ P,EXTRDM		;Do an "extra" DM wholine or check for a PTY DM
	PUSHJ P,WHODM		;Check for a normal DM wholine once for each DD
	SOSGE WHO,WHDDNXT	;Which DD channel is next for wholine
	PUSHJ P,WHOSYS		;END OF DD.  RECALCULATE SYSTEM LINE
	PUSHJ P,EXTRDD		;Think about doing an extra DD wholine now
	 JRST [	PUSHJ P,WHODOE	;Got an extra DD, do it
		JRST WHODO3 ]	;Now do next III
	MOVE WHO,WHDDNXT	;EXTRDD clobbered WHO
	LDB WHO,[DDUSR(WHO)]	;MAP FROM DD CHANNEL TO TTY NUMBER
	CAIN WHO,DDAVLU		;AVAILABLE CHANNEL?
	JRST WHODO3		;YES, SKIP WHODO1
	CAIL WHO,DTTUSR
	CAIL WHO,DTTUSR-DTTL0+DDL0+DDNUM
	JRST WHODO2		;NOT USER'S CONSOLE
	SUBI WHO,DTTUSR-DTTL0	;MAKE TTY NUMBER
	PUSHJ P,WHODO1		;GO REFRESH ONE MORE DD WHO LINE
WHODO3:	HRRZM WHO,WHOPTR	;SET TO FLAG WHOQUE.
WHODO2:	MOVEI WHO,DPYNUM-1	;START ON III DISPLAYS AGAIN
	MOVEM WHO,WHONXT	;SAVE INDEX OF WHO WAS DONE LAST
WHODO5:	MOVEI WHO,DPYL0(WHO)	;WHODO1 NOW EXPECTS LINE NUMBER IN WHO
>;IFE FTF2
WHODO1:	HRRZS (P)		;Flag not doing an extra
WHOD1A:	HLL WHO,LINTAB(WHO)	;GET DISPLAY-TYPE BIT IN LH
	MOVE AC1,FRETAB(WHO)	;GET THE FREE STORAGE BLOCK
	MOVE DDB,LETAB(WHO)	;GET PTR TO DPY HEADER
	JUMPE DDB,WHOCLR	;JUMP IF NO DPY HEADER
	HRRZ J,WHOTAB(DDB)	;GET JOB NUMBER FOR THIS LINE.
	MOVE DAT,JBTSTS(J)	;GET JOB'S STATUS WORD
	TLNN DAT,JNA		;IS IT STILL THERE?
	SETZB J,WHOTAB(DDB)	;NO, FLUSH!
	JUMPE J,WHOCLR		;JUMP IF NO WHO REQUEST
	TLNE WHO,DMLIN
	JRST DMWCHK		;See if previous wholine is done for this DM
;FALL THRU AND CHECK FOR RELEASE OF FREE STORAGE
DMWOK:	JUMPE AC1,WHOSET	;JUMP IF WE NEED TO MAKE FS BLOCK.
IFE FTF2,<
	JUMPGE WHO,WHOLIN	;ALWAYS UPDATE SLOW PART FOR DD AND DM
	MOVE DAT,WHDDNXT
	TRNE DAT,3		;UPDATE WHOLE III AFTER 4 DATA DISCS
	JRST ALWAYS		;JUST DO THE FAST PART THIS TIME
>;IFE FTF2
	JRST WHOLIN		;COMPUTE ENTIRE LINE.
;WHOCLR WHODM WHODM2 DMUSLN DMUSL3 DMUSL4 DMWCHK DMWCH3

WHOCLR:	JUMPE AC1,CPOPJ		;DO WE HAVE FREE STORAGE BLOCK
	SETZM FRETAB(WHO)	;YES. CLEAR FRETAB
	HRRZM AC1,FREWAT	;YES, QUEUE IT FOR NEXT TIC.
IFE FTF2,<
	JUMPGE WHO,CPOPJ	;LEAVE IF THIS IS NOT A III
	HRRZ DDB,LETAB(WHO)
	JUMPE DDB,CPOPJ		;IF SLIPPED OUT FROM UNDER US, FORGET IT
	MOVEI TAC,DISNOP	;RESET WHOCALL.
	MOVEM TAC,WHOCALL(DDB)
	MOVSI TAC,400000	;DONT SELECT III FOR SYS WHO LINE
	MOVNI AC2,-DPYL0(WHO)
	LSH TAC,(AC2)
	ANDCAM TAC,WHOSEL	;TURN OFF SET BIT
	LSH TAC,-=12		;DESELECT THIS III FOR SYS WHO LINE
	IORM TAC,WHOSEL		;TURN ON RESET BIT
	HRRZ AC3,PRGNUM(DDB)	;GET TTY NUMBER
	MOVEI AC2,PSELB(DDB)	;INVENT A RESTARTING JMP FOR IT AND
	HRLI AC2,DISJMP		;PUT IN RSTTBL SO PRGM WILL GET
	MOVSM AC2,PRGSTP(DDB)	;Clobber old continue PC to really restart
	MOVSM AC2,RSTTBL-DPYL0(AC3) ;STARTED AT ITS BEGINNING NEXT TIME.
>;IFE FTF2
	POPJ P,

IFE FTF2,<
WHODM:	SKIPE WHDMPT		;Any DM wholine yet to be queued?
	POPJ P,			;Yes, don't do any more
	SOSL WHO,NEXTDM
	JRST WHODM2		;GO DO THIS TTY IF IT IS A DISPLAY (DM)
	MOVEI WHO,SCNNUM-1	;Highest numbered TTY getting DM wholine
	MOVEM WHO,NEXTDM	;START OVER
>;IFE FTF2
WHODM2:
IFN FTF2,<
	SKIPE WHDMPT		;Any DM wholine yet to be queued?
	JRST EXTRG2		;Yes, don't do any more, backup WHDDNXT
>;IFN FTF2
	PUSHJ P,WHODO1		;Skips for DM if ready for new wholine
	 POPJ P,		;DM's wholine is busy, or no job or dpy hdr
	PUSHJ P,DMUSLN		;See if user line has changed
	MOVEM WHO,WHDMPT	;Tell DPYCLK to queue up this DM's wholine
	POPJ P,

DMUSLN:	MOVEI AC1,(AC1)		;LH of AC1 will count text words to suppress
	MOVE AC2,[-WLINK+WTEND,,DMWCOP] ;AOBJN ptr to copy of previous text
DMUSL3:	MOVE AC3,WTEND(AC1)	;Get new text word
	CAME AC3,(AC2)
	JRST DMUSL4		;User line has changed
	AOBJN AC1,.+1
	AOBJN AC2,DMUSL3
	TLZA AC1,400000		;Don't need to output user line
DMUSL4:	TLO AC1,400000		;Make sure WHDMPT is non-zero
	HLL WHO,AC1		;Pass number of text words to suppress
	POPJ P,

DMWCHK:	HRRZ AC2,DMWHO(DDB)	;Get pointer to first entry in DM WHO queue
	CAIE AC2,DMWHO-QLINK(DDB) ;Does it point to header itself?
	POPJ P,			;Direct return from WHODO1 to indicate busy
	AOS (P)			;Make WHODO1 skip to indicate winning
	JUMPE AC1,DMWCH3	;Jump if this is first time
	MOVSI AC2,WTEND(AC1)	;Copy previous text of user part of wholine
	HRRI AC2,DMWCOP
	BLT AC2,DMWCOP+WLINK-WTEND-1
	JRST DMWOK

DMWCH3:	SETZM DMWCOP		;Make test for no change fail
	JRST DMWOK
;WHOSIX WHOSXX WSDPAD WSDPD3 WSDPD2 WSDPD0 WSDNUL WSDDEC WSDOCT WSDPD1 WPER2D W0PD2 DECPDF WHPRNT

WHOSIX:	MOVEI AC2,6		;CHARACTER COUNT
WHOSXX:	MOVEI TAC,0		;DATA IN TAC1
	LSHC TAC,6
	ADDI TAC," "
	IDPB TAC,AC3
	SOJG AC2,WHOSXX
	POPJ P,

;WSDPAD - CALL WITH
;	AC3 = BYTE POINTER
;	AC2 = CHARACTER COUNT
;	TAC = DATA
;	TAC1, UCHN, DAT ARE CLOBBERED.
;	PRINTS NUMBER WITH LEADING SPACES.
;CALL WSDPD2 WITH UCHN = RADIX; DAT = PADDING CHARACTER. AC3,AC2,TAC AS ABOVE.
;CALL WSDPD3 WITH UCHN = RADIX.  USES BLANK PADDING.
WSDPAD:	MOVEI UCHN,=10
WSDPD3:	MOVEI DAT," "		;PADDING CHARACTER
WSDPD2:	IDIVI TAC,(UCHN)
	HRLM TAC1,(P)
	SUBI AC2,1		;COUNT A CHARACTER GENERATED.
	JUMPE TAC,WSDPD1
	PUSHJ P,WSDPD2
WSDPD0:	HLRZ TAC,(P)
	ADDI TAC,"0"
	IDPB TAC,AC3
	POPJ P,

WSDPD1:	SOJL AC2,WSDPD0		;HERE TO INSERT PADDING WHEN DIGITS ENDED
	IDPB DAT,AC3		;PAD ONCE
	JRST WSDPD1		;MAYBE NEED MORE PADDIG

WSDNUL:	MOVEI DAT,0		;NULL PADDING
WSDDEC:	MOVEI UCHN,=10		;DECIMAL PRINT
	JRST WSDPD2

WSDOCT:	MOVEI UCHN,10		;OCTAL PRINT
	JRST WSDPD3		;WITH BLANK PADDING

WPER2D:	IMULI TAC,=100		;PRINT TAC/TAC1 AS A PERCENTAGE IN 2 DIGITS
	IDIV TAC,TAC1
	CAIL TAC,=100
	MOVEI TAC,=99		;PRINT 99 FOR 100
				;FALL INTO W0PD2

;PRINT A 2 DIGIT DECIMAL NUMBER PADDED WITH A LEADING ZERO IF NECESSARY
;CALL WITH NUMBER IN TAC, BYTE POINTER IN AC3.  CLOBBERS TAC1
W0PD2:	IDIVI TAC,=10
	ADDI TAC,"0"
	IDPB TAC,AC3
	ADDI TAC1,"0"
	IDPB TAC1,AC3
	POPJ P,

;PRINT A DECIMAL NUMBER PADDING WITH FOLLOWING BLANKS
;	TAC = DATA
;	AC2 = CHARACTER COUNT
;	AC3 = BYTE POINTER
;TAC, AC2, TAC1 AND DAT ARE CLOBBERED
DECPDF:	MOVEI DAT," "		;THIS IS THE CHARACTER TO PAD WITH
	PUSHJ P,WHPRNT		;CONVERT TAC TO ASCII AND SAVE CHARACTERS
	SOJL AC2,CPOPJ		;ANY PADDING NEEDED?
	IDPB DAT,AC3		;YES.  PAD WITH A BLANK
	SOJGE AC2,.-1		;MORE PADDING NEEDED?
	POPJ P,			;NOPE

WHPRNT:	IDIVI TAC,=10		;ROUTINE TO DO THE WORK FOR DECPDF
	HRLM TAC1,(P)
	JUMPE TAC,.+2
	PUSHJ P,WHPRNT
	HLRZ TAC,(P)
	ADDI TAC,"0"
	IDPB TAC,AC3		;DEPOSIT ONE DECIMAL DIGIT
	SUBI AC2,1		;NOTE THAT WE HAVE PUT OUT A CHARACTER
	POPJ P,
;⊗ WHITTY WHIOWQ WHIOW2 WHIOW3 ALWAYS ALWA01 ALWA00 ALWAY3 NOIDLE DOIDLE ALWY3A ALWY3B XTALL NOXTIM NOXTM1 DOTIME WHOTIM WHRMIN WMIN LNGMIN

;HERE WHEN IN IOWQ FOR TTY INPUT.  IOS IS IN AC2.
WHITTY:	TLO AC2,IO		;PRETEND IO REALLY ON IF OUTPUT WAIT
	JUMPGE AC2,WHIOW2	;JUMP IF NOT WAITING FOR INPUT (TTYIOW BIT OFF)
	TLNE AC2,TPMON		;IF TTY IN MONITOR MODE,
	MOVE AC2,TTYBTS(TAC1)	; THEN GET SAVED VERSIONS OF WAIT BITS
	MOVE TAC,[ASCID/LINE /]
	TLNE AC2,DDTM		;AWAITING JUST A CHAR?
	MOVE TAC,[ASCID/CHAR /]
	TLNE AC2,SNKWAT		;MAYBE REALLY JUST SNEAKING A CHAR?
	MOVE TAC,[ASCID/SNK  /]
	JRST ALWA01

;HERE TO PRINT DEVICE NAME AND "I" OR "O" IF JOB IN IOWQ FOR A DEVICE
WHIOWQ:	MOVE AC2,@DEVSPT(TAC1)	;GET IOS FOR THIS DEVICE
	MOVE AC3,DEVMOD(TAC1)	;SEE WHAT KIND OF DEVICE THIS IS
	TLNE AC3,DVTTY		;IF AWAITING TTY INPUT, REPORT SPECIAL STATUS
	JRST WHITTY		;TTY IS SPECIAL
WHIOW2:	MOVE AC3,[POINT 7,WTEND+3(AC1)]
	HLLZ TAC1,DEVNAM(TAC1)	;GET GENERIC DEVICE NAME
	PUSH P,TAC1		;SAVE DEVICE NAME
	PUSH P,AC2		;SAVE IOS
	MOVEI AC2,3		;NUMBER OF CHARS OF DEVICE NAME TO PRINT
	SKIPN TAC1
	MOVSI TAC1,'TTY'	;DETACHED TTY DDB
	PUSHJ P,WHOSXX		;PRINT GENERIC NAME
	POP P,AC2		;GET BACK IOS
	POP P,TAC1
	MOVS TAC1,TAC1
IFN FTIP,<
	CAIN TAC1,'IMP'
	TLNE AC2,IDATWT		;This bit set for IMP input data wait
	CAIA			;Not IMP, or IMP in input wait
	JRST WHIOW3		;Protocol or output wait
>;IFN FTIP
IFN PUPNUM,<
	CAIE TAC1,'PUP'		;PUPS AND DIALNETSES ONLY HAVE ONE WAIT STATE,
>;IFN PUPNUM
	CAIN TAC1,'DLN'		;IE, A "PROTOCOL WAIT" (RFNM/ACK OR INPUT)
WHIOW3:	SKIPA TAC1,["W"]	;IO WILL NEVER BE SET, SO THIS WILL WIN
	MOVEI TAC1,"I"		;ASSUME DOING INPUT
	TLNE AC2,IO		;DOING OUTPUT?
	MOVEI TAC1,"O"		;YUP
	IDPB TAC1,AC3
	IBP AC3
	JRST ALWA00

;THIS IS THE PART WE ALWAYS UPDATE.
ALWAYS:	ANDI J,-1		;MAKE CAMN WORK, CLEAR "DOING IDLE TIME" FLAG
	MOVM TAC,JOBQUE(J)	;GET QUEUE NUMBER.
	CAIN TAC,IOWQ		;HANDLE THIS QUEUE SPECIALLY
	SKIPN TAC1,JBTIOW(J)	;GET DDB WSYNC IS WAITING FOR
	SKIPA TAC,QNAMS(TAC)	;GET PRINT NAME OF QUEUE
	JRST WHIOWQ		;SEE IF WAITING FOR SOME DEVICE
ALWA01:	MOVE AC3,[POINT 7,WTEND+3(AC1),34]
	TRO TAC,1
	MOVEM TAC,@AC3
ALWA00:	MOVE DAT,JBTSTS(J)
	MOVEI TAC," "
	CAMN J,JOB		;CURRENTLY RUNNING JOB?
	MOVEI TAC,"-"		;YES
	TLNE DAT,SWP		;SWAPPED OUT?
	MOVEI TAC,"*"		;YES
	TRNE DAT,JLOCK		;LOCKED IN CORE?
	MOVEI TAC,"⊗"		;YES
	DPB TAC,AC3

	MOVEI TAC," "
	SKIPE SPWGO(J)		;SPACEWAR ON P1?
	MOVEI TAC,"\"		;YES
	LDB TAC1,PSEGN		;IS THERE A SEGMENT?
	JUMPE TAC1,ALWAY3	;NO
	MOVE TAC1,JBTSTS(TAC1)	;YES
	TLNE TAC1,SWP		;IS IT SWAPPED OUT?
	MOVEI TAC,"*"		;YES
ALWAY3:	IDPB TAC,AC3

;PRINT XTIME INCREMENT, UNLESS IDLE FOR MORE THAN 5 MINUTES
	JUMPE DDB,.+2		;JUMP IF TTY WHO CMD (AC "WHO" NOT SET UP!)
	JUMPL WHO,NOIDLE	;CAN'T DO IDLE TIME ON IIIS
	TLNN DAT,JSEG		;DON'T PRINT IDLE TIME FOR SEGMENTS!
	SKIPGE -1(P)		;LOOK AT FLAG IN WHOLIN'S RETURN PC
	JRST NOIDLE		;WE'RE DOING AN EXTRA (OR SEG), SHOW XTIME
	PUSH P,FTIME(J)		;SAVE DAY,,TIME WHEN JOB LAST RAN
	PUSH P,TIMDAT		;SAVE CURRENT DAY,,TIME (SECONDS)
	HLRZ TAC,-1(P)
	PUSHJ P,DAYCNT		;CONVERT DATE RUN TO DAYCNT FORMAT
	HRLM TAC,-1(P)
	HLRZ TAC,(P)
	PUSHJ P,DAYCNT		;CONVERT CURRENT DATE TO DAYCNT FORMAT
	HLRZ TAC1,-1(P)		;GET BACK DAY WHEN JOB RAN
	SUB TAC,TAC1		;DAYS SINCE JOB RAN
	IMULI TAC,=24*=60*=60	;CONVERT DAYS TO SECONDS
	POP P,TAC1		;CURRENT TIME
	POP P,DAT		;TIME LAST RUN
	JUMPL TAC,NOIDLE	;BETTER NOT BE NEGATIVE
	ADDI TAC,(TAC1)		;PRETEND IT'S THAT MUCH LATER TODAY
	CAIGE TAC,5*=60(DAT)	;HAS JOB RUN IN LAST 5 MINUTES?
	JRST NOIDLE		;NO, SHOW INCREMENTAL RUN TIME
	SUBI TAC,(DAT)		;MAKE IT SECONDS SINCE LAST RAN
	IDIVI TAC,=60		;MAKE IT MINUTES
	HRL J,TAC		;PASS IDLE MINUTES BACK TO WHOLIN
	JRST DOIDLE		;NOW PRINT XTIME, EXCEPT FOR TICKS

;PRINT XTIME INCREMENT
NOIDLE:	MOVE TAC,JBTMSC(J)
	MOVEI TAC1,"'"		;PUNCTUATE TICKS WITH RIGHT QUOTE
	TLNE TAC,NOXRST		; UNLESS NO-UPDATE FLAG SET
	MOVEI TAC1,42		;IN WHICH CASE USE double QUOTE
	DPB TAC1,[POINT 7,WTEND+12(AC1),20] ;DEPOSIT PUNCTUATOR
DOIDLE:
IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST ALWY3A
	LSH J,1
	MOVE TAC,MTRTTIME(J)
	MOVE TAC1,MTRTTIME+1(J)
	SUB TAC1,MTRXTIME+1(J)
	TLZE TAC1,400000
	SUBI TAC,1
	SUB TAC,MTRXTIME(J)	;I.E. DSUB TAC,MTRXTIME(J)
	LSH J,-1
	PUSHJ P,MTRCVT		;CONVERT TAC TO TICKS
	JRST ALWY3B
ALWY3A:
>;IFN FTMTRACT
	MOVE TAC,TTIME(J)	;CALCULATE INCREMENT IN RUN TIME
	SUB TAC,XTIME(J)
ALWY3B:	JUMPE DDB,XTALL		;ALWAYS IF TTY (DDB=0)
	HLRZ TAC1,WHOTAB(DDB)	;GET INCREMENT FROM LAST TIME
	CAIN TAC1,(TAC)		;SAME?
	JRST NOXTIM		;YES.  DON'T UPDATE INCREMENT
	HRLM TAC,WHOTAB(DDB)	;NO.  SAVE INCREMENT THIS TIME FOR NEXT TIME
XTALL:	IDIVI TAC,=60		;CONVERT TO SECONDS
	PUSH P,TAC1		;SAVE TICKS
	MOVE AC3,[POINT 7,WTEND+11(AC1),6]
	PUSHJ P,WHOTIM		;PRINT X INCREMENT
	IBP AC3			;SKIP OVER PUNCTUATOR (ALREADY DEPOSITED)
	POP P,TAC		;RETRIEVE TICKS
	TLNN J,-1		;ARE WE PRINTING IDLE TIME?
	PUSHJ P,W0PD2		;NO, PRINT TICKS

NOXTIM:
IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST NOXTM1
	LSH J,1
	MOVE TAC,MTRTTIME(J)
	MOVE TAC1,MTRTTIME+1(J)
	LSH J,-1
	PUSHJ P,MTRCVT		;CONVERT TO TICKS IN TAC
	CAIA
NOXTM1:
>;IFN FTMTRACT
	MOVE TAC,TTIME(J)	;GET RUN TIME
	JUMPE DDB,DOTIME	;ALWAYS DO FOR TTY WHO (DDB=0)
	CAML TAC,WHORUN(DDB)	;TIME TO UPDATE RUN TIME YET?
	JRST DOTIME		;YES
	ADDI TAC,=60		;MAYBE NOT.  IS WHORUN REASONABLE?
	CAML TAC,WHORUN(DDB)
	POPJ P,			;YES
	SUBI TAC,=60		;NO, READJUST RUN TIME AND THEN UPDATE
DOTIME:	MOVE DAT,TAC		;COPY RUN TIME
	IDIVI TAC,=60		;LEAVE SECONDS IN TAC.
	SUBI DAT,(TAC1)		;ADJUST DAT TO LAST WHOLE SECOND OF RUN TIME
	ADDI DAT,=60		; AND THEN ADD ONE SECOND
	SKIPE DDB		;NOT FOR TTY WHO
	MOVEM DAT,WHORUN(DDB)	; AND SAVE THAT AS TIME FOR NEXT UPDATE
	MOVE AC3,[POINT 7,WTEND+6(AC1),34] ;FALL INTO WHOTIM

;Call with seconds in TAC.
WHOTIM:	CAIL TAC,=10*=60*=60	;10 or more hours?
	CAML TAC,[=10000*=60]	;Yes, less than 10000 mins?
	JRST WHRMIN		;No to one of these, print hours and mins
	MOVEI AC2,4		;Make long field 4 cols
	MOVEI DAT," "		;Fill long mins field, if used, with spaces
	ADD AC3,[70000,,0]	;Back up byte ptr so IDPB gets first byte
	JRST LNGMIN		;Display over 60 mins in mins only

WHRMIN:	IDIVI TAC,=60*=60	;HOURS IN TAC, MINUTES, SECONDS IN TAC1
	JUMPE TAC,[
		MOVEI DAT," "	;FILL HOURS FIELD WITH ONE SPACE
		DPB DAT,AC3
		MOVEI DAT,0	; AND ONE NULL.  THEN FILL MINUTES WITH NULLS
		IDPB DAT,AC3
		JRST WMIN ]
	MOVEI DAT,"0"		;FLAG TO FILL MINUTES FIELD WITH 0'S
	ADDI TAC,"0"
	DPB TAC,AC3
	MOVEI TAC,":"
	IDPB TAC,AC3
WMIN:	MOVE TAC,TAC1
	MOVEI AC2,2		;NUMBER OF CHARACTERS TO FILL.
LNGMIN:	IDIVI TAC,=60
	PUSH P,TAC1		;SAVE SECONDS
	PUSHJ P,WSDDEC		;WRITE DECIMAL WITH FILL CHAR IN DAT
	MOVEI TAC,":"
	IDPB TAC,AC3
	POP P,TAC
	JRST W0PD2		;WRITE SECONDS AS TWO CHARACTERS.  RETURN.
;WHOTTY WHOSET WHOLIN

;HERE FROM WHO UUO AND TTY WHO COMMAND.
↑WHOTTY:HRRZS (P)		;FLAG NOT DOING AN "EXTRA" WHOLINE
	JRST WHOLIN		;NOW GO TO NORMAL ROUTINE

; THIS ROUTINE SETS UP A NEW WHO TABLE FROM A PIECE OF FREE STORAGE

WHOSET:	MOVEI AC3,WLINK+1	;GET SIZE.
	PUSHJ P,FSGET		;GET FREE STORAGE.
	 POPJ P,		;NONE, RETURN.
	MOVEM AC1,FRETAB(WHO)	;SAVE FREE STORAGE POINTER.
	MOVE TAC,AC1
	HRLI TAC,TITLE
	BLT TAC,WLINK(AC1)	;PUT LINE MODEL INTO FREE STORAGE.
	HRRZS WHFILE+2(AC1)	;Note no filestatus display ever put up
	MOVEI AC2,177⊗8!27⊗1!1
	TLNE WHO,DMLIN
	MOVEM AC2,WLINK-1(AC1)	;Replace CRLF in DM wholine with EEOL
	SETZM WHORUN(DDB)	;ZERO THE TIME TO UPDATE RUN TIME NEXT
IFN FTGRIN,<
	TLNN WHO,DDDLIN		;Is this a Grinnell?
	JRST WHONGR		;No
	SKIPN AC3,LETAB(WHO)
	JRST WHOCLR		;Jump if dpy hdr disappeared
	MOVE TAC,DPYHGT(AC3)	;Get height of screen
	SUBI TAC,1		;Number of text lines from bottom to top
	IMUL TAC,DCHHGT(AC3)	;Times scanlines per text line gives scanline of
	ADD TAC,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB TAC,[POINT 10,POSOFF(AC1),31] ; first text line of screen
	MOVE TAC,DCHWID(AC3)	;Get char width in pixels
	DPB TAC,[POINT 10,POSOFF(AC1),15] ;Store as initial position (skip 1 char)
	DPB TAC,[POINT 10,DLTOFF(AC1),15] ;Store as delta-X per char
	MOVE TAC,CURPP(AC3)	;Get pointer to current PP
	MOVE AC2,DDCW(TAC)	;Get channel/subchannel select cmd
	MOVEM AC2,GWCOFF(AC1)	;Store channel-select word
WHONGR:
>;IFN FTGRIN
	JUMPGE WHO,WHOLIN	;AVOID SPECIAL STUFF EXCEPT FOR IIIs
	MOVEI TAC,DISNOP	;IIIs DONT DO THEIR OWN SYSTEM WHO LINE
	MOVEM TAC,2(AC1)	; SO A NO-OP REPLACES THE JMP TO SYS LINE
	HRLI AC1,DISJMP
	MOVSM AC1,WLINK(AC1)	;STORE JUMP BACK TO FRONT OF BLOCK.
	HRLI AC1,DISJSR
	MOVE AC3,LETAB(WHO)
	JUMPE AC3,WHOCLR	;JUMP IF DPY HEADER DISAPPEARED
	MOVSM AC1,WHOCALL(AC3)	;STORE JSR TO FS BLOCK WHERE III WILL HIT IT
	ANDI AC1,-1		;CLEAR LEFT SIDE.
	MOVSI TAC,400000	;SELECT THIS III FOR SYS WHO LINE
	MOVNI AC2,-DPYL0(WHO)
	LSH TAC,(AC2)
	IORM TAC,WHOSEL		;TURN ON SET BIT
	LSH TAC,-=12		;DON'T DESELECT THIS III FOR SYS WHO LINE
	ANDCAM TAC,WHOSEL	;TURN OFF RESET BIT
WHOLIN:	PUSHJ P,ALWAYS		;DO "FAST" PART. "EXTRA" FLAG IS IN OUR RETURN PC.
	HRRZ TAC,J
	MOVE AC3,[POINT 7,WTEND(AC1)]
	MOVEI AC2,2		;2 CHARACTERS
	PUSHJ P,WSDPAD		;WRITE DECIMAL JOB NUMBER
	MOVEI TAC1," "
	IDPB TAC1,AC3		;DMs force out wholine by clobbering this
	MOVE TAC1,PRJPRG(J)	;PROJECT-PROGRAMMER INITIALS.
	PUSHJ P,WHOSIX		;DO SIXBIT OUTPUT
	HRRE TAC,JBTLIN(J)	;GET LINE NUMBER AND SEE IF DETACHED
	JUMPL TAC,[	MOVE TAC1,[ASCID /DET# /]
			MOVEM TAC1,WTEND+2(AC1)
			JRST WLRET	]
	MOVEI AC2,4		;NOT DETACHED.  PRINT LINE NO IN 4 SPACES
	PUSHJ P,WSDOCT		;WRITE IT IN OCTAL WITH BLANK PADDING
;FALL THRU TO NEXT PAGE
;WLRET1 WLRET RTMPER NOIDL2 XTMPER XTMPR1 NOXPER WALIAS

	MOVEI TAC1," "		;PUT SPACE AFTER LINE NUMBER IF OWN LINE
	JUMPE DDB,WLRET1	; (USE SPACE FOR TTY WHOLINE)
	HRRZ TAC,JBTLIN(J)	;GET BACK LINE NUMBER
	LDB AC2,[PHIDDN+TAC,,LSTESC] ;GET HIDDEN BIT
	JUMPE AC2,.+2		;HIDDEN?
	MOVEI TAC1,"!"		;YES (PRIVATE)
	CAIE TAC,(WHO)		;JOB RUNNING ON THIS DPY?
	MOVEI TAC1,"#"		;NO
WLRET1:	DPB TAC1,[POINT 7,WTEND+2(AC1),27]
WLRET:	MOVE AC3,[POINT 7,WTEND+4(AC1),13]
	MOVE TAC1,JOBNAM(J)	;JOB NAME
	PUSHJ P,WHOSIX
	MOVEI TAC1,(J)
	PUSHJ P,CORSGT		;TAC1←CORESIZE IN WORDS
	LSH TAC1,CSHIFT		;CONVERT TO PAGES OR K
	MOVE TAC,TAC1
	MOVEI AC2,4		;4 CHARACTERS OUT, PAD WITH BLANKS
	PUSHJ P,WSDPAD		;WHOSER DECIMAL PAD OUTPUT

	MOVE AC3,[POINT 7,WTEND+10(AC1),13] ;OVERALL RUN/WAIT PERCENTAGE
	MOVE TAC1,JBTWAT(J)	;WAIT TIME
	JUMPGE TAC1,.+2		;IS WAIT TIME HONEST?
	ADD TAC1,UPTIME		;NO.  ADJUST IT
	PUSH P,TAC1		;SAVE TOTAL WAIT TIME
IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST RTMPER
	LSH J,1
	MOVE TAC,MTRTTIME(J)
	MOVE TAC1,MTRTTIME+1(J)
	PUSHJ P,MTRCVT		;CONVERT TO TICS IN TAC
	LSH J,-1
	MOVE TAC1,(P)
	CAIA
RTMPER:
>;IFN FTMTRACT
	MOVE TAC,TTIME(J)	;RUN TIME
	PUSHJ P,WPER2D		;PRINT PERCENTAGE IN 2 COLS WITH LEADING 0

;NOW PRINT INCREMENTAL RUN/WAIT PERCENTAGE, OR IDLE TIME IF 5 MINS OR MORE
	HLRZ TAC,J
	JUMPE TAC,NOIDL2	;JUMP IF NOT PRINTING IDLE TIME
	SUB P,[1,,1]		;DON'T NEED TOTAL WAIT TIME AFTER ALL

;PRINT IDLE TIME IN MINUTES
	MOVE TAC1,[ASCID/Idle /]
	MOVEM TAC1,WTEND+13(AC1) ;Set up titles for Idle time
	MOVE TAC1,[ASCID/ mins/]
	MOVEM TAC1,WTEND+15(AC1)
	MOVE AC3,[POINT 7,WTEND+12(AC1),20] ;POINT TO PUNCTUATOR OF TICKS
	MOVEI TAC1," "
	DPB TAC1,AC3		;REPLACE PUNCTUATOR WITH SPACE
	MOVEI DAT,0
	IDPB DAT,AC3
	IDPB DAT,AC3		;REPLACE PERCENTAGE WITH NULLS
	MOVE AC3,[POINT 7,WTEND+14(AC1)]
	MOVEI AC2,5		;WRITE IT IN 5 COLS
	PUSHJ P,WSDDEC		; IN DECIMAL WITH LEADING NULLS (DAT ALREADY SET)
	JUMPE DDB,NOXPER	;JUMP IF DOING WHOLINE FOR TTY OR UUO
	HRROS WHOTAB(DDB)	;FORCE UPDATING OF XTIME WHEN NOT IDLE
	JRST NOXPER		;DON'T PRINT INCREMENTAL RUN TIME OR DISKOPS

NOIDL2:	MOVE AC3,[POINT 7,WTEND+13(AC1)] ;INCREMENTAL RUN/WAIT PERCENTAGE
	MOVEI TAC1,"-"
	IDPB TAC1,AC3		;RESTORE THE DASH (CLOBBERED BY IDLE)
IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST XTMPER
	LSH J,1
	MOVE TAC,MTRTTIME(J)
	MOVE TAC1,MTRTTIME+1(J)
	SUB TAC1,MTRXTIME+1(J)
	TLZE TAC1,400000
	SUBI TAC,1
	SUB TAC,MTRXTIME(J)	;I.E., DSUB TAC,MTRXTIME(J)
	LSH J,-1
	PUSHJ P,MTRCVT		;CONVERT TAC TO TICKS
	JRST XTMPR1
XTMPER:
>;IFN FTMTRACT
	MOVE TAC,TTIME(J)	;RUN TIME
	SUB TAC,XTIME(J)	;CALCULATE INCREMENTAL RUN TIME
XTMPR1:	POP P,TAC1		;RETRIEVE CURRENT WAIT TIME
	SUB TAC1,JB2WAT(J)	;CALCULATE INCREMENTAL WAIT TIME
	PUSHJ P,WPER2D		;PRINT PERCENTAGE IN 2 COLS WITH LEADING 0

	MOVS TAC1,DSKOPS(J)	;GET NUMBER OF DSK OPS
	HLRZ TAC,TAC1		;TOTAL NO OF DSK OPS
	SUBI TAC,(TAC1)		;LESS PREVIOUS TOTAL
	MOVEI AC2,6		;6 COLS
	PUSHJ P,WSDPAD		;LEADING BLANKS, DECIMAL NUMBER
	MOVSI TAC1,1
	IDPB TAC1,AC3		;FILL WORD WITH NULL (OVERWRITING IDLE)
	HLRZM TAC1,WTEND+15(AC1) ;FLUSH IDLE'S "MINS" WORD 

NOXPER:	LDB TAC,PSEGN		;DOES HE HAVE A SECOND SEGMENT?
	JUMPE TAC,[
		MOVEI TAC,DISNOP ;NO
		TLNE WHO,DMLIN
		MOVEI TAC,1	;DISNOP is not a no-op on DM
		MOVEM TAC,WSEG(AC1)
		MOVEM TAC,WSEG+1(AC1)
		JRST WALIAS ]
	MOVE AC3,[POINT 7,WSEG(AC1),6] ;YES
	MOVEI TAC1,1
	MOVEM TAC1,WSEG(AC1)
	MOVEM TAC1,WSEG+1(AC1)
	MOVEI TAC1," "
	DPB TAC1,AC3		;PRECEDE SEGMENT NAME WITH 1 SPACE
	MOVE TAC1,JOBNAM(TAC)
	MOVEI AC2,7		;WRITE SIXBIT + 1 SPACE
	PUSHJ P,WHOSXX
WALIAS:	MOVE TAC1,DSKPPN(J)	;DOES HE HAVE AN ALIAS?
	JUMPE TAC1,[
		MOVEI TAC,DISNOP ;NOPE
		TLNE WHO,DMLIN
		MOVEI TAC,1	;DISNOP is not a no-op on DM
		MOVEM TAC,WSEG+2(AC1)
		MOVEM TAC,WSEG+3(AC1)
		JRST WHOFIL]
	MOVEI TAC,1		;YES
	MOVEM TAC,WSEG+2(AC1)
	MOVEM TAC,WSEG+3(AC1)
	MOVE AC3,[POINT 7,WSEG+2(AC1),6]
	MOVEI TAC," "
	DPB TAC,AC3
	MOVEI TAC,"("
	IDPB TAC,AC3
	PUSHJ P,WHOSIX		;PUT IN 6 SIXBIT CHARS FROM DSKPPN
	MOVEI TAC,")"		; SURROUNDED BY PARENTHESES
	IDPB TAC,AC3
	JRST WHOFIL		;PUT FILE STATUS INTO 3RD WHOLINE LINE
;WHOSYS NMTRNL NONULL TEMPOK CENTOK WHOSY1 WHOII0 DMCNTL D12LPA D12LPB WRUN1 WRUN2 WRUN2A

↑WHOSYS:MOVE TAC,LDAVG		;Get current load average
	PUSH P,TAC		;Save copy of remainder in case it changes
	LSH TAC,-LDSHF-LDPWR	;Get integer part of avg for one tick
	MOVEI AC2,2
	MOVE AC3,WHOSBP(=0)	;get byte pointer to before 1st byte in sys wholine
	PUSHJ P,WSDPAD		;Write integer part in two chars
	IBP AC3			;Skip over decimal point
	POP P,TAC
	AND TAC,[1⊗(LDPWR+LDSHF)-1] ;Just remainder
	IMULI TAC,=100
	LSH TAC,-LDSHF-LDPWR	;Get remainder as hundredths
	PUSHJ P,W0PD2		;Write hundredths of load avg in two digits

IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST NMTRNL
	MOVE TAC,MTRTTIME	;GET DOUBLEWORD NULL TIME
	MOVE TAC1,MTRTTIME+1
	PUSHJ P,MTRCVT		;CONVERT TO TICS IN TAC
	MOVN TAC,TAC
	CAIA
NMTRNL:
>;IFN FTMTRACT
	MOVN TAC,TTIME		;GET CURRENT NULL TIME
	EXCH TAC,LASTNL		;SAVE IT AND GET PREVIOUS NULL TIME
	SUB TAC,LASTNL		;FIND INCREMENT IN NULL TIME
	MOVN TAC1,UPTIME	;GET CURRENT UPTIME
	EXCH TAC1,LASTUP	;SAVE IT AND GET PREVIOUS UP TIME
	ADD TAC1,UPTIME		;FIND INCREMENT IN UP TIME
	JUMPE TAC1,NONULL
	IMULI TAC,=100		;CALCULATE NULL TIME IN PERCENT
	IDIV TAC,TAC1
	CAILE TAC,=99
	MOVEI TAC,=99		;LIMIT TO FIT IN TWO SPACES
	MOVE AC3,WHOSBP(=35)
	MOVEI AC2,3		;PRINT NULL PERCENTAGE IN 3 SPACES,
	PUSHJ P,WSDPAD		; PADDING WITH SPACES
NONULL:	MOVE AC3,WHOSBP(=66)
	HRRZ TAC,TIMDAT		;GET TIME OF DAY IN SECS
	IDIVI TAC,=60		;MINS INTO TAC, SECS INTO TAC1
	IDIVI TAC,=60		;HOURS INTO TAC, MINS INTO TAC1
	PUSH P,TAC1		;SAVE MINS
	PUSHJ P,W0PD2		;WRITE HOURS AS 2 DECIMAL DIGITS, PADDING WITH 0'S
	IBP AC3			;SKIP OVER COLON AFTER HOURS
	POP P,TAC		;RETRIEVE MINS
	PUSHJ P,W0PD2		; AND WRITE 2 DIGIT NUMBER

IFE FTF2,<
	MOVE AC3,WHOSBP(=72)
	MOVEI AC2,2		;PRINT NEGATIVE TEMP IN 2 DIGITS PLUS "-"
	PUSH P,OTHERM		;SAVE A COPY OF SAME TEMP FOR CENTIGRADE
	MOVEI DAT," "		;PAD WITH SPACE(S) FOR POSITIVE TEMPS
	SKIPL TAC,(P)		;NOW THE OUTSIDE TEMPERATURE
	AOJA AC2,TEMPOK		;PRINT POSITIVE TEMP IN 3 DIGITS
	MOVEI AC1,"-"
	IDPB AC1,AC3
	MOVM TAC,TAC
	CAIL TAC,=100
	MOVEI TAC,=99		;ONLY ROOM FOR MINUS SIGN AND TWO DIGITS
	MOVEI DAT,0		;PAD WITH NULL FOR NEGATIVE TEMP
TEMPOK:	PUSHJ P,WSDDEC

;NOW FOR CENTIGRADE
	MOVE AC3,WHOSBP(=77)
	POP P,TAC
	SUBI TAC,=32		;convert to Celsius
	MOVEI AC2,3		;print non-negative Celsius temp in 3 cols
	JUMPGE TAC,CENTOK	;jump unless below zero
	MOVEI AC1,"-"
	IDPB AC1,AC3
	SUBI AC2,1		;print negative temp in 2 cols
	MOVM TAC,TAC
	CAIL TAC,=180
	MOVEI TAC,=179		;ONLY ROOM FOR MINUS SIGN AND TWO DIGITS
CENTOK:	IMULI TAC,5		;MULTIPLY BY 5/9 TO GET CENTIGRADE
	IDIVI TAC,9
	CAILE TAC1,4
	ADDI TAC,1		;ROUND
	PUSHJ P,WSDNUL		;Pad with nulls, to avoid "- 1C", giving "-1C"
>;IFE FTF2

	MOVE AC1,THSDAT		;GET TODAY'S DATE
	CAMN AC1,WHODAT		;NEW DAY ARRIVED YET?
	JRST WHOSY1		;NO. DONT RECOMPUTE DAY AND DATE
	MOVEM AC1,WHODAT	;YES

	IDIVI AC1,=31		;DAY INTO AC2
	PUSH P,AC2		;SAVE DAY
	IDIVI AC1,=12		;MONTH INTO AC2
	MOVE AC1,MONTAB(AC2)	;GET TEXT OF MONTH (right justified in 3 chars)
	DPB AC1,WHOSBP(=50+1)	;store last char of month
	LSH AC1,-7
	DPB AC1,WHOSBP(=49+1)	;store middle char of month
	LSH AC1,-7
	DPB AC1,WHOSBP(=48+1)	;store first char of month
	POP P,TAC		;GET DAY BACK
	ADDI TAC,1		; AND CORRECT IT
	MOVE AC3,WHOSBP(=52)
	MOVEI AC2,2		;WRITE IT IN 2 COLS
	PUSHJ P,WSDNUL		; IN DECIMAL WITH LEADING NULLS
	MOVE TAC,WHODAT		;GET DATE AGAIN
	PUSHJ P,DAYCNT		;CONVERT TO NUMBER OF DAYS SINCE 1-1-64
	IDIVI TAC,7		;GET DAY OF WEEK (REMAINDER)
	LSH TAC1,1		;(TABLE ENTRIES ARE 2 WORDS EACH)
	MOVE TAC,DAYTAB(TAC1)
	IORI TAC,1
	MOVEM TAC,COMWHO+13	;STORE FIRST PART OF DAY
	MOVE TAC,DAYTAB+1(TAC1)
	IORI TAC,1		;Make 2nd part of Day into ASCID (ends with null(s))
	MOVEM TAC,COMWHO+14	;STORE SECOND HALF OF DAY

WHOSY1:	MOVE TAC,DQCNT		;GET NBR OF JOBS IN DISK QUEUE
	MOVE AC3,WHOSBP(=39)
	MOVEI AC2,2		; AND WRITE IT IN 2 COLS
	PUSHJ P,WSDPAD		; PADDING WITH BLANKS
	MOVE TAC1,DSKNUM	;get main disk device's unit number
	PUSHJ P,DSKRES		;FIND FREE BLOCK COUNT FROM DSKSER
	CAILE TAC,=99999
	MOVEI TAC,=99999	;LIMIT AMOUNT OF SPACE NEEDED
	MOVE AC3,WHOSBP(=42)
	MOVEI AC2,5		;AND WRITE IT IN 5 COLS
	PUSHJ P,WSDNUL		; IN DECIMAL WITH LEADING NULLS

	MOVEI AC1," "		;Means no IIIs in use
IFE FTF2,<
	HLLZ AC2,DPYAVL+1	;PICK UP III SELECT WORD FOR AVL MSG
	MOVEI TAC,6		;ASSUME ALL POSSIBLE III'S IN USE
	TLZA AC2,7777		;CLEAR ALL BUT 6 SELECT BITS
	LSH AC2,1		;LOOK AT NEXT III BIT
	JUMPG AC2,.-1		;JUMP IF THIS III IN USE BUT SOME NOT
	JUMPE AC2,.+2		;JUMP IF REST OF III'S IN USE
	SOJA TAC,.-3		;NOTE A FREE III
	JUMPLE TAC,WHOII0
	MOVEI AC1,"-"		;Means one in use
	SOJLE TAC,WHOII0
	MOVEI AC1,"+"		;Means two or more (only two set up)
>;IFE FTF2
WHOII0:	DPB AC1,WHOSBP(=10+1)	;PLACE III COUNT INTO WHOLINE

	MOVEI TAC,0		;Count DMs in this AC
IFN FTSUAI,<
	MOVEI TAC1,NPORDM	;Look for regular DM phone lines in use
	MOVSI AC1,DCACAR	;Carrier Detect bit in DCA table
>;IFN FTSUAI
IFE FTSUAI,<
	MOVEI TAC1,DDL0-1	;Look at non-Grinnell lines for dpy hdrs
>;IFE FTSUAI
DMCNTL:	LDB AC2,DCALIN		;Get TTY line number
IFN FTSUAI,<
	TDNN AC1,FPORDM-1(TAC1)	;Skip if carrier detect for this DM phone line
>;IFN FTSUAI
	SKIPE TTYTAB(AC2)	;Skip if no DDB for this line
	ADDI TAC,1		;count a line in use
	SOJG TAC1,DMCNTL	;loop though all interesting lines
	MOVE AC3,WHOSBP(=6)
	MOVEI AC2,2		;Print DM count in 2 cols
	PUSHJ P,WSDPAD		;Padding with space

IFN FTSUAI,<
	MOVEI TAC,0		;Count baud detect lines here
	MOVE TAC1,[-NPO12A,,FPO12A-DCATAB] ;aobjn ptr for DCA ports in this group
D12LPA:	LDB AC2,DCALIN		;Get TTY line number from port number in TAC1
	TDNN AC1,DCATAB(TAC1)	;Skip if carrier detect for this phone line
	SKIPE TTYTAB(AC2)	;Skip if no DDB for this line
	ADDI TAC,1		;count a line in use
	AOBJN TAC1,D12LPA	;loop though all interesting lines
;keep counting more lines in 2nd batch of similar dialups
	MOVE TAC1,[-NPO12B,,FPO12B-DCATAB] ;aobjn ptr for DCA ports in this group
D12LPB:	LDB AC2,DCALIN		;Get TTY line number from port number in TAC1
	TDNN AC1,DCATAB(TAC1)	;Skip if carrier detect for this phone line
	SKIPE TTYTAB(AC2)	;Skip if no DDB for this line
	ADDI TAC,1		;count a line in use
	AOBJN TAC1,D12LPB	;loop though all interesting lines
	MOVEI AC2,2		;Print 1200/1200 count in 2 cols
	PUSHJ P,WSDPAD		;Padding with space
>;IFN FTSUAI

IFN FTDD!FTGRIN,<
	PUSHJ P,WHODDC		;Put out number of DD channels in use
>;IFN FTDD!FTGRIN
IFE FTDD!FTGRIN,<
	MOVE AC3,WHOSBP(=13)	;Skip DD cols
>;IFE FTDD!FTGRIN

	SETZB TAC,TAC1		;TAC=# OF JOBS LOGGED IN. TAC1=# OF JOBS RUN LATELY.
	SETZB DDB,DAT		;DDB=CORE OF JOBS RUN LATELY. DAT=CORE OF ALL JOBS.
	MOVSI WHO,JNA!CMWB	;Count all job slots used up
	MOVEI J,JOBN-1
	MOVEI AC2,JOBN∂44	;Nbr of bits to look at in last word of JBSRUN tbl
	MOVEI DSER,<JOBN-1>/44	;Word index of last job's bit
	MOVE AC1,JBSRUN(DSER)	;Get last word of table
	LSH AC1,43-<<JOBN-1>∂44> ;Skip over unused job bits
WRUN1:	TDNN WHO,JBTSTS(J)	;IS THIS JOB LOGGED IN?
	JRST WRUN2		;NOPE
	ADDI TAC,1		;YES.  COUNT HIM
	PUSH P,TAC1
	MOVEI TAC1,(J)
	PUSHJ P,CORSGT		;TAC1←CORE SIZE OF JOB
	MOVE UCHN,TAC1
	POP P,TAC1
	ADD DAT,UCHN		;ADD CORE SIZE TO TOTAL FOR ALL JOBS
	TLNN AC1,400000		;HAS THIS JOB RUN LATELY?
	JRST WRUN2		;NOPE.  FORGET HIM
	ADDI TAC1,1		;YES.  COUNT HIM
	ADD DDB,UCHN		; AND ADD IN HIS CORE
WRUN2:	LSH AC1,1		;PUT NEXT JOB'S BIT IN SIGN BIT OF AC1
	SOJG AC2,WRUN2A
	MOVEI AC2,44		;Number of bits in next word of table
	SUBI DSER,1
	MOVE AC1,JBSRUN(DSER)	;Get next word of table
WRUN2A:	SOJG J,WRUN1		;MOVE ON TO NEXT JOB, IF ANY
	SETZM JBSRUN		;Clear table of jobs run recently
IFG JOBN-44,<
	MOVE AC1,[JBSRUN,,JBSRUN+1]
	BLT AC1,JBSRUN+<<JOBN+43>/44>-1 ;Clear the whole table
>;IFG JOBN-44

	PUSH P,TAC1		;SAVE # OF JOBS RUN LATELY
	PUSH P,DAT		;SAVE TOTAL CORE SIZE
	MOVEI AC2,3		;WRITE # OF JOBS IN 3 SPACES,
	PUSHJ P,WSDPAD		; PADDING WITH BLANKS,
	IBP AC3			; AND SKIP OVER THE COMMA (EG: 12,888)
	POP P,TAC		;GET BACK TOTAL CORE SIZE,
	LSH TAC,CSHIFT		; CONVERT TO K OR PAGES
	CAMLE TAC,MXJCOR	; (REMEMBER MAX CORE USED BY ALL JOB)
	MOVEM TAC,MXJCOR	; (BIGGER THAN PREVIOUS HIGH, REMEMBER NEW HIGH)
	MOVEI AC2,5		; AND PRINT IN 5 SPACES
	PUSHJ P,DECPDF		; WITH FOLLOWING BLANKS
	POP P,TAC		;GET BACK # OF JOBS RUN LATELY
	MOVEI AC2,2		; AND WRITE IT IN 2 SPACES,
	PUSHJ P,WSDPAD		; PADDING WITH BLANKS,
	IBP AC3			; AND SKIP OVER THE COMMA AGAIN
	MOVE TAC,DDB		;GET CORE OF JOBS RUN LATELY,
	LSH TAC,CSHIFT		; CONVERT TO K OR PAGES
	MOVEI AC2,5		;WRITE IT IN 5 SPACES,
	PUSHJ P,DECPDF		; PADDING WITH FOLLOWING BLANKS

	MOVE TAC,CORMAX		;GET AMOUNT OF AVAILABLE CORE,
	LSH TAC,CSHIFT		; CONVERT TO K OR PAGES
	MOVEI AC2,4		; AND PRINT IT IN 4 SPACES,
	PUSHJ P,WSDPAD		; PADDING WITH BLANKS

IFN FTF2,<
	MOVEI WHO,SCNNUM+DDNUM-1 ;Biggest TTY number to service for wholine
>;IFN FTF2
IFE FTF2,<
	MOVEI WHO,37		;START OVER WITH FIRST DD CHAN
>;IFE FTF2
	MOVEM WHO,WHDDNXT
	POPJ P,
;WHODDC WHODD2 WHONOQ WHODD5 WHODD3 WHOGRL

IFN FTDD!FTGRIN,<

WHODDC:
IFE FTF2,<
	MOVE AC3,[POINT 7,DDUNMS,20]
	MOVEI UCHN,10		;Print line numbers in octal
	PUSH P,[LWHDDQ]		;Max number of queue people to list
;;use following instruction instead of above to display more numbers,
;;if queues are often very big
;;	PUSH P,[=18]		;Max number of queue people to list
	SETO TAC,		;Pointer to header
WHODD2:	LDB TAC,[DDQLNK+TAC,,LSTESC]
	JUMPE TAC,WHONOQ
	SOSGE (P)
	JRST WHODD5
	PUSH P,TAC
	LDB TAC,[DDQREQ+TAC,,LSTESC]
	MOVEI AC2,4
	PUSHJ P,WSDPD3		;PRINT IN 4 COLUMNS IN OCTAL
	POP P,TAC
	JRST WHODD2

WHONOQ:	POP P,AC2		;Get number of lines not in queue
	MOVEI TAC," "
	JRST WHODD3

WHODD5:	POP P,AC2		;Get expired count
	MOVEI TAC," "
	IDPB TAC,AC3
	SKIPA TAC,["."]
WHODD3:	IDPB TAC,AC3
	IDPB TAC,AC3
	IDPB TAC,AC3
	IDPB TAC,AC3
	SOJGE AC2,WHODD3
;Now tell how many DD channels in use
	MOVN TAC,DDFCNT		;GET NUMBER OF FREE DD CHANS
	ADDI TAC,=31		; AND SUBTRACT FROM TOTAL NUMBER
	ADD TAC,DDQSIZ		;Include people waiting!
>;IFE FTF2
IFN FTGRIN,<
	MOVEI TAC,0		;Count Grinnells in use
	MOVSI AC2,-DDNUM
WHOGRL:	SKIPE LETAB+DDL0(AC2)
	ADDI TAC,1		;Has dpy hdr, count in use
	AOBJN AC2,WHOGRL
>;IFN FTGRIN
	MOVE AC3,WHOSBP(=11)
	MOVEI AC2,2		;PRINT NUMBER OF DD CHANS IN USE
	JRST WSDPAD		; IN 2 SPACES PADDING WITH BLANKS

>;IFN FTDD!FTGRIN
;WHOFI3 WHOFI2 WHFGRN WHFCUR WHFDD WHFDD WHFDM WHFIII WHOFIL WHFIL2 SHOWIT SHOWI2

;HERE IF NO FILE TO HAVE ITS STATUS DISPLAYED
WHOFI3:	SETZM JBTDDB(J)
WHOFI2:	MOVE TAC,WHFILE+2(AC1)	;SAVE PIECE OF OLD FILENAME
	MOVEI TAC1,1
	MOVEM TAC1,WHFILE(AC1)
	MOVSI TAC1,WHFILE(AC1)
	HRRI TAC1,WHFILE+1(AC1)
	BLT TAC1,WLINK-2(AC1)	;CLEAR OUT FILENAME AREA IN FS
	TLNE TAC,-1		;IS THERE A FILENAME NEEDING ERASING?
	SKIPN DDB		;(WITH A REAL DPY HDR)
	POPJ P,			;NO
	JUMPL WHO,CPOPJ		;CAN'T SUPPRESS ON III
	JUMPL AC2,CPOPJ		;JUMP IF SUPPRESSING ERASURES OF FILESTATUS
	MOVSI TAC,WHFDD
	TLNE WHO,DMLIN
	MOVSI TAC,WHFDM
	HRRI TAC,WHFILE(AC1)
	BLT TAC,WHFILE+2(AC1)	;PUT IN ENOUGH TO ERASE THE OLD FILENAME
IFN FTGRIN,<
	TLNN WHO,DDDLIN		;Skip if Grinnell
	POPJ P,
WHFGRN:	MOVE TAC,DPYHGT(DDB)	;Get screen height
	SUBI TAC,3		;Position to third line from top
	IMUL TAC,DCHHGT(DDB)	;Convert to scanlines
	ADD TAC,GRSKIP		;Move up by number of scanlines to avoid at bottom
	DPB TAC,[POINT 10,WHFILE(AC1),31] ;Store position
	MOVE TAC,DCHWID(DDB)	;Get char width in pixels
	IMULI TAC,WHFCUR	;Figure X position of beginning of filestatus line
	DPB TAC,[POINT 10,WHFILE(AC1),15] ;Store position
>;IFN FTGRIN
	POPJ P,

WHFCUR←←=45
IFE FTGRIN,<
↑WHFDD:	CW 0,0,3,WHFCUR,3,WHFCUR
	CW 3,WHFCUR,4,1,5,10
	40⊗1 ! 1		;A SPACE TO FORCE ERASURE OF RIGHT HALF OF 3RD LINE
>;IFE FTGRIN
IFN FTGRIN,<
↑WHFDD:	GW G.LEA,0,G.LLA,0	;X-Y position.  Both X & Y get set up.
	ASCID/ /		;A space to make erasure happen
	1			;Text word of nulls
>;IFN FTGRIN

WHFDM:	BYTE(7)177,27,177,14,WHFCUR≠140,2≠140
	BYTE(7)0,0,0,177,27	;ERASE 3RD LINE

WHFIII:	BYTE(11)60,710(3)2,2(2)1,2(3)3	;III POSITION WORD TO MIDDLE OF THIRD LINE
	DISNOP

WHOFIL:	MOVE AC2,JBTDDB(J)	;SEE IF ANY DDB TO SHOW FILENAME FOR
	TRNE AC2,-1		;ANY DDB THERE?
	SKIPN DDB		;DON'T DO THIS FOR WHO UUO AND TTY WHO
	JRST WHOFI2		;NOPE
	MOVE TAC,DEVMOD(AC2)	;GET DEVICE CHARACTERISTICS
	TLNN TAC,DVDSK
	JRST WHOFI3		;NOT A DISK, FORGET IT
	MOVSI TAC,WHFDD
	TLNE WHO,DMLIN
	MOVSI TAC,WHFDM
	JUMPGE WHO,.+2
	MOVSI TAC,WHFIII
	HRRI TAC,WHFILE(AC1)
	BLT TAC,WHFILE+1(AC1)	;Put the two device dependent words into wholine FS
IFN FTGRIN,<
	TLNE WHO,DDDLIN		;Is this a Grinnell?
	PUSHJ P,WHFGRN		;Yes, put in the position cmds for file line
>;IFN FTGRIN
	PUSH P,DDB		;Save the dpy hdr address
	MOVE DDB,AC2		;DDB TO BE DISPLAYED ON WHOLINE
	MOVEI TAC,1
	MOVEM TAC,WHFILE+2(AC1)
	MOVSI TAC,WHFILE+2(AC1)
	HRRI TAC,WHFILE+3(AC1)
	BLT TAC,WLINK-2(AC1)	;CLEAR OUT OLD FILENAME CRUD
	MOVE AC3,[POINT 7,WHFILE+2(AC1)]
	MOVEI TAC1," "
	IDPB TAC1,AC3		;START WITH A SPACE
	MOVE TAC1,DEVFIL(DDB)	;GET FILE NAME
	PUSHJ P,WHOSIX		; AND PRINT 6 CHARS
	MOVEI TAC1," "
	IDPB TAC1,AC3
	HLLZ TAC1,DEVEXT(DDB)	;GET FILE EXT
	MOVEI AC2,3
	PUSHJ P,WHOSXX		; AND PRINT 3 CHARS
	MOVEI TAC1," "
	IDPB TAC1,AC3
	MOVE TAC1,FILPPN(DDB)	;GET FILE PPN
	PUSHJ P,WHOSIX		; AND PRINT 6 CHARS
	MOVE TAC,FILLNG(DDB)	;GET FILE LENGTH
	PUSHJ P,DGETL1		; AND CONVERT TO RECORDS (DGETL1 IS IN DSKSER)
	SKIPE TAC		;IF NON-ZERO, SUBTRACT ONE TO GET NUMBER
	MOVEI TAC,-1(TAC)	; OF LAST RECORD, NOT FIRST FREE RECORD
	MOVEI AC2,6
	PUSHJ P,WSDPAD		;PRINT FILE LENGTH IN RECORDS IN DECIMAL
	MOVEI AC2,6
	HRRZ TAC,USETP(DDB)	;GET CURRENT USET POINTER
	PUSHJ P,WSDPD3		; AND PRINT IT IN SAME RADIX AS LENGTH
	MOVEI TAC1," "
	IDPB TAC1,AC3		;PRINT A SPACE
	MOVEI TAC1,"U"
	MOVSI TAC,DVUDP
	TDNE TAC,DEVMOD(DDB)	;IS THIS A UDP?
	IDPB TAC1,AC3		;YES, PRINT "U"
	MOVE TAC,DEVIOS(DDB)	;SEE WHAT IS HAPPENING TO THIS FILE
	TLNN TAC,READB		;BEING READ?
	JRST WHFIL2		;NO
	MOVEI TAC1,"R"		;YES.  PRINT "R"
	IDPB TAC1,AC3
	MOVEI TAC1,"A"
	TLNE TAC,ALTERB		;OPEN IN READ-ALTER MODE?
	IDPB TAC1,AC3		;YUP,  PRINT "A" AFTER THE "R"
	MOVEI TAC1,"E"
	TLNE TAC,IOEND		;END OF FILE?
	IDPB TAC1,AC3		;YES, PRINT "E"
	POP P,DDB
	POPJ P,

WHFIL2:	MOVEI TAC1,"W"
	TLNE TAC,WRITEB		;IS FILE BEING WRITTEN?
	IDPB TAC1,AC3		;YES, PRINT "W"
	POP P,DDB
	POPJ P,

HISYS

;WANTS TO INCLUDE PARTICULAR FILE IN WHOLINE.  GIVE CHANNEL NUMBER IN AC.
;0,,200000 BIT IN AC MEANS DON'T SHOW ANY FILESTATUS ON WHOLINE ANYMORE.
;0,,400000 BIT IN AC MEANS SUPPRESS ERASURE OF FILESTATUS WHEN DDB GOES AWAY.
;(THE 0,,400000 BIT IS SIMPLY PASSED TO WHOSER IN LH OF JBTDDB.)
↑SHOWIT:LDB AC1,[POINT 4,TAC,35];GET CHANNEL NUMBER
	MOVS TAC,TAC		;PUT RH AC BITS INTO LEFT HALF
	HRR TAC,USRJDA(AC1)	;GET DDB ADDRESS FOR THIS CHANNEL
	MOVSI AC2,DVDSK
	CAMG AC1,USRHCU		;CHANNEL IN USE?
	TDNN AC2,DEVMOD(TAC)	;IS THIS A DISK OR UDP?
	JRST SHOWI2		;NOPE
	TLNE TAC,200000		;THIS BIT MEANS TURN OFF WHOLINE FILESTATUS
SHOWI2:	TRZ TAC,-1		;DON'T SHOW ANY FILESTATUS ON WHOLINE
	MOVEM TAC,JBTDDB(J)	;STORE DDB AND BITS FOR WHOSER
	POPJ P,
	
BEND WHOSER
