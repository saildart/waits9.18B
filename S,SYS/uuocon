COMMENT ⊗   VALID 00103 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00011 00002	dispatching
C00014 00003	NCUBG1 SETPCU KLUUON KLUUOH KLCNOK UUO3 UUO1 NOPCK UUO1B UUO1A
C00023 00004	KLUNZS KLENZS KLPNZS KLUNZ2 KLUNZ3 UUOX UUOX1
C00029 00005	UUOSYS UUOSY2 LOSPDL UUOSY1 UUOSY3 NCUEN1 DISP4 USRXT0 USRXT1
C00033 00006	USRXIT USRXT6 USRXT2 USRX4A USRXT4
C00036 00007	USRXT8 USRX8A USRXTS USRXT9 USRXT5
C00039 00008	UUOSY4 SPWBLK UUOSIM
C00042 00009	CHNSET CHNSE1 NOCHAN CHNSE2 CHNSE3
C00044 00010	UUOPHZ UUOPHZ UUOTAB
C00046 00011	UUOIOT UUOPHZ IUUTAB IUUMAX UUONAM
C00048 00012	UCALL UCALLI UCALL1 UCALL2
C00051 00013	UUO.NAMES
C00054 00014	STANFORD.CALLIS
C00063 00015	UCLTAB ZZ ZZ UCLJMP
C00064 00016	EXIT EXIT1 EXIT2 EXIT3
C00067 00017	INTTST RESET RESETU RESETB NOPR2 NOTWHO
C00071 00018	RESETSEG RESTG1
C00072 00019	APRDKL APRDK3 APRDK2 APRDK1
C00073 00020	SETPOV APRENB APREN2
C00076 00021	PEEK PHPEEK SWITCH JOBNO DATE STOTAC DAYCT STDTIM ACCTIM TIMER JOBTIM JOBTI2 MSTIME MSTIM1
C00081 00022	 SLEEP SLEEPT SLEEP1 ASYML ASYMSL ASYMLL ASYMS1 ASYMS2 ASYML0 ASYML6 ASYML2 ASYML3 ASYML7 ASYML8 ASYML4 ASYME0 ASYME1 ASYME2 ASYME3 ASYMEX SADXCH SADXC2 SADXCT SADXC3 SADXC4 SADLDB
C00103 00023	DVCHR DVCHR0 DVCHR1 DVCHR2 DEVNUM
C00119 00024	UDSKPPN RSTPPN RTDSKPPN RTZERO GETPPN GETPPL GETPP1 GETPP2
C00123 00025	SETNAM SETCRD SETCD1 SETCD2 SETDDT GETNAM GETNA1
C00125 00026	WAIT GETLN SPCWAR EIOTM LIOTM
C00127 00027	DATIME DAT2 DAT2A DAT1 DAT3 DAT4 VENTIM
C00131 00028	LOGIN LOGIN1 LOGIN2 LOGIN3 SETLOG LOGIN4 LOGTAB LOGTOP
C00135 00029	PRIBUF
C00136 00030	SETPRV STPRV0 STPRV1 GETPRV FNCTAB MAXFNC SETPPV PRVIOR PRVIO1 PRVIO2 PRVACM
C00142 00031	RLEVEL RLEV1 RLEV2 GETLV1 SPRSSL SPRSS0 SPRSS1 SPRSS2 SETLVL SETRES SETAL1 SETAL0
C00149 00032	LOGOUT
C00150 00033	RUNUUO
C00152 00034	SYSRJB SYSSJ1 SYSRJ1 RUNUU2 PRUNJB SYSRXT SYSRX2
C00157 00035	SYSRS SYSRS1 SVUACS SVUA1 RSUACS RSUACX
C00161 00036	PHANTO PHWIN PHLOSE PHLOS1
C00166 00037	PNAME USTAT
C00168 00038	TTYIOS TTYIO1 TTYIO5 TTYIO2 TTYIO4 TTYIO3
C00170 00039	WAKEME WAKEM1 WAKEM3 WAKEM2 WHOAMI SPCJBS NSPJBS
C00174 00040	CALLIT CALT1 CALT0
C00177 00041	CALTU CALTU1 CALTU2
C00179 00042	CALT2 CALT3 CALT4
C00181 00043	SETPR2 READP2 GETP2 GETHI P2UUO P2FIX0 P2FIX1 P2FIX2 P2UNFX P2UNF1 P2UNF2 P2TEST P2RUNT P2FIXD P2FIXN
C00194 00044	PR2REL PR2SET STPR2 STPR2A
C00196 00045	PR2GET
C00197 00046	 REMAP REMAP4 REMAP0 REMAP5 REMAP2 SEGXT1 SEGXIT SEGXT5 SEGXT3 SEGXT4 SEGXT2 SEGXT6 RMPER2 RMPER1
C00206 00047	REMAP1 REMAP3 RMPUPB REMZAP REMZP1 REMZPE REMAP8
C00213 00048	BLTUP FASBLT BLTUP1 BLTUP2 BLTUP3 BLTUP4
C00219 00049	SETUWP SETUW1 SETUW2
C00222 00050	UNPURE UNPUR2 UNPNC2 UNPNC1 UNPNC4 UNPNC3 UNPNC5 UNPURS UNPRS1 UNPNON
C00233 00051	CORE2 CORE2A CORE2E CORE2B CORE2N CORE2X CORE2D
C00237 00052	ATTSEG ATTSE8 ATTSE5 ATTSE1 ATTSER ATTSE6 ATTSE3 ATTSE4 ATTSE2
C00241 00053	ATTSGJ ATTSG1 ATTSG4 ATTSG3 ATTSG2 ATTSE7
C00243 00054	DETSEG DETSE1 DETSE2 NJERR
C00246 00055	SEGNUM SEGSIZ SEGNAM
C00248 00056	SETNM2 SETNM3 SETNM4 JTPOPJ
C00250 00057	LINKUP
C00251 00058	MXPOIN POINTS POINT2 POINT1 POINT3
C00253 00059	SETPRO SETP3 SETP2
C00255 00060	INTORM INTACM INTAPC INTENS INTIIP INTIRQ
C00257 00061	INTENB INTEN1 INTCHK INTLOS
C00259 00062	CLKENB CLKENA CLKNB1 CLKNBL CLKNB2 CLKNB3 CLKNB4 CLKNB6 CLKNB7 CLKNB5
C00261 00063	DISMIS DISLOS DEBREAK DISM2 DISM1 DISM3 DISQTB NDISQS
C00263 00064	INTGEN INTGN1 USKIP UWAIT UWAIT1 UWNPC IWAIT
C00266 00065	IENBW INTMSK IMCALL IMSKST IMSKCL
C00268 00066	CLKUUO CLKUU2
C00269 00067	INTUUO INTMXU INTDEJ IMSTW
C00271 00068	IWKMSK IMSKCR IRUMSK IRUMST IRUMCL
C00273 00069	INTDMP
C00275 00070	INTDR1 INTDR2 INTDR3 INTDR4 INTDR5 INTDR6 INTDRX GXJOBN GXJOB2 GXJOB3 GXJOB4 GXJOB5 GXJOB6 GXJOB7 GXJOB0
C00278 00071	INTIPI
C00280 00072	UUOCON - STANFORD SPECIAL IO ROUTINES  CHNSTS BUFLEN BLKLEN
C00283 00073	NAMEIN NAMINL NAMEI1 NAMEI2 NAMEI4 NAMEI3 NAMEI5
C00285 00074	FILUSW FILUSR FILUS1 FILUS2 FILUS3 FILUS9
C00290 00075	DEVUSE DEVUS1 DEVUS2 DEVUS3 DEVUS4 DEVUS5 DEVUS6 DEVUS7
C00295 00076	JOBRD JOBRDX JOBRDY JOBRCK JOBRCQ JRDBLT JRDBL1 JRDWIN JRDLEV JRDLOS JOBRC3 JOBRC1 JOBRC2 JOBRC4
C00303 00077	TMPMAX TMPLNK TMPNAM TMPPPN TMPDAT TMPCRD TMPCOR TMPCO1 TMPCR1 TMPDSP NUMTMP TMPSCN TMPSC1 TMPSZ1 TMPSIZ TMPSET TMPST1
C00309 00078	TMPFND TMPRED TMPRDX TMPWRT TMPRDD TMPDEL TMPALD TMPDIR TMPDR2 TMPDR0 TMPDR1 TMPALC TMPCLR TMPKIL
C00315 00079	UMAIL MAXMAIL SKPSEN SEND SEND1 NOWAKE WRCV SRCV SKPME SKPHIM FNDJOB GJ1 GJERR GJERR2 GTGAR1 GTGARP
C00322 00080
C00324 00081	IOPUSH IOPSH1 IOPSH3 IOPSH2 IOPOP3 IOPOP IOPOP0 IOPOP2 IOPOP1 IOPOP4 IOPOP5 IOPDL IOPDL0 IOPDL1 IOPDL2 IOPDLD IOPDLL FIOPID IOPID1
C00330 00082	CLOSE1 UCLS0 UCLS1 UCLS4 UCLS5
C00335 00083	UCLS2 UCLS2A UCLS2B UCLS6 UCLS7 UCLS3
C00339 00084	UOUTBF UOBF2 UOBF1 UINBF UINBF1 MINBF MOUTBF MBFSET ILLOBF ILLIBF
C00344 00085
C00347 00086	UINIT UOPEN UINIT0 UINITG UINITA UINITK UNITDX UINITB UINITL UINITM UNITAC UNTAC1 UNTAD1 UINITC UINIT4 UINIT5 UINXIT UINITZ UINITR
C00358 00087	UINITW UINTWX UINTW1 UINTW2 SETERZ SETWAT SETWA0 GOTIT UCTEXT
C00365 00088	UDEN UDEN1 UDLKC UDLK
C00367 00089	URENAM UDSO UDSI UDGF UMTAPE UTPCLR
C00369 00090	CLRIN SETFILE
C00370 00091
C00372 00092	IN IN5 IN4 IN2 IN099 IN098 IN1 INPT0C INPT0A INPT2 INPUT2 INPT1 INEOF INEOFE
C00379 00093	INPUTF INPUT3 INDMP CALIN BCHECK
C00382 00094
C00385 00095	UOUT OUT3 OUT4 OUT5 OURDN UOUT1
C00388 00096	OUT OUT069 OUT099 OUT098 OUT097 OUT096 OUT1 OUT2 OUTAGN OUTF OUTF1 OUTS OUTDMP
C00398 00097	RELEA0 RELEA3 RELEA1 RELEA5 RELEA4 RELE4A RELE4C RELE4B RELEA9 RELEA7 RELEA6
C00403 00098	RELDVW RELDVA RELDVU RELDOK RELDVX RELDV4 RELDV5 RELDV8
C00408 00099	USTATO USTATS USTATZ
C00410 00100	TIN TOUT
C00411 00101	SPCWGO USPCWAR SPCWG1
C00412 00102	 NETUUO NETUU1 NETUUX NNETUU NETU1 NETU11 NETU2 NETU3 NETU4 NETULG NETU5
C00417 00103	 SPOOLR SPOOLN SPOOLC SPOOLB SPOOLX SPOOLM SPOOLU SPOOLA SPOOLG SPOOLS SPOOLT SPOOLI SPOOL0
C00430 ENDMK
C⊗;
;dispatching
SUBTTL	UUOCON	NON-IO SECTION

COMMENT %

UUOCON consists of the UUO trap handler, the CALL UUO routines, the
non-IO routines, and the device independent IO UUO routines.  Some
UUOs dispatch to other routines outside of UUOCON.

Only System UUOs trap to the system.  User UUOs (001 to 037) are
stored in user's 40 and execute user's 41 (note this is a special
feature on the PDP-6).  On the PDP-6 System UUOs are stored in 40 and
execute 41.  On the KA10, System UUOs are stored in 140 and execute
141.

If called from user mode, the System UUO trap routine will first save
the current ACs in the user's locations 0-17.  (If a UUO is called
from the EXEC at UUO level, the user's ACs have already been saved in
relative 0-17.) Then the following ACs are loaded up before
dispatching:

P		Pushdown pointer in system free storage.
J		Current job number.
UUO		The contents of loc 40 (or 140)
		(In CALL and CALLI, the right half of UUO is the
		same as the AC field of the UUO).
DDB		Address of the device data block for this IO channel
IOS		Device IO status word
DSER		Address of the device service routine dispatch table.
UCHN		The AC field of UUO (User's IO channel number).
TAC		(In CALL and CALLI, TAC contains the user's ac)

The return address is placed in UUOPC(J), and the appropriate UUO
routine is called via PUSHJ P,.  All UUO routines should return to
UUOCON via POPJ P, or by JRST CPOPJ1 which will cause the UUO to skip
return to the user.  Upon returning from the UUO routine, UUOCON will
restore the ACs (if called from user mode), restore the APR
conditions, and return if the job is still runnable.

Since parts of UUOCON are not reentrant, care must be exercised if
any attempt is made to call a UUO from interrupt level.  See the code
at INTRUN in CLKSER for one attempt at making UUOCON reentrant.


%
;NCUBG1 SETPCU KLUUON KLUUOH KLCNOK UUO3 UUO1 NOPCK UUO1B UUO1A

IFN FTNCU,<
NCUBG1::	;beginning address of special code we don't want cached
>;IFN FTNCU

;HERE WE FIGURE OUT WHOSE FAULT THE UUO IS AND WHO IT IS FOR

NOKL10,<
;140/		0			;IMAGE OF THE UUO
;141/		JSR UUO0		;TRAP INSTRUCTION
;UUO0/		0			;TRAP ADDRESS STORED HERE BY JSR
;UUO0+1/	JRST UUO1
;160/		0			;IMAGE OF ILLEGAL INSTR (105-127)
;161/		JSR UUO2
;UUO2/		0
;UUO2+1/	JRST UUO3
>;NOKL10

IFKL10,<
IFN FTKLB,<
;Here from JSP TAC,SETPCU.  Set PCU in current PC flags.
SETPCU:	TLO TAC,PCU		;turn on prev context user in PC flags
	JRST 2,@TAC		;set PC flags, return to caller

;Here for user LUUO from non-zero section (can't happen).
;Treat same as user MUUO, after copying data to MUUO's block.
↑KLUUON:MOVEM 17,UUO.SA+17
	MOVE 17,[KLLUUB,,KLUPT+KLUUFG]	;copy three words saved by LUUO to array
	BLT 17,KLUPT+KLUUEA		;where MUUO would have saved them
	DATAI KLPAG,KLUPT+KLCNTX	;store process context word like MUUO
	MOVE 17,UUO.SA+17		;then fall into MUUO handler
>;IFN FTKLB
;Here for MUUO.
↑KLUUOH:MOVEM 17,UUO.SA+17
	MOVEI 17,UUO.SA
	BLT 17,UUO.SA+16		;save ACs at time of UUO, for debugging
	MOVE 17,UUO.SA+17		;restore AC before changing AC blocks
	DATAO KLPAG,[400100,,0]		;SET AC CONTEXT: CURRENT = 0, PREV = 1
;note: even though we just selected AC block 0, we preserve ACs because the MUUO
;may have been from exec (and thus we may already have been using AC block 0).
	EXCH TAC,KLUPT+KLUUPC		;GET PC OF THE UUO
	MOVEM TAC,UUO0			;STORE PC WHERE WE'LL LOOK FOR IT
IFN FTKLB,<
	TLNE TAC,-1		;make sure PC is in section 0
	JRST KLUNZS		;UUO from non-zero section, shouldn't happen
	MOVE TAC,KLUPT+KLUUEA	;now check effective address of UUO
	TLNE TAC,-1		;make sure eff adr is in sect 0
	JRST KLENZS		;eff adr w/non-zero section! shouldn't be.
	HRL TAC,KLUPT+KLUUFG	;get opcode and AC
	TLNE TAC,37		;make sure previous context section is 0
	JRST KLPNZS		;prev context sect is nonzero! bad news
	MOVEM TAC,UUOWRD	;store reconstructed UUO where can find it
	MOVE TAC,KLUPT+KLUUFG	;get flags saved at time of UUO
	HLLM TAC,UUO0		;store with section 0 PC as PC word
	TLNN TAC,USRMOD		;was uuo from user mode? (if so, PCU already on)
	JSP TAC,SETPCU		;no, set PCU for uuo from exec (args in user mem)
;begin context bugtrap
	MOVE TAC,UUO0		;see if right AC block was in use for exec or user
	AND TAC,[USRMOD,,0]	;just user mode bit from trap PC flags
	LSH TAC,-3		;MOVE 10000 TO 1000
	XOR TAC,KLUPT+KLCNTX	;XOR usr bit with current AC context
	TLNN TAC,7000		;AC CONTEXT AND USRMOD SHOULD AGREE
	JRST KLCNOK		;OK
	SYSPIFF		;bad context!
	MOVE P,ERRPDL
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /AC context bad at KLUUOH.  Context = /
	MOVE TAC,KLUPT+KLCNTX	;get uuo context
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /  PC = /
	MOVE TAC,UUO0		;print PC flags and PC
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	PUSHJ P,DDTCALL
jfcl;	DATAI KLPAG,TAC
jfcl;	TLC TAC,1100		;hopefully change between two contexts used
jfcl;	MOVEM TAC,ERRPD		;save on stack
	MOVSI 17,UUO.SA
	BLT 17,17		;restore the original ACs
jfcl;	DATAO KLPAG,ERRPD	;set correct (?) context and try to continue
	SYSPIN
consz pi,77400		;drd -- make sure we're not at any PI level
halt .
skipn j,job		;skip unless null job running
jrst nuljb		;attempt to fix the world, restart null job
skipn p,jbtpdl(j)	;get a stack for this job
halt .			;none!
jrst uuoerr		;and give this job an error

KLCNOK:
;end context bugtrap
	HRRZ TAC,UUO0		;get back UUO's PC
>;IFN FTKLB
	EXCH TAC,KLUPT+KLUUPC		;RESTORE TAC and UUO PC.  FALL INTO UUO1
>;IFKL10
NOKL10,<
↑UUO3:	EXCH TAC,UUO2			;TRAP TO LOCATION 160.
	MOVEM TAC,UUO0			;ILLEGAL FOR NOW.
	MOVE TAC,@UU2LOC
	MOVEM TAC,@UUOLOC
	MOVE TAC,UUO2			;RESTORE TAC.
↑UUO1:	MOVEM 17,UUO.SA+17		;SAVE ALL AC'S FOR ILLUUO FROM EXEC
	MOVEI 17,UUO.SA
	BLT 17,UUO.SA+16	
	MOVE 17,UUO.SA+17		;RESTORE AC 17
>;NOKL10
	CONSO PI,177⊗8			;ARE WE AT INTERRUPT LEVEL?
	JRST NOPCK			;NO.
	EXCH TAC,UUO0			;SAVE TAC, GET PC OF UUO + 1
	TLNN TAC,USRMOD			;USER MODE?
	JRST UUOX			;UUO FROM EXEC WHILE PI IN PROG - ILLEGAL
	EXCH TAC,UUO0			;RESTORE TAC
NOPCK:	SKIPN SPWUUF			;ARE WE RUNNING SPACEWAR NOW?
	JRST UUO1B			;NO.
NOKL10,<
;Since we have to have saved the user level ACs on the F2, we might
;as well let SPW UUOs reference the SPW ACs, like works on the KL.
;So here we store the ACs in user shadow area, just like normal user mode UUOs.
	XCTR XW,[MOVEM 17,17]		;Save user 17 in shadow area
	MOVEI 17,0			;SOURCE = AC 0, DEST = USER RELATIVE 0.
	XCTR XBLTW,[BLT 17,16]		;STORE IN USER RELATIVE 0-16
>;NOKL10
	MOVEI PID,P1PID
	JRST SPWUUO			;LET SPWSER PROCESS IT

;Here for UUO not at PI level nor at spacewar level
UUO1B:	MOVEM 17,USRSAV			;SAVE AC 17
	MOVE 17,UUO0			;GET PROCESSOR FLAGS
	TLNE 17,USRMOD			;IS UUO FROM MONITOR?
	JRST UUO1A			;NO. ORDINARY FROM USER MODE
;Here with UUO from exec.
IFN FT17P,<
	MOVE 17,USRSAV			;restore AC 17 (P!)
>;IFN FT17P
	MOVE DAT,UUO0			;UUO FROM EXEC - DON'T SAVE ACS.
	MOVEI PID,P1PID
	MOVE UUO,@UUOLOC
	MOVE J,JOB
	JRST UUOSY1			;UUO FROM SYSTEM

;Here with UUO from user mode.
UUO1A:	SKIPE JOB			;IS A JOB RUNNING?
	JRST UUOSYS			;HAPPY
	MOVEI PID,P1PID			;THERE IS NO JOB DATA AREA.
	JRST NULJB			;RESTART THE AILING NULL JOB.
;KLUNZS KLENZS KLPNZS KLUNZ2 KLUNZ3 UUOX UUOX1

IFN FTKLB,<
;Here with UUO from PC in non-zero section.  Shouldn't happen.
KLUNZS:	JSP TAC,KLUNZ2
	ASCIZ/UUO from non-zero section!/

;Here with UUO with effective address of non-zero section.  Shouldn't happen.
KLENZS:	JSP TAC,KLUNZ2
	ASCIZ/UUO with non-zero section in effective address!/

;Here with UUO that stored non-zero previous context section.  Shouldn't happen.
KLPNZS:	JSP TAC,KLUNZ2
	ASCIZ/UUO with non-zero previous context section!/

KLUNZ2:	EXCH TAC,UUO0		;save ptr to error msg, get UUO PC
	EXCH TAC,KLUPT+KLUUPC	;RESTORE TAC and UUO PC.
	SYSPIFF
	EXCH P,ERRPDL		;GET A PDL
	PUSHACS
	SOS KLUPT+KLUUPC	;back up PC to actual UUO
	PUSHJ P,DISGST		;print time of error on cty
	MOVE AC1,UUO0		;get ptr to error msg
	PUSHJ P,DISSTR		;print UUO error message
	MOVE TAC,KLUPT+KLUUFG	;get PC flags
	MOVEI AC1,[ASCIZ/  UUO at Exec /]
	TLNE TAC,USRMOD		;user mode?
	MOVEI AC1,[ASCIZ/  UUO at User /] ;yes, say so
	PUSHJ P,DISSTR
	MOVE TAC,KLUPT+KLUUPC	;get UUO PC
	PUSHJ P,DISOHS		;print half words, suppressing leading zeroes
	PUSHJ P,DISCRLF
	CONSO PI,77400		;any PI in progress?
	JRST KLUNZ3		;no
	PUSHJ P,DISMES
	 ASCIZ/PI in Progress, PI = /
	CONI PI,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	 ASCIZ/   /
KLUNZ3:	PUSHJ P,DISMES
	 ASCIZ/PC Flags = /
	HLRZ TAC,KLUPT+KLUUFG	;get PC flags
	PUSHJ P,DISLOC		;print flags in octal
	PUSHJ P,DISMES
	 ASCIZ/,,x   Prev context section = /
	LDB TAC,[POINT 5,KLUPT+KLUUFG,35]
	PUSHJ P,DISLOC		;print prev cont sect
	PUSHJ P,DISERR
	 [ASCIZ/
UUO context word = /]
	 DISARG OHS,KLUPT+KLCNTX
	 [ASCIZ/   UUO effective adr = /]
	 DISARG OHS,KLUPT+KLUUEA ;print half words, suppressing leading zeroes
	 [ASCIZ/   UUO opcode and AC = /]
	 -1
	MOVE TAC,KLUPT+KLUUFG
	ANDI TAC,777700		;clear prev context section
	PUSHJ P,DISLOC		;print opcode and AC
	PUSHJ P,DISMES
	 ASCIZ/,,x
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA		;we'll need help for this one
	EXCH P,ERRPDL		;restore P
	SYSPIN		;assume PI system was on when we started
	XJRSTF KLUPT+KLUUFG	;but we'll try the thing again anyway if requested
>;IFN FTKLB

;UUOX - UUO FROM EXEC AT  INTERUPT LEVEL.  TRY TO FIGURE OUT WHAT TO DO

UUOX:	EXCH TAC,UUO0			;RESTORE TAC, UUO0
	SYSPIFF			;HOLD EVERYTHING
	EXCH P,ERRPDL			;GET A PDL
	PUSHACS
	MOVEI PID,P1PID
UUOX1:	SOS UUO0			;FIX UP ADDRESS FOR PRINTING AND RETURN
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /UUO FROM EXEC WHILE PI IN PROGRESS.
PI = /
	CONI PI,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISERR
	[ASCIZ /
P  = /]
	DISARG OCT,<ERRPDL>		;OLD STACK
	[ASCIZ /    C(P) = /]
	-1
	HRRZ TAC,ERRPDL
	MOVE TAC,(TAC)
	PUSHJ P,DISOCT
	PUSHJ P,DISERR
	[ASCIZ /
PC = /]
	DISARG OCT,<UUO0>
	[ASCIZ /    UUO  = /]
	DISARG OCT,<@UUOLOC>
	[ASCIZ /
(WILL RETURN VIA JRST 2,@UUO0 AFTER TURNING ON PIS)
/]
	-1
	PUSHJ P,SYSFIX
	JFCL				;COULDN'T FIX ERROR
	JFCL				;COULDN'T FIND ERROR
	PUSHJ P,DISFLUSH		;FIXED AN ERROR
	POPACS
	PUSHJ P,DDTCALL
	EXCH P,ERRPDL
	SYSPIN
	JRST 2,@UUO0			;TRY TO GO ON!
;UUOSYS UUOSY2 LOSPDL UUOSY1 UUOSY3 NCUEN1 DISP4 USRXT0 USRXT1

;SAVE USER'S ACS, GET A PDL

UUOSYS:
NOKL10,<
	XCTR XW,[MOVEM 16,16]	;STORE AC16 IN USER 16
	MOVEI 16,0		;SOURCE = AC0, DEST = USER RELATIVE 0.
	XCTR XBLTW,[BLT 16,15]	;STORE IN USER RELATIVE 0-15
	MOVE TAC,USRSAV		;MOVE USER 17 TO USER'S AREA
	XCTR XW,[MOVEM TAC,17]
>;NOKL10
	MOVEI PID,P1PID
UUOSY2:	MOVE J,JOB			;PICK UP JOB NUMBER
	MOVE DAT,UUO0			;SAVE RETURN IN ACS
	MOVE UUO,@UUOLOC		;AND SAVE UUO ALSO
	SKIPE INTACT
	SKIPA P,INTSP			;USE INTERRUPT LEVEL PDL
	SKIPE P,JBTPDL(J)		;GET US A PDL
	JRST UUOSY1			;WE GOT A PDL.
LOSPDL:	MOVE P,ERRPDL			;(HERE FROM MONSTR IF JBTPDL=0)
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / AT GETPDL WITHOUT A PDL.  RETURNS VIA UUOERR
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCAL
	MOVEI P,0
	JRST UUOERR

↑UUOSY1:EXCH DAT,UUOPC(J)		;(ENTER HERE FROM SPWSER)  SAVE RETURN.
	MOVEM DAT,UUOOPC(J)		;SAVE OLD RETURN.
	SKIPE DAT,UUOPTR(J)		;IS USER TRYING TO SIMULATE UUOS?
	JRST UUOSY4			;PERHAPS.  GO CHECK FOR SIMULATION.
UUOSY3:	TLNN UUO,740000			;SYSTEM UUO?
	JRST UUOERR			;NO, 0-37 ARE ILLEGAL,PRINT ERROR
IFN FTNCU,<
NCUEN1::	;ending address of special code we don't want cached
>;IFN FTNCU
	LDB UCHN,PUUOAC			;SETUP USER DEVICE CHANNEL NUMBER
	LDB TAC1,[POINT 9,UUO,8]	;PICK UP UUO OP CODE
	XORI TAC1,700			;IS THIS AN IOT UUO?
	TRCN TAC1,700
	JRST UUOIOT			;YES, SEPARATE DISPATCH TABLE
	CAIL TAC1,100			;ILLEGAL INSTRUCTION?
	JRST ILLINS			;YES, STOP JOB AND PRINT ERROR
	PUSHJ P,CHNSET			;CHECK CHANNEL NUMBER AND LOAD IOS AND DSER
	JRST USRXIT			;NO CHANNEL, BUT UUO LEGAL ANYWAY
	JRST USRXT1			;THIS IS LONG UUO ON SHORT DISPATCH DEVICE.
	ROT TAC1,-1			;DIVIDE UUO OPCODE BY 2, SAVE REMAINDER
	MOVE DAT,UUOTAB-20(TAC1)	;GET DISPATCH TABLE ENTRY
DISP4:	TLNN TAC1,400000		;WAS UUO ODD?
	MOVS DAT,DAT			;NO, USE LH OF DISPATCH ENTRY
	AOS NUUOS
	PUSHJ P,(DAT)			;DISPATCH TO UUO ROUTINE. RETURN BY POPJ
;BEGINNING HERE WE WON'T TAKE USER INTERRUPTS
USRXT0:	JRST USRXIT			;NO SKIP RETURN REQUIRED
	JRST USRXT1			;(SINGLE) SKIP REQUIRED.
	MOVE J,JOB
	AOSA UUOPC(J)			;DOUBLE SKIP.
USRXT1:	MOVE J,JOB
	AOS UUOPC(J)			; SKIP RETURN TO USER

;FALLS THROUGH
;USRXIT USRXT6 USRXT2 USRX4A USRXT4

;USRXIT  - RETURN FROM UUO ROUTINE.
;CHECK TO SEE IF SCHEDULER WANTS TO RESCHEDULE THIS JOB.

;FALLS THROUGH FROM PREV PAGE

↑USRXIT:MOVE J,JOB
IFN FTSCNBUG <
	JSR CH7CHK		;BUG TRAP FOR STATE OF SCANNER CHANNEL
>;FTSCNBUG
	SKIPN SPWUUF		;ARE WE AT SPACEWAR LEVEL ?
	JRST USRXT6		;NO.
	MOVE TAC,UUOPC(J)
	POP P,UUOPC(J)		;RESTORE OLD PC WORD
	MOVEM TAC,UUO0
NOKL10,<MOVEI 17,0		;SOURCE=RELATIVE 0, DEST=AC0
	XCTR XBLTR,[BLT 17,17]	;MOVE USER RELATIVE 0-17 INTO ACS
>;NOKL10
IFKL10,<DATAO KLPAG,[401000,,0] ;AC BLK = 1, PREV = 0
>;IFKL10
	XCT SPWXCT		;USUALLY JRST 2,@UUO0 ;RETURN TO SPW JOB

USRXT6:	SKIPE INTACT		;USER INTERRUPT LEVEL?
	JRST USRXT4		;YES, SKIP SCHEDULING CHECK
	SKIPL TAC,JBTSTS(J)	;STILL RUNNABLE?
	JRST USRXT9		;NO - RUN BIT OFF - PUT HIM IN STOPQ
	TLNE TAC,STOPIO		;YES?
USRXT2:	PUSHJ P,USRXTS		;NO, CAUSE CLK INT ON EXIT
	MOVSI UCHN,INTWAIT	;ARE WE ENABLED FOR INTERRUPT WAIT INTERRUPT?
	TDNN UCHN,JBTIEN(J)
	JRST USRXT4		;NOT ENABLED FOR INT-WAIT INTERRUPT
	IORM UCHN,JBTIRQ(J)
	SETOM INTREQ
USRX4A:	PUSHJ P,USRXTS		;INT ON WAY BACK TO LOSER (HERE FROM ESTOP6)
USRXT4:	MOVEI DAT,USRXT5
	EXCH DAT,UUOPC(J)
	TLNN DAT,USRMOD
	JUMPN DAT,@DAT		;RETURN IF UUO FROM EXEC, EXCEPT EXIT UUO.

;FALLS THROUGH
;USRXT8 USRX8A USRXTS USRXT9 USRXT5

;RESTORE ACS AND DISMISS UUO 

;FALLS THROUGH FROM PREV PAGE

	MOVEM DAT,UUO0
USRXT8:	SKIPN JBTPAG(J)			;IF PRESENT JOB GOES TO CORE 0 (I.E., KILLS)
	SETZB J,JOB			;THEN WE'LL WIND UP IN CHANNEL 7 WITH JOB=0
	JUMPE J,USRX8A
NOKL10,<MOVEI 17,0			;SOURCE=RELATIVE 0, DEST=AC0
	XCTR XBLTR,[BLT 17,17]		;MOVE USER RELATIVE 0-17 INTO ACS
>;NOKL10
IFKL10,<DATAO KLPAG,[401000,,0]		;SET CURRENT AC BLK = 1, PREVIOUS = 0
>;IFKL10

;UUOXIT normally contains JRST 12,@UUO0 which will restore flags and
;return to the user.  If the clock ticks while a UUO is in progress,
;the code at CLKINT clobbers UUOXIT to CONO PI,PIOFF; then XCT UUOXIT
;will fail to jump, and an interrupt on CH7 will be initiated to
;continue the clock interrupt that had been delayed.

USRX8A:	SETOM NULBAD		;IN CASE OF KILLING OLD JOB, RESTART NULL JOB
	XCT UUOXIT		;JRST 12,@UUO0 OR CONO PI,PIOFF
	SETOM CLKFLG		;HERE WITH INTS OFF IF CLOCK HAS TICKED (SEE CLKINT)
	SETOM SCHEDF		;IN CASE OF 0 PC FROM EXIT
	SETZM PIOFFS
	CONO PI,PION!4000!<200⊗-CLKCHN>	;NOW (GOES TO CLKIN0 SINCE CLKFLG LT 0)
	CONO PI,0		;FOR THE KL10, SOAK UP ANOTHER EBUS CYCLE
	CONSO PI,77000		;GET HERE ON TRPJEN (ALREADY IN PROGRESS)
	JRST CLKIN0		;CH7, JUST GO
	JRST 10,.-2		;HIGHER CHN, DISMISS (SHOULDN'T RETURN)

;ROUTINE TO FORCE CLOCK BREAK UPON RETURN TO USER
↑USRXTS:MOVE TAC,[CONO PI,PIOFF]
	MOVEM TAC,UUOXIT
	POPJ P,

;GET HERE IF RUN BIT WAS OFF
USRXT9:	MOVNI TAC,STOPQ
	MOVEM TAC,JOBQUE(J)
	JRST USRXT2		;GO FORCE SCHEDULE

USRXT5:	SYSPIFF		;BEYOND HERE USER INTS OK
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /EXITING UUOCON WITHOUT HAVING ENTERED UUOCON
/
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCALL
	HALT AUTOLOAD
;UUOSY4 SPWBLK UUOSIM

;UUOSIM - UUO SIMULATION.   UUOSY4

;GET HERE WHEN UUOPTR≠0 TO THINK ABOUT LETTING LOSER SIMULATE UUO
;UUOPTR POINTS TO TABLE (IN LOSER'S CORE) OF 3 3-WORD BLOCKS
;EACH BLOCK LOOKS LIKE THIS:

;WD0:	PLACE TO SAVE PC
;WD1:	PLACE TO SAVE UUO ITSELF
;WD2:	PC TO TRANSFER TO

;THE FIRST BLOCK IS USED FOR PDP-10 MAIN PROGRAM UUOS, THE SECOND FOR PDP-10
;INTERRUPT LEVEL UUOS, AND THE THIRD FOR PDP-10 SPACEWAR UUOS. NO PDP-6 UUOS
;CAN BE SIMULATED.  IF EITHER WD1≠0 OR WD2=0 IN A GIVEN BLOCK, THOSE
;UUOS ARE NOT GIVEN TO THE USER'S HANDLER.  THE WD1≠0 CONDITION HAS THE
;EFFECT OF AUTOMATICALLY DISABLING SIMULATION WHILE IN THE SIMULATOR.

UUOSY4:	SKIPE INTACT			;FIRST MAKE PNTR TO APPROP BLK
	ADDI DAT,3
	SKIPE SPWUUF
	ADDI DAT,6
	XCTR XR,[SKIPN 1(DAT)]		;NOW SEE IF HE REALLY WANTS TO SIMULATE THIS
	XCTR XR,[SKIPN TAC,2(DAT)]
	JRST UUOSY3			;NOPE, WE'LL DO OUR THING AS USUAL
	XCTR XW,[MOVEM UUO,1(DAT)]
	TLO TAC,USRMOD
	EXCH TAC,UUOPC(J)		;SWAP PC'S AROUND
	XCTR XW,[MOVEM TAC,(DAT)]
	JRST USRXIT			;AND "RETURN" TO HIS SIMULATOR

↑SPWBLK←←6	;TELL SPWSER WHERE TO LOOK

;UUO TO SET UUOPTR TO ENABLE/DISABLE SIMULATOR
;CALL:	MOVE AC,<ADDRESS OF 9-WORD SIMULATOR BLOCK>
;	UUOSIM AC,
;STORES USER'S ARGUMENT IN UUOPTR(J)

UUOSIM:	MOVEM TAC,UUOPTR(J)
	POPJ P,
;CHNSET CHNSE1 NOCHAN CHNSE2 CHNSE3

;CHNSET ROUTINE TO ASSIGN A CHANNEL NUMBER

CHNSET:	POP P,DAT		;POP UP RETURN ADDRESS
	SKIPE DDB,USRJDA(UCHN)	;GET ADDRESS OF DEVICE DATA BLOCK
	CAMLE UCHN,USRHCU	;IS IT LESS THAN OR EQUAL TO HIGHEST
				;USER IO CHANNEL IN USE FOR CURRENT JOB?
	JRST NOCHAN		;CHANNEL NOT ASSIGNED
CHNSE1:	MOVE IOS,@DEVSPT(DDB)	;GET DATA BLOCK STATUS WORD
	MOVE DSER,DEVSER(DDB)	;SETUP IO SERVICE DISPATCH TABLE ADDRESS
	CAIL TAC1,LNGUUO	;LONG DISPATCH TABLE UUO?
	JRST CHNSE3		;YES
	JRST 2(DAT)

NOCHAN:	MOVE TAC,UUOPC(J)	;IS UUO FROM USER MODE?
	CAIGE TAC1,IOUUO	;IO UUO?
	JRST CHNSE2		;NO.
REPEAT 0,<
	PUSHJ P,GOTOP1		;ALL IO DONE FROM P1
>
	TLNN TAC,USRMOD
	JRST CHNSE1		;EXEC MODE
	CAIE TAC1,70		;YES,IS IT CLOSE OR RELEASE?
	CAIN TAC1,71		;CLOSE AND RELEASE ALWAYS LEGAL
	JRST (DAT)
	JRST IOIERR		;NO, PRINT IO TO UNASSIGNED CHANNEL AND STOP JOB

CHNSE2:	MOVEI DDB,0		;SET DDB 0 TO FLAG NON-IO UUO
	JRST 2(DAT)		;GO DISPATCH

CHNSE3:	MOVE TAC,DEVMOD(DDB)	;LONG DISPATCH TABLE UUO
	TLNE TAC,DVLNG		;DOES THIS DEVICE HAVE A LONG DISPATCH TABLE?
	JRST 2(DAT)		;YES, DISPATCH
	CAIGE TAC1,76		;NO, IS UUO LOOKUP OR ENTER?
	JRST (DAT)		;NO, RETURN TO USER
	JRST 1(DAT)		;YES, SKIP RETURN TO USER
;UUOPHZ UUOPHZ UUOTAB

;TABLE OF UUO DISPATCH ADDRESSES
;IN FORMAT:
;	XWD 40,41
;	XWD 42,43
;	.
;	XWD 76,77
;THERE'D BETTER BE EXACTLY 40 ENTRIES HERE

DEFINE UUOS{FOR X IN(CALL,INIT,,SPCWAR,,,,<CALLI>	;40-47
,OPEN,<TTYUUO,TTYUUO>,,,,RENAME,<IN,TIN>,<OUT,TOUT>	;50-57
,<SETSTS,SETIOS>,STATO,<GETSTS,USTATS>,<STATZ>		;60-63
,<INBUF,UINBF>,<OUTBUF,UOUTBF>,<INPUT,IN>,<OUTPUT,UOUT>	;64-67
,<CLOSE,CLOSE1>,<RELEAS,RELEA1>,MTAPE,<UGETF,UDGF>	;70-73
,<USETI,UDSI>,<USETO,UDSO>,<LOOKUP,UDLK>,<ENTER,UDEN>)}	;74-77

DEFINE UUOADR(C,A,B)
{IFE UUOPHZ,<DEFINE UUOAD1<0,A,B>;>XWD UUOAD2(C,\UUOAD1),UUOAD2(C,,A,B)
UUOPHZ←←1-UUOPHZ}

DEFINE UUOAD2!(C,X,A,B)
{IFIDN <A!B><><UUOERR+>IFDIF <B><><B+>IFDIF <A><><IFIDN <B><><C!A+>>0}

UUOPHZ←←0
UUOTAB:	UUOS
{	UUOADR U,X
}
XP IOUUO,55			;LOWEST IO UUO(RENAME)
XP LNGUUO,72			;LOWEST LONG DISPATCH TABLE UUO
;UUOIOT UUOPHZ IUUTAB IUUMAX UUONAM

;IOT UUO DISPATCH TABLE

UUOIOT:	SUBI TAC1,700		; MAKE 700-777 INTO 0-77
	CAIL TAC1,2*IUUMAX	; DOES THIS ONE EXIST?
	JRST ILLINS		; NO, ILLEGAL INSTRUCTION
	AOS NIOTS		; BUMP NUMBER OF IOT UUOS USED
	ROT TAC1,-1
	MOVE DAT,IUUTAB(TAC1)	; PICK UP DISPATCH ADDRESS
	MOVEI DDB,[SIXBIT /GARPLY/]	;INIT. FOR ERROR PRINTOUTS.
	AOS NNUUOS		; BUMP COUNT OF DISPATCHES
	JRST DISP4

DEFINE IUUOS{FOR X IN(<,CPOPJ>,DPYCLR,PPIOT,<UPGIOT>		;700-703
,<UINBF,MINBF>,<UOUTBF,MOUTBF>,<FBREAD,UUOERR>,<FBWRT,UUOERR>	;704-707
,<MAIL,UMAIL>,PTYUUO,POINTS,<UPGMVE,UPGMOV>			;710-713
,UPGMVM,PGIOT,CHNSTS,<CLKINT,CLKUUO>				;714-717
,INTMSK,IMSKST,IMSKCL,INTUUO,IOPUSH,IOPOP,IOPDL)}		;720-726

IFN FTF2,<UPGMVM←←ILLINS  UPGMOV←←ILLINS>

UUOPHZ←←0
IUUTAB:	IUUOS
{	UUOADR ,X
}
IFN UUOPHZ,<UUOADR>
IUUMAX←←.-IUUTAB

;UUO NAME TABLE, FOR FAIL, ETC.

PSHSYS
LOSYS

IFE UUOPHZ,<IUUMAX*2,,UUOFLK;>IUUMAX*2-1,,UUOFLK ;LINK TO TABLES FOR TTYUUO, ETC.
↑UUONAM:UUOS
{	<SIXBIT ,X,>
}	IUUOS
{	<SIXBIT ,X,>
}

POPSYS
;UCALL UCALLI UCALL1 UCALL2

;CALL AND CALLI
; CALLING SEQUENCE
;	CALL D,[SIXBIT/NAME/]
; WHERE NAME IS THE NAME OF A SYSTEM ROUTINE.
; IF NO SYSTEM ROUTINE WITH THE SPECIFIED NAME IF FOUND, THIS ROUTINE
; EXITS TO UUOERR.
;CONTENTS OF USER AC PLACED IN AC TAC,  UUO SET TO POINT TO USER AC
;J SET TO JOB NUMBER

UCALL:	XCTR XR,[MOVE DAT,(UUO)]	;PICK UP NAME OF SYSTEM ROUTINE
	MOVSI TAC1,-UCLLEN
	CAME DAT,UCLTAB(TAC1)		;SEARCH SYSTEM ROUTINE NAME TABLE
	AOBJN TAC1,.-1
	TLZN TAC1,-1			;CLEAR LH. WAS IT ZERO?
	JRST UUOERR			;YES. RAN OUT OF TABLE
	JRST UCALL1			;NO. DISPATCH.


;CALLI UUO	-	CALL IMMEDIATE
;CALLI D,E
;WHERE E IS RELATIVE INDEX IN CALL TABLE


↑UCALLI:
	HRRZ TAC1,UUO
	CAIL TAC1,UCLDLN		;EXCEED ?
	JRST UCALL2			;YES. ERROR
UCALL1:	POP P,TAC			;REMOVE RETURN
	HRR UUO,UCHN			;UUO AC FIELD
	XCTR XR,[MOVE TAC,(UUO)]	;PICK UP CONTENTS OF USER AC
	ROT TAC1,-1			;DIVIDE BY 2 AND SAVE REMAINDER
	MOVE DAT,UCLJMP(TAC1)		;GET DISPATCH TABLE ENTRY
	MOVE J,JOB
	JRST DISP4			;AND GO DISPATCH

UCALL2:	TRZN UUO,400000			;IS HE ASKING FOR A STANFORD CALLI?
	JRST UUOERR			;NO, SHOOT HIM!! BANG!
	MOVEI TAC1,UCLDLN(UUO)
	CAIL TAC1,UCLDLN		;IF NOT BIGGER THAN THIS, FLUSH IT!
	CAIL TAC1,UCLLEN		;STILL TOO LARGE?
	JRST UUOERR			;YES, FLUSH
	AOS NSCALL			;BUMP NUMBER OF STANFORD CALLIS USED
	JRST UCALL1
;UUO.NAMES

COMMENT ⊗
UUO.NAMES: ⊗	;FOR NDFAIL

;CALL UUO DISPATCH TABLE
;NEW UUOS MUST BE ADDED AT END SINCE CALLI DEPENDS ON
;POSITION IN TABLE
;ALSO NUMBER OF DEC CALLIS MUST BE EVEN


DEFINE NAMES!,<
	X RESET,RESETUUO	;RESET IO
	X DDTIN,DDTIN		;EXT-GET DDT CHAR.
	X SETDDT,SETDDT		;SETDDT LOC IN PROTECTED JOB DATA
	X DDTOUT,DDTOUT		;EXT:SEND DDT CHAR.
	X DEVCHR,DVCHR		;DEVICE CHARACTISTICS
	X DDTGT,CPOPJ		;GET DDT MODE
	X GETCHR,DVCHR		;DEVICE CHAR.(DIFF. NAME)
	X DDTRL,CPOPJ		;RELEASE DDT MODE

	X WAIT,WAIT		;WAIT TILL DEVICE INACTIVE
	X CORE,CORUUO		;CORE UUO
	X EXIT,EXIT		;EXIT
	X UTPCLR,UTPCLR		;CLEAR DEC TAPE DIRECTORY 
	X DATE,DATE		;GET DATE
	X LOGIN,LOGIN		;LOGIN
	X APRENB,APRENB		;ENABLE APR FOR TRAPPING
	X LOGOUT,LOGOUT		;LOGOUT

	X SWITCH,SWITCH		;RETURN DATA SWITCHES
	X REASSIGN,REASSIGN	;REASSIGN DEVICE TO ANOTHER JOB
	X TIMER,TIMER		;RETURN JIFFY CLOCK TIME
	X MSTIME,MSTIME		;RETURN TIME OF DAY IN MS
	X GETPPN,GETPPN		;RETURN PROJECT-PROGRAMMER NUMBER
	X <>,UUOERR		;TRPSET ILLEGAL
	X <>,UUOERR		;TRPJEN ILLEGAL
	X RUNTIM,JOBTIM		;RETURN TOTAL JOB RUNNING TIME

	X PJOB,JOBNO		;RETURN JOB NUMBER
	X SLEEP,SLEEP		;SLEEP FOR N SECONDS, THEN RETURN TO USER
	X SETPOV,SETPOV		;SET PUSH DOWN OVERFLOW TRAP (FOR COMPAT ONLY)
	X PEEK,PEEK		;PEEK INTO SYSTEM CORE.
	X GETLN,GETLN		;GET NAME OF TTY
	X RUN,RUNUUO		;DEC'S SWAP UUO
	X SETUWP,SETUWP		;SET USER WRITE PROTECT
	X REMAP,REMAP		;REDO CORE MAP

	X GETSEG,CPOPJ		;GET SEGMENT
	X GETTAB,CPOPJ		;GETTAB ILLEGAL (ERROR RETURN) HERE.
	X <>,UUOERR		;SPY ALSO ILLEGAL
	X SETNAM,SETNAM		;SET JOB NAME
	X TMPCOR,TMPCOR		;TEMPORARY FILES FOR RPG, ETC.
	X <>,UUOERR		;FILL OUT THE TABLE
>
;STANFORD.CALLIS

COMMENT ⊗
STANFORD.CALLIS: ⊗	;FOR NDFAIL

DEFINE STANFORD <
	X SPWBUT,SPCWAR		;READ SWITCH REGISTER
	X CTLV,CTLV1		;PUT TTY IN NON-DUPLEX MODE.
	X <>,SETNAM		;SET JOB NAME FOR SYSTAT (OBSOLETE)
	X SPCWGO,SPCWGO		;ANOTHER SPACEWAR UUO
	X SWAP,SYSRJB		;RUN A JOB
	X EIOTM,EIOTM		;ENTER IOT USER MODE
	X LIOTM,LIOTM		;LEAVE IOT USER MODE
	X PNAME,PNAME		;GET A DEVICE'S PHYSICAL NAME
	X .SYML,ASYML		;LOOK UP A SYSTEM SYMBOL
	X SHOWIT,SHOWIT		;SHOW FILE STATUS ON WHOLINE
	X FREEZE,FREEZE		;FREEZE ALL NON UPGIOT OUTPUT TO DM
	X JBTSTS,USTAT		;GET JOB STATUS WORD OF A JOB
	X TTYIOS,TTYIOS		;GET A JOB'S TELETYPES STATUS WORD
	X CORE2,CORE2		;FUNNY CORE UUO FOR HIGH SEGMENTS
	X ATTSEG,ATTSEG		;ATTACH HIGH SEGMENT
	X DETSEG,DETSEG		;DETACH HIGH SEGMENT
	X SETPRO,SETPRO		;CHANGE PROTECTION OF HIGH SEGMENT - 400020
	X SEGNUM,SEGNUM		;GET NUMBER OF HIGH SEGMENT
	X SEGSIZ,SEGSIZ		;SIZE OF UPPER
	X LINKUP,LINKUP		;LINK TO AN UPPER
	X DISMIS,DISMIS		;DISMISS INTERRUPT
	X INTENB,INTENB		;ENABLE INTERRUPTS
	X INTORM,INTORM		;ORM INTERRUPT MASK
	X INTACM,INTACM		;ANDCAM INTERRUPT MASK
	X INTENS,INTENS		;400030
	X INTIIP,INTIIP		;MOVE AC,JOBCNI
	X INTIRQ,INTIRQ		;PENDING INTERRUPTS
	X INTGEN,INTGEN		;GENERATE AN INTERRUPT
	X UWAIT,UWAIT		;WAIT FOR UUO TO BE DONE
	X DEBREAK,DEBREAK	;BECOME USER LEVEL PROCESS
	X SETNM2,SETNM2		;SET NAME OF UPPER, IF ANY
	X SEGNAM,SEGNAM		;GET NAME OF UPPER, IF ANY
	X IWAIT,IWAIT		;GO INTO A WAIT STATE, WAKE UP ON ANY INTERRUPT. - 400040
	X USKIP,USKIP		;SKIP IF A UWAIT REALLY HAS TO WAIT.
	X BUFLEN,BUFLEN		;RETURN BUFFER LENGTH FOR A DEVICE
	X NAMEIN,NAMEIN		;SEE IF THIS JOB NAME EXISTS
	X SLEVEL,SETLVL		;SET OR GET SERVICE LEVEL.
	X IENBW,IENBW		;ENABLE INTERRUPTS AND IMMEDIATELY GO INTO WAIT STATE
	X FILUSR,FILUSR		;TELL WHAT JOB(S) USING A FILE
	X TTYMES,TTYMES		;SEND A STRING TO A TTY
	X JOBRD,JOBRD		;READ A BLOCK FROM A GUY'S CORE IMAGE - 400050
	X DEVUSE,DEVUSE		;TO TELL HOW MANY PEOPLE ARE WAITING FOR A DEVICE
	X SETPR2,SETPR2		;SET SECOND PROTECT-RELOCATE REGISTER!
	X GETPR2,PR2GET		;GET LAST SETPR2 VALUE
	X RLEVEL,RLEVEL		;GET CURRENT SERVICE LEVEL RESERVATION
	X STDTIM,STDTIM		;LIKE ACCTIME, BUT RETURN PACIFIC STANDARD TIME
	X KILL,KILUUO		;KILL A JOB (FOR SPY, MUST HAVE MESPRV)
	X WHOAMI,WHOAMI		;I ASSERT THAT I AM A SPECIAL PHANTOM
	X ATTJOB,ATTJBU		;PRIVILEGED ATTACH TO JOB
	X WAKEME,WAKEME		;SET ALFRED. TIME TO INITIALIZE A JOB.
	X GETNAM,GETNAM		;RETURN JOBNAME IN AC
	X SNEAKW,SNEAKW		;PEEK AT NEXT TTY CHAR. AND WAIT FOR IT
	X SNEAKS,SNEAKS		;PEEK AT NEXT TTY CHAR. AND SKIP IF ONE THERE
	X CHRMAC,CHRMAC		;DEFINE CHARACTER MACRO FOR NOEDIT DM
	X SETPRV,SETPRV		;RESET JOBTPRV
IFE FTF2,<
	X DDCHAN,DDCHAN		;GET/RELEASE DD CHANS ETC.
	X VDSMAP,VDSMAP		;CHANGE VIDEO SWITCH MAPPING - 400070
>;IFE FTF2
IFN FTF2,<
	X F2UUO,UUOERR		;NO DDCHAN ON F2, BUT DEFINE ILLEGAL TO USE F2UUO
IFN FTLLL,<
	X LLLUUO,UUOERR		;NO VDSMAP ON F2, BUT DEFINE ILLEGAL TO USE LLLUUO
>;IFN FTLLL
IFE FTLLL,<
	X <>,UUOERR		;NO VDSMAP ON F2, NO LLLUUO AT CCRMA
>;IFE FTLLL
>;IFN FTF2
	X DSKPPN,UDSKPPN	;GET OR SET DISK ALIAS PPN
	X GETHI,GETHI		;GET EXTRA CORE AS UPPER SEGMENT
	X SETCRD,SETCRD		;SET JOB CREATION DATE & TIME
	X CALLIT,CALLIT		;TRANSLATE CALL TO CALLI OR VICE VERSA
IFN FTP2*XGPNUM,<
	X XGPUUO,XGPUUO		;FONT COMPILER & XGPSER COMMUNICATION.
>;IFN FTP2*XGPNUM
IFE FTP2*XGPNUM,<
	X <>,UUOERR		;NO XGPUUO IF NO P2
>;IFE FTP2*XGPNUM
	X LOCK,LOCK		;LOCK A JOB IN CORE.
	X UNLOCK,UNLOCK		;UNLOCK A JOB
	X DAYCNT,DAYCT		;SYSTEM DATE TO DAY COUNT. - 400100
	X ACCTIM,ACCTIM		;RETURN <DATE>,,<TIME IN SECS>
	X UNPURE,UNPURE		;UNPURIFY UPPER SEGMENT
	X TMPCRD,TMPCRD		;READ OTHER JOB'S TMPCOR
	X DEVNUM,DEVNUM		;CONVERT LOGICAL DEV NAME OR CHANNEL # TO UNIT #
	X ACTCHR,ACTCHR		;WAIT FOR ACTIVATION AND RETURN CHAR WHICH DUN IT
	X UUOSIM,UUOSIM		;SET UP UUO SIMULATOR
	X PPSPY,PPSPY		;LIKE PPINFO FOR ANOTHER JOB
	X ADSMAP,ADSMAP		;SET/READ AUDIO SWITCH SELECTIONS -400110
	X BEEP,BEEP		;BEEP A TTY'S CHANNEL
	X WHO,WHOUUO		;READ SYSTEM OR USER WHO LINE
	X TTYJOB,TTYJNO		;GET JOB # ON THIS TTY
	X NULMES,NULMES		;LIKE TTYMES BUT ALLOWS NULLS WITHIN TEXT
	X GETPRV,GETPRV		;GET PRIVILEGES BY JOB #
	X TTYSKP,TTYSKP		;SKIP IF TTY INPUT UUO WON'T HANG
	X DIAL,DIAL		;DIAL UUO
	X GETMAC,GETMAC		;GET NOEDIT DM CHARACTER MACRO
	X TTYSET,TTYDDL		;EXECUTE TABLE OF OPERATIONS FOR TTY
IFKL10,<
	X MTRUUO,MTRUUO		;DIDDLE KL10 METERS
>;IFKL10
NOKL10,<
	X <>,UUOERR		;NO MTRUUO IF NOT KL
>;NOKL10
	X RDLINE,RDLINE		;READ A LINE OF TTY INPUT AND GIVE IT TO USER
	X SETPPV,SETPPV		;SET PASSIVE PRIVS
IFN FTP2,<
	X P2UUO,P2UUO		;DO VARIOUS THINGS ABOUT P2SYS
>;IFN FTP2
IFE FTP2,<
	X <>,UUOERR		;NO P2UUO IF NO P2
>;IFE FTP2
	X PHPEEK,PHPEEK		;PEEK PHYSICAL MEMORY
IFKL10,<
	X DTELOD,DTELOD		;Load 11/40 console via DTE20
	X QMPUUO,QMPUUO		;Manipulate to-11 and to-10 message queues
>;IFKL10
NOKL10,<
	X <>,UUOERR		;No DTELOD if no DTE
	X <>,UUOERR		;No QMPUUO if no 11/40 via DTE20
>;NOKL10
IFN FTCCRMA,<
	X MCREAD,MCREAD		;At CCRMA, read Microswitch kbd state.
>;IFN FTCCRMA
IFE FTCCRMA,<
	X MCREAD,CPOPJ		;Elsewhere, a no-op
>;IFE FTCCRMA
	X PRVIOR,PRVIOR		;Turn on privileges
	X PRVACM,PRVACM		;Turn off privileges
	X BLKLEN,BLKLEN		;Get disk block length
	X NETUUO,NETUUO		;Special network functions
	X SPOOLR,SPOOLR		;Spooler name lookup
>;STANFORD	;Insert new UUOs above here
;NOTE, USE UP THE UUOERR ENTRIES BEFORE MAKING NEW ONES
;UCLTAB ZZ ZZ UCLJMP

;MACROS TO DEFINE CALLI TABLES

DEFINE X! (A,B)
<
	<SIXBIT /A/>
>

PSHSYS
LOSYS

↑UCLTAB:		;POINTER TO HERE IN OUTER
	XLIST
	NAMES
XP UCLDLN,.-UCLTAB
	STANFORD
	LIST
XP UCLLEN,.-UCLTAB
	UUONAM		;POINTER TO FIND REST OF UUO NAMES

POPSYS

DEFINE X!(A,B)
<IFE ZZ/2*2-ZZ,<DEFINE ZZZ<B>>
IFN ZZ/2*2-ZZ,<XWD ZZZ,B>
ZZ←←ZZ+1
>

ZZ←←0

UCLJMP:
	XLIST
	NAMES
	STANFORD
	LIST

IFN ZZ/2*2-ZZ,<XWD ZZZ,0>
;EXIT EXIT1 EXIT2 EXIT3

;EXIT UUO ROUTINE

HISYS

;REG (1-14-72) EXIT UUO WITH AC FIELD ≠ 0 WILL STOP JOB,
;TYPE CRLF DOT AND ALLOW USER TO TYPE CONTINUE

EXIT:	PUSHJ P,INTTST		;MAKE SURE NOT AT INT LEVEL OR SPACEWAR
	MOVE	TAC,JBTSTS(J)
	HRRE	TAC1,JBTLIN(J)
	JUMPL	TAC1,EXIT1	;KILL DETACHED JOB THAT EXIT!
	TLNN	TAC,JLOG	;LOGGED IN?
	JRST	EXIT1		;FLUSH DETATCHED OR UNLOGGED IN JOBS
	JUMPN	UCHN,EXIT2	;JUMP IF AC FIELD OF EXIT UUO WAS NOT ZERO
	MOVSI TAC,JACCT		;LOGIN FROM ATTACH CMD CAN JUST EXIT
	ANDCAB TAC,JBTSTS(J)	;SO WE SHOULD MAKE SURE TO FLUSH JACCT
	PUSHJ	P,KILSPW
	PUSHJ	P,INTKIL
	PUSHJ	P,IORELS	;FLUSH USER'S IO (GENTLY - CLOSES FILES)
	PUSHJ	P,RESETB	;RESET EVERYTHING ELSE
	PUSHJ	P,TTYFUW	;FIND TTY FOR CURRENT JOB.  SETUP J,DDB,DAT
	XCTR	XW,[SETZM JOBOPC]	;NO MORE OPC
	SETZM	UUOPC(J)		;NOR USER PC (ESTOP NOW GOES TO USRXIT)
	SETZM	UUOOPC(J)		;NOR BACKUP USER PC
					;ALL THIS MEANS THAT THE NEXT START, ETC.
					;PUTS A 0 IN JOBOPC - FOR RAID
	JSP	TAC,PHOLD		;APPEND "EXIT". STOP JOB. START TTY.
	ASCIZ /
Exit/

EXIT1:	PUSHJ	P,KILSPW	;ZERO SPACEWAR CELLS
	PUSHJ	P,INTKIL
	PUSHJ	P,IORELS	;HERE TO KILL JOB.  FLUSH USER IO (GENTLY?)
	JRST	JOBKL		;AND THROW THE USER OFF. (CALLS RESET)

EXIT2:	PUSHJ P,KILSPW		; ZERO SPACEWAR CELLS
	HLL TAC1,LINTAB(TAC1)	;Get line characteristics
	SKIPN DDB,LETAB(TAC1)
	JRST EXIT3		;No dpy hdr
	HLLZ DAT,TAC1		;Get display-type bit
	SETZ UUO,
	PUSHJ P,LEYPOS		;Reset line editor position to normal
	TLNE	TAC1,DDDLIN!DMLIN
	PUSHJ	P,DDWAIT	;WAIT FOR DD/DM USER OUTPUT TO FINISH
EXIT3:	PUSHJ	P,TTYFUW	;GET THE USER'S CONSOLE
	PUSHJ	P,PRCRCC	;TYPE CRLF ↑C CRLF .
	PUSHJ	P,TTYSTC	;START THE TTY
	JRST	STOP1		;SET JOB NOT RUNNABLE.  UUOXIT WILL STOP IT.
;INTTST RESET RESETU RESETB NOPR2 NOTWHO

;INTTST RESET RESETU RESETB NOPR2

INTTST:	SKIPE SPWUUF		;SPACEWAR ACTIVE?
	JRST SPWERR		;YES. THIS IS AN ERROR.
	SKIPN INTACT		;USER INTERRUPT-LEVEL?
	POPJ P,			;NO. WE'RE OK.
	JSP TAC,UUOMES		;HERE FOR A UUO ILLEGAL AT INT LEVEL
	ASCIZ /Illegal I-level call, UUO/


↑RESET:	SKIPA TAC,[PUSHJ P,RESETSEG]
↑RESETU:MOVSI TAC,(<JFCL>)	;INSTR TO XCT AFTER STOPPING IO, ETC.
	PUSHJ P,INTTST
	PUSH P,TAC		;SAVE INSTR. TO XCT.
	PUSHJ P,KILSPW
	PUSHJ P,INTKILL
	PUSHJ P,IOKILL		;KILL IO ON ALL DDBS.  (RELEA5)
	SETZM DDBCNT(J)		;NO DDBS OPEN NOW (JUST TO BE SAFE)
	POP P,TAC
	XCT TAC			;PUSHJ P,RESETSEG OR JFCL
RESETB:	PUSHJ P,UNLOCK		;UNLOCK HIM IN CORE.
	SKIPE TAC,JBTPR2(J)	;IS HE DOING PEEK-POKE?
	TRNE TAC,2		;YES, BUT DON'T CLEAR PSEUDO-UPPER
	JRST NOPR2		;NO PEEK-POKE, OR PSEUDO-UPPER.
	PUSHJ P,ZERPR2		;CLEAR JBTPR2 AND PAGE MAP ENTRIES
	JFCL
NOKL10,<CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON	;CLEAR ARS
>;IFKL10
NOPR2:	MOVE J,JOB
	SETZM JBTIOW(J)		;NOT WAITING FOR ANY DEVICE (WHOLINE)
	SETZM JBTDDB(J)		;NO DDB TO DISPLAY ON WHOLINE NOW
	SKIPE AC1,JBTFS(J)	;ANY FREE STORAGE?
	PUSHJ P,FSGIVE		;YES, RETURN IT
	SETZM JBTFS(J)
IFN FTNSWP,<
	PUSHJ P,RELSWP		;RELEASE SWAPPING SPACE
>;IFN FTNSWP
	MOVEI TAC,0
	PUSHJ P,APRENB		;KILL HIS APR INTERRUPTS
	HRRZ AC1,JBTMAIL(J)	;ANYTHING IN HIS MAILBOX ?
	JUMPE AC1,.+2		;NO.
	PUSHJ P,FSGIVE		;YES. RETURN THE FREE STORAGE.
	SETZM JBTMAIL(J)	;EMPTY THE MAILBOX.
	CAME J,WHOJOB		;IS IT THE MINI-WHO PHANTOM?
	JRST NOTWHO
	SETZM WHOJOB		;NOT ANY MORE
	SETOM WHOKLU		; SO THE SYSTEM BETTER ERASE AVLCHN
NOTWHO:	PUSHJ P,TTYRST		;FLUSH HIS PTY'S & RESET TTY.
	MOVSI TAC,(J)
IFE FTF2,<
	PUSHJ P,DDAREL		;FLUSH HIS DATA DISC CHANNELS
>;IFE FTF2
IFN FTAS,<
	PUSHJ P,ADSRES		;RESET AUDIO SWITCH MAP
>;IFN FTAS
IFKL10,<
	PUSHJ P,CSHRES		;CLEAR CACHE DISABLE REASONS
>;IFKL10
	MOVE AC1,JBTLIN(J)	;PICK UP LINE CHARACTERISTICS
	CAMN AC1,[-1]		;DETACHED?
	POPJ P,			;YES, NO RESET OF SCREEN
	HLL AC1,LINTAB(AC1)	;GET REAL LINE CHARACTERISTICS
	TLNE AC1,DISLIN!DDDLIN!DMLIN ;IF III OR DD OR DM, GO RESET THE DISPLAY
	JRST DPYRST		;RESET HIS DPY, IF HE HAS ONE.
	JRST CHASER		;FLUSH ANY DM PROGRAM OF OURS FROM PTY OWNER
;RESETSEG RESTG1

;RESETSEG - ROUTINE TO RESET ONE'S UPPER SEGMENT

RESETSEG:
	PUSH P,TAC
	PUSH P,AC1
	PUSH P,TAC1
	PUSH P,DDB
	PUSHJ P,FLUSHSEG	;FLUSH HIS UPPER, IF ANY
	CAME J,JOB		;IS THIS THE CURRENT JOB?
	JRST RESTG1		;NO, DON'T BOTHER TO RESET PR
NOKL10,<CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON	;CLEAR ARS
>;IFKL10
RESTG1:	POP P,DDB
	POP P,TAC1
	POP P,AC1
	POP P,TAC
	POPJ P,
;APRDKL APRDK3 APRDK2 APRDK1

;APRDKL  ROUTINE TO KILL ANY CLOCK INTERRUPT REQUESTS FOR JOB J

APRDKL:	PUSH P,TAC1		;SAVE THIS IN CASE SOMEONE DEPENDS ON IT
	CONI PI,TAC1		;GET STATE OF PI SYSTEM
	ANDI TAC1,APROFF-1000	;MASK FOR ONLY STATE OF APR CHANNEL
	CONO PI,APROFF		;MAKE SURE CHANNEL IS OFF
	SKIPE TAC,APRLST
APRDK3:	SKIPN AC1,(TAC)
	JRST APRDK1		;APRLST EMPTY OR END OF LIST
	CAIN J,(AC1)
	JRST APRDK2		;THIS IS OUR REQUEST
	ADDI TAC,2
	JRST APRDK3

APRDK2:	PUSHJ P,APRDEL		;DELETE REQUEST POINTED TO BY TAC
	JFCL
APRDK1:	CONO PI,2000(TAC1)	;TURN CHANNEL ON ONLY IF WE TURNED IT OFF.
	POP P,TAC1
	POPJ P,
;SETPOV APRENB APREN2

;APRENB, SETPOV - ROUTINE TO SET UP APR FOR USER TRAPPING, PDLOV TRAP  APREN2

;CALL:	MOVE AC,<APR CONI BITS TO BE ENABLED (SEE BELOW)>
;	APRENB AC,

;SET THE FOLLOWING BITS IN THE AC PRIOR TO CALLING APRENB
;1B18		;CONS TRAP		;JS
;1B19	;PUSHDOWN OVERFLOW
;1B22	;ILLEGAL MEMORY
;1B23	;NON-EXISTENT MEMORY		(USERS ARE NOT ALLOWED TO GET NXM TRAPS)
;1B26	;CLOCK
;1B29	;AR FOV (OR PC CHANGE FLAG ON 166)
;1B32	;AROV


;SETPOV - SET PUSH DOWN OVERFLOW TRAP
;CALL:	MOVE AC,<ADRESS OF TRAP ON PD OVF>
;	SETPOV AC,


SETPOV:	XCTR XW,[MOVEM TAC,JOBAPR]	;STORE USER'S TRAP ADDRESS
	MOVEI TAC,1B19			;SELECT ENABLE BITS FOR ARPENB
APRENB:	ANDI TAC,CPUMSK!1000		;MASK OUT ILLEGAL BITS ;JS
	XCTR XW,[MOVEM TAC,JOBENB]	;SET RH TO CONSO BITS
	TDNE TAC,APRIN2
	JRST INTLOS			;CONFLICTING INTERRUPT ENABLINGS
	IOR TAC,APRIN2			;INCLUDE NEW MOORER INTERRUPT SYSTEM
	JRST APREN2

LOSYS

;P2 CAN GET HERE FROM CLKSER
;(CALL APREN2 TO START A PROCESS (CIP8 OR SPACEWAR))
↑APREN2:HRRM TAC,APRIN1(PID)		;STORE USER'S ENABLINGS FOR ARPINT CONSO
	XORI TAC,110			;COMPLEMENT FOV AND AROV
	ADDI TAC,330			;DISABLE THE ENABLED ONES
	ANDI TAC,660
NOKL10,<CONO APR,APRCHN(TAC)		;ENABLE OR DISABLE FOV AND/OR AROV >;NOKL10
IFKL10,<TRNN TAC,220			;SKIP IF ANYTHING IS ENABLED
	TLOA TAC,(<CAI>)		;NO
	MOVSI TAC,(<.TRAP 1,>)
	MOVEM TAC,KLUPT+KLUOVT		;STORE ARITH OVERFLOW TRAP INSTR
>;IFKL10
	POPJ P,

HISYS
;PEEK PHPEEK SWITCH JOBNO DATE STOTAC DAYCT STDTIM ACCTIM TIMER JOBTIM JOBTI2 MSTIME MSTIM1

;PEEK - READ A WORD FROM A GIVEN MONITOR SPACE ADDRESS.

PEEK:	ANDI TAC,-1			;GET 18-BIT EXEC VIRTUAL ADDRESS ONLY
	LDB AC1,[POINT 9,TAC,26]	;GET PAGE NUMBER
NOKL10,<
	CAIL AC1,600
	ADDI AC1,PSB-EXPGT		;PAGE IS IN PSB
>;NOKL10
	SKIPN EXPGT(AC1)		;DOES THIS PAGE EXIST IN MAP?
	JRST RTZERO			;NO SUCH ADDRESS, LOSE
	MOVE TAC,(TAC)			;YES, GET THE DATA
	JRST STOTAC

; PHYMEM - READ A WORD FROM A GIVEN PHYSICAL (FULLWORD!) ADDRESS

PHPEEK:	LDB AC1,[POINT 9,TAC,35]	;GET PAGE OFFSET
	LSH TAC,-9			;MAKE PHYSICAL PAGE
	CAIL TAC,PHYMEM*2
	JRST RTZERO			;PAST END OF PHYSICAL MEM
	MOVEI DSER,(TAC)		;(DSER=LOC)
	LDB DSER,COREP			;GET CORTAB ENTRY FOR THIS PAGE
	CAIN DSER,NXMCUS		;IS THIS THE NXM CORE USAGE CODE?
	JRST RTZERO			;THIS IS A NON-EX PAGE
	CAIL DSER,JOBN		;This page belong to a job?
	JRST PHPEE2		;No, allow peek
	JUMPE DSER,PHPEE2	;Allow peek if page not in use
	EXCH DSER,J		;Put peekee job in J, preserve old J
	PUSHJ P,PRVCHK		;Skip if peekee isn't specially priv'd
	 MOVEI J,0		;Flag priv failure
	EXCH DSER,J		;Restore J, flag to DSER
	JUMPE DSER,RTZERO	;Return zero on failure
PHPEE2:	MOVEI TAC1,PEKEXP
	PUSHJ P,ADDEMP
	MOVE TAC,PEKEXP⊗9(AC1)
	PUSHJ P,DELEMP
	JRST STOTAC


SWITCH:
NOKL10,<DATAI TAC		;RETURN APR DATA SWITCHES >;NOKL10
IFKL10,<PUSHJ P,RSWITCH		;GET PDP-11'S VERSION OF SWITCHES >;IFKL10
	JRST STOTAC

;STOTAC STORES TAC IN THE USER'S ADDRESS POINTED TO BY RH OF UUO.
;FOR CALL/CALLI UUOS, UUO POINTS TO THE USER'S ACCUMULATOR.

JOBNO:	SKIPA TAC,J			;RETURN JOB NUMBER OF THIS JOB
DATE:	MOVE TAC,THSDAT			;RETURN DATE TO USER
↑STOTAC:XCTR XW,[MOVEM TAC,(UUO)]	;STORE TAC INTO USER'S AC
	POPJ P,

;CONVERT SYSTEM FORMAT DATE TO NUMBER OF DAYS SINCE 1-JAN-64
DAYCT:	JUMPG TAC,.+2		;ARGUMENT IN SYSTEM FORMAT TO DAY COUNT.
	MOVE TAC,THSDAT		;ZERO OR NEGATIVE DATE GIVEN GETS TODAY'S DATE
	PUSHJ P,DAYCNT		;THIS ROUTINE IS IN COMMAND DECODER (CLKSER)
	JRST STOTAC

STDTIM:	MOVE TAC,PSTDAT
	JRST STOTAC

ACCTIM:	SKIPA TAC,TIMDAT	;GET <DATE>,,<TIME IN SECS>
TIMER:	MOVE TAC,TIME		;RETURN TIME OF DAY IN JIFFIES
	JRST STOTAC

;RETURN JOB RUNNING TIME IN MILLISECONDS
JOBTIM:	JUMPL TAC,RTZERO	;ILLEGAL JOB NUMBER
	CAIL TAC,JOBN	
	JRST RTZERO		;ILLEGAL JOB NUMBER
	JUMPG TAC,.+2
	MOVEI TAC,(J)		;ASSUME CURRENT JOB FOR ZERO ARGUMENT
IFKL10,<
IFE FTMTRACT,<
	SKIPG MTRBKG
>;IFE FTMTRACT
IFN FTMTRACT,<
	SKIPL MTRBKG
>;IFN FTMTRACT
	JRST JOBTI2
	LSH TAC,1
	PUSH P,TAC
	PUSHJ P,EBXPUT		;STORE ACCOUNTING METERS
 	PUSHJ P,EBXGET		;RE-ENABLE AND ZERO UPT COUNTERS
	POP P,TAC
	MOVE TAC1,MTRETIME+1(TAC)
	MOVE TAC,MTRETIME(TAC)
	PUSHJ P,MTRCVM		;CONVERT TO MILLISECONDS IN TAC
	JRST STOTAC
>;IFKL10
JOBTI2:	SKIPA TAC,TTIME(TAC)	;TOTAL JOB RUNNING TIME IN TICKS.
MSTIME:	MOVE TAC,TIME		;RETURN TIME OF DAY IN MILLISECONDS
MSTIM1:	IMULI TAC,=1000		;CONVERT TIME FROM JIFFIES TO MILLISECONDS
	IDIVI TAC,JIFSEC	;DIVIDE BY NO. OF JIFFIES PER SECOND
	JRST STOTAC
;⊗ SLEEP SLEEPT SLEEP1 ASYML ASYMSL ASYMLL ASYMS1 ASYMS2 ASYML0 ASYML6 ASYML2 ASYML3 ASYML7 ASYML8 ASYML4 ASYME0 ASYME1 ASYME2 ASYME3 ASYMEX SADXCH SADXC2 SADXCT SADXC3 SADXC4 SADLDB

;SLEEP	PUT JOB TO SLEEP FOR NSECONDS
;CALL:	CALL AC,[SIXBIT /SLEEP/]

↑SLEEP:	IMULI TAC,JIFSEC	;MULTIPLY BY NO. OF JIFFIES PER SECOND
↑SLEEPT:MOVSI TAC1,CLKR
	TDNE TAC1,JBTSTS(J)	;IS THERE A CLOCK REQUEST FOR THIS JOB ALREADY?
	JRST SETSLP		;YES, DO NOT PUT ANOTHER ONE IN.
	ANDI TAC,7777		;Clear most of AC for clock request data
	TRNN TAC,7777		;0 TIME?  JS
SLEEP1:	MOVEI TAC,1		;YES. SLEEP 1 JIFFY
	DPB J,[POINT JOBNSZ,TAC,23]
	TLO TAC,$WAKE		;Go to WAKE to wakeup job when time runs out
	CLKENQ(TAC)		;Plant clk req
	JRST SETSLP		;SET JOB STATUS WORD SO JOB WILL NOT RUN

;.SYML LOOK UP SYSTEM SYMBOL
;CALL:	MOVEI AC,ADR
;	.SYML AC,
;	ERROR RETURN
;	SUCCESS RETURN

;ADR:	RADIX50 /SYMBOL/
;ADR+1:	RADIX50 /BLOCKNAME/ OR 0

;THE UUO WILL SEARCH THE SYSTEM'S SYMBOL TABLE FOR THE GIVEN SYMBOL.
;IF IT IS FOUND IN THE SPECIFIED BLOCK, THE SYMBOL'S VALUE IS RETURNED,
;REGARDLESS OF THE EXISTENCE OF THE SYMBOL IN ANY OTHER BLOCKS.  IF THE
;BLOCKNAME IS 0, THEN THERE MUST BE EXACTLY ONE OCCURENCE OF THE SYMBOL
;IN THE TABLE.

;ON A SUCCESSFUL RETURN THE SYMBOL VALUE WILL BE IN AC
;IN A FAILURE RETURN, THE AC WILL CONTAIN A FAILURE REASON:
;	0	SYSTEM SYMBOLS NOT IN CORE OR NOT SORTED
;	1	SYMBOL NOT FOUND IN ANY BLOCK
;	2	SYMBOL NOT FOUND IN SPECIFIED BLOCK, BUT IS IN SOME OTHER BLOCK
;	3	SYMBOL MULTIPLY DEFINED (BLOCKNAME WAS 0)

IFN FTDMAP,<
;If DDT's symbols are mapped out into extra core, then this UUO references
;the mapped out symbol table by mapping it into the PEKEXP exec virtual
;page one page at a time.  Careful track is kept of how much of which
;physical page of the symbol table is left in the mapped-in page:
;"Logical address" here means the original virtual (same as physical)
;address of the entity before DDT got mapped out (i.e., the address of
;the entity if DDT and the symbols were currently mapped in).
;PROG/ logical address of base of symbol table page currently mapped in
;DAT/ -<page word count>,,logical address of symbol table entry being examined
;     The <page word count> here is words left in the currently mapped page.
;AC3/ -<symbol word count>,,exec virtual address corresponding to RH DAT.
;     The LH of AC3 tells number of words left in the symbol table.
;     The RH of AC3 is an address within the PEKEXP exec page.
;
;The routine SADXCH is called to map references of logical symbol table
;addresses to exec virtual address and to execute the instruction containing
;the logical address by using the virtual address.  A special check is made
;for LDB instructions, to map the effective address within the byte pointer
;instead of the effective address within the instruction.  That routine also
;updates the LH of DAT and the RH of AC3 to match the descriptions above.
;
;If the symbols are actually all mapped in (INDDT non-zero), then all the
;special map checking is avoided and the LH of DAT is set to a big negative
;number to keep ASYMS1 from thinking it needs to map in a new page of symbols.
>;IFN FTDMAP

ASYML:
IFE FTDMAP,<
	SKIPE INDDT
>;IFE FTDMAP
	SKIPN TAC1,SYMLOC
	JRST ASYME0		;NO DDT NO SYMBOLS
IFN FTDMAP,<
	MOVSI DAT,400000	;In case symbols are in, big LH count; no page in.
	MOVEI PROG,0		;No page mapped in yet
	PUSHJ P,SADXCH		;Check address of next instruction
>;IFN FTDMAP
	 MOVE TEM,(TAC1)
	AOJN TEM,ASYME0		;SYMBOLS NOT SORTED
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 MOVE TEM,1(TAC1)	;RELATIVE POINTER TO BLOCK NAMES
	ADDI TEM,(TAC1)		;ABSOLUTE
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 MOVE DSER,11(TAC1)	;RELATIVE PTR TO 1 PAST LAST SYMBOL
	ADDI DSER,(TAC1)	;ABSOLUTE
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 MOVE AC3,5(TAC1)	;RELATIVE PTR TO FIRST SYMBOL
	ADDI AC3,(TAC1)		;ABSOLUTE
IFN FTDMAP,<
	HRR DAT,AC3		;Copy pointer (AC3 will get virtual address)
>;IFN FTDMAP
	SUBM AC3,DSER		;- NUMBER OF WORDS OF SYMBOLS
	HRLI AC3,(DSER)		;AOBJN POINTER TO SYMBOLS
	XCTR XR,[MOVE AC1,(TAC)] ;GET THE SYMBOL
	XCTR XR,[MOVE AC2,1(TAC)] ;GET THE BLOCKNAME
	MOVEI TAC,0		;FLAGS
ASYMSL:	MOVEI IOS,=2000
ASYMLL:	SOJG IOS,ASYMS1
IFN FTDMAP,<
	PUSH P,TAC1
	MOVEI TAC1,PEKEXP	;Used PEEK virtual page for looking at symbols
	SKIPE EXPGT(TAC1)	;If we set up a special map page, flush it
	PUSHJ P,DELEMP		;Flush the exec virtual page we used
	POP P,TAC1
	SKIPN INDDT		;Don't touch infinite count if symbols are in
	HRLI DAT,0		;Clear remaining word count in page
	MOVEI PROG,0		;No page mapped any more
>;IFN FTDMAP
	PUSHJ P,WSCHED		;GIVE SOMEONE ELSE A CHANCE
	JRST ASYMSL

ASYMS1:
IFN FTDMAP,<
	JUMPL DAT,ASYMS2	;Jump if any words left in mapped page
	PUSHJ P,SADXCH		;Check address and execute next instruction
	 LDB DSER,[POINT 32,(DAT),35] ;GET A SYMBOL
	CAIA
ASYMS2:
>;IFN FTDMAP
	 LDB DSER,[POINT 32,(AC3),35] ;GET A SYMBOL
	CAMN DSER,AC1		;DOES IT MATCH?
	JRST ASYML6		;YES
ASYML0:
IFN FTDMAP,<
	ADD DAT,[2,,2]		;Two less words left in mapped page
>;IFN FTDMAP
	ADD AC3,[2,,2]		;Advance pointer beyond two words of symbol
	JUMPL AC3,ASYMLL	; table entry--loop if more entries.
	TLNN TAC,600000
	JRST ASYME1		;SYMBOL NOT FOUND ANYWHERE
	JUMPL TAC,ASYME2	;SYMBOL FOUND IN SOME OTHER BLOCK
	JRST ASYML8		;UNIQUE SYMBOL value, USER BLOCKNAME 0, return value

ASYML6:	JUMPE AC2,ASYML2	;JUMP IF USER BLOCKNAME IS 0
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
	 LDB DSER,[POINT 13,1(DAT),12]	;GET BLOCK NAME POINTER
>;IFN FTDMAP
IFE FTDMAP,<
	 LDB DSER,[POINT 13,1(AC3),12]	;GET BLOCK NAME POINTER
>;IFE FTDMAP
	ADD DSER,TEM			;ADDRESS OF ENTRY IN BLOCK NAME TABLE
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 LDB DSER,[POINT 32,(DSER),35]	;GET BLOCK NAME SYMBOL
ASYML2:
IFN FTDMAP,<
	SKIPN INDDT		;Don't touch infinite count if symbols are in
	HRLI DAT,0		;Clear word count left in page, force checking
	HRR AC3,DAT		;Logical address of matching symbol
>;IFN FTDMAP
	PUSH P,UCHN		;remember any previous value discovered
	HRRZ DDB,AC3		;Address of winning symbol
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 HRRZ UCHN,1(DDB)	;GET THE VALUE
	SUBI DDB,(TAC1)		;MAKE DDB RELATIVE ADDRESS OF SYMBOL
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 CAMGE DDB,7(TAC1)	;IS IT CLASS 3 OR 4 SYMBOL?
	JRST ASYML3		;NO, ALL DONE
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 CAMGE DDB,10(TAC1)	;IS IT A CLASS 4 SYMBOL?
	JRST ASYML4		;NO, CLASS 3
	ADDI UCHN,(TAC1)	;VAL IS REALLY REL PTR TO VALUE
IFN FTDMAP,<
	PUSHJ P,SADXCH		;Check address and execute next instruction
>;IFN FTDMAP
	 MOVE UCHN,(UCHN)	;GET ACTUAL VALUE
ASYML3:	POP P,DDB		;get back any prev value found
	JUMPN AC2,ASYML7	;jump if explicit blockname specified by user
	TLOE TAC,200000		;remember we found a value, skip if no prev
	CAMN UCHN,DDB		;found second value, skip if different from prev
	JRST ASYML0		;first value, or same as prev, all OK, keep looking
	JRST ASYME3		;multiply defined, with different values

;here if explicit block name given by user, see if it matches this symbol's block
ASYML7:	TLO TAC,400000		;note a partial match, at least
	CAME AC2,DSER		;block name match?
	JRST ASYML0		;no, keep looking
ASYML8:	MOVE TAC,UCHN		;get winning value to be returned
	AOS (P)			;success, skip return
	JRST ASYMEX

ASYML4:	HRLZ UCHN,UCHN		;CLASS 3 IS LEFT HALF VALUE
	JRST ASYML3

ASYME0:	TDZA TAC,TAC
ASYME1:	MOVEI TAC,1
	JRST ASYMEX

ASYME2:	SKIPA TAC,[2]
ASYME3:	MOVEI TAC,3
ASYMEX:
IFN FTDMAP,<
	MOVEI TAC1,PEKEXP	;Used PEEK virtual page for looking at symbols
	SKIPE EXPGT(TAC1)	;If we set up a special map page, flush it
	PUSHJ P,DELEMP		;Flush the exec virtual page we used
>;IFN FTDMAP
	JRST STOTAC

IFN FTDMAP,<
;Check address and execute next instruction inline following call.
;Updates LH of DAT to zero or -count of words left in page pointed to by RH,
;RH of AC3 to exec virtual address of ptr in DAT RH (if currently mapped page),
;and PROG to page mapped in.
SADXCH:	SKIPE INDDT		;Return quick if symbols mapped in
	POPJ P,
	PUSH P,TAC1		;Check address of next instruction
	PUSH P,TAC		;Must map in different page
	PUSH P,@-2(P)		;Get instruction to check
	MOVEI TAC,@(P)		;Get effective address
	EXCH TAC,(P)		;Get instruction, save effective address
	AND TAC,[777000,,0]	;Just opcode, to test for LDB
	XOR TAC,[LDB]		;Make zero mean opcode is LDB
	PUSH P,TAC		;Put opcode-not-LDB flag on top of stack
	JUMPN TAC,SADXC2	;Jump if not LDB
	MOVE TAC,@-1(P)		;Get byte pointer
	MOVEM TAC,-1(P)		;Save on stack
	MOVE TAC,-2(P)		;Restore TAC, in case referenced in byte pointer
	MOVEI TAC,@-1(P)	;Get real effective address from byte pointer
	CAIA
SADXC2:	MOVE TAC,-1(P)		;Get back effective address
	CAIL TAC,(PROG)		;Is address within mapped page?
	CAILE TAC,777(PROG)	;Skip if so
	CAIA			;Different page, diddle map
	JUMPN PROG,SADXCT	;Yes, proceed, unless no map set up at all
	MOVE PROG,TAC		;Calculate beginning page address of DDT page
	SUB TAC,CDDTA		;Offset within mapped DDT
	LSH TAC,-9		;Which page we need
	CAML TAC,DDTPGS
	PUSHJ P,BUGTRP		;There aren't that many pages of mapped DDT!
	HRRZ TAC,DDTMAP(TAC)	;Physical page number
	MOVEI TAC1,PEKEXP	;Use PEEK virtual page for looking at symbols
	SETZM EXPGT(TAC1)	;Forget any old page mapped
NOKL10,<CONO PAG,1		;GRONK PAGER TO MAKE IT FORGET OLD EXEC ARS
>;NOKL10
IFKL10,<BLKO KLPAG,PEKEXP⊗9	;Clear ARS for this page only
>;IFKL10
	PUSHJ P,ADPEMP		;Map page in, cached
	MOVE TAC,PROG		;Get back effective address
	TRZ PROG,777		;Remember beginning address of page just mapped
SADXCT:	ANDI TAC,777		;Just page offset in effective address
	ADDI TAC,PEKEXP⊗9	;Make it a virtual address within mapped page
	HRRZS TAC1,DAT		;Current symbol table ptr (clear page wd count)
	TRZ TAC1,777		;Current page of symbol table
	CAME TAC1,PROG		;Is this the page that is now mapped in?
	JRST SADXC3		;No, leave page word count zero in LH DAT
	HRRI AC3,(DAT)		;Copy pointer into symbol table
	TRZ AC3,777000		;Flush page number, leave offset within page
	MOVEI TAC1,-1000(AC3)	;Negative word count to end of symbol table page
	HRL DAT,TAC1		;Store for ASYMS1
	ADDI AC3,PEKEXP⊗9	;Make symbol pointer point within mapped page
SADXC3:	MOVE TAC1,@-4(P)	;Get the instruction
	DPB TAC,[POINT 23,TAC1,35] ;Insert effective address, clear index/indirect
	SKIPN (P)		;Skip if not LDB
	JRST SADLDB		;Simulate LDB
SADXC4:	MOVE TAC,-2(P)		;Restore TAC
	EXCH TAC1,-3(P)		;Restore TAC1, put instruction on stack
	AOS -4(P)		;Instruction may skip
	XCT -3(P)		;Reference symbol table
	 SOS -4(P)		;No skip
	ADJSP P,-4		;Flush flag, address/byte ptr, TAC, instruction
	JRST CPOPJ1		;Skip over instruction (plus maybe another skip)

SADLDB:	HRRI TAC1,-1(P)		;This will be effective address of LDB
	DPB TAC,[POINT 23,-1(P),35] ;Insert effective address in byte pointer
	JRST SADXC4
>;IFN FTDMAP
;DVCHR DVCHR0 DVCHR1 DVCHR2 DEVNUM

;DVCHR, DEVNUM

DVCHR:	PUSHJ	P,FNDDDB	;SEARCH FOR DEVICE (OR CHANNEL)
	TDZA	TAC,TAC		;NOT A DEVICE, RETURN ZERO
	SKIPA	TAC,DEVMOD(DDB)	;DEVICE FOUND,RETURN DEVMOD
	JRST	STOTAC		;RETURN ZERO, DEVICE NOT FOUND
	TLNN	TAC,DVUDP
	JRST	DVCHR2		;EASY OUT UNLESS UDP
NoStructure,<
	LDB	AC2,PUNIT	;UDP, SCAN ENTIRE DDB LIST OF THIS UDP
	MOVE	TAC1,DKDBML(AC2)	;model DDB
>;NoStructure
IfStructure,<
	MOVE	AC2,SDBPTR(DDB)		;Address of SDB
	MOVE	TAC1,ST.MDB(AC2)	;address of model DDB
>;IfStructure
	MOVE	AC1,DEVNAM(DDB)
DVCHR0:	HLRZ	TAC1,DEVSER(TAC1)
	CAME	AC1,DEVNAM(TAC1)
	JRST	DVCHR1		;END OF DDBS FOR THIS DEVICE
	IOR	TAC,DEVMOD(TAC1);RETURN UNION OF ALL ASSCON AND ASSPRG BITS
	JRST	DVCHR0

DVCHR1:
NoStructure,<
	SKIPL	TAC1,UDPOWN-1(AC2)
>;NoStructure
IfStructure,<
	SKIPL	TAC1,ST.JOB(AC2)	;job number of UDP owner
>;IfStructure
	CAMN	TAC1,JOB
	TLO	TAC,DVAVAL	;AVAILABLE IF HIS OR PUBLIC
	JRST	STOTAC

DVCHR2:	LDB	TAC1,PJOBN	;GET JOB NO.  USING DEVICE
	CAME	TAC1,JOB	;DOES CURRENT USER ALREADY HAVE IT?
	TDNN	TAC,[XWD TTYATC,ASSCON+ASSPRG]	;NO, IS IT ASSIGNED?
	TLO	TAC,DVAVAL	;NO, BUT HE CAN GET IT.
	JRST	STOTAC

DEVNUM:	PUSHJ	P,FNDDDB
	POPJ P,			;NONE
	LDB TAC,PUNIT		;GET UNIT NUMBER
	AOS (P)
	JRST STOTAC
;UDSKPPN RSTPPN RTDSKPPN RTZERO GETPPN GETPPL GETPP1 GETPP2

;GETPPN -- DSKPPN

;DSKPPN
;CALLING:
;	CALL AC,[SIXBIT/DSKPPN/]
;
;AC		MEANING
;0		RETURN CURRENT JOB'S DSKPPN
;1 TO JOBN-1	RETURN DSKPPN OF JOB IN AC
;-1		RESET DSKPPN OF CURRENT JOB
;ANYTHING ELSE	WILL TRY TO BE PPN TO SET DSKPPN TO
;		MUST HAVE NON-ZERO LEFT AND RIGHT HALVES

UDSKPPN:
	CAMN	TAC,[-1]	;REQUESTING A RESET?
	AOJA	TAC,RSTPPN	;YES, SET TAC TO 0 AND STORE IT
	TLNN	TAC,-1		;IS IT PPN?
	JRST	RTDSKPPN	;NO, MAYBE JUST GETTING SOMEONES DSKPPN
	TRNN	TAC,-1
	HRR	TAC,PRJPRG(J)	;COPY PRG FROM PRJPRG
RSTPPN:	CAMN	TAC,PRJPRG(J)
	MOVEI	TAC,0		;THIS IS REALLY A RESET
	CAMN	TAC,MFDENT	;SAME AS 1,1?
	POPJ	P,		;DISALLOW SOME FORMS OF LOSSAGE.
	CAME	TAC,DSKPPN(J)
	SETZM	JBTUFD(J)	;CLEAR LOC OF UFD IF DEFAULT UFD IS CHANGING
	MOVEM	TAC,DSKPPN(J)	;SET NEW DISK ALIAS PPN
	MOVSI TAC,AAOPRV	;ALSO CLEAR HER AAO PRIVILEGE
	ANDCAM TAC,JB2PRV(J)
	POPJ	P,

RTDSKPPN:
	JUMPN	TAC,.+2
	MOVE	TAC,J			;WANTS HIS OWN
	MOVSI	TAC1,JNA
	CAIGE	TAC,JOBN		;LEGAL?
	TDNN	TAC1,JBTSTS(TAC)	;AND A REAL JOB?
	JRST	RTZERO			;NO
	SKIPN	TAC1,DSKPPN(TAC)	;IF THIS IS 0
	MOVE	TAC1,PRJPRG(TAC)	;THEN THIS IS IT
	XCTR	XW,[MOVEM TAC1,(UUO)]	;RETURN IT
	POPJ	P,

↑RTZERO:MOVEI	TAC,0
	JRST	STOTAC

;RETURN PROJECT-PROGRAMMER NUMBER IN AC
GETPPN:	MOVSI	TAC,JACCT		;ACCOUNTING PROGRAM?
	TDNE	TAC,JBTSTS(J)
	JRST	GETPPL			;YES. GETPPN DOES DIFFERENT THING
	MOVE	TAC,PRJPRG(J)
	JRST	STOTAC

GETPPL:	SETZM	JBTUFD(J)	;ACCOUNTING: ANY OTHER USERS UNDER SAME PPN?
	SETZM	DSKPPN(J)	;RESET DISK ALIAS PPN
	MOVE	TAC,DUMPPN	;GET ALL POWERFULL PPN
	EXCH	TAC,PRJPRG(J)	;SET THIS JOB TO THAT PPN
	MOVSI AC1,JLOG		;PHANTOMS DON'T COUNT
	MOVEI	TAC1,JOBN-1	;LOOK THRU ALL THE WORLD
GETPP1:	CAMN	TAC,PRJPRG(TAC1);SKIP IF NOT MATCHED
	CAMN	J,TAC1		;MATCH. SKIP IF MATCH DIFFERENT FROM JOB NUMBER
	JRST GETPP2		;NO MATCH
	TDNN AC1,JBTSTS(TAC1)	;PHANTOM?
GETPP2:	SOJG	TAC1,GETPP1	;NO MATCH OR MATCHED SELF. LOOP
	JUMPLE	TAC1,STOTAC	;IF TAC1 = 0 THEN NO MATCH
	AOS	(P)		;MAKE IT SKIP RETURN
	JRST	STOTAC		;GO RETURN
;SETNAM SETCRD SETCD1 SETCD2 SETDDT GETNAM GETNA1

;SETNAM, SETCRD, SETDDT, GETNAM

SETNAM:	MOVEM TAC,JOBNAM(J)		;SET JOB NAME FOR SYSTAT
IFN FTSTAT,< PUSHJ P,NAMSTT >
	POPJ P,

;SET CREATION DATE & PROT

SETCRD:	TLZE TAC,400000		;CLEAR & CHECK UNUSED BIT
	JRST SETCD2		;ANY OF THESE MEANS DO IT TO THE UPPER
SETCD1:	MOVEM TAC,JOBCRD(J)
	TDNE TAC,[37,,-1]
	POPJ P,
	PUSHJ P,DSKTM1		;IN DSKSER
	IORM TAC1,JOBCRD(J)
	POPJ P,

SETCD2:	PUSH P,J	;SAVE FOR ACCESS
	LDB J,PSEGN
	JUMPE J,TPOPJ	;EASY IF NO UPPER
	MOVE AC1,TAC	;ELSE SAVE ARG
	PUSHJ P,ACCESS	;AND MAKE SURE THIS IS LEGAL
	JRST TPOPJ
	JRST TPOPJ
	SUB P,[1,,1]	;DON'T NEED THAT JOB # ANY MORE
	MOVE TAC,AC1
	JRST SETCD1


SETDDT:	MOVEM TAC,USRDDT	;ROUTINE TO SET ONE'S DDT STARTING ADDRESS
	POPJ P,			;RETURN TO USER

GETNAM:	JUMPLE TAC,GETNA1	;GET JOBNAME GIVEN JOB NUMBER
	CAIL TAC,JOBN
GETNA1:	MOVE TAC,J
	MOVE TAC,JOBNAM(TAC)
	JRST STOTAC
;WAIT GETLN SPCWAR EIOTM LIOTM

;WAIT, GETLN, SPCWAR (SPWBUT), EIOTM, LIOTM

;WAIT FOR IO TO BECOME INACTIVE ON CHANNEL SPECIFIED BY AC FIELD OF UUO

WAIT:	JUMPE	DDB,IOIERR	;JUMP IF NO CHANNEL IS ASSIGNED HERE.
	JRST	WAIT1		;WAIT TILL INACTIVE BEFORE RETURNING TO USER.

GETLN:	PUSHJ	P,TTYFND		;GET NAME OF TTY
	MOVE	TAC,DEVNAM(DDB)
	JRST	STOTAC


;READ SPACEWAR BUTTONS
SPCWAR:
IFE FTF2,<
	CONI	TV,TAC		;READ SWITCH REGISTER
>;IFE FTF2
	JRST	STOTAC


;EIOTM - ENTER IOT-USER MODE
;LIOTM - LEAVE IOT-USER MODE

EIOTM:	MOVE	TAC,JB2PRV(J)	;GET PASSIVE PRIVS
	TLNN	TAC,LUPPRV
	JRST	UUOERR
	MOVSI	TAC,4000
	IORM	TAC,UUOPC(J)
	POPJ	P,

LIOTM:	MOVSI	TAC,4000
	ANDCAM	TAC,UUOPC(J)
	POPJ	P,
;DATIME DAT2 DAT2A DAT1 DAT3 DAT4 VENTIM

IFE FTF2,<	;Whole page

;FOR A DESCRIPTION OF THE ON-LINE CALENDAR CLOCK SEE SAILON 9

;DATIME SKIP RETURNS IF CLOCK IS OK.  RETURNS IN DAT THE SYSTEM
;FORMAT DATE, RETURNS IN J THE COUNT OF TICKS SINCE MIDNIGHT

IFE FT11CLK,<

↑DATIME:MOVEI TAC1,1000		;TRY ONLY 1000 TIMES
DAT2:	CONI PCLK,TEM		;READ FAST PART.
	DATAI PCLK,TAC		;READ SLOW PART.
	JUMPG TAC,DAT1		;CLOCK IS VALID.
DAT2A:	SOJG TAC1,DAT2		;INVALID, RETRY.
	POPJ P,			;TOO MANY RETRIES, CONSIDER IT SICK.

DAT1:	SUBI TAC,5004		;NORMALIZE CROCK DATA.
	SUB TEM,[2020136700]	;AND FAST PART.
	LDB J,[POINT 4,TEM,9]
	LDB DAT,[POINT 4,TAC,35]
	CAME DAT,J		;DID READINGS GIVE THE SAME MINUTE?
	JRST DAT2A		;NO. GO RETRY.
	TLNE TAC,200000		;YEAR INVALID?
	POPJ P,			;YES. CROCK SICK.
	LDB J,[POINT 4,TAC,19]	;MONTH.
	SUBI J,4
	CAIL J,=12
	POPJ P,
	IMULI J,=31
	MOVEM J,DAT
	LDB J,[POINT 5,TAC,24]
	ADDM J,DAT		;ADD IN DAY.
	LDB TAC1,[POINT 4,TAC,11]
	CAILE TAC1,=7		;AFTER 1979?
	POPJ P,			;YES.  LOOK GUYS, HERE'S ANOTHER BUG!
	IMULI TAC1,=10
	LDB J,[POINT 4,TAC,15]
	CAILE J,9
	POPJ P,			;19WHAT?
	ADD J,TAC1
	CAIGE J,=76		;ITS AFTER 1-JAN-76.
	POPJ P,
	SUBI J,=64		;NORMALIZE TO 1964.
	IMULI J,=12*=31
	ADDM J,DAT		;DAT IS NOW SET UP.
	LDB TAC1,[POINT 5,TAC,29]	;HOUR.
	CAIL TAC1,=24
	POPJ P,
	MOVE J,TAC1
	IMULI J,=60*=60*=60
	ANDI TAC,77		;MINUTES
	CAIL TAC,=60
	POPJ P,
	IMULI TAC,=60*=60
	ADD J,TAC
	LDB TAC,[POINT 6,TEM,15]	;SECONDS.
	CAIL TAC,=60
	POPJ P,
	IMULI TAC,=60
	ADD J,TAC		;ADD INTO RESULT.
	LDB TAC,[POINT 20,TEM,35]
	CAML TAC,[=1000000]	;CHECK MILLISECONDS.
	POPJ P,
	IDIVI TAC,<=1000000/JIFSEC>
	ADD J,TAC
>;IFE FT11CLK
DAT3:	CAMGE DAT,THSDAT	;DON'T GO BACKWARDS
	POPJ P,
	CAME DAT,THSDAT		;USUALLY THE SAME DAY...
	JRST DAT4		;THIS IS DIFFERENT
	CAMGE J,TIME		;DON'T GO BACKWARDS
	POPJ P,			;LOSER.
DAT4:	CAML J,MIDNIT		;LESS THAN AN ENTIRE DAY'S WORTH OF TICKS?
	POPJ P,			;NO. LOSE!
	JRST CPOPJ1

IFKL10,<
↑VENTIM:PUSHJ P,RTIMBS		;READ PDP-11'S TIMEBASE
	SKIPN KLTIME
	SKIPE KLTIME+1
	JRST .+2
	POPJ P,			;NOBODY HOME
	DMOVE TAC,KLTIME	;TAC,TAC1 ← TIMEBASE
	DIV TAC,MIDNIT		;DIVIDE BY JIFFIES PER DAY
	PUSH P,TAC1		;TIME IN JIFFIES
	PUSHJ P,DCTOSD		;DAYCOUNT IN TAC1 TO SYSTEM DATE
	MOVE DAT,TAC		;DAT ← DATE
	POP P,J			;POP TIME INTO J
	JRST DAT3
>;IFKL10
>;IFE FTF2
;LOGIN LOGIN1 LOGIN2 LOGIN3 SETLOG LOGIN4 LOGTAB LOGTOP

;LOGIN UUO.	FOR LOGIN CUSP ONLY.
;	CALL AC,['LOGIN ']
;	AC = -N,,LOC
; 	LOC = LOCATION OF TABLE OF LENGTH N. TABLE HAS LOGIN GOODIES.
;(1-14-72 REWRITTEN BY REG)
; 9/29/78 MRC ALLOW PHANTOM TO SET ITS PPN WITH LOGIN UUO, BUT NOT TO SET PRIVS
;		OR SET JLOG.

LOGIN:	MOVE TAC1,JBTSTS(J)	;TEST JLOG AND JACCT
	TLNE TAC1,JLOG		;SKIP IF ALREADY LOGGED IN
	JRST UUOERR		;LOGGED IN ALREADY.
	TLNN TAC1,JACCT		;SKIP IF LOGIN PROGRAM
	 JRST [	XCTR XR,[MOVE TAC,(TAC)] ;GET PPN WANTED
		CAME TAC,SYSPPN	;FORBID THE MFD
		 CAMN TAC,['  1  2'] ;AND [1,2] AS WELL
		  JRST UUOERR	;LOSER
		MOVEM TAC,PRJPRG(J) ; SET IT
		JRST LOGIN3]	;DON'T LET HER CHANGE HER PRIVS
	HLRO AC1,TAC		;GET -WORD COUNT
	HRR UUO,TAC		;BASE OF DATA TABLE
	MOVE AC2,[-LOGTOP,,LOGTAB]	;SET A DEPOSIT/CONTROL WORD
LOGIN1:	AOJG AC1,LOGIN2		;INCREMENT USER'S COUNT. SKIP IF EXHAUSTED
	XCTR XR,[SKIPA AC3,(UUO)]	;GET DATA FROM USER AND SKIP
LOGIN2:	MOVEI AC3,0		;NO DATA FROM USER. USE ZERO
	MOVEM AC3,@(AC2)	;STORE DATA IN JOB TABLE
	ADDI UUO,1		;PUSH USERS POINTER
	AOBJN AC2,LOGIN1	;LOOP UNTIL WE FILL MONITOR TABLES
	MOVSI TAC1,JLOG
	IORM TAC1,JBTSTS(J)	;SET JLOG BIT IN JBTSTS
	MOVSI TAC1,JACCT	;
	ANDCAM TAC1,JBTSTS(J)	;CLEAR ACCOUNTING BIT
LOGIN3:	SETZM JBTPRV(J)		;NO FREE PRIVS ANY MORE
	SETZM JBTUFD(J)  	;ZERO UFD POINTER FOR NEW PPN
	SETZM DSKPPN(J)  	;INITIALIZE DISK ALIAS PPN
↑SETLOG:			;SET-UP USER TABLES FOR LOGIN AND OTHERS!
	SKIPN JBTJL(J)
	PUSHJ P,PRIBUF

;SPREAD SERVICE LEVEL TO THIS NEW JOB
	HRRZ AC1,PRJPRG(J)	;GET PROGRAMMER NAME
	MOVN TAC,SLNRES		;LOAD -NUMBER OF RESERVATIONS
	JUMPE TAC,CPOPJ		;NO RESERVATIONS.
	HRLZ TAC,TAC		;-SLNRES,,0 IN TAC
LOGIN4:	HRRZ TAC1,SLRES(TAC)	;PROG NAME WHO HAS A RESERVATION
	CAME TAC1,AC1		;MATCH?
	AOBJN TAC,LOGIN4	;NO MATCH: OOPS
	JUMPGE TAC,CPOPJ	;NO MATCH ANYWHERE.
	HLRZ TAC,SLRES(TAC)	;GET HIS RESERVATION AS A RH FRACTION
	MOVEM TAC,JBTGSL(J)	;SET GUARANTEED SERVICE LEVEL
	POPJ P,			;STOW IT.

;TABLE OF TABLES SET BY LOGIN UUO. INCLUDE J AS INDEX REGISTER
;AND STORE @ THRU THIS TABLE.

LOGTAB:	J,,PRJPRG		;USER NAME 
	J,,JB2PRV		;JOB PASSIVE PRIVLEGE BITS
LOGTOP←←.-LOGTAB		;NO. OF TABLES TO BE SET
;PRIBUF

; ROUTINE TO SET UP SCHEDULER DATA STRUCTURE FOR A JOB

↑PRIBUF:MOVEI AC3,JLLENGTH
	PUSHJ P,FSGET
	POPJ P,			;IF YOU LOSE, YOU LOSE
	MOVEM AC1,JBTJL(J)
	SETZM JBTJLH(J)
	SETZM JBTGSL(J)
	HRL AC2,AC1
	HRRI AC2,1(AC1)
	SETZM (AC1)
	BLT AC2,JLLENGTH-1(AC1)
	POPJ P,
;SETPRV STPRV0 STPRV1 GETPRV FNCTAB MAXFNC SETPPV PRVIOR PRVIO1 PRVIO2 PRVACM

;SETPRV, GETPRV
;	SETPRV	SET JBTPRV	JOB PRIVILEGE BITS
;	CALL AC,['SETPRV']
; JBTPRV WILL BE SET TO CONTENTS OF AC IF 
; EITHER PRIPRV IS SET IN CURRENT JBTPRV OR JBTSTS INDICATES JACCT SET
; RETURN CONTENTS OF JBTPRV IN AC.
; IF AC REQUESTS FEWER PRIVILEGES THAN ARE NOW ALLOWED, THEN
; THE REQUEST WILL BE SUCESSFUL
; IF C(AC) = -1 THEN ONLY RETURN CURRENT CONTENTS OF JBTPRV

SETPRV:	CAME	TAC,[-1]	;SKIP UNLESS SPECIAL CODE
	PUSHJ P,STPRV0		;BH 8/19/80 Subroutinize this for PRVIOR
	JRST	STPRV1		;JUST GIVE HIM THE CURRENT CONTENTS

STPRV0:
IFE FTF2,<
	MOVE TAC1,JBTPRV(J)
	IOR TAC1,JB2PRV(J)
	TDNE TAC1,[NXPRIV]
	JRST STPRV2
>;IFE FTF2
	MOVSI TAC1,AAOPRV
	TDNN TAC1,JBTPRV(J)
	TLZ TAC,AAOPRV		;DOESN'T HAVE AAO ACTIVE, SO CAN'T GET IT
	MOVE TAC1,JBTSTS(J)
	MOVE AC1,JB2PRV(J)	;ALLOW PASSIVE PRIVS TO BE ACTIVATED.
	IOR AC1,JBTPRV(J)	;IF HE ALREADY HAS IT, HE CAN KEEP IT
	IOR AC1,[FREPRV]	;ALSO ALLOW ANY OF THESE.
	TLNN TAC1,JACCT		;ACCOUNTING PROG CAN HAVE ANY PRIVS
	AND TAC,AC1		;ONLY ALLOW TURNING ON FROM PASSIVE AND FREE PRIVS
	MOVE AC1,TAC		;Make copy of privs we'll allow, for passive set
	TDZ TAC,[ENPASS]	;Turn off privs that only are passive
	MOVEM TAC,JBTPRV(J)	;SET NEW active PRIVS
	AND AC1,[ENPASS]	;Turn off privs that only are active
	IORM AC1,JB2PRV(J)	;Set new passive privs
	POPJ P,

STPRV1:	MOVE TAC,JBTPRV(J)	;GET ACTIVE PRIVS
	TLZ TAC,LUPPRV
	MOVSI TAC1,LUPPRV
	TDNE TAC1,JB2PRV(J)
	TLO TAC,LUPPRV
	JRST STOTAC		;RETURN THEM

;GET PRIVILEGES FOR JOB
;CALLING SEQUENCE:
;	MOVE AC,[FUNC CODE,,JOB #]
;	GETPRV AC,
;	<ALWAYS RETURN HERE>
;CODE 0 ACTIVE PRIVILEGES
;CODE 1 PASSIVE PRIVILEGES
;CODE 2	ACTIVE+PASSIVE AS PER ENPASS.  INVERSE OF SETPRV SORT OF

GETPRV:	HLRZ AC1,TAC		;GET FUNCTION CODE
	CAIL AC1,MAXFNC		;LEGAL FUNCTION CODE
	JRST UUOERR		;NO, FLUSH
	HRRZ TAC,TAC		;GET JUST JOB #
	CAIGE TAC,JOBN		;JOB # TO LARGE?
	JUMPN TAC,.+2		;OR 0?
	MOVE TAC,J		;YES, USE CURRENT JOB
	XCT FNCTAB(AC1)		;DO FUNCTION
	JRST STOTAC		;RETURN ANSWER

FNCTAB:	MOVE TAC,JBTPRV(TAC)	;ACTIVE PRIVILEGES
	MOVE TAC,JB2PRV(TAC)	;PASSIVE PRIVILEGES
	JRST PRVIO2		;COMBINED PRIV WORD AS PER ENPASS
MAXFNC←←.-FNCTAB

SETPPV:	MOVSI AC1,AAOPRV	;SET PASSIVE PRIVILEGES UUO
	TDNN AC1,JBTPRV(J)	;REQUIRES AAO PRIV IN ACTIVE PRIVS
	JRST UUOERR		;OTHERWISE ERROR
	MOVEM TAC,JB2PRV(J)	;DO THE HAIR AT USER LEVEL!
	POPJ P,

;TURN ON PRIVILEGES
;	PRVIOR AC,
;TURNS SELECTED PRIVS ON IN ACTIVE OR PASSIVE AS APPROPRIATE
;ACTUALLY MAKES AN ARGUMENT TO SETPRV AND CALLS IT
;SETPRV DOES THE LEGALITY CHECKING.

PRVIOR:	MOVE TAC1,TAC		;TAC WILL BE ACTIVE, TAC1 PASSIVE
	IOR TAC,JBTPRV(J)
	IOR TAC1,JB2PRV(J)
	TDZ TAC,[ENPASS]
	AND TAC1,[ENPASS]
	IOR TAC,TAC1		;PUT 'EM BACK TOGETHER
	PUSHJ P,STPRV0		;TAKE IT AWAY
PRVIO1:	MOVE TAC,J		;SO GETPRV CAN JUMP IN HERE
PRVIO2:	MOVE TAC1,JB2PRV(TAC)	;PASIVE IN TAC1
	MOVE TAC,JBTPRV(TAC)	;ACTIVE IN TAC
	TDZ TAC,[ENPASS]
	AND TAC1,[ENPASS]
	IOR TAC,TAC1
	JRST STOTAC

;TURN OFF PRIVILEGES
;	PRVACM AC,
;TURNS OFF SELECTED PRIVILEGES IN ACTIVE OR PASSIVE
;NO LEGALITY CHECKING, CAN ALWAYS TURN OFF ANYTHING

PRVACM:	MOVE TAC1,TAC		;TAC WILL BE ACTIVE, TAC1 PASSIVE
	TDZ TAC,[ENPASS]
	AND TAC1,[ENPASS]
	ANDCAM TAC,JBTPRV(J)
	ANDCAM TAC1,JB2PRV(J)
	JRST PRVIO1		;STORE COMBINED PRIVS
;RLEVEL RLEV1 RLEV2 GETLV1 SPRSSL SPRSS0 SPRSS1 SPRSS2 SETLVL SETRES SETAL1 SETAL0

;RLEVEL,  SLEVEL, SETRES   - SERVICE LEVEL UUOS

;GET A PPN'S SERVICE LEVEL RESERVATION.
;CALLING
;	MOVE AC,[SIXBIT /PPN/]		;ONLY THE PROG NAME IS USED
;	CALL AC,[SIXBIT /RLEVEL/]
;	RETURN HERE ALWAYS, AC = <SL RESERVATION IN %>,,PRG NAME,
;		IF RESERVATION ≠ 0, OTHERWISE AC = 0,,0.


IFE FTPRIQ,<
RLEVEL:	JRST RTZERO
>;IFE FTPRIQ
IFN FTPRIQ,<
RLEVEL:	HRRZ	AC1,TAC		;GET PROGRAMMER NAME
	MOVN	TAC,SLNRES	;LOAD -NUMBER OF RESERVATIONS
	JUMPE	TAC,RTZERO	;NO RESERVATIONS: RETURN ZERO
	HRLZ	TAC,TAC		;-SLNRES,,0 IN TAC
RLEV1:	HRRZ	AC2,SLRES(TAC)	;PROG NAME WHO HAS A RESERVATION
	CAME	AC2,AC1		;MATCH?
	AOBJN	TAC,RLEV1	;NO MATCH: LOOP
	JUMPGE	TAC,RTZERO	;JUMP IF NO MATCH.
RLEV2:	HLRZ	TAC,SLRES(TAC)	;GET HIS RESERVATION AS A RH FRACTION
GETLV1:	IMULI	TAC,=100	;MAKE IT LEFT HALF PERCENT
	ADDI	TAC,400000	;ROUND IT. (LIKE YOU DID IN CLKSER)
	HRR	TAC,AC1		;JOB NUMBER (OR PRG NAME) TO TAC
	JRST	STOTAC		;STOW IT.


;REG 12-5-72
SPRSSL:	SETZM	JBTGSL+1	;SPREAD SERVICE LEVEL TO USERS WITH RESERVATIONS.
	MOVE	TAC,[JBTGSL+1,,JBTGSL+2]	
	BLT	TAC,JBTGSL+JOBN-1	;FIRST ZERO ALL LEVELS.
	SKIPLE	AC2,SLNRES	;GET THE NUMBER OF RESERVATIONS
	CAILE	AC2,SLRMAX	;SKIP IF REASONABLE NUMBER.
	POPJ	P,		;RETURN QUICK IF NONE.
SPRSS0:	HRRZ	TAC1,SLRES-1(AC2)
	MOVE	AC1,JOBNM1	;LOOK THROUGH ALL THE JOBS
SPRSS1:	HRRZ	TAC,PRJPRG(AC1)
	CAIE	TAC1,(TAC)
	JRST	SPRSS2
	HLRZ	TAC,SLRES-1(AC2)
	MOVEM	TAC,JBTGSL(AC1)
SPRSS2:	SOJG	AC1,SPRSS1
	SOJG	AC2,SPRSS0
	POPJ	P,
>;IFN FTPRIQ

;SET BELOW IS DISABLED!
;GET OR SET A JOBS SERVICE LEVEL.
;CALLING
;	MOVE AC,[XWD %SLEVEL,JOB # ]
;	CALL AC,[SIXBIT/SLEVEL/]
;	RETURN HERE ALWAYS
;IF %SLEVEL<0 RETURN  CURRENT %SL,,JOB NUMBER
;OTHERWISE SET SLEVEL OF JOB TO %SLEVEL
; SET IS ALLOWED ONLY IF JOB NUMBER GIVEN IS 0 OR USER'S JOB #
; IF SET COMMAND FAILS, USER'S AC WILL BE SET TO 
; - % AVAILABLE 
;ALSO SET IT FOR HIS OTHER JOBS.
;IF JOB # = 0 USE THIS JOB
;IF JOB # = -1, AND SERVICE LEVEL MONITOR IS THE USER,
;	THEN RESET THE SL RESERVATION TABLE.


IFN FTPRIQ,<
SETLVL:	HRRZ	AC1,TAC		;GET JOB NUMBER
	CAIL	AC1,JOBN	;LEGAL JOB?
	JRST	SETRES		;NO. MAYBE SL MONITOR CHANGING RESERVATIONS
	JUMPG	AC1,.+2		;SKIP UNLESS ZERO
	MOVE	AC1,J		;ZERO MEANS THIS JOB.

	PUSH	P,AC1		;THESE 5 INSTRUCTIONS: REG 12-5-72
	PUSHJ	P,SPRSSL	;SPREAD ALL SERVICE LEVELS
	POP	P,AC1
	HRRZ	TAC,JBTGSL(AC1)
	JRST	GETLV1
	
;;;	WE ARRIVE HERE IF A NEGATIVE JOB NUMBER IS SPECIFIED.
;;;	THIS IS ALWAYS ILLEGAL UNLESS THE JOB HAS THE SSL PRIVILEGE,
;;;	IN WHICH CASE THE CURRENT SLRESERVATION TABLE IS BEING RESET,
;;;	AND THE CALLING SEQUENCE WAS:
;;;	
;;;		MOVE AC,[XWD [ XWD <0,1, OR 2>,N
;;;			      <1ST TABLE ENTRY>
;;;			      <2ND TABLE ENTRY>
;;;				    ...
;;;			      <NTH TABLE ENTRY>],-1]
;;;		CALL AC,[SIXBIT /SLEVEL/]
;;;		FAILURE RETURN (N TOO LARGE, TOTAL SL TOO MUCH, ETC.)
;;;		SUCCESS RETURN
>;IFN FTPRIQ
IFE FTPRIQ,<
SETLVL:	HRRZ	AC1,TAC		;GET JOB NUMBER
>;IFE FTPRIQ
SETRES:	CAIE	AC1,-1
	JRST	RTZERO
	MOVE	TAC1,JBTPRV(J)	;GET THE USER'S PRIV BITS
	TLNN	TAC1,SSLPRV	;SKIP IF HE HAS THE PRIVILEGE
	JRST	RTZERO		;RETURN ZERO.

;;;	THIS IS THE CODE THAT READS A NEW SL RESERVATION TABLE FROM
;;;	GSLMON AND GIVES THE RESERVED AMOUNTS TO ANYBODY CURRENTLY
;;;	LOGGED IN, DECREASING THE SL OF SCROUNGERS IF NECESSARY.

IFE FTPRIQ,<
	JRST CPOPJ1		;always give skip return
>;IFE FTPRIQ
IFN FTPRIQ,<
	XCTR	XR,[HLRZ TAC1,(UUO)]	;TAC1 ← USER REL. ADDR. OF TABLE INFO.

IFN FTSLCORE,<
	XCTR	XR,[HLRZ AC2,(TAC1)]	;AC2 ← CORE COST OF SL = 0,1 OR 2
	CAIL	AC2,3			;IS 0 ≤ (TAC) ≤ 2  ?
	MOVEI	AC2,1			;NO, MAKE IT 1.
	MOVEM	AC2,SLCOST		;STORE IN SL DATA AREA
>;IFN FTSLCORE

	XCTR	XR,[HRRZ TAC,(TAC1)]	;TAC ← (# OF RESERVATIONS)
	CAILE	TAC,SLRMAX		;TOO MANY RESERVATIONS?
	JRST	SETAL0			;YES, FAILURE EXIT
	MOVSI	AC2,(TAC1)		;SOURCE OF BLT (USER-RELATIVE)
	HRRI	AC2,SLNRES		;DESTINATION OF BLT
	XCTR	XBLTR,[BLT AC2,SLNRES(TAC)];BLT NEW RES TABLE INTO SYSTEM
	HRRZS	SLNRES			;ZERO OUT THE 0,1,OR 2 IN LEFT HALF,

	MOVEI	TAC1,0			;ADD UP NEW RESERVATIONS...
	HLRZ	AC1,SLNRES(TAC)
	ADD	TAC1,AC1
	SOJG	TAC,.-2

	CAIG	TAC1,<XWD MAXLEV,0>/=100+SLRMAX	;TOO MUCH RESERVED SL?
SETAL1:	AOSA	(P)		;NOT TOO MUCH. SET SKIP RETURN
SETAL0:	SETZM	SLNRES		;TOO MUCH. CLEAR TABLE.
	JRST	SPRSSL		;SPREAD NEW TABLE
>;IFN FTPRIQ
;LOGOUT

;LOGOUT UUO

LOGOUT:	MOVSI TAC,JACCT		;IS HE REALLY THE LOGOUT ROUTINE?
	TDNN TAC,JBTSTS(J)	;SEE IF THE ACCOUNTING BIT IS ON
	JRST UUOERR		;NO, ERROR
	JRST JOBKL		;ALL OK. LOG HIM OUT.
;RUNUUO

;SWAP UUO, RUN UUO
; FORMAT AS FOLLOWS . . .
;	MOVE AC,[E,,F]
;	SWAP AC,

;E:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXTENSION/ + MODE BITS
;	(CORESIZE - IN K),,(STARTING ADDRESS)
;	SIXBIT /PROJ-PROG NUMBER/
; IF STARTING ADDRESS IS ZERO, C(JOBSA) WILL BE USED
; IF E=0, NO SAVE WILL BE DONE

;F:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXTENSION/ + MODE BITS
;	(CORESIZE - IN K),,(STARTING ADDRESS INCREMENT)
;	SIXBIT /PROJ-PROG NUMBER/
; IF F=0, NO RUN WILL BE DONE. IF E=F=0, THE UUO IS A NO-OP
; MODE BIT 35 = DO NOT START JOB. JUST GET CORE IMAGE.
; MODE BIT 34 = MAKE STARTING ADDRESS ABSOLUTE, NOT AN INCREMENT
; MODE BIT 33 = LOGIN NEW JOB AND RUN THIS THERE!
; MODE BIT 32 = DON'T SET JLOG

; RUN UUO INCLUDED FOR COMPATABILITY WITH DEC SYSTEMS:
;	MOVE AC,[<STARTING INCREMENT>,,G]
;	RUN AC,
;
;G:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXT/
;	0
;	SIXBIT /PROJ-PROG NUMBER/
;	0,,<DESIRED CONTENTS OF JOBREL>

RUNUUO:	PUSHJ P,SVUACS
	HLRM TAC,SAVSAI(J)		;SET START INCREMENT
	XCTR XR,[HRRZ TAC1,5(TAC)]
	XCTR XW,[MOVEM TAC1,JOBCOR]	;SET CORE SIZE
	HRROI AC1,(TAC)			;COPY PNTR WITH "RUN" FLAG
	JRST RUNUU2			;NOW ENTER SWAP UUO
;SYSRJB SYSSJ1 SYSRJ1 RUNUU2 PRUNJB SYSRXT SYSRX2

; SWAP UUO

SYSRJB:	PUSHJ P,INTTST			;MAKE SURE NO SPACEWAR, NO INTLEVEL
	XCTR XR,[SKIPN AC1,(UCHN)]	;PICK UP ADDRESSES OF TABLES, IF ANY
	POPJ P,				;NONE, NO-OP
	XCTR XW,[MOVEM AC1,JOBFDV]	;SAVE TABLE ADDRESS OF GET SIDE
	MOVE AC1,UUOPC(J)		;SAVE RETURN ADDRESS
	XCTR XW,[MOVEM AC1,JOBOPC]
	PUSHJ P,SVUACS			;SAVE USER'S ACS
	XCTR XR,[HLRZ AC1,JOBFDV]	;PICK UP 'SAVE' TABLE ADDRESS
	JUMPE AC1,SYSRJ1		;IF ZERO OMIT THE SAVE.
	PUSHJ P,SYSRS			;GET SAVE-ARGUMENTS FROM USER
	JSP TAC1,SG1			;OPEN DEVICE. DOES SUPERFLUOUS LOOKUP
;SG1 CLOBBERS ACS (P) BECAUSE IT THINKS IT IS BEING RUN AS A "MONITOR JOB"
;DO NOT CLOBBER ANY ACS BETWEEN SG1 AND  SAVJBB
	JFCL
	PUSH P,AC1
	XCTR XR,[MOVE AC1,JOBOPC]	;GET UUO RETURN ADDRESS
	MOVEM AC1,UUOPC(J)		;AND RESTORE IT IN CASE OF ADDRESS CHECK
	HRRZ AC1,SAVSAI(J)		;PICK UP NEW STARTING ADDRESS
	JUMPE AC1,SYSSJ1		;JUMP IF THERE WAS NONE
	XCTR XR,[SKIP (AC1)]		;TEST TO BE SURE ADDRESS IS LEGAL
	XCTR XRW,[HRRM AC1,JOBSA]	;STUFF NEW STARTING ADDRESS IN CORE
SYSSJ1:	XCTR XW,[SETZM NEWCOR]		;ASSUME SAVE, NOT SSAVE.
	XCTR XR,[MOVE AC1,INCWRD]	;FETCH SAVE-SIDE MODE BITS
	TRNE AC1,1			;SSAVE?
	XCTR XW,[SETOM NEWCOR]		;SET FLAG FOR SSAVE
	POP P,AC1
	PUSHJ P,SAVJBB			;DO ACTUAL SAVE
	PUSHJ P,RSUACX			;RESTORE USER'S ACS IN CASE ARGS ARE THERE
SYSRJ1:	XCTR XR,[HRRZ AC1,JOBFDV]	;GET 'RUN' TABLE ADDRESS BACK
	JUMPE AC1,SYSRXT		;IF ZERO, EXIT GRACEFULLY
	XCTR XR,[MOVE TAC1,2(AC1)]	;GET MODE BITS FIRST!
	TRNE TAC1,4			;TEST FOR PHANTOM STARTUP.
	JRST PHANTOM			;YES!
RUNUU2:	PUSHJ P,SYSRS			;(HERE FROM RUN UUO)  GET RUN-SIDE ARGS
PRUNJB:	JSP TAC1,SG1			;ASSIGN DEVICE, DO LOOKUP, AND RESET PDL
	JRST NOFILE			;NO FILE?
	PUSHJ P,GETJB			;READ JOB IN
	MOVSI AC1,USRMOD		;MAKE SURE HE GETS INTO USER MODE
	XCTR XR,[HRR AC1,JOBSA]		;PICK UP STARTING ADDRESS
	XCTR XR,[MOVE AC2,INCWRD]	;PICK UP OUR MODE BITS AGAIN
	PUSH P,AC1			;PUT THAT ADDRESS ON THE STACK
	MOVE J,JOB			;PICK UP JOB NUMBER
	TRNE AC2,2			;IF BIT 34 ON, INHIBIT ADDING IN HIS STARTING ADDRESS
	SKIPA AC1,SAVSAI(J)		;INSTEAD, PICK UP INCREMENT AND USE IT!
	ADD AC1,SAVSAI(J)		;PICK UP STARTING ADDRESS INCREMENT
	XCTR XR,[PUSH P,JOBOPC]		;GET UUO RETURN ADDRESS
	POP P,UUOPC(J)			;AND RESOTRE IT IN CASE OF ADDRESS CHECK
	XCTR XR,[SKIP (AC1)]		;SEE IF ADDRESS IS IN BOUNDS
	HRRM AC1,(P)			;UPDATE STARTING ADDRESS
	PUSH P,AC2			;SAVE MODE BITS
	PUSHJ P,RSUACS			;RESTORE USER'S ACCUMULATORS
	POP P,AC2			;MODE BITS
	POP P,UUOPC(J)			;"UUO RETURN ADDRESS" 
	TRNN AC2,1			;IF MODE BIT 35 IS ON, DON'T START JOB
	JRST USRXIT			;START USER BY EXITING UUOCON
	JRST GETJ1			;EXIT PRINTING "JOB SETUP" MESSAGE

SYSRXT:	PUSHJ P,RSUACS			;RESTORE USER ACS
SYSRX2:	XCTR XR,[MOVE TAC,JOBOPC]	;GET UUO RETURN ADDRESS
	MOVEM TAC,UUOPC(J)		;AND RETURN TO IT!
	JRST USRXIT			;MAKE IT LOOK LIKE A UUO EXIT (WHICH IT IS)
;SYSRS SYSRS1 SVUACS SVUA1 RSUACS RSUACX

;SYSRS, SVUACS, RSUACS
; ROUTINE TO PICK UP BITS OF USER'S GOODIE TABLE
; IF LH OF AC1 IS -1 THEN WE'RE HERE FROM THE RUN UUO.
;THIS CODE'S BEEN REORGANIZED TO PERMIT ARGUMENT BLOCK TO BE ANYWHERE IN ACS.

SYSRS:	XCTR XR,[MOVE TAC1,4(AC1)]	;START WITH PPN
	MOVEM TAC1,JOBPPN(J)
	XCTR XR,[PUSH P,(AC1)]		;SAVE DEVICE NAME
	XCTR XR,[PUSH P,1(AC1)]		;SAVE FILE NAME
	XCTR XR,[PUSH P,2(AC1)]		;SAVE EXTENSION,,MODE BITS
	JUMPL AC1,SYSRS1		;JUMP IF RUN UUO
	XCTR XR,[MOVE TAC1,3(AC1)]	;PICK UP CORE SIZE,,STARTING INCREMENT
	HRRM TAC1,SAVSAI(J)		;STORE STARTING INCREMENT
	HLRZ TAC1,TAC1			;GET CORE SIZE IN K
	LSH TAC1,=10			;CONVERT TO WORD COUNT
	JUMPE TAC1,.+2			;UNLESS, OF COURSE, HE ASKED FOR NONE
	SUBI TAC1,1
	XCTR XW,[MOVEM TAC1,JOBCOR]
SYSRS1:	POP P,TAC1			;GET EXTENSION AND MODE BITS
	TLNN TAC1,-1			;SKIP IF EXTENSION SPECIFIED.
	HRLI TAC1,'DMP'			;HE REALLY WANTS .DMP
	XCTR XW,[HLLZM TAC1,FILEXT]	;STORE FILE EXTENSION
	XCTR XW,[HRRZM TAC1,INCWRD]	;AND SAVE MODE BITS
	POP P,TAC1			;FILE NAME
	XCTR XW,[MOVEM TAC1,FILNAM]	;FOR LOOKUP/ENTER IN SAVGET
	MOVEM TAC1,JOBNAM(J)		;THIS IS NEW JOB NAME TOO
IFN FTSTAT,<PUSHJ P,NAMSTT>
	XCTR XW,[POP P,DEVWRD]		;DEVICE NAME FOR SAVJOB
	POPJ P,


; ROUTINE TO SAVE ACCUMULATORS OVER RUNJOB UUO

SVUACS:	HLRZ AC1,SAVSAI(J)	;ANY FREE STORAGE HERE ALREADY?
	JUMPN AC1,SVUA1		;YES
	MOVEI AC3,20		;GET A 20-WORD BLOCK OF FREE STORAGE
	PUSHJ P,UFSGET		;GET FREE STORAGE AT UUO LEVEL
	HRLM AC1,SAVSAI(J)	;SAVE THE POINTER
SVUA1:	HRLI AC1,0		;BLT USER 0-17 INTO THE SYSTEM
	HRR AC2,AC1
	XCTR XBLTR,[BLT AC1,17(AC2)]	;RELOCATE "FROM OF BLT"
	POPJ P,

RSUACS:	PUSHJ P,RSUACX		;RESTORE USER ACS THEN FLUSH FS. BLOCK
	HLRZ AC1,SAVSAI(J)	;GET ADDRESS OF BLOCK.
	SETZM SAVSAI(J)		;ZERO OUT FS POINTER
	JUMPN AC1,FSGIVE
	POPJ P,

RSUACX:	HLLZ AC1,SAVSAI(J)	;PICK UP FREE STORAGE POINTER,,0
	JUMPE AC1,CPOPJ		;NOBODY HOME
	XCTR XBLTW,[BLT AC1,17]	;STORE IN USER SPACE. (RELOCATE "TO OF BLT")
	POPJ P,			;RESTORE ACS WITHOUT FLUSHING FS BLOCK
;PHANTO PHWIN PHLOSE PHLOS1

; SWAP UUO - LOG IN NEW JOB AND RUN THIS ON IT - PHANTOM STARTUP

PHANTO:	HLLZ TAC,SAVSAI(J)		;FREE STORAGE ADDRESS,,0
	XCTR XBLTW,[BLT TAC,17]		;COPY OLD ACS BACK TO USER SPACE.
	XCTR XR,[SKIPN TAC,5(AC1)]	;PRJPRG
	MOVE TAC,PRJPRG(J)		;USE CURRENT PPN
	CAMN TAC,PRJPRG(J)		;IS HE DOING IT TO HIMSELF?
	JRST PHWIN			;YES
	CAMN TAC,SYSPPN			;1,1
	JRST PHLOS1			;LOSE.
PHWIN:	PUSH P,J			;SAVE PRESENT JOB NUMBER
	PUSHJ P,INIJOB			;INITIALIZE A NEW JOB
	JRST PHLOSE			;NO JOBS TO BE HAD
	JFCL	
	MOVSI TAC,JNA
	IORM TAC,JBTSTS(J)
	TLNN TAC1,-1			;WAS ANY EXTENSION SPECIFIED?
	HRLI TAC1,'DMP'			;NO. USE 'DMP'
	MOVEM TAC1,JOBLOG(J)		;SAVE MODE BITS AND EXTENSION
	MOVSI TAC,JLOG
	TRNN TAC1,10			;THIS BIT SAYS DON'T SET JLOG
	IORM TAC,JBTSTS(J)
	SETZM JBTUFD(J)			;FLUSH THIS OR ELSE!
	SETZM JBTKCJ(J)			;INITIALIZE KILO CORE SECONDS
	XCTR XR,[MOVE TAC1,(AC1)]	;DEVICE
	MOVEM TAC1,JOBDEV(J)
	XCTR XR,[MOVE TAC1,1(AC1)]	;FILENAME
	MOVEM TAC1,JOBNAM(J)
IFN FTSTAT,< PUSHJ P,NAMSTT >
	XCTR XR,[MOVE TAC1,4(AC1)]	;LOC OF FILE
	MOVEM TAC1,JOBPPN(J)
	MOVE TAC,(P)			;GET OUR J TEMPORARILY
	XCTR XR,[SKIPN 5(AC1)]		;EXPLICIT PPN GIVEN?
	SKIPA TAC1,DSKPPN(TAC)		;NO, USE OUR ALIAS
	MOVEI TAC1,0			;YES, NO ALIAS
	MOVEM TAC1,DSKPPN(J)
	XCTR XR,[SKIPN TAC1,5(AC1)]	;PPN
	MOVE TAC1,PRJPRG(TAC)		;NONE, USE CURRENT
	MOVEM TAC1,PRJPRG(J)
	CAME TAC1,PRJPRG(TAC)		;SAME AS CALLER?
	TDZA TAC1,TAC1			;NO. ZERO PRIVILEGES AND SKIP.
	MOVE TAC1,JB2PRV(TAC)		;SAME PPN. COPY OUR PRIVILEGES TO NEW GUY.
	PUSH P,TAC1			;SAVE PRIV WORD FOR NEW GUY.
	MOVSI TAC1,LUPPRV
	TDNE TAC1,JB2PRV(TAC)		;SKIP IF CALLER DOESN'T HAVE LUPPRV
	IORM TAC1,(P)			;COPY CALLER'S LUPPRV TO NEW GUY.
	POP P,JB2PRV(J)			;NEW GUY'S PRIVS. (PASSIVE)
	MOVE TAC1,PRJPRG(TAC)		;GET OUR PPN
	CAME TAC1,PRJPRG(J)		;SAME AS HIS?
	TDZA TAC1,TAC1			;NO, NO PRIVILEGES
	MOVE TAC1,JBTPRV(TAC)		;ALSO ACTIVE PRIVILEGES
	MOVEM TAC1,JBTPRV(J)
	MOVSI TAC1,AAOPRV		;NEVER GIVE PHANTOM AAO!
	ANDCAM TAC1,JBTPRV(J)		;at least not in active privs
;;OK to pass it along as passive, after ACCESS cmd on main job.
;;	ANDCAM TAC1,JB2PRV(J)
	XCTR XR,[MOVS TAC1,3(AC1)]	;GET S.A.,,CORE SIZE
	HRRZM TAC1,JOBCRD(J)		;PASS ON CORE SIZE
	MOVE TAC,(P)			;CALLERS JOB #
	HLR TAC1,SAVSAI(TAC)
	MOVSM TAC1,SAVSAI(J)		;GIVE AC BLK AND S.A. TO NEW JOB
	SETZM SAVSAI(TAC)		;NO LONGER BELONGS TO CALLER
	ADDI TAC1,(UCHN)
	MOVEM TAC,(TAC1)		;CALLERS JOB # TO NEW JOB (IN SAME AC)
	XCTR XW,[MOVEM J,(UCHN)]	;NEW JOB # TO CALLER
	PUSHJ P,DELBTT
	POP P,J
	JRST SYSRX2			;DON'T BOTHER LOOKING FOR ACS

PHLOSE:	POP P,J
PHLOS1:	PUSHJ P,RSUACS			;RESTORE ACS.
	XCTR XW,[SETZM (UCHN)]		;FLAG FAILURE BY RETURNING ZERO
	JRST SYSRX2
;PNAME USTAT

;PNAME, USTAT

; UUO TO GET THE PHYSICAL NAME OF A DEVICE
; PUT THE SIXBIT OF THE DEVICE LOGICAL NAME IN AN AC
; DO A PNAME AC,
; AND THE ROUTINE SKIPS UPON SUCCESS (IE, IF DEVICE NAME EXISTS)
; AND RETURNS PHYSICAL NAME IN THAT AC

PNAME:	PUSHJ P,FNDDDB		;SEARCH FOR DEVICE NAME (OR CHANNEL #)
	POPJ P,			;FAILURE
	MOVE TAC,DEVNAM(DDB)	;PICK UP PHYSICAL NAME
	XCTR XW,[MOVEM TAC,(UCHN)]
	JRST CPOPJ1

; GET A JOB'S JOB STATUS WORD
; CALLING . . .
;	MOVE AC,<JOB NUMBER IN QUESTION>
;	JBTSTS AC,
; RETURNS JOB STATUS WORD IN AC

USTAT:	JUMPG TAC,.+2		;POSITIVE JOB NUMBER?
	MOVE TAC,J		;LESS OR EQUAL TO ZERO MEANS OWN JOB
	CAIL TAC,JOBN		;MUST BE LESS THAN MAXIMUM TOO
	JRST UUOERR		;OR ELSE, ERROR
	MOVE TAC,JBTSTS(TAC)	;GET STATUS WORD
	JRST STOTAC		;AND GIVE IT TO HIM
;TTYIOS TTYIO1 TTYIO5 TTYIO2 TTYIO4 TTYIO3

;TTYIOS,   GET A TELETYPE'S DEVIOS
; CALLING . . .
;	MOVE AC,<JOB NUMBER WHOSE TTY IOS YOU WANT>
;	TTYIOS AC,

TTYIOS:	JUMPLE TAC,TTYIO3		;TRY NAME IF ILLEGAL NUMBER
	CAIL TAC,JOBN
	JRST TTYIO3			;ILLEGAL AS A JOB NUMBER, TRY AS A DEV NAME.
	HLRZ DDB,DEVLST
TTYIO1:	HLRZ TAC1,DEVNAM(DDB)		;IS THIS A TELETYPE?
	CAIE TAC1,'TTY'
	JRST TTYIO2			;NO. KEEP LOOKING.
	LDB TAC1,PJOBN			;YES, DOES THE JOB NUMBER MATCH?
	CAIE TAC1,(TAC)
	JRST TTYIO2			;NO, SCAN SOME MORE
TTYIO5:	MOVE TAC,@DEVSPT(DDB)		;YES, PICK UP HIS IOS
	JRST STOTAC			;AND GIVE IT TO HIM

TTYIO2:	HLRZ DDB,DEVSER(DDB)		;PICK UP NEXT DEVICE DATA BLOCK ADDRESS
	JUMPN DDB,TTYIO1		;AND GO BACK IF NOT END OF LIST
TTYIO4:	MOVNI TAC,1			; IF END OF LIST, GIVE HIM A -1 TO CHEW ON
	JRST STOTAC

TTYIO3:	CAMLE TAC,[-20]			;BH 1/25/81 IS THIS NEGATIVE CHANNEL #?
	JRST TTYIO6			;YES, GIVE THAT CHANNEL'S IOS
	PUSHJ P,DEVSRC			;TRY SEARCHING FOR THIS SIXBIT NAME.
	JRST TTYIO4			;LOSE.
	JRST TTYIO5			;WIN.

TTYIO6:	MOVNS TAC			;BH 1/25/81 GET POSITIVE CHANNEL #
	CAMG TAC,USRHCU			;DOES THIS CHANNEL EXIST?
	SKIPN DDB,USRJDA(TAC)		;YES, GET DDB ADDRESS
	JRST TTYIO4			;NO, LOSE
	JRST TTYIO5			;RETURN IOS
;WAKEME WAKEM1 WAKEM3 WAKEM2 WHOAMI SPCJBS NSPJBS

COMMENT $

CALL BY--
	MOVE	AC,<ADDRESS OF 3 WORD BLOCK>
	CALL	AC,['WAKEME']
	<ERROR -- JOB NAMED WAS NOT IN BATMAN AND ROBIN, ELSE MAINTMODE SET>


BLOCK CONTAINS
	JOBNAME
	PPN
	DATA

IF JOBNAME AND PPN ARE FOUND IN BATMAN AND ROBIN THEN 
SET ALFRED TO DATA.  DATA IS INTERPRETED AS FOLLOWS
	<0 MEANS NEVER START THIS
	=0 MEANS KEEP THIS JOB RUNNING
	>0 DATA IS INTERPRETED AS 
		DATE,,TIME IN MINUTES 
	WHEN TO START THIS AGAIN.

ALFRED IS ZEROED AT SYSINI, SO ALL JOBS NAMED IN BATMAN WILL
BE STARTED AT RELOADS AND RESTARTS

$

WAKEME:	SKIPE	MAINTMODE		;SKIP IF NORMAL MODE
	POPJ	P,			;ERROR RETURN IF MAINTMODE
	XCTR	XR,[MOVE AC1,(UCHN)]	;GET USER'S POINTER
	XCTR	XR,[MOVE AC2,(AC1)]	;GET JOBNAME
	XCTR	XR,[MOVE AC3,1(AC1)]	;GET PPN
	MOVSI	TAC,-BATLEN		;GET SIZE OF BATMAN
WAKEM1:	CAMN	AC2,BATMAN(TAC)		;LOOK IN TABLE
	CAME	AC3,ROBIN(TAC)		;SAME AS TABLE?
	JRST	WAKEM2			;NO
	XCTR	XR,[SKIPGE AC3,2(AC1)]	;GET DATA FOR ALFRED
	JRST	WAKEM3			;RUN NEVER.
	MOVE	AC1,TIME
	IDIVI	AC1,=60*JIFSEC
	HRL	AC1,THSDAT
	CAMG	AC3,AC1			;SKIP IF RUN IN THE FUTURE
	SETZM	BATYET			;MAKE CH7 LOOK NEXT TICK
WAKEM3:	MOVEM	AC3,ALFRED(TAC)		;STUFF IT
	JRST	CPOPJ1			;GIVE HIM SUCCESS RETURN

WAKEM2:	AOBJN	TAC,WAKEM1		;LOOK THRU TABLE
	POPJ	P,			;LOSE

;THIS CALLI TAKES NO ARGUMENT, BUT LOOKS AT THE JOB'S JOBNAM; IF IT IS ONE
;OF THE SPECIAL ONES WE LIKE, WE SAVE THE JOB NUMBER FOR LATER REFERENCE.

WHOAMI:	MOVE TAC,JOBNAM(J)		;FIND OUT WHO HE CLAIMS TO BE
	MOVSI TAC1,-NSPJBS		;HOW MANY WE KNOW ABOUT
	CAME TAC,SPCJBS(TAC1)		;FIND HIS NAME IN TABLE
	AOBJN TAC1,.-1
	JUMPGE TAC1,CPOPJ		;LOSE
	MOVEI TAC,[ASCIZ/WHOAMI attempted when another phantom already exists, UUO/]
	SKIPE SPCWRD(TAC1)		;IS THERE ALREADY SUCH A JOB?
	JRST UUOMES			;YES, TYPE ERROR MESSAGE
	MOVEM J,SPCWRD(TAC1)		;MOVE JOB NUMBER INTO CELL
	POPJ P,				;RETURN

;IF YOU ADD TO THIS TABLE YOU MUST ALSO ADD A CELL AT SPCWRD IN CACDAT!
SPCJBS:	'WHOPHN'
NSPJBS←←.-SPCJBS
;CALLIT CALT1 CALT0

;TRANSLATE SYSTEM CALL TO/FROM SIXBIT.

;CALL:	MOVE AC,[SIXBIT OR NUMERIC UUO]
;	CALLIT AC,
;	RETURN WITH NUMERIC OR SIXBIT FORM (RESP.), 0 IF ERROR

;IF AC12-16 ≠ 0,  ARG IS ASSUMED TO BE SIXBIT (ALL UUO MNEMONICS ARE > 2 CHARS)
; NUMERIC REPRESENTATION WILL BE RETURNED, OR 0 IF THE SPECIFIED UUO DOES
; NOT EXIST.  NOTE THAT CALLING THIS WITH 1- OR 2-CHARACTER NAMES MAY HAVE 
; STRANGE RESULTS.

;IF AC12-17 = 0,  ARG IS ASSUMED TO BE A NUMERIC UUO OF SOME FORM.  THE AC AND
; ADDRESS FIELDS MUST BE 0 UNLESS RELEVANT FOR DECODING (I.E. ADR OF CALLI,
; AC OF TTYUUO, ETC.).  IF THE ARG IS A LEGAL UUO, ITS SIXBIT MNEMONIC WILL BE
; RETURNED, OTHERWISE 0.  IN THE EVENT OF AMBIGUITY, THE MORE SPECIFIC MNEMONIC
; WILL BE RETURNED (E.G. INCHRW RATHER THAN TTYUUO).

;IF AC12-17 = 1, THE MNEMONIC FOR THE SPECIFIED MAJOR OPCODE WILL BE RETURNED.
; THE AC AND ADDRESS FIELDS MUST BE 0.  THIS PROVIDES A WAY TO GET AT MNEMONICS
; SUCH AS "TTYUUO".

CALLIT:	TLNE TAC,36		;IF ITS SIXBIT
	JRST CALT0		;    THEN GO LOOK IT UP
	HLRZ TAC1,TAC
	CAIE TAC1,(<CALLI>)
	JUMPN TAC1,CALTU
	ANDI TAC,-1
	CAIGE TAC,UCLDLN	;IF ITS A DEC CALLI
	JRST CALT1		;    THEN GET THE SIXBIT
	TRZN TAC,400000		;IF NOT A STANFORD CALLI
	JRST RTZERO		;    THEN RETURN 0
	MOVEI TAC,UCLDLN(TAC)	;GET ACTUAL POINTER
	CAIL TAC,UCLLEN		;IF ITS OFF THE END
	JRST RTZERO		;    THEN RETURN 0
CALT1:	MOVE TAC,UCLTAB(TAC)	;ELSE PICK UP SIXBIT
	JRST STOTAC		;THEN PUT IT IN AC AND RETURN

CALT0:	MOVSI TAC1,-UCLLEN
	CAME TAC,UCLTAB(TAC1)	;SEARCH CALLI SIXBIT TABLE
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT2	;IF OFF THE END, TRY FOR OPCODES
	MOVEI TAC,(TAC1)
	CAIL TAC,UCLDLN		;IF STANFORD CALL
	MOVEI TAC,400000-UCLDLN(TAC)	;THEN CONVERT
	HRLI TAC,(<CALLI>)	;MAKE IT A CALLI
	JRST STOTAC		; AND SHIP IT
;CALTU CALTU1 CALTU2

CALTU:	ANDI TAC1,777000
	CAIL TAC1,40000
	CAIL TAC1,700000+IUUMAX*2000
	JRST CALT0		;OUTSIDE UUO RANGE - TRY AS SIXBIT
	CAIL TAC1,100000
	CAIL TAC1,700000
	TRNE TAC,-1
	JRST CALT0		;IN BETWEEN RANGES OR RH NOT ZERO
	TLZE TAC,1
	JRST CALTU2		;SPECIAL - FORCE MAJOR OPCODE NAME
	MOVSI AC1,(TAC1)
	MOVSI AC2,1000(TAC1)
	MOVEI TAC1,UUONAM	;HEADER FOR SECOND LEVEL TABLES
CALTU1:	HRRZ TAC1,-1(TAC1)
	JUMPE TAC1,CALTU2	;NO MORE - MUST BE PLAIN UUO
	CAMG AC1,-1(TAC1)
	CAMG AC2,-1(TAC1)
	JRST CALTU1		;NOT THIS ONE
	HLLZ AC3,-1(TAC1)	;GET OPCODE
	CAMLE TAC,AC3
	JRST RTZERO		;ILLEGAL AC FIELD
	ROT TAC,15
	ANDI TAC,17		;ISOLATE AC FIELD
	ADD TAC,TAC1
	MOVE TAC,(TAC)		;GET SIXBIT
	JRST STOTAC

CALTU2:	TLNE TAC,(<17,>)
	JRST RTZERO		;AC FIELD MUST BE ZERO
	ROT TAC,9		;GET OPCODE
	CAIL TAC,700
	SKIPA TAC,UUONAM+40-700(TAC)
	MOVE TAC,UUONAM-40(TAC)
	JRST STOTAC
;CALT2 CALT3 CALT4

CALT2:	MOVSI TAC1,-IUUMAX*2-40	;TOTAL # MAJOR OPCODES
	CAME TAC,UUONAM(TAC1)
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT3	;NOT FOUND - TRY SECOND LEVEL TABLES
	MOVEI TAC,40(TAC1)	;THIS WILL BE THE OPCODE
	CAILE TAC,77
	MOVEI TAC,700-40(TAC1)	;UNLESS IT'S ONE OF THESE
	ROT TAC,-9		;PUT IT IN THE RIGHT PLACE
	JRST STOTAC

CALT3:	MOVE DAT,[,UUONAM(TAC1)];INIT TABLE PNTR TO HDR, (TAC1) FOR @ BELOW
CALT4:	HRR DAT,-1(DAT)		;GET NEXT TABLE LOC
	TRNN DAT,-1
	JRST RTZERO		;IF NO MORE JUST RET 0 FOR FAILURE
	LDB TAC1,[270400,,-1(DAT)];GET MAX #
	MOVNI TAC1,1(TAC1)	;OFFSET BY 1 FOR COUNT
	MOVSI TAC1,(TAC1)	;MAKE AOBJN PNTR
	CAME TAC,@DAT
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT4	;TRY NEXT TABLE IF NOT FOUND
	HLLZ TAC,-1(DAT)	;FOUND - GET BASE OPCODE
	DPB TAC1,[270400,,TAC]	;SET CORRECT AC FIELD
	JRST STOTAC
;SETPR2 READP2 GETP2 GETHI P2UUO P2FIX0 P2FIX1 P2FIX2 P2UNFX P2UNF1 P2UNF2 P2TEST P2RUNT P2FIXD P2FIXN

BEGIN SEGUUO ↔ SUBTTL	UUO'S FOR HIGH SEGMENTS

;The word JBTPR2(J) indicates whether a special "upper segment" is
;in use by job J.  Here's what JBTPR2 holds:
;
;	If a SETPR2 has been done, JBTPR2 holds the arg to SETPR2,
;	possibly modified to turn on write-protect (1,,0) bit
;	if user doesn't have ACW.  The 0,,776 bits are forced off
;	and the 776,,0 bits are forced on.
;
;	If a GETHI UUO has been done, JBTPR2 holds the arg to GETHI,
;	with the 0,,4 bit turned on to indicate GETHI arg.
;
;In summary, bits in JBTPR2 are:
;	0,,1	  ;relative SETPR2 has been done -- RH adr is relative to user base
;	0,,2	  ;SETPR2 has been simulated by GETJOB code when no job for upper
;	0,,4	  ;GETHI has been done
;	0,,10	  ;GETHI of 2nd type has been done (0,,4 bit will be on too)
;	0,,20	  ;GETHI is write enabled
;	0,,777740 ;GETHI starting page nbr
;	777777,,0 ;number of pages (at zero or at RH page, depending on GETHI type)
;	777776,,0 ;for SETPR2, the last valid address in upper (400000,,0 irrelevant?)
;	1,,0	  ;for SETPR2, write protected upper
;	0,,777000 ;for SETPR2, base address (system or user, depending on 0,,1)


;	SETPR2 UUO
;	MOVE AC,[PROT,,RELOC]
;	SETPR2 AC,
;	<ERROR RETURN>
;	<SUCCESS RETURN>
;
;	RELOC IS ABSOLUTE ADDRESS YOU WISH AS YOUR BASE ADDRESS
;	IF THE LOW ORDER BIT IS ON THEN RELOC IS A RELATIVE ADDRESS
;	IN YOUR CORE IMAGE.
;	IF THE LOW ORDER BIT OF PROT IS ON THEN ACCESS IS WRITE PROTECTED
;	IF THE ACCESS IS ABSOLUTE AND YOU DON'T HAVE THE ACW PRIV THEN YOU ARE
;	AUTOMATICALLY WRITE PROTECTED.
;	BOTH PROT. AND RELOC. ARE TRUNCATED TO 1K BOUNDARIES WHEN LOADED
;	INTO THE PROT.-RELOC. REGISTER.
;	IN RELATIVE MODE PROT. IS ADJUSTED TO BE WITHIN YOUR CORE IMAGE.


↑SETPR2:PUSHJ P,LOW128		;SKIP UNLESS LOWER IS BIGGER THAN 128K
	 POPJ P,		;Lose, lower too big to have upper
	TRNE TAC,1		;IS THIS RELATIVE?
	JRST PR2REL
	MOVE TAC1,JBTPRV(J)	;GET THIS GUY'S PRIV BITS
	TLNN TAC1,ACWPRV	;SKIP IF HE HAS ABS CORE WRITE PRIV
	TLO TAC,1		;NO, WRITE PROTECT AUTOMATICALLY
	JRST PR2SET


;THERE ARE TWO FORMATS OF GETHI CALLS, FIRST:
;	MOVE AC,[# OF PAGES,,STARTING PAGE*40+WENB]
;	GETHI AC,
;	<ERROR RETURN>
;	<SUCCESS RETURN>
;WENB=20 FOR WRITE PERMISSION
;NUMBER OF PAGES MUST BE 400 OR FEWER.
;
;THE SECOND FORMAT IS:
;	MOVE AC,[# PGS STARTING AT ABS 0,,STARTING OTHER PAGE*40+10+WENB]
;	GETHI AC,
;	<ERROR RETURN>
;	<SUCCESS RETURN>
;
;SPECIAL PURPOSE UPPER SEGMENT MAP MUNGING UUO.
;ATTACHES CERTAIN PHYSICAL ADDRESSES AS THIS JOB'S UPPER SEGMENT.
;FLUSHES ANY UPPER THAT EXISTED PRIOR TO THIS CALL.
;SUCCEEDS UNLESS LOWER IS BIGGER THAN 128K.

IFN FTP2,<
READP2:	SKIPE NOP2			;ALLOWED TO LOAD P2?
	POPJ P,				;NO, ERROR RETURN
	MOVE TAC,[P2SIZE,,<P2BASE*40>]	;GET P2 MEMORY WRT PROTECTED
	JRST GETHI

;SPECIAL VERSION TO GET P2'S MEMORY IN ORDER TO LOAD P2SYS
GETP2:	SKIPE NOP2			;ALLOWED TO LOAD P2?
	POPJ P,				;NO, ERROR RETURN
	MOVE TAC,[P2SIZE,,<P2BASE*40>+20]	;GET P2 MEMORY WRT ENABLED
>;IFN FTP2
↑GETHI:	HLRZ TAC1,JBTPAG(J)
	HLRZ AC1,TAC			;NUMBER OF PAGES FROM THE USER'S ARGUMENT
	JUMPE AC1,CPOPJ			;MUST NOT BE ZERO PAGES
	CAIG AC1,400			;SKIP IF NEW UPPER IS TOO BIG.
	CAILE TAC1,400
	POPJ P,				;LOWER IS TOO BIG
	MOVE TAC1,JBTPRV(J)
	TLNN TAC1,ACWPRV		;SKIP IF HE CAN WRITE ANYWHERE
	TRNN TAC,20			;NOT ALLOWED TO WRITE.  SKIP IF HE'S TRYING
	JRST .+2			;WRITE PERMITTED, OR NOT WRITING
	POPJ P,				;DISALLOW WRITE WITHOUT PERMISSION
	LDB TAC1,[POINT 13,TAC,30]	;STARTING PHYSICAL PAGE NUMBER
	MOVEI AC2,400
	SUBI AC2,(AC1)			;NUMBER OF OTHER PAGES
	TRNE TAC,10			;IS THIS KLUDGY 2-PIECE UPPER SEGMENT
	MOVEI AC1,(AC2)			;YES, THIS IS NUMBER OF HI PIECE PAGES
	ADDI TAC1,(AC1)			;TAC1←ENDING PAGE NUMBER+1
;	LSH TAC1,9			;COMPUTE ENDING ADDRESS+1
	CAILE TAC1,PHYMEM*2		;WITHIN BOUNDS OF PHYSICAL MEM?
	POPJ P,				;NO. LOSE.
	PUSH P,TAC			;SAVE USER'S ARGUMENT
	PUSHJ P,KILSEG			;KILL ANY SEGMENT THAT MAY HAVE BEEN THERE.
	POP P,TAC	
	AOS (P)
	TRZ TAC,7			;CLEAR SOME BITS
	TRO TAC,4			;SET GETHI BIT FOR JBTPR2
	JRST STPR2			;STORE JBTPR2.  UPMAPL DOES ALL THE WORK!

IFN FTP2,<
↑P2UUO:	CAILE UCHN,P2FIXN		;CODE IN RANGE?
	JRST UUOERR			;NO
	JRST @P2FIXD(UCHN)		;YES, DISPATCH

P2FIX0:	MOVSI TAC,DEVPRV		;THIS UUO REQUIRES DEV
	TDNN TAC,JBTPRV(J)
	JRST UUOERR			;NOPE
	SKIPN NOP2			;IS P2 MEMORY DOWN?
	POPJ P,				;NO, NOTHING TO DO
	MOVEI UUO,P2MNUM		;NUMBER OF P2 PAGES
	MOVEI TAC,P2BASE		;FIRST PHYSICAL PAGE
P2FIX1:	MOVEI TAC1,PEKEXP		;RANDOM VIRTUAL PAGE (PEEK UUO)
	PUSHJ P,ADDEMP			;GET PAGE INTO MAP
	CAM PEKEXP⊗9+100		;MAKE A NXM HAPPEN IF IT'S GONNA
	CAM PEKEXP⊗9+101		;MAKE A NXM HAPPEN IF IT'S GONNA
	CAM PEKEXP⊗9+102		;MAKE A NXM HAPPEN IF IT'S GONNA
	CAM PEKEXP⊗9+103		;MAKE A NXM HAPPEN IF IT'S GONNA
	PUSHJ P,DELEMP			;FLUSH THE PAGE
	MOVEI TAC,1(TAC)		;NEXT PHYSICAL PAGE
	SOJG UUO,P2FIX1			;CHECK THEM ALL
	SYSPIFF			;SORRY BUT WE WON'T DO IT OFTEN
	MOVEI DDB,P2MNUM		;HOW MANY P2 PAGES WE GET IN MAP
	MOVEI TAC,P2BASE		;PHYSICAL FIRST PAGE OF P2 MEMORY
	MOVEI TAC1,P2MEXP		;P1 VIRTUAL FIRST PAGE OF P2 MEMORY
P2FIX2:	HRRZ DSER,EXPGT(TAC1)		;GET OLD PHYSICAL PAGE
	PUSHJ P,DELEMP			;FLUSH THE OLD MAPPING
	MOVEI AC1,0
	DPB AC1,COREP			;THE PAGE IS NOW FREE
	AOS HIFREE			;AND THERE'S ANOTHER FREE PAGE!
	PUSHJ P,ADDEMP			;GET A PAGE
	MOVEI AC1,P2MCUS		;P2 MEMORY CORE USE CODE
	MOVEI DSER,(TAC)		;PHYSICAL PAGE
	DPB AC1,COREP			;NO LONGER NXM
	MOVEI TAC,1(TAC)
	MOVEI TAC1,1(TAC1)
	SOJG DDB,P2FIX2
	MOVEI TAC,P2MNUM⊗9	;NUMBER OF WORDS WE JUST RETURNED TO USER CORE
	PUSHJ P,ADJCOR			;FIX CORMAX AND USRMAX
	SETZM P2NUM			;ZERO THESE FLAGS BEFORE CONTINUING SYSTEM
	SETZM DETFLG
	SYSPIN			;LET THE SYSTEM RUN NOW
	SETZM P2VORG
	MOVE TAC,[P2VORG,,P2VORG+1]
	BLT TAC,P2VORG+<P2MNUM⊗9>-1	;ZERO P2 CORE THAT WE CAN ACCESS
	SETZM NOP2			;LET P2 RUN TOO
	SETOM P1NUM			;TELL P2 THERE'S A P1
	POPJ P,

P2UNFX:	MOVSI TAC,DEVPRV		;THIS UUO REQUIRES DEV
	TDNN TAC,JBTPRV(J)
	JRST UUOERR			;NOPE
	MOVEI UUO,20			;RETRY COUNT
	JRST P2UNF2

P2UNF1:	SYSPIN			;WAIT FOR STORAGE
	SOJLE UUO,CPOPJ			;ERROR IF NO STORAGE 20 TIMES
	PUSHJ P,WSCHED
P2UNF2:	SKIPE NOP2			;GOING DOWN.  DOWN ALREADY?
	JRST CPOPJ1			;YES, NOTHING TO DO
	SETZM P2NUM			;TELL P2 TO SHUT DOWN
	SYSPIFF			;HO HUM
	MOVE TAC,HIFREE			;IS THERE ENOUGH FREE HIGH CORE FOR THIS?
	CAIGE TAC,P2MNUM
	JRST P2UNF1			;NO, WAIT
	PUSHJ P,KILLP2			;THIS IS IN SYSINI
	 JRST P2UNF1			;THIS BETTER NOT HAPPEN!  NOT ENOUGH FS.
	SETOM NOP2			;TELL THE SYSTEM P2'S MEMORY IS DOWN
	SETOM HNGP2F			;TELL P1 TO STOP P2 DEVICES
	SYSPIN
	JRST CPOPJ1

P2TEST:	SKIPN NOP2			;IS P2 MEMORY UP?
	AOS (P)				;YES, SKIP RETURN
	POPJ P,				;NO, DIRECT RETURN

P2RUNT:	SKIPE DETFLG			;IS P2 RUNNING?
	AOS (P)				;YES, SKIP RETURN
	POPJ P,				;NO, DIRECT RETURN

P2FIXD:	P2TEST				;0 - TEST P2 MEMORY UP
	P2RUNT				;1 - TEST P2 RUNNING
	P2FIX0				;2 - SET P2 MEMORY UP
	P2UNFX				;3 - SET P2 MEMORY DOWN
	GETP2				;4 - GET P2 MEMORY AS HISEG
	READP2				;5 - GET P2 MEMORY READ-ONLY
P2FIXN←←.-P2FIXD
>;IFN FTP2
;PR2REL PR2SET STPR2 STPR2A

;PR2REL, PR2SET

; HERE WE ADDRESS CHECK HIS PR REQUEST

PR2REL:	HLRZ TAC1,JBTPAG(J)	;NUMBER OF PAGES IN LOWER
	LSH TAC1,9		;LOWER'S WORD COUNT
	HRRZ AC1,TAC		;RELOC REQUESTED(RELATIVE TO CORE IMAGE).
	ANDCMI AC1,1777
	CAIL AC1,(TAC1)		;TOO HIGH?
	POPJ P,			;LOSE
	HLRZ AC1,TAC		;PROT.
	IORI AC1,1777
	HRRZ AC2,TAC
	ANDCMI AC2,1777
	ADDI AC1,(AC2)		;+RELOC
	CAIL AC1,(TAC1)		;TOO BIG?
	POPJ P,			;YES, LOSE
PR2SET:	PUSH P,TAC
	PUSHJ P,KILSEG
	POP P,TAC
	AOS (P)
	TRZ TAC,776
	TLO TAC,776
↑STPR2:	MOVEM TAC,JBTPR2(J)	;HERE FOR PSEUDO UPPER FROM GETJB OR FROM GETHI
STPR2A:	PUSHJ P,UPMAPL		;LOOP THROUGH ALL UPPER SEGMENT PAGES
	 MOVEM AC2,(TAC1)	;INSTRUCTION FOR UPMAPL TO EXECUTE
	JRST SEGXIT		;SET UP JOBRL2
;PR2GET

;GETPR2
;CALLING SEQUENCE:
;	GETPR2 AC,
;	<ALWAYS RETURNS HERE>
;
;	AC NOW CONTAINS PROT,,RELOC
;	LOW ORDER BIT OF PROT IS ON IF ACCESS IS WRITE PROTECTED.
;	LOW ORDER BIT OF RELOC IS ON IF RELATIVE MODE.
;	NEXT TO LOW ORDER BIT ON IF PSEUDO-UPPER
;	NEXT TO NEXT TO LOW ORDER BIT ON IF GETHI

↑PR2GET:MOVE TAC,JBTPR2(J)
	JRST STOTAC		;GIVE HIM CURRENT VALUE
;⊗ REMAP REMAP4 REMAP0 REMAP5 REMAP2 SEGXT1 SEGXIT SEGXT5 SEGXT3 SEGXT4 SEGXT2 SEGXT6 RMPER2 RMPER1

;REMAP UUO,  ALSO SEGXIT, SEGXT1 - COMMON SEGMENT UUO EXIT ROUTINE
;CALL:	MOVE AC,[FLAG,,<HIGHEST ADDRESS IN LOW PART>]
;	REMAP AC,
;	<FAILURE>
;IF SIGN BIT IN AC IS ON, SETS SEGMENT AS WRITE-PROTECTED.
;RETURNS IN AC THE JOB NUMBER OF THE SEGMENT.

↑REMAP:	PUSH P,TAC		;SAVE ARGUMENT
	MOVEI TAC,(TAC)		;RIGHT HALF ONLY
	CAIL TAC,400000
	JRST TPOPJ		;HE WANTS TO MAKE HIS LOWER TOO BIG
	HLRZ TAC1,JBTPAG(J)	;check size of current job
	LSH TAC1,9		;make size in words
	CAIL TAC,-1(TAC1)	;SKIP IF ADDRESS IS IN BOUNDS (AND UPPER NON-EMPTY)
	JRST UADERR
	SUBI TAC1,1(TAC)	;MAKE SURE UPPER WON'T BE TOO BIG
	CAILE TAC1,400000	;skip if upper will be no more than than 128K
	JRST TPOPJ		;TOO BIG, YOU LOSE
	MOVE AC1,(P)		;get write protection state in sign bit
	TLO AC1,200000		;request matching write protection state
	PUSHJ P,LNKCHK		;check for existing segment we can link to
	 JRST REMAP4		;none
	EXCH TAC,(P)		;save job number of matching segment found, get arg
	MOVEI TAC,(TAC)		;NEW CORE ASSIGNMENT (AC FROM USER)
	IORI TAC,1777
	PUSHJ P,CORUUO		;SHRINK LOWER, won't be breaking lower into upper
	 JRST RMPER2		;impossible error
	POP P,TAC		;segment number
	PUSHJ P,CONSEG		;connect to segment given in TAC
	 POPJ P,		;can't happen--always skips (unless TAC is zero)
	MOVE TAC,JBTSTS(TAC)	;WAIT FOR SEG TO BE IN CORE
	TLNE TAC,SWP
	PUSHJ P,WSCHED		;WAIT FOR SEGMENT TO GET IN.
	JRST REMAP5

;here if no existing upper segment to link to.
REMAP4:	PUSHJ P,KILSEG		;get rid of any existing upper
REMAP0:	PUSHJ P,MAKESEG		;MAKE A NEW UPPER
	LDB TAC1,PSEGN
	JUMPE TAC1,TPOPJ	;EXIT IF COULDN'T MAKE A NEW SEG.
	MOVE TAC,JBTSTS(TAC1)	;IF WE LINKED, WAIT FOR SEG TO BE IN CORE
	TLNE TAC,SWP
	PUSHJ P,WSCHED		;WAIT FOR SEGMENT TO GET IN.
	SKIPN JBTPAG(TAC1)	;DID WE MAKE A NEW SEGMENT?
	JRST REMAP1		;YES, WE GOT A NEW ONE.
	TLNN TAC,JSEG
	JRST RMPER1		;ERROR IF JSEG ISN'T ON IN THE UPPER'S JBTSTS
	LDB AC1,[POINT 1,TAC,JWPPOS]	;GET WRITE PROTECT BIT FOR SEG
	ROT AC1,-1		;SHIFT JWP BIT TO SIGN BIT.
	XOR AC1,(P)		;COMPARE WITH USER'S ARGUMENT
	JUMPL AC1,REMAP0	;IF WHAT WE GOT ISN'T WHAT WE WANT, MAKE A NEW SEG
	POP P,TAC		;GET NEW CORE ASSIGNMENT BACK (AC FROM USER)
	HRRZ TAC,TAC		;NEW SIZE FOR LOWER
	IORI TAC,1777
	PUSHJ P,CORUUO		;SHRINK LOWER.
	 JRST RMPER2		;IMPOSSIBLE ERROR.
REMAP5:	LDB TAC1,PSEGN
REMAP2:	LDB UCHN,PUUOAC		;RESTORE UCHN - CLOBBERED BY CORUUO
	XCTR XW,[MOVEM TAC1,(UCHN)]	;STORE SEG # IN USER'S AC

IFN FTHPSG,<
	MOVEI TAC,0		;ARGUMENT TO SPECIFY DIRECTION
	PUSHJ P,LTHUUO		;MOVE SEGMENT TO HIGH CORE
	JFCL			;IGNORE FAILURE
	MOVE J,JOB
>;IFN FTHPSG

SEGXT1:	AOS (P)			;GIVE SKIP RETURN.
SEGXIT:
NOKL10,<CONO PAG,3
>;NOKL10
IFKL10,<CONO KLPAG,@KLPCON	;CLEAR ARS
>;IFKL10
	LDB TAC1,PSEGN
	JUMPE TAC1,SEGXT2	;NO REAL UPPER, TRY JBTPR2
	HLRZ TAC,JBTPAG(TAC1)	;NUMBER OF PAGES IN UPPER
	LSH TAC,9		;NUMBER OF WORDS
	SUBI TAC,1		;HIGHEST UPPER ADDRESS
	MOVE TAC1,JBTSTS(TAC1)
	TLNE TAC1,JWP		;SKIP UNLESS WRITE PROTECTED
	HRLI TAC,400000		;INDICATE THAT IN JOBHRL
PRINTX HERE'S ANOTHER PLACE THAT KNOWS ABOUT K BOUNDARIES
SEGXT5:	TROA TAC,401777
SEGXT3:	MOVEI TAC,0
SEGXT4:	XCTR XW,[MOVEM TAC,JOBRL2]
	POPJ P,

SEGXT2:	SKIPN TAC,JBTPR2(J)	;PEEK-POKE?
	JRST SEGXT4		;NO, CLEAR OUT JOBHRL
	TRNE TAC,4		;GETHI HACK?
	JRST SEGXT6		;YES, set JOBHRL appropriately
	HLRZ TAC,TAC		;GET PROTECTION FROM JBTPR2
	TRNE TAC,1		;IS IT WRITE PROTECTED?
	HRLI TAC,400000		;YES
	JRST SEGXT5

;Here if GETHI in effect
SEGXT6:	TRNE TAC,10		;two-part GETHI?
	HRLI TAC,400		;yes, then all 400 possible pages are in upper
	PUSH P,[400000,,0]	;assume write protected
	TRNE TAC,20		;test write enable bit
	SETZM (P)		;write enabled
	HLRZ TAC,TAC		;get nbr of pages in upper
	SUBI TAC,1		;make final page nbr
	TRZ TAC,777400		;can't be more than this many pages in upper
	LSH TAC,9		;make into words
	IOR TAC,(P)		;include write protect bit if set
	ADJSP P,-1		;fix stack
	JRST SEGXT5

RMPER2:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ /  ERROR RETURN FROM CORUUO AT REMAP
/
	POPACS
	JSP DAT,UERROR

RMPER1:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ /  REMAP FAILED TO GET AN UPPER.
/
	POPACS
	JSP DAT,UERROR
;REMAP1 REMAP3 RMPUPB REMZAP REMZP1 REMZPE REMAP8

;REMAP1 - INTIALIZE THE CONTENTS OF THE NEW SEGMENT.

;WE'VE MADE A NEW SEGMENT.  MOVE IMAGE OF UPPER TO 1K BOUNDARY.
;(P) HAS THE USER'S AC, TAC1 HAS THE JOB NUMBER OF THE UPPER

REMAP1:	SETCM TAC,(P)
	TRNN TAC,1777		;SKIP UNLESS IMAGE OF UPPER IS ALREADY
	JRST REMAP3		;   AT A 1K BOUNDARY.   AVOID UPWARD BLT
	HLRZ TAC,JBTPAG(J)
	LSH TAC,9
	ADDI TAC,1777		;GET AN EXTRA 1K TO BLT HIM UP INTO
	PUSH P,JBTSTS(J)	;SAVE SEGMENT NUMBER
	MOVEI TAC1,0
	DPB TAC1,PSEGN		;MAKE THE WORLD NOT SEE OUR SEGMENT FOR A WHILE
	PUSHJ P,CORUUO
	JRST REMAP8		;COULDN'T GET 1K EXTRA CORE.  GIVE ERROR RETURN
	POP P,TAC1
	DPB TAC1,PSEGN		;RESTORE NEW SEGMENT NUMBER
	HRRZ TAC,(P)		;GET LAST ADDRESS IN LOWER
	PUSHJ P,BLTUP		;MOVE UP UPPER.
	LDB TAC1,PSEGN		;GET BACK SEGMENT NUMBER
REMAP3:				;(NOTE:  UCHN IS CLOBBERED BY CORUUO)
	PUSH P,J
	MOVE J,TAC1		;JOB NUMBER OF UPPER
	PUSHJ P,MAKMAP		;GET A PAGE MAP (WE MAY ALREADY HAVE ONE)
	POP P,J
	POP P,TAC		;GET USER'S AC BACK
	MOVSI DAT,JWP
	SKIPG TAC		;SKIP IF REQUESTING NO WRITE PROTECT
	IORM DAT,JBTSTS(TAC1)	;SET WRITE PROTECT IN SEGMENT'S STATUS
	HRRZ TAC,TAC
	IORI TAC,1777		;TAC←LAST ADDRESS IN NEW LOWER
	MOVE DAT,JBTPAG(J)	;SAVE CURRENT CORE ASSIGNMENT OF LOWER
	XCTR XW,[HRRZM TAC,JOBREL]
	MOVEI TAC,1(TAC)
	LSH TAC,-9
	HRLM TAC,JBTPAG(J)	;FIX LOWER'S SIZE
	HLRZ TAC,DAT		;TAC←PAGE COUNT OF UPPER+LOWER
	HLRZ DAT,JBTPAG(J)	;DAT←PAGE COUNT OF LOWER
	SUBI TAC,(DAT)		;TAC←PAGE COUNT OF UPPER
	HRLM TAC,JBTPAG(TAC1)	;STORE UPPER'S PAGE COUNT.

IFN FTSTAT,<
	LSH TAC,6
	IORI TAC,CSZSTA(TAC1)		;SEND CORE SIZE OF UPPER.
	PUSHJ P,STAPTT
>;IFN FTSTAT

	PUSH P,TAC1			;FIX CORTAB AT REMAP TIME.  PUSH SEG #
	HLRZ TAC,JBTPAG(J)		;NUMBER OF PAGES IN LOWER
	LDB DDB,[POINT 1,JBTSTS(TAC1),JWPPOS]  ;GET JWP BIT OF UPPER
	ROT DDB,-1			;MOVE TO SIGN BIT
	HRR DDB,TAC1			;GET NUMBER OF UPPER IN RH OF DDB
IFE FTMPP2,<
	MOVE UCHN,JBTMAP(DDB)
	LSH UCHN,9			;ADDRESS OF UPPER'S MAP
>;IFE FTMPP2
IFN FTMPP2,<
	PUSH P,J
	MOVEI J,(DDB)
	MOVEI AC1,PAGEXP		;CAN'T USE JOBMAP HERE
	PUSHJ P,JOBEVP			; BECAUSE ZMAPL USES IT
	 JFCL				; SO WE USE A SPECIAL EXEC VIRTUAL PAGE
	POP P,J
	MOVEI UCHN,PAGEXP⊗9
>;IFN FTMPP2
	HLRZ AC1,JBTPAG(TAC1)		;NUMBER OF PAGES OF UPPER.
	PUSHJ P,ZMAPL			;LOOP THROUGH LOWER'S PAGE MAP WHERE UPPER
	 PUSHJ P,REMZAP			; WAS, REASSIGN IN CORTAB AND MOVE TO UPPER
	PUSH P,J
	MOVE TAC,J			;LOWER
	HRRZ J,DDB			;UPPER
	PUSHJ P,ASGMAP			;COPY PAGE MAP OF UPPER TO LOWER
	POP P,J
	POP P,TAC1
IFN FTUPCLB,<
IFN FTCINS,<
	PUSH P,DDB
	PUSH P,PROG
	PUSH P,J
	LDB J,PSEGN
	MOVE DDB,JBTSTS(J)
	TLNN DDB,JWP
	JRST RMPUPB		;JUMP IF WRITE PERMIT
	CONO KLPAG,@KLPCON	;KEEP PAGE TABLES HONEST
	HLLZ DDB,JBTPAG(J)
	LSH DDB,9
	MOVN DDB,DDB		;-SIZE OF CORE IMAGE,,0  = AOBJN POINTER TO CORE
	HRRI DDB,400000
	MOVEI PROG,0
	XCTR XBLTR,[CHKINS DDB,]	;CHECKSUM!
	MOVEM PROG,JBTSCS(J)
	HLRZ DDB,JBTPAG(J)	;GET SIZE OF JOB IN PAGES
	LSH DDB,3		;MAKE A 12-BIT FIELD
	DPB DDB,[POINT 12,JB2SWP(J),29]	;STORE HERE (9BIT SIZE, 3BIT COUNT)
	CAIA
RMPUPB:	SETZM JBTSCS(J)
	POP P,J
	POP P,PROG
	POP P,DDB
>;IFN FTCINS
>;IFN FTUPCLB
	JRST REMAP2

REMZAP:	MOVEI DSER,(AC2)  ;(DSER=LOC)	;PHYSICAL PAGE NUMBER OF LOWER'S ENTRY
	TLZ AC2,P.WRT			;CLEAR WRITE ENABLE BIT IN MAP ENTRY
	SKIPL DDB			;SKIP IF SUPPOSED TO WRITE PROTECT
	TLO AC2,P.WRT			;TURN WRITE ENABLE BACK ON
	MOVEM AC2,(UCHN)		;STORE IN UPPER'S MAP
IFN FTCORBUG,<
	LDB AC2,COREP
	CAIE AC2,(J)
	PUSHJ P,REMZPE
>;IFN FTCORBUG
	MOVEI AC2,0			;NEW PAGE MAP ENTRY FOR LOWER'S MAP
	DPB DDB,COREP			;STORE UPPER'S JOB NUMBER IN CORTAB
	CAMGE DSER,FSLIMIT
	JRST REMZP1
	SOS JBTPAG(J)			;ONE LESS HI PAGE FOR LOWER
	AOS JBTPAG(DDB)			;ONE MORE HI PAGE FOR UPPER
REMZP1:	AOJA UCHN,CPOPJ			;BUMP POINTER TO UPPER'S MAP

IFN FTCORBUG,<
REMZPE:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CORTAB ENTRY AND J DISAGREE AT REMZAP
CORTAB = /
	MOVE TAC,AC2-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /  J = /
	MOVE TAC,J-17(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	POPACS
	POPJ P,
>;IFN FTCORBUG

REMAP8:	POP P,TAC1
	DPB TAC1,PSEGN			;RESTORE NEW SEGMENT NUMBER
	POP P,TAC			;HERE IF WE COULDN'T BLT UP
	JRST KILSEG			;RETURN SEGMENT'S JOB NUMBER TO SYSTEM
;BLTUP FASBLT BLTUP1 BLTUP2 BLTUP3 BLTUP4

;BLTUP - FAST UPWARDS BLT
;TAKES SOURCE ADDRESS-1 IN TAC (RELATIVE)
;BLTS UP REST OF CORE IMAGE TO NEXT 1K BOUNDARY
;CLOBBERS TAC,TAC1,AC1,AC2,AC3
;THIS CODE IS MORE OR LESS COPIED FROM CORE ROUTINES IN 'E'

;ALTERNATE ENTRY POINT AT FASBLT (NO ONE USES THIS).  TAC1=DEST-1, AC2=LAST DEST
;THIS ROUTINE IS MORE GENERAL THAN NECESSARY FOR ITS PRESENT USES

;NOTE THAT THE MAP MUST BE SETUP BEFORE ENTERING THIS!

↑BLTUP:	MOVEI TAC1,(TAC)	;TAC1←SOURCE ADDRESS-1
	IORI TAC1,1777		;TAC1←FIRST DESTINATION ADDRESS-1
	HLRZ AC2,JBTPAG(J)	;PAGE COUNT OF LOWER
	LSH AC2,9		;WORD COUNT
	SUBI AC2,1		;AC2←LAST DESTINATION ADDRESS.
FASBLT:	SUBI AC2,(TAC1)		;AC2←LENGTH OF TRANSFER
	SUBI TAC1,(TAC)		;TAC1←DISTANCE OF TRANSFER
	CAILE AC2,(TAC1)	;IF LENGTH LESS THAN DISTANCE, THERE'S NO OVERLAP
	JUMPGE TAC1,BLTUP1	;JUMP IF OVERLAP AND DISTANCE TO MOVE IS POSITIVE.
	JUMPLE AC2,CPOPJ	;IF THE LENGTH TO MOVE IS NEGATIVE YOU'RE CONFUSED
	MOVEI AC3,(TAC)		;FIRST SOURCE-1
	ADD AC3,TAC1		;+DISTANCE=FIRST DESTINATION. (ABSOLUTE)
	HRLI AC3,1(TAC)		;AC3←FIRST SOURCE,,FIRST DESTINATION
	ADDI AC2,(AC3)		;AC2←DESTINATION+LENGTH = ENDING ADDRESS+1
	BLT AC3,-1(AC2)
	POPJ P,

BLTUP1:	CAILE TAC1,5		;THIS IS BELIEVED TO BE THE ROUGH BREAK-EVEN POINT
	JRST BLTUP2		;BETWEEN THE TWO METHODS
	JUMPE TAC1,CPOPJ	;IF DISTANCE TO MOVE IS ZERO, WE ARE DONE.
	MOVSI AC1,(<POP TAC1,(TAC1)>)
	HRRI AC1,(TAC1)		;AC1←POP TAC1,OFFSET(TAC1)
	MOVSI TAC1,377777(AC2)	;SET COUNT TO GO POS WHEN DONE.
	HRRI TAC1,(TAC)		;TAC1←COUNT,,FIRST SOURCE-1
	ADDI TAC1,(AC2)		;TAC1←COUNT,,LAST SOURCE
	MOVE AC2,[JUMPL TAC1,AC1]
	PUSH P,TAC		;SAVE TAC.
	MOVE TAC,AC1		;MOVE THE POP INSTRUCTION TO TAC
	MOVE AC1,[XCTR XWSTKR,TAC]	;EXECUTE RELOCATED FOR THE POP INSTR.
	MOVE AC3,[JRST TPOPJ]	;THE RETURN INSTR.
	JRST AC1		;ROAR

;TAC/	POP	TAC1,OFFSET(TAC1)
;TAC1/	377777+WC,,LAST SOURCE ADDRESS
;AC1/	XCTR	XWSTKR,TAC
;AC2/	JUMPL	TAC1,AC1
;AC3/	JRST	TPOPJ


;HERE WE ITERATE ON BLTS, POSSIBLY STARTING WITH A SMALLER ONE

BLTUP2:	PUSH P,AC2
	IDIVI AC2,(TAC1)	;REMAINDER (AC3) IS SIZE OF FIRST (SHORT) BLT
	MOVE AC2,(P)		;AC2← # OF WORDS TO MOVE
	ADDI AC2,1(TAC)		;AC2←LAST SOURCE ADDRESS+1
	HRLI AC2,(AC2)		;LAST SOURCE+1,,LAST SOURCE+1
	ADDI AC2,(TAC1)		;LAST SOURCE+1,,LAST DESTINATION+1
	JUMPE AC3,BLTUP3	;IF REMAINDER IS ZERO, DON'T NEED INITIAL SHORT BLT
	MOVSI AC1,(<BLT AC3,(AC2)>)
	HRRI AC1,-1(AC3)	;AC1 ← BLT AC3,LENGTH-1(AC2)
	HRLI AC3,(AC3)		;AC3 ← LENGTH,,LENGTH  (OF SHORT BLT)
	SUBB AC2,AC3		;BACKUP THE BLT POINTER (AC3) AND COPY IT IN AC2.
	XCTR XBLTRW,AC1		;EXECUTE THE BLT, RELOCATING BOTH FETCH AND STORE
BLTUP3:	HRLI TAC1,(<BLT AC3,(AC2)>)	;TAC1←BLT AC3,DISTANCE(AC2)
	MOVEM TAC1,(P)
	SOS (P)			;(P) ← BLT AC3,DISTANCE-1(AC2)
	HRLI TAC1,(TAC1)	;TAC1 ← DISTANCE,,DISTANCE
	MOVEI AC1,1(TAC)	;AC1←FIRST SOURCE ADDRESS
	ADDI AC1,(TAC1)		;AC1←FIRST DESTINATION ADDRESS
;AC2 ← LAST SOURCE+1,,LAST DESTINATION+1
;TAC1 ← DISTANCE,,DISTANCE  OF EACH BLT
;AC1 ← FIRST DESTINATION ADDRESS
BLTUP4:	SUB AC2,TAC1		;BACKUP AC2 TO BE READY FOR NEXT BLT.
	MOVE AC3,AC2		;COPY FOR BLT ENDING ADDRESS COMPUATION
	XCTR XBLTRW,(P)		;DO BLT, RELOCATING FETCH AND STORE
	CAIGE AC1,(AC2)		;HAVE WE REACHED THE FIRST DEST. YET?
	JRST BLTUP4		;NO. DO SOME MORE.
	SUB P,[1,,1]		;REMOVE BLT FROM STACK
	POPJ P,
;SETUWP SETUW1 SETUW2

;SETUWP UUO TO SET OR CLEAR USER WRITE-PROTECT BIT
; CALLING . . .
;	MOVE AC,<0 FOR CLEAR, ≠0 FOR SET>
;	SETUWP AC,
;	<NO CAN DO>

↑SETUWP:PUSH P,TAC			;ARGUMENT AC
	PUSH P,J
	LDB J,PSEGN
	JUMPN J,SETUW1			;JUMP IF A REAL SEGMENT EXISTS
	POP P,J				;UNWIND STACK
	POP P,TAC1			;ARGUMENT AC
	SKIPN TAC,JBTPR2(J)
	JRST SEGXIT
	TRNE TAC,4			;SKIP IF NOT GETHI HACK
	JRST SEGXIT
	MOVEI AC1,0
	SKIPE TAC1
	MOVEI AC1,1			;SET UP WRITE PROTECT BIT FOR SETPR2
	DPB AC1,[POINT 1,TAC,17]	;SET UP ARGUMENT TO SETPR2
	JRST SETPR2

SETUW1:	PUSHJ P,ACCESS			;ACCESS NEEDS JOB PUSHED ON STACK!
	JFCL				;NO ACCESS
	JRST SETUW2			;READ ACCESS ONLY
	EXCH DDB,-1(P)
	PUSHJ P,WPMAPL		;SET WRITE PROTECT ACCORDING TO DDB
	PUSHJ P,AUPMAP		;CHANGE ALL LOWERS OF OUR UPPER
	EXCH DDB,-1(P)
	POP P,TAC1		;MASTER JOB NUMBER
	EXCH TAC1,(P)		;GET BACK USER'S AC INTO TAC1, MASTER JOB INTO 0(P)
	MOVSI TAC,JWP
	JUMPE TAC1,.+2		;JUMP IF HE WANTS TO BE ABLE TO WRITE
	IORB TAC,JBTSTS(J)	;HE WANTS TO WR PROT, SET THE BIT
	JUMPN TAC1,.+2		;JUMP IF HE WANTS TO BE WRITE PROTECTED
	ANDCAB TAC,JBTSTS(J)	;HE WANTS TO BE ABLE TO WRITE, CLEAR THE BIT
	HLRZ TAC1,JBTPAG(J)	
	LSH TAC1,9
	SOJA TAC1,CORE2X	;CALL CORE2X WITH TAC=PROTECTION OF UPPER

SETUW2:	POP P,J			;FORGET IMMEDIATELY IF READ-ONLY ACCESS
	POP P,TAC
	JUMPN TAC,CPOPJ1
	POPJ P,
;UNPURE UNPUR2 UNPNC2 UNPNC1 UNPNC4 UNPNC3 UNPNC5 UNPURS UNPRS1 UNPNON

;UNPURE, UNPURS
;MAKE A WRITEABLE COPY OF PRESENT UPPER.
;IF THE UPPER IS NOT WRITE-PROTECTED, WE USE IT, OTHERWISE, A COPY IS MADE.
;SKIPS ON SUCCESS (ALREADY WRITEABLE, NO UPPER, RELATIVE SETPR2, OR COPY DONE).
;NO-SKIP MEANS THAT A COPY COULDN'T BE CREATED (JOB SLOTS) OR SETPR2 SEGMENT
;CAN'T BE WRITTEN IN.

↑UNPURE:LDB AC1,PSEGN			;AC1←JOB NUMBER OF PRESENT UPPER.
	JUMPE AC1,UNPNON		;JUMP IF NO UPPER.  CHECK FOR PR2.

IFN FTHPSG,<
	MOVEI TAC,1			;ALWAYS FLUSH UNPURIFIED UPPERS FROM HICORE
	PUSHJ P,LTHUUO
	MOVE J,JOB
>;IFN FTHPSG

	MOVE TAC,JBTSTS(AC1)
	TLZN TAC,JWP
	JRST CPOPJ1			;SUCCESS RETURN IF UPPER IS WRITEABLE
	MOVE TAC1,NJOBS(AC1)
	SOJG TAC1,UNPNC1		;JUMP UNLESS WE ARE THIS SEG'S ONLY USER
	MOVEM TAC,JBTSTS(AC1)		;OURS ALONE - JUST UNPROTECT IT
	PUSHJ P,UNPMAP			;UNPURIFY THE SEGMENT AND ITS LOWERS
	PUSHJ P,UNPUR2
	JRST SEGXT1

UNPUR2:	MOVE TAC,JOBNAM(AC1)		;MUNG JOBNAM SO THE OLD ONE IS STILL UNIQUE
	LSH TAC,-6			;CLEVERLY PRESERVING THE INFO FOR HUMANS
	MOVEM TAC,JOBNAM(AC1)
IFN FTELOK,<
	CAMN AC1,ESEGNO
	SETZM ESEGNO			;NOT E UPPER SEGMENT ANY MORE
>;IFN FTELOK

IFN FTSTAT,<
	PUSH P,J
	MOVEI J,(AC1)
	PUSHJ P,NAMSTT
	POP P,J
>;IFN FTSTAT

	MOVEI TAC,400(J)		;400 BIT WILL FEND OFF ACCESS
	DPB TAC,[POINT 9,JOBCRD(AC1),8]	;SET PROTECTION
	POPJ P,

;An unpurification resource (bits 24-35 of RTIME) is associated with
;each segment.  The resource is claimed by one lower that's trying to
;unpurify an upper.  We wait until this resource is free, claim it for
;ourselves, and when the upper is swapped out, the resource will be
;freed, and, hopefully, we'll be given a new, writeable, segment.

UNPNC2:	PUSHJ P,WSCHED			;WAIT UNTIL WE HAVE THE UNPURE RESOURCE
UNPNC1:	LDB AC1,PSEGN			;AC1←SEGMENT NUMBER

;PRINTX Here is the crock disabling the UNPURE disable crock -- test it out
PRINTX Here is the UNPURE disable crock
	POPJ P,
REPEAT 0,<

	LDB TAC,[POINT JOBNSZ,RTIME(AC1),35] ;TAC←OWNER OF UNPURE RESOURCE
	CAIE TAC,(J)			;OK IF WE'VE GOT IT.
	JUMPN TAC,UNPNC2		;WAIT IF ASSIGNED TO SOMEONE ELSE.
	DPB J,[POINT JOBNSZ,RTIME(AC1),35] ;CLAIM RESOURCE
UNPNC4:	LDB TAC,[POINT JOBNSZ,RTIME(AC1),35] ;AC1=(OLD) SEGMENT NUMBER
	CAME TAC,JOB			;SKIP IF WE STILL HAVE RESOURCE
	JRST UNPNC5			;NO.  GO SEE WHAT'S HAPPENED
	MOVE J,AC1			;J←SEGMENT NUMBER
	MOVE TAC1,JBTSTS(J)
	SKIPN XJOB(J)
	TLNE TAC1,SWP
	JRST UNPNC3			;CAN'T GRONK SEGMENT NOW.
	HLRZ TAC,JBTPAG(J)		;CALL XPAND WITH SAME AMOUNT OF CORE AS NOW
	PUSHJ P,XPAND			;FORCE SEGMENT OUT.
UNPNC3:	PUSHJ P,WSCHED			;WAIT BEFORE GRONKING SEGMENT
	JRST UNPNC4

UNPNC5:	MOVE J,JOB
	PUSHJ P,SPWCNT			;CONTINUE SPACEWAR.
	LDB TAC1,PSEGN			;TAC1←NEW SEGMENT NUMBER
	MOVE TAC,JBTSTS(TAC1)
	TLNN TAC,JWP			;IS SEGMENT WRITE PROTECTED?
	AOS (P)				;NO.  WE MUST HAVE WON
	JRST SEGXIT			;EXIT, HAVING WON OR LOST.

;ENTER UNPURS FROM SWAPPER (FINOUT) TO FINISH THE ACTION REQUESTED ABOVE.
;J←JOB NUMBER OF SEGMENT.  TAC1←JOB NUMBER OF LOWER WHO'S REQUESTING UNPURE.

↑↑UNPURS:
	MOVEI TAC,0			;FREE THE UNPURIFICATION RESOURCE.
	DPB TAC,[POINT JOBNSZ,RTIME(J),35]
	MOVE AC1,J			;AC1←JOB NUMBER OF OLD UPPER.
	MOVE TAC,NJOBS(AC1)		;MAYBE BY NOW WE'RE THE ONLY USER
	CAIG TAC,1
	JRST UNPRS1			;WE'RE THE ONLY USER...
	PUSHJ P,ESTSEG			;J←JOB SLOT FOR NEW SEGMENT.
	POPJ P,				;LOSE.  NONE AVAILABLE.
	PUSH P,TAC1			;SAVE JOB NUMBER OF MAIN JOB.
	PUSH P,AC1			;SAVE JOB NUMBER OF OLD UPPER.
	PUSH P,J			;SAVE JOB NUMBER OF NEW UPPER.

	MOVE J,-2(P)
	MOVE AC1,0(P)
	PUSHJ P,UNPUR2			;ADJUST NAME AND PROTECTION NOW.
	MOVE J,0(P)
	MOVEI TAC,0
	EXCH TAC,JBTMAP(AC1)		;OLD UPPER NEEDS NO MAP
	MOVEM TAC,JBTMAP(J)		;BUT NEW UPPER NEEDS ONE.
IFN FTMAPP,<
	MOVE TAC,JBTMA2(AC1)		;EXCHANGE PHYSICAL PAGE ASSIGNMENTS TOO
	EXCH TAC,JBTMA2(J)
	MOVEM TAC,JBTMA2(AC1)
>;IFN FTMAPP
	MOVEI DSER,0
	EXCH DSER,JBTPAG(AC1)		;RELEASE OLD UPPER'S CORE.
	MOVEM DSER,JBTPAG(J)		;AND ASSIGN IT TO NEW UPPER.

IFN FTSTAT,<
	MOVEI TAC,CPSSTA(AC1)		;SEND NEW POSITION OF OLD UPPER
	PUSHJ P,STAPTT
	MOVEI TAC,0
	PUSHJ P,STAPTT			;NEW POSITION IS ZERO.
	MOVEI TAC,CPSSTA(J)		;SEND NEW POSITION OF NEW UPPER
	PUSHJ P,STAPTT
	HRRZ TAC,JBTPAG(J)
	PUSHJ P,STAPTT
	HLRZ TAC,JBTPAG(J)		;SIZE OF NEW UPPER
	LSH TAC,6
	IORI TAC,CSZSTA(J)
	PUSHJ P,STAPTT
>;IFN FTSTAT

	HLRZ AC1,JBTPAG(J)		;FIX CORTAB - OUT WITH THE OLD.
	HRRZ DSER,JBTPAG(J)
	MOVEI UCHN,0
	PUSHJ P,CORSTG			;OUT WITH THE OLD JOB
	MOVEI UCHN,(J)			;JOB NUMBER OF THE (NEW) UPPER
	HLRZ AC1,JBTPAG(J)
	PUSHJ P,LMAPL			;SETUP PAGE MAP ENTRIES OF NEW UPPER
	 MOVEM AC2,(TAC1)		;MARK PAGES WRITEABLE
	PUSHJ P,CORSTG			;IN WITH THE NEW
	MOVE TAC,-2(P)			;TAC←JOB NUMBER OF MAIN JOB.
	MOVE J,-1(P)			;J←JOB NUMBER OF OLD UPPER.
	SKIPE JBTPAG(TAC)		;SKIP IF LOWER IS SWAPPED OUT (NO MAP)
	PUSHJ P,ZSGMAP  		;FLUSH THE SEGMENT FROM LOWER'S PAGE MAP 
	SOS NJOBS(J)
	MOVE J,-2(P)			;JOB NUMBER OF LOWER
	MOVEI TAC,0
	DPB TAC,PSEGN			;ZERO OLD SEGMENT FIELD

IFN FTSTAT,< PUSHJ P,SEGSTT >

	MOVE J,-1(P)			;J←JOB NUMBER OF OLD SEGMENT
	MOVE TAC,0(P)			;TAC←JOB NUMBE OF NEW SEGMENT
	PUSHJ P,MAKSE2			;COPY PARAMETERS FROM OLD SEG TO NEW
	MOVE J,-2(P)			;J←JOB NUMBER OF MAIN JOB
	DPB TAC,PSEGN			;THIS IS NOW OUR SEGMENT
	EXCH TAC,J			;J←NEW SEGMENT NUMBER, TAC←LOWER
	SKIPE JBTPAG(TAC)		;LOWER MAY BE SWAPPED OUT ALREADY
	PUSHJ P,ASGMAP			;PUT PAGES OF UPPER IN MAP OF LOWER
	EXCH TAC,J
IFN FTSTAT,< PUSHJ P,SEGSTT >
; EVENTUALLY, THE CODE AT UNPNC5 WILL FIND A WRITEABLE UPPER.
	MOVE J,-1(P)			;RESTORE OLD SEGMENT NUMBER FOR FINOUT
	SUB P,[3,,3]
	JRST CPOPJ1			;RETURN TO FINOUT/SWAPSCAN

;AC1=J=JOB NUMBER OF SEGMENT.  TAC1←JOB NUMBER OF LOWER WHO'S REQUESTING UNPURE.
;HERE, AFTER ALL THAT WORK, WE'RE THE ONLY USER.
UNPRS1:	MOVSI TAC,JWP
	ANDCAM TAC,JBTSTS(J)		;MARK SEGMENT AS WRITEABLE
	MOVE J,TAC1			;J←JOB NUMBER OF LOWER
	PUSHJ P,UNPUR2
	MOVE J,AC1			;RESTORE JOB NUMBER OF UPPER
	POPJ P,				;RETURN, LET FINOUT DO THE WORK

>;END REPEAT 1

UNPNON:	MOVEI TAC,4			;HERE IF HE DOESN'T HAVE A REAL UPPER.
	TDNE TAC,JBTPR2(J)
	POPJ P,				;GETHI HACK, HE LOSES!
	MOVSI TAC,1
	TSNN TAC,JBTPR2(J)		;IF HE HAS RELATIVE PR2
	POPJ P,
	ANDCAM TAC,JBTPR2(J)		;THEN UNPROTECT IT
	AOS (P) 			;SET SUCESS RETURN.
	JRST STPR2A			;MAKE WRITEABLE ENTRIES IN MAP OF LOWER
;CORE2 CORE2A CORE2E CORE2B CORE2N CORE2X CORE2D

;CORE2, CORE2X
;CALL:	MOVE AC,<HIGHEST REL. ADR. IN UPPER, INCLUDING 0>
;	CORE2 AC,
;	<ERROR RETURN>
;SETS CORE SIZE OF UPPER ACCORDING TO THE ARGUMENT SPECIFIED BY USER.

↑CORE2:	TRNE TAC,377777		;IS HE REQUESTING ANY CORE AT ALL?
	JRST CORE2A		;YES.
	PUSHJ P,KILSEG		;NO. KILL THE SEGMENT
	JRST SEGXT1		;SET UP JOBRL2. LEAVE, GIVING SKIP RETURN

CORE2A:	IORI TAC,1777		;ROUND UP TO NORMAL BOUNDARY
	ANDI TAC,377777		;ZERO SOME BITS.
	PUSHJ P,LOW128		;SEE IF WE ARE ALLOWED TO HAVE AN UPPER
	POPJ P,			;NOPE, LOWER IS BIGGER THAN 128K
	PUSH P,J
	LDB J,PSEGN
	JUMPN J,CORE2B		;JUMP IF WE HAVE A SEGMENT ALREADY.
	POP P,J			;WE HAVE TO MAKE A NEW SEGMENT. 
	PUSH P,TAC		;SAVE DESIRED SEGMENT SIZE
	PUSHJ P,MAKESEG		;MAKE A NEW SEG.
	POP P,TAC
	LDB TAC1,PSEGN		;LOOK TO SEE WHAT NUMBER WE GOT.
	JUMPE TAC1,SEGXIT	;LOSE IF NO JOB SLOT AVAILABLE FOR NEW SEG
	PUSH P,J		;SAVE JOB NUMBER OF MAIN JOB.
	LDB J,PSEGN		;J←JOB NUMBER OF OUR NEW SEGMENT.
	PUSHJ P,CORUUO		;ASSIGN CORE FOR NEW SEGMENT.
	JRST CORE2E		;LOSE.  RELEASE JOB ASSIGNED TO NEW SEGMENT
	JRST CORE2N		;CORE ASSIGNED OK.

CORE2E:	POP P,J			;HERE IF THERE'S NO CORE FOR NEW SEGMENT.
	PUSHJ P,KILSEG
	JRST SEGXIT

CORE2B:	PUSH P,TAC		;SAVE DESIRED UPPER SIZE
	PUSH P,-1(P)		;PUT JOB NUMBER ON TOP OF STACK FOR ACCESS!
	PUSHJ P,ACCESS
	JFCL			;LOSE.
	SETZM -1(P)		;LOSE.  FLAG CORE SIZE AS ZERO.
;NOTE: IF ACCESS GIVES ERROR RETURN, THEN TAC AS POPPED BELOW WILL BE ZERO
;AND CORUUO WILL ALWAYS GIVE ERROR RETURN FOR A ZERO ARGUMENT IN TAC.
	SUB P,[1,,1]		;REMOVE JOB NUMBER
	POP P,TAC		;GET BACK DESIRED UPPER SIZE
	PUSHJ P,CORUUO		;ASSIGN CORE FOR THIS SEGMENT.
	JRST CORE2D		;FAILED. (STORES USER'S AC)
CORE2N:	PUSHJ P,AUPMAP 		;OK, SET UP MAP FOR EACH LOWER OF THIS UPPER
	HLRZ TAC1,JBTPAG(J)
	LSH TAC1,9
	SUBI TAC1,1		;TAC1←UPPER'S JOBREL
CORE2X:	TLNE TAC,JWP		;(ENTER HERE FROM SETUWP)
	TLO TAC1,400000		;SET JOBRL2 FOR EACH LOWER OF THIS UPPER.
	MOVE TAC,J
	TRO TAC1,400000
	AOS -1(P)		;SET FOR SUCCESS RETURN
	MOVE AC1,TAC1		;AC1←NEW JOBHRL
	PUSHJ P,UAPPLY		;APPLY TO ALL LOWERS OF THIS UPPER.
	 PUSHJ P,SETRLC		;(ARGUMENT TO UAPPLY - SEE SETUWP COMMAND)
CORE2D:	POP P,J			;RESTORE JOB NUMBER OF MAIN JOB
	AOS AMC14		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;RESET MAP TO RUN THE CURRENT JOB
	JRST SEGXIT
;ATTSEG ATTSE8 ATTSE5 ATTSE1 ATTSER ATTSE6 ATTSE3 ATTSE4 ATTSE2

;ATTSEG - ATTACH HIGH SEGMENT
; CALLING . . .
;	MOVE AC,<JOB NUMBER OR JOB NAME>
;	ATTSEG AC,
;	<NO CAN DO, ERROR CODE IN AC>
;
; ERROR CODES:
; 0 - PROTECTION VIOLATION
; 1 - AMBIGUOUS ADDRESSEE
; 2 - NOT A HIGH SEGMENT
; 3 - DOES NOT EXIST
; 4 - ALREADY HAVE A HIGH SEGMENT
; 5 - LOWER TOO BIG (BIGGER THAN 128K)

↑ATTSEG:PUSHJ P,LOW128			;SKIP UNLESS LOWER IS BIGGER THAN 128K
	JRST ATTSE8
	LDB TAC1,PSEGN
	SKIPN JBTPR2(J)			;CAN'T ATTACH WHILE DOING PEEK-POKE
	JUMPE TAC1,ATTSE5
	MOVEI TAC,4
	JRST ATTSER

ATTSE8:	MOVEI TAC,5
	JRST ATTSER

ATTSE5:	CAIL TAC,JOBN
	JRST ATTSGJ			;TREAT AS SIXBIT JOB NAME
	JUMPLE TAC,ATTSGJ		;Jump if can't possibly be job number
ATTSE1:	MOVE TAC1,JBTSTS(TAC)		;SEE IF SPECIFIED JOB IS A SEGMENT
	TLNE TAC1,JSEG
	JRST ATTSE6			;IT IS
	MOVEI TAC,2
ATTSER:	XCTR XW,[MOVEM TAC,(UCHN)]	;STORE ERROR CODE
	POPJ P,

ATTSE6:	PUSH P,J			;SAVE OUT JOB NUMBER
	MOVE J,TAC			;GET NUMBER OF SEGMENT
	PUSHJ P,ACCESS			;SEE IF WE HAVE ACCESS
	 JRST ATTSE7			;NO ACCESS
	 JFCL				;READ ACCESS ONLY
	MOVE TAC1,J			;JOB NUMBER OF SEGMENT
	POP P,J				;GET BACK OUR JOB NUMBER
	DPB TAC1,PSEGN			;MAKE IT OUR SEGMENT
IFN FTSTAT,<
	PUSHJ P,SEGSTT
>;FTSTAT
	AOS NJOBS(TAC1)			;BUMP COUNT OF JOBS PNTING TO THIS SEGMENT
	SKIPN AC1,JBTDTS(J)		;DOES HE HAVE A LIST OF DETACHED SEGMENTS?
	JRST ATTSE2			;NO.
ATTSE3:	LDB DAT,PDSEGN			;YES, IS THERE A SEGMENT NUMBER THERE
	JUMPE DAT,ATTSE2		;NO SEGMENTS LEFT IN LIST
	CAME DAT,TAC1			;IS THIS THE ONE IN QUESTION?
	AOJA AC1,ATTSE3			;NO, TRY THE NEXT ONE
	MOVEI TEM,1(AC1)		;YES, RUN DOWN TO END OF LIST
ATTSE4:	SKIPE (TEM)			;IS THIS THE END OF LIST?
	AOJA TEM,ATTSE4			;NO, TRY AGAIN
	MOVE DAT,-1(TEM)		;MOVE LAST WORD ONTO WHERE WE'RE DELETING
	MOVEM DAT,(AC1)
	SETZM -1(TEM)			;ZERO THE END OF THE LIST
	SUBI TEM,1
	CAME TEM,JBTDTS(J)		;DOES HE HAVE ANY DETACHED SEGMENTS LEFT?
	JRST ATTSE2			;YES, WE ARE DONE
	MOVE AC1,JBTDTS(J)		;NO, WE CAN GIVE BACK FREE STORAGE
	PUSHJ P,FSGIVE
	SETZM JBTDTS(J)
ATTSE2:	AOS (P)
	PUSH P,J
	MOVE TAC,J			;OUR JOB NUMBER
	MOVE J,TAC1			;JOB NUMBER OF THE UPPER
	PUSHJ P,ASGMAP			;ADD UPPER TO OUR PAGE MAP
	POP P,J
	PUSHJ P,WSCHED			;MAKE SURE SEGMENT IS IN CORE
	JRST SEGXIT			;NOW GO SET PROT-RELOC
;ATTSGJ ATTSG1 ATTSG4 ATTSG3 ATTSG2 ATTSE7

;SEARCH FOR A SEGMENT OF A GIVEN NAME

ATTSGJ:	MOVE DAT,JOBNM1
ATTSG1:	CAME TAC,JOBNAM(DAT)
	JRST ATTSG4
	MOVE TAC1,JBTSTS(DAT)
	TLNN TAC1,JSEG
	JRST ATTSG4			;IGNORE JOB OF THIS NAME IF NOT A SEGMENT
	MOVE TAC1,DAT			;SAVE JOB NUMBER AND CHECK IF UNIQUE
	JRST ATTSG2

ATTSG4:	SOJG DAT,ATTSG1
	MOVEI TAC,3			;NO SUCH JOB NAME ERROR RETURN
	JRST ATTSER

ATTSG3:	CAME TAC,JOBNAM(DAT)
	JRST ATTSG2
	MOVE TEM,JBTSTS(DAT)
	TLNN TEM,JSEG
	JRST ATTSG2			;NOT A SEGMENT, DON'T WORRY ABOUT IT
	MOVEI TAC,1			;AMBIGUOUS SEGMENT NAME
	HRL TAC,DAT			;RETURN NUMBER OF SECOND ONE FROM TOP
	JRST ATTSER

ATTSG2:	SOJG DAT,ATTSG3			;KEEP SEARCHING
	MOVE TAC,TAC1			;NO OTHERS, GET NUMBER IN TAC
	JRST ATTSE1			;GO TRY IT

ATTSE7:	POP P,J
	MOVEI TAC,0			;GIVE PROTECTION VIOLATION ERROR
	JRST ATTSER
;DETSEG DETSE1 DETSE2 NJERR

;DETSEG  DETACH SEGMENT
; CALLING . . .
;	DETSEG AC,
; IF AC=0, THEN THE SEGMENT IS DETACHED AND PLACED INTO A LIST
; OF THE SEGMENTS THIS GUY HAS DETACHED, SUCH THAT WHEN THE
; SYSTEM CALLS RESET, ALL HIS DETACHED SEGMENTS GO AWAY. IF AC LOW
; ORDER BIT IS ON, SEGMENT WILL BE SPECIALLY DETACHED- WILL STICK AROUND
; UNTIL THE MAKER KJOBS.

↑DETSEG:PUSHJ P,ZERPR2			;TRY TO FLUSH JBTPR2, SKIP IF NONE
	JRST SEGXIT
	LDB TAC1,PSEGN
	JUMPE TAC1,CPOPJ		;NO HIGH SEGMENT HERE, HOW STRANGE!
	SKIPE AC1,JBTDTS(J)		;PUT THIS ON THE LIST OF DETACHED SEGMENTS.
	JRST DETSE1			;HE HAS A DETACHED SEGMENT LIST ALREADY.
	MOVEI AC3,JOBN			;NO, GET HIM ONE ABOUT THIS LONG.
	PUSHJ P,UFSGET
	HRRZM AC1,JBTDTS(J)
	JRST DETSE2

DETSE1:	SKIPE (AC1)			;NOW RUN DOWN TO END OF LIST
	AOJA AC1,DETSE1
DETSE2:	TRNE UCHN,1			;DOES HE HAVE THE 1-BIT ON IN THE AC FIELD?
	TLO TAC1,400000			;YES, SET SPECIAL DET SEG.
	MOVEM TAC1,(AC1)		;PUT THIS SEGMENT NUMBER IN THE TABLE
	SOSGE NJOBS(TAC1)
	PUSHJ P,NJERR
	SETZB TAC,1(AC1)		;AND MARK THE END OF LIST
	DPB TAC,PSEGN
	PUSH P,J
	MOVE TAC,J			;LOWER'S JOB NUMBER
	MOVE J,TAC1			;UPPER'S JOB NUMBER
	PUSHJ P,ZSGMAP			;FLUSH THE PAGE MAP ENTRIES FOR THE UPPER
	POP P,J
IFN FTSTAT,<
	PUSHJ P,SEGSTT
>;FTSTAT
	JRST SEGXIT

NJERR:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME FOR NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /NJOB WENT NEGATIVE AT DETSEG
/
	POPACS
	SETZM NJOBS(TAC1)
	POPJ P,
;SEGNUM SEGSIZ SEGNAM

;SEGNUM, SEGSIZ, SEGNAM

;CALL:	MOVE AC,[<JOB NUMBER>]
;	CALL AC,['SEGNUM']
;RETURNS IN AC THE JOB NUMBER OF THE SEGMENT BELONGING TO THE JOB SPECIFIED BY
;CONTENTS OF AC AT THE TIME OF THE CALL.  ZERO IS RETURNED IF THERE IS NO SEGMENT
;IF THE ARGUMENT AC IS ZERO, THIS RETURNS YOUR SEGMENT NUMBER.

↑SEGNUM:CAIL TAC,0
	CAIL TAC,JOBN
	JRST UUOERR
	CAIN TAC,0
	MOVEI TAC,(J)
	MOVEI J,(TAC)
	LDB TAC,PSEGN
	JRST STOTAC

;CALL:	CALL AC,['SEGSIZ']
;RETURNS IN AC THE HIGHEST LEGAL ADDRESS IN UPPER SEGMENT - 400000.
;RETURNS ZERO IF YOU DO NOT HAVE AN UPPER SEGMENT

↑SEGSIZ:LDB TAC,PSEGN
	JUMPE TAC,STOTAC
	HLRZ TAC,JBTPAG(TAC)
	LSH TAC,9
	JUMPE TAC,STOTAC
	SOJA TAC,STOTAC


;CALL:	CALL AC,['SEGNAM']
;THE NAME OF YOUR SEGMENT, OR 0, IS RETURNED IN AC.

↑SEGNAM:LDB TAC,PSEGN
	MOVE TAC,JOBNAM(TAC)
	JRST STOTAC
;SETNM2 SETNM3 SETNM4 JTPOPJ

; SETNM2 CALLING . . .
;	MOVE AC,[SIXBIT /<NAME YOU WISH YOUR UPPER TO HAVE>/]
;	CALL AC,[SIXBIT /SETNM2/]
;	<ERROR RETURN>
; IF YOU HAVE AN UPPER SEGMENT, GIVES IT THE NAME IN ACCUMULATOR AC.
; IF YOU DON'T HAVE AN UPPER, THIS UUO IS A NO-OP.
; UPON SUCCESS, AC IS CLEARED, UNLESS THERE IS ANOTHER SEGMENT OF THE SAME NAME,
;	 IN WHICH CASE YOU GET ITS JOB NUMBER

↑SETNM2:
	LDB TAC1,PSEGN
	JUMPE TAC1,CPOPJ1
	PUSH P,TAC
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,ACCESS
	JFCL
	JRST JTPOPJ
	POP P,TAC1
	POP P,JOBNAM(J)
IFN FTELOK,<
	MOVE DAT,JOBNAM(J)
	CAMN DAT,[SIXBIT /E/]
	MOVEM J,ESEGNO			;STORE JOB NUMBER OF E'S UPPER SEGMENT
>;IFN FTELOK
IFN FTSTAT,< PUSHJ P,NAMSTT >
	MOVEI TAC1,JOBN-1
SETNM3:	MOVE DAT,JBTSTS(TAC1)
	TLNN DAT,JSEG
	JRST SETNM4
	MOVE DAT,JOBNAM(TAC1)
	CAME TAC1,J
	CAME DAT,JOBNAM(J)
SETNM4:	SOJG TAC1,SETNM3
	XCTR XW,[MOVEM TAC1,(UCHN)]
	JRST CPOPJ1

↑JTPOPJ:POP P,J
	JRST TPOPJ
;LINKUP

;LINKUP

; THIS UUO FIRST KILLS ANY HIGH SEGMENT YOU MAY HAVE.
; CALLING . . .
;	CALL [SIXBIT /LINKUP/]
;	<NO CAN DO>
; IT THEN ATTEMPTS TO MAKE A LINKUP WITH ANY HIGH SEGMENT
; IN CORE WITH YOUR CREDENTIALS.

↑LINKUP:PUSHJ P,LINKSEG		;TRY TO GET THE SEGMENT
	 POPJ P,
	AOS (P)			;LINKSEG PUTS IT IN THE MAP IF SEG ALREADY IN CORE
	PUSHJ P,WSCHED		;MAKE SURE UPPER IS IN CORE
	JRST SEGXIT
;MXPOIN POINTS POINT2 POINT1 POINT3

; RETURNS LIST OF JOB NUMBERS WHO POINT TO YOUR UPPER SEGMENT.
; THE LIST TERMINATES WITH A ZERO
; IF YOU HAVE NO UPPER SEGMENT, ZERO IS RETURNED IN ADR
; ADR BETTER BE AT LEAST 64. WORDS LONG.
; CALLING . . .
;	POINTS ADR

MXPOIN←←100 ;Max block size required by this UUO, including zero at end
↑POINTS:
IFN FTFBI,<
	PUSHJ P,FBI
	 JFCL 4			;Feature 4 is use of POINTS UUO
>;IFN FTFBI
	LDB DAT,PSEGN
	JUMPE DAT,POINT3
	MOVEI J,JOBN-1
	HRLI UUO,1-MXPOIN	;Max number of jobs, for max block size
POINT2:	LDB TAC1,PSEGN
	CAME TAC1,DAT
	JRST POINT1
	XCTR XW,[MOVEM J,(UUO)]
	AOBJP UUO,POINT3	;Jump if no room for more jobs in table
POINT1:	SOJG J,POINT2
POINT3:	XCTR XW,[SETZM (UUO)]
	POPJ P,
;SETPRO SETP3 SETP2

; SET PROTECTION ON A HIGH SEGMENT
; CALLING . . .
;	MOVE AC,<0-8 NEW PROTECTION KEY; 30-35 SEGMENT NUMBER>
;	CALL AC,[SIXBIT /SETPRO/]
;	<NO CAN DO>
;
; IF SEGMENT NUMBER IS ZERO, REFERS TO YOUR OWN SEGMENT

↑SETPRO:
	PUSH P,TAC
	PUSH P,J		;Save current job
	LDB J,[POINT JOBNSZ,TAC,35]
	CAIL J,JOBN		;Don't assume JOBN is power of 2
	JRST JTPOPJ		;Job number too big
	JUMPN J,SETP3		;Jump if explicit job number given
	MOVE J,(P)
	LDB J,PSEGN		;Get number of own upper segment
	JUMPE J,JTPOPJ
SETP3:	CAMN J,(P)		;Allow set of protection of OWN lower segment
	JRST SETP2		;Guaranteed access (this is for copying to upper)
	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,JSEG		;Otherwise, only can set protection of an upper
	JRST JTPOPJ		;Not an upper, not own job
	PUSHJ P,ACCESS
	 JRST JTPOPJ
	 JRST JTPOPJ
	TRNE TAC,400		;PROTECTION PROTECTED?
	JRST JTPOPJ
SETP2:	MOVE TAC,-1(P)
	LSH TAC,-=27
	ANDI TAC,377		;ONLY REAL BITS
	DPB TAC,[POINT 9,JOBCRD(J),8]
	AOS -2(P)
	JRST JTPOPJ

BEND SEGUUO
;INTORM INTACM INTAPC INTENS INTIIP INTIRQ

SUBTTL	INTUUO 	;RUNMSK, INTORM, INTACM, INTENS, INTIIP, INTIRQ

;UUOS FOR NEW STYLE INTERRUPT SYSTEM

;INTORM - SET BITS IN INTERUPT ENABLE MASK

INTORM:	PUSHJ	P,INTCHK
	MOVE	AC1,TAC		;INTERRUPT BITS BEING TURNED ON
	IORB	TAC,JBTIEN(J)	;TAC MUST HAVE JBTIEN AT INTAPC
	TLNE	AC1,INTCLK
	PUSHJ	P,CLKENB	;PLANT CLOCK REQ FOR 1 TICK
	JRST	INTAPC


;INTACM - CLEARS BITS IN INTERRUPT ENABLE MASK

INTACM:	PUSHJ	P,INTCHK
	MOVE	AC1,TAC		;INTERRUPT BITS BEING TURNED OFF
	ANDCAB	TAC,JBTIEN(J)
	TLNE	AC1,INTCLK	;SKIP IF NOT CLEARING INTCLK
	JRST	INTEN1
INTAPC:	ANDI	TAC,CPUMSK
	HRRZM	TAC,APRIN2	;ONLY LEGAL BITS
	XCTR	XR,[IOR TAC,JOBENB]
	ANDI	TAC,CPUMSK!1000	;MASK THIS TOO, SINCE IT'S UNPROTECTED
	JRST	APREN2		;SET UP PROCESSOR CONO


;INTENS, INTIIP - RETURN INFORMATION

INTENS:	SKIPA	TAC,JBTIEN(J)	;RETURN STATE OF ENABLES
INTIIP:	MOVE	TAC,JBTIIP(J)	;RETURN STATE OF INTS IN PROGRESS
	JRST	STOTAC


;INTIRQ - RETURNS STATE OF PENDING INTERRUPTS

INTIRQ:	MOVE	TAC,JBTIRQ(J)
	JRST	STOTAC
;INTENB INTEN1 INTCHK INTLOS

;INTENB -  ENABLE INTERRUPTS . . .
;	MOVE AC,[MAGIC BITS]
;	CALL AC,[SIXBIT /INTENB/]

INTENB:	PUSHJ P,INTCHK		;CHECK FOR CONFLICTS BETWEEN OLD AND NEW.
	MOVE AC1,JBTIEN(J)	;OLD ENABLINGS
	MOVEM TAC,JBTIEN(J)	;NEW ENABLINGS
	XOR AC1,TAC
	TLNN AC1,INTCLK		;SKIP IF INTCLK CHANGING
	JRST INTAPC		;INTAPC NEEDS TAC = JBTIEN
	TLNN TAC,INTCLK		;SKIP IF TURNING INTCLK ON
	JRST INTEN1		;TURNING IT OFF
	PUSHJ P,CLKENB		;PLANT CLOCK REQUEST IN APRLST FOR 1 TICK
	JRST INTAPC

INTEN1:	PUSHJ P,INTAPC
	MOVSI TAC,INTCLK
	ANDCAM TAC,JBTIRQ(J)	;FLUSH PENDING CLOCK INTERRUPT
	JRST APRDKL		;KILL ANY CLOCK REQUESTS WE MIGHT HAVE

INTCHK:	TLZ TAC,INTWAIT		;UUO WAIT IS THE ONLY PROTECTED INTERRUPT BIT
	XCTR XR,[TDNN TAC,JOBENB]
	POPJ P,
INTLOS:	JSP TAC,UUOMES
	ASCIZ /Interrupt enablings conflict, UUO/
;CLKENB CLKENA CLKNB1 CLKNBL CLKNB2 CLKNB3 CLKNB4 CLKNB6 CLKNB7 CLKNB5

; CLKENB, CLKENA  - ENABLE FOR USER CLOCK INTERRUPTS
; CLKENA - SAME AS CLKENB EXCEPT TAC HAS NUMBER OF TICKS FOR REQ

CLKENB:	PUSH P,TAC
	TDZA TAC,TAC		;FLAG NOT TO STORE TIME
CLKENA:	PUSH P,TAC
CLKNB1:	CONO PI,APROFF
	SKIPN AC1,APRLST
	JRST CLKNB2		;HAVE TO CREATE APRLST BLOCK
CLKNBL:	SKIPN AC2,(AC1)		;FIND THE FIRST BLANK SPOT
	JRST CLKNB5		;END OF LIST AND THIS JOB HAS NO REQ YET
	CAIN J,(AC2)		;IS THERE AN ENTRY FOR THIS JOB?
	JRST CLKNB4
	ADDI AC1,2		;LOOP AROUND
	JRST CLKNBL

CLKNB2:	CONO PI,APRON
	MOVEI AC3,2*JOBN
	PUSHJ P,UFSGET		;GET A BLOCK OF FREE STORAGE
	SETZM (AC1)
	CONO PI,APROFF
	SKIPN APRLST		;SEE IF SOMEONE ELSE HAS MADE IT ALREADY
	JRST CLKNB3		;NO, WE STILL GET TO DO IT
	CONO PI,APRON
	PUSHJ P,FSGIVE		;FALSE ALARM
	JRST CLKNB1
CLKNB3:	MOVEM AC1,APRLST
	JRST CLKNBL

CLKNB4:	JUMPE TAC,CLKNB7	;ALREADY AN ENTRY AND DON'T CHANGE TIME
CLKNB6:	HRLM TAC,(AC1)
	MOVNM TAC,1(AC1)
CLKNB7:	CONO PI,APRON
	JRST TPOPJ

CLKNB5:	SETZM 2(AC1)		;MAKE A FRESH ENTRY
	HRRZM J,(AC1)
	JUMPN TAC,CLKNB6	;STORE NEW TIME
	AOJA TAC,CLKNB6
;DISMIS DISLOS DEBREAK DISM2 DISM1 DISM3 DISQTB NDISQS

;DISMISS, DEBREAK


DISMIS:	SKIPE	INTACT		;DISMISS - TERMINATE CURRENT I-LEVEL RUN
	JRST	DISM2
	SKIPE	SPWUUF
	JRST	SPWXIT		;MUST LEAVE THROUGH HERE!
DISLOS:	JSP	TAC,UUOMES
	ASCIZ	/I-level UUO when not at I-level, UUO/



DEBREAK:SKIPN	INTACT		;MAKE I-LEVEL PROCESS TAKE PLACE OF U-LEVEL PROCESS
	JRST	DISLOS
	SKIPA	AC1,[INTDEB]	;DISPATCH ADDRESS FOR INTDISP
DISM2:	MOVEI	AC1,INTDSM	;
DISM1:	JUMPE	UCHN,DISM3	;NONZERO AC FIELD REQUEUES JOB AS SPEC BY C(AC)
	MOVM	TAC,JOBQUE(J)
	XCTR	XR,[MOVE TAC1,(UCHN)]	;LH(AC) IS MASK FOR LEGAL SOURCE Q'S
	LSH	TAC1,(TAC)
	JUMPGE	TAC1,DISM3		;NOT IN LEGAL SOURCE Q
	XCTR	XR,[HRRZ TAC,(UCHN)]	;GET NEW CODE
	CAIL	TAC,NDISQS
	JRST	DISM3			;OUT OF BOUNDS
	MOVE	TAC,DISQTB(TAC)
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
↑DISM3:	SYSPIFF			;AVOID EXTRANEOUS CLK INTS
	MOVEM AC1,INTDISP
	HLLOS CLKFLG		;MAKE SURE CH7 KNOWS WE'RE COMING!
	SETZM PIOFFS
	CONO PI,PION!1B24!1⊗(7-CLKCHN)
	CONO PI,PION
	HALT .+1
	JRST CLKINT

DISQTB:	TQ		;THESE ARE POSITIVE SO THEY WON'T GENERATE QXFER INTS
	RUNQ
	INTWQ
	IOWQ
NDISQS←←.-DISQTB
;INTGEN INTGN1 USKIP UWAIT UWAIT1 UWNPC IWAIT

;INTGEN, USKIP, UWAIT, IWAIT


INTGEN:	SETCM	AC1,JBTIEN(J)		;GENERATE AN INTERRUPT FOR YOURSELF
	TDNN	AC1,TAC
	JRST	INTGN1
	JSP	TAC,UUOMES
	ASCIZ	/Intgen of non-enabled interrupt, UUO/

INTGN1:	IORM	TAC,JBTIRQ(J)
	TDNE TAC,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM	INTREQ		;YES, REQUEST RUNNING INTERRUPTS
	SKIPN	INTACT
	JRST	WSCHED
	POPJ	P,


USKIP:	SKIPN	INTACT			;TELL USER IF HE IS INSIDE A UUO
	JRST	DISLOS			;ILLEGAL WHEN NOT AT INT LEVEL
	MOVE	AC1,USRPC		;PC OF SUSPENDING MAIN JOB
	TLNN	AC1,USRMOD
	AOS	(P)			;IN EXEC MODE.  MAKE UUO SKIP.
	POPJ	P,


;WAITS FOR UUO THAT WAS INTERRUPTED TO TERMINATE

UWAIT:	PUSHJ	P,USKIP		;SKIP IF INTERRUPTED OUT OF A UUO, RETURNING
	JRST	UWNPC		; IN AC1 THE PC OF THE SUSPENDED PROCESSES
	MOVE	DSER,JBTSTS(J)	; HE HAS BEEN REQUEUED IF HE IS IN INTERRUPT WAIT,
				; NOW CHECK FOR SLEEPING.
	TLNE	DSER,CLKR	; DOES HE HAVE A SLEEP REQUEST IN?
	PUSHJ	P,UWAIT1	; YES, GO WAKE HIM UP
	MOVSI	AC1,INTWAIT
	IORM	AC1,JBTIEN(J)
	IORM	AC1,JBTMSK(J)
	MOVE	AC1,UUOPC(J)
	MOVEM	AC1,JBTUPC(J)	;USER ADDRESS AFTER UWAIT
	JRST	DISMIS

UWAIT1:	MOVE	TAC,J		;SIMULATE UUO LEVEL CALL BY PUTTING JOB NUMBER IN TAC
	JRST	WAKE

UWNPC:	XCTR	XW,[MOVEM AC1,JOBTPC]	;STORE TRAP PC.
	MOVE	AC1,[JOBDAC,,JOBAC]	;MOVE DUMP ACS (20-37) TO REAL ACS (0-17)
	XCTR	XBLTRW,[BLT AC1,JOBAC+17]	;ACS WILL BE RESTORED UPON EXIT.
	POPJ	P,


IWAIT:	MOVEI	AC1,INTWQ	;WAIT UNTIL AWAKENED BY AN APPROPRIATE INTERRUPT
	MOVNM	AC1,JOBQUE(J)
	JRST	WSCHED
;IENBW INTMSK IMCALL IMSKST IMSKCL

;IENBW, INTMSK, IMCALL, IMSKST, IMSKCL


;ENABLE INTERRUPTS AND THEN GO INTO INTERRUPT WAIT.
;CALL:	MOVE AC,[<INTERRUPT BITS>]
;	CALL AC,[SIXBIT /IENBW/]
;YOU ARE NOW IN INTERRUPT WAIT.

IENBW:	MOVEI	AC1,INTWQ	;PUT US IN INTERRUPT WAIT
	MOVNM	AC1,JOBQUE(J)
	PUSHJ	P,INTENB	;ENABLE INTERRUPTS
	JRST	WSCHED		;WAIT.



;UUO TO SET THE INTERRUPT MASK
;CALL:	INTMSK [<MASK BITS>]

INTMSK:	XCTR	XR,[MOVE AC1,(UUO)]
	MOVEM	AC1,JBTMSK(J)
IMCALL:	SKIPN	INTACT		;DON'T CALL WSCHED IF ALREADY AT I-LEVEL
	TDNN	AC1,JBTIRQ(J)	;DOES HE HAVE ANY INTERRUPTS PENDING?
	POPJ	P,
	SETOM	INTREQ		;YES, GIVE THEM
	JRST	WSCHED



IMSKST:	XCTR	XR,[MOVE AC1,(UUO)]	;SET BITS IN THE MASK
	IORM	AC1,JBTMSK(J)
	JRST	IMCALL

IMSKCL:	XCTR	XR,[MOVE AC1,(UUO)]	;CLEARS BITS IN THE MASK
	ANDCAM	AC1,JBTMSK(J)
	POPJ	P,
;CLKUUO CLKUU2

; CLKINT UUO  (CLKUUO) START UP A CLOCKED I-LEVEL JOB
; CALLING . . .
;	CLKINT TIX
; TIX IS THE TIME IN TICKS BETWEEN STARTUPS
; IF TIX IS ZERO, ANY CLOCKED JOB IS FLUSHED

CLKUUO:	TRNN UUO,-1		;ZERO TIX?
	JRST CLKUU2		;YES, GO KILL JOB
	MOVSI TAC,INTCLK
	IORM TAC,JBTIEN(J)	;ENABLE CLOCK INTERRUPTS
	ANDCAM TAC,JBTIRQ(J)	;FLUSH PENDING OLD CLOCK INTERRUPT
	HRRZ TAC,UUO
	JRST CLKENA		;PLANT THE CLOCK REQUEST

CLKUU2:	PUSHJ P,APRDKL		;KILL CLOCK REQUEST
	MOVSI TAC,INTCLK
	ANDCAM TAC,JBTIEN(J)
	ANDCAM TAC,JBTIRQ(J)
	POPJ P,
;INTUUO INTMXU INTDEJ IMSTW

;INTUUO - INTDEJ, IMSTW
; MULTI-PURPOSE INTERRUPT UUO

INTUUO:	CAILE UCHN,INTMXU
	JRST UUOERR
	JRST @INTUTB(UCHN)

DEFINE UUOS{FOR X IN(INTDEJ,IMSTW,IWKMSK,INTDMP,INTIPI,IMSKCR,IRUMSK,IRUMST,IRUMCL)}

PSHSYS
LOSYS

UUOMAC INTUTB,INTUUO
INTMXU←←UUOCNT

POPSYS


; RESET INTERRUPT MASK AND JUMP TO ADDRESS UUO.
; CALLING . . .
;	INTDEJ ADR
; WITH THE FOLLOWING DATA . . .
; ADR:	<INTERRUPT BITS TO BE ORED INTO MASK>
;	<PC WORD TO GO TO>
; THIS UUO DOES NOT RETURN, BUT INSTEAD JUMPS TO THE ADDRESS

INTDEJ:	XCTR XR,[MOVE TAC,1(UUO)];FETCH PC WORD
	TLO TAC,USRMOD		; KEEP THE LOSER OUT OF THE SYSTEM
	PUSH P,TAC
	PUSHJ P,IMSKST		; OR IN MASK BITS
	POP P,UUOPC(J)		; SET UP RETURN ADDRESS
	POPJ P,			; RETURN TO LOSER

; SET MASK FROM FIRST WORD OF UUO AND GO INTO WAIT STATE.
; CALLING . . .
;	IMSTW ADR
;
; ADR:	<MASK BITS>

IMSTW:	MOVEI AC1,INTWQ		; PUT US INTO INTERRUPT WAIT FIRST
	MOVNM AC1,JOBQUE(J)
	PUSHJ P,INTMSK		; SET THE MASK
	JRST WSCHED		; DO THE WAIT STATE THING.
;IWKMSK IMSKCR IRUMSK IRUMST IRUMCL

; IWKMSK, IMSKCR
; SET MASK THAT ALLOWS THE MAIN JOB TO BE AWAKENED
; FROM IWAIT QUEUE.
; CALLING . . .
;	IWKMSK ADR
;
; ADR:	<INTERRUPT BITS WHICH SHOULD AWAKEN>

IWKMSK:	XCTR XR,[MOVE TAC,(UUO)]
	MOVEM TAC,JBTWKM(J)
	POPJ P,

;CLEAR SPECIFIED BITS OF MASK (PDP-10 ONLY) AND RETURN OLD MASK
;CALL:
;	IMSKCR ADR
;
;ADR:	BITS TO TURN OFF IN MASK, REPLACED BY OLD MASK VALUE

IMSKCR:	MOVE TAC,JBTMSK(J)
	XCTR XR,[ANDCM TAC,(UUO)]
	EXCH TAC,JBTMSK(J)
	JRST STOTAC

IRUMSK:	XCTR XR,[MOVE TAC,(UUO)] ;get user's bits
	MOVEM TAC,JBTIRU(J)	 ;store for user's job
	POPJ P,

IRUMST:	XCTR XR,[MOVE TAC,(UUO)] ;get user's bits
	IORM TAC,JBTIRU(J)	 ;set for user's job
	POPJ P,

IRUMCL:	XCTR XR,[MOVE TAC,(UUO)] ;get user's bits
	ANDCAM TAC,JBTIRU(J)	 ;clear for user's job
	POPJ P,
;INTDMP

;INTDMP
;UUO TO RETURN INFORMATION ABOUT A PARTICULAR JOB'S INTERRUPT CONDITION.
;CALL:	INTDMP ADR
;	<FAILURE - ERROR CODE IN ADR+1>
;	<SUCCESS>
;
;	BEFORE				AFTER
;ADR:	<JOB NUMBER OR JOB NAME>	same
;ADR+1:					<ENABLE BITS, OR ERROR CODE>
;					<P1 INTERRUPT MASK>
;					0
;					<WAKEUP MASK>
;					<JOB QUEUE>
;ERROR CODES RETUNED IN ADR+1 ARE:
;	1  JOB NOT LOGGED IN
;	2  AMBIGUOUS JOB NAME
;	3  NON-EX JOB NAME

INTDMP:	JSP AC3,GXJOBN			;TAC←JOB NUMBER FROM JOB NUMBER OR JOB NAME
	MOVE AC1,JBTIEN(TAC)		;GIVE THE GUY HIS ENABLE BITS
	XCTR XW,[MOVEM AC1,1(UUO)]
	MOVE AC1,JBTMSK(TAC)		;AND HIS PROCESSOR MASKS
	XCTR XW,[MOVEM AC1,2(UUO)]
	MOVE AC1,JBTIRU(TAC)		;his interrupt run mask
	XCTR XW,[MOVEM AC1,3(UUO)]
	MOVE AC1,JBTWKM(TAC)		;HIS WAKEUP MASK
	XCTR XW,[MOVEM AC1,4(UUO)]
	MOVM AC1,JOBQUE(TAC)		;AND HIS CURRENT QUEUE
	XCTR XW,[MOVEM AC1,5(UUO)]
	JRST CPOPJ1			;GIVE SUCCESS RETURN
;INTDR1 INTDR2 INTDR3 INTDR4 INTDR5 INTDR6 INTDRX GXJOBN GXJOB2 GXJOB3 GXJOB4 GXJOB5 GXJOB6 GXJOB7 GXJOB0

;GXJOBN.  INTDR1,INTDR2, ETC.

INTDR1:	JSP AC1,INTDRX
INTDR2:	JSP AC1,INTDRX
INTDR3:	JSP AC1,INTDRX
INTDR4:	JSP AC1,INTDRX
INTDR5:	JSP AC1,INTDRX
INTDR6:	JSP AC1,INTDRX
INTDRX:	MOVEI AC1,-INTDR1(AC1)	;CONVERT STORED PC TO INDEX.
	XCTR XW,[MOVEM AC1,1(UUO)]
	POPJ P,

;JOB NUMBER OR NAME TO JOB NUMBER.  CALL VIA JSP AC3,GXJOBN
;CALL WITH (UUO) POINTING TO ADDRESS WHERE WE CAN FIND A JOB NAME OR NUMBER.
;RETURNS JOB NUMBER IN TAC.  ERRORS CALL INTDR1, INTDR2, OR INTDR3.

GXJOBN:	XCTR XR,[MOVE TAC,(UUO)];PICK UP JOB NUMBER OR NAME.
	CAIGE TAC,JOBN
	JUMPGE TAC,GXJOB0	;JUMP IF JOB NUMBER WAS GIVEN
	MOVEI AC1,JOBN-1
GXJOB2:	CAME TAC,JOBNAM(AC1)
GXJOB3:	SOJG AC1,GXJOB2		;LOOP LOOKING FOR MATCH.
	JUMPLE AC1,INTDR3	;JUMP IF NON-EX NAME
	MOVE AC2,JBTSTS(AC1)	;FOUND A MATCH.  MAKE SURE IT'S NOT A SEGMENT.
	TLNE AC2,JNA		;SKIP IF LOSING
	TLNE AC2,JSEG		;SKIP IF WINNING
	JRST GXJOB3		;KEEP LOOKING.
	SKIPA AC2,AC1		;SAVE THE JOB NUMBER WE LIKED.
GXJOB4:	CAME TAC,JOBNAM(AC1)
GXJOB5:	SOJG AC1,GXJOB4		;MAKE SURE THERE'S NO AMBIGUITY.
	JUMPLE AC1,GXJOB7	;JUMP IF WINNING.
	PUSH P,TAC
	MOVE TAC,JBTSTS(AC1)
	TLNE TAC,JNA
	TLNE TAC,JSEG
	JRST GXJOB6		;IGNORE THIS MATCH.  NOT LOGGED IN, OR SEGMENT
	SUB P,[1,,1]
	JRST INTDR2		;AMBIGUOUS NAME.

GXJOB6:	POP P,TAC
	JRST GXJOB5

GXJOB7:	MOVE TAC,AC2
	JRST (AC3)

GXJOB0:	SKIPG TAC		;SKIP IF NON-ZERO JOB NUMBER
	MOVE TAC,J		;FOR ZERO JOB NUMBER, USE HIS OWN JOB.
	MOVE AC2,JBTSTS(TAC)
	TLNN AC2,JNA
	JRST INTDR1		;ERROR 1.  BAD JOB NUMBER.
	JRST (AC3)		;RETURN.
;INTIPI

;INTIPI
;INTER-PROCESS INTERRUPT SYSTEM
;CALL:	INTIPI	ADR
;	<ERROR RETURN.  ERROR CODE RETURNED IN ADR+1>
;	<SUCCESS RETURN>
;
;ADR:	<JOB NUMBER OR NAME>
;ADR+1:	<INTERRUPT BITS FOR THAT JOB>
;
;ERROR CODES RETUNED IN ADR+1 ARE:
;	1  JOB NOT LOGGED IN
;	2  AMBIGUOUS JOB NAME
;	3  NON-EX JOB NAME
;	4  JOB IS NOT ENABLED FOR THOSE INTERRUPTS

INTIPI:	JSP AC3,GXJOBN			;TAC←JOB NUMBER, ELSE ERROR RETURN.
	XCTR XR,[MOVE AC1,1(UUO)]	;INTERRUPT BITS
	SETCM AC2,JBTIEN(TAC)
	TDNE AC1,AC2
	JRST INTDR4			;ERROR - CLASS4
	IORM AC1,JBTIRQ(TAC)
	TDNE AC1,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, RUN INTERRUPTS
	JRST CPOPJ1
SUBTTL UUOCON - STANFORD SPECIAL IO ROUTINES ;⊗ CHNSTS BUFLEN BLKLEN

;UUO TO GET USE BITS FOR A CHANNEL
;	CHNSTS <CHANNEL NUMBER>,ADR
;PUTS USRJDA IN ADR, 0 FOR UNUSED.

CHNSTS:	CAMLE UCHN,USRHCU
	TDZA TAC,TAC
	HLRZ TAC,USRJDA(UCHN)
	JRST STOTAC

;THIS UUO GETS THE STANDARD BUFFER LENGTH FOR A DEVICE
;	MOVE AC,[DEVICE NAME IN SIXBIT]
;	CALL AC,[SIXBIT /BUFLEN/]
;	<RETURNS HERE WITH BUFFER LENGTH, OR 0, IN AC>

BUFLEN:	PUSHJ P,FNDDDB		;LOOK FOR DEVICE WITH THIS NAME (OR CHANNEL #)
	JRST RTZERO		;GIVE BACK A ZERO IF NOT FOUND
	LDB TAC,PDVBLN		;RETURN BUFFER LENGTH
	JRST STOTAC

;BLKLEN UUO (CALLI 400134).  Usage (very similar to BUFLEN UUO):
;	MOVE AC,[<device name in sixbit, or channel number>]
;	BLKLEN AC,
;Returns  <optimum buffer count>,,<block length in words>  in AC.
;Returns 0 if no such device, or device not a disk.

BLKLEN:	PUSHJ P,FNDDDB		;Look for device with this name or channel #
	JRST RTZERO		;Return 0 if not found
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVDSK		;Is it a disk?
	JRST RTZERO		;No, return 0
IfStructure,<
	MOVE TAC,SDBPTR(DDB)	;Get SDB address
	MOVE TAC,ST.RPB(TAC)	;Get records per block
	IMUL TAC,[1,,RECSIZ]	;<records/block>,,<words/block>
	ADD TAC,[1,,0]		;Optimum buffer count in LH
>;IfStructure
NoStructure,<
	MOVE TAC,[RCPBLK+1,,BKDSIZ]
>;NoStructure
	JRST STOTAC
;NAMEIN NAMINL NAMEI1 NAMEI2 NAMEI4 NAMEI3 NAMEI5

;NAMEIN NAMINL

; NAMEIN - RETURNS A CODE TELLING WHETHER A JOB NAME IS LOGGED IN
;	MOVE AC,[<JOB NAME IN SIXBIT>]
;	CALL AC,[SIXBIT /NAMEIN/]
;	<NO SUCH JOB - ERROR CODE IN AC>
;
; ERROR CODE IS 3 FOR MULTIPLY DEFINED JOB NAME, 1 FOR NO SUCH NAME

NAMEIN:	PUSHJ P,NAMINL
	CAIA
	AOS (P)
	JRST STOTAC

↑NAMINL:MOVEI TAC1,JOBN-1	;FORMERLY CALLED FROM IMPSER TO FIND THE LOGGER
NAMEI1:	CAME TAC,JOBNAM(TAC1)	; IS THIS IT?
NAMEI2:	SOJG TAC1,NAMEI1
	JUMPN TAC1,NAMEI4
	MOVEI TAC,1
	POPJ P,			; NO SUCH NAME, GIVE ERROR 1 RETURN

NAMEI4:	MOVE AC1,JBTSTS(TAC1)
	TLNN AC1,JNA		; NOW, IS IT A JOB?
	JRST NAMEI2
	MOVE AC2,TAC1		;GIVE BACK JOB NUMBER
NAMEI3:	SOJLE TAC1,NAMEI5	; SEARCH REMAINDER OF NAMES FOR MATCH
	CAME TAC,JOBNAM(TAC1)
	JRST NAMEI3
	MOVE AC1,JBTSTS(TAC1)
	TLNN AC1,JNA
	JRST NAMEI3
	MOVEI TAC,3
	POPJ P,

NAMEI5:	MOVE TAC,AC2
	JRST CPOPJ1		; SKIP RETURN WITH THE JOB NUMBER IN TAC
;FILUSW FILUSR FILUS1 FILUS2 FILUS3 FILUS9

;UUO TO FIND WHICH JOB(S) USING A DISK FILE
;
;CALL:	MOVEI AC,ARGS
;	FILUSR AC,
;	 <ERROR RETURN - NOT A DISK DEVICE>
;	<NORMAL RETURN>
;	...
;ARGS:	SIXBIT /DEV/	MUST BE DISK OR NEW-STYLE UDP, 0 MEANS DSK
;	SIXBIT /NAME/
;	SIXBIT /EXT/
;	BLK
;	SIXBIT /PPN/
;	...
;BLK:	BLOCK =16
;
;RETURNS IN BLK A LIST OF JOB NUMBERS, IN 18-BIT BYTES, TERMINATED
;WITH A ZERO BYTE.  THE 400000 BIT OF A BYTE INDICATES THAT THAT JOB
;IS WRITING (INCLUDING R/A) THE FILE.  The 370000 BITS ARE UNUSED BUT
;PROGRAMS SHOULDN'T RELY ON THAT.  If more than =31 jobs have the file
;open, only =31 job numbers are returned (plus a zero byte).
FILUSW←←400000	;Bit in returned job-number byte that means file being written
FILUWD←←=16	;Max size block we'll use in returning job-number bytes
FILBPW←←2	;Number of job-number bytes per word returned (18-bit bytes)

FILUSR:	XCTR XR,[SKIPN TEM,(TAC)]	;GET ARGS: DEVICE
	 MOVSI TEM,'DSK'		; WITH DEFAULT
	XCTR XR,[MOVE AC1,1(TAC)]	;NAME
	XCTR XR,[HLLZ AC2,2(TAC)]	;EXT
	XCTR XR,[MOVE UUO,3(TAC)]	;RESULT BLOCK ADDR
	XCTR XR,[MOVE AC3,4(TAC)]	;PPN
	MOVE TAC,TEM			;DEVICE NAME IN TAC
	PUSHJ P,DEVSRC			;FIND A DDB FOR IT
	 POPJ P,			;SORRY NO SUCH DEVICE
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVDSK			;IS THIS DEVICE A DISK?
	POPJ P,				;NO, SORRY AGAIN
	HRLI UUO,442200			;MAKE 18-BIT BPT
	MOVE DSER,UUO			;WE NEED A COPY OF IT
	MOVEI TAC1,0
	XCTR XDB,[IDPB TAC1,UUO]	;START THE LIST WITH A ZERO
	MOVEI DAT,FILUWD*FILBPW-1	;MAX NUMBER OF JOBS WE'LL REPORT
	HLRZ DDB,DEVLST			;START THROUGH DDBS
FILUS1:	CAMN TEM,DEVNAM(DDB)		;RIGHT DEVICE?
	CAME AC1,DEVFIL(DDB)		;RIGHT FILENAME?
	JRST FILUS9			;NO
	HLLZ TAC,DEVEXT(DDB)
	CAMN TAC,AC2			;RIGHT EXT?
	CAME AC3,FILPPN(DDB)		;RIGHT PPN?
	JRST FILUS9			;NO
	LDB TAC1,PJOBN			;YES, GET JOB OWNING THIS DDB
	JUMPE TAC1,FILUS9		;IGNORE STRANGE JOBLESS DDB
	MOVE TAC,DEVIOS(DDB)
	TLNN TAC,READB!ALTERB!WRITEB	;FILE CURRENTLY OPEN?
	JRST FILUS9			;NO, IGNORE FILE
	MOVE UUO,DSER			;GET BPT TO USER RESULT BLOCK
FILUS2:	XCTR XLB,[ILDB TAC,UUO]		;LOOP THROUGH PREVIOUSLY SAVED JOBS
	JUMPE TAC,FILUS3		;JUMP IF NOT PREVIOUSLY FOUND
	ANDI TAC,JOBNMK			;GET JUST JOB NUMBER
	CAIE TAC,(TAC1)			;SAME AS NEW JOB?
	JRST FILUS2			;NO, KEEP LOOKING
	XCTR XLB,[LDB TAC,UUO]		;YES, GET FLAG BIT BACK
FILUS3:	TRNN TAC,JOBNMK			;Skip if we're replacing an existing byte
	SOJL DAT,FILUS9			;Jump if no more room for new bytes
	HLL TAC,DEVIOS(DDB)
	TLNE TAC,ALTERB!WRITEB		;FILE BEING WRITTEN?
	TRO TAC1,FILUSW			;YES
	IORI TAC1,(TAC)			;IOR THE WRITTEN FLAGS (OLD AND NEW)
	XCTR XDB,[DPB TAC1,UUO]		;SAVE FOR USER PROGRAM
	MOVEI TAC1,0
	TRNN TAC,JOBNMK			;ARE WE REPLACING AN EXISTING JOB NO BYTE?
	XCTR XDB,[IDPB TAC1,UUO]	;NO, MUST REPLACE ZERO BYTE AT END
FILUS9:	HLRZ DDB,DEVSER(DDB)		;GET NEXT DDB
	JUMPN DDB,FILUS1		; IF ANY
	JRST CPOPJ1
;DEVUSE DEVUS1 DEVUS2 DEVUS3 DEVUS4 DEVUS5 DEVUS6 DEVUS7

; DEVUSE - HOW MANY JOBS ARE WAITING FOR A PARTICULAR DEVICE.
; CALLING . . .
;	MOVE AC,<DEVICE NAME>
;	CALL AC,[SIXBIT /DEVUSE/]
; RETURNS NUMBER OF JOBS WAITING FOR THIS DEVICE IN AC (NOT INCLUDING YOUR JOB)

DEVUSE:	PUSHJ	P,FNDDDB	; PICK UP DEVICE DATA BLOCK ADDRESS
	JRST	RTZERO		; NO SUCH DEVICE, NOBODY WAITING FOR IT!
	MOVEI	AC1,JOBN-1	; PREPARE TO SCAN JOB TABLES
	SETZ	TAC,
	MOVE	TAC1,DEVNAM(DDB); JBTDVW NOW HAS DEVICE NAME
DEVUS1:	CAME	TAC1,JBTDVW(AC1); IS THIS THE DEVICE?
DEVUS2:	SOJG	AC1,DEVUS1	; NO, LOOP AROUND
	JUMPE	AC1,DEVUS3	; RETURN ARGUMENT AND LEAVE
	CAIN	AC1,(J)
	JRST	DEVUS2		; DON'T COUNT YOURSELF.
	MOVE	AC2,JBTSTS(AC1)	; SEE IF THE JOB EXISTS
	MOVM	AC3,JOBQUE(AC1)	; AND IF IT IS IN DEVICE WAIT
	TLNE	AC2,JNA
	CAIE	AC3,DWQ
	JRST	DEVUS2
	AOJA	TAC,DEVUS2	; BUMP COUNT AND LOOP BACK

DEVUS3:	MOVE	TAC1,DEVMOD(DDB)
	TLNE	TAC1,DVUDP
	JRST	DEVUS4		;COMPLICATED FOR UDP
	LDB	AC1,PJOBN	;GET JOB NUMBER OF DEVICE OWNER
	TLNE	TAC1,TTYATC
	TRO	AC1,100000
	TRNE	TAC1,ASSCON
	TRO	AC1,400000
	TRNE	TAC1,ASSPRG
	TRO	AC1,200000
	HRL	TAC,AC1
IFN FTP2,<
	MOVE TAC1,DEVCMR(DDB)	;SEE IF THIS IS A P2 DEVICE
	TLNE TAC1,DEVP2		;SKIP IF NOT P2 DEVICE
	SKIPE DETFLG		;P2 DEVICE, SKIP IF P2 NOT RUNNING
	JRST STOTAC		;NOTHING SPECIAL FOR THIS DEVICE
	TLO TAC,400000		;NO P2, MAKE DEVICE APPEAR DETACHED FROM SYSTEM
>;IFN FTP2
	JRST	STOTAC

DEVUS4:
NoStructure,<
	LDB AC1,PUNIT		;UDP, SCAN ALL DDBS FOR ASSCON, ASSPRG
	HRRZ AC2,DKDBML(AC1)	;MODEL DDB FOR THIS UDP
>;NoStructure
IfStructure,<
	MOVE AC1,SDBPTR(DDB)	;get the SDB address
	HRRZ AC2,ST.MDB(AC1)	;get the address of the model DDB from SDB
>;IfStructure
	SKIPA AC3,DEVNAM(AC2)	;BH 5/22/75 CHECK MODEL DDB IN CASE SWAPPING
DEVUS5:	HLR AC2,DEVSER(AC2)
	CAME AC3,DEVNAM(AC2)
	JRST DEVUS7		;NO MORE DDBS
	MOVE TAC1,DEVMOD(AC2)
	TRNE TAC1,ASSCON
	TLO AC2,400000
	TRNE TAC1,ASSPRG
	TLO AC2,200000
	LDB AC1,[POINT JOBNSZ,DEVJBN(AC2),JOBNPS]
	CAIE AC1,(J)		;EXTRA BITS FOR UDP ONLY,
	JRST DEVUS6		;NAMELY ASSCON AND ASSPRG FOR YOUR OWN JOB
	TRNE TAC1,ASSCON
	TLO AC2,40000
	TRNE TAC1,ASSPRG
	TLO AC2,20000
	JRST DEVUS5

DEVUS6:	TRNE TAC1,ASSCON	;AND SEPARATELY FOR OTHER JOBS
	TLO AC2,10000
	TRNE TAC1,ASSPRG
	TLO AC2,4000
	JRST DEVUS5

DEVUS7:	HLRZ AC1,AC2		;FLAGS INTO AC1
	TRO AC1,2000		;THIS IS PRIVATE OWNERSHIP FLAG
NoStructure,<
	LDB TAC1,PUNIT		;GET UDP NUMBER
	SKIPGE UDPOWN-1(TAC1)	;SKIP IF PRIVATE
	TRZA AC1,2000		;PUBLIC, TURN OFF PRIVATE FLAG
	ADD AC1,UDPOWN-1(TAC1)	;JOB NUMBER OF OWNER OR 0 FOR PUBLIC
>;NoStructure
IfStructure,<
	MOVE TAC1,SDBPTR(DDB)	;Get SDB address from DDB
	SKIPGE ST.JOB(TAC1)	;SKIP IF PRIVATE or job zero
	TRZA AC1,2000		;PUBLIC, TURN OFF PRIVATE FLAG
	ADD AC1,ST.JOB(TAC1)	;JOB NUMBER OF OWNER OR 0 FOR PUBLIC
>;IfStructure
	HRL TAC,AC1
	JRST STOTAC
;JOBRD JOBRDX JOBRDY JOBRCK JOBRCQ JRDBLT JRDBL1 JRDWIN JRDLEV JRDLOS JOBRC3 JOBRC1 JOBRC2 JOBRC4

;COPY DATA FROM SOME OTHER JOB'S CORE IMAGE TO YOURS.
;CALL:	MOVEI AC,ADR
;	CALL AC,['JOBRD ']
;	<ERROR - CODE IN ADR+1>
;
;ADR:	<JOB NAME OR NUMBER>
;	<-NWDS,,HISADR>
;	<ADDRESS IN YOUR CORE IMAGE WHERE YOU WANT THE DATA>
;
;ON ERROR RETURN, ADR+1 CONTAINS AN ERROR CODE:
;	1  JOB NOT LOGGED IN
;	2  AMBIGUOUS JOB NAME
;	3  NON-EX JOB NAME
;	4  ADDRESS OUT OF BOUNDS
;	5  JOB DISAPPEARED
;	6  BLOCK TOO LARGE

JOBRD:	HRR UUO,TAC			;PUT DATA BLOCK ADDRESS IN UUO
	SKIPE AC1,JBTFS(J)		;RETURN ANY FREE STORAGE HE MIGHT HAVE.
	PUSHJ P,FSGIVE
	SETZM JBTFS(J)
	XCTR XR,[HLRO TAC,1(UUO)]	;PICK UP LENGTH OF TRANSFER
	CAMGE 1,[-2000]			;MORE THAN ONE K?
	JRST INTDR6			;YES. ERROR 6.  BLOCK TOO LARGE
	JSP AC3,GXJOBN			;TAC←JOB NUMBER.
	EXCH TAC,J			;PRVCHK EXPECTS JOB IN J
	PUSHJ P,PRVCHK
	 JRST [	EXCH TAC,J
		JRST INTDR4]		;REPORT ADDRESS OUT OF BOUNDS
	EXCH TAC,J			;RESTORE ARGUMENT
	XCTR XR,[HLRO AC3,1(UUO)]	; PICK UP WORD COUNT
	MOVN AC3,AC3
	ADDI AC3,1			;WE NEED ONE OVERHEAD WORD.
	PUSHJ P,UFSGET
	HRL AC1,TAC			;STORE JOB TO READ FROM IN LH. OF JBTFS.
	MOVEM AC1,JBTFS(J)		;SOURCE JOB,,FREE STORAGE ADDRESS
	XCTR XR,[MOVE AC2,1(UUO)]
	MOVEM AC2,(AC1)			;STORE SOURCE IOWD IN FS BLOCK.
	MOVE DAT,J			;ARG IS JOB NUMBER
	HRLI DAT,JOBRCK			;ROUTINE TO CALL
	PUSHJ P,DPYTIM			;ENTER CLOCK REQUEST.
JOBRDX:	MOVNI AC3,IOWQ			;WAIT FOR IT TO HAPPEN.
	MOVEM AC3,JOBQUE(J)
	PUSHJ P,WSCHED			;DELAY.
	SKIPN AC1,JBTFS(J)		;IS FS. BLOCK STILL THERE?
	JRST INTDR4			;NO.  GIVE ILL ADDR ERROR (CROCK)
	SKIPGE (AC1)			;DONE YET?
	JRST JOBRDX			;NO, WAIT AGAIN
	SKIPE TAC,(AC1)			;WAS THERE AN ERROR?
	JRST JOBRDY			;RETURN ERROR CODE TO USER.
	MOVEI TAC1,1(AC1)		;SOURCE ADDRESS OF BLT
	XCTR XR,[HLRO AC3,1(UUO)]	;WC OF BLT
	MOVN AC3,AC3
	SUBI AC3,1
	XCTR XR,[HRRZ AC2,2(UUO)]	;PICK UP ADDRESS IN HIS CORE
	ADD AC3,AC2			;ENDING ADDR. OF TRANSFER
	HLRZ AC1,JBTPAG(J)
	LSH AC1,9			;NUMBER OF WORDS IN OUR CORE IMAGE
	MOVEI TAC,4			;ASSUME ERROR CODE 4.
	CAIGE AC2,(AC1)
	CAIL AC3,(AC1)
	JRST JOBRDY			;ADDRESS CHECK. TAC=4.  RETURN ERROR CODE.
	HRLI AC2,(TAC1)			;SOURCE ADDRESS TO LH OF BLT AC
	XCTR XBLTW,[BLT AC2,(AC3)]	;DO THE TRANSFER.  FREE STG. TO USER.
	AOSA (P)			;WIN! SET SKIP RETURN.  SKIP STORE OF ERROR
JOBRDY:	XCTR XW,[MOVEM TAC,1(UUO)]	;STORE ERROR CODE
	MOVE AC1,JBTFS(J)
	SETZM JBTFS(J)
	JRST FSGIVE			;RETURN BLOCK

;FREE STORAGE BLOCK LOCATIONS
;	BEFORE			AFTER
;0	-WC,,MA TO READ		0=SUCCESS, POSITIVE=ERROR
;1	RANDOM			DATA TO END OF BLOCK
;2					.

;HERE AT CLOCK LEVEL  (FROM DPYSER CLOCK QUEUE)

JOBRCK:	HRRZ J,DAT		;J←JOB NUMBER OF READER.
	SKIPN TEM,JBTFS(J)	;DID FREE STORAGE BLOCK GO AWAY?
	POPJ P,			;YES, DISAPPEAR.   (↑C KJOB HAPPENED)
	HLRZ TAC,TEM		;GET JOB # WE ARE READING
	MOVE AC1,JBTSTS(TAC)
	TLNN AC1,JNA		;IS JOB STILL THERE?
	JRST JOBRC3		;NO, ERROR
	TLNN AC1,SWP		;SWAPPED OUT?
	JRST JRDBLT		;NO.  READ DATA NOW.
JOBRCQ:	MOVE J,TAC		;TRANSFER CONTROL TO SWAP IN LIST
	MOVSI TAC,JRDSNB
	JRST SETSIN


;HERE, TAC=JOB TO READ FROM.  J=JOB TO WRITE IN.
JRDBLT:	SKIPN TEM,JBTFS(J)	;MAKE SURE FS BLOCK EXISTS
	POPJ P,
	HRRZ AC2,(TEM)		;PICK UP STARTING ADDRESS
	HLRO AC3,(TEM)		;AND WORD COUNT
	MOVNS AC3
	HLRZ AC1,JBTPAG(TAC)
	LSH AC1,9
	ADDI AC3,(AC2)
	SUBI AC3,1		;AC3←ENDING ADDR IN SOURCE CORE IMAGE
	CAIL AC3,(AC1)
	JRST JOBRC1		;ADDRESS ERROR.
	PUSH P,J
	MOVE J,TAC		;J←JOB NUMBER OF SOURCE JOB
	PUSHJ P,JRDBL1		;NEED PUSHJ HERE FOR MAPSET
	POP P,J
	JRST JOBRC2

JRDBL1:	PUSHJ P,MAPSET
	SUBI AC3,-1(AC2)	;BACK UP TO JUST WORD COUNT - 1
	HRLI AC2,1(TEM)		;PREPARE TO MOVE DATA
	MOVS AC2,AC2
	ADD AC3,TEM		;AC3←ENDING ADDRESS.
	XCTR XBLTR,[BLT AC2,(AC3)]	;COPY FROM SOURCE JOB TO FREE STORAGE
	SETZM (TEM)		;CLEAR THE ERROR FLAG
	POPJ P,			;RETURN TO CALLER OF JRDBL1, RESTORING MAP


;ENTER HERE WITH TAC=JOB JUST SWAPPED IN, J=JOB # WHO WANTS TO READ HIM
;CALLED FROM FININ
↑JRDWIN:PUSH P,TEM		;FIRST SAVE SOME ACS
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSHJ P,JRDBLT		;DO BLT
JRDLEV:	POP P,AC3		;NOW RESTORE ACS
	POP P,AC2
	POP P,AC1
	POP P,TEM
	POPJ P,

;CALLED FROM FININ
↑JRDLOS:PUSH P,TEM		;FIRST SAVE SOME ACS
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSHJ P,JOBRC1		;GIVE ADDR ERROR RETURN ON SWAP ERROR
	JRST JRDLEV

;DONE, RESTART USER
JOBRC3:	SKIPA TAC,[5]		;NO JOB THERE
JOBRC1:	MOVEI TAC,4		;ADDR ERROR
	SKIPN TEM,JBTFS(J)	;MAKE SURE FS BLOCK EXISTS
	POPJ P,			;NO FS.  EXIT QUIETLY.
	MOVEM TAC,(TEM)
JOBRC2:	MOVM AC3,JOBQUE(J)
	CAIE AC3,IOWQ		;IS HE WHERE WE LEFT HIM?
	JRST JOBRC4		;NO, GIVE BACK FS AND GO AWAY
	MOVNI AC3,RUNQ
	MOVEM AC3,JOBQUE(J)
	JRST REQUE

JOBRC4:	SKIPE AC1,JBTFS(J)
	PUSHJ P,FSGIVE
	SETZM JBTFS(J)
	POPJ P,
;TMPMAX TMPLNK TMPNAM TMPPPN TMPDAT TMPCRD TMPCOR TMPCO1 TMPCR1 TMPDSP NUMTMP TMPSCN TMPSC1 TMPSZ1 TMPSIZ TMPSET TMPST1

;TMPCOR UUO - BEHAVES AS DESCRIBED IN DEC MANUAL

TMPMAX←←400	;MAX TOTAL SIZE OF ONE JOB'S TMPCOR FILES

;FORMAT OF TMPCOR BLOCK
TMPLNK←←0	;DOUBLE LINK WORD
TMPNAM←←1	;NAME,,SIZE
TMPPPN←←2	;PPN (ALIAS) OF TMP FILE
TMPDAT←←3	;BEGINNING OF DATA

TMPCRD:	XCTR XR,[HRRZ DSER,(TAC)]	;TMPCOR TO OTHER JOB
	SKIPN DSER			;DSER←JOB NUMBER.
	MOVEI DSER,(J)			;IF ZERO, USE OWN JOB.
	MOVEI TAC1,0			;IN CASE OF ACCIDENT, SETUP TO RETURN ZERO
	CAMLE DSER,JOBNM1
	JRST TMPCR1			;ILLEGAL JOB NUMBER.  RETURN ZERO.
	MOVE AC1,JBTSTS(DSER)
	TLNN AC1,JNA
	JRST TMPCR1			;NO SUCH JOB.  RETURN ZERO.
	XCTR XR,[SKIPN UUO,2(TAC)]	;GET ALIAS, IF ANY, FROM USER
	MOVE UUO,PRJPRG(DSER)		;DEFAULT TO HIS OWN PPN
	JRST TMPCO1			;ACT LIKE TMPCOR

TMPCOR:	MOVEI DSER,(J)			;TMPCOR TO YOURSELF.  DSER←JOB NUMBER
	SKIPN UUO,DSKPPN(DSER)		;UUO←YOUR ALIAS, OR PPN
	MOVE UUO,PRJPRG(DSER)	
TMPCO1:	HLRZ TAC1,TAC			;TAC1←TMPCOR FUNCTION NUMBER.
	CAIL TAC1,NUMTMP
	JRST UUOERR			;ILLEGAL FUNCTION NUMBER.
	CAIE DSER,(J)			;TMPCOR TO SELF?
	SKIPGE TMPDSP(TAC1)		;NO.  SKIP IF ILLEGAL FUNTION FOR TMPCRD
	JRST .+2			;LEGAL FUNCTION
	JRST UUOERR
	PUSHJ P,@TMPDSP(TAC1)		;PERFORM FUNCTION.
	JRST .+2
	AOS (P)				;SET SKIP RETURN FOR UUO.
TMPCR1:	XCTR XW,[MOVEM TAC1,(UCHN)]	;RETURN PARAMETER FROM TAC1 (OFTEN SIZE)
	POPJ P,

TMPDSP:	SETZ TMPSZ1			;SIGN BIT IF FUNCTION IS ALLOWED FOR TMPCRD
	SETZ TMPRED
	TMPRDD
	TMPWRT
	SETZ TMPDIR
	TMPCLR
	SETZ TMPALD			;TMPDIR IN ALL-ALIAS VERSION
	TMPALC				;TMPCLR DITTO
NUMTMP←←.-TMPDSP

;SCAN A JOB'S TMPCOR FILES.
; EXECUTE 3 INSTRS FOLLOWING CALL:
;	JSP DAT,TMPSCN
;	 INST1				;CAME UUO,TMPPPN(AC1) OR CAIA
;	 INST2				;IF THIS SKIPS, TMPSCN WILL SKIP RETURN
;	 INST3				;IF THIS DOESN'T SKIP, TMPSCN WILL SKIP
;	<NORMAL RETURN>
;	<SKIP RETURN>

TMPSCN:	HRRZ AC3,JBTTCR(DSER)
TMPSC1:	SKIPN AC1,AC3
	JRST 3(DAT)
	HRRZ AC3,TMPLNK(AC1)		;SAVE LINK NOW IN CASE WE ARE DELETING
	XCT (DAT)			;SKIP IF ALIAS IS OK.
	JUMPN UUO,TMPSC1		;BUT, UUO = 0 MEANS ALL ALIAS.
	XCT 1(DAT)
	XCT 2(DAT)			;THIS ONE USUALLY SKIPS
	JRST 4(DAT)			;BUT SKIP RETURN NOW IF NOT
	JRST TMPSC1

;CALCULATE AMOUNT OF ROOM LEFT (TMPMAX-CURRENT TOTAL)
TMPSZ1:	AOS (P)				;FUNCTION ZERO.  GIVE SKIP RETURN.
TMPSIZ:	MOVEI TAC1,TMPMAX
	JSP DAT,TMPSCN
	 CAIA				;IGNORE ALIAS
	 SUB TAC1,TMPNAM(AC1)		;COMPUTE FREE SPACE.
	 TLZA TAC1,-1
	POPJ P,

;CHECK TMPCOR WCMA
;RETURNS TAC1=FIRST RELATIVE ADDRESS OF XFER.  AC2=MINIMUM WORD COUNT.
;IF WORD COUNT IS ZERO, THE NON-SKIP RETURN IS TAKEN.
;ENTER AT TMPSET FOR WRITE OPERATIONS.  AT TMPST1 FOR READ.

TMPSET:	MOVEI TAC1,-1			;UPPER LIMIT ON WC IS INFINTE (WRITE)
TMPST1:	XCTR XR,[HLRE AC2,1(TAC)]	;-WC
	JUMPGE AC2,CPOPJ		;DIRECT RETURN IF WC=0
	MOVN AC2,AC2			;+ WC
	CAILE TAC1,(AC2)		;USE MIN OF FILE & USER WC'S
	SKIPA TAC1,AC2
	MOVEI AC2,(TAC1)
	XCTR XR,[HRRZ AC3,1(TAC)]	;START ADR-1.  (BOTH AC2 AND TAC1 HAVE WC)
	PUSH P,AC1
	ADDI TAC1,(AC3)			;CALCULATE END ADR
	PUSHJ P,RELOCA			;CHECK IT
	JRST UUOERR
	MOVEI TAC1,1(AC3)		;START ADR
	PUSHJ P,RELOCB			;CHECK THAT TOO
	JRST UUOERR
	POP P,AC1
	XCTR XR,[HRRZ TAC1,1(TAC)]	;TAC1←STARTING ADDRESS-1
	AOJA TAC1,CPOPJ1		;SET TAC1 TO STARTING ADDRESS.  SKIP.
;TMPFND TMPRED TMPRDX TMPWRT TMPRDD TMPDEL TMPALD TMPDIR TMPDR2 TMPDR0 TMPDR1 TMPALC TMPCLR TMPKIL

;FIND REQUESTED TMPCOR FILE
TMPFND:	XCTR	XR,[HLLZ TAC1,(TAC)]
	JSP	DAT,TMPSCN
	 CAME	 UUO,TMPPPN(AC1)	;ONLY MATCH CURRENT ALIAS
	 HLLZ	 AC2,TMPNAM(AC1)
	 CAMN	 AC2,TAC1
	POPJ	P,
	JRST	CPOPJ1

;READ TMPCOR FILE
TMPRED:	PUSHJ	P,TMPFND		;LOOK FOR FILE
	JRST	TMPSIZ			;NOT THERE - RETURN FREE SIZE
	HRRZ	TAC1,TMPNAM(AC1)	;LIMIT TRANSFER TO SIZE OF FILE.
	PUSHJ	P,TMPST1		;SETUP FOR TRANSFER.
	JRST	TMPRDX			;USER SPECIFIED 0 WC.  RETURN FILE SIZE.
	HRLI	TAC1,TMPDAT(AC1)	;SOURCE IN LH.  USER ADDRESS IN RH
	ADDI	AC2,(TAC1)		;USER'S FIRST ADDR+SIZE = ENDING ADDR+1
	XCTR	XBLTW,[BLT TAC1,-1(AC2)]	;MOVE DATA FROM SYSTEM TO USER.
TMPRDX:	HRRZ	TAC1,TMPNAM(AC1)	;RETURN ACTUAL FILE SIZE.
	JRST	CPOPJ1

;WRITE TMPCOR FILE
TMPWRT:	PUSHJ	P,TMPFND	;SEE IF IT ALREADY EXISTS
	JRST	.+2		;NO.
	PUSHJ	P,TMPDEL	;YES - DELETE IT
	PUSHJ	P,TMPSET	;CHECK ARGUMENTS.
	JRST	TMPSIZ		;NO TRANSFER.
	PUSHJ	P,TMPSIZ
	CAILE	AC2,(TAC1)
	POPJ	P,		;NOT ENOUGH ROOM LEFT
	MOVEI	AC3,TMPDAT(AC2)	;AC3←SIZE OF FREE STORAGE BLOCK NEEDED.
	PUSHJ	P,UFSGET		;GET A BLOCK
	XCTR	XR,[HLRE AC2,1(TAC)]	;-WC
	MOVN	AC2,AC2			;+ WC
	XCTR	XR,[HRRZ TAC1,1(TAC)]	;TAC1←STARTING ADDRESS-1
	MOVSI	DAT,1(TAC1)		;SOURCE OF BLT. USER TO SYSTEM
	MOVSI	TAC1,JBTTCR(DSER)
	HRR	TAC1,JBTTCR(DSER)	;& LINK IT IN
	MOVEM	TAC1,TMPLNK(AC1)
	HRRM	AC1,JBTTCR(DSER)
	HRLM	AC1,(TAC1)
	XCTR	XR,[HLL AC2,(TAC)]	;GET NAME (SIZE STILL IN RH OF AC2)
	MOVEM	AC2,TMPNAM(AC1)		;STORE NAME & SIZE
	MOVEM	UUO,TMPPPN(AC1)		;AND ALIAS WITH TMP FILE
	HRRI	DAT,TMPDAT(AC1)		;MAKE BLT PNTR
	ADDI	AC2,(DAT)		;CALCULATE ENDING ADDRESS+1
	XCTR	XBLTR,[BLT DAT,-1(AC2)]	;MOVE DATA. USER TO SYSTEM.
	JRST	TMPSZ1			;SKIP RETURN WITH NEW FREE CNT

;READ & DELETE TMPCOR FILE
TMPRDD:	PUSHJ	P,TMPRED		;TRY TO READ FILE
	POPJ	P,			;READ FAILED.
	AOS	(P)			;SET SKIP. FALL INTO TMPDEL
;DELETE TMPCOR FILE SPECIFIED BY (AC1)
TMPDEL:	MOVE	AC2,TMPLNK(AC1)		;FETCH DOUBLE LINK WORD
	TRNE	AC2,-1			;SKIP IF FORWARD LINK IS ZERO
	HLLM	AC2,(AC2)		;STORE REVERSE LINK IN NEXT BLOCK
	MOVS	AC2,AC2
	HLRM	AC2,(AC2)		;STORE FORWARD LINK IN PREVIOUS BLOCK
	JRST	FSGIVE			;RETURN BLOCK TO FREE STORAGE.

;READ TMPCOR DIRECTORY
TMPALD:	MOVEI	UUO,0			;LIST ALL REGARDLESS OF ALIAS
TMPDIR:	MOVEI	TEM,CPOPJ		;NO DELETING
TMPDR2:	PUSHJ	P,TMPSET
	JFCL
	MOVSI	AC2,1(AC2)		;ADJUST BY 1 FOR TOP-TESTING AOBJN
	MOVN	AC2,AC2	
	HRRI	AC2,(TAC1)		;AOBJN POINTER RELATIVE TO USER CORE.
	MOVEI	TAC1,0			;INITIALIZE ITEM COUNT.  (RETURNED TO USER)
	JSP	DAT,TMPSCN
	 CAME	UUO,TMPPPN(AC1)		;MUST MATCH ALIAS (UNLESS UUO=0)
	 PUSHJ	P,TMPDR0
	 CAIA
	JRST	CPOPJ1

TMPDR0:	JUMPN	UUO,TMPDR1		;ALL-ALIAS LISTING HAS 2-WD ENTRIES
	AOBJP	AC2,.+3			;(BUT ONLY IF IT FITS)
	MOVE	TAC,TMPPPN(AC1)		;FIRST WORD IS ALIAS
	XCTR	XW,[MOVEM TAC,-1(AC2)]
TMPDR1:	MOVE	TAC,TMPNAM(AC1)		;GET NAME & SIZE
	AOBJP	AC2,.+2
	XCTR	XW,[MOVEM TAC,-1(AC2)]	;STORE IF ROOM
	AOJA	TAC1,(TEM)		;COUNT ITEM & DO EXIT THING

;READ & CLEAR TMPCOR DIRECTORY
TMPALC:	MOVEI	UUO,0			;CLEAR ALL REGARDLESS OF ALIAS
TMPCLR:	JSP	TEM,TMPDR2		;SET TEM TO CALL TMPDEL FOR EACH ITEM
	PUSH	P,AC2			;NEED TO SAVE THIS FOR TMPDR0
	PUSHJ	P,TMPDEL
	POP	P,AC2
	POPJ	P,

;DELETE ALL TMPCOR FILES (IGNORE ALIAS) - HERE FROM JOBKL
TMPKIL:	MOVEI	DSER,(J)		;THIS ROUTINE DOES OWN JOB!
	JSP	DAT,TMPSCN		;FIND ALL TMP FILES.
	 CAIA				;IGNORE ALIAS
	 PUSHJ	 P,TMPDEL		;DELETE EACH ONE
	 CAIA
	POPJ	P,
;UMAIL MAXMAIL SKPSEN SEND SEND1 NOWAKE WRCV SRCV SKPME SKPHIM FNDJOB GJ1 GJERR GJERR2 GTGAR1 GTGARP

UMAIL:	CAILE	UCHN,MAXMAIL		;AC FIELD IN BOUNDS?
	JRST	UUOERR			;NO LOSE.
	JRST	@MALTBL(UCHN)		;DISPATCH TO APPROPRIATE ROUTINE

DEFINE UUOS{FOR X IN(SEND,WRCV,SRCV,SKPME,SKPHIM,SKPSEN)}

PSHSYS
LOSYS

UUOMAC MALTBL,MAIL
MAXMAIL←←UUOCNT-1

POPSYS

SKPSEN:	JSP	AC3,FNDJOB		;THIS JSP MUST BE LABELED SKPSEN
	JRST	SEND1			;ADDRESSEE EXISTS, BEHAVE LIKE "SEND" UUO

SEND:	JSP	AC3,FNDJOB		;DAT ← JOB# OF RECEIVING JOB
SEND1:	XCTR	XR,[HRRZ TAC,1(UUO)]	;GET THE ADDRESS OF THE MAIL BLOCK
	XCTR	XR,[MOVE AC2,37(TAC)]	;ADDRESS CHECK LAST WORD OF MAIL BLOCK
	MOVEI	AC3,40			;GET SOME FREE STORAGE.
	PUSHJ	P,UFSGET
	HRRZ	TAC1,JBTMAIL(DAT)	;DOES THIS GUY HAVE MAIL ALREADY?
	JUMPN	TAC1,FSGIVE		;YES.  CAN'T DO IT.  RETURN FS BLOCK.
	HRRM	AC1,JBTMAIL(DAT)	;STORE ADDRESS OF MAIL (KEEP MAIL WAIT FLAG)
	HRLI	AC1,(TAC)		;USER-RELATIVE SOURCE ADDRESS.
	MOVEI	AC2,37(AC1)		;AC2←ENDING ADDRESS IN FREE STORAGE
	XCTR	XBLTR,[BLT AC1,(AC2)]	;BLT FROM USER TO FREE STORAGE
	MOVEI	J,(DAT)			;J←RECEIVER'S JOB NUMBER
	HLLZ	TAC,JBTMAIL(J)
	JUMPE	TAC,NOWAKE		;JUMP IF HE'S NOT WAITING IN WRCV.
	HRRZS	JBTMAIL(J)		;CLEAR WRCV FLAG
	SKIPL	JBTSTS(J)		;IF NOT RUNNABLE, DON'T REQUE HIM
	JRST	NOWAKE
	MOVEI	TAC,RUNQ
	MOVNM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
NOWAKE:	MOVSI	AC1,INTMAIL		;IS HE ENABLED FOR A MAIL INTERRUPT?
	TDNN	AC1,JBTIEN(J)
	JRST	CPOPJ1			;NO RETURN QUICK
	IORM	AC1,JBTIRQ(J)		;YES, GIVE HIM THE INTERRUPT.
	TDNE AC1,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM	INTREQ		;YES, RUN INTERRUPTS
	SKIPN	INTACT			;SKIP IF SENDER IS ALREADY AT I-LEVEL
	PUSHJ	P,WSCHED		;SHUT US OFF TO GET THE INTERRUPT PROCESSED.
	JRST	CPOPJ1			;DON'T TRY TO RESCHEDULE IF AT I-LEVEL


WRCV:	PUSHJ	P,SRCV			;WAIT FOR MAIL AND RECIEVE IT.  ANY THERE?
	TROA	AC1,IOWQ		;NO ONE HOME (AC1 IS RETURNED AS 0)
	POPJ	P,			;THERE WAS A LETTER AND HE'S BEEN GIVEN IT.
	HRROS	JBTMAIL(J)		;STORE -1,,0 IN JBTMAIL TO FLAG WAITING
	MOVNM	AC1,JOBQUE(J)
	PUSHJ	P,WSCHED
	JRST	WRCV

SRCV:	HRRZ	AC1,JBTMAIL(J)		;RECIEVE MAIL AND SKIP IF THERE'S SOME.
	JUMPE	AC1,CPOPJ		;DIRECT RETURN IF NO MAIL
	MOVSI	TAC,(AC1)		;SOURCE ADDRESS FOR MAIL
	HRRI	TAC,(UUO)		;GET RELATIVE ADDRESS OF DESTINATION
	MOVEI	TAC1,37(TAC)
	XCTR	XBLTW,[BLT TAC,(TAC1)]	;MOVE DATA FROM FREE STORAGE TO USER
	SETZM	JBTMAIL(J)		;(IN CASE OF ADDRESS CHECK, DON'T ZERO
	PUSHJ	P,FSGIVE		; POINTER TO FS UNTIL READY)
	JRST	CPOPJ1

SKPME:	SKIPA	DAT,J			;SKIP IF THERE'S MAIL FOR ME.
SKPHIM:	JSP	AC3,FNDJOB		;SKIP IF THERE'S MAIL FOR SOME OTHER JOB
	HRRZ	AC3,JBTMAIL(DAT)
	JUMPG	AC3,CPOPJ1
	POPJ	P,

;GET THE JOB NUMBER OF THE ADDRESSEE.

↑FNDJOB:XCTR	XR,[MOVE DAT,(UUO)]	;GET USER'S ARGUMENT  (CALLED FROM DPYSER)
	CAIGE	DAT,JOBN		;IS IT TOO BIG FOR A JOB NUMBER?
	JUMPG	DAT,GJ1			;YES. IF POSITIVE, THIS IS A JOB NUMBER.
	MOVSI	TAC,-JOBN		;SEARCH ALL JOB NAMES.
	CAME	DAT,JOBNAM(TAC)		;IS THIS ONE?
	AOBJN	TAC,.-1			;NOT A MATCH. LOOP.
	JUMPGE	TAC,GJERR		;JUMP IF NO NAMES MATCHED
	SKIPA	TAC1,TAC		;CONTINUE SCAN.  LOOK FOR ANOTHER
	CAME	DAT,JOBNAM(TAC1)	;SAME NAME?
	AOBJN	TAC1,.-1		;NO.
	JUMPL	TAC1,GJERR2		;MATCH OR END OF LOOP.  JUMP IF AMBIGUOUS
	MOVEI	DAT,(TAC)		;DAT←JOB NUMBER OF UNIQUE MATCH
GJ1:	MOVE	TAC,JBTSTS(DAT)		;GET JOB STATUS
	TLNE	TAC,JNA			;IS THIS JOB SLOT ASSIGNED?
	JRST	(AC3)			;YES. RETURN WITH JOB NUMBER IN DAT
GJERR:	SKIPA	TAC,[GTGAR1]		;GET ADDRESS OF ERROR ROUTINE
GJERR2:	MOVEI	TAC,GTGARP		;PICKUP THE AMBIGUOUS NAME ERROR MESSAGE
	HRRZ	AC3,AC3			;FIND OUT WHO CALLED FNDJOB
	CAIN	AC3,SKPSEN+1		;WAS IT SKPSEN UUO?
	JRST	CPOPJ2			;YES, TERMINATE THE UUO
	PUSHJ	P,HNGMES		;NO, COME BACK WHEN HE TYPES CONTINUE
	JRST	FNDJOB			; 

GTGAR1:	ASCIZ	/? Non-ex job name or number
/

GTGARP:	ASCIZ	/? ambiguous job name
/
;

SUBTTL	UUOCON	IO SECTION
;FOR PURPOSES OF COMMENTING THIS SUBROUTINE THE
;TERM 'BUFFER HEADER' SHALL REFER TO THE 3 WORD HEADER
;WHICH IS USED BY THE USER PROGRAM AND THIS EXEC FOR
;REFERING TO THE RING BUFFERS.

;THE CONTENTS OF THE 3 WORD HEADER (AS SET BY THE MONITOR
;		ON EACH INPUT AND OUTPUT UUO).
;		BIT 18-35=ADDRESS OF SECOND WORD OF THE
;		CURRENT BUFFER IN RING WHICH USER IS REFERENCING
;	WORD 2:	BYTE POINTER TO CURRENT ITEM.
;	WORD 3:	POSITIVE ITEM COUNT (NO. OF ITEMS LEFT ON
;		INPUT, NO. OF FREE ITEMS TO GO ON OUTPUT).

;EACH BUFFER IN THE RING HAS FOLLOWING FORMAT (AS THE USER SEES IT)

;	WORD 1:	RESERVED FOR BLOCK NUMBER FOR FIXED ADDRESS DEVICES
;	WORD 2:	BIT 0=USE BIT FOR THIS BUFFER
;		BIT 1-17=NO. OF WORDS WHICH FOLLOW (LENGTH OF BUFFER)/
;		BIT 18-35=ADDRESS OF SECOND WORD OF NEXT BUFFER IN RING
;	WORD 3:	LH=LINK TO NEXT BLOCK (SET BY MONITOR FOR DECTAPE)
;		RH=NO. OF WORDS OF DATA WHICH FOLLOW (USUALLY
;		SET BY EXEC EXCEPT IF THE USER HAS SPECIFIED
;		THAT HE WANTS TO COMPUTE WORD COUNT
;		HIMSELF INSTEAD OF HAVING THE MONITOR DO IT
;		USING THE BYTE POINTER IN THE 3 WORD HEADER).
;IOPUSH IOPSH1 IOPSH3 IOPSH2 IOPOP3 IOPOP IOPOP0 IOPOP2 IOPOP1 IOPOP4 IOPOP5 IOPDL IOPDL0 IOPDL1 IOPDL2 IOPDLD IOPDLL FIOPID IOPID1

;IOPUSH CHN,ID
;	PUSH DEVICE ON CHANNEL "CHN" ON STACK WITH ID "ID"
IOPUSH:	CAMG UCHN,USRHCU	;IF CHANNEL IS IN USE,
	SKIPN DDB,USRJDA(UCHN)	; FIND ITS DDB
	JRST .+2		;NO DDB
	PUSHJ P,WAIT1		;WAIT BEFORE PUSHING THE CHANNEL
	SKIPE AC1,JBTIOP(J)
	JRST IOPSH1
	MOVEI AC3,IOPDLN
	PUSHJ P,UFSGET
	MOVEM AC1,JBTIOP(J)
IOPSH1:	HLRZ AC3,AC1
	CAIN AC3,-IOPDLN
	POPJ P,			;NO SPACE ERROR
	SUBM AC1,AC3
	CAMLE UCHN,USRHCU
	TDZA DDB,DDB
	MOVE DDB,USRJDA(UCHN)
	MOVEM DDB,(AC3)
	SETZM USRJDA(UCHN)
	SKIPN TAC,USRHCU
	JRST IOPSH2		;USRHCU STAYS AT 0 EVEN IF NO CHANNELS OPEN
IOPSH3:	SKIPN USRJDA(TAC)
	SOJG TAC,IOPSH3
	MOVEM TAC,USRHCU
IOPSH2:	MOVEM UCHN,1(AC3)
	HRLM UUO,1(AC3)		;SAVE ID ON STACK WITH CHANNEL NUMBER
	SUB AC1,[2,,0]
IOPOP3:	MOVEM AC1,JBTIOP(J)
	JRST CPOPJ1

;IOPOP CHN,ID
;	RELEASE DEVICE ON CHANNEL "CHN", POP DEVICE WITH ID "ID" INTO CHANNEL "CHN"
IOPOP:	PUSHJ P,FIOPID		;FIND ID WHICH USER SPECIFIED
	POPJ P,			;NO STACK, OR NOT FOUND
IOPOP0:	SKIPE DDB,USRJDA(UCHN)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN?
	CAMLE UCHN,USRHCU	;YES, IS THIS CHAN. LE HIGHEST CHAN. FOR THIS USER?
	JRST IOPOP2		;NO, NO PREVIOUS DEVICE TO RELEASE
	HRRZ DSER,DEVSER(DDB)
	PUSH P,AC3		;SAVE POINTER TO ENTRY WE WILL POP
	PUSHJ P,RELEA0		;RELEASE PREVIOUS DEVICE ON THIS CHAN.
	POP P,AC3
IOPOP2:	MOVE DDB,(AC3)		;THIS POINTS TO STACK ENTRY
	MOVEM DDB,USRJDA(UCHN)	;NEW DEV ON THIS CHANNEL
	JUMPE DDB,IOPOP4	;DON'T READJUST USRHCU IF POPPING A NULL CHANNEL
	CAMG UCHN,USRHCU
	JRST IOPOP4
IOPOP1:	AOS TAC,USRHCU
	CAMN UCHN,USRHCU
	JRST IOPOP4
	SETZM USRJDA(TAC)
	JRST IOPOP1

IOPOP4:	MOVE AC1,JBTIOP(J)
	ADD AC1,[2,,0]
	JUMPG AC1,IOPOP5
	HLRE AC2,AC1
	SUBM AC1,AC2
	HRRZ AC3,AC3
	CAIN AC3,(AC2)		;ARE WE THE END ENTRY?
	JRST IOPOP3		;YES, SKIP BLT
	HRLI AC3,2(AC3)		;BLT DOWN ONE ENTRY
	BLT AC3,-1(AC2)		;LAST WORD OF LAST ENTRY
	JRST IOPOP3

IOPOP5:	SETZM JBTIOP(J)
	AOS (P)
	JRST FSGIVE

IOPDL:	CAIL UCHN,IOPDLL	;LEGAL IOPDL FUNTION?
	JRST UUOERR		;NO
	JRST @IOPDLD(UCHN)	;DISPATCH

;IOPDL 0,
;	RETURN ALL STACKED DEVICES TO WHERE THEY CAME FROM
IOPDL0:	SKIPL AC3,JBTIOP(J)
	POPJ P,
	HLRE AC1,AC3
	SUB AC3,AC1
	HRRZ UCHN,-1(AC3)	;GET JUST CHANNEL NUMBER
	TRZ UUO,-1		;MAKE SURE WE GET TOP OF STACK
	PUSHJ P,IOPOP
	POPJ P,
	JRST IOPDL0		;LOOP TO RESTORE MORE PUSHED CHANNELS

;IOPDL 1,
;	RELEASE ALL STACKED DEVICES
IOPDL1:	SKIPL JBTIOP(J)
	POPJ P,			;DONE
	TRZ UUO,-1		;DO IT TO TOP OF STACK
	PUSHJ P,IOPDL2		;RELEASE IT
	POPJ P,			;FOO
	JRST IOPDL1		;LOOP TILL ALL GONE

;IOPDL 2,ID
;	RELEASE STACKED DEVICE WITH ID "ID".
IOPDL2:	PUSHJ P,FIOPID
	POPJ P,			;NOT FOUND
	MOVE DDB,(AC3)		;GET DEVICE HE WANTS RELEASED
	EXCH DDB,USRJDA		;EXCHANGE WITH CHAN 0
	MOVEM DDB,(AC3)		;WHICH WE SAVE ON STACK
	SETZ UCHN,		;NOW RELEASE CHANNEL 0 AND POP OLD ONE BACK THERE
	JRST IOPOP0

IOPDLD:	IOPDL0
	IOPDL1
	IOPDL2
IOPDLL←←.-IOPDLD

FIOPID:	SKIPL AC3,JBTIOP(J)	;ANY STACK AT ALL?
	POPJ P,			;NO
	HLRE AC1,AC3
	SUBI AC3,2(AC1)		;POINT TO TOP OF STACK
	MOVNI AC1,2(AC1)
	HRL AC3,AC1		;PUT COUNT IN LEFT HALF
	TRNN UUO,-1		;ANY ID?
	JRST CPOPJ1		;NO, 0 IS ALWAYS TOP OF STACK
IOPID1:	HLRZ AC1,1(AC3)		;GET ID
	CAIN AC1,(UUO)
	JRST CPOPJ1		;FOUND IT
	SUB AC3,[2,,2]
	JUMPG AC3,IOPID1	;MORE TO GO?
	POPJ P,			;NO, NOT FOUND
;CLOSE1 UCLS0 UCLS1 UCLS4 UCLS5

; CLOSE UUO - CALLING SEQUENCE
;	CLOSE D,
;	EXIT		ALWAYS RETURNS HERE
; THIS ROUTINES PROCESSES THE CLOSE UUO AND DETERMINES WHETHER THE
;OUTPUT ROUTINE SHOULD BE CALLED IF OUTPUT WERE ACTIVE, CLEARS
;THE INPUT BUFFER AREA IF INPUT WERE ACTIVE, AND CLEARS THE 
;ITEM COUNTS OF BOTH INPUT AND OUTPUT HEADERS SERVING TO BOTH
;TERMINATE THE USE OF THE DEVICE AND SET THE I/O ROUTINES TO
;ACCEPT ANOTHER INPUT OR OUTPUT COMMAND IN A CLEAR STATE.
;IN THE CASE OF OUTPUT DEVICES, THE CLOSE ROUTINE OF THE DEVICE HANDL-
;ING ROUTINE IS CALLED IN CASE ANY SPECIAL HANDLING IS REQUIRED.

;CLOSE UUO, CLOSE INPUT  - WAIT FOR IO TO FINISH, FLUSH BUFFERS - CLOSE1
;DEVICE SERVICE ROUTINES ARE EXPECTED TO PRESERVE DDB, UUO

↑CLOSE1:PUSH P,UCHN		;BULLETPROOFING!
	PUSHJ P,WAIT1		; WAIT UNTIL DEVICE IS INACTIVE
	ANDCMI UUO,777774	;ZERO ALL BUT CLOSE-INHIBIT BITS IN RH OF UUO
	TRNN UUO,CLSIN		;SUPPRESS INPUT CLOSE?
	TLOE DDB,ICLOSB		;NO. INPUT ALREADY BEEN CLOSED?
	JRST UCLS2		;YES
	LDB TAC,PIOMOD		;NO
	CAIL TAC,SD		;DUMP MODE?
	JRST UCLS5		;YES  - GO CLOSE DUMP INPUT.
	MOVE TAC,DEVMOD(DDB)	;CLOSE BUFFERED INPUT.
	TLNN DDB,INBFB+INPB	;WAS AN INPUT BUFFER SETUP?
	JRST UCLS4		;NO. FORGET ABOUT CLOSE (EXCEPT DISK OR IMP)
	TLNE TAC,DVLNG		;LONG DISPATCH TABLE?
	PUSHJ P,DCLI(DSER)	;YES, THEN CALL DEVICE TO CLOSE BUFFERED INPUT
	HRRZ TAC1,DEVBUF(DDB)
	XCTR XR,[HRRZ DAT,(TAC1)]	;PICK UP FIRST WORD OF BUFFER HEADER
	LDB AC3,PDVBLN		;PICK UP BUFFER LENGTH
	ADDI AC3,(DAT)		;ADD IN BUFFER ADDRESS
	XCTR XRW,[MOVES (AC3)]	;ADDRESS CHECK BUFFER ADDRESS
	XCTR XR,[HRR TAC1,(TAC1)]	;REMEMBER CURRENT BUFFER IN TAC1
	MOVSI TAC,IOUSE		;USED BOTH FOR HEADER AND EACH BUFFER
	JUMPE DAT,UCLS1		;HAS A RING BEEN SETUP?(NO IF 0)
	MOVEI AC1,0
	LDB AC3,PDVBLN		;FIGURE MAXIMUM nbr OF BUFFERS -- get buf size
	HLRZ TEM,JBTPAG(J)	;core size in pages
	LSH TEM,9		;core size in words
	IDIVM TEM,AC3		;max nbr of buffers to fit in core (avoid remainder)
	ADDI AC3,2		;AND THIS IS CERTAINLY A GOOD UPPER BOUND!
UCLS0:	XCTR XR,[HRR DAT,(DAT)]	; ADVANCE CURRENT INPUT BUFFER ADDRESS
	CAIN AC1,(DAT)		;IS THIS THE SAME BUFFER AS LAST ONE?
	JRST UCLS1		;YES. BAD RING. LOOPING ON ITSELF.
	MOVEI AC1,(DAT)		;IS ADDRESS OK?
	XCTR XRW,[ANDCAM TAC,(DAT)]	;CLEAR USE BIT IN BUFFER
	SOJL AC3,UCLS1
	CAME TAC1,DAT		;DONE?
	JRST UCLS0
UCLS1:	HRRZ DAT,DEVBUF(DDB)
	XCTR XRW,[IORM TAC,(DAT)]	;FLAG AS VIRGIN BUFFER IN HEADER
	XCTR XW,[SETZM 2(DAT)]	;CLEAR INPUT ITEM COUNT
	MOVE IOS,[IOEND,,IODEND]
	ANDCAB IOS,@DEVSPT(DDB)
	JRST UCLS2			;GO CLOSE THE OUTPUT SIDE

UCLS4:	TLNE TAC,DVDSK!DVIMP	;NO INPUT BUFFERS BUT FOR DSK & IMP MUST CALL DEVICE
UCLS5:	PUSHJ P,DCLI(DSER)	;CLOSE DUMP MODE INPUT.  PRESERVE UUO,DDB
	JRST UCLS2		;NOW CLOSE OUTPUT SIDE
;UCLS2 UCLS2A UCLS2B UCLS6 UCLS7 UCLS3

;CLOSE OUTPUT

UCLS2:	MOVE DSER,DEVSER(DDB)	;IN CASE OF ACCIDENTS.
	LDB J,PJOBN		;IMPSER CLOBBERS J, DSER AND WHATEVER ELSE
	TRNN UUO,CLSOUT		;SUPPRESS OUTPUT CLOSE?
	TLOE DDB,OCLOSB		;NO. OUTPUT ALREADY CLOSED?
	JRST UCLS3		;YES
	LDB TAC,PIOMOD		;NO.
	CAIL TAC,SD		;DUMP MODE?
	JRST UCLS7		;YES - GO CLOSE DUMP OUTPUT
	TLNN DDB,OUTBFB+OUTPB	;CLOSE BUFFERED OUTPUT
	JRST UCLS6		;NO BUFFERS WERE SETUP
	HLR DAT,DEVBUF(DDB)	;RESTORE DAT NOW.
	XCTR XR,[SKIPG (DAT)]	;BUFFERS SET UP?
	JRST UCLS6		;NO.  DON'T CLOSE UNLESS DISK OR IMP
	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	LDB AC2,PSEGN
	HLRZ AC2,JBTPAG(AC2)	;NUMBER OF PAGES IN THE UPPER
	ADD AC1,AC2
	LSH AC1,9		;TOTAL NUMBER OF WORDS
	LDB AC2,PDVBLN		;SIZE OF DATA PORTION OF BUFFER
	IDIVI AC1,2(AC2)	;GET MAXIMUM NUMBER OF BUFFERS HE COULD HAVE
	PUSH P,AC1		;AND SAVE IT
UCLS2A:	MOVE DSER,DEVSER(DDB)
	MOVE AC1,DEVOAD(DDB)
	SOSL (P)		;DECREMENT BUFFER COUNT
	XCTR XR,[SKIPL (AC1)]	;HAS DEVICE WRITTEN ITS NEXT BUFFER YET?
	JRST UCLS2B		;YES, OR WE LOOKED AT TOO MANY BUFFERS
	MOVEI IOS,760000	;NO. START OUTPUT DEVICE.
	ANDCAB IOS,DEVIOS(DDB)	;Clear error bits where they're meaningful
	PUSH P,UUO		;UUO GETS CLOBBERED BY SOMEONE
	PUSHJ P,DOU(DSER)	;KICK DEVICE
	LDB J,PJOBN		;GODDAM IMPSER
	POP P,UUO		;RESTORE UUO
	PUSHJ P,WAIT1		;WAIT TILL MOST BUFFERS EMPTIED
	TRNN IOS,760000		;ERROR?
	JRST UCLS2A		;NO - TRY TO EMPTY MORE BUFERS
UCLS2B:	SUB P,[1,,1]		;THROW AWAY MAXIMUM BUFFER COUNT
	MOVE DSER,DEVSER(DDB)
	PUSHJ P,DCL(DSER)	;CLOSE BUFERED OUTPUT
	HLRZ DAT,DEVBUF(DDB)
	MOVSI TAC,IOUSE
	XCTR XRW,[IORM TAC,(DAT)]
	XCTR XW,[SETZM 2(DAT)]
	PUSHJ P,WAIT1
	JRST UCLS3

UCLS6:	MOVSI TAC,DVDSK!DVIMP	;NO OUTPUT BUFFERS TO CLOSE.
	TDNE TAC,DEVMOD(DDB)	;FOR DISK OR IMP ALWAYS CALL DEVICE
UCLS7:	PUSHJ P,DCL(DSER)	;CLOSE DUMP OUTPUT.
UCLS3:	POP P,UCHN		;BULLETPROOFING.  UCHN←AC FIELD OF UUO.
	HLLM DDB,USRJDA(UCHN)
	MOVE DSER,DEVSER(DDB)	;IN CASE OF ACCIDENTS. RESTORE J AND DSER
	LDB J,PJOBN
	POPJ P,			;EXIT THIS UUO
;UOUTBF UOBF2 UOBF1 UINBF UINBF1 MINBF MOUTBF MBFSET ILLOBF ILLIBF

; INBUF - CALLING SEQUENCE
;	INBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
;CALLING SEQUENCE
;	OUTBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; SETS UP AN N BUFFER RING FOLLOWING THE USER'S PROGRAM FOR DEVICE
; D AND INITIALIZES THE JOB BUFFER AREA HEADER:
;	JBFADR0:=1,	JBFADR 1-17:=0
;	JBFADR 18-35:=ADDRESS OF FIRST BUFFER IN RING
;INPUT SETS DEVIAD:=ADDRESS OF FIRST BUFFER IN RING
;OUTPUT SET DEVOAD:=ADDRESS OF FIRST BUFFER IN RING
;BUFPNT IS RESTORED.

;UOUTBF, UINBF, MINBF, MOUTBF.  INBUF, OUTBUF, UINBF, UOUTBF   - SETUP BUFFERS

;OUTBUF
UOUTBF:	TLNN DDB,OBUFB		;SEE IF THERE EXISTS AN OUTPUT BUFFER HEADER
	JRST ILLOBF		;NO HEADER, GIVE ERROR MESSAGE
	TLO DDB,OUTBFB		;FLAG OUTBUF UUO DONE
	PUSH P,BUFPNT		;SAVE BUFPNT ON STACK
	PUSHJ P,BUFCLC		;SET UP BUFFER RING
UOBF2:	HLR TAC,DEVBUF(DDB)	;TAC←OUTPUT BUFFER AREA HEADER ADDRESS
	HRRM BUFPNT,DEVOAD(DDB)	;DEVOAD←ADDRESS OF FIRST BUFFER IN RING
UOBF1:	XCTR XW,[MOVEM BUFPNT,(TAC)]	;BUFFER HEADER←IOUSE,,ADDR. OF FIRST BUFFER
	LDB TAC,PUUOAC
	MOVEM DDB,USRJDA(TAC)
	POP P,BUFPNT		;RESTORE BUFPNT FROM STACK
	POPJ P,

;INBUF
UINBF:	TLNN DDB,IBUFB		;IS THERE AN INPUT BUFFER HEADER?
	JRST ILLIBF		;NO, ERROR
	TLO DDB,INBFB		;FLAG INBUF UUO DONE
	PUSH P,BUFPNT		;SAVE BUFPNT ON STACK
	PUSHJ P,BUFCLC		;SET UP BUFFER RING
UINBF1:	HRRM BUFPNT,DEVIAD(DDB)	;DEVIAD←ADDRESS OF FIRST BUFFER IN RING
	HRR TAC,DEVBUF(DDB)	;TAC←INPUT BUFFER AREA HEADER ADDRESS
	JRST UOBF1

; UINBF - CALLING SEQUENCE . . .
;	UINBF D,ADR
; WHERE D IS CHANNEL NUMBER AND ADR IS ADDRESS OF TWO WORD BLOCK
; THE FIRST WORD OF WHICH IS THE NUMBER OF BUFFERS YOU WANT
; THE SECOND WORD IS THE LENGTH OF EACH BUFFER

MINBF:	SKIPE DDB,USRJDA(UCHN)		;GET ADRESS OF DEVICE DATA BLOCK
	CAMLE UCHN,USRHCU		;IS IT LESS THAN OR EQUAL TO HIGHEST
	JRST IOIERR			;IO TO UNASSIGNED CHANNEL.
	TLNN DDB,IBUFB			;IS THERE A BUFFER HEADER ADDRESS?
	JRST ILLIBF			;NO, GO COMPLAIN
	TLO DDB,INBFB			;MARK WE HAVE PERFORMED INBUF
	PUSH P,BUFPNT
	PUSHJ P,MBFSET			;DO ALL THE DIRTY WORK
	JRST UINBF1

;UOUTBF - SAME CALLING SEQUENCE AS UINBF

MOUTBF:	SKIPE DDB,USRJDA(UCHN)		;GET ADRESS OF DEVICE DATA BLOCK
	CAMLE UCHN,USRHCU		;IS IT LESS THAN OR EQUAL TO HIGHEST
	JRST IOIERR			;IO TO UNASSIGNED CHANNEL.
	TLNN DDB,OBUFB
	JRST ILLOBF
	TLO DDB,OUTBFB
	PUSH P,BUFPNT
	PUSHJ P,MBFSET
	JRST UOBF2

MBFSET:	MOVE AC1,UUO
	XCTR XR,[HRR UUO,(AC1)]		;MAKE UUO LOOK LIKE NORMAL INBUF
	XCTR XR,[MOVM TAC,1(AC1)]	;AND PICK UP BUFFER LENGTH
	JRST BUFCLM			;GO MAKE THE BUFFERS.

;ERROR MESSAGES FOR THE ABOVE.

ILLOBF:	JSP TAC,ERRPTU			;PRINT A BIT, SET UP TTY DDB
	ASCIZ /Output /
	PUSHJ P,ERNAM			;PRINT "DEVICE XXX"
	PUSHJ P,INLMES
	ASCIZ / has no output buffer header/
	JRST EXCALP			;PRINT PC AND STOP JOB

ILLIBF:	JSP TAC,ERRPTU			;SET UP FOR ERROR PRINTOUT
	ASCIZ /Input /
	PUSHJ P,ERNAM			;PRINT "DEVICE XXX"
	PUSHJ P,INLMES
	ASCIZ / has no input buffer header/
	JRST EXCALP
;

;INIT AND OPEN UUOS


;OPEN UUO - PERFORMS SAME OPERATION AS INIT
;MAY BE USED EASILY BY REENTRANT PROGRAMS
;CALLING SEQUENCE FROM USER AREA
;	OPEN D,ADR
;	ERROR RETURN
;	DEVICE INITED
;
;LH(ADR)=0,RH(ADR)=DATA MODE THIS INIT
;LH(ADR+1)=OUTPUT BUFFER HEADER ADDRESS
;RH(ADR+1)=INPUT BUFFER HEADER ADDRESS
;C(ADR+2,...,ADR+5)=SAME AS LOOKUP OR ENTER
;


; INIT - CALLING SEQUENCE
;	INIT D,MODUS	D=JOB DEVICE CHANNEL
;			MODUS=IORDEL,IOCON,IOWC,MODE.
;	SIXBIT/NAME/	DEVICE NAME
;	XWD OBUF,IBUF	BUFFER AREA HEADER ADDRESSES
;	EXIT1		DEVICE NOT AVAILABLE
;	EXIT2		DEVICE PROPERLY ASSIGNED
;THE LEFT HALF OF NAME CONTAINS THE THREE LETTER DEVICE MNEMONIC,
;   THE RIGHT HALF IS EITHER ZERO (SYSTEM WILL ASSIGN AN ARBITRARY
;   UNIT) OR NON-ZERO TO REQUEST A SPECIFIC UNIT (LEFT JUSTIFIED).
;IF THE SELECTED DEVICE IS NOT AVAILABLE, CONTROL RETURNS TO EXIT1.
;OTHERWISE, THE DEVICE IS ASSIGNED TO THE USER AND ATTACHED TO HIS
;CHANNEL D.  THE DEVICE IS INITIALIZED IN THE FOLLOWING MANNER AFTER
;IOACT IS ZERO:
;	IOBEG:=1
;	DATA MODE:=BITS 32-35 OF AC UUO
;	IOCON:=BIT 31 OF AC UUO
;	IOWC:=BIT 30 OF AC UUO
;	IORDEL:=BIT 29 OF AC UUO
;	IOACT:=IODEND:=IOBKTL:=IODTER:=IODERR:=IOIMPM:=0
;	JBFADR:=JBFCTR:=0 FOR THE SPECIFIED BUFFERS.
;	DEVBUF:=OBUF,IBUF
;UINIT UOPEN UINIT0 UINITG UINITA UINITK UNITDX UINITB UINITL UINITM UNITAC UNTAC1 UNTAD1 UINITC UINIT4 UINIT5 UINXIT UINITZ UINITR

; INIT CODE - FIRST FIND DEVICE AND TRY TO ASSIGN IT

↑UINIT:	MOVE DAT,UUOPC(J)	;SETUP DAT WITH REL ADR OF ARGUMENTS TO INIT
	PUSHJ P,UINIT0		;DO THE INIT
	JRST .+2		;NOW SET UP KLUDGEY MULTIPLE SKIP RETURN
	AOS UUOPC(J)		;(ONLY AFTER ALL THRU WAITING, ETC.)
	AOS UUOPC(J)
	JRST CPOPJ1		;RETURN WITH ONE MORE SKIP

↑UOPEN:	XCTR XR,[SKIP 2(UUO)]	;ADDRESS CHECK GOODIE TABLE
	MOVEI DAT,1(UUO)	;SETUP REL ADR OF ARGUMENTS
	XCTR XR,[HRR UUO,(UUO)]	;SET UP RH WITH DATA MODE TO LOOK LIKE INIT
UINIT0:	PUSH P,DAT		;SAVE POINTER TO ARGUMENT LIST.
	SETZM JBTDVW(J)		;FLAG WE NEVER NEEDED TO WAIT FOR DEVICE
;(IF A GOTCHA! FAILS, WE'LL WAIT AGAIN AUTOMATICALLY)
UINITG:	SKIPE DDB,USRJDA(UCHN)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN?
	CAMLE UCHN,USRHCU	;IS THIS REALLY AN ACTIVE CHANNEL?
	JRST UINITA		;NO PREVIOUS DEVICE TO RELEASE
	PUSH P,UUO		;SAVE UUO
	PUSH P,DAT		;SAVE POINTER TO ARGS.
	PUSHJ P,RELEA0		;RELEASE PREVIOUS DEVICE ON THIS CHAN.
	POP P,DAT		;RESTORE REL. ADR. OF ARGS.
	POP P,UUO		;RESTORE UUO
UINITA:	XCTR XR,[MOVE TAC,(DAT)] ;GET DEVICE NAME FROM USER
UINITK:	MOVE J,JOB		;JOB NUMBER
	PUSHJ P,DEVSRC		;SEARCH FOR DEVICE NAME
	 JRST UINXIT		;NO SUCH DEVICE.  ADJUST STACK AND EXIT.
	MOVE AC1,DEVMOD(DDB)
	TLNN AC1,DVUDP		;IS THIS A UDP?
	JRST UNITDX		;NO
NoStructure,<
	LDB AC1,PUNIT		;YES, IS OK TO INIT WITHOUT HAVING ASSIGNED
	SKIPLE UDPCNT-1(AC1)	;  PROVIDING SOMEBODY ELSE HAS IT AS PUBLIC
	SKIPL UDPOWN-1(AC1)
>;NoStructure
IfStructure,<
	MOVE AC1,SDBPTR(DDB)	;Point to the structure data block
	SKIPLE ST.CNT(AC1)	;  PROVIDING SOMEBODY ELSE HAS IT AS PUBLIC
	SKIPL ST.JOB(AC1)
>;IfStructure
UNITDX:	SKIPA AC1,DEVCMR(DDB)
	JRST UINITB		;WIN
	TLNE AC1,DEVMAS		;SKIP UNLESS MUST ASSIGN FIRST
	JRST UNITAC		;CHECK IF ASSIGNED
UINITB:
IFN FTP2,<
IFN FTVRN,<
IFG XGPNUM,<
	MOVS TAC,DEVNAM(DDB)	;PHYSICAL DEVICE NAME
	CAIE TAC,'XGP'		;IF XGP, INTERLOCK WITH VRN
	JRST UINTNX		;NOT XGP
	MOVE TAC1,DEVMOD+VRNDDB
	TRNN TAC1,ASSPRG	;IS THE VRN IN USE?
	JRST UINTXO		;NO, LET HIM TRY TO GET XGP
	MOVE AC2,DEVNAM(DDB)	;THIS IS NAME OF DEVICE TO INIT
	MOVEI DDB,VRNDDB	;THIS IS DDB TO WAIT FOR AND TEST
	JRST UINTWX

UINTNX:	CAIE TAC,'VRN'		;IF VRN, INTERLOCK WITH XGP
	JRST UINTXO		;NO SPECIAL INTERLOCK
	MOVE TAC1,DEVMOD+XGPDDB
	TRNN TAC1,ASSPRG	;IS THE XGP IN USE?
	JRST UINTXO		;NO, LET HIM TRY TO GET VRN
	MOVE AC2,DEVNAM(DDB)	;THIS IS NAME OF DEVICE TO INIT
	MOVEI DDB,XGPDDB	;THIS IS DDB TO WAIT FOR AND TEST
	JRST UINTWX

UINTXO:
>;IFG XGPNUM
>;IFN FTVRN
>;IFN FTP2
	MOVEI TAC1,ASSPRG	;TRY TO ASSIGN IT BY PROGRAM
	PUSHJ P,ASSASG
	 JRST UINITW		;NOT AVAILABLE, SEE IF HE WILL WAIT FOR IT
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVDSK!DVTTY	;SKIP IF DSK OR TTY
	AOS DDBCNT(J)		;NO, COUNT IT IN USE
	TLNE TAC,DVTTY
	PUSHJ P,OPNTTY		;FOR TTY, CHECK GOING INTO/OUT OF IMAGE MODE
	PUSHJ P,SETMOD		;SET DDB IOS STATUS WORD
	 JRST UINITR		;LOSE. ILLEGAL MODE.
	MOVSI IOS,IOBEG		;FLAG INIT JUST DONE
	IORB IOS,@DEVSPT(DDB)	;FROM RT. HALF OF UUO
	MOVE TAC,DEVMOD(DDB)	;GET GOOD BITS
	TLNE TAC,DVTTY		;IS IT A TTY?
	TLNE TAC,TTYATC		;AND NOT HIS CONSOLE?
	JRST UINITL		;NO
	MOVSI IOS,TPMON
	ANDCAB IOS,DEVIOS(DDB)	;TTY IS NOT IN MONITOR MODE ANY MORE
UINITL:	SKIPGE USRHCU		;IS USRHCU SCREWED UP?(NEGATIVE?)
	SETZM USRHCU		;YES, ZERO IT
UINITM:	CAMG UCHN,USRHCU	;IS THIS CHAN .GT. HIGHEST CHAN. IN USE?
	JRST UINITC		;NO
	AOS TAC,USRHCU		;YES, BUMP HIGHEST SO FAR BY ONE
	SETZM USRJDA(TAC)	;AND CLEAR IT OUT
	JRST UINITM		;AND KEEP LOOKING

UNITAC:	PUSH P,DDB		;SAVE MODEL DDB
UNTAC1:	LDB AC1,PJOBN		;CHECK FOR ASSIGNED OR INITED ALREADY
	CAIN AC1,(J)
	JRST UNTAD1		;SAME JOB MEANS ASSIGNED OR INITED
	PUSHJ P,DEVLP2		;CONTINUE SEARCH
	CAIA
	JRST UNTAC1		;GOT ANOTHER, KEEP CHECKING
	POP P,DDB
	TRNE UUO,400		;USER DESIRES ERROR RETURN?
	JRST UINXIT		;YES. GIVE IT NOW.
	JSP TAC,ERRPTU		;RAN OUT, HE LOSES
	ASCIZ /Must assign /
	PUSHJ P,ERNAM		;TYPE "DEVICE MUMBLE"
;;;	JRST EXCALP		;AT USER/EXEC XXX
	PUSHJ P,UUOATP
;This ought to be in COMCSS somewhere...  TVR/Apr82
	PUSHJ P,PRCRCC		;APPEND CRLF ↑C .
	PUSHJ P,TTYSTC		;START TTY
	PUSHJ P,STOP1		;AND STOP USER, ALLOWING CONTINUE
	PUSHJ P,WSCHED
	SUB P,[XWD 2,2]		;STACKED BY ERRPTU
	POP P,DAT		;STACKED BY UINIT0
	JRST UINIT0		;TRY AGAIN

UNTAD1:	POP P,(P)
	JRST UINITB

; INIT - SET UP BUFFERS AND INITIALIZE THEM

UINITC:	POP P,DAT			;RESTORE POINTER TO ARGUMENT LIST
	TLO DDB,INITB			;SET INIT UUO BIT
	XCTR XR,[HLRZ TAC1,1(DAT)]	;OUTPUT BUFFER HEADER FROM USER
	JUMPE TAC1,UINIT4		;WAS ONE SPECIFIED?
	HRLM TAC1,DEVBUF(DDB)		;YES, SET DEVICE DATA BLOCK
	TLO DDB,OBUFB			;SET OUTPUT BUFFER SPECIFIED BIT
	PUSHJ P,UINITZ			;INITIALIZE OUTPUT BUFFER HEADER
UINIT4:	XCTR XR,[HRRZ TAC1,1(DAT)]	;INPUT BUFFER HEADER FROM USER
	JUMPE TAC1,UINIT5		;WAS ONE SPECIFIED?
	HRRM TAC1,DEVBUF(DDB)		;YES, SET DEVICE DATA BLOCK
	TLO DDB,IBUFB			;SET INPUT BUFFER SPECIFIED BIT
	MOVSI IOS,IOEND			;CLEAR END OF FILE FLAG
	ANDCAB IOS,@DEVSPT(DDB)		;AND RETAIN IOS
	PUSHJ P,UINITZ			;INITIALIZE INPUT BUFFER HEADER
UINIT5:	MOVEM DDB,USRJDA(UCHN)		;STORE UUO BITS AND DDB ADDRESS
	MOVE TAC,DEVNAM(DDB)		;PHYSICAL DEVICE NAME
IFN FTP2,<
IFN FTVRN,<
	CAMN TAC,[SIXBIT /VRN/]
	PUSHJ P,VRNOPN			;REMEMBER WHICH OF VRN AND XGP IS IN USE
IFG XGPNUM,<
	CAMN TAC,[SIXBIT /XGP/]
	PUSHJ P,XGPOPN			;REMEMBER WHICH OF VRN AND XGP IS IN USE
>;IFG XGPNUM
>;IFN FTVRN
>;IFN FTP2
IFN ELFNUM,<
	CAMN TAC,[SIXBIT /ELF/]		;ELF NEEDS TO KNOW WHEN OPENED (PMF 4/14/76)
	PUSHJ P,ELFOPN
>;IFN ELFNUM
IFN TVNUM,<
IFN FTTVFS,<
	CAMN TAC,[SIXBIT /TV/]
	PUSHJ P,TVOPN
>;IFN FTTVFS
>;IFN TVNUM
	JRST CPOPJ1			;SUCCESS RETURN

UINXIT:	POP P,DAT			;RESTORE STACK LOSER EXIT.
	POPJ P,

;UINITZ - SET TAC1 TO ADDRESS OF USER'S BUFFER HEADER.
;CLEARS FIRST AND THIRD WORD OF THE BUFFER HEADER.   SETS BYTE SIZE IN
;THE SECOND WORD OF THE BUFFER HEADER, ACCORDING TO IO MODE.

UINITZ:	XCTR XW,[SETZM (TAC1)]		;CLEAR FIRST WORD OF BUFFER HEADER
	XCTR XW,[SETZM 2(TAC1)]		;AND LAST WORD OF BUFFER HEADER
	HRLI TAC,700			;ASSUME A 7 BIT MODE. (0 OR 1)
	TRNE IOS,10			;SKIP IF MODE IS LESS THAN 10.
	HRLI TAC,4400			;36 BIT MODE. IMAGE, BINARY, OR IB
	XCTR XRW,[HLLM TAC,1(TAC1)]	;SET BYTE SIZE IN BUFFER HEADER.
	POPJ P,				;RETURN


UINITR:	PUSH P,DDB		;SAVE LOSER DDB
	JSP TAC,ERRPTU
	ASCIZ /Illegal data mode for /
	PUSHJ P,ERNAM
	EXCH DDB,(P)		;SAVE TTY DDB, GET LOSER DDB
	PUSHJ P,RELEA7		;RELEASE DEVICE.
	POP P,DDB		;RESTORE TTY DDB
	JRST EXCALP		;SEND THE BEDBUG LETTER


DEFINE TYPE (S) <
	PUSHJ P,TTYFUW		;WAIT FOR OUTPUT TO FINISH
	PUSHJ P,INLMES
	ASCIZ /S
/
	PUSHJ P,TYPGO		;START UP TTY
>
;UINITW UINTWX UINTW1 UINTW2 SETERZ SETWAT SETWA0 GOTIT UCTEXT

;UINITW, UINTWX  ASK HIM IF HE IS WILLING TO WAIT FOR THE DEVICE
; PUT HIM IN DEVICE WAIT (DWQ) IF HE WANTS TO WAIT
; ROUTINE TO WAIT FOR DEVICE TO BECOME AVAILABLE FOR INIT
; DDB HAS DEVICE TO WAIT FOR, AC2 HAS PHYSICAL NAME OF DEVICE TO TRY TO INIT

UINITW:	MOVE AC2,DEVNAM(DDB)		;ASSIGN SAME DEVICE AS WAITING FOR
;ENTER HERE FROM XGP/VRN INTERLOCK
UINTWX:	TRNE UUO,400			;DOES HE WANT ERROR RETURN?
	JRST UINXIT			;YES. GIVE IT NOW

IFN FTDEVLUP,<
	MOVE TAC1,JB2PRV(J)		;PASSIVE PRIVS
	TLNE TAC1,LUPPRV		;LOCAL-USER?
	JRST UINTW1			;YES BYPASS TEST FOR SPECIAL DEV
	MOVE TAC1,DEVCMR(DDB)
	TLNE TAC1,DEVLUP
	JRST UINXIT
UINTW1:
>;IFN FTDEVLUP

	LDB TAC,PJOBN		;WHAT JOB IS USING THE DEVICE?
	JUMPE TAC,UINXIT	;JOB 0.  NOT BUSY, DETACHED.  LOSE.

	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	PUSH P,AC2		;PHYSICAL NAME OF DEVICE TO INIT
	PUSH P,DDB		;DEVICE TO WAIT FOR
	MOVE TAC1,DEVNAM(DDB)	;GET NAME OF DEVICE TO WAIT FOR
	EXCH TAC1,JBTDVW(J)	;SAVE NAME OF DEVICE TO WAIT FOR
	JUMPN TAC1,SETWA0	;JUMP IF HERE BEFORE FOR THIS INIT -- LOST RACE
	TRNE UUO,IOPAR		;DO WE ASK HIM?
	JRST SETWA0		;NO, WAIT AUTOMATICALLY
	PUSHJ P,TTYFUW		;WAIT FOR OUTPUT, SET UP DAT AND DDB
	MOVE TAC1,-1(P)		;DEVICE TO INIT
	PUSHJ P,PRNAME
	MOVE TAC1,(P)		;DEVICE TO WAIT FOR
	MOVE TAC1,DEVNAM(TAC1)	;PHYSICAL NAME
	CAMN TAC1,-1(P)		;WAITING FOR SAME DEVICE WE WANT TO INIT?
	JRST UINTW2		;YES, THIS ISN'T XGP/VRN INTERLOCK
	PUSHJ P,INLMES
	ASCIZ / is unavailable - /
	MOVE TAC1,(P)		;DEVICE TO WAIT FOR
	MOVE TAC1,DEVNAM(TAC1)	;NAME
	PUSHJ P,PRNAME		;PRINT NAME OF DEVICE TO WAIT FOR
UINTW2:	PUSHJ P,INLMES
	ASCIZ / is busy.  Will you wait? /
	PUSHJ P,TYPGO
	CLRBFI			;CLEAR INPUT BUFFER TYPEAHEAD
	PUSHJ P,UCTEXT
	CAME TAC1,[SIXBIT /Y/]
	CAMN TAC1,[SIXBIT /YES/]
	JRST SETWA0		;GO WAIT.
	TYPE {Would you like to do IO to the disk instead?}
	CLRBFI
	PUSHJ P,UCTEXT
	CAME TAC1,[SIXBIT /Y/]
	CAMN TAC1,[SIXBIT /YES/]
	JRST SETERZ		;OK.  MAKE IO HAPPEN TO DISK.
	SUB P,[1,,1]		;FLUSH DEVICE TO WAIT FOR
	POP P,AC2
	POP P,UCHN		;EXIT, LOSING.
	POP P,UUOPC(J)
	POP P,UUO
	JRST UINXIT

SETERZ:	MOVSI TAC,'DSK'		;SET IO TO DSK.
	SUB P,[1,,1]		;FLUSH DEVICE TO WAIT FOR
	POP P,AC2
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	JRST UINITK

;WAIT FOR DEVICE.  WAIT UNTIL SOMEONE (RELDVW) WAKES US UP.
;ENTER AT SETWA0 TO MAKE SURE WE DON'T WAIT AT ALL IF DEVICE IS ALREADY FREE.
SETWAT:	MOVEI TAC1,DWQ
	MOVNM TAC1,JOBQUE(J)
	MOVE DDB,(P)		;ADDRESS OF DEVICE TO WAIT FOR
	MOVE DDB,DEVNAM(DDB)	;DEVICE NAME FOR COMPARISON
	MOVSI TAC,DVWDIF	;MAYBE WAITING FOR AND INITING DIFFERENT DEVICES
	ANDCAM TAC,JBTMSC(J)	;ASSUME WAITING FOR DEVICE TO BE INITED
	CAME DDB,-1(P)		;IF DIFFERENT DEVICES, THEN SET FLAG SO RELDVW
	IORM TAC,JBTMSC(J)	; CAN WAKE US ON RELEASE, EVEN IF STILL ASSIGNED
	PUSHJ P,WSCHED		;WAIT FOR RELEASE, DEASSIGN OR REASSIGN
SETWA0:	MOVE DDB,(P)		;DEVICE WE'RE WAITING FOR (MAYBE INTERLOCK)
	MOVEI TEM,ASSPRG	;SEE IF IT'S FREE
	TDNE TEM,DEVMOD(DDB)	;SKIP IF DEVICE WE ARE WAITING FOR IS FREE
	JRST SETWAT		;NOPE, KEEP WAITING (REASSIGN ONLY SETS ASSCON)
	MOVE TAC,-1(P)		;NAME OF DEVICE TO INIT
	MOVEM TAC,JBTDVW(J)	;NOW THAT'S THE DEVICE TO WAKE US UP
	PUSHJ P,DEVPHY		;FIND DDB
	 JRST GOTIT		; ?? IS THIS RIGHT ?? (SHOULDN'T EVER HAPPEN)
	LDB TEM,PJOBN
	CAIN TEM,(J)		;SEE IF WE HAVE IT ALREADY (REASSIGN)
	JRST GOTIT
	JUMPN TEM,SETWAT	;JUMP IF SOMEONE ELSE HAS IT.
	MOVE TAC,[TTYATC,,ASSCON+ASSPRG]
	TDNE TAC,DEVMOD(DDB)
	JRST SETWAT		;DEVICE MAY BE ASSIGNED TO JOB ZERO!
GOTIT:	TYPE {Gotcha!}
	SUB P,[1,,1]		;FLUSH DEVICE TO WAIT FOR
	POP P,AC2		;DEVICE TO INIT
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DAT,(P)
	JRST UINITG

UCTEXT:	INCHWL JOBTM5		;INPUT A CHARACTER WHICH WE WILL THROW AWAY!
	MOVEI DAT,TTIBUF(DDB)	;SET UP ADDRESS OF DATA BUFFER
	PUSHJ P,CTEXT1
	PUSHJ P,SKPBRK		;MOVE OUT TO END OF LINE
	POPJ P,
;UDEN UDEN1 UDLKC UDLK

;ENTER, LOOKUP - LONG DISPATCH TABLE UUOS
;HERE ONLY IF DEVICE HAS LONG DISPATCH TABLE
;DISPATCH TO DEVICE DEPENDENT SERVICE ROUTINE

;Note: This code will not work for a P2 device, both because it uses
;DEVIOS directly rather than through DEVSPT, and because it does not
;synchronize with P2 before clobbering DEVIOS.

;ENTER UUO - ENTER FILE NAME IN DIRECTORY

UDEN:	MOVEI TAC,CLSIN
	TLNN DDB,ENTRB			;HAS THIS FILE BEEN OPENED FOR WRITING?
	JRST UDEN1			;NO, SUPRESS CALL ON CLOSE CODE
	TLNN DDB,OCLOSB			;FILE OPEN?
	PUSHJ P,UDLKC			;YES. CLOSE IT.
UDEN1:	TLO IOS,IOBEG
	TRZ IOS,776000
	MOVEM IOS,DEVIOS(DDB)
	TLO DDB,ENTRB
	TLZ DDB,OCLOSB
	HLLM DDB,USRJDA(UCHN)		;STORE UUO BITS
	JRST DEN(DSER)

UDLKC:	PUSH P,UUO
	HRRI UUO,(TAC)
	PUSHJ P,CLOSE1
	POP P,UUO
	JRST WAIT1

;LOOKUP UUO - LOOKUP FILE NAME IN DIRECTORY

↑UDLK:	MOVEI TAC,CLSOUT		;(CALLED FROM DSKSER MTAPE)
	TLNN DDB,ICLOSB			;FILE OPEN?
	PUSHJ P,UDLKC			;YES. CLOSE IT
	TDZ IOS,[IOEND,,776000]
	MOVEM IOS,DEVIOS(DDB)
	TLO DDB,LOOKB
	TLZ DDB,ICLOSB
	HLLM DDB,USRJDA(UCHN)		;STORE UUO BITS
	JRST DLK(DSER)
;URENAM UDSO UDSI UDGF UMTAPE UTPCLR

;RENAME, UTPCLR, USETO, USETI, UGETF, MTAPE

;RENAME UUO - HERE ON SHORT DISPATCH TABLE DEVICES TOO
URENAM:	MOVE TAC,DEVMOD(DDB)	;IS THIS DEVICE A LONG DISPATCH TABLE?
	TLNE TAC,DVLNG
	JRST DRN(DSER)		;YES, DISPATCH TO SERVICE ROUT.
	JRST CPOPJ1		;NO. GIVE SKIP RETURN TO USER

UDSO:	JRST DSO(DSER)		;USETO UUO - SET NEXT OUTPUT BLOCK NUMBER

UDSI:	JRST DSI(DSER)		;USETI UUO - SET NEXT INPUT BLOCK NUMBER

UDGF:	JRST DGF(DSER)		;UGETF UUO - GET NEXT FREE BLOCK

UMTAPE:	JRST DMT(DSER)		;MTAPE UUO - CONTROL FUNCTIONS.

;UTPCLR - CLEAR DECTAPE DIRECT.
UTPCLR:	MOVE TAC,DEVMOD(DDB)	;IS THIS A LONG DISPATCH TABLE?
	TLNN TAC,DVLNG
	POPJ P,			;NO,RETURN
	JRST DCLR(DSER)		;YES, DISPATCH
;CLRIN SETFILE

;SETFILE - GET A FILE NAME FROM USER'S TERMINAL
;CALLED FROM INPUT (OUTPUT) UUOS WHEN A LOOKUP (ENTER) IS NEEDED.

CLRIN:	PUSHJ	P,SKPBRK
SETFILE:TYPE	{  Please type file name: }
	CLRBFI
	INCHWL	JOBTM5
	MOVEI	DAT,TTIBUF(DDB)		;GODDAMN SYSTEM
	PUSHJ	P,CTEXT1		;READ IN FILE NAME IF ANY
	JUMPE	TAC1,CLRIN		;ERROR IF NOTHING WAS TYPED.
	XCTR	XW,[MOVEM TAC1,JOBTM1]	;STORE FILE NAME.
	PUSHJ	P,CTEXT1		;SCAN EXTENSION
	XCTR	XW,[HLLZM TAC1,JOBTM2]
	XCTR	XW,[SETZM JOBTM3]
	PUSHJ	P,PJPGNO		;SEEK PPN
	XCT	SGPPN			;NONE GIVEN. USE DEFAULT
	XCTR	XW,[MOVEM AC2,JOBTM4]
	JRST	SKPBRK			;SCAN TO END OF LINE, RETURN.
;

;INPUT UUO

;1)  IF OUTPUT ACTIVE ON THIS CHANNEL, WAIT FOR IT TO COMPLETE.
;2)  IF DUMP MODE, WAIT FOR DEVICE INACTIVE, CALL SERVICE
;	ROUTINE TO START INPUT, WAIT TILL COMPLETE, THEN RETURN TO USER.
;3)  IF NO BUFFER RING SETUP, SET UP 2 RING BUFFER.
;4)  IF FIRST REFERENCE, START SERVICE ROUTINE, GO TO
;5)  FLAG CURRENT BUFFER AS FREE TO RECEIVE MORE INPUT
;	(USE BIT SET TO 0).
;	START SERVICE ROUTINE FILLING FIRST BUFFER WITH USE BIT 0
;	(NEXT BUFFER OR ONE AHEAD OF IT)
;	(SERVICE ROUTINE WILL SET USE BIT WHEN IT FINISHES FILLING
;	BUFFER).
;7)  IF NEXT INPUT BUFFER IS FULL OF DATA, GO TO 10).
;8)  PUT JOB IN IO WAIT TILL NEXT BUFFER FILLED.
;9)  IF NEXT INPUT BUFFER STILL NOT FILLED, CHECK FOR END
;	OF FILE OR ERROR BITS SET BY SERVICE ROUTINE.
;10) CONVERT WORD COUNT AS STORED BY SERVICE ROUTINE IN THIRD
;	WORD OF BUFFER TO ITEM COUNT AND STORE IN THIRD WORD
;	OF HEADER (ITEM COUNT) ALSO SET BYTE POINTER (SECOND
;	WORD OF HEADER) AND RETURN TO USER.

;IN IN5 IN4 IN2 IN099 IN098 IN1 INPT0C INPT0A INPT2 INPUT2 INPT1 INEOF INEOFE

;INPUT UUO.

↑IN:	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK			;SKIP IF DEVICE DOESN'T NEED A LOOKUP
	TLNE DDB,LOOKB			;SKIP IF NO LOOKUP WAS DONE.
	JRST IN2			;NO LOOKUP NEEDED, OR ALREADY DONE.
	PUSH P,UUO			;SAVE COPY OF THE ORIGINAL UUO
	PUSH P,UUOPC(J)			;SAVE OUR RETURN PC
	PUSH P,UCHN			;AND CHANNEL NUMBER
	TYPE {Lookup needed.}		;MESSAGE TO USER.
	JRST IN4

IN5:	TYPE {Lookup failed.}		;HERE FROM BELOW.
IN4:	PUSHJ P,SETFILE			;GET FILE NAME FROM USER
	MOVE UUO,[LOOKUP JOBTM1]	;IMAGE OF A UUO TO XCT.
	MOVE UCHN,(P)			;RELOAD UCHN FROM STACK (CHANNEL NO.)
	DPB UCHN,PUUOAC			;STORE CHANNEL NUMBER INTO AC UUO
	XCT UUO				;LOOKUP, WITH PROPER CHANNEL NO.
	JRST IN5			;LOOKUP FAILED.
	POP P,UCHN			;LOOKUP OK. RESTORE STATE.
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DDB,USRJDA(UCHN)		;RESTORE OTHER IMPORTANT THINGS.
	HRRZ DSER,DEVSER(DDB)
	MOVE IOS,@DEVSPT(DDB)
IN2:	TLNE IOS,IO			;IS DEVICE DOING OUTPUT NOW?
	PUSHJ P,WAIT1			;WAIT FOR OUTPUT TO FINISH.
	TLO DDB,INPB			;FLAG INPUT UUO HAS BEEN DONE.
	TLZ DDB,ICLOSB			;NO INPUT CLOSE YET
	HLLM DDB,USRJDA(UCHN)		;FLAGS GO TO LH OF JDA ENTRY
	LDB TAC,PIOMOD			;IO MODE
	CAIL TAC,SD			;DUMP MODE? (SD,D,DR)
	JRST INDMP			;YES.
	TLNN DDB,IBUFB			;WAS THERE AN INPUT BUFFER HEADER IN INIT?
	JRST ADRERR			;NO. LOSE NOW.
	TRNN UUO,777774			;DOES UUO SPECIFY NONZERO ADDR?
	JRST IN1			;NO, REAL INPUT
	PUSHJ P,WAIT1			;YES, WE WANT TO MOVE THE BUFFERS
	MOVEI TAC,(UUO)			;BH 10/11/78 USER'S ADDR FOR END TEST
	MOVEI TAC1,100			;BH ARBITRARY LIMIT ON NUMBER OF BUFFERS IN RING
IN099:	XCTR XR,[SKIPL (UUO)]		;BH USE BIT MUST BE OFF FOR DEVIAD BUFFER
	JRST IN098			;BH THIS ONE IS OK
	XCTR XR,[HRRZ UUO,(UUO)]	;BH NOPE, GET NEXT CANDIDATE
	CAIN TAC,(UUO)			;BH ALL BUFFERS FULL?
	JRST IN098			;BH YES
	SOJG TAC1,IN099			;BH LOOP BUT NOT FOREVER
	JRST UUOERR			;BH HELPFUL ERROR MESSAGE ON BAD RING

IN098:	HRRM UUO,DEVIAD(DDB)		;STORE USER'S ADDR IN DDB
	POPJ P,				;DON'T ACTUALLY DO INPUT

IN1:	HRR JBUF,DEVBUF(DDB)		;GET ADDRESS OF BUFFER HEADER
	MOVSI TAC,IOUSE			;BUFFER IN USE BIT
	MOVE IOS,@DEVSPT(DDB)		;GET A NEW COPY OF IOS
;BUFFER HEADER (JBUF) WILL BE 0 IF VIRGIN, OR NEGATIVE IF INBUF WAS DONE.
	XCTR XR,[SKIPG (JBUF)]		;SKIP IF BUFFER IS SETUP AND HAS BEEN USED
	JRST INPUTF			;SET UP BUFFER IF NECESSARY. DO FIRST IN
	PUSHJ P,BCHECK			;CHECK ADDRESS OF BUFFERS.
	JRST ADRERR			;ADDRESS CHECK
	XCTR XR,[MOVE TAC1,(JBUF)]	;TAC1←ADDRESS OF CURRENT BUFFER.
	MOVE IOS,@DEVSPT(DDB)
	XCTR XR,[TDNN TAC,(TAC1)]	;SKIP IF BUFFER HAD BEEN BUSY.
	JRST INPT1			;MUST BE VIRGIN BUFFER. GO KICK DEVICE.
;FLAG CURRENT BUFFER AS FREE TO RECEIVE MORE INPUT
	XCTR XRW,[ANDCAB TAC,(TAC1)]	;CLEAR IOUSE. GET POINTER TO NEXT BUFFER
	XCTR XRW,[HRRM TAC,(JBUF)]	;ADVANCE BUFFER HEADER TO NEXT BUFFER
	TRNE IOS,IOACT			;IS DEVICE ALREADY ACTIVE?
	JRST INPT0C			;YES.  SEE IF THERE'S A BUFFER READY
	MOVE AC1,DEVMOD(DDB)
	TLNN AC1,DVTTY			;TTY?  (FILL ONE BUFFER AT A TIME)
	XCTR XR,[HRR TAC,(TAC)]		;NO. GET POINTER 1 BUFFER AHEAD OF NEXT BUF
	XCTR XR,[SKIPL (TAC)]		;IS THE USE BIT SET?
	PUSHJ P,CALIN			;NO, START DEVICE FILLING EMPTY BUFFER
INPT0C:	XCTR XR,[HRR TAC1,(TAC1)]	;GET USE BIT FOR NEXT BUFFER
INPT0A:	XCTR XR,[SKIPGE (TAC1)]		;SKIP UNLESS BUFFER ALREADY FULL.
	JRST INPUT2			;  HERE'S A BUFFER FOR THE USER
INPT2:	PUSHJ P,WSYNC			;WAIT UNTIL BUFFER FILLED.
	XCTR XR,[SKIPL (TAC1)]		;CHECK TO MAKE SURE BUFFER IS FILLED
	JRST INEOF			;NO, MUST BE EOF OR ERROR
INPUT2:	MOVSI AC1,DEPCBC		;Does WC word in buffer contain a byte ptr?
	TDNE AC1,DEVCMR(DDB)
	XCTR XR,[SKIPA J,1(TAC1)]	;Yes.  Set J to entire word
	XCTR XR,[HRRZ J,1(TAC1)]	;No.  Set J to word count in buffer
	JRST IOSETC			;SET ITEM COUNT AND BYTE POINTER. RETURN.

INPT1:	TRNN IOS,IOACT			;IS DEVICE ALREADY ACTIVE?
	PUSHJ P,CALIN			;NO. KICK IT.
	JRST INPT2			;WAIT FOR IT.

;HERE IF WE GOT BACK FROM DEVICE SERVICE WITHOUT A filled BUFFER.
INEOF:	TDNN IOS,[IOEND,,IODEND!IODERR!IOBKTL!IODTER!IOIMPM]	;EOF OR ERROR?
	JRST INEOFE			;NO, SYSTEM ERROR.
	TLNE IOS,IOEND			;IS THIS EOF?
	TRO IOS,IODEND			;YES, SET USER EOF BIT.
	IORM IOS,@DEVSPT(DDB)
	POPJ P,				;RETURN TO USER'S PROGRAM

INEOFE:	JSP DAT,UERROR			;MONITOR ERROR AT UUO LEVEL
	POPJ P,
;INPUTF INPUT3 INDMP CALIN BCHECK

;MORE INPUT - BCHECK, CALLIN, INPUTF, INDMP

;HERE WHEN BUFFERS ARE EITHER NON EXISTANT, OR HAVE NEVER BEEN USED.
INPUTF:	XCTR XRW,[ANDCAB TAC,(JBUF)]	;MARK HEADER - BUFFERS HAVE BEEN USED
	JUMPE TAC,INPUT3		;JUMP IF NO BUFFERS EXIST YET.
	PUSHJ P,BCHECK			;CHECK BUFFERS THAT HE'S GOT
	JRST ADRERR			;ADDRESS CHECK
	XCTR XR,[MOVE TAC1,(JBUF)]	;POINTER TO FIRST BUFFER
	XCTR XR,[SKIPG (TAC1)]		;SKIP IF BUFFER IS FREE TO BE FILLED.
	JRST INPUT2			;BUFFER IS FULL. GIVE IT TO USER ????
	HRRM TAC,DEVIAD(DDB)		;STORE BUFFER ADDRESS FOR DEVICE.
	PUSHJ P,CALIN			;START DEVICE.
	JRST INPT0A			;WAIT FOR IT TO FILL.

INPUT3:	HRRI UUO,2			;NO BUFFERS EXIST YET - MAKE 2
	PUSHJ P,UINBF
	HRRI UUO,0			;CLEAR RIGHT HALF
	JRST IN1			;BACK TO IN1 AND INPUTF AGAIN.


;HERE FOR DUMP MODE INPUT.  NOTE THAT ADCSER (XGPSER) THINK THEY CAN RETURN
;TO USER WITHOUT WAITING BY "JRST TPOPJ" TO SKIP WSYNC
INDMP:	PUSHJ P,DDI(DSER)		;CALL SERVICE ROUTINE
	JRST WSYNC			;WAIT FOR IO TO FINISH AND RETURN TO USER.


;HERE FOR BUFFERED MODE INPUT.
CALIN:	TLNE IOS,IOEND			;CALL DEVICE SERVICE INPUT ROUTINE
	POPJ P,				;END OF FILE ALREADY. RETURN.
	PUSH P,TAC1
	PUSH P,JBUF
	HRRZ AC1,DEVIAD(DDB)		;CHECK BUFFER ADDRESS.
	CAIG AC1,JOBPFI
	JRST ADRERR			;ERROR - IN PROTECTED PART OF JOBDAT
	XCTR XR,[HLRZ AC2,(AC1)]	;GET LENGTH OF BUFFER
	TRZ AC2,IOUSE			;CLEAR USE BIT IN CASE IT IS ON(TTY)
	ADD AC1,AC2
	XCTR XRW,[MOVES (AC1)]		;ADDRESS CHECK LAST ADDRESS OF BUFFER
	PUSHJ P,DIN(DSER)		;DISPATCH TO IO SERVICE ROUTINE
	POP P,JBUF
	POP P,TAC1
	POPJ P,

↑BCHECK:MOVEI AC1,(JBUF)
	CAIG AC1,JOBPFI			;CHECK PROTECTED PART THIS WAY
	POPJ P,
	XCTR XRW,[MOVES AC1,(AC1)]	;AND THE REST THIS WAY
	HRRZ AC1,AC1
	CAIG AC1,JOBPFI
	POPJ P,
	XCTR XRW,[MOVES (AC1)]
	JRST CPOPJ1
;

;OUTPUT UUO - CALLING SEQUENCE
;     OUTPUT D,
;     EXIT
;OR
;     OUTPUT D, ADR
;     EXIT

;IF INPUT IS ACTIVE, WAIT FOR IT TO COMPLETE.
;IF DUMP MODE WAS SELECTED BY THE LAST INIT UUO OR SETSTS UUO
;   THE PROGRAM WAITS UNTIL THE DEVICE IN INACTIVE AND THEN
;   WRITES THE DUMPFILE AND RETURNS CONTROL TO THE USER'S PROGRAM
;   WHEN IO HAS COMPLETED.
;IF THE MODE IS NOT DUMP, THEN
;1) IF ADR IS NOT ZERO, WAIT FOR DEVICE TO BECOME INACTIVE THEN SET THE
;   CURRENT BUFFER ADDRESS EQUAL TO ADR AND AN INDICATOR (JBFADR0)
;   SPECIFYING THAT THIS BUFFER RING HAS NEVER BEEN REFERENCED FROM THE
;   USER'S PROGRAM BY AN INPUT OR AN OUTPUT UUO.  OTHERWISE, GO TO
;   2) DIRECTLY.

;2) IF THE BUFFER RING HAS NEVER BEEN REFERENCED (JBFADR0=1), THE
;   BUFFER IS CLEARED, IOUSE SET TO ZERO AND
;      IF THE CURRENT BUFFER ADDRESS IS ZERO, A TWO BUFFER RING IS SET UP.
;      THEN GO TO 8
;
;3) IF THE BUFFER RING HAS BEEN REFERENCED (JBFADR0=0	,THEN A CHECK IS
;   MADE TO DETERMINE IF THE WORD COUNT IS TO BE COMPUTED.
;      IF THE WORD COUNT IS TO BE COMPUTED (IOWC=0), IT IS SET EQUAL
;      TO THE ADDRESS FOR THE LAST DATA WORD MINUS THE ADDRESS OF THE
;      BUFFER MINUS ONE.

;4) IOUSE IS SET TO ONE, INDICATING THAT THE BUFFER IS FULL OR BEING
;   EMPTIED, AND THE CURRENT BUFFER ADDRESS IS ADVANCED.

;5) IF THE DEVICE IS NOT ACTIVE (IOACT=0), OUTPUT IS STARTED.
;6) IF THE CURRENT BUFFER IS FULL OR BEING EMPTIED (IOUSE=1),
;   THE PROGRAM WAITS UNTIL THE DEVICE FINISHES THE BUFFER
;   (THE OUTPUT SERVICE ROUTINE CLEARS THE USE BIT WHEN
;   IT FINISHES OUTPUTTING A BUFFER).
;7) THE CURRENT BUFFER IS CLEARED.
;8) THE ITEM POINTER IS INITIATED TO THE CURRENT BUFFER ADDRESS+1
;   AND THE ITEM COUNT IS SET TO THE PRODUCT OF THE BUFFER SIZE
;   MINUS ONE AND THE INTEGER PART OF 36/BYTE SIZE.
;9) RETURN TO THE USER'S PROGRAM
;UOUT OUT3 OUT4 OUT5 OURDN UOUT1

;UOUT - OUTPUT UUO

UOUT:	MOVE	TAC,DEVMOD(DDB)
	TLNE	TAC,DVDSK
	TLNE	DDB,ENTRB
	JRST	UOUT1			;NOT DISK OR ALREADY ENTERED.
	PUSH	P,UUO
	PUSH	P,UUOPC(J)
	PUSH	P,UCHN
	TYPE	{Enter needed.}
	JRST	OUT4

OUT3:	TYPE	{Enter failed.}
OUT4:	PUSHJ	P,SETFILE
	MOVE	UUO,[LOOKUP JOBTM1]
	MOVE	UCHN,(P)
	DPB	UCHN,PUUOAC
	XCTR	XR,[PUSH P,JOBTM4]	;LOOKUP CLOBBERS THIS.
	XCT	UUO			;LOOKUP
	JRST	OUT5			;DOESN'T EXIST OR ENTER WILL DETECT ERROR
	XCTR	XW,[POP P,JOBTM4]
	TYPE	{File already exists.  Is it OK to delete it?}
	CLRBFI
	INCHWL	JOBTM5
	MOVEI	DAT,TTIBUF(DDB)
	PUSHJ	P,CTEXT1
	PUSHJ	P,SKPBRK
	CAME	TAC1,['Y     ']
	CAMN	TAC1,['YES   ']
	JRST	OURDN			;LET'S GO OVERWRITE.
	JRST	OUT4			;LET HIM TRY AGAIN.

OUT5:	XCTR	XW,[POP P,JOBTM4]	;RESTORE PPN
OURDN:	XCTR	XRW,[HLLZS JOBTM2]	;CLEAR CRUD FROM LOOKUP
	XCTR	XW,[SETZM JOBTM3]
	MOVE	UUO,[CLOSE]
	MOVE	UCHN,(P)
	DPB	UCHN,PUUOAC
	XCT	UUO			;MAKE SURE WE DON'T GET INTO ALTER MODE
	MOVE	UUO,[ENTER JOBTM1]
	MOVE	UCHN,(P)
	DPB	UCHN,PUUOAC
	XCT	UUO
	JRST	OUT3			;ENTER FAILED. LOOP.
	POP	P,UCHN
	POP	P,UUOPC(J)
	POP	P,UUO
	MOVE	DDB,USRJDA(UCHN)
	MOVE	IOS,@DEVSPT(DDB)
	HRRZ	DSER,DEVSER(DDB)
UOUT1:	TLO	DDB,OUTPB		;SET OUTPUT UUO BIT.  ENTER HAS BEEN DONE
	TLZ	DDB,OCLOSB		;CLEAR CLOSE OUTPUT BIT.  FALL INTO OUT.
;OUT OUT069 OUT099 OUT098 OUT097 OUT096 OUT1 OUT2 OUTAGN OUTF OUTF1 OUTS OUTDMP

;OUT 
;HERE FROM DEVICE SERVICE ROUTINES ON CLOSE UUO

↑OUT:	TLNN	IOS,IO		;IS THIS DEVICE ALREADY DOING INPUT?
	PUSHJ	P,WAIT1		;YES, WAIT TILL IT BECOMES INACTIVE
	HLLM	DDB,USRJDA(UCHN)	;SAVE NEW BIT SETTINGS.
	LDB	TAC,PIOMOD	;GET DATA MODE SET BY INIT OR SETSTS.
	CAIL	TAC,SD		;IS IT DUMP MODE(SD,DR,D)?
	JRST	OUTDMP		;YES.
	TLNN	DDB,OBUFB	;IS THERE AN OUTPUT BUFFER HEADER?
	JRST	ADRERR		;NO, ERROR
	TRNN	UUO,777774		;IS USER CHANGING RING ADDRESS?
	JRST	OUT1			;NO
REPEAT 0,<		;LET'S TRY ANOTHER WAY
	PUSHJ	P,DFLSHO		;FLUSH OUT ALL PENDING BUFFERS
	HLR	JBUF,DEVBUF(DDB)	;GET ADDRESS OF BUFFER HEADER
	XCTR	XRW,[HRRM UUO,(JBUF)]	;STORE NEW RING ADDRESS IN HEADER
	HRRM	UUO,DEVOAD(DDB)		;SET ADDRESS OF NEXT BUFFER FOR DEVICE
	MOVSI	TAC,IOUSE
	XCTR	XRW,[IORM TAC,(JBUF)]	;FLAG THE RING IS NOT INITIALIZED.
	POPJ P,			;THE USER NOW MOVES THE BUFFERS AND DOES ANOTHER OUT
>;REPEAT 0
	PUSHJ P,WAIT1			;STABILIZE THE WORLD
	MOVEI TAC,(UUO)			;FIRST FIND A NON-FULL BUFFER
	MOVEI TAC1,100			;ARBITRARY LIMIT ON NUMBER OF BUFFERS
OUT099:	XCTR XR,[SKIPL (UUO)]		;FIND ONE WITH USE BIT OFF, IF ANY
	JRST OUT098			;THIS ONE IS OK
	XCTR XR,[HRRZ UUO,(UUO)]	;NOPE, GET NEXT CANDIDATE
	CAIN TAC,(UUO)			;ALL BUFFERS FULL?
	JRST OUT098			;YES
	SOJG TAC1,OUT099		;LOOP BUT NOT FOREVER
	JRST UUOERR			;HELPFUL ERROR MESSAGE ON BAD RING

OUT098:	MOVEI TAC,(UUO)			;NOW FIND A FULL ONE
	MOVEI TAC1,100			;ARBITRARY LIMIT ON NUMBER OF BUFFERS
OUT097:	XCTR XR,[SKIPGE (UUO)]		;FIND ONE WITH USE BIT ON, IF ANY
	JRST OUT096			;THIS ONE IS OK
	XCTR XR,[HRRZ UUO,(UUO)]	;NOPE, GET NEXT CANDIDATE
	CAIN TAC,(UUO)			;ALL BUFFERS EMPTY?
	JRST OUT096			;YES
	SOJG TAC1,OUT097		;LOOP BUT NOT FOREVER
	JRST UUOERR			;HELPFUL ERROR MESSAGE ON BAD RING

OUT096:	HRRM UUO,DEVOAD(DDB)		;STORE USER'S ADDR IN DDB
	POPJ P,				;DON'T ACTUALLY DO OUTPUT

OUT1:	HLR	JBUF,DEVBUF(DDB)	;ADDRESS OF OUTPUT BUFFER HEADER
	XCTR	XR,[SKIPG TAC1,(JBUF)]	;SKIP IF RING HAS BEEN REFERENCED.
	JRST	OUTF		;RING NOT SET UP OR FIRST REFERENCE TO RING
	PUSHJ	P,BCHECK	;RING SET-UP, CHECK IT
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[SKIPG (TAC1)];DID WE GET BACK TO HIM WITH NO FREE BUFFERS?
	JRST	OUTAGN		;YES, LET DEVICE WORRY ABOUT IT! 
	AOS	JBUF		;COMPUTE WORD COUNT FROM BYTE POINTER
	XCTR	XR,[HRRZ TAC,(JBUF)]	;GET RH OF BYTE POINTER.
	ADDI	TAC1,1			;REL. ADDR. OF 3RD WORD IN BUFFER.
	SKIPN	TAC			;BYTE POINTER INITIALIZED ;DWP(JS)
	TDZA	TAC,TAC			;NO. SET WORD COUNT = 0	  ;DWP(JS)
	SUB	TAC,TAC1		;DISTANCE FILLED BY USER.
	TRNE	IOS,IOWC		;DOES USER WANT SYSTEM TO COMPUTE WORD
					;COUNT FROM BYTE POINTER?
	JRST	OUT2			;NO.
	HRRZ	AC1,TAC1	;YES, PROCEED IF ADDR. OF WORD COUNT IN BOUNDS
	ADDI	AC1,(TAC)	;CHECK ENDING ADDRESS.
	XCTR	XRW,[MOVES (AC1)]
	SUBI	TAC1,1		;BACK UP POINTER TO LENGTH AND LINK WORD
	XCTR	XLB,[LDB AC1,[POINT 17,(TAC1),17]]
	CAMLE	TAC,AC1		;IS THERE MORE DATA THAN THERE IS BUFFER?
	JRST	ADRERR		;YES, USER ERROR
	ADDI	TAC1,1		;RESET BUFFER WORD COUNT POINTER
	HRRZ TAC,TAC			;Zero LH(TAC)
	MOVSI AC2,DEPCBC
	TDNE AC2,DEVCMR(DDB)		;Should we store LH of byte ptr?
	 XCTR XR,[HLL TAC,(JBUF)]	;Yes
	XCTR XRW,[MOVEM TAC,(TAC1)]	;Store in 3rd word of buffer

; OUTPUT UUO - HERE, WE ADVANCE BUFFER ADDRESS, START OUTPUT, AND WAIT FOR
; OUTPUT TO FINISH BEFORE RETURNING TO USER

OUT2:	SUBI	JBUF,1			;REL. ADDR. OF 1ST WORD IN HEADER
					;(POINTER TO CURRENT BUFFER).
	SUBI	TAC1,1			;REL. ADDR. OF 2ND WORD IN BUFFER
					;(LINK TO NEXT BUFFER).
	MOVSI	TAC,IOUSE		;FLAG CURRENT BUFFER CONTAINS ACTIVE DATA.
	XCTR	XRW,[IORB TAC,(TAC1)]
	XCTR	XRW,[HRRM TAC,(JBUF)]	;ADVANCE CURRENT BUFFER ADDRESS
	XCTR	XRW,[HLLZS 1(JBUF)]	;ZERO RH OF BYTE PTR  - NOT INITIALIZED
OUTAGN:	XCTR	XW,[SETZM 2(JBUF)]	;CAN'T USE NEXT BUFFER YET!!   RPH
	MOVE	IOS,@DEVSPT(DDB)	;IS DEVICE ACTIVE?
	MOVSI	AC1,DEVAOA		;CAN WE CALL SERVICE ROUTINE ANYWAY?
	TDNN	AC1,DEVCMR(DDB)		;SKIP IF WE CAN CAN SERVICE ROUTINE.
	TRNN	IOS,IOACT		;ONLY CALL SERVICE ROUTINE IF IOACT OFF.
	PUSHJ	P,DOU(DSER)		;CALL DEVICE TO START (OR CONTINUE) OUTPUT.
	HLR	JBUF,DEVBUF(DDB)	;JBUF ← REL. ADDR. OF BUFFER HEADER
	XCTR	XR,[MOVE TAC1,(JBUF)]	;TAC1 ← REL. ADDR. OF 2ND WORD OF BUFFER.
	XCTR	XR,[SKIPL (TAC1)]	;HAS SERVICE ROUTINE EMPTIED NEXT BUFFER
	JRST	OUTS			;YES, CLEAR AND RETURN
	TRNE	IOS,740000		;ANY ERRORS TO SHOW LOSER?   RPH
	POPJ	P,			;YES, LET HIM SEE THEM	     RPH
	PUSHJ	P,WSYNC			;NO, WAIT.
	JRST	OUTS			;BUFFER SHOULD BE FREE. CLEAR IT AND RETURN

OUTF:	XCTR	XR,[SKIPE TAC1,(JBUF)]	;FIRST OUTPUT. SETUP BUFFER RING.
	JRST	OUTF1
	HRRI	UUO,2
	PUSHJ	P,UOUTBF
	HLR	JBUF,DEVBUF(DDB)
OUTF1:	PUSHJ	P,BCHECK		;CHECK BUFFER ADDRESSES
	JRST	ADRERR			;ADDRESS CHECK
	MOVSI	TAC,IOUSE
	XCTR	XRW,[ANDCAB TAC,(JBUF)]	;IOUSE←0
	HRRM	TAC,DEVOAD(DDB)
OUTS:	XCTR	XR,[HRRZ TAC,(JBUF)]	;CLEAR NEXT OUTPUT BUFFER.
	PUSHJ	P,BUFCLR		;CLEAR BUFFER. (MAY BOMB VIA UADRER)
	XCTR	XR,[HRR TAC1,(JBUF)]
	XCTR	XLB,[LDB J,[POINT 17,(TAC1),17]]
	SOJA	J,IOSETC
				;ADDRESS+1
				;JBFCTR:=(BUFFER SIZE-1)*[36/BYTE SIZE]
				;RETURN TO USER'S PROGRAM

OUTDMP:	PUSHJ	P,DDO(DSER)	;NOTE THAT XGPSER (AND ADCSER) THINK THEY CAN RETURN
				;  WITHOUT WAITING BY JRST TPOPJ
	JRST	WSYNC		;WAIT BEFORE RETURNING TO USER
;RELEA0 RELEA3 RELEA1 RELEA5 RELEA4 RELE4A RELE4C RELE4B RELEA9 RELEA7 RELEA6

RELEA0:
↑RELEA3:
	TRZ UUO,-1		;CLOSE BOTH INPUT AND OUTPUT.  HERE FROM IORELS
↑RELEA1:			;ALLOW SUPPRESION ON RELEASE UUO
	PUSHJ P,CLOSE1		;(CLOSE PRESERVES J AND DSER)
	PUSHJ P,WAIT1		;WAIT FOR DEVICE TO BECOME INACTIVE
↑RELEA5:PUSH P,DDB		;TTYREL STEPS ON DDB
	PUSHJ P,DRL(DSER)	;DISPATCH TO DEVICE SERVICE ROUTINE
	TRNE DDB,-1		;DO WE STILL HAVE DDB POINTER?
	MOVEI IOS,IOACT		;YES, CLEAR IO ACTIVE BIT
	TDZA IOS,IOS		;NO, NO IOS BITS IF NO DDB
	ANDCAB IOS,@DEVSPT(DDB)	;AND RETURN WITH IOS SET
	POP P,DDB		;GET DDB BACK SO WE CAN FLUSH POINTERS FROM OTHER CHANNELS
	LDB J,PJOBN		;MAKE SURE J IS SET TO JOB NUMBER
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVDSK!DVTTY	;IF NOT DSK OR TTY,
	SOS DDBCNT(J)		; COUNT IT NOT IN USE
	SETZB DAT,USRJDA(UCHN)	;CLEAR DEVICE ASSIGNMENT
	SKIPGE TAC,USRHCU
	MOVEI TAC,17
RELEA4:	HRRZ TAC1,USRJDA(TAC)
	JUMPN DAT,RELE4A	;NON-ZERO CHAN. ALREADY?
	MOVE DAT,TAC1		;NO, SET DAT WHEN FIRST(HIGHEST) FOUND
	MOVEM TAC,USRHCU	;STORE HIGHEST IN USE CHANNEL
RELE4A:	CAIE TAC1,(DDB)		;IS THIS DEVICE SAME AS ONE BEING RELEASED?
	SOJGE TAC,RELEA4
	JUMPGE TAC,CPOPJ	;DON'T FLUSH THIS DDB IF OPEN ON ANOTHER CHANNEL
	SKIPL TAC,JBTIOP(J)
	JRST RELE4B
RELE4C:	HRRZ TAC1,(TAC)		;ALSO SEARCH IOPDL FOR EXISTING SAME DDB
	CAIN TAC1,(DDB)
	POPJ P,
	ADD TAC,[1,,1]
	AOBJN TAC,RELE4C
RELE4B:	HLLZS DEVIAD(DDB)	;CLEAR INPUT BUFFER ADDRESS
	HLLZS DEVOAD(DDB)	;AND OUTPUT BUFFER ADDRESS.

;CALLED FROM ERROR STOP ROUTINE(ESTOP)
↑RELEA9:
RELEA7:	MOVEI TAC1,ASSPRG		;CLEAR ASSIGNED BY PROGRAM BIT
↑RELEA6:ANDCAB TAC1,DEVMOD(DDB)		;CALLED FROM DEASSIGN
	TRZ TAC1,777			;CLEAR JOB NO. FIELD
	TDNE TAC1,[TTYATC,,ASSPRG]
	POPJ P,				;DEVICE STILL IN USE BY PROGRAM
	TRNE TAC1,ASSCON		;STILL ASSIGNED?
	JRST RELDVA			;YES, MAYBE NOW INTERLOCKED DEV IS FREE
	HRRZ TAC,JBTIOW(J)
	CAIN TAC,(DDB)			;WHOLINE THINK WE'RE WAITING FOR THIS DEV?
	SETZM JBTIOW(J)			;YES, BUT WE CAN'T BE ANY MORE
	HRRZ TAC,JBTDDB(J)		;JUST FS ADDRESS
	CAIN TAC,(DDB)			;IS THIS THE DDB WE'RE DISPLAYING?
	HLLZS JBTDDB(J)			;YES, CAN'T DISPLAY THIS DDB ON WHOLINE NOW
	DPB TAC1,PJOBN			;CLEAR JOB NUMBER
	MOVE TAC1,DEVCMR(DDB)
	TLNN TAC1,DEVSHR		;SHARABLE DEV?
	JRST RELDVW			;NO - WAKE UP WAITERS IF ANY
	PUSH P,DAT			;IF AT COMMAND LEVEL, SAVE TTY POINTER
	PUSH P,DDB			;AND DDB ADDRESS
	PUSH P,DSER
	HRRZ DSER,DEVSER(DDB)		;GET POINTER TO DEVICE DEPENDENT ROUTINES
	PUSHJ P,DGIVDD(DSER)		;RETURN DDB TO STORAGE
	POP P,DSER
	POP P,DDB
	POP P,DAT			;RESTORE COMMAND POINTER
	POPJ P,
;RELDVW RELDVA RELDVU RELDOK RELDVX RELDV4 RELDV5 RELDV8

;RELDVW (RELEAS) - IF THERE IS ANYONE WAITING FOR THE DEVICE WAKE HIM UP.

;ENTER AT RELDVA IF DEVICE STILL ASSIGNED, BUT NOT INITED, SO WAITER FOR
;INTERLOCKED DEVICE (VRN/XGP) CAN BE AWAKENED.

RELDVW:	TDZA AC1,AC1		;DEVICE NOT STILL ASSIGNED
RELDVA:	MOVEI AC1,-1		;FLAG DEVICE STILL ASSIGNED
	PUSH P,DSER
	PUSH P,UUO
	PUSH P,DAT
	PUSH P,J		;SAVE OLD JOB NUMBER
	PUSH P,DDB
	PUSH P,AC1		;SAVE STILL-ASSIGNED FLAG
	MOVE DSER,DEVNAM(DDB)	;JBTDVW NOW CONTAINS DEVICE NAME
RELDVU:	MOVEI DAT,DVWSCAN	;SCAN ALL JOBS IN DEVICE WAIT
	JSP UUO,QSCAN
	 JRST RELDV4		;END OF QUEUE -- CHECK FOR INTERLOCKED DEVICE
	CAME DSER,JBTDVW(J)	;THIS JOB WAITING FOR DEVICE WE JUST FREED?
	JRST (AC1)		;NO, GO RESCAN FOR NEXT JOB IN DWQ
	SKIPN (P)		;IS THE DEVICE STILL ASSIGNED?
	JRST RELDOK		;NO, WAKE UP THIS WAITER
	HLL J,JBTMSC(J)		;GET BIT INDICATING IF INITING DIFFERENT DEVICE
	TLNN J,DVWDIF		;SKIP UNLESS INITING THIS STILL-ASSIGNED DEVICE
	JRST (AC1)		;RESCAN FOR NEXT JOB IN DWQ
RELDOK:	MOVEI AC1,RUNQ
	MOVNM AC1,JOBQUE(J)	;WAKE HIM UP
	PUSHJ P,REQUE
RELDVX:	SUB P,[1,,1]		;FLUSH STILL-ASSIGNED FLAG
	POP P,DDB
	POP P,J
	POP P,DAT
	POP P,UUO
	POP P,DSER
	POPJ P,

IFE FTP2*XGPNUM,<
RELDV4←←RELDVX
>;IFE FTP2*XGPNUM
IFN FTP2*XGPNUM,<
RELDV4:	CAME DSER,['XGP   ']	;IS IT AN INTERLOCKED DEVICE?
	CAMN DSER,['VRN   ']	;WELL?
	TRCA DDB,XGPDDB≠VRNDDB	;YES!  SWITCH TO ADDRESS OF OTHER INTERLOCKED DEVICE
	JRST RELDVX		;NO, THERE'S NO JOB TO AWAKEN
	MOVE DSER,DEVNAM(DDB)	;GET READY TO LOOK FOR JOB AWAITING THAT DEVICE
	MOVEI DAT,DVWSCAN	;SCAN ALL JOBS IN DEVICE WAIT
	JSP UUO,QSCAN
	 JRST RELDVX		;END OF DEVICE WAIT QUEUE
	CAME DSER,JBTDVW(J)	;THIS JOB WAITING FOR INTERLOCKED DEVICE?
	JRST (AC1)		;NO, GO RESCAN FOR NEXT JOB IN DWQ
	HLL J,JBTMSC(J)		;GET BIT INDICATING IF INITING DIFFERENT DEVICE
	TLNN J,DVWDIF		;SKIP IF INITING DEVICE WE JUST RELEASED
	JRST RELDV5		;WAITING FOR OTHER DEVICE -- SEE IF REALLY FREE
	SKIPN (P)		;IS THE DEVICE STILL ASSIGNED?
	JRST RELDOK		;NO, WAKE UP THIS WAITER
	JRST (AC1)		;CONTINUE DWQ SCAN

RELDV5:	LDB DSER,PJOBN		;SEE IF ANYONE OTHER THAN THIS WAITER HAS DEVICE
	CAIN DSER,(J)		;BELONG TO THIS WAITER (ASSIGNED)?
	JRST RELDOK		;YES, WAKE JOB
	JUMPE DSER,RELDV8	;JUMP IF NO ONE HAS DEVICE
	MOVE DSER,DEVNAM(DDB)	;RESTORE DEVICE NAME FOR SEARCH CHECK
	JRST (AC1)		;SCAN FOR NEXT WAITER

RELDV8:	MOVE DSER,DEVMOD(DDB)	;MAYBE THE DEVICE IS DETACHED FROM SYSTEM!
	TRNE DSER,ASSCON!ASSPRG
	JRST RELDVX		;DETACHED FROM SYSTEM, DON'T WAKE NOBODY!
	JRST RELDOK		;NOT IN USE, NOT DETACHED, WAKE THIS WAITER
>;FTP2*XGPNUM
;USTATO USTATS USTATZ

;STATO, STATZ, GETSTS UUOS.   USTATO, USTATZ, USTATS

;CALL:	STATO	D,MASK
;	EXIT1		ALL SELECTED BITS ARE 0
;	EXIT2		SOME SELECTED BITS ARE 1
;TESTS THOSE BITS OF I/O STATUS WORD OF DEVICE ON USER'S CHANNEL D
;WHICH ARE SELECTED BY MASK.


USTATO:	TRNN	IOS,(UUO)		;SKIP IF ANY INDICATED BITS ARE ONE
	POPJ	P,			;RETURN TO USER
	JRST	CPOPJ1			;SKIP RETURN TO USER.


;CALL: 	GETSTS	D,ADR
;	EXIT		ALWAYS RETURNS HERE
;STORES I/O STATUS WORD OF DEVICE ON CHANNEL D IN LOCATION ADR.

USTATS:	HRRZ	TAC,IOS		;GET USER HALF OF IOS
	JRST	STOTAC		;ADDRESS CHECK AND STORE IN USER AREA


;CALL:	STATZ	D,MASK
;	EXIT1		SOME SELECTED BITS ARE 1
;	EXIT2		ALL SELECTED BITS ARE 0

;TESTS THOSE BITS OF I/O STATUS WORD OF DEVICE ON USER'S CHANNEL D
;WHICH ARE SELECTED BY MASK.

USTATZ:	TRNE	IOS,(UUO)	;SKIP IF ALL INDICATED BITS ARE ZERO
	POPJ	P,
	JRST	CPOPJ1
;TIN TOUT

;TIN, TOUT - IN AND OUT UUOS.

;IN UUO - LIKE INPUT  - SKIPS IF EOF OR ERRORS

TIN:	PUSHJ	P,IN		;DO INPUT UUO
	TRNE	IOS,IOBKTL+IODTER+IODERR+IOIMPM+IODEND
	JRST	CPOPJ1
	POPJ	P,


;OUT UUO - LIKE OUTPUT  -  SKIPS IF ERRORS

TOUT:	PUSHJ	P,UOUT		;DO OUTPUT UUO
	TRNE	IOS,IOBKTL+IODTER+IODERR+IOIMPM
	JRST	CPOPJ1
	POPJ	P,
;SPCWGO USPCWAR SPCWG1

;SPACEWAR UUOS

SPCWGO:	MOVEI UUO,(TAC)		;SETUP STARTING ADDRESS.
	HLLZ UCHN,TAC		;MODE BITS IN UCHN LEFT
	HLR UCHN,TAC		;TICKS IN UCHN RIGHT
	AND UCHN,[740000,,17]	;FLUSH IRRELEVANT BITS
	JRST SPCWG1

;UUO43 IS THE SPACEWAR UUO.  SEE SPWSER FOR MORE DETAILS - JS

USPCWAR:ANDI UCHN,17		;TICKS ONLY
SPCWG1:	MOVE TAC,JB2PRV(J)	;PASSIVE PRIVS
	TLNE TAC,LUPPRV
	JRST SPWCON		;LET SPACE WAR SERVICE FIGURE OUT WHAT TO DO
	JRST UUOERR		;ILLEGAL FOR REMOTE JOBS
;⊗ NETUUO NETUU1 NETUUX NNETUU NETU1 NETU11 NETU2 NETU3 NETU4 NETULG NETU5

;Special network functions.  (For physical networks, not protocols.)

;Call:	MOVEI  AC,ADR
;	NETUUO AC,
;	<error return>
;
;ADR:	<function code>
;	<network name in sixbit>
;	<data>

NETUUO:	XCTR XR,[MOVE AC1,(UCHN)]	;Get user's pointer
	XCTR XR,[MOVE AC2,(AC1)]	;Get function code
	XCTR XR,[MOVE AC3,1(AC1)]	;Get network name
	CAIL AC2,1		;Range check function
	CAILE AC2,NNETUU
	POPJ P,			;Out of range, return error
	SKIPGE NETUUX-1(AC2)	;Immediate dispatch without checking net name?
	JRST @NETUUX-1(AC2)	;Yes, dispatch now
;	CAIN AC2,1
;	JRST NETU1		;No name check for function 1
	MOVSI TAC,-NINUM	;- Number of network interfaces
NETUU1:	MOVE TAC1,NILIST(TAC)	;Network interface block
	CAMN AC3,NI.NAM(TAC1)	;Names match?
	JRST @NETUUX-1(AC2)	;Yes, dispatch on function code
	AOBJN TAC,NETUU1
	POPJ P,			;None match, return error

;Dispatch table.  Sign bit means don't bother checking net name.
NETUUX:	400000,,NETU1
	NETU2
	NETU3
	NETU4
	400000,,NETU5		;check subnet for accessibility
NNETUU←←.-NETUUX	;number of function codes defined

;Function 1.  Return list of network names.  Data is [-N,,BUF].
NETU1:	XCTR XR,[MOVE DAT,2(AC1)]	;Get user's AOBJN ptr
	MOVSI TAC,-NINUM
NETU11:	JUMPGE DAT,CPOPJ	;Error if out of room
	MOVE TAC1,NILIST(TAC)	;Get next interface
	MOVE TAC1,NI.NAM(TAC1)	;Get name
	XCTR XW,[MOVEM TAC1,(DAT)]
	ADD DAT,[1,,1]
	AOBJN TAC,NETU11
	JRST CPOPJ1

;Function 2.  Return status of a network.
NETU2:	HRRZ TAC,NI.UP(TAC1)
	HRL TAC,NI.OK(TAC1)
	XCTR XW,[MOVEM TAC,2(AC1)]
	JRST CPOPJ1

;Function 3.  Take network down.
NETU3:	MOVE TAC,JB2PRV(J)	;Check passive privs
	TLNN TAC,DEVPRV		;Does he have DEV?
	POPJ P,			;No, return error
	SETZM NI.UP(TAC1)	;Mark network down
	JSP TAC,NETULG		;Log this on the CTY
	 ASCIZ/ taken down by user /

;Function 4.  Bring network up.
NETU4:	MOVE TAC,JB2PRV(J)	;Check passive privs
	TLNN TAC,DEVPRV		;Does he have DEV?
	POPJ P,			;No, return error
	SETOM NI.UP(TAC1)	;Mark network up
	JSP TAC,NETULG
	 ASCIZ/ brought up by user /

;Type log message on CTY.
NETULG:	PUSHACS
	PUSH P,TAC		;Up or down message
	PUSH P,NI.FNM(TAC1)	;Network name for typeout
	PUSHJ P,DISUSR
	 SIXBIT/NET/
	POP P,TAC
	PUSHJ P,DISTAC		;Type network name
	POP P,TAC
	PUSHJ P,DISTAC		;Type message
	MOVE TAC1,PRJPRG(J)
	PUSHJ P,DISSIX		;Type user name
	PUSHJ P,DISMES
	 ASCIZ/, job = /
	PUSHJ P,DISJOB
	PUSHJ P,DISCRLF
	POPACS
	JRST CPOPJ1

;Function 5.  Check a subnet for accessibility, using PUP routing table.
;Skips if given subnet is in the table (that is, is accessible).
NETU5:	XCTR XR,[MOVE TAC,2(AC1)]	;Get subnet number
	JRST GROUTE			;off to PUPSER, to skip or not

;⊗ SPOOLR SPOOLN SPOOLC SPOOLB SPOOLX SPOOLM SPOOLU SPOOLA SPOOLG SPOOLS SPOOLT SPOOLI SPOOL0

;SPOOLR UUO -- Get info about available spoolers on this system.
;
;	MOVEI AC,ADR	     ;find spooler named in block below, return jobname/ext
;	  or
;	MOVE AC,[-LTXT,,TXT] ;return list of all spoolers' names via this aobjn ptr
;	SPOOLR AC,
;	 <error return, code in AC>
;	<success return>
;	...
;Block for specifying one spooler and returning info about it.
;An abbreviated printer name is allowed, provided it is not ambiguous.
;Case of letters doesn't matter in ASCIZ printer name.
;On error return, AC will contain 0 if no such printer name was found,
;or AC will contain 1 if printer name was ambiguous.
;ADR:	<spooler's sixbit jobname returned here>
; +1:	<spooler command file ext returned here in LH>
; +2:	PRNAME
;
;PRNAME:<user-supplied ASCIZ printer name, can be abbreviated>
;
;If AC is negative upon call to SPOOLR UUO, the left half of AC is taken
;as a negated word count (here, -LTXT) and the
;ASCII names of all available spoolers are returned at the location
;pointed to by the right half of AC (here, TXT).  Each name returned is
;followed by a space.  A null ends the list. 
;E.g.: "Maple Boise Dover Rover Lathrop(private) <null>".
;If more than LTXT words are needed for the list of names, as many names
;as fit in LTXT words are returned, the UUO takes the direct return
;with error code 2 in the AC, and the last name returned may be truncated,
;but the list returned will still be terminated with a null, in the last
;byte of the block specified.
;TXT:	BLOCK LTXT		;block for ASCIZ list of returned ASCII names

SPOOLR:	JUMPL TAC,SPOOLG	;jump if getting list of all spoolers
	MOVEI DAT,0		;no partial match yet
	MOVSI TAC1,-NSPLRS	;make aobjn ptr to spooler tables
;loop per name within system table
SPOOLN:	XCTR XR,[MOVE AC1,2(TAC)] ;get address of ASCIZ string naming the printer
	HRLI AC1,440700		;make byte ptr to printer name
	MOVE AC3,PRIEXT(TAC1)	;get ptr to system text in RH
	HRLI AC3,440700		;make byte ptr
;loop per character within names
SPOOLC:	XCTR XLB,[ILDB AC2,AC1]	;get char from user
	ILDB TEM,AC3		;get char from system name
	JUMPE AC2,SPOOLM	;jump if end of user name, given name matched
	CAIN AC2,(TEM)		;char match exactly?
	JRST SPOOLC		;yes, loop for more chars in current names
	XORI TEM,(AC2)		;no, see if differ only by case of letters
	CAIE TEM,40		;skip if possibly case difference
	JRST SPOOLB		;different chars, names don't match
	TRZ AC2,40		;force upper case
	CAIL AC2,"A"		;if a letter, then match is
	CAILE AC2,"Z"
	JRST SPOOLB		;not a letter
	JRST SPOOLC		;letters differ by case only

SPOOLB:	AOBJN TAC1,SPOOLN	;not a match, look for another system name
	JUMPE DAT,SPOOLU	;jump if no partial match (undefined name)
	MOVEI TAC1,(DAT)	;get partial match ptr
;success, return info for spooler to user.
SPOOLX:	MOVE AC2,PRIJOB(TAC1)	;get spooler's phantom job name
	XCTR XW,[MOVEM AC2,0(TAC)] ;and return it to user
	MOVE AC2,PRIEXT(TAC1)	;get ext,,[asciz/.../]
	XCTR XW,[HLLZM AC2,1(TAC)] ;return cmd file extension in LH
	JRST CPOPJ1		;take success return to user

SPOOLM:	JUMPE TEM,SPOOLX	;jump if exact match (user and system names ended)
	JUMPN DAT,SPOOLA	;jump if second partial match (ambiguous)
	HRROI DAT,(TAC1)	;remember first partial match
	JRST SPOOLB		;check through remainder of list for ambiguity

SPOOLU:	TDZA TAC,TAC		;return error code 0 for undefined name
SPOOLA:	MOVEI TAC,1		;return error code 1 for ambiguous name
	JRST STOTAC

;Here to give the user a list of the available spoolers, in ascii.
;Each name is followed by a space.  The list ends with a null.
SPOOLG:	HLRE AC1,TAC		;get negative word count
	IMULI AC1,5		;make it negative byte count (including ending null)
	HRLI TAC,440700		;make byte ptr to user area
	MOVSI TAC1,-NSPLRS	;aobjn ptr to spoolers
SPOOLS:	MOVE AC3,PRIEXT(TAC1)	;get ext,,[asciz/.../]
	TLNN AC3,-1		;make sure we have non-empty extension
	JRST SPOOLI		;ignore patch space
	HRLI AC3,440700		;make byte ptr to ascii spooler name
SPOOLT:	ILDB AC2,AC3		;get char in spooler name
	XCTR XDB,[IDPB AC2,TAC]	;pass to user
	AOJGE AC1,SPOOL0	;jump if ran out of room, overwrite with a null
	JUMPN AC2,SPOOLT	;jump unless end of this name
	MOVEI AC2," "		;put space after each name
	XCTR XDB,[DPB AC2,TAC]	;terminate name with space (overwriting the null)
SPOOLI:	AOBJN TAC1,SPOOLS	;on to next spooler name, if any
	MOVEI AC2,0		;terminate string with a null
	XCTR XDB,[IDPB AC2,TAC]	;end of string
	JRST CPOPJ1		;skip return for success

SPOOL0:	MOVEI AC2,0		;terminate full block with a null
	XCTR XDB,[DPB AC2,TAC]	;overwrite char that filled block
	MOVEI TAC,2		;return error code 2 for block overflow
	JRST STOTAC

BEND APRSER
