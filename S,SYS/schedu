COMMENT ⊗   VALID 00046 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	BEGIN SCHEDU ↔ SUBTTL SCHEDULING ALGORITHM FOR SWAPPING SYSTEM
C00008 00003	NXTJOB CKJB3 CKJB11 STRQN2 STRQNT STRQN0 STRQN3
C00013 00004	CHKXJB CHKXJ4 CHKXJ3 CHKXJ1 CKJBRN CKJB9 CKJB10 CKJB2A
C00017 00005	CKJB1 CKJB2 CKJB2X CKJB4 CKJB6 CKJB8 CKJB7
C00021 00006	SCHED SCHPDR SCH2 SCHSCN SCHD2 SCHD3 SCH2
C00023 00007	CHKJOB CHKXOK
C00025 00008	SCHD4 SCH3 SCH3A SCH3ER SCH5 CLRSGW CLRSGX CLRSGZ
C00029 00009	SCH1 SCH6 SCH4 SCHD1
C00031 00010	JOBGET JOBG3 JOBG2 JOBG1 JOBRLS JOBRL1 JOBRER JOBR2
C00033 00011	ORDER ORD3 ORD2 ORD1 ORDINS ORDX
C00037 00012	GRSPRI NSLFPL DFTPRI MAXPRI JLCAL JLCA1
C00040 00013	JLCA3 JLCA3A JLCA9 JLCA15 JLCA4 JLCA5 JLCA6 JLCA7
C00046 00014	JLCA10 JLCA14 JLCA12 JLCA13 JLCA11 JLCA20 JLCNSL
C00050 00015	QCSS	24 JULY 67
C00053 00016	QINI QINI1 QINI2
C00055 00017	QXFER J QXFER1 QXFER2 QXFER5 QXFU3 QXFU5 QXFU4 QXFU2 QXFER3 QXFER4 QXF6 QXF8 QXSB QXF5 QXF9 QXF2A QXF2B QXF2 QXF3 QXF7 QXF4
C00070 00018	QNORUN QNORU4 QNORUN QNORU4 QNORU1
C00073 00019	SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
C00075 00020	QSCAN QFOR1 QFOR QFORB QBAK1 QBAK QFOR2
C00077 00021	DEFINE X'(A),<
C00078 00022	QBITS QFUCKW QTW QRUNW QSTW QDTW QDCW QMTW QIOWW QINTWW QDIOWW QNULW QSTOP QSTOPW QSEGW QDWW QPAGEW
C00081 00023	ISCAN OSCAN RUNSCAN DVWSCAN
C00082 00024	SETSIN CLRSIN SINBAD FLUSIN FLUSN1 JRSRCH JRSRC1 JRSRC2 FLUHLD FLUHL2 FLUHL3 FLUHL4 FLUHL1 GETSIN GETSN1
C00088 00025	SWAP	4 AUG 67
C00090 00026	SWAP
C00091 00027	SWAP1 FINSWP FININ FNINNS GENCH1 GENCHK GENCK1 GENCK2 CHKCHK CHKCH1
C00098 00028	SWPMST FNINM1 FNINM2 FINAFB FININA FININS FININC FININB FINZRL FINZR2
C00105 00029	FININ5 FNIN5A FININ1 NOTSET FINDET FININ2
C00108 00030	NOSINT NOSBAT NOSJRD NOSCOM NSINBT
C00110 00031	FININ9
C00112 00032	INERR INERR7 SEGERR SEGER1 SEGER2 SEGER3 SEGER4
C00115 00033	FINOUT OUTP1 OUTP1A OUTP1B OUTP1D SWP2 PSPWAC
C00119 00034	SCNIN SCNINZ SCNIN1 DEADR1 DEADR9 DEDR9A DEDR9B
C00124 00035	DEADUP DEADU1 DEADU2 DEADU7 DEADUC DEADU3
C00127 00036	DEADU4 SCNIN9 RESCNIN RESCN2 NOFIT
C00130 00037	HALFIN PLANT DEADL2 DEADL1 DEACLN
C00132 00038	SDEAD HALFD HALFD1 KILLIN
C00135 00039	GCMAX GCMAX2 GCMAX1 GCLP GCLP1 GCLP2 GCMCK GCS
C00141 00040	SCNOUT FORCE3 SCNOF1 FORCE5
C00145 00041	FORCE4 FORCE6 FORCE0 FORCE1 FRCE4A UNFRCE
C00148 00042	OUTJOB OUTJO1 OUTJO3 OUTJ1 OUTJ2 SWP5 WSYJCL WSYJCK WSYJCJ WSYJCX WSYJC1 WSYJCM
C00155 00043	SIZCHK FRCE2A FORCE2 SETMRS SETMRJ
C00157 00044	CJOB CJBXIT
C00159 00045	INJOB INJO1A INJO1B INJO1C INJO1D INJO1 INJO2 INJO3
C00163 00046	XPAND XPAND3 XPAND4 XPANDB XPAND1 XPAND2
C00168 ENDMK
C⊗;
BEGIN SCHEDU ↔ SUBTTL SCHEDULING ALGORITHM FOR SWAPPING SYSTEM
;11 SEPT 67 REDESIGNED PERIODICALLY BY JAM (AND OTHERS)

HISYS

;AC'S
QJ←DDB		;QJOB WORD
Q←PROG		; QUEUE NUMBER
PC←UUO		; PC ON QUEUE SCAN CALLS
QR←AC1		; RESCAN ADDRESS ON QUEUE SCAN CALLS

;INITIALIZE SCHEDULER  (CALLED FROM IOINI1 BEFORE ALL OTHER
;	DEVICES ARE INITIALIZED)


↑NXTINI:
REPEAT 0,<
	SYNINI JBTCSC
	MOVE DDB,[JBTOWN,,JBTOWN+1]
	SETZM JBTOWN
	BLT DDB,JBTOWN+JOBN-1
>
	SETZM SCHBEG			;ZERO JOB PRIORITY STUFF
	MOVE DDB,[SCHBEG,,SCHBEG+1]
	BLT DDB,SCHEND
	MOVEI DDB,MAXQ			;MAXIMUM NUMBER OF QUEUES
NXTIN1:	SETZM AVALTB(DDB)		;CLEAR SHARABLE DEVICE AVAIL. FLAGS
	SETOM REQTAB(DDB)		;SET SHARABLE DEVICE REQUEST COUNT
					;TO -1,  I.E. NO JOB WAITING OR
					;USING DEVICE OTHER THAN INITIALIZATION
	SOJGE DDB,NXTIN1
	SETZM SWPCNT			;CLEAR SWAPPER COUNT
	SETZM SCHMQT			;WAKE SWAPPER UP THE FIRST TIME AROUND
	SETZM QJOB
	MOVE DDB,[QJOB,,QJOB+1]
	BLT DDB,QJOB+JOBN-1
	POPJ P,
;NXTJOB CKJB3 CKJB11 STRQN2 STRQNT STRQN0 STRQN3

;NXTJOB DECREMENTS CURRENT JOB'S QUANT. AND PROTECT
;TIMES AND REQUEUES IT IF QUANT. TIME GONE TO 0.
;SERVICES ANY JOB REQUEUING REQUESTED AT OTHER PRIORITY
;LEVELS THEN CALLS SHUFFLER,SWAPPER AND SCHEDULER
;MAKES NO ASSUMPTIONS RE. ACS
;RETURNS NEXT JOB TO RUN IN J.


↑NXTJOB:

; HERE, WE SEE IF CURRENT JOB IS RUNNABLE. IF IT IS, WE
; SEE IF ITS QUANTUM TIME HAS RUN OUT. IF IT HAS, WE REQUEUE THE
; JOB. IF NOT, WE LEAVE NOW

; Whenever this code decides to schedule on a different job for any reason,
; it must store the current job's remaining quantum count for use at QXFER
; when the job starts up again (goes to front of RUNQ if nonzero leftover count).
; So any way out of this code except POPJ (with J unchanged) should call STRQNT
; or friends (except if old job was null job).

CKJB3:	SKIPN J,JOB		;CURRENT JOB NO., IS IT NULL JOB?
	JRST CKJB1		;YES,GO SEE IF OTHER JOBS NEED RESCHEDULING
	SYSPIFF		;AVOID CONFUSION BETWEEN NEXT 2 INSTRS
	MOVE DAT,JOBQUE(J)	;PICK UP HIS NEW QUEUE (LH USED AT CKJB10)
	MOVMM DAT,JOBQUE(J)	;STORE BACK POS (NO MORE INT NEEDED)
	SYSPIN
	MOVM DDB,DAT		;GET POSITIVE FORM
	HLRZ IOS,JBTSTS(J)	;GET JOB STATUS BITS AND CODES
	ANDCMI IOS,RUNMSK	;MASK OUT DO NOT CARE BITS
	CAIE IOS,RUNABLE	;IS CURRENT JOB RUNABLE?
	JRST CKJB11		;NO, REQUE CURRENT JOB
	CAIE DDB,RUNQ		;IS HE STILL RUNNABLE?
	CAIN DDB,TQ
	CAIA
	JRST CKJB11		;NO. REQUE HIM.
	SKIPE TIMEF		;YES, IS THIS A TIME INTERRUPT?
;THIS CODE ONLY RUNS ON P1!
	SOSLE DSER,SCHMQT	;YES, DO WE RUN THE SCHEDULER THIS TICK?
	CAIA			;NO
	JRST CKJB9		;YES
	SKIPE XJOB(J)		;NO, THIS JOB EXPANDING?
	JRST CHKXJ1		;YES, SCHEDULE TO GET SWAPPED OUT
	LDB DDB,PSEGN		;GOT AN UPPER?
	JUMPE DDB,CPOPJ		;NO, FORGET IT
	SKIPE XJOB(DDB)		;IS HIS UPPER SEGMENT EXPANDING?
	JRST CHKXJ3		;YES
	MOVE DDB,JBTSTS(DDB)	;IS IT IN TRANSIT?
	TLNN DDB,SWP
	POPJ P,			;NO
IFE FTPRIQ,<
	PUSHJ P,STRQN2		;decrement quantum cnt (if haven't already) & store
>;IFE FTPRIQ
	JRST CKJB2A		;YES, SHUT THIS JOB OFF

CKJB11:
IFE FTPRIQ,<
	PUSHJ P,STRQNT		;store remaining quantum count
>;IFE FTPRIQ
	JRST CKJB10		;now go requeue him

IFE FTPRIQ,<
STRQN2:	SKIPE TIMEF		;skip if haven't already decremented quantum count
	JRST STRQN3		;already have decremented count in DSER
STRQNT:	SOSGE DSER,SCHMQT	;count down quantum to see how much is left
STRQN0:	MOVEI DSER,0		;make sure count isn't negative
STRQN3:	DPB DSER,REMQNT		;store remaining quantum count for next time
	POPJ P,

↑REMQNT: POINT QQMQTL,JBTMSC(J),35 ;last unused quantum count, for QXFER
↑REMQND: POINT QQMQTL,JBTMSC(DSER),35 ;last unused quantum count, for QXFER
>;IFE FTPRIQ
;CHKXJB CHKXJ4 CHKXJ3 CHKXJ1 CKJBRN CKJB9 CKJB10 CKJB2A

;BUG TRAP
CHKXJB:	SKIPE XJOB	;THIS SHOULD BE SET.
	POPJ P,		;ALL IS WELL
	AOS XJOB	;GET IT TAKEN CARE OF.
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / XJOB(J) SET BUT NOT XJOB(0)
/
	POPACS
	POPJ P,

CHKXJ4:	PUSH P,J
	MOVE J,DDB
	PUSHJ P,CHKXJB
	POP P,J
	POPJ P,

;HERE WHEN SEGMENT IS EXPANDING
CHKXJ3:
IFE FTPRIQ,<
	PUSHJ P,STRQN2		;decrement quantum cnt (if haven't already) & store
>;IFE FTPRIQ
	PUSHJ P,CHKXJ4
	JRST CKJB2A

;HERE WHEN JOB IS EXPANDING
CHKXJ1:
IFE FTPRIQ,<
	PUSHJ P,STRQN2		;decrement quantum cnt (if haven't already) & store
>;IFE FTPRIQ
	PUSHJ P,CHKXJB
	JRST CKJB2A

IFE FTPRIQ,<
;move job just run (J) from front (or middle) of RUNQ to end of RUNQ
;(this code duplicated from QXFER, since has to be executed a lot)
CKJBRN:	MOVE DSER,JBTQ(J)	;DELETE JOB FROM SOURCE-Q
	MOVS UCHN,DSER		;DSER=FORW. LINK, UCHN=BACK LINK
	HRRM DSER,JBTQ(UCHN)	;GO BACK AND LINK FORWARD PAST THIS JOB
	HRLM UCHN,JBTQ(DSER)	;GO FORWARD AND LINK BACKWARD PAST THIS JOB
;insert at end of RUNQ
	MOVS DSER,JBTQ-RUNQ	;GET THE LAST LINK IN Q in RH DSER
	HRRM J,JBTQ(DSER)	;SET FORWARD LINK from old end to new end
	HRLM J,JBTQ-RUNQ	;SET BACK LINK from header to new end
	HRLI DSER,-RUNQ		;SET OUR FORWARD LINK to header
	MOVSM DSER,JBTQ(J)	;SET OUR BACK LINK to old end
	JRST CKJB2A
>;IFE FTPRIQ

;Job's quantum expired.
CKJB9:
IFE FTPRIQ,<
	PUSHJ P,STRQN0		; store zero remaining quantum count
>;IFE FTPRIQ
;see change to SCH1 - reg
;	MOVEI DAT,QQMQT		; RESET SCHEDULER WAIT TIME
;	MOVEM DAT,SCHMQT
	AOS NTMOS		; BUMP NUMBER OF TIME-OUTS
IFE FTPRIQ,<
	CAIN DDB,RUNQ		; IF IN RUNQ, WE HAVE TO MOVE TO END OF RUNQ
	JRST CKJBRN
>;IFE FTPRIQ
	CAIE DDB,TQ		; IF IN TQ, WE HAVE TO REQUEUE THIS JOB TO RUNQ
	JRST CKJB2A
	MOVEI DDB,RUNQ		; PUT HIM INTO STANDARD RUN QUEUE
	MOVEM DDB,JOBQUE(J)	;SAVE QUEUE CODE (POS SINCE INT TAKEN CARE OF HERE)
	SKIPA DAT,[-1,,QRUNW]
CKJB10:				;HERE TO TURN OFF OLD UNRUNNABLE JOB
	HRR DAT,QBITS(DDB)	;GET ADR FROM POS CODE IN DDB, PRESERVE SIGN OF ORIG
	PUSHJ P,QXFER
	MOVE J,JOB
CKJB2A:
REPEAT 0,<
	PUSHJ P,JOBRLS		;ARRIVE HERE TO TURN OFF A JOB
>
	AOS NSCHOF(J)		;COUNT ANOTHER SCHEDULE OFF FOR THIS JOB
;CKJB1 CKJB2 CKJB2X CKJB4 CKJB6 CKJB8 CKJB7

;	MOVE JOBS TO NEW QUEUES

CKJB1:
CKJB2:	SETZ TAC1,
	SYSPIFF		;MAKE SURE LIST STAYS HONEST
	SKIPN J,QJOB
	JRST CKJB4
	EXCH TAC1,(J)		;GET LIST LINK AND ZERO THIS ENTRY
	HRRZM TAC1,QJOB		;LINK HIM OUT
	SYSPIN
	SUBI J,QJOB		;GET JOB NUMBER
	SYSPIFF		;PROBABLY BETTER DUPLICATED THAN OFF TOO LONG
	MOVM DDB,JOBQUE(J)
	CAILE DDB,MXQUE		;IS QUEUE CODE REASONABLE?
	JRST CKJB2X		;NO.
	MOVE DAT,JOBQUE(J)	;NEW QUEUE, - → GEN INT IF ENABLED
	MOVMM DAT,JOBQUE(J)	;INT NO LONGER NEEDED
	SYSPIN
	MOVM DDB,DAT		;GET POS FORM
	HRR DAT,QBITS(DDB)	;AND BITS (PRESERVE SIGN)
	PUSHJ P,QXFER		;DO THE QXFER THING
	JRST CKJB2

CKJB2X:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /JOBQUE CLOBBERED AT CKJB2X.  JOBQUE = /
	MOVE TAC,JOBQUE(J)
	PUSHJ P,DISOCT
	PUSHJ P,DISTAB
	PUSHJ P,DISJOB
	PUSHJ P,DISCRLF
	POPACS	
	JRST CKJB2

CKJB4:	SYSPIN		;TURN PI'S BACK ON
	MOVEI QJ,AVLNUM		;CK AVAL FLAGS FOR SHAR. DEVS.
CKJB6:	SKIPN AVALTB(QJ)	;FLAG=0?
	SOJGE QJ,CKJB6		;YES - TRY NEXT ONE
	CAIGE QJ,MINQ		;LESS THAN MIN. SHAR. DEV.Q?
	JRST CKJB7		;YES. IGNORE.
	MOVN J,QJ		;NO--GET 1ST JOB IN Q
	HRRE J,JBTQ(J)
	JUMPLE J,CKJB8		;FINISHED Q?

IFN FTMQBUG,<
IFN MTCNUM,<
	CAMN J,MTQBUG		;IS THIS THE RELEVANT JOB?
	CAIE QJ,MTQ		;YES. AND THE RIGHT QUEUE?
	CAIA			;NOT RIGHT JOB AND RIGHT QUEUE
	SETZM MTQBG1		;YES.  CLEAR THE TRAP FLAG
>;IFN MTCNUM
>;IFN FTMQBUG

	MOVNI DAT,RUNQ		; REQUEUE HIM TO THE RUN QUEUE
	MOVEM DAT,JOBQUE(J)
	HRROI DAT,QRUNW		;- SO INT CAN HAPPEN
	SETZM AVALTB(QJ)	;CLEAR AVAL FLAG
	HRRZM J,CALLTB(QJ)	;BUT SET FLAG IN CASE OF CALL BEFORE BEING RUN
	PUSHJ P,QXFER		;REQUEUE THE JOB AND PUT IT IN
				;PROCESSOR Q SO SCHEDULER WILL RUN IT
CKJB8:	SOJG QJ,CKJB6		;CONTINUE IF ANY MORE FLAGS TO LOOK AT
CKJB7:				;NONE--GO SHUFFLE AND SWAP
	HGMAC (7)
	SKIPE INTREQ		;BUT FIRST A WORD FROM OUR INTERRUPTS
	PUSHJ P,INTRUN		;(QXFER MAY HAVE GENERATED INTS)


	HGMAC(10)
	PUSHJ P,SWAP
	HGMAC(6)

;FALLS THROUGH TO NEXT PAGE
;SCHED SCHPDR SCH2 SCHSCN SCHD2 SCHD3 SCH2

; SCAN JOB STATUS TABLES FOR A JOB TO RUN

;FALLS THROUGH FROM PREVIOUS PAGE

SCHED:	AOS NSCHEDS		;COUNT NUMBER OF TIMES THROUGH HERE
	MOVEI DAT,ALLRUNSCAN	;SCAN TQ AND RUNQ ONLY
	JSP PC,QSCAN
	JRST SCHD1		;NOBODY LEFT, RUN NULL JOB
	PUSH P,DAT		;SAVE POINTER TO QUEUE SCAN LIST
	PUSHJ P,CHKJOB		;IS HE REALLY RUNNABLE?
	JRST SCHPDR		;NO, TRY NEXT GUY
	POP P,DAT
	JRST SCH1		;YES, DO IT

SCHPDR:	POP P,DAT
SCH2:	JRST (QR)

REPEAT 0,<			;FLUSH THIS
SCHSCN:	MOVE J,JOB		; START AT CURRENT JOB NUMBER MINUS ONE
SCHD2:	SOJG J,SCHD3		; WRAP JOB 0 AROUND TO MAXIMUM LEGAL JOB NUMBER
	MOVEI J,JOBN-1
SCHD3:	PUSHJ P,CHKJOB		; IS HE REALLY RUNNABLE?
	JRST SCH2		; NO
	JRST SCH1		; YES, DO IT.

SCH2:	CAIN J,1		; IS THIS JOB 1?
	SKIPE JOB		; IF THIS IS JOB 1 AND THE NULL JOB RAN LAST, WE ARE DONE
	CAMN J,JOB		; ARE WE BACK TO WHERE WE STARTED?
	JRST SCHD1		; YES, RETURN NULL JOB
	JRST SCHD2		; NO, SCAN NEXT JOB
>;END REPEAT 0
;CHKJOB CHKXOK

; THIS ROUTINE CHECKS TO SEE IF THE JOB IN J IS REALLY RUNNABLE   CHKJOB
; RETURNS IF NOT RUNNABLE, TAKES SKIP RETURN IF RUNNABLE

CHKJOB:	HLRZ IOS,JBTSTS(J)	;PICK UP STATUS BITS
	ANDCMI IOS,RUNMSK	;ZERO THE BITS THAT DON'T MATTER
	SKIPE XJOB(J)
	JRST CHKXJB		;JOB IS EXPANDING.  CAN'T BE RUN.
CHKXOK:	CAIN IOS,RUNABLE	;IS THIS JOB RUNNABLE
	JRST SCHD4		;YES.  MAKE SURE THAT SEGMENT IS THERE.
	TRNE IOS,RUN
	POPJ P,
	MOVM DAT,JOBQUE(J)
	CAIE DAT,RUNQ
	POPJ P,
	PUSHACS
	MOVSI DAT,RUN
	ANDCAM DAT,JBTSTS(J)
	MOVNI DAT,STOPQ
	MOVEM DAT,JOBQUE(J)
	PUSHJ P,REQUE
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ /  IN RUNQ; NOT RUNNABLE. JBTSTS= /
	MOVE TAC,JBTSTS(J)
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	POPACS
	POPJ P,
;SCHD4 SCH3 SCH3A SCH3ER SCH5 CLRSGW CLRSGX CLRSGZ

; HERE WE SEE IF THIS JOB'S HIGH SEGMENT IS IN CORE   CLRSGW

SCHD4:	LDB DDB,PSEGN		;DOES THIS JOB HAVE A HIGH SEGMENT?
	JUMPE DDB,CPOPJ1	;SKIP RETURN IF NOT.
	MOVE DSER,JBTSTS(DDB)
	TLNE DSER,SWP		;IS SEGMENT SWAPPED?
	JRST SCH5		;YES.  HAVE TO DRAG IT IN.
	SKIPE XJOB(DDB)		;SEGMENT EXPANDING?
	JRST CHKXJ4		;YES.  CAN'T RUN LOWER NOW.
	PUSH P,J		;SAVE LOWER'S NUMBER.
	MOVE J,DDB		;J←SEGMENT'S NUMBER.
	MOVM DSER,JOBQUE(J)
	CAIN DSER,STOPQ		;IS THE SEGMENT IN STOPQ?
	JRST SCH3		;YES.
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / SEGMENT IN SEGQ BUT IN CORE AT SCH3
/
	POPACS
	MOVEI DSER,STOPQ	;MUST HAVE BEEN IN SEGQ.  MOVE IT TO STOPQ.
	MOVNM DSER,JOBQUE(J)
	MOVEI DAT,QSTOPW
	PUSHJ P,QXFER
SCH3:	SKIPG J,SEGWAIT		;IS THERE SOMEONE WAITING FOR A SEGMENT?
	JRST SCH3A		;NO.
	LDB DAT,PSEGN
	CAMN DAT,DDB		;WAS HE WAITING FOR THIS SEGMENT?
	PUSHJ P,SCH3ER
SCH3A:	POP P,J
	JRST CPOPJ1

SCH3ER:	PUSHACS
	MOVE J,DDB
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / SEGWAIT'S UPPER IS ALREADY IN CORE AT SCH3
/
	POPACS
	SETZM SEGWAIT
	POPJ P,

SCH5:	SKIPE SEGWAIT		;HERE TO DRAG A SEGMENT INTO CORE.
	POPJ P,			;IF SEGWAIT IS SET, WE CAN'T EVEN START.
	MOVEM J,SEGWAIT		;STUFF JOB NUMBER WHO NEEDS IT.
	MOVM DAT,JOBQUE(DDB)
	CAIN DAT,SEGQ		;IS SEGMENT ALREADY IN SEGQ?
	POPJ P,			;YES. (THAT'S STRANGE)
	PUSH P,J
	MOVE J,DDB
	MOVEI DAT,SEGQ
	MOVNM DAT,JOBQUE(J)
	MOVEI DAT,QSEGW		;PUT IT IN SEGMENT WAIT QUEUE
	PUSHJ P,QXFER
	POP P,J
	POPJ P,

CLRSGW:	PUSH P,J
	PUSH P,DAT
	SKIPN J,SEGWAIT
	JRST CLRSGX
	SETZM SEGWAIT
	LDB J,PSEGN		;J←UPPER OF SEGWAIT JOB
	JUMPE J,CLRSGX
	MOVM DAT,JOBQUE(J)
	CAIN DAT,STOPQ
	JRST CLRSGZ		;UPPER ALREADY IN STOPQ
	MOVNI DAT,STOPQ
	MOVEM DAT,JOBQUE(J)
	PUSHJ P,REQUE		;REQUE IT TO STOPQ
CLRSGX:	POP P,DAT
	POP P,J
	POPJ P,

CLRSGZ:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ /AT CLRSGW UPPER ALREADY IN STOPQ
/
	POPACS
	JRST CLRSGX
;SCH1 SCH6 SCH4 SCHD1

; AT THIS POINT, WE HAVE ALMOST DECIDED ON A JOB
; WE CLAIM IT AND RETURN

SCH1:	PUSH P,TEM
IFE FTPRIQ,<
;Any possible quantum length must fit in the REMQNT byte!
	LDB TEM,REMQNT		;get leftover quantum count for this job, if any
	SKIPN TEM		;use it, if nonzero
>;IFE FTPRIQ
	MOVEI TEM,QQMQT		;else use standard quantum
	MOVEM TEM,SCHMQT	;SET SCHEDULER QUANTUM
	POP P,TEM

REPEAT 0,<
	MOVE DDB,JB2STS(J)
SCH6:	TLNN DDB,RUN1
	JRST SCH2
SCH4:	PUSHJ P,JOBGET
	JRST SCH2
>;END REPEAT 0

	POPJ P,			;RETURN

SCHD1:	MOVEI J,0		;RETURN NULL JOB
	SETZM SCHMQT		;RUN SCHEDULER AGAIN SOON
	AOS NNULLJS		;BUMP NUMBER OF TIMES NULL JOB SELECTED
	POPJ P,
;JOBGET JOBG3 JOBG2 JOBG1 JOBRLS JOBRL1 JOBRER JOBR2

;;2-PROCESSOR ROUTINES TO INTERLOCK JOBS
		;JBTOWN(J) GT 0 MEANS JOB J IS BEING RUN BY P1
		;JBTOWN(J) LT 0 MEANS JOB J IS BEING RUN BY P2
REPEAT 0,<

JOBGET:
	PSYNC JBTCSC
JOBG3:	SKIPGE JBTOWN(J)
	JRST JOBG1
	AOS JBTOWN(J)
JOBG2:	AOS (P)
JOBG1:	XSYNC JBTCSC
	POPJ P,

JOBRLS:
JOBRL1:	SOSL JBTOWN(J)
	POPJ P,
JOBRER:	PUSHACS
	MOVE TAC,UPTIME
	EXCH TAC,LASTDISASTERTIME
	SUB TAC,UPTIME
	MOVN TAC,TAC
	CAIG TAC,=60*JIFSEC
	SYSPIFF
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /ππJOB RELEASED ILLEGALLY
/
	DEBCHECK(POPACS)
	SKIPN DISFLAG
	JRST JOBR2
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

JOBR2:	AOS JBTOWN(J)
	POPJ P,
>
;ORDER ORD3 ORD2 ORD1 ORDINS ORDX

; HERE, WE SORT THE RUN QUEUE INTO PRIORITY ORDER, EVERY 2 OR 3 SECONDS (SEE JLCAL)

;Called when ORDYET is nonzero
↑ORDER:	MOVE DDB,INTIME		;TOTAL INTERRUPT TIME
	EXCH DDB,OINTIME	;SAVE IT
	SUB DDB,OINTIME		;-(RECENT INTERRUPT TIME)
	MOVE J,UPTIME		;CURRENT UPTIME
	EXCH J,OUTIME		;SAVE IT
	SUB J,OUTIME		;-(CHANGE IN UPTIME)
	MOVE DSER,DDB		;SAVE -(RECENT INTERRUPT TIME)
	SUB DDB,J		;(DELTA UPTIME)-(DELTA INTERRUPT TIME)
	MOVEM DDB,JLFACTOR	;SAVE AS WEIGHTING FACTOR.
	MOVEM DDB,RJLFACTOR
	MOVSI DDB,1
	IDIVM DDB,RJLFACTOR	;AVOID REMAINDER
	IMULI DSER,=1000
	IDIVM DSER,J
	MOVEM J,JLRIT		;SAVE RECENT INTERRUPT FRACTION, *1000
IFE FTPRIQ,<
	POPJ P,
>;IFE FTPRIQ
IFN FTPRIQ,<	;rest of page
	MOVE TAC,[JBTNPR,,JBTPRI]
	BLT TAC,JBTPRI+JOBN-1
	MOVNI Q,RUNQ
ORD3:	HRRE Q,JBTQ(Q)		;PICK UP FIRST JOB IN RUN QUEUE
	JUMPL Q,ORDX		;NO MORE, EXIT.
ORD2:	HRRE DSER,JBTQ(Q)	;GET NEXT JOB IN QUEUE.
	JUMPL DSER,ORDX		;IF NO NEXT JOB, WE'RE DONE.
	MOVE DDB,JBTPRI(DSER)	;COMPARE PRIORITIES.
	CAMG DDB,JBTPRI(Q)
	JRST ORD3		;RIGHT ORDER  PRI[Q] GT PRI[DSER].  ADVANCE IN QUEUE
	HLRE UCHN,JBTQ(Q)	;WRONG ORDER. SCAN BACKWARDS TO FIND RIGHT SPOT
ORD1:	JUMPL UCHN,ORDINS	;JUMP IF THERE'S NO FURTHER BACKWARDS.
	CAMG DDB,JBTPRI(UCHN)	;IS THIS WHERE IT SHOULD BE?
	JRST ORDINS		;YES. PRI[UCHN] GT PRI[DSER]
	HLRE UCHN,JBTQ(UCHN)	;ADVANCE BACKWARDS.
	JRST ORD1

;DELETE ENTRY POINTED TO BY DSER; INSERT IT AFTER ENTRY POINTED TO BY UCHN.
ORDINS:	MOVE DDB,JBTQ(DSER)	;DELETE HIM FROM OLD POSITION.
	HLLM DDB,JBTQ(DDB)	;SET BACKWARDS LINK IN GUY FORWARD FROM US.
	MOVS DDB,DDB
	HLRM DDB,JBTQ(DDB)	;SET FORWARDS LINK IN GUY BACKWARD FROM US.
	MOVE DDB,JBTQ(UCHN)	;ADD US AFTER (FORWARDS FROM) OUR TRUE PREDECESSOR
	HRRM DDB,JBTQ(DSER)	;FLINK[DSER]←FLINK[UCHN]
	HRRM DSER,JBTQ(UCHN)	;FLINK[UCHN]←DSER
	HRLM UCHN,JBTQ(DSER)	;BLINK[DSER]←UCHN
	HRLM DSER,JBTQ(DDB)	;BLINK[FLINK[DSER]]←DSER
	JRST ORD2		;HE IS IN PLACE, SCAN SOME MORE (DON'T ADVANCE Q)

ORDX:	SETZM ORDYET		;TELL P2 THAT WE'VE FINISHED OUR SORT
	POPJ P,
>;IFN FTPRIQ
;GRSPRI NSLFPL DFTPRI MAXPRI JLCAL JLCA1

; THIS ROUTINE CALCULATES THE VARIOUS JOB PRIORITIES
; IT DOES SO BY TAKING THE CURRENT JOB LOADING FACTOR,
; DEFINED TO BE TIME WAITING FOR COMPUTE TIME OVER REAL TIME,
; AND PUTS IT IN A TABLE WITH THE PREVIOUS JLLENGTH
; FACTORS. THEN IT MAKES A WEIGHTED AVERAGE OF THESE AND
; ADDS IT INTO THE JOBS TOTAL JOB LOADING HISTORY, WHICH IS
; DECAYED EXPONENTIALLY BY SUBTRACTING A FRACTION EVERY SO OFTEN

IFN FTPRIQ,<
GRSPRI←←360000	;LH priority for jobs having gotten less than guaranteed SL
NSLPRI←←1000	;LH priority for negative service level jobs
>;IFN FTPRIQ
NSLFPL←←<100,,0> ;full word additional weighted PL to fake for NSL jobs
DFTPRI←←300000	;LH value for default priority
MAXPRI←←377777	;LH max priority, given to LOGIN/LOGOUT

LOSYS

↑JLCAL:
;;No P2 ever here any more.
;;	MOVE J,ORDYET		;HAS P1 DONE IT'S THING YET?
;;	JUMPN J,CPOPJ		;IF NOT, WAIT FOR IT
	SOSLE J,JLCYET
	JRST JLCA1
	SETZM SWPCNT
	MOVEI DDB,JLTIME
	MOVEM DDB,JLCYET
;;	SETOM ORDYET
	JRST ORDER		;IF WE'RE P1, NO NEED TO INTERLOCK

JLCA1:	ROT J,-1		;DIVIDE BY 2
	JUMPL J,CPOPJ		;SKIP ODD TICKS.
	CAIL J,JOBN		;LEGAL JOB NUMBERS ONLY
	POPJ P,
	SKIPE DDB,JBTJL(J)	;IS THERE A HISTORY TABLE?
	JRST JLCA3		;YES, GO RECOMPUTE PRIORITY
IFN FTPRIQ,<
	MOVSI DDB,DFTPRI	;NO. MAKE A SILLY ASSUMPTION
	MOVEM DDB,JBTNPR(J)
>;IFN FTPRIQ
	POPJ P,
;JLCA3 JLCA3A JLCA9 JLCA15 JLCA4 JLCA5 JLCA6 JLCA7

; CALCULATE ONE JOB'S NEW PRIORITY
; DECAY PAST, WEIGHT NEAR PAST, THEN COMPUTE PRIORITY
; JBTJLH = DISTANT PAST CELL.
; JBTJL  = TABLE OF FS BLOCKS, ONE-PER-JOB. KEEPS RECENT HISTORY.
; JBTNPR = JOB'S NEW PRIORITY.
; JBTRNB = AMOUNT OF CPU TIME THAT JOB HAS ACCUMULATED SINCE LAST CALL HERE.

JLCA3:	MOVN DSER,JBTJLH(J)		;FIRST, DECAY DISTANT PAST
	ASH DSER,-5
	ADDM DSER,JBTJLH(J)		;PAST ← (31/32)*PAST

	MOVE UCHN,(DDB)			;ADD OLDEST TO DISTANT HISTORY
	ADDM UCHN,JBTJLH(J)		;PAST ← PAST+OLDEST "RECENT" HISTORY

	MOVSI DSER,1(DDB)		;BLT DOWN RECENT HISTORY
	HRRI DSER,(DDB)
	BLT DSER,JLLENGTH-2(DDB)	;MAKE ROOM FOR NEW FACTOR

IFN FTMTRACT,<
	SKIPL MTRBKG
	JRST JLCA3A			;NOT IN ACCOUNTING MODE
	LSH J,1
	MOVE TAC,MTRTTIME(J)
	MOVE TAC1,MTRTTIME+1(J)
	PUSHJ P,MTRCVT			;CONVERT TO TICS IN TAC
	LSH J,-1
	EXCH TAC,MTRRNB(J)
	SUB TAC,MTRRNB(J)
	MOVN DSER,TAC			;TICS SINCE LAST TIME HERE
	CAIA
JLCA3A:
>;IFN FTMTRACT
	HRRZ DSER,JBTRNB(J)		;PICK UP RUN TIME USED
	IMUL DSER,RJLFACTOR		;DIVIDE BY USEABLE TIME. = PROCESSOR LEVEL
	MOVEM DSER,JLLENGTH-1(DDB)	;SET IN LAST POSITION IN TABLE (MOST RECENT)
					;1,,0 = 100% PL
	SETZB AC3,JBTRNB(J)
IFE FTPRIQ,<
	POPJ P,			;we don't compute any priorities, so all done
>;IFE FTPRIQ
IFN FTPRIQ,<	;to end of next page
	MOVE DSER,JBTSTS(J)	;GIVE LOGIN AND LOGOUT GOOD SERVICE
	TLNN DSER,JACCT		;ACCOUNTING?
	JRST JLCA15		;NO.
	MOVSI DDB,MAXPRI	;GIVE THEM THE HIGHEST POSSIBLE PRIORITY
	HLR DDB,JBTPRI(J)	;RANDOM	;PUT IN SOME NUMBERS FOR GOOD MEASURE
JLCA9:	MOVEM DDB,JBTNPR(J)	;SAVE USER'S PRIORITY
	POPJ P,

JLCA15:
	MOVEI TEM,=100			;WEIGHT.
;;	MOVEI AC1,0			;COUNT WEIGHTS USED
	MOVSI DSER,JLLENGTH-1
	HRRI DSER,JLLENGTH-1(DDB)	;DSER ← <JLLENGTH-1,,ADDRESS OF DATA>
JLCA4:	MOVE AC2,(DSER)			;PICK UP HISTORICAL JOB LOAD
	IMULI AC2,(TEM)			; %PL * WEIGHT
;;	ADDI AC1,(TEM)			;SUM OF ALL WEIGHTS.
	ADD AC3,AC2
	MOVEI AC2,(TEM)
	LSH AC2,-3
	SUBI TEM,(AC2)			;WEIGHT ← (7/8)*WEIGHT.
	SUB DSER,[1,,1]
	JUMPG DSER,JLCA4		;LOOP THROUGH JOB HISTORY

	MOVE AC2,JBTJLH(J)		;PICK UP DISTANT PAST
	IMULI AC2,(TEM)			;JUST TO MAKE CURVES JOIN
;;	ADDI AC1,(TEM)			;ADD UP WEIGHTS.
	ADD AC3,AC2
	SUB AC3,[DFTPRI,,0]		;USAGE - DEFAULT PRIORITY = -(PRIORITY)
	MOVNM AC3,JBTNPR(J)		;THIS IS THEN HIS PRIORITY
	MOVE AC2,JB2PRV(J)	;See if this job has negative service level
	MOVSI DDB,NSLPRI	;Priority for negative service level
	TLNE AC2,NSLPRV		;Skip if not negative service level
	JRST JLCNSL		;Give low priority
	TLNE AC2,DOVPRV		;Skip unless Dover spooler
	JRST DOVSPL		;Dover, pretend has lots of SL

; CHECK THIS JOB'S SERVICE LEVEL TO SEE IF HE DESERVES HIGHER PRIORITY.
;AC2 = SERVICE GUARANTEE LEVEL, TEM = SUM OF ALL THE SERVICE LEVELS

	SKIPE JBTGSL
	POPJ P,
	HRRZ AC2,JBTGSL(J)		;PICK UP THE SERVICE LEVEL GUARANTEE
	CAILE AC2,320000		;MORE THAN 40.625% SERVICE LEVEL?
DOVSPL:	MOVEI AC2,320000		;REDUCE TO 40% - REG'S UNFAIRNESS.
	HRRZ DDB,PRJPRG(J)
	MOVEI TEM,0			;ADD UP SERVICES TO RELATIVES.
	MOVEI DSER,JOBN-1		;INDEX FOR LOOP THRU JOBS
JLCA5:	HRRZ UCHN,PRJPRG(DSER)
	CAIN DDB,(UCHN)			;DOES THIS GUY HAVE THE SAME PPN
	SKIPN UCHN,JBTJL(DSER)		;YES, DOES HE HAVE ANY PAST
	JRST JLCA6			;NO. LOOP FOR NEXT GUY

	HRLI UCHN,-JLLENGTH		;AOBJN POINTER TO PL HISTORY
	ADD TEM,(UCHN)			;ADD IN THE SERVICE LEVEL
	AOBJN UCHN,.-1

JLCA6:	SOJG DSER,JLCA5	  ;NOW LOOP AROUND TO LOOK FOR ANOTHER GUY WITH SAME PPN
IFN DSER-TEM-1,<.FATAL ACs TEM and DSER are not contiguous as required here.>
	IDIVI TEM,JLLENGTH		;NORMALIZE PL.  SUM OF PL OF ALL RELATIVES.

;FALLS THROUGH TO NEXT PAGE
;JLCA10 JLCA14 JLCA12 JLCA13 JLCA11 JLCA20 JLCNSL

;FALLS THROUGH FROM PREV PAGE

; ADD UP THE SERVICES TO HIS VARIOUS RELATIVES
	CAMG AC2,TEM		; SEE IF HE GOT MORE THAN HE BARGAINED FOR
	POPJ P,			; YES, HE NOW JUST FOLLOWS HIS PRIORITY
IFN FTSLCORE,<
	SKIPN SLCOST		; ARE WE CHARGING FOR CORE?
	JRST JLCA20		;NO SKIP THIS STUFF.
	PUSH P,AC2		;SAVE HIS GSL 
	PUSH P,TEM		;SAVE ACTUAL PL
	MOVEI TAC1,JOBN-1	; OK. NOW SEE IF HE IS A CORE LEVEL VIOLATOR
	HRRZ AC1,PRJPRG(J)
	MOVEI AC2,0		;COUNT SUM OF CORE SIZES.
JLCA10:	HRRZ AC3,PRJPRG(TAC1)
	MOVM DAT,JOBQUE(TAC1)	; PICK UP HIS QUEUE CODE
	CAME AC1,AC3
	JRST JLCA11
	CAIE DAT,TQ		;ADD HIS CORE SIZE IF RUNNING OR LOCKED IN
	CAIN DAT,RUNQ
	JRST JLCA14
	CAIE DAT,DIOWQ
	SKIPE JBTST2(TAC1)	;SPACEWAR DOES THIS TOO
	JRST JLCA14
	MOVEI DAT,JLOCK
	TDNN DAT,JBTSTS(TAC1)
	JRST JLCA11

JLCA14:	PUSH P,TAC1		;SAVE JOB NUMBER WE'RE THINKING ABOUT.
	PUSHJ P,CORSGT		;GET HIS CORE SIZE IN TAC1
	ADDI AC2,(TAC1)		;ADD IN TO CORE TOTAL
	MOVE TAC1,(P)		;GET JOB NUMBER BACK
	LDB TAC1,[POINT JOBNSZ,JBTSTS(TAC1),35]
	JUMPE TAC1,JLCA13
	MOVEI DDB,JOBN-1	;HE GETS CHARGED FOR (1/N) OF HIS HIGH SEGMENT CORE
	MOVEI UCHN,0		;WHERE N WILL BE THE NUMBER OF PEOPLE POINTING AT THIS SEGMENT
JLCA12:	LDB DSER,[POINT JOBNSZ,JBTSTS(DDB),35]
	CAMN DSER,TAC1
	SKIPL JBTSTS(DDB)	; ONLY IF HE IS ACTIVE
	CAIA
	ADDI UCHN,1		; BUMP NUMBER OF JOBS POINTING TO THIS SEGMENT BY ONE
	SOJG DDB,JLCA12
	PUSHJ P,CORSGT		;GET THE SIZE OF THIS UPPER
	MOVE TAC,TAC1
	IDIVI TAC,(UCHN)	; GET HIS SHARE OF THE UPPER SEGMENT CORE
	ADD AC2,TAC		; AND ADD IT IN TO THE TOTAL
JLCA13:	POP P,TAC1
JLCA11:	SOJG TAC1,JLCA10	; LOOP AROUND FOR NEXT JOB

	LSH AC2,-=10		; CONVERT TO NUMBER OF 1K BLOCKS
	MOVSI AC2,(AC2)		; PUT CORE IN K IN LEFT HALF
	MOVE AC3,SLCOST		;AC3←1 OR 2 (LOW OR HIGH COST, RESPCTIVELY)
	IDIV AC2,[=1000		;CONVERT TO ONE PERCENT FOR EACH
		  =500]-1(AC3)	;	10K (LO) OR 5K(HI) OF CORE
	POP P,TEM		; GET PROCESSOR LEVEL
	ADD TEM,AC2		; CALL THIS PROCESSOR LEVEL TOO.
	POP P,AC2		; GET BACK HIS GSL
>;IFN FTSLCORE
JLCA20:	CAMLE TEM,AC2		; IS HE OVER HIS GUARANTEE?
	POPJ P,			; YES, HE IS OFFICIALLY A SCROUNGER
	MOVSI DDB,GRSPRI	; NO, GIVE HIM HIGH PRIORITY
JLCNSL:	HLR DDB,JBTNPR(J)	; WITH HIS REAL PRIORITY AS HIS LOW-ORDER BITS
	MOVEM DDB,JBTNPR(J)
	POPJ P,
>;IFN FTPRIQ

HISYS
SUBTTL	QCSS	24 JULY 67
;THIS ROUTINE MUST BE ASSEMBLED WITH THE CONFIGURATION
;TAPE TO DEFINE NUMBER OF JOBS
;THIS SECTION CONTAINS 2 ROUTINES FOR Q MANIPULATION
;AND NECESSARY TABLES FOR SPECIFING OPERATIONS PERFORMED
;BY THEM.



;STORAGE:
;EACH Q IS A RING STRUCTURED, FOWARD AND BACKWARD
;LINKED SRING LIST. THE "FIRST" LINK IN A Q IS
;A Q-HEADER POINTING TO THE FIRST AND LAST MEMBERS OF THE Q.
;A NULL Q HAS ONE LINK--THE Q-HEADER ITSELF.  THE LINKS MAKING
;UP THE QS ARE CONTAINED IN A TABLE (JBTQ) WITH NEGATIVE
;INDICIES (ADDRESSES LESS THAN JBTQ) USED FOR Q-HEADERS AND
;POSITIVE INDICIES USED FOR MEMBERS (JOBS). THUS ONLY ONE WORD
;PER LINK IS NECESSARY--ITS ADDRESS RELATIVE TO JBTQ GIVES THE
;JOB NO. (OR Q NO. IF NEGATIVE) WHICH IT REPRESENTS WHILE
;ITS CONTENTS CONTAINS THE LINKING POINTERS. THESE
;POINTERS ARE ALSO INDICIES RELATIVE TO JBTQ RATHER THAN
;ABSOLUTE ADDRESSES--RH(LINK)=FOWARD POINTER;
;LH(LINK)=BACKWARD POINTER.
;A JOB IS ASSUMED TO BE IN NO MORE THAN ONE Q AT A TIME, AND
;THE NULL JOB (JOB 0) DOES NOT APPEAR IN THE QS  (I.E. JBTQ
;ITSELF IS THE Q-HEADER FOR Q 0).

;ROUTINES:
;BOTH ROUTINES ARE "TABLE DRIVEN" IN THE SENSE THAT THE
;CALLING ROUTINE PROVIDES THE ADDRESS OF A TABLE WHICH
;DEFINES THE SPECIFIC OPERATIONS TO BE PERFORMED.
;QINI QINI1 QINI2

;QUEUE INITIALIZATION
;PUT ALL JOBS IN NULL QUEUE (NO CORE ASSIGNED)


↑QINI:	MOVE DDB,[-MXQUE,,-MXQUE]	;SET QUEUE HEADERS POINT TO THEMSELVES
	MOVEM DDB,JBTQ(DDB)
	AOBJN DDB,.-1
	MOVEI DDB,-NULQ			;PUT JOBS ALL IN NULQ QUEUE
	MOVSM DDB,JBTQ+1		;BACK POINTER FOR JOB 1
	MOVEI J,JOBN-1			;MAX. JOB NO.
	MOVEM DDB,JBTQ(J)		;FOR. POINTER OF JOBMAX JOB NO.
	HRLM J,JBTQ-NULQ		;SET NULQ HEADER TO POINT TO JOB1
	MOVEI DDB,1			;AND JOBMAX
	HRRM DDB,JBTQ-NULQ		;FORWARD POINTER
	MOVNI DSER,NULQ
QINI1:	HRRM J,JBTQ-1(J)		;JOB I-1 POINT TO JOB I
	MOVEM DSER,JOBQUE(J)
	SOJLE J,QINI2			;FINISHED?
	HRLM J,JBTQ+1(J)		;BACK POINTER JOB I+1 POINTS TO JOB I
	JRST QINI1

QINI2:	SETZM JBTQ
	SETZM QJOB(J)
	MOVE TAC,[QJOB,,QJOB+1]
	BLT TAC,QJOB+JOBN-1
	SETZM XJOB(J)
	MOVE TAC,[XJOB,,XJOB+1]
	BLT TAC,XJOB+JOBN-1
	POPJ P,
;QXFER J QXFER1 QXFER2 QXFER5 QXFU3 QXFU5 QXFU4 QXFU2 QXFER3 QXFER4 QXF6 QXF8 QXSB QXF5 QXF9 QXF2A QXF2B QXF2 QXF3 QXF7 QXF4

;QXFER

;DELETES A JOB FROM ITS "SOURCE-Q", DETERMINES A "DEST-Q"
;ACCORDING TO ONE OF 3 FUNCTIONS, AND INSERTS THE JOB AT
;THE BEGINNING OR END OF THIS DEST-Q.
;THE DRIVING TABLES ARE "TRANSFER TABLES":
;
;
;T. TABLE:	BITS,,-<QUEUE NUMBER>

;CALLING SEQUENCE:
;	MOVE J,[JOB NUMBER]
;	MOVEI/HRROI DAT,TRANS TABLE ADDRESS	;DAT NEG MEANS GEN QXFER INT IF NECC
;	PUSHJ P,QXFER
;  ON RETURN J IS UNALTERED; LH(Q)=-1  IF QUANT. TIME NOT
;  RESET; =QUANT. TIME IF RESET;RH(Q)=DEST.Q

QXFER:	CAIGE J,JOBN		;JOB NUMBER TOO HIGH?
	JUMPG J,QXFER1		;JUMP IF OK.
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL JOB NUMBER AT QXFER.
J=/]
	DISARG (DCP,<-20+J(P)>)
	[ASCIZ /
/]
	-1
	POPACS
	POPJ P,

QXFER1:	JUMPGE DAT,QXFER2	;NO INT NEEDED IF POS
	MOVSI DSER,INTQXF	;DOES HE WANT INT ON Q XFER?
	TDNN DSER,JBTIEN(J)
	JRST QXFER2		;NO INT ON QXFER
	IORM DSER,JBTIRQ(J)
	TDNE DSER,JBTMSK(J)	;ANY BIT MASKED ON?
	SETOM INTREQ		;YES, RUN INTERRUPTS
QXFER2:	SKIPGE Q,(DAT)		;GET TRANSFER TABLE ADDRESS, SKIP IF RUNNABLE QUEUE
	JRST QXFER5
	MOVE AC2,JBTSTS(J)
	TLNE AC2,SWP
	SETZM SWPCNT		;FIRE UP SWAPPER WHEN GOING RUNNABLE AND SWAPPED OUT
QXFER5:	AOS NQXFERS		;COUNT A QUEUE TRANSFER

;NOW WE FIGURE OUT IF IT IS TIME TO SIGNAL THE USER THAT WE ARE WAITING FOR HIM
	TLNE Q,200000		;ARE WE NOW WAITING FOR THE SYSTEM?
	JRST QXFER3		;YES
	TLNE Q,40000		;DO WE NEED TO CHECK TTYIOW BIT?
	JRST QXFU3		;YES
	TLNN Q,20000		;DO WE NEED TO CHECK INTERRUPT ENABLINGS?
	JRST QXFU2		;NO
	MOVSI DSER,INTTTY
	TDNE DSER,JBTIEN(J)	;IS HE TAKING TTY INTERRUPTS?
	JRST QXFU4		;YES, SIGNAL HIM NOW
	JRST QXFU2		;NO

QXFU3:	HRRE UCHN,JBTLIN(J)	;IN IOW, CHECK TTYIOW BIT IN ATTACHED TTY DDB
	JUMPL UCHN,QXFU2	;JUMP IF DETACHED (ASSUME WAITING FOR USER)
	SKIPN DSER,TTYTAB(UCHN) ;GET DDB ADDRESS
	JRST QXFU2		;I GIVE UP, WHERE IS HE?
	SKIPGE DSER,DEVIOS(DSER);TTYIOW IS SIGN BIT IN IOS
	JRST QXFU5		;WAITING FOR INPUT
	TLNN DSER,IOW
	JRST QXFER3		;NOT WAITING FOR TTY AT ALL, WAITING FOR SYSTEM
	TLNE DSER,TTYHLD
	JRST QXFU2		;CHARGE HOLDING TIME TO USER, BUT DON'T SIGNAL HIM
	SKIPE UCHN,LETAB(UCHN) 	;HOLD IS INDICATED DIFFERENTLY ON DPYS
	SKIPN DPHOLD(UCHN)
	JRST QXFER3		;NOT WAITING FOR USER AFTER ALL
	JRST QXFU2		;HOLDING ON DPY--WAITING FOR USER BUT DON'T SIGNAL

QXFU5:	TRNE DSER,IOACT		;IOACT IS OFF IF WAITING FOR EITHER PTY OR TTY
QXFU4:	TLO Q,100000		;SIGNAL USER WE ARE WAITING FOR HIM
QXFU2:	MOVE DSER,UPTIME	;WE ARE WAITING FOR THE USER.
	SKIPL JBTWAT(J)		;WERE WE ALREADY WAITING FOR THE USER?
	JRST QXFER4		;YES, DON'T SIGNAL HIM NOW
	ADDB DSER,JBTWAT(J)	;NO.  NOTE THAT WE ARE NOW
	MOVE AC2,JBTMSC(J)
	TLNN AC2,NOXRST		;IF XTIME NEVER BEING RESET, DON'T EVER SIGNAL
	TLNN Q,100000		;DOES THIS QUEUE XFER NEED TO BE SIGNALLED TO USER?
	JRST QXFER4		;NO
	SUB DSER,JB2WAT(J)	;SEE HOW LONG WE HAVE BEEN WAITING RECENTLY
	SKIPGE JBTMSC(J)	;DOES USER WANT TO KNOW WE ARE DONE?
	CAIGE DSER,=15*=60	;YES, DID HE HAVE TO WAIT 15 SECONDS OR MORE?
	JRST QXFER4		;NO
	PUSHACS			;WHO KNOWS WHAT HE'LL CLOBBER
	PUSHJ P,BEEPJB		;BEEP HIM
	POPACS
	JRST QXFER4

QXFER3:	MOVN DSER,UPTIME	;WE ARE WAITING FOR THE SYSTEM
	SKIPL JBTWAT(J)		;WERE WE ALREADY WAITING FOR THE SYSTEM?
	ADDM DSER,JBTWAT(J)	;NO.  NOTE THAT WE ARE NOW
QXFER4:	HRRE DSER,Q		;SAVE QUEUE CODE IN DSER
	MOVM DSER,DSER		;GET THE Q CODE. PUT IT IN JBTSTS FOR THIS JOB
	CAIG DSER,MAXQ		;IF RELEVANT TYPE
	DPB DSER,[POINT JWSIZ,JBTSTS(J),JWPOS]	;STORE WAIT STATE CODE

IFN FTSTAT, <			;GATHER STATISTICS.
	PUSH P,TAC
	LSH DSER,6
	MOVEI TAC,QUESTA(DSER)
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT

	MOVE DSER,JBTQ(J)	;DELETE JOB FROM SOURCE-Q
	MOVS UCHN,DSER		;DSER=FORW. LINK, UCHN=BACK LINK
	HRRM DSER,JBTQ(UCHN)	;GO BACK AND LINK FORWARD PAST THIS JOB
	HRLM UCHN,JBTQ(DSER)	;GO FORWARD AND LINK BACKWARD PAST THIS JOB
IFN FTPRIQ,<
	CAME Q,QRUNW		;ARE WE ENTERING THE RUN QUEUE?
	JRST QXF3		;NO
	MOVE AC2,JBTPRI(J)	;GET THIS GUY'S PRIORITY
	CAMGE AC2,[DFTPRI,,0]	;SKIP IF BIG, WE WILL SCAN FORWARD
	JRST QXSB		;SMALL PRIORITY, SCAN BACKWARDS.
	HRRE DSER,JBTQ(Q)	;SEARCH AHEAD. PICK UP FORWARD LINK
	JUMPL DSER,QXF3		;NO ONE HERE. THERE'S NO ORDERING NEEDED
QXF6:	CAML AC2,JBTPRI(DSER)	;IS THIS THE RIGHT PLACE FOR HIM?
	JRST QXF8		;YES. OUR (J) PRIORITY .GT. HIS (DSER)
	HRRE DSER,JBTQ(DSER)	;OUR PRIORITY IS SMALL, KEEP LOOKING
	JUMPGE DSER,QXF6	;LOOP UNLESS END OF LIST, STICK HIM AT BOTTOM.
	JRST QXF3		;GO STICK HIM IN AT THE BOTTOM.
QXF8:	HLRZ UCHN,JBTQ(DSER)	;PUT US BEFORE DSER, AND AFTER DSER'S BACK LINK.
	HRLZM UCHN,JBTQ(J)	;STICK HIS BACK LINK IN AS OUR BACK LINK.
	HRLM J,JBTQ(DSER)	;STICK US IN AS DSER'S BACK LINK.
	HRRM DSER,JBTQ(J)	;STICK DSER IN AS OUR FORWARD LINK.
	HRRM J,JBTQ(UCHN)	;STUFF US IN AS UCHN'S FORWARD LINK.
	JRST QXF4		;ALL DONE WITH TRANSFER.

QXSB:	HLRE DSER,JBTQ(Q)	;SORTING IN FROM THE BOTTOM. FOLLOW BACK.
	JUMPL DSER,QXF3		;JUMP IF Q IS EMPTY. PUT US IN THE END.
QXF5:	CAMG AC2,JBTPRI(DSER)	;SKIP IF OUR PRIORITY ≥ HIS PRIORITY
	JRST QXF9		;OUR PRIORITY IS SMALL. WE HAVE A HOME.
	HLRE DSER,JBTQ(DSER)	;LINK BACKWARDS.
	JUMPGE DSER,QXF5	;CONTINUE SCAN FOR A PLACE TO PUT US.
	JRST QXF7		;WE BELONG AT TOP OF Q.

QXF9:	HRRZ UCHN,JBTQ(DSER)	;WE BELONG BELOW DSER. GET DSER'S FORWARD LINK
	MOVEM UCHN,JBTQ(J)	;SET OUR FORWARD LINK FROM DSER'S LINK.
	HRRM J,JBTQ(DSER)	;SET US AS DSER'S FORWARD LINK.
	HRLM DSER,JBTQ(J)	;SET DSER AS OUR BACKWARDS LINK
	HRLM J,JBTQ(UCHN)	;SET US AS UCHN'S BACKWARDS LINK.
	JRST QXF4		;ALL DONE.

>;IFN FTPRIQ
IFE FTPRIQ,<
	;fell through from above!
	CAME Q,QRUNW		;entering the run queue?
	JRST QXF3		;no, enter at end of queue
	MOVE UCHN,TIMDAT	;current date,,time(secs)
	SUB UCHN,FTIME(J)	;subtract last date&time run
	LSH UCHN,LDSHF+LDPWR	;shift over to line up with load average
	CAML UCHN,LDAVG		;if haven't run for this many secs,
	JRST QXF2		;then put in TQ for high priority
	MOVE UCHN,JB2PRV(J)	;see if this is dover spooler
	TLNE UCHN,DOVPRV	;skip unless Dover spooler
	JRST QXF2		;then put in TQ for high priority
	MOVE UCHN,JBTSTS(J)	;not spooler, see if LOGIN or LOGOUT
	TLNE UCHN,JACCT		;skip unless LOGIN/LOGOUT
	JRST QXF2		;put in TQ for high priority
	LDB UCHN,REMQNT		;see if any leftover quantum count
	JUMPE UCHN,QXF3		;jump if no leftover count, put at end of queue
;Now we have a job w/leftover quantum count from last run.  Insert at front of
;the RUNQ but after any other such jobs already in RUNQ.
	MOVE DSER,Q		;start at front of queue
QXF2A:	SKIPGE DSER,JBTQ(DSER)	;put at front, but after others w/leftover counts
	JRST QXF2B		;end of queue, put before DSER
	LDB UCHN,REMQND		;get count for job in DSER
	JUMPN UCHN,QXF2A	;loop if that job has a count too
;Found first guy in RUNQ w/o leftover count.  Insert ahead of that job (DSER).
QXF2B:	HLRZ UCHN,JBTQ(DSER)	;PUT US BEFORE DSER, AND AFTER DSER'S BACK LINK.
	HRLZM UCHN,JBTQ(J)	;STICK HIS BACK LINK IN AS OUR BACK LINK.
	HRLM J,JBTQ(DSER)	;STICK US IN AS DSER'S BACK LINK.
	HRRM DSER,JBTQ(J)	;STICK DSER IN AS OUR FORWARD LINK.
	HRRM J,JBTQ(UCHN)	;STUFF US IN AS UCHN'S FORWARD LINK.
	JRST QXF4		;ALL DONE WITH TRANSFER.

QXF2:	MOVE Q,QTW		;put in TQ, not RUNQ after all, for high priority
>;IFE FTPRIQ
;add job at end of the queue
QXF3:
IFE FTPRIQ,<
	CAMN Q,QTW		;entering TQ?
	PUSHJ P,STRQN0		;yes, clear leftover quantum count (get full quantum)
>;IFE FTPRIQ
	HLR Q,JBTQ(Q)		;GET THE LAST LINK IN Q. UCHN becomes Q hdr.
;enter here to add job at front of the queue
QXF7:	MOVE UCHN,JBTQ(Q)	;UCHN IS FORWARD LINK AND Q IS Q-HEADER.
	HRRM J,JBTQ(Q)		;SET FORWARD LINK
				;F/ INSERT IN Q HEAD. B/ INSERT AT END.
	HRLM J,JBTQ(UCHN)	;SET BACK LINK
				;F/ INSERT IN FIRST.  B/ INSERT AT Q-HEAD.
	HRRZM UCHN,JBTQ(J)	;SET OUR FORWARD LINK
	HRLM Q,JBTQ(J)		;SET OUR BACK LINK.

QXF4:	JUMPL Q,QNORUN		; RETURN IF QUANTUM TIME NOT REQUESTED

;HERE WE ARE IF JOB IS COMING INTO A RUN QUEUE

	SETZ DSER,		;CLEAR WAIT STATE CODE IN JBTSTS
	DPB DSER,[POINT JWSIZ,JBTSTS(J),JWPOS]
	POPJ P,			;RETURN
;QNORUN QNORU4 QNORUN QNORU4 QNORU1

; JOB IS NOT RUNNING.  REQUEUE HIS SEGMENT IF NEEDED.   QNORUN

;REG 3-26-75.  LET SOME OTHER USER OF THE SEGMENT CAUSE IT TO COME IN.
QNORUN:	CAME J,SEGWAIT		;IS THIS THE GUY WHO'S WAITING FOR A SEGMENT?
	POPJ P,			;NO.
	SETZM SEGWAIT		;YES - WAIT NO LONGER.
	PUSH P,J
	LDB J,PSEGN		;GET NUMBER OF THE SEGMENT
	JUMPE J,QNORU4
	MOVM DAT,JOBQUE(J)
	CAIN DAT,STOPQ
	JRST QNORU4		;DON'T CHANGE QUEUE IF ALREADY STOPPED.
	MOVNI DAT,STOPQ		;AND STUFF IT INTO STOPQ
	MOVEM DAT,JOBQUE(J)	
	MOVEI DAT,QSTOPW
	PUSHJ P,QXFER
QNORU4:	POP P,J
	POPJ P,

REPEAT 0,<
QNORUN:	CAMN J,SEGWAIT		;WAS THIS GUY WAITING FOR HIGH SEGMENT?
	SETZM SEGWAIT		;YES, NOT ANY MORE
	LDB DSER,PSEGN		;DOES THIS JOB HAVE A HIGH SEGMENT?
	JUMPE DSER,CPOPJ	;NO, FORGET IT
	MOVM UCHN,JOBQUE(DSER)	;YES, IS IT IN SEGMENT WAIT QUEUE?
	CAIE UCHN,SEGQ
	POPJ P,			;NO, RETURN
	PUSH P,J		;YES, IF NO ONE ELSE WANTS SEGMENT, REQUE IT
	MOVE J,DSER		;UPPER'S NUMBER INTO J
	MOVEI UCHN,0		;FLAG FOR WHETHER LOWERS ARE ACTIVELY USING UPPER
	PUSHJ P,UAPPLY
	 PUSHJ P,QNORU1		;TEST THIS LOWER FOR ACTIVE
	JUMPG UCHN,QNORU4	;JUMP IF SOMEONE NEEDS THIS SEGMENT
	MOVNI DAT,STOPQ		;NO ONE CARES FOR THIS.
	MOVEM DAT,JOBQUE(J)	
	MOVEI DAT,QSTOPW	;NO RUNNABLE JOB USING THIS SEGMENT, REQUEUE IT
	PUSHJ P,QXFER
QNORU4:	POP P,J
	POPJ P,

QNORU1:	MOVE AC2,JBTSTS(J)	;GET JOB STATUS OF THIS GUY
	TLNE AC2,SWP		;DOESN'T COUNT IF HE'S SWAPPED OUT
	POPJ P,			;SO LOOK FOR SOMEONE ELSE.
	MOVM AC2,JOBQUE(J)	;AND HIS QUEUE
	CAIE AC2,RUNQ		;IS THIS GUY RUNNABLE?
	CAIN AC2,TQ
	AOJA UCHN,CPOPJ1	;THIS GUY WANTS THIS SEGMENT.  RETURN QUICK!
	POPJ P,
>;END REPEAT 0
;SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
;THE ORDER AND MANNER IN WHICH THE QS ARE SEARCHED IS
;DETERMINED BY A "SCAN TABLE" ADDRESSED IN THE CALLING SEQ.
;THE SCAN TABLE HAS THE FORM:
;
;SCANTAB:	<Q1>,,<CODE1>	;SCN Q1 ACCRDING TO CODE1
;		...
;		<QN>,,<CODEN>	;QN ACCORDING TO CODEN
;		Z		;ZERO TERMINATES TABLE
;
;EACH Q MAY BE SCANNED IN ONE OF FOUR WAYS SPECIFIED BY <CODE>
;THE CODES ARE:
;
;QFOR	SCAN WHOLE Q FOWARD
;QFOR1	SCAN FOR ONLY THE 1ST MEMBER (IF ANY)
;QBAK	SCAN WHOLE Q BACKWARD
;QBAK1	SCAN BACKWARD FOR ALL MEMBERS EXCEPT THE 1ST
;
;CALLING SEQ.
;
;	MOVEI DAT,SCAN TABLE ADDRESS
;	JSP PC,QSCAN	;SET UP PC FOR REPEATED RETURNS
;	...		;RETURN HERE WHEN NO MORE JOBS
;	...		;RETURN HERE WITH NEXT JOB IN AC J
;			;   AND ITS Q IN LH(QR)
;
;	PERFORM ANY NECESSARY TESTING OF THIS JOB
;	J,DAT,PC,QR MUST BE PRESERVED
;
;	JRST (QR)	;RETURN TO QSCAN TO GET NEXT JOB
;			;   IF THIS ONE NOT ACCEPTABLE
;
;QSCAN QFOR1 QFOR QFORB QBAK1 QBAK QFOR2

↑QSCAN:	SKIPN QR,(DAT)	;END OF SCAN TABLE?
	JRST (PC)	;YES--RETURN TO CALL+1
	HLRE J,QR	;NO--GET NO. OF Q
	JRST (QR)	;DISPATCH

QFOR1:	MOVEI QR,QFORB	;ONLY THE FIRST JOB

QFOR:	HRRE J,JBTQ(J)	;SCAN FOWARD ALL JOBS
	JUMPGE J,1(PC)	;RETURN THIS JOB NO. CALL+2 UNLESS--
QFORB:	AOJA DAT,QSCAN	;END OF THIS Q--GET NEXT Q

QBAK1:	HLRE J,JBTQ(J)	;SCAN BACKWARD ALL JOBS EXCEPT 1TT
	SKIPLE JBTQ(J)	;IS THIS THE FIRST MEMBER?
	JRST 1(PC)	;NO--RETURN CALL+2
	AOJA DAT,QSCAN	;YES--GET NEXT Q

QBAK:	HLRE J,JBTQ(J)	;SCAN BACKWARD ALL JOBS
	JUMPG J,1(PC)	;RETURN CALL+2 WITH JOB NO. UNLESS
	AOJA DAT,QSCAN	;BEG OF THIS Q--GET NEXT Q

QFOR2:	HRRE J,JBTQ(J)	;ALL BUT FIRST JOB
	HRRI QR,QFOR	;PUT UP NEW RESCAN ADDRESS
	JUMPGE J,QFOR	;IF NOT END OF QUEUE, GET SECOND JOB
	AOJA DAT,QSCAN	;END OF QUEUE, TRY NEXT ONE
DEFINE X'(A),<

↑A'Q←←ZZ
ZZ←←ZZ+1
>
	ZZ←←0
	QUEUES
	LOC←←ZZ
NQUEUE←←LOC		;NO. OF QUEUES COUNTING RUN QUEUE
XP MAXQ,NQUEUE-1	;MAX. STATE CODE WHICH HAS AN AVAL FLAG
XP MINQ,ELFQ		;MINIMUM SHARABLE DEVICE QUEUE
XP AVLNUM,MAXQ		;MAX. STATE CODE WHICH HAS AN AVAL FLAG

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS


DEFINE X!(A)
<
↑A!Q←←LOC
LOC←←LOC+1
>
	CODES
	PQUES		;PROCESSOR QUEUES TOO!!
;QBITS QFUCKW QTW QRUNW QSTW QDTW QDCW QMTW QIOWW QINTWW QDIOWW QNULW QSTOP QSTOPW QSEGW QDWW QPAGEW

;CORRESPONDENCE TABLE BETWEEN JOB STATUS CODES AND QUEUE TRANSFER TABLES
;USED BY SCHEDULER
;RUNCSS SETS JOB STATUS WORD TO NEW STATE CODE.
;SCHEDULER SETS UP QUEUE TRANSFER TABLE ADDRESS FROM
;FOLLOWING TABLE USING NEW STATE CODE AS INDEX

DEFINE X!(A)
<	Q!A!W
>


QBITS:	QUEUES
	CODES
	PQUES


;400000,,0 BIT MEANS IS NOT RUNNABLE QUEUE
;200000,,0 BIT MEANS QUEUE REQUIRES WAITING FOR THE SYSTEM RATHER THAN THE USER
;100000,,0 BIT MEANS TELL USER WE ARE DONE (IF HE ASKED US TO)
;040000,,0 BIT MEANS CHECK TTYIOW BIT FOR ATTACHED TTY DDB AND TELL USER WE ARE
;			DONE IF IT IS ON AND HE ASKED TO BE TOLD
;020000,,0 BIT MEANS CHECK JBTIEN FOR ENABLING OF ONLY INTTTY BIT

QFUCKW:
QTW:	200000,,-TQ
QRUNW:	200000,,-RUNQ
QELFW:	600000,,-ELFQ		;ELF
QDTW:	600000,,-DTQ		;DEC TAPE
QDCW:	600000,,-DCQ		;DATA CONTROL WAIT
QMTW:	600000,,-MTQ		;MAG TAPE
QIOWW:	440000,,-IOWQ		;IOW (EXCEPT TTY) HELD IN IOWQ
QINTWW:	420000,,-INTWQ		;INTERRUPT WAIT QUEUE
QDIOWW:	600000,,-DIOWQ
QNULW:	500000,,-NULQ		;NULL QUEUE JOB NO. NOT ASSIGNED
↑QSTOP:
QSTOPW:	500000,,-STOPQ		;UNRUNABLE JOBS TO END OF STOPQ
↑QSEGW:	600000,,-SEGQ		;SEGMENT WAIT QUEUE
QDWW:	400000,,-DWQ		;DEVICE WAIT GOES BACK TO DEVICE WAIT
IFN FTDMDP,<
QPAGEW:	600000,,-PAGEQ
>;IFN FTDMDP
;ISCAN OSCAN RUNSCAN DVWSCAN

ISCAN:	;SCAN FOR INPUT
	-SEGQ,,QFOR	; SEGMENT WAIT QUEUE
	-TQ,,QFOR	; TELETYPE IO WAIT QUEUE
	-RUNQ,,QFOR
	-DCQ,,QFOR1
	-ELFQ,,QFOR1
	-DTQ,,QFOR1
	-MTQ,,QFOR1
	-DCQ,,QFOR2
	-ELFQ,,QFOR2
	-DTQ,,QFOR2
	-MTQ,,QFOR2
	0

; TABLE TO DECIDE ON WHICH JOB TO SWAP OUT
OSCAN:	-STOPQ,,QBAK	;UNRUNABLE JOBS FIRST
	-DWQ,,QBAK
	-MTQ,,QBAK1
	-DTQ,,QBAK1
	-ELFQ,,QBAK1
	-DCQ,,QBAK1
	-MTQ,,QFOR1
	-DTQ,,QFOR1
	-ELFQ,,QFOR1
	-DCQ,,QFOR1
	-INTWQ,,QFOR
	-IOWQ,,QFOR
	-RUNQ,,QBAK
	-TQ,,QBAK
	0

ALLRUNSCAN:
	-TQ,,QFOR
RUNSCAN:
	-RUNQ,,QFOR
	0

↑DVWSCAN:
	-DWQ,,QFOR
	0
;SETSIN CLRSIN SINBAD FLUSIN FLUSN1 JRSRCH JRSRC1 JRSRC2 FLUHLD FLUHL2 FLUHL3 FLUHL4 FLUHL1 GETSIN GETSN1

;SETSIN,CLRSIN,FLUSIN,JRSRC,FLUHLD,GETSIN
;HERE RESIDES ALL THE SWAP IN LIST CODE -- RPH 1/15/74

;CALL WITH C(J)=JOB, C(TAC)=BIT TO SET
↑SETSIN:
IFN FTSINBUG,<
	CONSZ PI,77000
	PUSHJ P,SINBAD
>;IFN FTSINBUG
	SETZM SWPCNT			;RUN SWAPPER
	TDNE TAC,JBTSIN(J)		;BIT ON ALREADY?
	POPJ P,				;YES, LEAVE
IFN FTSTAT,<
	PUSH P,TAC
	PUSH P,TAC1
	JFFO TAC,.+1
	LSH TAC1,6
	MOVEI TAC,SINSTA+4000(TAC1)	;SETTING BIT
	PUSHJ P,STAPUT
	POP P,TAC1
	POP P,TAC
>;IFN FTSTAT
	IORM TAC,JBTSIN(J)		;TURN IT ON
	ANDCA TAC,JBTSIN(J)		;PICK UP ALL OTHER BITS
	JUMPN TAC,CPOPJ			;LEAVE IF ALREADY LINKED IN
	LDB TAC,PSINB0			;PUT AT END OF LIST
	DPB J,PSINB0			;NOW WE ARE END
	DPB TAC,PSINBJ			;AND WE POINT TO OLD LAST
	DPB J,PSINFT			;AND HE POINTS TO US
	SETZ TAC,
	DPB TAC,PSINFJ			;AND WE ARE END
	POPJ P,				;ALL DONE

;ENTER HERE WITH C(J)=JOB, C(TAC)=BIT(S) TO CLEAR
↑CLRSIN:
IFN FTSINBUG,<
	CONSZ PI,77000
	PUSHJ P,SINBAD
>;IFN FTSINBUG
	TLZ TAC,¬JALSIN			;Clear mask bits not used as flags
	TDNN TAC,JBTSIN(J)		;IN CASE SOMEONE SNUCK IN
	POPJ P,
IFN FTSTAT,<
	PUSH P,TAC
	PUSH P,TAC1
	JFFO TAC,.+1
	LSH TAC1,6
	MOVEI TAC,SINSTA(TAC1)		;CLEARING BIT
	PUSHJ P,STAPUT
	POP P,TAC1
	POP P,TAC
>;IFN FTSTAT
	ANDCAB TAC,JBTSIN(J)		;TURN OF REQUESTED BIT
	TLNE TAC,JALSIN			;ANY BITS LEFT ON?
	POPJ P,				;YES, DON'T HAVE TO DE-LINK
	LDB TAC,PSINFJ			;GET OUR FORWARD LINK
	PUSH P,J			;USE J HERE
	LDB J,PSINBJ			;AND OUR BACKWARD LINK
	DPB J,PSINBT			;STORE OUR BACK IN OUR FORWARD
	DPB TAC,PSINFJ			;AND OUR FORWARD IN OUR BACK
	POP P,J
	SETZM JBTSIN(J)			;ZERO FOR TESTS
	POPJ P,				;ALL DONE

IFN FTSINBUG,<
SINBAD:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /SETSIN OR CLRSIN IN PROG ON CH 1-6, PC=/
	HRRZ TAC,-21(P)
	PUSHJ P,DISLOC
	PUSHJ P,WDDTCAL
	POPACS
	POPJ P,
>;IFN FTSINBUG

;ENTER HERE WITH J SETUP TO FLUSH ALL SWAPIN BITS (DOESN'T CLOBBER ACS)
↑FLUSIN:PUSH P,TAC			;KEEP THIS ROUTINE AUTONOMOUS
	MOVE TAC,JBTSIN(J)
	TLNN TAC,HLDSNB			;BITS WHICH MAY SET JHLDIN
	PUSHJ P,FLUHLD			;FLUSH
	TLNN TAC,JRDSNB
	JRST FLUSN1
	PUSHJ P,JRSRCH			;IF JOB READ BIT ON
	  JRDLOS			;SEND EVERYONE TO LOSE ROUTINE
FLUSN1:	MOVSI TAC,-1
	PUSHJ P,CLRSIN			;CLEAR ALL BITS
	JRST TPOPJ

;SEARCH FOR ALL OTHER JOBS TRYING TO READ THIS ONE (J)
;AND CALL SUBROUTINE FOLLOWING CALL ON JRSRCH
↑JRSRCH:PUSH P,J
	MOVEI J,JOBN-1			;SCAN ALL JOBS
JRSRC1:	HLRZ TAC,JBTFS(J)
	CAME TAC,(P)
	JRST JRSRC2
	MOVE TAC1,@-1(P)		;GET ROUTINE TO CALL
	PUSHJ P,(TAC1)			;CALL IT
JRSRC2:	SOJG J,JRSRC1
	POP P,J
	JRST CPOPJ1			;SKIP ROUTINE NAME

;FLUSH JHLDIN FROM UPPER OR LOWERS OF THIS JOB
↑FLUHLD:PUSH P,TAC
	PUSH P,J
	MOVE TAC,JBTSTS(J)
	TLNN TAC,JSEG			;SEGMENT?
	JRST FLUHL1			;NO, EASY
	MOVEI J,JOBN-1
FLUHL2:	LDB TAC,PSEGN			;GET HIS SEGMENT
	CAME TAC,(P)			;DOES THIS JOB POINT TO US?
	JRST FLUHL3			;NO
	MOVSI TAC,JHLDIN
	ANDCAM TAC,JBTSTS(J)
FLUHL3:	SOJG J,FLUHL2
FLUHL4:	POP P,J
	POP P,TAC
	POPJ P,

FLUHL1:	LDB J,PSEGN
	JUMPE J,FLUHL4			;ANY SEGMENT?
	MOVSI TAC,JHLDIN
	ANDCAM TAC,JBTSTS(J)		;CLEAR BIT IN UPPER
	JRST FLUHL4

;CALLED FROM SCNIN TO SWAP GUYS IN JBTSIN IN FIRST
GETSIN:	SETZ J,
	MOVEI QR,GETSN1
GETSN1:	LDB J,PSINFJ			;FOLLOW FORWARD LINK
	JUMPN J,(PC)			;GOT ANOTHER JOB
	JRST 1(PC)			;NO MORE
SUBTTL	SWAP	4 AUG 67

;SWAPPER CALLED EVERY CLOCK TIC.
;SINCE MOST OPERATIONS STARTED BY THE SWAPPER REQUIRE SEVERAL
;TICS TO RUN TO COMPLETION, SEVERAL FLAGS(FINISH,FIT,FORCE,
;XPANDF) ARE USED TO "REMEMBER" PREVIOUS STATES.
;THE BASIC ALGORITHM:
;IS CORE SHUFFLER WAITING FOR IO TO FINISH FOR SOME JOB?
;  YES--TRY AGAIN TO SHUFFLE(WHEN IO STOPS)
;IS CORE SHUFFLER STILL WAITING FOR IO TO FINISH?
;  YES--RETURN AND DO NOTHING
;IS SWAPPER STILL BUSY?
;  YES--RETURN AND DO NOTHING
;SCAN QS FOR 1ST JOB OUT OF CORE.
; IF NONE--RETURN
;A:
; IF ONE--WILL IT FIT IN LARGEST HOLE IN CORE?
;  YES--START INPUT AND RETURN
;  NO--IS TOTAL FREE CORE(CORTAL) ENOUGH TO ACCOMMODATE IT?
;    YES--CALL CORE SHUFFLER
;       IS SHUFFLER WAITING FOR IO TO STOP?
;         YES--RETURN AND DO NOTHING
;         NO--GO TO A:
;   NO--"REMEMBER" THIS JOB FOR INPUT AND LOOK FOR OUTPUT:
;ANY JOBS WAITING TO XPAND CORE BY SWAP OUT/IN?
; YES--OUTPUT ONE AND RETURN
; NO--SCAN QS BACKWARD FOR JOB IN CORE WHOSE PROTECT TIME
;		(SET ON INPUT) HAS GONE TO 0.
;  IF NONE--RETURN
;  IF ONE--IS IT SWAPPABLE?
;   YES--OUTPUT AND RETURN
;   NO--SET SWP BIT(FORCE JOB TO BECOME SWAPPABLE)--RETURN








;SOME DEVICE DEPENDENT CODE IS MARKED WITH A "*"
;SWAP

;SWAP 	SWAPPER CALLED EVERY TICK WHETHER WE NEED TO OR NOT

↑SWAP:	SOSLE SWPCNT			;RUN THE SWAPPER THIS TICK?
	POPJ P,				;NO.
	MOVEI TAC,5*JIFSEC		;RUN THE SWAPPER EVERY SO OFTEN
	MOVEM TAC,SWPCNT
;IN CASE WE WANT TO MUNG THE MAP, SAVE IT
	PUSHJ P,PSHMAP
	PUSHJ P,SWAP1			;THINK ABOUT SWAPPING AND SHUFFLING
	PUSHJ P,POPMAP
	SKIPN FIT			;ARE WE FITTING SOMEBODY?
	SKIPE FORCE			;OR PERHAPS FORCING SOMEONE?
	SETZM SWPCNT			;IF SO, FIRE UP SWAPPER NEXT TICK.
	POPJ P,
;SWAP1 FINSWP FININ FNINNS GENCH1 GENCHK GENCK1 GENCK2 CHKCHK CHKCH1

SWAP1:	SKIPE SQREQ			;*NO.  IS SWAPPER IO ACTIVE?
	POPJ P,				;*YES  WAIT FOR SHUFFLER OR SWAPPER IDLE
↑FINSWP:SKIPN J,FINISH			;SWAPPER IDLE.  ANY I/O OP TO FINISH?
	JRST SWP2			;NO.  SCAN FOR NEW SWAP-IN
	SETZM SWPCNT			;RUN SWAPPER AGAIN NEXT TICK.
	JUMPL J,FINOUT			;JUMP IF OUTPUT FINISHED.
FININ:	MOVEM J,LASTIN			;FINISH A SWAP-IN REQUEST

IFN FTSTAT,<
	MOVEI TAC,SWPSTA
	PUSHJ P,STAPUT			;FINISH SWAPIN OPERATION
>;FTSTAT

	MOVE TAC,JBTSTS(J)
	TLNE TAC,JSEG
	TLNN TAC,JWP
	JRST FNINNS
IFN FTUPCLB,<
IFN FTCINS,<
	PUSHJ P,SWPMST
	PUSHJ P,CHKCHK
	 CAIA				;NO ERROR, ETC
	JRST INJO1			;RETRY
>;IFN FTCINS
>;IFN FTUPCLB
	HLRZ AC1,JBTPAG(J)
	PUSHJ P,SMAPL			;LOOP THROUGH UPPER'S PAGES
	 TLZ AC2,P.WRT			;CLEARING WRITE ENABLE BIT
FNINNS:
	PUSHJ P,SWPMST			;SETUP MAP AFTER SWAPIN

IFN FTSWPC,<	SKIPN SWPCHK	>	;CHECKSUMMING NOW?
	SKIPE BLTSWP			;TEST CORE IMAGE AFTER SWAP IN?
	PUSHJ P,CHKCHK			;YES. (BLTSWP OR SWPCHK). SKIP IF RETRY
	 JRST FINAFB			;NO ERROR (ELSE TOO MANY, THEN SERA .GT. 0)
	HLRZ AC1,JBTPAG(J)
	PUSHJ P,SMAPL			;LOOP THROUGH UPPER'S PAGES
	 TLO AC2,P.WRT			;SET WRITE ENABLE BIT
	JRST INJO1			;RETRY THE SWAPIN.

;NOTE THAT ALL THESE CALLS NEED MAP SETUP.  (GENCHK, CHKCHK, GENCH1)

GENCH1:	PUSH P,DSER			;CACULATE CHECKSUM INTO AC1
	PUSH P,DDB
	PUSHJ P,GENCHK
	MOVE AC1,DSER
	POP P,DDB
	POP P,DSER
	POPJ P,

GENCHK:				;CALCULATE CHECKSUM INTO DSER
IFN FTCINS,<
	PUSH P,PROG
	HLLZ DDB,JBTPAG(J)
	LSH DDB,9
	MOVN DDB,DDB		;-SIZE OF CORE IMAGE,,0  = AOBJN POINTER TO CORE
	MOVEI PROG,0
IFN FTF2,<
	TLCN DDB,400000			;Larger than 128K?
	XCTR XBLTR,[CHKINS DDB,]	;  Yes, checksum upper half of memory
	TLC DDB,400000			;Undo fudge
>;IFN FTF2
	XCTR XBLTR,[CHKINS DDB,]	;CHECKSUM!
	MOVE DSER,PROG
	POP P,PROG
	POPJ P,
>;IFN FTCINS

IFE FTCINS,<
	MOVEI DSER,0		;INITIAL SUM
	HLLZ DDB,JBTPAG(J)
	LSH DDB,9
	MOVN DDB,DDB		;-SIZE OF CORE IMAGE,,0  = AOBJN POINTER TO CORE
	JUMPL DDB,GENCK2	;JUMP IF .LE. 128K
GENCK1:	XCTR XR,[ADD DSER,(DDB)]	;COMPUTE CHECKSUM. SCAN FOR BAD PARITY
	XCTR XR,[ADD DSER,1(DDB)]
	XCTR XR,[ADD DSER,2(DDB)]
	XCTR XR,[ADD DSER,3(DDB)]
	XCTR XR,[ADD DSER,4(DDB)]
	XCTR XR,[ADD DSER,5(DDB)]
	XCTR XR,[ADD DSER,6(DDB)]
	XCTR XR,[ADD DSER,7(DDB)]
	ADD DDB,[10,,10]
	JUMPG DDB,GENCK1
GENCK2:	XCTR XR,[ADD DSER,(DDB)]	;COMPUTE CHECKSUM. SCAN FOR BAD PARITY
	XCTR XR,[ADD DSER,1(DDB)]
	XCTR XR,[ADD DSER,2(DDB)]
	XCTR XR,[ADD DSER,3(DDB)]
	XCTR XR,[ADD DSER,4(DDB)]
	XCTR XR,[ADD DSER,5(DDB)]
	XCTR XR,[ADD DSER,6(DDB)]
	XCTR XR,[ADD DSER,7(DDB)]
	ADD DDB,[10,,10]
	JUMPL DDB,GENCK2
	POPJ P,
>;IFE FTCINS

CHKCHK:
IFKL10,<
	PUSHJ P,CSHSE0		;CACHE IS ON, TURN ON CACHE BITS IN PAGE TABLE
>;IFKL10
	PUSHJ P,GENCHK		;GET CHECKSUM IN DSER (REFERENCE MEM FOR BLTSWP)
	NOCACHE (CSHSWP)	;SWEEP THE CACHE
	CACHE (CSHSWP)		;RESTORE STATE OF CACHE TO ORIGINAL STATE
IFN FTSWPC,<
	SKIPN SWPCHK
	POPJ P,
>;IFN FTSWPC
IFN FTSWPC!FTUPCLB,<
CHKCH1:	CAME DSER,JBTSCS(J)	;COMPARE CHECKSUM
	SKIPN JBTSCS(J)		;LOSES.  SKIP IF CHECKSUM WAS SET
	POPJ P,			;CHECKS OK, OR NOTHING TO CHECK AGAINST.
	SKIPE SERA		;WAS THERE A LIBRASCOPE ERROR?
	POPJ P,			;YES. NO POINT IN SAYING THE CHECK FAILED.

	LDB DDB,[POINT 9,JB2SWP(J),26]	;GET CORE SIZE HE HAD WHEN HE WENT OUT
	HRLZ DDB,DDB
	XOR DDB,JBTPAG(J)	;COMPARE WITH CURRENT SIZE.
	TLNE DDB,-1		;IF SIZES MATCH, WE HAVE A REAL ERROR.
	POPJ P,			;IGNORE FAILURE.
	PUSHACS	
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /SWPCHK/
	PUSH P,DSER
	PUSHJ P,DISMES
	ASCIZ /SWPCHK FAILURE.  RTRY = /
	LDB TAC,[POINT 3,JB2SWP(J),29]	;RETRY COUNT
	PUSHJ P,DISDCP
	PUSHJ P,DISTAB
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ /
OLD = /
	MOVE TAC,JBTSCS(J)
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /   NEW = /
	MOVE TAC,(P)
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /   NEW-OLD = /
	POP P,TAC
	SUB TAC,JBTSCS(J)
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	POPACS
	PUSH P,TIMDAT		;PRETTY DISASTEROUS I'D SAY
	POP P,LASTDISASTER
	LDB TAC,[POINT 3,JB2SWP(J),29]
	ADDI TAC,1		;BUMP RETRY COUNT
	DPB TAC,[POINT 3,JB2SWP(J),29]
;	  PUSHJ P,DISFLUSH
;	  PUSHJ P,WDDTCAL
;	  LDB TAC,[POINT 3,JB2SWP(J),29]
	CAIGE TAC,4
	JRST CPOPJ1		;RETRY SWAPIN. (I HOPE IT WORKS...)
	HLLOS SERA
>;IFN FTSWPC!FTUPCLB
	POPJ P,
;SWPMST FNINM1 FNINM2 FINAFB FININA FININS FININC FININB FINZRL FINZR2

;SETUP MAP AFTER SWAPIN
SWPMST:	LDB TAC,PSEGN
	JUMPN TAC,FNINM1	;WE HAVE A REGULAR UPPER
	SKIPN JBTPR2(J)
	JRST FNINM2		;WE HAVE NO KIND OF UPPER AT ALL
	PUSHJ P,UPMAPL		;SETUP LOWER MAP FOR SETPR2
	 MOVEM AC2,(TAC1)	;ARGUMENT TO UPMAPL
	JRST FNINM2

FNINM1:	EXCH J,TAC
	PUSHJ P,ASGMAP		;ADD UPPER TO LOWER'S PAGE MAP
	EXCH J,TAC
FNINM2:	MOVE DAT,JBTSTS(J)
	TLNE DAT,JSEG
	PUSHJ P,AUPMAP		;SET UP PAGE MAPS OF ALL LOWERS OF THIS SEGMENT
>;FTPAGER

	AOS AMC17		;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP		;SETUP MAP (OR APR) FOR THIS JOB.
	POPJ P,			;PLEASE DON'T OPTIMIZE PUSHJ-POPJ


FINAFB:	MOVE DAT,JBTSTS(J)		;RESTORE JOB DATA AREA FROM JBTPDL
	TLNN DAT,JSEG			;SKIP IF THIS IS A SEGMENT
	TRZN DAT,SAVJDA			;NO SEGMENT. IS THERE A SAVED DATA AREA?
	JRST FININA			;SEGMENT OR NOT SAVED IN PDL
	SKIPN JBTPDL(J)
	JRST FININA			;CAN'T BE IN THE PDL IF THERE'S NO PDL.
	MOVEM DAT,JBTSTS(J)		;NOT SAVED ON PDL ANYMORE.
	HRLZ TAC1,JBTPDL(J)		;SOURCE (SORT OF)
	ADD TAC1,[<JBTPLN+JOBPRT-JOBPFI>,,JOBPRT]	;ADD OFFSETS.
	XCTR XBLTW,[BLT TAC1,JOBPFI]	;RESTORE JOB DATA AREA TO USER CORE.
IFN FTACBUG,<
	MOVE TAC,JBTMAP(J)
IFE FTMPP2,<
	LSH TAC,9
	HRRZ TAC,(TAC)		;PHYSICAL PAGE NUMBER OF PAGE 0
>;IFE FTMPP2
IFN FTMPP2,<
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP		;GET ACCESS TO UPMP
	PUSH P,MAPEXP⊗9		;PHYSICAL PAGE NUMBER OF PAGE 0
	PUSHJ P,DELEMP		;FLUSH UPMP
	POP P,TAC		;GET BACK PAGE 0 PAGE NUMBER
	MOVEI TAC,(TAC)
>;IFN FTMPP2
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP		;MAKE MAPEXP POINT AT USER'S PAGE 0
	PUSH P,MAPEXP⊗9+JOBDAC+J	;GET USER'S J
	PUSHJ P,DELEMP
	POP P,TAC
	CAMN TAC,SWPPSV(J)	;COMPARE WITH SAVED J AT SWAPOUT
	JRST FININA		;IT'S OK, LET HIM GO
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /J CLOB/
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / J CLOBBERED AFTER SWAPIN
/
	PUSHJ P,DISFLUSH
	PUSHJ P,WDDTCAL
	POPACS
	JRST INERR
>;IFN FTACBUG
	
FININA:	SKIPE DAT,SERA			;ANY INPUT ERRORS?
	JRST INERR			;YES
	SETZM STIME(J)			;MARK FRESH IMAGE IN CORE
	HLRZ DDB,JBTPAG(J)
	LDB AC1,IMGOUT
	CAIE DDB,(AC1)
	SETOM STIME(J)
	SETZM JBTICP(J)			;INITIALLY NO PROTECT TIME
	MOVE DDB,JBTSTS(J)		;IS THIS A HIGH SEGMENT?
	TLNN DDB,JSEG
	JRST FININ5			;NOT A SEGMENT.
	PUSHJ P,UAPPLY			;FOR ALL LOWERS OF THIS UPPER,
	 PUSHJ P,SPWCNT			;CONTINUE SPACEWAR (ARGUMENT TO UAPPLY)
	PUSHJ P,FININS
	JRST FININ1

;FINISHED SWAPPING IN A SEGMENT (OR MAYBE JUST GETTING IT CORE IF FROM INJO2)
;NOW WE MAKE SURE EITHER SEGWAIT IS SET TO A LOWER OF OURS OR WE ARE NOT IN SEGQ
;IF WE ARE THE SEGMENT THAT IS WAITED FOR WE CLEAR SEGWAIT AND REQUE TO STOPQ
;ALSO GET HERE FROM FORCE1 WHEN WE DISCOVER THAT WE CAN'T SWAP OUT A SEGMENT
;BECAUSE SOME LOWER WANTS IT IN CORE.
FININS:	SKIPN AC1,SEGWAIT	
	JRST FININB			;SEGWAIT WASN'T SET.
	LDB AC1,[POINT JOBNSZ,JBTSTS(AC1),35]
	CAIE AC1,(J)			;WAS THAT GUY WAITING FOR US?
	JRST FININB			;NO. SEGWAIT WASN'T SET ON OUT ACCOUNT
	SETZM SEGWAIT			;IT WAS OUR FAULT.  CLEAR SEGWAIT.
FININC:	MOVNI AC1,STOPQ
	MOVEM AC1,JOBQUE(J)
	JRST REQUE			;QUEUE THIS SEGMENT BACK TO STOPQ

FININB:	MOVM AC1,JOBQUE(J)		;SOMETIMES A SEGMENT GETS INTO
	CAIE AC1,SEGQ			;SEGQ WITHOUT BEING SET IN SEGWAIT!
	POPJ P,				;NOT THIS BUG.
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / SEGMENT IN SEGQ WITHOUT SEGWAIT BEING SET.
/
	POPACS
	JRST FININC			;UNWEDGE THE WORLD

;SETUP JOBRL2.  HERE FROM FININ7 AND FROM GETJOB IN COMCSS.
;J AND MAP SETUP.   CLOBBERS TAC AND TAC1.  CALL FOR LOWERS ONLY!

↑FINZRL:LDB TAC1,PSEGN			;TAC1←JOB NUMBER OF UPPER
	JUMPE TAC1,FINZR2		;JUMP IF NO UPPER.
	MOVE TAC,JBTSTS(TAC1)		;JOB STATUS OF UPPER
	PUSHJ P,CORSGT			;GET SIZE OF UPPER TO TAC1.
	SUBI TAC1,1			;CHANGE NUMBER OF WORDS TO PROTECTION ADDR
	TLNE TAC,JWP			;IS THE UPPER WRITE PROTECTED?
	TLO TAC1,400000			;YES. FLAG IT.
	TRO TAC1,400000			;MAKE IT AN UPPER SEGMENT ADDRESS
FINZR2:	XCTR XR,[CAME TAC1,JOBRL2]	;SEE IF IT HAS CHANGED
	SKIPE JBTPR2(J)			;CHANGE.  PEEK-POKE?
	POPJ P,				;PEEK-POKE OR NO CHANGE.
	SETOM STIME(J)			;MARK CORE IMAGE MODIFIED IF CHANGED
	XCTR XW,[MOVEM TAC1,JOBRL2]	;SET JOBRL2
	POPJ P,
;FININ5 FNIN5A FININ1 NOTSET FINDET FININ2

;FININ5, FININ1

;AT FININ5 FOR A LOWER.  CONTINUE ANY SPW JOB THAT WAS ACTIVE. GIVE SWAPIN INTS
;SPW JOBS CAN BE SWAPPED DUE TO THEIR EXPANSION, BY FREE STORAGE EXPANDING, OR
;BY SOMEONE DOING A LOCK UUO.  ALSO, IF THEIR UPPER IS BEING UNPURIFIED BY SOMEONE.

FININ5:	MOVE DDB,JBTSTS(J)
	TLZN DDB,LOKSWP
	JRST FNIN5A
	IORI DDB,JLOCK		;FINISH LOCKING IN CORE
	MOVEM DDB,JBTSTS(J)
IFN FTSTAT,<
	PUSH P,TAC
	MOVEI TAC,LOKSTA+100	;LOCKING
	PUSHJ P,STAPUT
	POP P,TAC
>;IFN FTSTAT
	HLRZ DDB,JBTPAG(J)
	ADDM DDB,LOKTOT		;TOTAL NUMBER OF PAGES LOCKED IN
FNIN5A:	PUSHJ P,SPWCNT		;CONTINUE ITS SPW JOB, IF ANY
	PUSHJ P,FINZRL		;SET UP JOBRL2
	HLRZ DDB,JBTPAG(J)	;NUMBER OF PAGES THIS GUY HAS
	IMUL DDB,CPFAC1
	ADD DDB,CPFAC2
IFN FTPRIQ,<
	MOVE DSER,JBTPRI(J)
	CAML DSER,[GRSPRI,,0]	;SKIP UNLESS WERE TRYING TO MAKE HIS PL MATCH HIS SL
	LSH DDB,2		;QUADRUPLE HIS IN CORE PROTECT TIME
>;IFN FTPRIQ
	LSH DDB,-=12		;DIVIDE (INCLUDES EXTRA FACTOR OF 4)
	MOVEM DDB,JBTICP(J)
FININ1:	MOVSI DDB,SWP		;CLEAR SWP BIT (UPPER OR LOWER HERE)
	ANDCAB DDB,JBTSTS(J)
	HRRE DSER,JBTLIN(J)
	JUMPL DSER,FINDET	;DETACHED?
	MOVSI DDB,DLYBIT
	OFFSCN			;TURN OFF SCANNER CHANNEL
	TDNN DDB,TTYTAB(DSER)	;WAS HE DELAYED?
	JRST NOTSET		;NO.
	MOVSI DDB,COMBIT
	TDNE DDB,TTYTAB(DSER)	;COMMAND ALREADY IN?
	JRST NOTSET		;YES
	AOS COMCNT		;NOW LOOK AT HIM AGAIN!
	IORM DDB,TTYTAB(DSER)	;SET BIT
NOTSET:	ONSCN			;TURN ON SCANNER CHANNEL
FINDET:	MOVSI DSER,INTSWD
	TDNN DSER,JBTIEN(J)
	JRST FININ2
	IORM DSER,JBTIRQ(J)
	PUSH P,J
	PUSHJ P,INTRUN
	POP P,J
FININ2:
;NOSINT NOSBAT NOSJRD NOSCOM NSINBT

;HERE WE CHECK ALL THE SWAPIN BITS
	HLRZ TAC,JBTSIN(J)
	ANDI TAC,JALSIN		;Leave only real flag bits
	JUMPE TAC,NSINBT	;NO JBTSIN BITS ARE SET. SKIP THIS STUFF.
	PUSH P,J
	MOVSI TAC,HLDSNB	;BITS WHICH MAY CAUSE JHLDIN TO BE SET ELSEWHERE
	TDNE TAC,JBTSIN(J)
	PUSHJ P,FLUHLD		;FLUSH
	MOVSI TAC,INTSNB
	TDNN TAC,JBTSIN(J)	;INTERRUPT HANDLER TRYING TO GET HIM IN?
	JRST NOSINT		;NO
	PUSHJ P,CLRSIN		;YES, TURN OFF BIT
	PUSH P,HGCODE
	HGMAC (7)
	PUSHJ P,INTRUN
	POP P,HGCODE
	MOVE J,(P)		;RESET J
NOSINT:	MOVSI TAC,BATSNB	;PHANTOM TRYING TO START UP?
	TDNN TAC,JBTSIN(J)
	JRST NOSBAT
	PUSHJ P,CLRSIN
	PUSHJ P,BATSW		;FINISH HIM OFF
	MOVE J,(P)
NOSBAT:	MOVSI TAC,JRDSNB	;JOB READ?
	TDNN TAC,JBTSIN(J)
	JRST NOSJRD
	PUSHJ P,CLRSIN
	PUSHJ P,JRSRCH		;FIND EVERYONE TRYING TO READ THIS JOB
	 JRDWIN			;AND SEND THEM HERE
	MOVE J,(P)
NOSJRD:	MOVSI TAC,COMSNB	;COMMAND WAIT?
	TDNN TAC,JBTSIN(J)
	JRST NOSCOM
	PUSHJ P,CLRSIN
	PUSH P,HGCODE
	HGMAC (1)
	SKIPE COMCNT
	PUSHJ P,COMMAND		;CALL COMMAND DECODER (NOTE THIS MAY NOT GET THE RIGTH GUY)
	POP P,HGCODE
NOSCOM:	POP P,J
	MOVSI TAC,SPWSNB
	TDNE TAC,JBTSIN(J)	;FORCED OUT BY FS OR LOCK AND SPACEWAR ACTIVE?
	PUSHJ P,CLRSIN		;YES. JUST CLEAR BIT.
NSINBT:	
;FININ9

;CHECK IF UPPER WANTS IN
	MOVE DSER,J
	LDB J,PSEGN		;DOES THIS JOB HAVE AN UPPER?
	JUMPE J,SWAPSCAN	;NO, SCAN FOR MORE INPUT
	MOVE DDB,JBTSTS(J)
	TLNN DDB,SWP		;IS HIGH SEGMENT SWAPPED OUT?
	JRST SWAPSCAN		;NO
	MOVM UCHN,JOBQUE(DSER)
	CAIE UCHN,RUNQ		;LOWER RUNABLE?
	CAIN UCHN,TQ
	PUSHJ P,FININ9		;YES, CAUSE UPPER TO COME IN
	LDB TAC,IMGIN		;CAN UPPER FIT IN RIGHT NOW?
	MOVE UCHN,LOFREE
	ADD UCHN,HIFREE
	CAMG TAC,UCHN
	JRST INJOB		;YES, GET IT
	JRST SWAPSCAN		;WE'LL HAVE TO DO MORE WORK TO BRING IN UPPER.

FININ9:	SKIPE SEGWAIT
	POPJ P,			;SORRY, THERE'S A MORE IMPORTANT SEG TO GET IN.
	MOVNI DAT,SEGQ
	MOVEM DAT,JOBQUE(J)
	MOVEM DSER,SEGWAIT	;MAKE SURE LOWER STAYS INCORE.
	MOVEI DAT,QSEGW
	JRST QXFER
;INERR INERR7 SEGERR SEGER1 SEGER2 SEGER3 SEGER4

;INERR  THERE WAS A SWAPIN ERROR.

;SERA HAS THE FOLLOWING MEANING:
; IF ZERO, NO ERROR (AND WE DIDN'T GET HERE)
; IF FBACT≠0, BIT 18 OF SERA IS L'SCOPE ERROR, BIT 17 IS CORE PARITY ERROR.
; IF FBACT=0 THEN SERA CONTAINS IODERR AND IODTER, IF SET BY DSKSER


; ERROR AND NOT WRITE PROTECTED SEGMENT, OR LOWER.

INERR:	PUSHJ P,FLUSIN		;FLUSH ENTRIES FROM SWAPIN LIST
	MOVSI DDB,SWP		;CLEAR SWP
	ANDCAB DDB,JBTSTS(J)
	TLNN DDB,JSEG		;SEGEMENT?
	JRST INERR7		;NO.  GO REBUILD THE JOB DATA AREA
IFN FTUPCLB,<
	SETZM JBTSCS(J)
>;IFN FTUPCLB
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ /  SWAP READ ERROR IN SEGMENT
/
	POPACS
	MOVE AC1,PRJPRG(J)	;CHANGE SEGMENT NAME SO THAT
	MOVEM AC1,JOBNAM(J)	;  NO ONE WILL ATTATCH TO IT
IFN FTSTAT,<PUSHJ P,NAMSTT>
	PUSHJ P,UAPPLY
INERR7:	 PUSHJ P,SEGERR		;CALL SEGERR FOR EACH LOWER.
	JRST SWAPSCAN

SEGERR:	CAMN J,SEGWAIT
	PUSHJ P,CLRSGW		;CLEAR SEGWAIT
	PUSHJ P,DSKFIX		;CLEAR GOBIT IN ALL HIS DDBS (IN PARSER)
	PUSHACS
	PUSHJ P,DISJOB
IFN FTUPCLB,<
	SKIPL SERA
	JRST SEGER1
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /  UPPER SEGMENT CHECKSUM ERROR
/
	JRST SEGER2
SEGER1:
>;IFN FTUPCLB
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /SWPRER/
	PUSHJ P,DISMES
	ASCIZ /  SWAP READ ERROR
/
SEGER2:	POPACS
	PUSHJ P,TTYERP		;TELL USER.
IFN FTUPCLB,<
	SKIPL SERA
	JRST SEGER3
	PUSHJ P,INLMES
	ASCIZ /UPPER SEGMENT CHECKSUM ERROR/
	JRST SEGER4
SEGER3:
>;IFN FTUPCLB
	PUSHJ P,INLMES
	ASCIZ /SWAP READ ERROR/
SEGER4:	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	MOVE AC1,JBTSTS(J)
	TLNN AC1,JLOG		;LOGGED IN?
 	JRST ESTOP		;NO - KILL THE JOB
	JRST STOP1		;STOP JOB.
;FINOUT OUTP1 OUTP1A OUTP1B OUTP1D SWP2 PSPWAC

;FINOUT, SWP2, SWAPSCAN  - FINISH A SWAP OUT OPERATION

FINOUT:	MOVN J,J		;FINISH OUTPUT.
	PUSHJ P,SWPMST		;SETUP MAP.
	SKIPN SERA		;ANY ERRORS
	JRST OUTP1
	CACHE (CSHSWP)		;TRY OVER AGAIN.  THIS DOESN'T REALLY TURN ON CACHE
	JRST OUTJOB

;ENTER HERE FROM OUTJOB IF NO I/O IS NEEDED (WRITE PROTECTED UPPER)
OUTP1:
IFN FTSWPC,<
	SKIPN SWPCH2
	JRST OUTP1A
	CACHE (CSHSWP)
	PUSHJ P,CHKCHK		;CHECK CHECKSUM, SKIP IF LOST BUT NOT FOURTH TIME
	 JRST OUTP1A
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /UPON SWAPOUT.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCA
OUTP1A:
>;FTSWPC

REPEAT 0,<
;HERE IS WHERE WE FINISH UNPURE
	MOVE TAC1,JBTSTS(J)		;CODE FOR UNPURE UUO.
	TLNN TAC1,JSEG
	JRST OUTP1B			;NOT A SEGMENT.  SKIP THIS.
	LDB TAC1,[POINT JOBNSZ,RTIME(J),35]
	JUMPE TAC1,OUTP1B		;SEGMENT, BUT NO ONE WANTS UNPURE
	PUSHJ P,UNPURS			;FINISH UNPURE. (UUOCON)
	JRST OUTP1B			;UNPURE FAILED.  FINISH SWAPOUT.
	MOVEI J,0			;SET THE MAP TO NEUTRAL.
	PUSHJ P,APRMAP			;TO AVOID FUTURE INCONSISTANT PUSH AND POP
	JRST OUTP1D			;UNPURE OK.  THE CORE THAT BELONGED TO
					;THIS SEGMENT HAS ALREADY BEEN REASSIGNED.
>;END REPEAT 0

OUTP1B:	MOVEI TAC,0			;RETURN CORE
	PUSHJ P,CORE0
	 JSP DAT,CERROR			;SHOULD NEVER HAPPEN
	MOVEI J,0
	AOS AMC18			;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP			;FLUSH ONLY POINTER TO CURRENT JBTMAP FS
	MOVN J,FINISH
	SKIPE AC1,JBTMAP(J)		;FLUSH OLD JBTMAP
	PUSHJ P,GIVMAP
	SETZM JBTMAP(J)
OUTP1D:	MOVM J,FINISH			;RESTORE J AGAIN.

	CACHE (CSHSWP)

	MOVEI TAC,0		;SEE IF THIS GUY IS GOING OUT DESPITE SPACEWAR
	MOVE DDB,JBTSTS(J)
	TLNE DDB,JSEG		;SEGMENT?
	PUSHJ P,UAPPLY		;YES. APPLY ROUTINE TO ALL LOWERS
	 PUSHJ P,PSPWAC		;IS SPACEWAR ACTIVE FOR THIS USER? (SET TAC)
	JUMPE TAC,SWAPSCAN	;NO.
	PUSHJ P,SETSIN		;FORCE THIS GUY TO GET SWAPPED IN

SWAPSCAN:
	SETZM XPANDF		;CLEAR XPANDING JOB OUTPUT TO DISK FLAG
	SETZM FINISH		;CLEAR FINISH FLAG
SWP2:	SKIPE J,FORCE		;WAITING FOR JOB TO BECOME SWAPPABLE?
	JRST FORCE1		;YES
;	SETZM FIT		;RESCAN FOR INPUT NEXT TIME
	SKIPN FIT		;CONTINUE TRYING TO BRING THIS JOB IN
	SKIPE XJOB		;IS THERE SOMEONE WHO WANTS TO BE KICKED OUT?
	JRST SCNIN		;YES.  SCNIN WILL DO IT (BELIEVE IT OR NOT)
	SKIPGE FSCLKF		;ARE WE WAITING FOR FREE STORAGE?
 	POPJ P,			;YES.
	JRST SCNIN

PSPWAC:	SKIPE SPWGO(J)
	MOVSI TAC,SPWSNB	;INDICATE WE HAVE SPACEWAR ACTIVE
	POPJ P,
;SCNIN SCNINZ SCNIN1 DEADR1 DEADR9 DEDR9A DEDR9B

;SCAN FOR INPUT - LOOK FOR A JOB ON THE DISK WHICH OUGHT TO COME IN. - SCNIN
JN←←TEM

SCNIN:	HGMAC (2)		;TELL HG ROUTINES WE ARE IN SCNIN

;FORCE EXPANDING JOBS OUT before SCAN FOR INPUT
	PUSHJ P,XPAND1		;CHECK XPANDING JOB FIRST
	SKIPN SQREQ		;*WERE THERE ANY?
	SKIPE FORCE
	POPJ P,			;YES
	PUSHJ P,GCMAX		;GET TOTAL AMOUNT OF AVAILABLE CORE (CORE IS 
	MOVEM AC3,CORMX		;AVAILABLE IF NOT OCCUPIED BY SYSTEM OR SPW JOBS
				;OR LOCKED CORE)

	SKIPE J,FIT
	JSP QR,SCNINZ		;KEEP TRYING TO BRING IN JOB IN FIT
	SKIPE J,SEGWAIT		;KLUDGE 12/20/74 TO UNTANGLE A SCREW CASE -REG
	JSP QR,[LDB J,PSEGN	;GET APPROPRIATE SEGMENT - REG
		JRST SCNINZ]	;AND TRY TO GET IT IN. -REG

	JSP PC,GETSIN
	JRST SCNINZ		;FOUND A JOB IN SWAP IN LIST
	MOVEI DAT,ISCAN		;NO MORE IN SWAP IN LIST, TRY QUEUES
	JSP PC,QSCAN		;C(J)← NEXT MOST IMPORTANT JOB TO SWAP IN
	POPJ P,			;(THERE IS NO NEXT MOST IMPORTANT JOB)
SCNINZ:	MOVE DDB,JBTSTS(J)	;THIS JOB OUT OF CORE?
	TLNN DDB,SWP
	JRST (QR)		;NO--CONTINUE SCAN
	
	LDB TAC,IMGIN		;YES--WILL IT FIT IN BIGGEST HOLE?
SCNIN1:				;HERE FROM RESCNIN IF FOUND JOB WHICH WILL FIT

IFN FTSTAT,<
	PUSH P,TAC
	MOVEI TAC,CORSTA
	PUSHJ P,STAPTT
	MOVE TAC,LOFREE
	PUSHJ P,STAPTT
	MOVE TAC,HIFREE
	PUSHJ P,STAPTT
	MOVE TAC,HIUSED
	PUSHJ P,STAPTT
	MOVE TAC,LOKTOT
	PUSHJ P,STAPTT
	MOVE TAC,CORMX
	PUSHJ P,STAPTT
	MOVE TAC,CORHMX
	PUSHJ P,STAPTT
	MOVEI TAC,FITSTA
	MOVE TAC1,JBTSTS(J)
	TLNE TAC1,LOKSWP
	MOVEI TAC1,FITSTA+100
	PUSHJ P,STAPUT
	POP P,TAC
>;IFN FTSTAT

	MOVE DDB,HIFREE		;FREE PAGES ABOVE FSLIMIT
	MOVSI DSER,LOKSWP
	TDNN DSER,JBTSTS(J)	;IF JOB IS TRYING TO LOCK, DON'T CONSIDER ...
	ADD DDB,LOFREE		;...PAGES BELOW FSLIMIT
	CAMG TAC,DDB		;SKIP IF JOB IS BIGGER THAN AVAILABLE ROOM
	JRST INJOB		;HE FITS, BRING HIM IN
	MOVEM J,FIT		;NO--SET FIT FLAG
	MOVE DDB,JBTSTS(J)
	TLNE DDB,JSEG		;IS THIS JOB AN UPPER SEGMENT?
	JRST DEADUP		;  YES
	LDB DDB,PSEGN		;GET NUMBER OF THIS JOB'S UPPER SEGMENT
	MOVE DSER,JBTSTS(DDB)
	TLNN DSER,SWP		;IS UPPER SEGMENT IN CORE?
	JRST DEADR1		;  YES, (OR ELSE THERE IS NO UPPER)
	LDB DSER,IMGINT		;C(DSER) ← INCORE IMAGE SIZE OF THE UPPER
	ADD TAC,DSER		;C(TAC) ← CORE SIZE OF SWAPPED OUT PORTION OF JOB
DEADR1:	MOVE AC3,CORMX		;AC3 ← TOTAL CORE SPACE AVAILABLE TO OUR JOB
	SKIPE TAC1,DDB		;DOES THIS JOB HAVE AN UPPER SEGMENT?
	PUSHJ P,GCMCK		;  YES, IS IT'S SIZE ALREADY REFLECTED IN CORMX?
	JRST DEADR9		; NO UPPER OR UPPER'S SIZE HAS BEEN COUNTED IN CORMX
	PUSHJ P,CORSGT		;  NO, C(TAC1) ← SIZE OF UPPER SEGMENT
	SUB AC3,TAC1		;AC3 ← (AVAILABLE CORE) - (UPPER CORE SIZE)
DEADR9:	LDB DDB,IMGIN
	LSH DDB,9		;DDB ← CORE SIZE OF JOB (LOWER SEG ONLY)
	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,LOKSWP	;SKIP IF JOB TO FIT NEEDS TO BE IN LOCKED CORE
	JRST DEDR9A
	CAMG DDB,CORHMX		;WILL JOB (I.E.,LOWER) FIT INTO CORE ABOVE FSLIMIT?
	JRST SCNIN9		;YES
	JRST DEDR9B		;NO
DEDR9A:	CAMG DDB,AC3		;WILL WE FIT INTO AVAILABLE CORE?
	JRST SCNIN9		;  YES
DEDR9B:	PUSHJ P,DEADLOCK	;  NO
	JRST (QR)		;CONTINUE SCAN FOR A JOB TO SWAP IN
;DEADUP DEADU1 DEADU2 DEADU7 DEADUC DEADU3

; "DEADUP" IS CALLED FROM SCNIN, IF THE JOB TO BE SWAPPED IN IS AN
;UPPER SEGMENT AND NO SINGLE HOLE IS LARGE ENOUGH TO CONTAIN IT;
;	CODE BY JAM		COMMENTS BY JHS

DEADUP:	SETZB DSER,JN		;DSER WILL BE SIZE, JN NUMBER, OF LARGEST LOWER.
	SETZM ISONE
	MOVE DDB,J
	MOVEI J,JOBN-1		;SCAN JOB TABLE, LOOKING FOR OUR LOWERS
DEADU1:	LDB UCHN,PSEGN
	CAIE UCHN,(DDB)		;IS THIS JOB POINTING TO US?
DEADU2:	SOJG J,DEADU1		;  NO, CONTINUE SCAN
	JUMPE J,DEADU3		;JUMP WHEN SCAN COMPLETED
	MOVE UCHN,JBTSTS(J)
	TLNN UCHN,JHLDIN	;LOWER HOLDING?
	SKIPE JBTSIN(J)
	JRST DEADU7		;COMING IN
	MOVM UCHN,JOBQUE(J)	;IF OUR LOWER IS
	CAIE UCHN,RUNQ		;IN RUNQ OR TQ
	CAIN UCHN,TQ		;THEN GO TO DEADU7
	JRST DEADU7		;ELSE CONTINUE SCAN
	MOVE UCHN,JBTMSK(J)
	AND UCHN,JBTIEN(J)
	AND UCHN,JBTIRQ(J)
	JUMPN UCHN,DEADU7
	SKIPN JBTST2(J)
	JRST DEADU2		;NONE OF THE ABOVE, CONTINUE SCAN
DEADU7:	MOVE TAC1,JBTSTS(J)
	TLNE TAC1,SWP		;THIS LOWER OF OURS IS SWAPPED OUT?
	JRST DEADUC		;	YES
	HLRZ TAC1,JBTPAG(J)	;NO.  TAC1←LOWER'S JOB SIZE
	LDB UCHN,IMGINT		;UCHN←UPPER'S JOB SIZE 
	ADDI TAC1,(UCHN)	;TAC1 ← COMBINED SIZE OF LOWER AND UPPER
	LSH TAC1,9		;CONVERT PAGES TO WORDS
	CAMG TAC1,CORMX		;BOTH WILL FIT IN CORE AT ONE TIME?
	SETOM ISONE		;  YEP, INDICATE THAT THERE ISONE THAT FITS
DEADUC:	MOVE TAC1,J
	PUSHJ P,CORSGT		;C(TAC1) ← SIZE OF LOWER
	CAMG TAC1,DSER		;HAS SUCH A LARGE LOWER BEEN FOUND BEFORE?
	JRST DEADU2		;  NO, CONTINUE SCAN FOR LOWERS
	MOVE DSER,TAC1		;  YES, REMEMBER SIZE IN DSER
	MOVE JN,J		;   AND REMEMBER JOB# IN JN
	JRST DEADU2		;	AND CONTINUE SCAN
	
DEADU3:	JUMPN JN,DEADU4		;ARRIVE HERE WHEN SCAN FOR LOWERS COMPLETE
	MOVE J,DDB		;ARRIVE HERE IF WE HAVE NO LOWERS ! (?)
	JRST (QR)		;DON'T BRING IN UPPER, LOOK FOR SOME OTHER
				;  JOB TO SWAP IN
;DEADU4 SCNIN9 RESCNIN RESCN2 NOFIT

;DEADU4, SCNIN9, RESCNIN, NOFIT

;SEND THE MESSAGE TO A DEADLOCKED LOWER
;IF MORE THAN ONE LOWER IS SO LARGE THAT IT TOGETHER WITH THE UPPER WON'T FIT,
;THEN ONLY ONE OF THEM WILL GET THE DEADLOCK MESSAGE, AND THIS IS PROBABLY A BUG.
	
DEADU4:	MOVE J,JN		;J ← JOB# OF LARGEST LOWER SEGMENT
	MOVE UCHN,TAC		;UCHN←SIZE OF UPPER SEGMENT
	LSH UCHN,9		;CONVERT SIZE OF UPPER TO WORDS.
	ADD UCHN,DSER
	CAMG UCHN,CORMX		;WILL LARGEST LOWER BE LOCKED OUT?
	JRST SCNIN9		;  NO, GO SHUFFLE ETC.
	PUSH P,DDB		;  YES, ETC.
	CAMN J,SEGWAIT
	PUSHJ P,CLRSGW		;CLEAR SEGWAIT
	PUSHJ P,DEADLOCK
	POP P,J
	SKIPN ISONE
	JRST (QR)
;IF THE JOB FITS, COMPACT CORE, ELSE SCAN FOR SOMEBODY TO KICK OUT.
SCNIN9:	MOVEI DDB,SDEAD1	;J MAY CONTAIN THE NUMBER OF THE LOWER HERE
	ANDCAM DDB,JBTSTS(J)	;TELL SOMEONE WE GOT HIM IN.
	JRST SCNOUT

;HERE IF JOB WE PICKED TO FIT DIDN'T MAKE IT (SCNOUT RAN OUT OF JOBS TO SWAP)
;JUST TRY TO FIND ANY JOB THAT CAN FIT IN FREE CORE WITHOUT SWAPPING ANYONE OUT
RESCNIN:
IFN FTSTAT,<
	MOVEI TAC,SWPSTA+500
	PUSHJ P,STAPUT
>;IFN FTSTAT
	MOVEI DAT,ALLRUNSCAN
	JSP PC,QSCAN
	JRST NOFIT
	MOVE DDB,JBTSTS(J)
	CAME J,FIT		;SKIP JOB WE KNOW CAN'T FIT
	TLNN DDB,SWP
	JRST (QR)
	LDB TAC,IMGIN
	LDB DDB,PSEGN		;SECOND SEGMENT NUMBER
	JUMPE DDB,RESCN2
	MOVE TAC1,JBTSTS(DDB)
	TLNN TAC1,SWP
	JRST RESCN2
	LDB DSER,IMGINT
	ADD TAC,DSER
RESCN2:	MOVE DDB,HIFREE
	MOVE TAC1,JBTSTS(J)	;GET LOWER'S STATUS
	TLNN TAC1,LOKSWP
	ADD DDB,LOFREE
	CAMLE TAC,DDB
	JRST (QR)
	LDB TAC,IMGIN
	JRST SCNIN1

NOFIT:
IFN FTSTAT,<
	MOVE TAC,FIT
	IORI TAC,SWPSTA+600
	PUSHJ P,STAPTT
>;IFN FTSTAT
	SETZM FIT		;FORGET ABOUT FITTING IN A JOB ON DISK
	POPJ P,			;ALL JOBS IN CORE ARE HIGHER PRIORITY.
;HALFIN PLANT DEADL2 DEADL1 DEACLN

; HERE WE HAVE DETECTED A CORE DEADLOCK

DEADLOCK:
IFN FTSTAT,<
	MOVEI TAC,SWPSTA+400
	PUSHJ P,STAPUT
>;IFN FTSTAT
	MOVEI DDB,SDEADIN
	TDNE DDB,JBTSTS(J)
	POPJ P,			;WE KNOW ABOUT HIM
	PUSH P,J
	TRO DDB,SDEAD1		;NOTE REALLY DEAD AT THIS TIME.
	IORM DDB,JBTSTS(J)	;MARK IT AS DETECTED
	PUSHJ P,GCS		;GET SIZE OF UPPER + LOWER IN DSER
	CAMLE DSER,CORMAX   ;IS HE TOO BIG ALTOGETHER, OR IS SOMEONE KEEPING HIM OUT
	JRST DEADL2		;TOO BIG ALTOGETHER.
	PUSHJ P,HALFIN
	JRST DEADL1

HALFIN:	LSH J,=12		;SOMEBODY'S FAULT. TELL HIM ABOUT IT.
	ADD J,[$HALFD,,=30*JIFSEC] ;Go to HALFD in 30 secs
PLANT:	CLKENQ(J)		;Plant clk req
	POPJ P,

DEADL2:	PUSHJ P,DEACLN
DEADL1:	POP P,J
	POPJ P,

DEACLN:	LSH J,=12
	ADD J,[$SDEAD,,=15*JIFSEC] ;Go to SDEAD in 15 secs
	JRST PLANT		;GO PLANT IT
;SDEAD HALFD HALFD1 KILLIN

; CLOCK REQUEST TIMES OUT IN 15-SOME-ODD-SECONDS AND COMES HERE:

↑SDEAD:	MOVEI J,SDEADIN
	ANDCAB J,JBTSTS(TAC)	;CLEAR SDEADIN (NO MORE CLOCK REQUESTS).
	TRNN J,SDEAD1		;HAS HE BEEN IN SINCE DETECTION?
	POPJ P,			;YES
	MOVE J,TAC
	PUSHJ P,GCS
	CAMG DSER,CORMAX
	POPJ P,
	MOVM DDB,JOBQUE(J)	; SEE IF HE HAS STOPPED HIS JOB
	CAIN DDB,STOPQ
	JRST DEACLN		; YES, WE WILL GIVE HIM SOME TIME
	PUSHJ P,FLUSIN		;FLUSH FROM SWAP IN LIST
	PUSH P,J
	LDB J,PSEGN
	SKIPE J
	PUSHJ P,FLUSIN		;ALSO UPPER
	POP P,J
	PUSHJ P,TTYERP		; FIND HIS TTY FOR HIM
	PUSHJ P,INLMES
	ASCIZ /CORE DEADLOCK.

/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	JRST STOP1

↑HALFD:	MOVE J,TAC
	MOVM AC3,JOBQUE(J)
	MOVE TAC,JBTSTS(J)
	CAIE AC3,STOPQ		;CLEAR BIT IF HE STOPPED HIMSELF
	TRNN TAC,SDEAD1		;HAS HE BEEN IN SINCE DETECTION?
	JRST KILLIN
	PUSHJ P,GCS
	CAMG DSER,CORMAX
	JRST HALFD1
	PUSH P,J
	JRST DEADL2
HALFD1:	PUSH P,DSER
	PUSHJ P,GCMAX
	POP P,DSER
	MOVE TAC,JBTSTS(J)
	TLNE TAC,LOKSWP
	MOVE AC3,CORHMX
	CAMG DSER,AC3
	JRST KILLIN
	PUSHJ P,TTYERR			;THIS GUY ONLY SETS ERROR BIT
					;DOESN'T CLEAR INPUT UNLESS NECESSARY
	PUSHJ P,INLMES
	ASCIZ /
YOU ARE LOCKED OUT OF CORE!
/
	MOVSI IOS,USRB
	IORB IOS,DEVIOS(DDB)
	PUSHJ P,TTYSTR
	JRST HALFIN

KILLIN:	MOVEI DDB,SDEADIN
	ANDCAM DDB,JBTSTS(J)
	POPJ P,
;GCMAX GCMAX2 GCMAX1 GCLP GCLP1 GCLP2 GCMCK GCS

;GCMAX GCMCK GCS

;	GCMAX - ROUTINE TO CALCULATE HOW MUCH CORE IS AVAILABLE FOR A
;	JOB ON THE DISK WHICH WANTS TO COME IN.  CORE IS CONSIDERED
;	TO BE AVAILABLE IF IT IS USER CORE NOT OCCUPIED BY SPW JOBS.

GCMAX:	SETZM GCBITS			;72 BITS FOR REMEMBERING
	SETZM GCBITS+1
	MOVE AC3,CORMAX			;SIZE FROM FSTOP UP (NOT COUNTING IO PAGES)
	LSH AC3,-9			;IN PAGES
	SUB AC3,LOKTOT			;LESS TOTAL LOCKED CORE
	PUSH P,AC3
	MOVE AC3,HIUSED
	ADD AC3,HIFREE
	SUB AC3,LOKTOT
IFN FTELOK,<
	PUSH P,DDB
	SKIPN DDB,ESEGNO		;IS THERE AN E UPPER SEGMENT?
	JRST GCMAX1
	PUSH P,DSER
	MOVE DSER,JBTSTS(DDB)
	TLNE DSER,SWP
	JRST GCMAX2			;IF IT'S SWAPPED OUT, DON'T DO ANYTHING
	PUSH P,IOS
	PUSHJ P,GCMCK
	 CAI
	MOVEM IOS,GCBITS(DSER)		;MARK E'S UPPER AS BEING REFLECTED IN CORMX
	POP P,IOS
	HRRZ DSER,JBTPAG(DDB)		;YES, GET ITS SIZE IN UPPER PAGES
	SUB AC3,DSER			;AND DECREASE UPPER PAGE TOTAL
	HLRZ DSER,JBTPAG(DDB)		;GET ITS SIZE IN TOTAL PAGES
	MOVN DSER,DSER
	ADDM DSER,-2(P)			;UGH! DECREASE TOTAL (IN PUSHED AC3)
GCMAX2:	POP P,DSER
GCMAX1:	POP P,DDB
>;IFN FTELOK
	LSH AC3,9
	MOVEM AC3,CORHMX		;WORDS ABOVE FSLIMIT AVAIL TO USERS
	POP P,AC3
	LSH AC3,9			;IN WORDS
	SKIPG SPWACT			;ANY ONE IN SPW MODE?
	POPJ P,				;NO. THIS IS SIMPLE
	PUSH P,UCHN
	PUSH P,DDB
	MOVE UCHN,CORHMX
	PUSH P,[POINT JOBNSZ,SPWGO(JN),JOBNSZ-1] ;GET A BYTE POINTER
	PUSHJ P,GCLP			;CALL THINK ABOUT P1 SPW JOBS
	SUB P,[1,,1]
	MOVEM UCHN,CORHMX
	POP P,DDB
	POP P,UCHN
	POPJ P,

GCLP:	MOVEI JN,0		;INITIALLY LOOK AT LIST BASE
GCLP1:	LDB JN,-1(P)		;GET NUMBER OF SOME SPW JOB.
	JUMPE JN,CPOPJ		;0 MEANS END OF LIST.
	SKIPN JBTST2(JN)	;SKIP IF SPACEWAR IS ACTIVE
	JRST GCLP1		;NOT STILL ACTIVE
	MOVEI DDB,(JN)		;GET JOB NUMBER INTO DDB
	PUSHJ P,GCMCK		;HAVE WE SEEN THIS JOB BEFORE?
	JRST GCLP1		;YES. DON'T COUNT AGAIN
	MOVEM IOS,GCBITS(DSER)	;SO WE WON'T COUNT THIS JOB AGAIN
	MOVE DDB,JBTSTS(JN)	
	TRNE DDB,JLOCK		;IS THIS JOB LOCKED IN?
	JRST GCLP2		;YES. DON'T COUNT IT TWICE
	HRRZ DSER,JBTPAG(JN)	;NUMBER OF PAGES IN JOB ABOVE FSLIMIT
	LSH DSER,9
	SUBI UCHN,(DSER)
	HLRZ DSER,JBTPAG(JN)	;GET THE PROTECTION
	LSH DSER,9
	SUBI AC3,(DSER)		;DECREASE THE AVAILABLE SIZE.
GCLP2:	ANDI DDB,JOBNMK		;SEGMENT NUMBER FROM JBTSTS
	JUMPE DDB,GCLP1		;LOOP IF NO SEGMENT
	PUSHJ P,GCMCK		;SEGMENT SEEN BEFORE?
	JRST GCLP1		;YES. DON'T DO IT AGAIN.
	MOVEM IOS,GCBITS(DSER)	;DON'T COUNT THIS SEGMENT AGAIN
	HLRZ DSER,JBTPAG(DDB)	;GET THE PROTECTION SIZE
	LSH DSER,9
	SUBI AC3,(DSER)
	HRRZ DSER,JBTPAG(DDB)
	LSH DSER,9
	SUBI UCHN,(DSER)
	JRST GCLP1		;LOOP

;JOB NUMBER IN DDB. SKIP IF WE'VE NOT SEEN THIS JOB BEFORE.
;IOS IS SET WITH WORD TO DEPOSIT IF YOU WANT TO MARK THIS JOB AS SEEN:
; USE	MOVEM IOS,GCBITS(DSER)	TO REMEMBER HAVING SEEN THIS JOB.
GCMCK:	MOVE DSER,DDB
	ANDI DSER,1		;THIS BIT WILL INDEX THE TWO WORD BIT TABLE
	MOVEI IOS,1		;THIS BIT WILL BE SHIFTED TO UNIQUE POSITION
	ROT DDB,-1
	ROT IOS,-=16(DDB)	;
	ROT DDB,1		;RESTORE DDB
	IOR IOS,GCBITS(DSER)	;TURN ON OTHER JOB BITS WE HAVE SEEN AND SET
	CAME IOS,GCBITS(DSER)	;IS THIS AN OLD JOB NUMBER?
	AOS (P)			;  NO, SKIP RETURN
	POPJ P,			;  YES, NORMAL RETURN


;GCS, CALLED FROM DEADLOCK, RETURN SIZE OF UPPER PLUS LOWER (IF ANY) IN DSER
GCS:	MOVE TAC1,J
	PUSHJ P,CORSGT		;ADD UP HIS CORE SIZE AND SEE IF STILL DEADLOCKED
	MOVE DSER,TAC1		;SIZE OF THE LOWER
	LDB TAC1,PSEGN
	MOVE DDB,TAC1
	JUMPE TAC1,CPOPJ	;NO UPPER
	PUSHJ P,CORSGT
	ADD DSER,TAC1		;SIZE OF LOWER+UPPER
	POPJ P,
;SCNOUT FORCE3 SCNOF1 FORCE5

;SCAN FOR OUTPUT  SCNOUT

SCNOUT:	HGMAC(3)
	MOVE DDB,HIFREE
	MOVE TAC,JBTSTS(J)
	TLNN TAC,LOKSWP
	ADD DDB,LOFREE		;NEED TO GET ENOUGH HI CORE ONLY
	MOVEM DDB,SUMCOR
	SETZM MAXSIZ		;CLEAR SIZE OF LARGEST JOB
	SETZM MAXJBN
	SETZM MAXRSZ
	SETZM MAXRJB
	SETZM MAXSSZ
	SETZM MAXSJB
	MOVE TAC,[NJOBS,,CJOBS]
	BLT TAC,CJOBS+JOBN-1	; MOVE OVER TABLE OF REFERENCE COUNTS
	MOVE DDB,FIT		;ENOUGH SEEN YET?
	LDB DSER,[POINT JOBNSZ,JBTSTS(DDB),35] ;GET SEGMENT NUMBER, IF ANY
	JUMPE DSER,FORCE3
	EXCH J,DSER
	MOVE UCHN,JBTSTS(J)
	TLNE UCHN,SWP
	LDB J,IMGIN
	TLNN UCHN,SWP		;OR IS HE SWAPPED IN?
	MOVEI J,0		; YES, HE DOESN'T COUNT INTO CORE WE HAVE TO GET
	EXCH J,DSER
FORCE3:	LDB DDB,IMGINT
	ADD DDB,DSER		;ADD IN SIZE OF UPPER
	MOVEM DDB,NEEDED	;AND STORE AS AMOUNT NEEDED
	MOVEI DAT,OSCAN		;NO--SCAN QS
	JSP PC,QSCAN
	JRST RESCNIN
	CAME J,FIT		; REACHED OURSELVES YET?
	JRST SCNOF1		; NO.
	SKIPN JBTSIN(J)		;GIVE HIGH PRIORITY TO GUYS IN SWAP IN LIST
	CAMN J,SEGWAIT		;IS THIS GUY WAITING FOR A SEGMENT?
	JRST (QR)		;YES, EXCEPT FOR US, SCAN BACK ALL THE WAY
	JRST RESCNIN		;NO, SCAN FOR MORE INPUT

SCNOF1:	MOVE DDB,JBTSTS(J)	;GET JOB STATUS BITS
	TLNE DDB,SWP		;NO, IS JOB ON DISK OR ON ITS WAY?
	JRST CJOB		;YES,CONTINUE SCAN TO FIND ANOTHER JOB TO OUTPUT
IFN FTELOK,<
	CAME J,ESEGNO		;IS IT THE E UPPER SEGMENT?
>;IFN FTELOK
	TLNE DDB,JHLDIN		;SOMEONE TRYING TO KEEP THIS GUY IN?
	JRST (QR)		;YES, SKIP HIM
	TLNE DDB,JSEG		;SEGMENT?
	JRST FRCE4A		;YES. CHECK NJOBS TO SEE IF IT SHOULD BE SWAPPED
	TRNE DDB,JLOCK		;LOCKED JOB?
	JRST (QR)		;YES. CAN'T BE SWAPPED.
	CAMN J,SEGWAIT		;DON'T SWAP OUT IF WAITING FOR A HIGH SEGMENT
	JRST (QR)		;DON'T SWAP OUT THE GUY WE'RE TRYING TO LOCK IN.

	SKIPLE JBTICP(J)	;IS HE STILL PROTECTED IN CORE?
	JRST (QR)		;YES.  DON'T SWAP HIM YET.


REPEAT 0,<		;LET'S TRY NOT CLOGGING UP CORE WITH LOW PRIORITY LOSERS
	MOVM DDB,JOBQUE(J)	; PICK UP HIS QUEUE
	CAIE DDB,TQ		; IS HE IN A RUN QUEUE?
	CAIN DDB,RUNQ
	CAIA
	JRST FORCE4
	LDB DDB,PSEGN		; YES, DOES HE HAVE AN UPPER?
	JUMPE DDB,FORCE5	; NO
	MOVE DDB,JBTSTS(DDB)	; YES, IS IT IN CORE?
	TLNE DDB,SWP
	JRST FORCE4		; NO, DOESN'T MATTER
FORCE5:	SKIPN STIME(J)		; HAS THIS JOB BEEN RUN?
	JRST (QR)		; NO, GO BACK AND LET IT RUN.
>
;FORCE4 FORCE6 FORCE0 FORCE1 FRCE4A UNFRCE

;FORCE0, FORCE1, FORCE4, UNFRCE

FORCE4:	CAME J,SEGWAIT		;IF WAITING FOR SEGMENT, MUST STAY IN
	SKIPE JBTST2(J)		;DOES HE HAVE A SPACEWAR MODULE?
	JRST (QR)		;YES. CAN'T SWAP HIM OUT.

	HLRZ DDB,JBTPAG(J)	;PICK UP SIZE OF JOB
	JUMPE DDB,(QR)
	PUSHJ P,SIZCHK		;UPDATE SUMCOR AND CHECK IF ENOUGH YET
	JRST CJOB		;NO. LOOK FOR MORE
FORCE6:	SKIPE J,MAXSJB		;SEGMENTS WITH NO INCORE USERS GET KICKED FIRST
	JRST FORCE0
	SKIPN J,MAXJBN		;YES, SWAP OUT LARGEST
	MOVE J,MAXRJB
FORCE0:	MOVSI DDB,SWP		;ENTER HERE FROM XPAND1 TO FORCE OUT XPANDING JOB
	IORM DDB,JBTSTS(J)

IFN FTSTAT,<
	MOVEI TAC,SWPSTA!200	;JOB NUMBER WE ARE FORCING.
	PUSHJ P,STAPUT
>;IFN FTSTAT

	MOVEM J,FORCE		;ASSUME NOT SWAPPABLE--IS IT?
FORCE1:	SKIPN JBTPAG(J)		;SKIP IF CORE IS ASSIGNED INCORE
	JRST OUTJOB		;NO CORE INCORE.  CANNOT HAVE ACTIVE DEVICES.
	CAME J,JOB		;IF THIS IS CURRENT JOB, WAIT UNTIL
				;PROTECTED AREA IS MOVED BACK TO JOB DATA AREA
	PUSHJ P,ANYACT		;ANY ACTIVE DEVICES?
	POPJ P,			;YES.  WAIT FOR I/O TO STOP AND JOB TO SCHEDULE OFF
	SKIPN DDB,SEGWAIT	;IS ANYONE WAITING FOR A SEGMENT?
	JRST OUTJOB		;NO
	LDB TAC,[POINT JOBNSZ,JBTSTS(DDB),35]
	CAIE TAC,(J)		;YES, IS IT US?
	JRST OUTJOB		;NO
	PUSHJ P,UNFRCE		;YES, WE ARE NO LONGER SWAPPABLE
	JRST FININS		;CLEAR SEGWAIT AND SEGQ

FRCE4A:	SKIPE NJOBS(J)		;ANYONE LEFT USING THIS?
	JRST (QR)		;YES. SEGMENT SWAP OUT WILL BE CONSIDERED W/LOWERS
	JRST FORCE4		;THIS MAY BE A DETACHED SEGMENT. SWAP IT

UNFRCE:	MOVSI TAC,SWP
	ANDCAM TAC,JBTSTS(J)
	SETZM FORCE
	SETZM SWPCNT
	POPJ P,
;OUTJOB OUTJO1 OUTJO3 OUTJ1 OUTJ2 SWP5 WSYJCL WSYJCK WSYJCJ WSYJCX WSYJC1 WSYJCM

;OUTPUT A JOB - OUTJOB

OUTJOB:	HGMAC(4)
	MOVNM J,FINISH		;SET FINISH FLAG FOR OUTJOB
	AOS NOUTSWPS
	SETZM FORCE		;CLEAR FORCE FLAG
	PUSHJ P,QNORUN		;REQUE HI SEGMENT IF NECESSARY
	MOVSI DDB,INTSWW
	TDNN DDB,JBTIEN(J)
	JRST OUTJO1
	IORM DDB,JBTIRQ(J)
	PUSHJ P,INTRUN
	MOVM J,FINISH
OUTJO1:

IFN FTSTAT,<
	MOVEI TAC,SWPSTA!100	;SWAPOUT OPERATION IS STARTING
	PUSHJ P,STAPUT
>;FTSTAT

	HLRZ DDB,JBTPAG(J)	;COMPUTE CORE IMAGE SIZE
	JUMPE DDB,SWP5		;DON'T OUTPUT IF 0 CORE
	PUSHJ P,SWPMST		;SETUP MAP FOR THIS JOB
	MOVE TAC1,JBTSTS(J)	;SAVE JOB DATA AREA OF LOWER ON JBTPDL
	SKIPE JBTPDL(J)		;DON'T SAVE IF THERE'S NO PLACE.
	TLNE TAC1,JSEG		;IS THIS A SEGMENT?
	JRST OUTJO3		;NO SAVE.  EITHER NO PDL OR THIS IS AN UPPER.
	MOVSI TAC1,JOBPRT	;SOURCE (RELATIVE)
	HRR TAC1,JBTPDL(J)	;DESTINATION (SORT OF)
	ADDI TAC1,<JBTPLN+JOBPRT-JOBPFI>	;ADJUST DESTINATION.
	HRRZ DAT,JBTPDL(J)			;COMPUTE ENDING ADDRESS
	XCTR XBLTR,[BLT TAC1,JBTPLN(DAT)]	;SAVE THE DATA.
	MOVEI TAC1,SAVJDA
	IORM TAC1,JBTSTS(J)	;DATA AREA IS NOW SAVED IN JBTPDL
IFN FTACBUG,<
	MOVE TAC,JBTMAP(J)
IFE FTMPP2,<
	LSH TAC,9
	HRRZ TAC,(TAC)		;PHYSICAL PAGE NUMBER OF PAGE 0
>;IFE FTMPP2
IFN FTMPP2,<
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP		;GET ACCESS TO UPMP
	PUSH P,MAPEXP⊗9		;PHYSICAL PAGE NUMBER OF PAGE 0
	PUSHJ P,DELEMP		;FLUSH UPMP
	POP P,TAC		;GET BACK PAGE 0 PAGE NUMBER
	MOVEI TAC,(TAC)
>;IFN FTMPP2
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP		;MAKE MAPEXP POINT AT USER'S PAGE 0
	PUSHJ P,WSYJCK		;CHECK J MAYBE
	MOVE TAC,MAPEXP⊗9+JOBDAC+J	;GET USER'S J
	MOVEM TAC,SWPPSV(J)	;SAVE IT IN A SAFE PLACE
	PUSHJ P,DELEMP
>;IFN FTACBUG
OUTJO3:	DPB DDB,IMGOUT		;RECORD AS OUT IMAGE (IN PAGES)
	SKIPN XPANDF		;DON'T SET IMGIN IF WE WERE CALLED FROM XPAND1
	DPB DDB,IMGIN
	SKIPE STIME(J)		;HAS HIS CORE IMAGE BEEN MODIFIED?
	JRST OUTJ1		;YES.  NEED OUTPUT OPERATION.
	HLRZ DDB,JBTSWP(J)	;SEE IF HE HAS BEEN SWAPPED OUT BEFORE
	JUMPN DDB,OUTP1		;WAS SWAPPED OUT BEFORE.  DON'T BOTHER WITH OUTPUT
OUTJ1:	LDB DDB,IMGOUT		;GET BACK SIZE OF CORE IMAGE IN PAGES
IFN FTSWPC,<
	SETZM JBTSCS(J)		;INITIALIZE CHECKSUM
	SKIPN SWPCHK		;COMPUTE CHECKSUM BEFORE SWAPPING?
>;IFN FTSWPC
	SKIPE BLTSWP		;ARE WE TESTING FOR BAD PARITY?
	JRST .+2		;YES, OR DOING CHECKSUM.
	JRST OUTJ2		;NO TEST BEFORE SWAP OUT.
	PUSHJ P,GENCH1		;GENERATE CHECKSUM IN AC1
IFN FTSWPC,<
	MOVEM AC1,JBTSCS(J)	;STORE CHECKSUM
	HLRZ AC1,JBTPAG(J)	;GET SIZE OF JOB IN PAGES
	LSH AC1,3		;MAKE A 12-BIT FIELD
	DPB AC1,[POINT 12,JB2SWP(J),29]	;STORE HERE (9BIT SIZE, 3BIT COUNT)
>;FTSWPC

OUTJ2:	MOVE AC1,JBTSTS(J)
	TLNE AC1,JSEG
	PUSHJ P,ZAPLOJ		;CLEAR PAGE MAP ENTRIES OF ALL LOWERS OF THIS SEG

	NOCACHE (CSHSWP)

	MOVE TAC1,JBTPAG(J)	;GET JBTPAG FOR GXSAT AND SQOUT
	PUSHJ P,GXSAT		;GET DEVICE STORAGE, GIVE SIZE IN PAGES IN DDB
	HRLM TAC,JBTSWP(J)	;SAVE DEVICE ADDRESS, SEE GXSAT AND JBTSWP COMMENT
	JRST SQOUT		;START OUTPUT AND RETURN

SWP5:	DPB DDB,IMGOUT		;SET OUTPUT IMAGE TO 0
	JRST SWAPSCAN		;GO LOOK FOR SOMETHING ELSE TO DO

IFN FTACBUG,<
WSYJCL:	PUSH P,AC1
	MOVE AC1,USRPC
	JRST WSYJCJ

WSYJCK:	PUSH P,AC1
	MOVE AC1,MAPEXP⊗9+JOBPC	;GET USER'S PC
WSYJCJ:	TLZ AC1,¬USRMOD
	CAIE AC1,STOP2+2
	JRST POPAJ
	MOVE AC1,MAPEXP⊗9+JOBDAC+P	;GET EXEC P
	PUSH P,AC2
	HRRZ AC2,(AC1)
	CAIE AC2,WSYN.2+1
	JRST WSYJCX
	HRRZ AC2,-4(AC1)
	CAIN AC2,HPWAID+1		;Is this the call to DDTWAT in HPWAIT?
	JRST WSYJC1
WSYJCX:	POP P,AC2
	JRST POPAJ

WSYJC1:	MOVE AC1,MAPEXP⊗9+JOBDAC+J	;GET EXEC J
	CAIN AC1,(J)
	JRST WSYJCX			;IT'S OK
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /J BAD IN JOBDAC AT WSYJCK/
	PUSHJ P,BUGTRP
	POPACS
	HRRZM J,MAPEXP⊗9+JOBDAC+J
	JRST WSYJCX

↑WSYJCM:SKIPN TAC,JBTMAP(J)
	POPJ P,
IFE FTMPP2,<
	LSH TAC,9
	HRRZ TAC,(TAC)		;PHYSICAL PAGE NUMBER OF PAGE 0
>;IFE FTMPP2
IFN FTMPP2,<
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP		;GET ACCESS TO UPMP
	PUSH P,MAPEXP⊗9		;PHYSICAL PAGE NUMBER OF PAGE 0
	PUSHJ P,DELEMP		;FLUSH UPMP
	POP P,TAC		;GET BACK PAGE 0 PAGE NUMBER
	MOVEI TAC,(TAC)
>;IFN FTMPP2
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP		;MAKE MAPEXP POINT AT USER'S PAGE 0
	PUSHJ P,WSYJCL
	PUSHJ P,DELEMP
	POPJ P,
>;IFN FTACBUG
;SIZCHK FRCE2A FORCE2 SETMRS SETMRJ

;SIZCHK.   SEE IF BY SWAPPING THIS WE'LL HAVE ENOUGH ROOM

;ADD A JOB'S SIZE TO CURRENT TOTAL AND SEE IF WE
;HAVE MADE ENOUGH ROOM FOR THE JOB WE ARE TRYING TO FIT IN
;JOB NUMBER IN J

SIZCHK:

IFN FTSTAT,<
	MOVEI TAC,SWPSTA!300	;JOB NUMBER BEING CONSIDERED FOR SWAPOUT
	PUSHJ P,STAPUT
>;IFN FTSTAT

	MOVE TAC,FIT
	MOVE TAC,JBTSTS(TAC)
	TLNN TAC,LOKSWP		;SKIP IF LOOKING FOR HI CORE
	JRST FRCE2A
	HRRZ DDB,JBTPAG(J)	;YES, LOOK AT AMOUNT OF HI CORE
	CAIA
FRCE2A:	HLRZ DDB,JBTPAG(J)
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JSEG
	JRST SETMRS		;SEGMENTS, IF THEY GET HERE, ARE PRIME CANDIDATES
;	MOVM TAC,JOBQUE(J)	; IS HE RUNNABLE?
;	CAIE TAC,TQ
;	CAIN TAC,RUNQ
;	JRST SETMRJ		;YES, GET SEPARATE MAXIMUM.
	CAMG DDB,MAXSIZ		;LARGEST SO FAR?
	JRST FORCE2		;NO
	MOVEM DDB,MAXSIZ	;YES, SAVE SIZE
	MOVEM J,MAXJBN		;AND JOB NUMBER
FORCE2:	ADDB DDB,SUMCOR		;ADD TO TOTAL
	CAML DDB,NEEDED		;IS IT WHAT WE NEEDED
	AOS (P)			;YES
	POPJ P,

SETMRS:	CAMG DDB,MAXSSZ
	JRST FORCE2
	MOVEM DDB,MAXSSZ
	MOVEM J,MAXSJB
	JRST FORCE2

REPEAT 0,<
SETMRJ:	CAMG DDB,MAXRSZ
	JRST FORCE2
	MOVEM DDB,MAXRSZ
	MOVEM J,MAXRJB
	JRST FORCE2
>;REPEAT 0
;CJOB CJBXIT

; ROUTINE TO DECREMENT REFERENCE TO THIS JOB'S UPPER, IF ANY   CJOB
; IF ALL REFERENCES HAVE BEEN SELECTED FOR SWAPOUT, THEN ADD
; IN THE UPPER SIZE TOO.

CJOB:	LDB DDB,PSEGN		;PICK UP NUMBER OF UPPER
	JUMPE DDB,(QR)
IFN FTELOK,<
	CAMN DDB,ESEGNO
	JRST (QR)		;DON'T THINK ABOUT E'S UPPER
>;IFN FTELOK
	MOVE TAC,JBTSTS(DDB)	;IS UPPER IN CORE?
	SOSN CJOBS(DDB)		;DECREMENT REFERENCE COUNT
	TLNE TAC,SWP
	JRST (QR)
	PUSH P,J
	MOVE J,DDB
	HLRZ DDB,JBTPAG(J)
	JUMPE DDB,CJBXIT
	PUSHJ P,SIZCHK		;UPDATE SUMCOR AND CHECK IF ENOUGH YET
	JRST CJBXIT		;NO, KEEP LOOKING
	SUB P,[1,,1]		;YES, SWAP OUT LARGEST
	JRST FORCE6

CJBXIT:	POP P,J
	JRST (QR)
;INJOB INJO1A INJO1B INJO1C INJO1D INJO1 INJO2 INJO3

;INPUT A JOB - INJOB, INJO1

INJOB:	HGMAC (5)
	MOVEM J,FINISH		;SET FINISH FLAG
	AOS NINSWPS
	SETZM FIT		;CLEAR FIT FLAG
	SKIPE JBTMAP(J)
	JRST INJO1A		;ALREADY HAVE A PAGE MAP
	PUSHJ P,GETMAP		;TRY TO GET A PAGE MAP FOR THIS JOB
	JRST INJO3		;CAN'T DO IT
	MOVEM AC1,JBTMAP(J)
INJO1A:
IFN FTHPSG,<
	SKIPN JBTPAG(J)		;DOES THIS GUY HAVE CORE ASSIGNED ALREADY?
	JRST INJO1B		;NO.  THIS IS NORMAL
	PUSHJ P,HTLFIN		;FINISH THE ACTION REQUESTED BY HTLMOV
	JRST INJO3		;THE HOLE VANISHED.  RESCAN FOR INPUT
	SETZM SERA		;ACT LIKE WE FINISHED SWAPIN WITHOUT ERROR
	JRST FININA
INJO1B:
>;IFN FTHPSG 

	LSH TAC,9		;CORE SIZE FROM IMGIN
	SUBI TAC,1		;TAC←HIGHEST ADDRESS NEEDED.
	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,LOKSWP
	JRST INJO1C
	PUSHJ P,CORHGT		;GET CORE ABOVE FSLIMIT
	JRST INJO3		;ISN'T ENOUGH THERE
	JRST INJO1D
INJO1C:	PUSHJ P,CORGET		;GET CORE. (MAKE UP MAP, BUT NEVER WRITE PROTECT)
	JRST INJO3		;RESCAN FOR INPUT. THE ROOM VANISHED.
INJO1D:
IFKL10,<
	PUSHJ P,SWEEPA		;SWEEP ALL (CACHE)
>;IFKL10

INJO1:	LDB DDB,IMGOUT			;GET OUTPUT IMAGE
	JUMPE DDB,INJO2			;DON'T READ DISK IF OUT IMAGE IS ZERO
	LDB TAC,IMGIN			;GET IN-CORE SIZE.
	CAML DDB,TAC			;SMALLER THAN OUT?
	MOVE DDB,TAC			;YES. READ ONLY WHAT WILL FIT.
	MOVS TAC1,DDB			;FOR SQIN
	HLRZ TAC,JBTSWP(J)		;GET DEVICE ADDRESS
	JRST SQIN			;START INPUT

INJO2:	PUSHJ P,SWPMST			;SETUP MAP.  USER HAD NO CORE ON DISK, SO
	XCTR XW,[SETZM JOBSA]		;NO INPUT IS NEEDED.  CLEAR JOB DATA AREA
	XCTR XW,[SETZM JOBPRT]		;FIRST LOC. PROTECTED FROM USER
	MOVE TAC,[JOBPRT,,JOBPR1]
	XCTR XBLTRW,[BLT TAC,JOBPFI]
	XCTR XW,[SETZM JOBENB]		;ALSO CLEAR APR ENABLE WORD
	XCTR XW,[SETZM JOBINT]		;AND MOORER RELOCATER
	HRRZS UUOPC(J)			;AND UUO PC FLAGS
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JSEG			;IS IT A SEGMENT?
	PUSHJ P,FININS			;YES, MAYBE SEGWAIT WAS SET, IF SO CLEAR IT.
	PUSHJ P,ESTOP2			;SET HIM TO NOT BE RUNNABLE.
	JRST FININ1			;NOW, ACT LIKE WE FINISHED READING DISK

INJO3:	SETZM FINISH
	SETZM SWPCNT
	POPJ P,
;XPAND XPAND3 XPAND4 XPANDB XPAND1 XPAND2

;XPAND SETS CONDITIONS TO GET MORE CORE FOR A JOB BY SWAPPING IT OUT  XPAND1
;THEN BACK IN TO DESIRED AMOUNT.
;JOB'S POSITION IN QS NOT AFFECTED.
;CALL:
;	MOVE J,[JOB NO.]
;	MOVE TAC,[NUMBER OF PAGES DESIRED]
;	PUSHJ P,XPAND
;
;Note that if you just want a guy swapped out, you can do it by calling
;XPAND with TAC setup to his current protection.  LOCK UUO and FSGETK
;do this.   Calling XPAND will clear SEGWAIT if this (lower) had
;been waiting for an upper.  
;Note that you may have to call XPAND in a loop, since if IO is active
;for this job or segment, the code at FORCE4 will ignore the fact that
;you're trying to force the job this way (note further that in the case
;that counts, BAKOLD, IO is already stopped so the warning above does 
;not apply.
;
;XPAND1 is called by the swapper to complete the action initiated by
;XPAND

↑XPAND:	PUSH P,DDB
	TRNN TAC,777
	JRST XPANDB
	DPB TAC,IMGIN		;STORE NEW INPUT IMAGE.

IFN FTSTAT,<
	LSH TAC,6
	TRO TAC,CSZSTA
	PUSHJ P,STAPUT
>;IFN FTSTAT

	HLRZ DDB,JBTPAG(J)
	JUMPE DDB,XPAND4	;JUMP IF THERE'S NO CORE IN MEMORY NOW
	SKIPE XJOB(J)		;EXPAND FLAG ALREADY SET?
	JRST XPAND3		;YES.  DONT INCREASE XJOB COUNT.
	SETOM XJOB(J)		;SET EXPAND FLAG
	AOS XJOB		;INCREASE COUNT OF JOBS TO EXPAND.
XPAND3:	POP P,DDB
	SETZM SWPCNT		;KICK SWAPPER NEXT TICK.
	SETZM JBTICP(J)
	POPJ P,

XPAND4:	DPB DDB,IMGOUT		;CLEAR IMGOUT NOW
	MOVSI DDB,SWP
	IORM DDB,JBTSTS(J)	;AND MARK AS SWAPPED OUT
	JRST XPAND3		;DON'T SET XPAND BECAUSE NO SWAPOUT IS NEEDED.

XPANDB:	POP P,DDB
	PUSHACS
	PUSH P,TAC
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /XPAND CALLED WITH BAD CORE SIZE IN TAC = /
	POP P,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCAL
	HLRZ TAC,JBTPAG(J)	;TRY WITH CURRENT CORE SIZE
	JRST XPAND

;XPAND1 COMPLETES ACTION REQUESTED BY XPAND.
;CALLED WHEN NO INPUT TO DO OR ON SEARCH FOR OUTPUT.

XPAND1:	SKIPN XJOB		;ANY JOBS TO EXPAND?
	POPJ P,			;NO.
	MOVEI J,JOBN		;SCAN FOR EXPANDING JOBS.
	SKIPN XJOB(J)		;THIS JOB NEED TO EXPAND?
	SOJG J,.-1
	SETZM XJOB(J)		;CLEAR THIS JOB.
	JUMPE J,XPAND2		;LOSE!
	SOS XJOB		;REDUCE THE COUNT.
	SETOM XPANDF		;SET FLAG SO IMGIN WONT BE RESET
	SETZM SWPCNT		;RUN SWAPPER NEXT TICK
	CAMN J,SEGWAIT		;IS THIS THE JOB THAT'S WAITING FOR A SEGMENT?
	PUSHJ P,CLRSGW		; YES.  DOESN'T NEED A SEGMENT ANYMORE.
	SKIPG TAC,SEGWAIT	;IS ANYONE WAITING FOR A SEGMENT?
	JRST FORCE0		;NO. GO START OUTPUT
	LDB TAC,[POINT JOBNSZ,JBTSTS(TAC),35] ;GET SEGMENT NUMBER THAT IS SOUGHT
	CAMN TAC,J		;IF THIS IS THE SEGMENT, WE MUST ZERO SEGWAIT
	PUSHJ P,CLRSGW
	JRST FORCE0

XPAND2:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /ππXJOB SET BUT NO JOB EXPANDING
/
	POPACS
	POPJ P,

BEND SCHEDU
