COMMENT ⊗   VALID 00011 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	ZSGMAP ZSGMA2 ZSGMAX ZSGMA1 ASGMAP ASGMAX
C00008 00003	ZERPR2 UPMAPL UPMAP1 UPMAP4 UPMAP3 UPMAPX UPMPGH UPMP3G UPMAP2 UPMAP5 SMAPL SMAP2 SMAP1 ZMAPL STRMAP WPMAPL WPMPBX
C00020 00004	UNPMAP MAKMAP MAKMP1 ZAPLOJ ZAPLO1 AUPMAP AUPMA1 SUPMAP SUPMA1
C00025 00005	PAGTRP PGTLOS PGTOK PAGPAR PAGPA3 PAGPA7 PAGPA8 PAGPAX PAGPA4 PAGPA5 PAGPA6 PGPART PAGPA1 PAGPA2 PAGKEY PAGEMD PAGBCH PAGBC0 PAGBC1 PAGBAD PAGADL
C00035 00006	KLPFTR KLPFT0 NOADJ4 NOADJ2 NOADJ3 NOADJB PFNOUP PFNOU2 DMDFLT DMDFL1 DMDFL2 PFNOCR PFNOC1 NODMND DOMPV DOMPV1 DOMPV2 DOMPV3 PFIOUU PFIOU2 PFIOU1 PFIOU3 PFIFET PFPUB PFPUBE EPF PFCOM PFCOM1 PFCOM2 PFXIT HPF PIPF RECPFT PAGPDL
C00057 00007	PFPAR KLPAR2
C00059 00008	PAGSET PAGSEN PAGSNL PAGJM0 PAGJ0A
C00065 00009	ADNEMP ADCEMP ADPEMP ADDEVP ADDEMP ADDEMX ADDEM0 ADDEM1 DELEMP GETEMP
C00074 00010	PAGINI PGINI1 SECINI
C00080 00011	NPSM NPSM MAPSET ACTOSH SHTOTR SHTOAC PSHMAP PSHMP2 POPMAP POPBU1 POPBUG APRMAP APMAPX APMAP2 APMA22 APMAPS APMAPZ APMAPY EBXPUT EBXGET
C00095 ENDMK
C⊗;
;ZSGMAP ZSGMA2 ZSGMAX ZSGMA1 ASGMAP ASGMAX

SUBTTL PAGSER - BBN PAGER ROUTINES - JBR 4/75 	;ZSGMAP, ASGMAP

LOSYS			;FOR SANITY, THIS RUNS IN LOWCORE


;ROUTINE TO FLUSH A SEGMENT FROM THE PAGE MAP OF THE LOWER
;CALL WITH JOB NUMBER OF THE LOWER IN TAC, OF THE UPPER IN J.

↑ZSGMAP:PUSH P,TAC1
	PUSH P,AC1
	PUSH P,AC2
IFE FTMPP2,<
	MOVE TAC1,JBTMAP(TAC)		;GET POINTER TO PAGE MAP OF LOWER
>;IFE FTMPP2
IFN FTMPP2,<
	PUSH P,J
	MOVEI J,(TAC)
	PUSHJ P,JOBMAP
	 JFCL
	MOVEI TAC1,(AC1)
	POP P,J
>;IFN FTMPP2
	LSH TAC1,9
	HLRZ AC1,JBTPAG(J)		;NUMBER OF PAGES IN SEGMENT
	JUMPE AC1,ZSGMA1		;JUMP IF THE SEGMENT IS SWAPPED OUT
ZSGMA2:
;	HLRZ AC2,JBTPAG(TAC)		;NUMBER OF PAGES IN THE LOWER
;	CAIGE AC2,400
	MOVEI AC2,400			;PAGE NUMBER WHERE UPPER STARTS
	ADDI AC2,(TAC1)			;ADDRESS OF MAP ENTRY FOR UPPER'S FIRST PAGE
	SETZM (AC2)			;FLUSH PAGE MAP ENTRY FOR UPPER'S FIRST PAGE
	HRLI AC2,(AC2)			;BLT POINTER.  (DESTINATION IS WRONG)
	ADDI AC1,(AC2)			;AC1←ADDR. OF UPPER'S LAST MAP ENTRY+1
	ADDI AC2,1			;SOURCE,,DESTINATION
	BLT AC2,-1(AC1)			;ZERO PAGE MAP ENTRIES FOR UPPER.
ZSGMAX:	POP P,AC2
	POP P,AC1
	POP P,TAC1
	POPJ P,

ZSGMA1:	MOVSI AC1,SWP
	TDNN AC1,JBTSTS(J)	;SKIP IF SEG REALLY SWAPPED OUT
	JRST ZSGMAX		;NON-EX SEGMENT (IT CAN HAPPEN)
	MOVE TAC1,J
	PUSHJ P,CORSGT		;GET SIZE OF UPPER (IN WORDS, IN TAC1)
	LSH TAC1,-9
	MOVE AC1,TAC1
	JRST ZSGMA2

;ROUTINE TO ADD A SEGMENT TO THE PAGE MAP OF THE LOWER
;CALL WITH JOB NUMBER OF THE LOWER IN TAC, OF THE UPPER IN J.
;DOES NOTHING IF UPPER ISN'T IN CORE

↑ASGMAP:PUSH P,TAC1
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	HLRZ AC3,JBTPAG(J)		;NUMBER OF PAGES IN THE UPPER
	JUMPE AC3,ASGMAX		;JUMP IF UPPER ISN'T IN CORE.
IFE FTMPP2,<
	MOVE TAC1,JBTMAP(J)		;TAC1←JBTMAP OF UPPER
	LSH TAC1,9
	MOVE AC1,JBTMAP(TAC)		;AC1←JBTMAP OF LOWER
>;IFE FTMPP2
IFN FTMPP2,<
	MOVEI AC1,PAGEXP		;SPECIAL EXEC VIRTUAL PAGE NUMBER FOR UPPER
	PUSHJ P,JOBEVP			;GET UPPER'S UPMP IN EXEC MAP
	 JFCL
	MOVEI TAC1,PAGEXP⊗9		;SAVE IN TAC1
	PUSH P,J
	MOVEI J,(TAC)			;LOWER'S JOB NUMBER
	PUSHJ P,JOBMAP			;GOES IN NORMAL PI-LEVEL EXEC VIRTUAL SLOT
	 JFCL				; (EXEC VIRTUAL PAGE NUMBER IS IN AC1)
	POP P,J
>;IFN FTMPP2
	LSH AC1,9
;	HLRZ AC2,JBTPAG(TAC)		;NUMBER OF PAGES IN THE LOWER
;	CAIGE AC2,400
	MOVEI AC2,400			;AC2←STARING PAGE OF THE UPPER.
	ADDI AC2,(AC1)			;SETUP TO BLT JBTMAP(UPPER) TO
	HRLI AC2,(TAC1)			; JBTMAP(LOWER) WHERE UPPER BEGINS
	ADDI AC3,(AC2)			;ADDRESS OF FIRST PAGE PAST LAST ONE
	BLT AC2,-1(AC3)			;COPY JBTMAP ENTRIES FROM THE UPPER TO LOWER
	CAIGE AC3,1000(AC1)		;SKIP IF PAGE 777 WAS FILLED.
	SKIPN (AC3)			;DID THE UPPER SHRINK?
	JRST ASGMAX			;SEEMINGLY NOT.
	SETZM (AC3)			;ZERO EXTRA ENTRIES IN JBTMAP OF LOWER
	CAIL AC3,777(AC1)		;VERY LAST PAGE?
	JRST ASGMAX			;YES. AVOID THE BLT.
	HRLI AC3,(AC3)
	ADDI AC3,1
	BLT AC3,777(AC1)
ASGMAX:	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,TAC1
	POPJ P,
;ZERPR2 UPMAPL UPMAP1 UPMAP4 UPMAP3 UPMAPX UPMPGH UPMP3G UPMAP2 UPMAP5 SMAPL SMAP2 SMAP1 ZMAPL STRMAP WPMAPL WPMPBX

;ROUTINE TO ZERO JBTPR2 AND CLEAR THE CORRESPONDING PAGE MAP
;ENTRIES FOR THE UPPER.  SKIPS IF THERE WAS NO JBTPR2.

↑ZERPR2:SKIPN JBTPR2(J)
	JRST CPOPJ1
	PUSHJ P,UPMAPL		;LOOP THROUGH UPPER PAGE MAP ENTRIES
	 SETZM (TAC1)		; ZEROING EACH ONE
	SETZM JBTPR2(J)
	POPJ P,


;ROUTINE TO LOOP THROUGH ALL PAGE MAP LOCATIONS CORRESPONDING TO THE UPPER
;SEGMENT ACCORDING TO JBTPR2.  IT WILL EXECUTE THE INSTRUCTION AFTER THE
;PUSHJ P,UPMAPL.  TAC1 WILL BE THE ADDRESS OF THE PAGE TABLE ENTRY.  AC2
;WILL HAVE THE CORRECT PAGE TABLE ENTRY TO STORE FOR A SIMPLE SETPR2.
;AC1 WILL HAVE A COPY OF JBTPR2(LOWER), J SHOULD HAVE THE JOB NUMBER OF
;THE LOWER

↑UPMAPL:PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC1
	PUSH P,AC2
	MOVE TAC,JBTPR2(J)
IFE FTMPP2,<
	MOVE TAC1,JBTMAP(J)	;POINTER TO PAGE MAP
>;IFE FTMPP2
IFN FTMPP2,<
	PUSHJ P,JOBMAP		;GET UPMP INTO EXEC MAP
	 JFCL
	MOVEI TAC1,(AC1)	;VIRTUAL PAGE NUMBER OF MAP
>;IFN FTMPP2
	LSH TAC1,9
	TRNE TAC,4		;IS THIS THE GETHI HACK?
	JRST UPMPGH		;YES.  DO GETHI
	TRNE TAC,1		;RELATIVE SETPR2?
	JRST UPMAP2		;YES.
UPMAP1:	LDB AC2,[POINT 9,TAC,26];GET RELOC OF UPPER AS A PAGE NUMBER
	HRLI AC2,PREAD		;SET READ, EXECUTE, AND ACCESS
	TLNN TAC,1		;SKIP IF WRITE PROTECTED
	HRLI AC2,PWRT		;Make WRITEable pages
	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	CAIGE AC1,400
	MOVEI AC1,400		;AC1←FIRST VIRTUAL PAGE NUMBER FOR UPPER.
	ADDI TAC1,(AC1)		;CORRESPONDING PAGE MAP ADDRESS
	HLRZ TAC,TAC		;PROTECTION OF THE UPPER
	IORI TAC,401777
	LSH TAC,-9		;LAST PAGE NUMBER OF UPPER
	SUBI TAC,-1(AC1)	;NUMBER OF PAGES OF UPPER
UPMAP4:	MOVE AC1,JBTPR2(J)
UPMAP3:	XCT @-4(P)		;EXECUTE ARGUMENT
	ADDI AC2,1		;BUMP PAGE TABLE ENTRY
	ADDI TAC1,1		;BUMP PAGE TABLE ADDRESS
	SOJG TAC,UPMAP3		;COUNT DOWN NUMBER OF PAGES
	MOVE TAC,JBTPR2(J)
	TRC TAC,14
	TRCN TAC,14		;SKIP UNLESS SCREWY 2-PIECE GETHI
	JRST UPMP3G
UPMAPX:	POP P,AC2
	POP P,AC1
	POP P,TAC1
	POP P,TAC
	JRST CPOPJ1

UPMPGH:	TRNE TAC,10		;IS THIS THE SCREWY 2-PIECE GETHI?
	TDZA AC2,AC2		;YES, START AT PHYSICAL 0
	LDB AC2,[POINT 13,TAC,30]	;GETHI HACK.  GET STARTING PAGE NUMBER.
	HRLI AC2,PREAD		;READ, EXECUTE AND ACCESS PERMISSION.
	TRNE TAC,20		;USER WANTS TO WRITE?
	HRLI AC2,PWRT		;YES. SET WRITE PERMISSION
	HLRZ TAC,TAC		;NUMBER OF PAGES TO ADD TO MAP.
	ADDI TAC1,400		;START AT VIRTUAL PAGE 400.
	JRST UPMAP4

UPMP3G:	TRNN TAC1,777		;SKIP UNLESS FINISHED ENTIRE PAGE MAP
	JRST UPMAPX
	LDB AC1,[POINT 13,TAC,30]	;GET HI PIECE STARTING PAGE NUMBER
	HRRI AC2,(AC1)		;MOVE INTO PAGE TABLE ENTRY
	HLRZ TAC,TAC		;NUMBER OF LOW PIECE PAGES DONE
	MOVN TAC,TAC
	ADDI TAC,400		;NUMBER OF HI PIECE PAGES TO DO
	JUMPE TAC,UPMAPX	;ALL IN LOW PIECE  (STUPID USER! USE SETPR2)
	JRST UPMAP4

;HERE FOR USER RELATIVE JBTPR2
UPMAP2:	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	LSH AC1,9
	SUBI AC1,1(TAC)		;COMPUTE ROOM FROM START OF UPPER TO TOP OF LOWER
	JUMPL AC1,UPMAPX	;UPPER TRYING TO START ABOVE TOP OF LOWER
	HLRZ AC2,TAC		;REQUESTED UPPER SIZE (WITH WR PROT BIT)
	CAILE AC2,(AC1)		;GET MIN OF REQUESTED SIZE AND ROOM
	MOVEI AC2,(AC1)
	IORI AC2,1777
	LSH AC2,-9		;LAST PAGE NUMBER OF UPPER (-400)
	ADDI AC2,1		;NUMBER OF UPPER PAGES
	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	MOVN AC1,AC1
	ADDI AC1,1000		;NUMBER OF PAGES AVAILABLE FOR UPPER
	CAILE AC2,(AC1)
	MOVEI AC2,(AC1)		;DON'T TRY TO HAVE UPPER PAST PAGE 777
	HRLI AC2,PREAD		;SET READ, EXECUTE, AND ACCESS
	TLNN TAC,1		;SKIP IF WRITE PROTECTED
	HRLI AC2,PWRT		;SET UP WRITE ACCESS
	HRRZ AC1,AC2		;NUMBER OF UPPER PAGES
	PUSH P,AC1
	LSH TAC,-9		;VIRTUAL PAGE NUMBER IN LOWER OF START OF UPPER
	ANDI TAC,777
	ADD TAC,TAC1		;PAGE MAP ADDRESS TO COPY FROM
	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES IN THE LOWER
	CAIGE AC1,400
	MOVEI AC1,400		;AC1←FIRST VIRTUAL PAGE NUMBER FOR UPPER.
	ADDI TAC1,(AC1)		;CORRESPONDING PAGE MAP ADDRESS
	MOVE AC1,JBTPR2(J)
UPMAP5:	HRR AC2,(TAC)		;GET PHYSICAL PAGE NUMBER FROM LOWER'S MAP
	XCT @-5(P)		;EXECUTE ARGUMENT
	ADDI TAC1,1		;BUMP PAGE TABLE ADDRESS
	ADDI TAC,1		;BUMP POINTER TO LOWER'S PAGE TABLE
	SOSLE (P)		;COUNT DOWN NUMBER OF PAGES
	JRST UPMAP5
	POP P,(P)		;FLUSH COUNT
	JRST UPMAPX


;LOOP THROUGH ALL PAGE MAP LOCATIONS FOR A SEGMENT (UPPER OR LOWER)
;AC1 SHOULD HAVE NUMBER OF PAGES.  IT WILL EXECUTE THE INSTRUCTION AFTER
;THE PUSHJ P,SMAPL.  TAC1 WILL BE THE ADDRESS OF THE PAGE TABLE ENTRY.
;AC2 WILL HAVE THE OLD PAGE TABLE ENTRY.  AFTER THE INSTRUCTION IS EXECUTED,
;AC2 IS STORED BACK IN THE PAGE TABLE AT (TAC1).  J SHOULD HAVE THE JOB
;NUMBER OF THE SEGMENT.
;
;CALL:	MOVE AC1,<NUMBER OF PAGES>
;	MOVE J,<JOB NUMBER OF SEGMENT>
;	PUSHJ P,SMAPL
;	 <INSTR TO XCT FOR EACH PAGE>	;TAC1=ADDRESS OF PAGE TABLE ENTRY
;					;AC2=OLD PAGE TABLE ENTRY

↑SMAPL:	PUSH P,TAC
	PUSH P,TAC1
IFE FTMPP2,<
	MOVE TAC1,JBTMAP(J)	;PAGE NUMBER OF PAGE MAP
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE TAC1,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH TAC1,AC1		;RESTORE AC1, EXEC VIRT PG NO IN TAC1
>;IFN FTMPP2
	LSH TAC1,9
SMAP2:	PUSH P,AC2
	MOVE TAC,AC1		;NUMBER OF PAGES
SMAP1:	MOVE AC2,(TAC1)		;GET PAGE TABLE ENTRY
	XCT @-3(P)
	MOVEM AC2,(TAC1)	;STORE IT BACK
	ADDI TAC1,1		;BUMP PAGE TABLE ADDRESS
	SOJG TAC,SMAP1		;LOOP FOR ALL SEGMENT PAGES
	POP P,AC2
	POP P,TAC1
	POP P,TAC
	JRST CPOPJ1		;SKIP THE ARGUMENT


;ZERO PAGE MAP ENTRIES FOR A JOB THAT IS SHRINKING
;CALL:	MOVE AC1,<NUMBER OF PAGES TO ZERO>
;	MOVE J,<JOB NUMBER OF LOWER>
;	MOVE TAC,<NUMBER OF PAGES TO KEEP IN THE LOWER>
;	PUSHJ P,ZMAPL
;	 MOVEI AC2,0

↑ZMAPL:	PUSH P,TAC
	PUSH P,TAC1
IFE FTMPP2,<
	MOVE TAC1,JBTMAP(J)	;PAGE NUMBER OF PAGE MAP
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE TAC1,AC1
	PUSHJ P,JOBMAP
	 JFCL
	EXCH TAC1,AC1		;RESTORE AC1, EXEC VIRT PG NO IN TAC1
>;IFN FTMPP2
	LSH TAC1,9
	ADDI TAC1,(TAC)		;START AFTER LOWER
	JRST SMAP2


;ROUTINE TO STORE PAGE MAP ENTRIES, SETTING WRITE PROTECTION IF DDB IS NON-ZERO
;USED AS ARGUMENT TO PUSHJ P,SMAPL

↑STRMAP:SKIPE DDB
	TLZ AC2,P.WRT		;TURN OFF WRITE PERMISSION
	MOVEM AC2,(TAC1)	;AND STORE PAGE MAP ENTRY
	POPJ P,


;SET OR CLEAR WRITE PROTECT BIT IN ALL PAGES OF A SEGMENT.
;CALL WITH J=SEGMENT NUMBER, DDB=0 FOR WRITE PERMIT

↑WPMAPL:PUSH P,AC1
	SKIPE DDB
	MOVNI DDB,1
	SETCA DDB,		;DDB BIT 35 IS NOW WRITE PERMIT BIT
	HLRZ AC1,JBTPAG(J)	;NUMBER OF PAGES IN SEGMENT
	PUSHJ P,SMAPL		;LOOP THROUGH ALL SEGMENT PAGES
	 DPB DDB,[POINT 1,AC2,∃P.WRT-18] ;SET P.WRT BIT FROM COMPLEMENT OF ARG
	SETCA DDB,		;RESTORE SENSE OF DDB
	POP P,AC1
IFN FTUPCLB,<
IFN FTCINS,<
	PUSH P,DDB
	PUSH P,PROG
	JUMPE DDB,WPMPBX	;JUMP IF WRITE PERMIT
	HLLZ DDB,JBTPAG(J)
	LSH DDB,9
	MOVN DDB,DDB		;-SIZE OF CORE IMAGE,,0  = AOBJN POINTER TO CORE
	HRRI DDB,400000
	MOVEI PROG,0
	XCTR XBLTR,[CHKINS DDB,]	;CHECKSUM!
	MOVEM PROG,JBTSCS(J)
	HLRZ DDB,JBTPAG(J)	;GET SIZE OF JOB IN PAGES
	LSH DDB,3		;MAKE A 12-BIT FIELD
	DPB DDB,[POINT 12,JB2SWP(J),29]	;STORE HERE (9BIT SIZE, 3BIT COUNT)
	CAIA
WPMPBX:	SETZM JBTSCS(J)
	POP P,PROG
	POP P,DDB
>;IFN FTCINS
>;IFN FTUPCLB
	POPJ P,
;UNPMAP MAKMAP MAKMP1 ZAPLOJ ZAPLO1 AUPMAP AUPMA1 SUPMAP SUPMA1

;UNPURIFY AN UPPER SEGMENT AND ALL THE LOWERS THAT ARE IN CORE
;AND POINT TO IT.  AC1 HAS JOB NUMBER OF THE UPPER

↑UNPMAP:PUSH P,AC1
	PUSH P,J
	MOVE J,AC1		;SET UP JOB NUMBER OF UPPER
	HLRZ AC1,JBTPAG(J)	;PROT OF UPPER
	PUSHJ P,SMAPL		;LOOP THROUGH PAGES OF UPPER
	 TLO AC2,P.WRT		;TURN ON WRITE ENABLE BIT
	PUSHJ P,AUPMAP		;NOW SPEAD THIS THROUGH ALL OUR LOWERS IN CORE
IFN FTUPCLB,<
	SETZM JBTSCS(J)
>;IFN FTUPCLB
	POP P,J
	POP P,AC1
	POPJ P,

;ROUTINE TO SET UP JBTMAP(J) TO NEW PAGE MAP UNLESS IT ALREADY HAS ONE

;; Note: If FTMPP2 is on, callers of MAKMAP (currently only in UUOCON) must
;; not have called JOBMAP because GETMAP calls it.

↑MAKMAP:PUSH P,AC1
	SKIPE AC1,JBTMAP(J)
	JRST MAKMP1
	PUSHJ P,GETMAP
	JRST 4,.		;GETMAP ALWAYS SKIPS AT UUO LEVEL
	MOVEM AC1,JBTMAP(J)
MAKMP1:	POP P,AC1
	POPJ P,

;ROUTINE TO REMOVE AN UPPER FROM ALL ITS LOWER'S MAPS
;JOB NUMBER OF THE UPPER IS IN J

↑ZAPLOJ:PUSH P,TAC
	PUSHJ P,UAPPLY
	 PUSHJ P,ZAPLO1		;ROUTINE TO CALL FOR EACH LOWER OF THE UPPER
	POP P,TAC
	POPJ P,

;GET HERE FOR EACH LOWER OF THE UPPER, WITH JOB NUMBER OF LOWER IN J
;JOB NUMBER OF UPPER IN DDB

ZAPLO1:	SKIPE JBTMAP(J)		;SKIP IF THERE'S NO MAP
	SKIPN JBTPAG(J)		;SKIP IF LOWER'S INCORE
	POPJ P,
	MOVE TAC,J		;LOWER IN TAC
	MOVE J,DDB		;UPPER IN J
	PUSHJ P,ZSGMAP		;FLUSH UPPER PAGES FROM LOWER'S MAP
	MOVE J,TAC
	POPJ P,

;SPREAD AN UPPER TO THE PAGE MAP OF EACH OF ITS LOWERS. CALL WITH J = UPPER'S NUMBER

↑AUPMAP:PUSH P,TAC
	PUSHJ P,UAPPLY
	 PUSHJ P,AUPMA1		;ROUTINE TO CALL FOR EACH LOWER OF THE UPPER
	POP P,TAC
	POPJ P,

;GET HERE FOR EACH LOWER OF THE UPPER, WITH JOB NUMBER OF LOWER IN J
;JOB NUMBER OF UPPER IN DDB

AUPMA1:	SKIPE JBTMAP(J)		;DO NOTHING UNLESS LOWER HAS A MAP
	SKIPN JBTPAG(J)		;AND CORE ASSIGNED IN CORE
	POPJ P,
	MOVE TAC,J		;TAC←JOB NUMBER OF LOWER
	MOVE J,DDB		;J←JOB NUMBER OF UPPER
	PUSHJ P,ASGMAP
	MOVE J,TAC
	POPJ P,

IFN FTDMDP,<
;COPY 1 ENTRY FROM THE PAGE MAP OF AN UPPER TO THE PAGE MAP OF EACH OF ITS LOWERS.
;CALL WITH J = UPPER'S NUMBER, TAC = PAGE NUMBER IN LOWER TO COPY INTO
;AND TAC1 = PAGE TABLE ENTRY TO WRITE THERE

SUPMAP:	PUSH P,AC1
	PUSHJ P,UAPPLY
	 PUSHJ P,SUPMA1		;ROUTINE TO CALL FOR EACH LOWER OF THE UPPER
	POP P,AC1
	POPJ P,

;GET HERE FOR EACH LOWER OF THE UPPER, WITH JOB NUMBER OF LOWER IN J
;JOB NUMBER OF UPPER IN DDB

SUPMA1:	SKIPE AC1,JBTMAP(J)	;DO NOTHING UNLESS LOWER HAS A MAP
	SKIPN JBTPAG(J)		;AND CORE ASSIGNED IN CORE
	POPJ P,
IFN FTMPP2,<
	PUSHJ P,JOBMAP		; !! NOTE THAT THE CALLER OF SUPMAP
	 JFCL			; !!  BETTER NOT CALL JOBMAP TO SET TAC1
>;IFN FTMPP2
	LSH AC1,9		;PAGE TABLE OF LOWER
	ADDI AC1,(TAC)		;ADD IN PAGE NUMBER
	MOVEM TAC1,(AC1)	;STORE ENTRY THERE
	POPJ P,
>;IFN FTDMDP
;PAGTRP PGTLOS PGTOK PAGPAR PAGPA3 PAGPA7 PAGPA8 PAGPAX PAGPA4 PAGPA5 PAGPA6 PGPART PAGPA1 PAGPA2 PAGKEY PAGEMD PAGBCH PAGBC0 PAGBC1 PAGBAD PAGADL

NOKL10,<	;Whole page

↑PAGTRP:EXCH P,PAGPDL
	CAME P,[-PAGPLN,,PAGPD-1]
	JRST RECPFT		;RECURSIVE PAGE FAULT
	PUSH P,TAC
	MOVE TAC,PSB+TSW	;GET TRAP STATUS WORD
	TLNE TAC,400		;PARITY ERROR?
	JRST PAGPAR
	TLNE TAC,100		;KEY CYCLE
	JRST PAGKEY
	CONSZ PI,<<100000⊗-APRCHN>-1>≠77777 ;SKIP IF NOT IN PROGRESS ON 1-3
	JRST PAGBCH		;BAD CHANNEL TO BE IN PROGRESS ON

	PUSH P,TAC1
	LDB TAC,PAGJOB		;JOB NUMBER THAT MAP IS SETUP FOR
	JUMPE TAC,PGTOK		;NULL JOB IS OK.
	HLRZ TAC1,PAGREG	;PAGER'S UBR
	CAMN TAC1,JBTMAP(TAC)	;OUGHT TO BE THE SAME.
	JRST PGTOK		;YES.  LEAVE.
PGTLOS:	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /PAGE TRAP WITH PAGREG INCONSISTENT.
PAGREG = /
	MOVE TAC,PAGREG
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /    BBN72= /
	MOVE TAC,BBN72
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /
JBTMAP(PAGREG[18:17+JOBNSZ]) = /
	LDB TAC,PAGJOB		;Get job number out of PAGREG
	MOVE TAC,JBTMAP(TAC)
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	POPACS
PGTOK:	POP P,TAC1
	MOVE TAC,PSB+TSW

	TLNE TAC,240		;NXM OR PI CYCLE?
	JRST PAGBAD		;SOMETHING BAD HAPPENED
	CAMGE TAC,[600000,,000000]
	TLNE TAC,160000
	JRST PAGBAD		;TSR 0,1 ≠ 1 0 OR BAD TRAP
	TLNE TAC,1000		;ADRESS LIMIT REGISTER VIOLATION?
	JRST PAGADL		;YES
	TLNN TAC,16000		;NO ACCESS OR ILLEGAL READ/EXECUTE OR WRITE
	JRST PAGBAD		;NO
	MOVE TAC,PAGINT		;GET TRAP PC.
	TLNN TAC,USRMOD		;USER MODE?
	CONSO PI,77400		;EXEC MODE.  UUO LEVEL?
	JRST .+2		;USER MODE OR UUO LEVEL TRAP.
	JRST PAGEMD		;EXEC MODE PI IN PROGRESS.  WORRY!
	POP P,TAC
	EXCH P,PAGPDL
PAGAGN:	CONO PI,APROFF		;DON'T GET INTO CH3 WITH PAGFLG BUT NO ILM
	SETOM PAGFLG		;TELL CHANNEL 3 WE'RE COMING
IFN FTF2,<
	SETOM F2ILM		;Set the simulated hardware ILM bit
	CONO PI,4000+1⊗<7-APRCHN> ;Generate int on APR channel, like ILM bit would
>;IFN FTF2
IFE FTF2,<
	CONO PI,20000		;SET CPA MEM PROT FLAG
PRINTX Does CONO PI,20000 set ILM only on our KA?
;If so, then F2ILM code around APRFLT should be under NOKL10 instead of FTF2.
>;IFE FTF2
	CONO PI,APRON
	JFCL

	PUSHACS			; HMM. DIDN'T INTERRUPT - THAT'S A BUG!
	PUSHJ P,DISUSR		;PRINT TIME OF MSG ON CTY
	 SIXBIT /PGTOK/
	PUSHJ P,DISERR
	DISARG STR,[ASCIZ /TRIED TO MAKE A CH3 INTERRUPT AND NOTHING HAPPENED!
/]
	-1
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCALL
	JRST PAGAGN		; ANYTHING BETTER TO DO HERE?


PAGPAR:	PUSHACS
	CONI PI,TAC
	SYSPIFF
	CONO PAG,4		;TURN OFF ALL MAPPING
	PUSH P,TAC
	PUSHJ P,DISMES
	ASCIZ /PAGER PARITY ERROR IN /
	MOVE TAC,PSB+TSW
	TLNN TAC,1		;EXEC MODE REFERENCE?
	JRST PAGPA1		;USER MODE
	PUSHJ P,DISMES
	ASCIZ /EXEC MODE
/
	MOVE TAC,PSB+TSW
	HRRZ TAC1,TAC		;GET EXEC VIRTUAL ADDRESS
	CAIL TAC1,600000
	JRST PAGPA2		;THESE ADDRESSES MAPPED INDIVIDUALLY PER USER
	LSH TAC1,-9		;GET PAGE NUMBER
	MOVEI AC1,3000(TAC1)	;ADDRESS OF PAGE TABLE ENTRY
PAGPA3:	PUSHJ P,PGPART		;SEE IF THERE IS A PARITY ERROR AT (AC1)
	JRST PAGPA4		;NO ERROR HERE, SEE IF SHARED OR INDIRECT NOW
PAGPA7:	CONO PI,200000		;YES, FIX UP THE PAGE TABLE AND GO AWAY
	PUSH P,AC2
	PUSH P,AC1
	PUSHJ P,DISMES
	ASCIZ /LOC = /
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / CORE = /
	POP P,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
PAGPA8:	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	CONO PAG,0		;LOAD UP REGISTERS AGAIN
	CONO PAG,7		;TURN MAPPING BACK ON (MAP ALL OF EXEC)
	POP P,TAC
	TRNE TAC,200		;SKIP IF PIS WERE OFF
	SYSPIN
PAGPAX:	POPACS
	POP P,TAC
	EXCH P,PAGPDL
	JRST 2,@PAGINT

PAGPA4:	TLNE AC2,600000		;SKIP IF PRIVATE PAGE
	JRST PAGPA5		;SHARED OR INDIRECT PAGE TABLE ENTRY
	MOVEI AC1,CST(AC2)	;CST ENTRY
	PUSHJ P,PGPART		;SKIP IF THERE IS A PARITY ERROR THERE
	JRST PAGPA6		;NOT THERE EITHER
	JRST PAGPA7		;STORE CORRECT CST ENTRY AND LEAVE

PAGPA5:	PUSHJ P,DISMES
	ASCIZ /SHARED OR INDIRECT PAGE TYPE -- NOT IMPLEMENTED YET
/
	JRST PAGPA8

PAGPA6:	PUSHJ P,DISMES
	ASCIZ /BUT NOT IN EXEC PT, PSB OR CST
/
	JRST PAGPA8

PGPART:	CONO PI,200000		;CLEAR PARITY ERROR FLAG
	MOVE AC2,(AC1)		;REFERENCE THE LOCATION
	CONSZ PI,200000		;SKIP IF THERE IS NO PARITY ERROR
	AOS (P)
	POPJ P,

PAGPA1:	PUSHJ P,DISMES
	ASCIZ /USER MODE
/
	MOVE TAC,PSB+TSW
	LDB AC1,[POINT 11,PAGREG,17] ;FETCH UBR
	LSH AC1,9		;TURN INTO AN ADDRESS
	HRRZ TAC1,TAC		;USER MODE VIRTUAL ADDRESS
	LSH TAC1,-9		;PAGE NUMBER
	ADDI AC1,(TAC1)		;ADDRESS OF PAGE TABLE ENTRY
	JRST PAGPA3

PAGPA2:	LSH TAC1,-9		;GET PAGE NUMBER
	MOVEI AC1,PSB(TAC1)
	JRST PAGPA3

PAGKEY:	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /PAGE FAULT ON KEY CYCLE
TRAP STATUS = /
	MOVE TAC,PSB+TSW
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	JRST PAGPAX

;THIS IS SOMETHING TO CONSIDER LATER.
PAGEMD:	POP P,TAC
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /PAGE FAULT - NO ACCESS OR ILLEGAL ACCESS - PI IN PROGRESS
PI = /
	JRST PAGBC0

;EXEC MODE AND PI IN PROGRESS.
PAGBCH:	POP P,TAC
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /PAGE FAULT PI IN PROGRESS PI = /
PAGBC0:	CONI PI,TAC
	PUSHJ P,DISLOC
PAGBC1:	PUSHJ P,DISMES
	ASCIZ /  PC = /
	MOVE TAC,PAGINT
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /
TRAP STATUS WORD = /
	MOVE TAC,PSB+TSW
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /
WILL DISMISS VIA JRST 2,@PAGINT
/
	PUSHJ P,DISFLU
IFE FTCCRMA,<
	PUSHJ P,WDDTCA
>;IFE FTCCRMA
IFN FTCCRMA,<
	PUSHJ P,FDDTCA		;Some people won't pay attention...
>;IFN FTCCRMA
	POPACS
	EXCH P,PAGPDL
	JRST 2,@PAGINT

PAGBAD:	POP P,TAC
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /PAGE FAULT WITH BAD TRAP STATUS/
	JRST PAGBC1

PAGADL:	SKIPN JOB		;IS IT THE NULL JOB
	CONSZ PI,77400		;YES, ARE WE IN PROGRESS AT ALL
	JRST PAGBAD		;NOT NULL JOB, OR IN PROGRESS SOMEWHERE
	HRRZ TAC,TAC		;GET ADDRESS OF REQUEST
	CAIGE TAC,40000		;NULL JOB IS ADDRESS LIMITED TO 16K
	JRST PAGBAD		;WELL, THAT WASN'T IT
	POP P,TAC
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /ADDRESS LIMIT VIOLATION FROM NULL JOB
/
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCA
	POPACS
	EXCH P,PAGPDL
	JRST NULPAG		;START UP THE NULL JOB AGAIN

>;NOKL10
;KLPFTR KLPFT0 NOADJ4 NOADJ2 NOADJ3 NOADJB PFNOUP PFNOU2 DMDFLT DMDFL1 DMDFL2 PFNOCR PFNOC1 NODMND DOMPV DOMPV1 DOMPV2 DOMPV3 PFIOUU PFIOU2 PFIOU1 PFIOU3 PFIFET PFPUB PFPUBE EPF PFCOM PFCOM1 PFCOM2 PFXIT HPF PIPF RECPFT PAGPDL

IFKL10,<
↑KLPFTR:EXCH P,PAGPDL
	CAME P,[-PAGPLN,,PAGPD-1]
	JRST RECPFT			;RECURSIVE PAGE FAULT
	PUSH P,TAC
	MOVE TAC,KLUPT+KLPFW		;save page fail word
	MOVEM TAC,SVPFW
	MOVE TAC,KLUPT+KLPFPC		;save page fail PC
	MOVEM TAC,SVPFPC
IFN FTKLB,<
	MOVE TAC,KLUPT+KLPFFG		;save PC flags too
	MOVEM TAC,SVPFFG
	JSP TAC,.+1			;get current PC flags
	TLO TAC,PCU			;turn on prev context user
	HRRI TAC,KLPFT0			;address to jump to when setting flags
	JRST 2,@TAC			;set PCU and continue here

KLPFT0:
>;IFN FTKLB
	LDB TAC,[POINT 5,KLUPT+KLPFW,5]	;GET FAILURE TYPE
	CAIE TAC,36
	CAIN TAC,37
	JRST PFPAR			;AR/ARX PARITY ERROR
IFN FTKLB,<
	CAIN TAC,25
	JRST PFPAR			;page table parity error
>;IFN FTKLB
	CAIN TAC,23			;IS IT ADDRESS BREAK?
	JRST KLADRB			;YES. (SEE KLSER)
	CONSZ PI,77400			;SKIP UNLESS IN PROGRESS
	JRST PIPF			;PAGE FAIL IN BAD PI CHANNEL
	SKIPL TAC,KLUPT+KLPFW		;GET PAGE FAIL WORD
	JRST EPF			;EXEC MODE REFERENCE FAILED
	LDB TAC,[POINT 5,TAC,5]
	CAIN TAC,21			;USER PROPRIETARY VIOLATION
	JRST PFPUB
IFE FTKLB,<
	CAIE TAC,24			;ILLEGAL WRITE
	CAIN TAC,30			;SECTION NO ACCESS
	JRST DOMPV
	CAIE TAC,33			;PAGE NO ACCESS?
	JRST HPF			;HARDWARE PAGE FAIL
>;IFE FTKLB
IFN FTKLB,<
;Here to see if page fail caused by buggy microcode for ADJBP on page boundary.
	JUMPN TAC,NOADJB	;jump if not a no-mapping trap
	HRRZ TAC,KLUPT+KLPFW	;get page fault address
	CAMN TAC,KLUPT+KLPFPC	;same as PC?
	TRNE TAC,777		;fault occur on page boundary?
	JRST NOADJB		;nope, not ADJBP bug after all
	MOVE TAC,JOB		;see if job is really big enough for this ref
	HLRZ TAC,JBTPAG(TAC)	;get size of job in pages
	LSH TAC,9		;convert to words
	CAMG TAC,KLUPT+KLPFPC	;fault PC in lower segment?
	JRST NOADJ2		;nope, maybe in upper
NOADJ4:	POP P,TAC		;yes, probably page fail shouldn't have happened
	JRST PFXIT		;restore P and return to user

NOADJ2:	MOVE TAC,KLUPT+KLPFPC	;get fault PC again
	TRZN TAC,400000		;PC maybe in upper?
	JRST NOADJB		;nope, real error
	PUSH P,J		;see if fault PC is in job's upper, save an AC
	MOVE J,JOB		;get job number again, for next byte ptr
	LDB J,PSEGN		;get number of upper segment, if any
	JUMPE J,NOADJ3		;jump if no upper, real error
	HLRZ J,JBTPAG(J)	;size of upper in pages
	LSH J,9			;convert to words
	CAIG J,(TAC)		;fault PC before end of upper?
	JRST NOADJ3		;no, must be real error
	POP P,J			;yes, false page fail
	JRST NOADJ4		;go restore things and return to losing instr

NOADJ3:	POP P,J			;restore AC (TAC still pushed)
NOADJB:
>;IFN FTKLB
IFE FTDMDP,<
;** Fall into DOMPV for user mode ILM.
>;IFE FTDMDP
IFN FTDMDP,<
	PUSH P,J
	PUSH P,TAC1
	LDB J,PAGJOB			;GET JOB NUMBER OUT OF PAGREG
	LDB TAC,[POINT 9,KLUPT+KLPFW,26]	;VIRTUAL PAGE NUMBER THAT FAILED
	CAIGE TAC,400			;IS THIS AN UPPER SEGMENT PAGE?
	JRST PFNOUP			;NO
	LDB TAC1,PSEGN			;DOES THIS JOB HAVE AN UPPER
	JUMPE TAC1,PFNOUP		;NO
	MOVE J,TAC1			;YES, TREAT AS UPPER'S PAGE FAULT
	SUBI TAC,400			;PAGE NUMBER IN UPPER
PFNOUP:
IFE FTMPP2,<
	MOVE TAC1,JBTMAP(J)
	LSH TAC1,9
>;IFE FTMPP2
IFN FTMPP2,<
	MOVE TAC1,AC1			;SAVE AC1
	MOVEI AC1,DPGEXP		;DEMAND PAGING SPECIAL EXEC VIRTUAL PAGE
	PUSHJ P,JOBEVP			;GET UPMP INTO EXEC MAP
	 JFCL
	MOVE AC1,TAC1			;RESTORE AC1
	MOVEI TAC1,DPGEXP⊗9
>;IFN FTMPP2
	ADD TAC,TAC1
	SKIPN TAC1,(TAC)		;PAGE TABLE ENTRY
	JRST NODMND			;REAL ILL MEM REF
	CONSO PI,77400			;SKIP IF IN PROGRESS
	TLNE TAC1,P.ACC			;KL10 ACCESS BIT SHOULD HAVE BEEN OFF
	JRST PFTILL			;IMPOSSIBLE OR ILLEGAL PAGE FAULT
	TLNN TAC1,4000			;SKIP IF FAULT IN A FRESH PAGE
	JRST DMDFLT			;PAGE IS ON THE DISK
	PUSH P,LOC
	PUSH P,TAC			;SAVE ITS ADDRESS IN PAGE TABLE
	PUSH P,TAC1			;SAVE OLD PAGE TABLE ENTRY
	PUSHJ P,GETPAG			;GET A FRESH PAGE, SETS UP CORTAB AND CST
	 JRST PFNOCR			;NO CORE
	POP P,TAC1			;GET PAGE TABLE ENTRY BACK
IFN FTKLB,<
.FATAL This use of the page table entries doesn't work for model B microcode paging.
;because I haven't figured out what really needs to be on for pages swapped out
;on the model B.  All of FTDMDP needs to be checked out.  Also SWPSER for FTDMDP.
>;IFN FTKLB
	TLO TAC1,P.READ ! P.ACC		;SET (READ) ACCESS BIT AND BBN ACCESS BIT
	TLZ TAC1,6037			;CLEAR ALL EXTRANEOUS BITS
	HRR TAC1,LOC			;GET PHYSICAL PAGE NUMBER
	POP P,TAC			;GET PAGE TABLE ENTRY ADDRESS BACK
	MOVEM TAC1,(TAC)		;STORE IN PAGE TABLE
	MOVE LOC,JBTSTS(J)
	TLNN LOC,JSEG			;IF JOB IS AN UPPER ...
	JRST PFNOU2
IFE FTMPP2,<
	MOVE LOC,JBTMAP(J)		;... SPREAD ENTRY TO ALL LOWERS' MAPS
	LSH LOC,9
>;IFE FTMPP2
IFN FTMPP2,<
	MOVEI LOC,DPGEXP⊗9
>;IFN FTMPP2
	SUBI TAC,-400(LOC)		;PAGE NUMBER IN LOWERS OF THIS UPPER PAGE
	PUSHJ P,SUPMAP			;COPY TAC1 TO LOWERS' PAGE TAC
PFNOU2:	POP P,LOC
	POP P,TAC1
	POP P,J
	POP P,TAC
	JRST PFXIT			;RESTART INSTRUCTION.  SHOULD WIN NOW.

DMDFLT:	TLNE TAC1,20			;IS PAGE ALREADY IN TRANSIT?
	JRST DMDFL1			;YES, WAIT FOR IT TO COME IN
	LDB TAC1,[POINT 7,KLUPT+KLPFW,24]	;VIRTUAL PAGE NUMBER/4
	PUSHJ P,DMDSWP			;MAKE A REQUEST TO SWAP IT IN
	 JRST PFNOC1			;CAN'T MAKE REQUEST SINCE NOT ENOUGH CORE
DMDFL1:	LDB J,PAGJOB			;GET JOB NUMBER WHICH REALLY FAULTED
	MOVNI TAC,PAGEQ
	MOVEM TAC,JOBQUE(J)		;REQUE JOB TO PAGE WAIT QUEUE
	PUSHJ P,REQUE
DMDFL2:	POP P,TAC1
	POP P,J
	MOVE TAC,KLUPT+KLPFPC
IFN FTKLB,<
.FATAL Does this really work to stuff the PC flags in the left half?
	HLL TAC,KLUPT+KLPFFG		;make a PC words, with flags in LH
>;IFN FTKLB
	CONO PI,CLKOFF
	MOVEM TAC,KLTPC			;STORE PF PC WHERE KCLKIN WILL SEE IT
	POP P,TAC
	EXCH P,PAGPDL			;FIX ALL THE ACS
	SETOM KLTPCF
	CONO PI,CLKON!4000		;INITIATE ON CLK CHNL AND TURN IT ON
	CONO PI,0			;MAKE SURE INT HAPPENS
	JRST 4,.

PFNOCR:	POP P,TAC1
	POP P,TAC
	POP P,LOC
PFNOC1:	AOS PFFLDC			;NOT ENOUGH CORE FOR SWAPIN REQUEST
	LDB J,PAGJOB			;GET JOB NUMBER WHICH REALLY FAULTED
	CAMN J,JOB			;IF THE LOSER IS THE CURRENT JOB,
	SETZM SCHMQT			;  THEN FLUSH THE REST OF HIS QUANTUM
	SETZM SWOCNT			;TELL CLKSER TO SWAP SOMEBODY OUT THIS TICK
	JRST DMDFL2			;FIRE UP CH7

NODMND:	POP P,TAC1
	POP P,J
>;IFN FTDMDP
DOMPV:	CONSZ PI,77400			;SKIP UNLESS IN PROGRESS
	JRST PIPF			;PAGE FAIL IN BAD PI CHANNEL
IFN FTKLB,<
	MOVE TAC,KLUPT+KLPFFG		;get pf flags
>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,KLUPT+KLPFPC		;get pf flags and PC
>;IFE FTKLB
	TLNE TAC,USRMOD			;SKIP UNLESS FAILING PC IS IN USER MODE
	JRST DOMPV1
	SKIPN TAC,PFIOEF		;SKIP IF DOING XCTR AT PFIOUU
	JRST DOMPV2			;NOT
	SETZM PFIOEF			;WAS A REAL PAGE FAULT ON EFF ADR CALC
	MOVEM TAC,KLUPT+KLPFPC		;PUT BACK PREVIOUS FAULT PC (USER MODE PC)
IFN FTKLB,<
	MOVE TAC,PFIOFG			;put back previous fault flags too
	MOVEM TAC,KLUPT+KLPFFG
>;IFN FTKLB
	DATAI KLPAG,TAC			;GET AC CONTEXT
	TLNE TAC,001000			;SHOULD BE EXEC (0)
	JRST DOMPV2
	POP P,TAC
	EXCH P,PAGPDL
	DATAO KLPAG,[401000,,0]		;BACK TO USER AC CONTEXT
	EXCH P,PAGPDL
	PUSH P,TAC
	JRST DOMPV2			;AND TAKE A PAGE FAULT

DOMPV1:	TLNE TAC,4000			;SKIP UNLESS FAILING PC IS IN IOT USER MODE
	JRST DOMPV2
IFN FTKLB,<
	MOVE TAC,KLUPT+KLPFPC
	TLNE TAC,-1			;skip unless fault PC is in nonzero section
	JRST DOMPV2			;forget about IO UUOs, this is real loser
	XOR TAC,KLUPT+KLPFW
	TRNN TAC,-1			;SKIP IF PF PC IS DIFFERENT THAN LOSING ADDR
	JRST DOMPV2			;PAGE FAULT WAS FROM INSTRUCTION FETCH
>;IFN FTKLB
IFE FTKLB,<
	TLZ TAC,17
	XOR TAC,KLUPT+KLPFW
	TDNN TAC,[17,,-1]		;SKIP IF PF PC IS DIFFERENT THAN LOSING ADDR
	JRST DOMPV2			;PAGE FAULT WAS FROM INSTRUCTION FETCH
>;IFE FTKLB
;Now we see if the page fail came from an IO UUO (700+), in which case we'll
;simulate an MUUO trap.  Otherwise, we'll give user the error (DOMPV2).
	XCTR XLB,[LDB TAC,[POINT 9,@KLUPT+KLPFPC,8]]	;GET TOP 9 BITS AT THAT PC
	CAIN TAC,<XCT>⊗-=27
	JRST PFIOUU			;IT'S AN EXECUTE
	TRC TAC,700
	TRCN TAC,700			;SKIP IF NOT AN I/O INSTRUCTION
	JRST PFIOUU			;REALLY AN I/O UUO (MAYBE)
DOMPV2:	MOVEI TAC,ILM			;SIMULATE MPV BIT IN KA10 STYLE CONI
DOMPV3:	IORM TAC,KLECON			;TURN ON IN KL10 ERROR CONI BITS
	POP P,TAC
	EXCH P,PAGPDL
	JRST KLEINT

;GET HERE IF THE PAGE FAULT WAS IN USER MODE, NOT IOT USER MODE.
PFIOUU:	POP P,TAC
	EXCH P,PAGPDL			;ALL USER'S ACS ARE NOW BACK
	DATAI KLPAG,KLUPT+KLCNTX	;STORE PROCESS CONTEXT FOR MUUO TRAP
	DATAO KLPAG,[400100,,0]		;GET AC BLOCK 0, PREV 1
	MOVE P,PAGPDL			;GET A STACK
IFN FTKLB,<
	MOVE TAC,KLUPT+KLPFFG		;user flags
	MOVEM TAC,PFIOFG		;remember flags for later restoral
	MOVEM TAC,KLUPT+KLUUFG		;simulate MUUO's storing of flags
>;IFN FTKLB
	MOVE TAC,KLUPT+KLPFPC		;USER ADDRESS OF FAILING INSTRUCTION
	MOVEM TAC,PFIOEF		;FLAG THAT WE MAY GET PF ON EFF ADR CALC
	MOVE TAC1,TAC
	HRRI TAC1,1(TAC1)		;SIMULATE PC THAT WOULD BE STORED ON MUUO
	MOVEM TAC1,KLUPT+KLUUPC		;STORE AS MUUO PC WORD
PFIOU2:	PUSHJ P,PFIFET			;COMPUTE INSTRUCTION AT (TAC) INTO TAC1
	LDB AC1,[POINT 9,TAC1,8]	;GET OPCODE
	CAIN AC1,<XCT>⊗-=27
	JRST PFIOU1
	TRC AC1,700
	TRNE AC1,700			;SKIP IF IT'S AN I/O INSTRUCTION
	JRST PFIOU3			;NOT XCT AND NOT I/O INSTRUCTION
IFN FTKLB,<
	HLRM TAC1,KLUPT+KLUUFG		;STORE OPCODE AND AC FIELD
	HRRZM TAC1,KLUPT+KLUUEA		;STORE EFFECTIVE ADDRESS
	SETZM PFIOEF
	JRST @KLUPT+KLCNTW		;SIMULATE CONCEALED NO TRAP MUUO
>;IFN FTKLB
IFE FTKLB,<
	MOVEM TAC1,KLUPT+KLUUOW		;STORE MUUO WORD
	SETZM PFIOEF
	JRST 2,@KLUPT+KLCNTW		;SIMULATE CONCEALED NO TRAP MUUO
>;IFE FTKLB

PFIOU1:	MOVE TAC,TAC1			;COPY INSTR TO TAC (RH GETS EFF ADR OF XCT)
	JRST PFIOU2

PFIOU3:	SETZM PFIOEF
	DATAO KLPAG,[401000,,0]		;BACK TO AC BLOCK 1
	EXCH P,PAGPDL
	PUSH P,TAC
	JRST DOMPV2			;BACK WHERE WE CAME FROM

;ROUTINE TO COMPUTE INSTRUCTION IN MUUO STORING FORMAT.  ASSUMES TAC HAS USER
;ADDRESS OF THE INTRUCTION.  RETURNS RESULT IN TAC1
PFIFET:	HRLI TAC,(<MOVEI TAC1,@0>)	;MAKE A <MOVEI TAC1,@ADDRESS OF INSTR>
	XCTR XE,TAC			;RELOCATE ON @ AND XR
	XCTR XR,[HLL TAC1,(TAC)]	;GET OPCODE AND AC FIELD
	TLZ TAC1,37			;CLEAR @ AND XR BITS
	POPJ P,

PFPUB:
IFN FTKLB,<
	MOVE TAC,KLUPT+KLPFFG		;check PC flags
>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,KLUPT+KLPFPC		;check PC flags
>;IFE FTKLB
	TLNN TAC,USRMOD			;skip if user mode
	JRST PFPUBE			;FROM AN XCTR, SOMEONE HAS SET PCP OR PUBLIC
	MOVSI TAC,PCPUBL
	JRST DOMPV3

PFPUBE:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /Exec mode proprietary violation, check PCP and PUBLIC bits./
	JRST PFCOM

EPF:	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /EXPGFL/
	PUSHJ P,DISMES
	ASCIZ /Exec mode page failure /
PFCOM:	PUSHJ P,DISMES
	ASCIZ /
Page failure word = /
	MOVE TAC,KLUPT+KLPFW
	PUSHJ P,DISOHS
	PUSHJ P,DISMES
	ASCIZ /    Trap PC = /
	MOVE TAC,KLUPT+KLPFPC
	PUSHJ P,DISOHS
IFN FTKLB,<
	PUSHJ P,DISMES
	 ASCIZ/   PC flags = /
	HLRZ TAC,KLUPT+KLPFFG
	PUSHJ P,DISLOC		;print LH flags from RH
	PUSHJ P,DISMES
	 ASCIZ/,,x/
	MOVE TAC,KLUPT+KLPFPC	;make sure PC is in section 0
	TLNE TAC,-1		;skip if section 0
	JRST PFCOM2		;nonzero section, don't try to get instruction
	MOVE TAC,KLUPT+KLPFFG
>;IFN FTKLB
IFE FTKLB,<
	MOVE TAC,KLUPT+KLPFPC
>;IFE FTKLB
	TLNE TAC,USRMOD		;Make sure Exec PC
	JRST PFCOM2
	LDB TAC1,[POINT 9,KLUPT+KLPFPC,26] ;Get virtual page location of instruction
	SKIPN EXPGT(TAC1)	;Don't page fault now!
	JRST PFCOM2
	PUSH P,@KLUPT+KLPFPC	;Save losing instruction
	PUSHJ P,DISMES
	 ASCIZ/
Instr = /
	MOVE TAC,(P)
	PUSHJ P,DISOHS		;Print instruction
	LDB TAC,[POINT 4,(P),17] ;Get index AC
	JUMPE TAC,PFCOM1
	PUSHJ P,DISMES
	 ASCIZ/;  /
	PUSHJ P,DISLOC		;Print number of index AC
	LDB TEM,[POINT 4,(P),17] ;Get index AC back
	MOVEI TAC,-20(TEM)	;AC position from top of stack
	ADDI TAC,(P)		;Calculate stack address of saved value of index
	CAIN TEM,TAC		;If index is TAC, stack position is different
	SUBI TAC,TAC+1		;TAC was pushed before all ACs
	MOVE TAC,(TAC)		;Get original value of index AC
	PUSHJ P,DISMES
	 ASCIZ $/ $
	PUSHJ P,DISOHS
PFCOM1:	SUB P,[1,,1]
PFCOM2:	PUSHJ P,DISMES
	ASCIZ /
PI CONI = /
	CONI PI,TAC
	PUSHJ P,DISOHS
	PUSHJ P,DISMES
	ASCIZ /    P (in PAGPDL) = /
	MOVE TAC,PAGPDL
	PUSHJ P,DISOHS
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	POPACS
	POP P,TAC
	PUSHJ P,DDTCALL
PFXIT:	EXCH P,PAGPDL			;YOU PROBABLY SHOULDN'T CONTINUE...
IFN FTKLB,<
	XJRSTF KLUPT+KLPFFG	;restore PC and flags from double word
>;IFN FTKLB
IFE FTKLB,<
	JRST 2,@KLUPT+KLPFPC
>;IFE FTKLB

HPF:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /Hardware page fail/
	JRST PFCOM

PIPF:	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT /PIPGFL/
	PUSHJ P,DISMES
	ASCIZ /Page fail, PI in progress/
	JRST PFCOM
>;IFKL10

RECPFT:	CONI PI,PFLTPI			;SAVE PI
	SYSPIFF
	EXCH P,PAGPDL			;SWITCH BACK
	EXCH P,PFPDL			;GET SPECIAL PDL FOR THIS ROUTINE
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /Attempted recursive page fault, PI CONI=/]
	DISARG OHS,PFLTPI
	[ASCIZ /
PAGPDL=/]
	DISARG OHS,PAGPDL
	[ASCIZ /    Fault PC=/]
NOKL10,<DISARG OHS,PAGINT
	[ASCIZ /    TSW=/]
	DISARG OHS,PSB+TSW
>;NOKL10
IFKL10,<DISARG OHS,KLUPT+KLPFPC
IFN FTKLB,<
	[ASCIZ /    Flag word=/]
	DISARG OHS,KLUPT+KLPFFG
>;IFN FTKLB
	[ASCIZ /    PFW=/]
	DISARG OHS,KLUPT+KLPFW
>;IFKL10
	-1
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLUSH
IFE FTCCRMA,<
	PUSHJ P,WDDTCA
>;IFE FTCCRMA
IFN FTCCRMA,<
	PUSHJ P,FDDTCA		;Some people won't pay attention...
>;IFN FTCCRMA
	MOVE TAC,[-PAGPLN,,PAGPD-1]
	MOVEM TAC,PAGPDL		;FIX PAGPDL
	MOVE TAC,PFLTPI
	ANDI TAC,PION
	CONO PI,(TAC)			;PUT PIS BACK
	POPACS
	EXCH P,PFPDL
NOKL10,<JRST 2,@PAGINT
>;NOKL10
IFKL10,<
IFN FTKLB,<
	XJRSTF KLUPT+KLPFFG	;restore PC and flags from double word
>;IFN FTKLB
IFE FTKLB,<
	JRST 2,@KLUPT+KLPFPC
>;IFE FTKLB
>;IFKL10
;PFPAR KLPAR2

;KL10 AR/ARX PARITY ERROR PAGE FAULTS

IFKL10,<
PFPAR:	CONSZ PI,<<100000⊗-APRCHN>-1>≠77777	;SKIP IF WE CAN GET TO APR CHANNEL
	JRST KLPAR2
	SYSPIFF			;I DON'T CARE IF THEY'RE ALREADY OFF
	SETOM PFPARF			;TELL CH3 WHY WE'RE COMING
	MOVEI TAC,35
	DPB TAC,[POINT 5,KLUPT+KLPFW,5]	;CHANGE FAILURE TYPE SO ERRINT BEHAVES
	POP P,TAC
	EXCH P,PAGPDL
	CONO PI,4200+1⊗<7-APRCHN>	;INITIATE INTO CHANNEL 3 AND PION
	CONO PI,0			;WAIT UNTIL GET INTO CH3
	JRST 4,.

KLPAR2:	POP P,TAC
	EXCH P,PAGPDL
	EXCH P,ETRPDL
	PUSH P,TAC
	CONI PI,TAC
	SYSPIFF
	ANDI TAC,PION			;KEEP PION BIT
	EXCH TAC,(P)
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF NEW MESSAGE ON CTY
	 SIXBIT \AR/ARX\
	PUSHJ P,DISMES
	ASCIZ \AR/ARX PARITY ERROR FAULT -  PI IN PROGRESS CHANNELS 1-3
\
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	POPACS
	CONO PI,@(P)
	POP P,(P)
	EXCH P,ETRPDL
IFN FTKLB,<
	XJRSTF KLUPT+KLPFFG	;restore PC and flags from double word
>;IFN FTKLB
IFE FTKLB,<
	JRST 2,@KLUPT+KLPFPC
>;IFE FTKLB
>;IFKL10
;PAGSET PAGSEN PAGSNL PAGJM0 PAGJ0A

;CALL PAGSET WITH JOB NUMBER IN J.  SET MAP AND PAGREG UP TO THAT JOB.
;CALL PAGSEN WITH NEW PAGREG VALUE IN TAC, RETURNS OLD VALUE IN TAC.

PAGSET:	JUMPE J,PAGSNL
	SKIPN TAC,JBTMAP(J)
	JRST PAGJM0		;ERROR- JBTMAP IS ZERO
	HRLZ TAC,TAC		;PAGE NUMBER OF PAGE MAP INTO LEFT HALF.
	DPB J,[PGJBYP,,TAC]	;STORE JOB NUMBER IN PAGREG JOB FIELD (IN TAC)
;ENTER HERE FROM POPMAP TO RESTORE MAP
PAGSEN:	PUSH P,TAC1
	MOVE TAC1,TAC		;TAC1 WILL BE STORED IN PAGREG
	MOVE TAC,PAGREG		;TAC←OLD PAGREG
NOKL10,<SYSPIFF		;KEEP PAGREG CONSISTENT WITH THE MAP
	MOVEM TAC1,PAGREG
	HRRI TAC1,PSB⊗-9	;Insert MBR, flush job number
	MOVEM TAC1,BBN71	;STORE IN FIRST WORD FOR PAGER
	MOVSI TAC1,700000	;BITS FOR AGER
	MOVEM TAC1,BBN72	;STORE IN SECOND WORD FOR PAGER
IFE FTF2,<
	CONO PAG,0		;MAKE PAGER RELOAD MAIN REGISTERS FROM BBN71/72
	CONO PAG,3		;CLEAR ARS MAPPING USER MODE PAGES
	CONO PAG,7		;TURN ON MAPPING FOR USER AND ALL EXEC ADDRESSES
	DATAO APR,[776000,,0]	;SET PROTECTION TO ∞,,0
>;IFE FTF2
IFN FTF2,<
  printx Try avoiding CONO PAG,... if PAGREG isn't really changed here
;;	CAME TAC,PAGREG		;Is this an expensive no-op?
;;	  JRST PGRGOK		;  Yes, very expensive.  Avoid it.
IFN 0,<		;Formerly IFN FTLLL.  LLL has new microcode as of 11/84.  - JJW
PRINTX If CONO PAG,10 worked on LLL microcode, then this could speeded up.
	CONO PAG,0		;MAKE PAGER RELOAD MAIN REGISTERS FROM BBN71/72
	CONO PAG,3		;CLEAR ARS MAPPING USER MODE PAGES
>;IFN 0
IFN 1,<		;Formerly IFN FTCCRMA
	CONO PAG,10		;RELOAD MAIN REGISTERS FROM BBN71/BBN72, BUT ONLY
				;  CLEAR ARS MAPPING USER MODE PAGES
>;IFN 1
	CONO PAG,7		;TURN ON MAPPING FOR USER AND ALL EXEC ADDRESSES
>;IFN FTF2
	SYSPIN
>;NOKL10
IFKL10,<
IFE FTKLB,<
	PUSH P,TAC		;SAVE OLD PAGREG ON STACK
	ADJSP P,6
	MOVEI TAC,-5(P)
	HRLI TAC,J
	BLT TAC,(P)		;SAVE J,DAT,DDB,PROG,TEM,DSER
	MOVEI J,EXPGT⊗-9	;MBR
	HLRE DAT,TAC1
IFN FTDMDP,<	;Only for demand paging, which can't possibly work
	LDB TAC,[PGJBYP,,TAC1]	;JOB NUMBER
	LSH TAC,2
IFN PROG-DDB-1,<.FATAL ACs DDB and PROG are not contiguous as required here.>
	DMOVE DDB,WRKSET(TAC)
IFN DSER-TEM-1,<.FATAL ACs TEM and DSER are not contiguous as required here.>
	DMOVE TEM,WRKSET+2(TAC)	;LOAD THE WORKING SET
>;IFN FTDMDP
	SYSPIFF
	MOVEM TAC1,PAGREG	;STORE NEW PAGREG
	BLKI KLPAG,J		;SET EXPGT AND USPGT POINTERS IN AC BLOCK 6
	CONO KLPAG,@KLPCON	;FLUSH OLD PAGE MAP CACHE ENTRIES
	SYSPIN
IFN FTDMDP,<
	LDB TAC,[PGJBYT+P,,-6]	;JOB # OF PREVIOUS JOB FROM TAC ON STACK
	LSH TAC,2
	DMOVEM DDB,WRKSET(TAC)
	DMOVEM TEM,WRKSET+2(TAC)	;STORE OLD WORKING SET
>;IFN FTDMDP
	MOVSI DSER,-5(P)
	HRRI DSER,J
	BLT DSER,DSER
	ADJSP P,-6
	POP P,TAC		;GET BACK OLD PAGREG
>;IFE FTKLB
IFN FTKLB,<
	SYSPIFF
	MOVEM TAC1,PAGREG	;STORE NEW PAGREG
	TLZ TAC1,760000		;clear extra bits not included in page number
	HRRI TAC1,PWRTC		;make writeable, cacheable section 0
	MOVSM TAC1,KLUPT+KLUSEC	;store page table ptr as user section 0 ptr
	CONO KLPAG,@KLPCON	;FLUSH OLD PAGE MAP CACHE ENTRIES
	SYSPIN
>;IFN FTKLB
>;IFKL10
	POP P,TAC1
	POPJ P,

PAGSNL:
IFKL10,<MOVSI TAC,400000	;SIGN BIT MEANS THERE IS NO USER PAGE TABLE
>;IFKL10
NOKL10,<MOVE TAC,[BYTE (4)0 (3)7 (11)PSB⊗-9]	;ALR=16K
>;NOKL10
	JRST PAGSEN	

PAGJM0:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISJOB
	PUSHJ P,DISMES
	ASCIZ / JBTMAP IS ZERO AT PAGSET.  FATAL.
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,DDTCALL
	HALT .

PAGJ0A:	JRST 4,.
;ADNEMP ADCEMP ADPEMP ADDEVP ADDEMP ADDEMX ADDEM0 ADDEM1 DELEMP GETEMP
	INTERN	ADDEMP,DELEMP,GETEMP

;ADD A PHYSICAL PAGE TO THE EXEC MAP
;CALL:	MOVE TAC,<PHYSICAL PAGE NUMBER>
;	MOVE TAC1,<OFFSET FROM EXPGT OF VIRTUAL PAGE'S PAGE TABLE ENTRY>
;	PUSHJ P,ADDEMP		;(OR ADDEVP,ADPEMP,ADCEMP) CLOBBERS ONLY TAC
;	<RETURN>
;IF ERRORS OCCUR, YOU WIND UP IN DDT
;
;IN THE IFKL10 SYSTEM, TAC1 SIMPLY HOLDS THE VIRTUAL PAGE NUMBER.
;IN THE NOKL10 SYSTEM, HOWEVER, IF THE PAGE NUMBER IS 600 OR GREATER,
;THEN TAC1 HOLDS THE PAGE NUMBER + PSB-EXPGT, SO THAT EXPGT(TAC1) IS
;THE ADDRESS OF THE PAGE'S ENTRY IN THE NOKL10 PAGE TABLE.  IF THE
;PAGE NUMBER IS LESS THAN 600, THEN TAC1 SIMPLY HOLD THE VIRTUAL PAGE NUMBER.

IFN FTNCU,<
;SAME AS ADDEMP EXCEPT THE PAGE CAN'T BE WRITTEN
ADNEMP:	JUMPL TAC,ADDEM1	;ERROR IF PHYSICAL PAGE NUMBER IS NEGATIVE
	CAIL TAC,PHYMEM*2	;SKIP IF PHYSICAL PAGE IS OK
	JRST ADDEM1
	HRLI TAC,PREAD!P.KEEP	;READ, EXECUTE AND ACCESS BITS
	JRST ADDEMX
>;IFN FTNCU

IFN FTCSHD,<
;SAME AS ADDEMP EXCEPT THE PAGE GETS WRITE ENABLED BUT CACHED
ADCEMP:	JUMPL TAC,ADDEM1	;ERROR IF PHYSICAL PAGE NUMBER IS NEGATIVE
	CAIL TAC,PHYMEM*2	;SKIP IF PHYSICAL PAGE IS OK
	JRST ADDEM1
	HRLI TAC,PWRTC!P.KEEP	;READ, WRITE, EXECUTE AND CACHE BITS
	JRST ADDEMX
>;IFN FTCSHD

;SAME AS ADDEMP EXCEPT THE PAGE GETS WRITE PROTECTED AND CACHED
ADPEMP:	JUMPL TAC,ADDEM1	;ERROR IF PHYSICAL PAGE NUMBER IS NEGATIVE
	CAIL TAC,PHYMEM*2	;SKIP IF PHYSICAL PAGE IS OK
	JRST ADDEM1
NOKL10,<HRLI TAC,PREAD >;NOKL10	;READ, EXECUTE AND ACCESS BITS
IFKL10,<HRLI TAC,PREADC!P.KEEP >;IFKL10;READ, EXECUTE AND CACHE BITS
	JRST ADDEMX

;USE THE SAME PHYSICAL PAGE AS VIRTUAL PAGE
↑ADDEVP:
IFKL10,<MOVE TAC,TAC1
>;IFKL10
NOKL10,<CAIL TAC1,PSB-EXPGT+600
	CAILE TAC1,PSB-EXPGT+777
	SKIPA TAC,TAC1		;NOT A HIGH VIRTUAL PAGE, PHYSICAL PAGE = INDEX
	MOVEI TAC,EXPGT-PSB(TAC1) ;HIGH VIRTUAL PAGE (600 UP), GET PHYS PAGE NBR
>;NOKL10
↑ADDEMP:JUMPL TAC,ADDEM1	;ERROR IF PHYSICAL PAGE NUMBER IS NEGATIVE
	CAIL TAC,PHYMEM*2	;SKIP IF PHYSICAL PAGE IS OK
	JRST ADDEM1
	HRLI TAC,PWRT!P.KEEP	;READ-WRITE-EXECUTE AND ACCESS PERMISSION
ADDEMX:	JUMPL TAC1,ADDEM1	;JUMP IF PAGE NUMBER IS NEGATIVE
NOKL10,<CAIGE TAC1,600		;THIS PAGE IN PSB?
	JRST .+4		;NO, ALL OK
	CAIL TAC1,PSB-EXPGT+600
	CAILE TAC1,PSB-EXPGT+777
	JRST ADDEM1		;ILLEGAL VIRTUAL PAGE ARG
>;NOKL10
IFKL10,<CAILE TAC1,777		;SKIP IF PAGE NUMBER IS REASONABLE
	JRST ADDEM1		;ERROR - VIRTUAL PAGE NUMBER OUT OF BOUNDS
>;IFKL10
	PUSH P,AC1
	MOVEI AC1,EXPGT(TAC1)	;ADDRESS OF THE EXPGT ENTRY FOR THIS PAGE.
REPEAT 0,<
NOKL10,<CAIL TAC1,600		;SKIP IF VIRTUAL PAGE IS IN THE EXPGT
	ADDI AC1,PSB-EXPGT	;VIRTUAL PAGE IS IN THE PSB
>;NOKL10
>;REPEAT 0
	SKIPE (AC1)		;SKIP IF THERE'S NO OLD ENTRY.
	CAMN TAC,(AC1)		;THERE IS AN OLD ENTRY.  SKIP IF DIFFERENT FROM NEW
	JRST ADDEM0		;WINNING.
	PUSHACS	
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /CONFLICTING ASSIGNMENT AT ADDEMP
/
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,WDDTCAL		;IF YOU CONTINUE IT CLOBBERS IT ANYWAY
ADDEM0:	MOVEM TAC,(AC1)
	POP P,AC1
	POPJ P,

ADDEM1:	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	 [ASCIZ /FATAL - Illegal arguments at ADDEMP, ADCEMP, ADPEMP or DELEMP
TAC = /]
	 DISARG OCH,<TAC-20(P)>
	 [ASCIZ/   TAC1 = /]
	 DISARG OCH,<TAC1-20(P)>
	 [ASCIZ/
Callers = /]
	 DISARG LOC,<-20(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-21(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-22(P)>
	 [ASCIZ /, /]
	 DISARG LOC,<-23(P)>
	 -1
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	POPACS
	HALT .+1
	PUSHJ P,DDTCAL
	HALT .		;FATAL

;DELETE A VIRTUAL PAGE FROM THE EXEC MAP
;CALL:	MOVE TAC1,<OFFSET FROM EXPGT OF VIRTUAL PAGE'S PAGE TABLE ENTRY>
;	PUSHJ P,DELEMP
;	<RETURN>
;IF ERRORS OCCUR, YOU WIND UP IN DDT
;
;THE ARGUMENT IN TAC1 IS THE SAME PAGE INDEX AS USED FOR ADDEMP.
;SEE THE DESCRIPTION OF ADDEMP'S VIRTUAL PAGE ARGUMENT ABOVE.

↑DELEMP:JUMPL TAC1,ADDEM1	;ERROR IF PAGE NUMBER IS NEGATIVE
NOKL10,<CAIGE TAC1,600		;THIS PAGE IN PSB?
	JRST .+4		;YES, ALL OK
	CAIL TAC1,PSB-EXPGT+600
	CAILE TAC1,PSB-EXPGT+777
	JRST ADDEM1		;ILLEGAL VIRTUAL PAGE ARG
>;NOKL10
IFKL10,<CAILE TAC1,777		;SKIP IF PAGE NUMBER IS REASONABLE
	JRST ADDEM1		;ERROR - VIRTUAL PAGE NUMBER OUT OF BOUNDS
>;IFKL10
	PUSH P,AC1
	MOVEI AC1,EXPGT(TAC1)	;ADDRESS OF THE EXPGT ENTRY FOR THIS PAGE.
	SETZM (AC1)		;ZERO THE ENTRY IN THE EXPGT
NOKL10,<
IFE FTF2,<
	CONO PAG,1		;GRONK PAGER TO MAKE IT FORGET OLD EXEC ARS
>;IFE FTF2
IFN FTF2,<
	MOVEI AC1,(TAC1)	;Get page number
	CAIL AC1,600		;Was address in PSB?
	  SUBI AC1,PSB-EXPGT	;  Yes, fixup this fudge
	LSH AC1,9		;Convert page number to virtual memory address
	DATAO PAG,(AC1)		;Clear physical map
>;IFN FTF2
>;NOKL10
IFKL10,<MOVEI AC1,(TAC1)
	LSH AC1,9		;CONVERT VIRTUAL PAGE TO ADDRESS
	BLKO KLPAG,(AC1)	;invalidate page table mapping entry for given page
>;IFKL10
	POP P,AC1
	POPJ P,

;return current map entry in TAC (includes access bits)
;   for exec page specified in TAC1
↑GETEMP:JUMPL TAC1,GETEM0	;JUMP IF PAGE NUMBER IS NEGATIVE
NOKL10,<CAIGE TAC1,600		;THIS PAGE IN PSB?
	JRST .+4		;YES, ALL OK
	CAIL TAC1,PSB-EXPGT+600
	CAILE TAC1,PSB-EXPGT+777
	JRST GETEM0		;ILLEGAL VIRTUAL PAGE ARG
>;NOKL10
IFKL10,<CAILE TAC1,777		;SKIP IF PAGE NUMBER IS REASONABLE
	JRST GETEM0		;ERROR - VIRTUAL PAGE NUMBER OUT OF BOUNDS
>;IFKL10
	SKIPA TAC,EXPGT(TAC1)	;Get the entry
GETEM0:	MOVEI TAC,0
	POPJ P,
;PAGINI PGINI1 SECINI

;INITIALIZE THE EXEC PAGE TABLE, PSB, AND WHATNOT

↑PAGINI:SETZM EXPGT
	MOVE TAC,[EXPGT,,EXPGT+1]
	BLT TAC,EXPGT+777
NOKL10,<
	SETZM PSB+600		;CLEAR MAP ENTRIES FOR LAST 64K
	MOVE TAC,[PSB+600,,PSB+601]
	BLT TAC,PSB+777
>;NOKL10
	MOVEI TAC1,0		;INCLUDE LOW EXEC IN PHYSICAL MAP
	MOVEI AC3,0		;COUNT ADDRESSES
PGINI1:	MOVEI AC1,ADPEMP	;ASSUME WRITE PROTECTED AND CACHED
	CAIL AC3,CHKBEG
	CAIL AC3,CHKEND+1
	MOVEI AC1,ADDEMP	;NOT IN CHECKSUM, WRITE ENABLED AND NOT CACHED
IFN FTNCU,<
	CAIL AC3,NCUBG1&777000	;IS THIS A SPECIAL PAGE WE'RE NOT CACHING?
	CAIL AC3,NCUEN1
	CAIA
	MOVEI AC1,ADNEMP	;YES, MAKE IT WRITE PROTECTED AND NOT CACHED
	CAIL AC3,NCUBG2&777000	;IS THIS A SPECIAL PAGE WE'RE NOT CACHING?
	CAIL AC3,NCUEN2
	CAIA
	MOVEI AC1,ADNEMP	;YES, MAKE IT WRITE PROTECTED AND NOT CACHED
	CAIL AC3,NCUBG3&777000	;IS THIS A SPECIAL PAGE WE'RE NOT CACHING?
	CAIL AC3,NCUEN3
	CAIA
	MOVEI AC1,ADNEMP	;YES, MAKE IT WRITE PROTECTED AND NOT CACHED
>;IFN FTNCU
IFN FTCSHD,<
IFE FTSEPONCE,<
IFN FTIP,<
	CAIG AC3,BLTBEG!777	;IP/TCP code and data (writeable) is above ONCE
	CAIGE AC3,CACEND
	MOVEI AC1,ADCEMP	;IP/TCP or DATA BELOW CACEND--WRITEABLE and CACHED
>;IFN FTIP
>;IFE FTSEPONCE
IFN FTSEPONCE,<
;IP/TCP code is between TAIL and DDT (or ONCE if no DDT).
;DDT and ONCE are uncached.
IFN FTDDT,<
	CAIGE AC3,DDTBEG&777000	;skip if this page includes DDT or ONCE--don't cache
	CAIG AC3,CHKEND		;skip if page is entirely within IP/TCP
	CAIGE AC3,CACEND
	MOVEI AC1,ADCEMP	;IP/TCP or DATA BELOW CACEND--WRITEABLE and CACHED
>;IFN FTDDT
IFE FTDDT,<
	CAIGE AC3,BLTBEG&777000	;skip if page includes ONCE (no DDT)--don't cache
	CAIG AC3,CHKEND		;skip if page is entirely within IP/TCP
	CAIGE AC3,CACEND
	MOVEI AC1,ADCEMP	;IP/TCP or DATA BELOW CACEND--WRITEABLE and CACHED
>;IFE FTDDT
>;IFN FTSEPONCE
>;IFN FTCSHD
	MOVEI TAC,(TAC1)	;STRAIGHT THROUGH
NOKL10,<PUSH P,TAC1
	CAIL TAC1,600		;IS THIS PART OF MAP IN PSB?
	ADDI TAC1,PSB-EXPGT	;YES, ADJUST VIRTUAL PAGE ARG, MAKING PAGE INDEX
	PUSHJ P,(AC1)		;CALL ROUTINE TO ADD PAGE TO MAP
	POP P,TAC1		;RESTORE REAL VIRTUAL PAGE NUMBER
>;NOKL10
IFKL10,<
	PUSHJ P,(AC1)		;ADD PHYSICAL PAGE TO MAP (STRAIGHT THROUGH)
>;IFKL10
	ADDI AC3,1000
	CAMGE AC3,SYSTOP	;DONE YET?
	AOJA TAC1,PGINI1	;NO.  LOOP.

;(NOTE - FREE STORAGE SYSTEM IS RESPONSIBLE FOR IT'S OWN MAP SETUP)

IFKL10,<MOVSI TAC,400000	;SIGN BIT MEANS THERE IS NO USER PAGE TABLE
>;IFKL10
NOKL10,<MOVE TAC,[BYTE (4)0 (3)7 (11)PSB⊗-9]	;ALR=16K
>;NOKL10
	MOVEM TAC,PAGREG	;INITIALIZE PAGREG SO APRMAP WILL WORK (AND SO THAT
				; THE FIRST CALL WON'T DO AN ACTOSH)
IFN FTKLB,<
;Now set up the section pointer for exec section 0 and clear other pointers
;I suppose this could be in ONCE....
↑SECINI:MOVE TAC,[PWRTC,,EXPGT⊗-9] ;set writeable, cacheable section 0
	MOVEM TAC,KLEPT+KLESEC	;store exec section 0 pointer
	SETZM KLEPT+KLESEC+1	;zero all other exec section pointers
	MOVE TAC,[KLEPT+KLESEC+1,,KLEPT+KLESEC+2]
	BLT TAC,KLEPT+KLESEC+NKLSEC-1 ;zero remaining exec section pointers
	SETZM KLUPT+KLUSEC+1	;zero all user section pointers except section 0
	MOVE TAC,[KLUPT+KLUSEC+1,,KLUPT+KLUSEC+2]
	BLT TAC,KLUPT+KLUSEC+NKLSEC-1 ;zero remaining section pointers
>;IFN FTKLB
	POPJ P,
;NPSM NPSM MAPSET ACTOSH SHTOTR SHTOAC PSHMAP PSHMP2 POPMAP POPBU1 POPBUG APRMAP APMAPX APMAP2 APMA22 APMAPS APMAPZ APMAPY EBXPUT EBXGET

IFN FTKLB,<
↑NPSM←←5	;number of places on the stack that PSHMAP adds.
>;IFN FTKLB
IFE FTKLB,<
↑NPSM←←4	;number of places on the stack that PSHMAP adds.
>;IFE FTKLB

;CALL:	MOVE J,<JOB NUMBER>		;CLOBBERS NO ACS
;	PUSHJ P,MAPSET
;	<RETURN HERE WITH OLD MAP PUSHED, AND MAP SETUP FOR NEW JOB>
;
;ONCE YOU'VE CALLED MAPSET, THE NEXT POPJ P, AT THE STACK LEVEL RETURNED
;BY MAPSET, WILL RESTORE THE STATE OF THE MAP, AND POPJ ONE LEVEL ABOVE
;WHERE YOU WERE WHEN YOU CALLED MAPSET.  I.E., DO A POPJ TO RESTORE THE
;MAP AND RETURN TO WHOEVER CALLED YOU (WHERE YOU=THE CALLER OF MAPSET)
;ALSO, JRST CPOPJ1 FROM THE CALLER OF MAPSET WILL WORK RIGHT.

↑MAPSET:PUSHJ P,PSHMAP			;SAVE STATE OF MAP
	AOS AMC13			;COUNT APRMAP COUNTER
	PUSHJ P,APRMAP			;NOW SETUP THE MAP
	PUSHJ P,@-NPSM(P)		;RETURN TO CALLER OF MAPSET, WHO POPJS 
	SOS -NPSM-1(P)			;(AVOID SKIP RETURN)   BACK HERE TO RESTORE
	PUSHJ P,POPMAP			;POP MAP AND AC CONTEXT BACK
	SUB P,[1,,1]			;FLUSH ORIGINAL CALL TO MAPSET
	JRST CPOPJ1			;RETURN TO CALLER OF MAPSET'S CALLER.

IFKL10,<
;COPY AC BLOCK 1 TO SHADOW MEMORY OF JOB WHOSE MAP IS CURRENTLY SET UP ONLY
;IF NOT PI IN PROGRESS ON CHANNELS 3 THROUGH 6
ACTOSH:	SKIPL PAGREG			;SKIP IF NO USER MAP (NULL JOB)
	CONSZ PI,1B27*(2⊗(7-APRCHN)-2)	;In progress on APRCHN thru CHN 6?
	POPJ P,				;YES, WON'T TRY TO REFERENCE ACS
	PUSH P,TAC
	HLRZ TAC,PAGREG
	TRNE TAC,SAC2SH			;SKIP UNLESS SUPRESS ACTOSH (SET BY SPWSER)
	JRST TPOPJ
	PUSH P,TAC1
IFN FTMPP2,<
	MOVEI TAC1,MAPEXP		;GOTTA GET IT INTO EXEC MAP FIRST
	PUSHJ P,ADDEMP
	LDB TAC,[POINT 13,MAPEXP⊗9,35]	;ALWAYS SAME EXEC VIRTUAL ADDRESS
	PUSHJ P,DELEMP
>;IFN FTMPP2
IFE FTMPP2,<
	LSH TAC,9
	LDB TAC,[POINT 13,(TAC),35]	;DO IT THIS WAY, MAP DOESN'T REALLY WORK
>;IFE FTMPP2
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP			;MAKE EXEC PAGE MAPEXP POINT AT SHADOW
	MOVEI TAC,MAPEXP⊗9
	XCTR XBLTR,[BLT TAC,MAPEXP⊗9+17]	;COPY AC BLK 1 TO HIS SHADOW ACS
	PUSHJ P,DELEMP			;FLUSH THAT PAGE
	POP P,TAC1
	JRST TPOPJ

IFN FTSAC2,<	;THIS IS MRC'S DUBIOUS FIX.  I DON'T THINK IT IS APPROPRIATE.--ME
SHTOTR:
jfcl;	PUSHJ P,BUGTRP		;MAKE SOMEONE CONTINUE SYSTEM, SO WE SEE DATA
;;;	AOS SAC2AC#		;COUNT THESE OCCURRENCES
	JRST TPOPJ		;GET OUT OF HERE, I GUESS
>;IFN FTSAC2

;COPY SHADOW MEMORY OF JOB WHOSE MAP IS CURRENTLY SET UP TO AC BLOCK 1 ONLY
;IF NOT PI IN PROGRESS ON CHANNELS 3 THROUGH 6
SHTOAC:	SKIPL PAGREG			;SKIP IF NO USER MAP (NULL JOB)
	CONSZ PI,1B27*(2⊗(7-APRCHN)-2)	;In progress on APRCHN thru CHN 6?
	POPJ P,				;YES.
	PUSH P,TAC
IFN FTSAC2,<	;THIS IS MRC'S DUBIOUS FIX.  I DON'T THINK IT IS APPROPRIATE.--ME
	HLRZ TAC,PAGREG
	TRNE TAC,SAC2SH			;SPW SAY NO SHADOW AC COPY?
	 JRST SHTOTR			;YES, HOW COME?
>;IFN FTSAC2
	PUSH P,TAC1
IFN FTMPP2,<
	MOVEI TAC1,MAPEXP		;GOTTA GET IT INTO EXEC MAP FIRST
	PUSHJ P,ADDEMP
	LDB TAC,[POINT 13,MAPEXP⊗9,35]	;ALWAYS SAME EXEC VIRTUAL ADDRESS
	PUSHJ P,DELEMP
>;IFN FTMPP2
IFE FTMPP2,<
	LSH TAC,9
	LDB TAC,[POINT 13,(TAC),35]	;DO IT THIS WAY, MAP DOESN'T REALLY WORK
>;IFE FTMPP2
	MOVEI TAC1,MAPEXP
	PUSHJ P,ADDEMP			;MAKE EXEC PAGE MAPEXP POINT AT SHADOW
	MOVSI TAC,MAPEXP⊗9
	XCTR XBLTW,[BLT TAC,17]		;COPY NEW SHADOW ACS TO AC BLOCK 1
	PUSHJ P,DELEMP			;FLUSH THAT PAGE
	POP P,TAC1
	JRST TPOPJ
>;IFKL10

;Save the state of the map by storing map info on the stack.
↑PSHMAP:ADD P,[NPSM-1,,NPSM-1]
	PUSH P,-NPSM+1(P)	;SAVE RETURN WORD FURTHER UP THE STACK
	PUSH P,TAC
	MOVEI TAC,-NPSM-2(P)	;POINTER TO ONE BELOW FIRST STACK ENTRY
NOKL10,<PUSH TAC,PAGREG
	PUSH TAC,BBN72		;Never actually used, just keep stack right
	PUSH TAC,PSB+TSW
	PUSH TAC,PAGINT
>;NOKL10
IFKL10,<PUSH TAC,PAGREG		;saved data 0
	PUSH P,TAC1
	DATAI KLPAG,TAC1
	TLZ TAC1,300000
	TLO TAC1,400000
	PUSH TAC,TAC1		;saved data 1
	POP P,TAC1
	PUSH TAC,KLUPT+KLPFW	;saved data 2
	PUSH TAC,KLUPT+KLPFPC	;saved data 3
IFN FTKLB,<
	PUSH TAC,KLUPT+KLPFFG	;saved data 4 is fault PC's flags too
>;IFN FTKLB
>;IFKL10
PSHMP2:	POP P,TAC
	POPJ P,

;Restore state of the map saved by PSHMAP, from the top of the stack.
↑POPMAP:
IFKL10,<PUSHJ P,ACTOSH		;COPY AC BLOCK 1 TO SHADOW IF NOT PI 3-6
>;IFKL10
	EXCH TAC,-NPSM+1(P)	;SAVE TAC ON STACK, GET BACK saved data 1
NOKL10,<
;;For the KA system, we don't need (nor save!) the old "PAGRG1" since
;;BBN72 is always set up to the same constant value.  But the position
;;kept on the stack so the KL and KA systems have the same stack length.
;;	MOVEM TAC,BBN72		;BBN72 is always set up as a constant
	POP P,TAC		;GET RETURN ADDRESS
	EXCH TAC,-NPSM+1(P)	;SAVE AT BOTTOM OF STACK, GET PAGREG
	POP P,PAGINT
	POP P,PSB+TSW
	PUSHJ P,PAGSEN		;SET UP MAP TO PAGREG THAT'S IN TAC
>;NOKL10
IFKL10,<PUSH P,TAC1
	DATAI KLPAG,TAC1	;GET CURRENT AC CONTEXT
	XOR TAC1,TAC		;COMPARE WITH NEW
	TLNE TAC1,7000		;SKIP IF NOT CHANGING CURRENT CONTEXT
	JRST POPBUG		;HOW DO YOU EXPECT TO GET BACK?
	POP P,TAC1
	DATAO KLPAG,TAC
POPBU1:	POP P,TAC		;GET RETURN ADDRESS
	EXCH TAC,-NPSM+1(P)	;SAVE AT BOTTOM OF STACK, TAC←PAGREG (saved data 0)
IFN FTKLB,<
	POP P,KLUPT+KLPFFG	;saved data 4 is fault PC's flags too
>;IFN FTKLB
	POP P,KLUPT+KLPFPC	;saved data 3
	POP P,KLUPT+KLPFW	;saved data 2
	PUSHJ P,PAGSEN		;SET UP MAP TO PAGREG THAT'S IN TAC,SAVE PREV IN TAC
	PUSHJ P,SHTOAC		;COPY SHADOW TO AC BLOCK 1 IF NOT PI 3-6
>;IFKL10
	JRST TPOPJ

IFKL10,<
POPBUG:	POP P,TAC1
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /ATTEMPTING TO CHANGE CURRENT AC CONTEXT AT POPMAP.
PRESENT = /
	DATAI KLPAG,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /   STACKED = /
	MOVE TAC,-17+TAC(P)
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	POPACS
	PUSHJ P,DISFLU
	PUSHJ P,WDDTCAL
	JRST POPBU1
>;IFKL10

↑APRMAP:PUSH P,TAC
APMAPX:	MTRON (MTRMAP)
IFKL10,<JSP TAC,.+1
	TLO TAC,PCU			;ALWAYS TURN ON PCU FOR NOW
	HRRI TAC,APMAP2
	JRST 2,@TAC
>;IFKL10
APMAP2:
;Next N lines are the questionable already-set-up code
	LDB TAC,PAGJOB			;GET JOB NUMBER CURRENTLY SET UP
	CAMN TAC,J
	JRST APMAPY			;ALREADY SET UP, AVOID WORK
APMA22:
;End of already-set-up code.
IFKL10,<PUSHJ P,ACTOSH			;COPY AC BLK 1 TO SHADOW IF NOT PI 3-6
	CONSO PI,1B27*(2⊗(7-APRCHN)-2)	;USE WHATEVER ACS WE HAVE IF PI 3-6
	DATAO KLPAG,[400100,,0]		;SET CURRENT AC BLK TO ZERO, PREV TO 1
	PUSHJ P,EBXPUT			;SAVE OLD EBOX COUNTER
>;IFKL10
	PUSHJ P,PAGSET			;Do work of setting up new map
IFKL10,<PUSHJ P,EBXGET			;LOAD NEW EBOX COUNTER
	PUSHJ P,SHTOAC			;COPY SHADOW TO AC BLK 1 IF NOT PI 3-6
	JRST APMAPZ

;Here in ch7/uuo level with SAC2SH off, same job as last time.
;If this is first spacewar run, then must save user level ACs in shadow
;(If this were 2nd or later spw run, then SAC2SH would have been on.)
APMAPS:	SKIPE SPWUUF
	PUSHJ P,ACTOSH			;Store user level ACs before running SPW
>;IFKL10
APMAPZ:	POP P,TAC
	MTROFF (MTRMAP)
	POPJ P,

APMAPY:
IFKL10,<CONSZ PI,1B27*(2⊗(7-APRCHN)-2)	;Skip if not in progress APRCHN thru CHN 6
	JRST APMAPZ			;HIGH PI LVL
	MOVSI TAC,SAC2SH		;SPWSER BIT FOR INHIBIT ACTOSH
	TDNN TAC,PAGREG			;SKIP IF BIT SET
	JRST APMAPS			;BIT CLEAR
	ANDCAM TAC,PAGREG		;BIT SET.  FIRST CLEAR IT.
	DATAO KLPAG,[400100,,0]		;SET CURRENT AC BLK TO ZERO, PREV TO 1
	PUSHJ P,SHTOAC			;RELOAD USER'S USER-LVL ACS, NOT SPW ACS
>;IFKL10
	JRST APMAPZ			;(NO PIOFF NEEDED BECAUSE ONLY CH7/UUO HERE)

IFKL10,<
EBXPUT:
IFE FTMTRACT,<
	SKIPLE MTRBKG
>;IFE FTMTRACT
IFN FTMTRACT,<
	SKIPGE MTRBKG			;DON'T BOTHER IF WE CAN'T USE THE METER
>;IFN FTMTRACT
	CONSZ PI,1B27*(2⊗(7-APRCHN)-2)	;In progress on APRCHN thru CHN 6?
	POPJ P,				;YES, FORGET IT
	LDB TAC,PAGJOB			;GET JOB NUMBER FROM PAGREG
	LSH TAC,1			;SHIFT FOR MTRETIME
	PUSH P,AC1
	PUSH P,AC2
	CONO MTR,MTRENB!APRCHN		;DISABLE ACCOUNTING METERS
IFN FTMTRACT,<
	BLKO TIM,[0]			;STOP PERFORMANCE COUNTER
>;IFN FTMTRACT
	DATAI KLPAG,AC1			;GET CURRENT USER CONTEXT
	TRZ AC1,400000			;MAKE SURE WE STORE ACCOUNTING METERS
	DATAO KLPAG,AC1			;LEAVE UPT WHERE IT IS BUT STORE ACCT METERS
	DMOVE AC1,MTRETIME(TAC)		;GET CUMULATIVE EBOX TIME FOR THIS JOB
	DADD AC1,KLUPT+UPTEBX		;ADD DOUBLE WORD EBOX COUNTER
	DMOVEM AC1,MTRETIME(TAC)	;STORE FOR THIS JOB
IFN FTMTRACT,<
	BLKI TIM,AC1			;GET PERFORMANCE COUNTER
	DADD AC1,MTRMTIME(TAC)
	DMOVEM AC1,MTRMTIME(TAC)
	DADD AC1,MTRETIME(TAC)
	DMOVEM AC1,MTRTTIME(TAC)	;STORE FOR THIS JOB
>;IFN FTMTRACT
	POP P,AC2
	POP P,AC1
	POPJ P,

EBXGET:
IFE FTMTRACT,<
	SKIPLE MTRBKG
>;IFE FTMTRACT
IFN FTMTRACT,<
	SKIPGE MTRBKG			;DON'T BOTHER IF WE CAN'T USE THE METER
>;IFN FTMTRACT
	CONSZ PI,1B27*(2⊗(7-APRCHN)-2)	;In progress on APRCHN thru CHN 6?
	POPJ P,				;YES, FORGET IT
	SETZM KLUPT+UPTEBX
	SETZM KLUPT+UPTEBX+1
IFN FTMTRACT,<
	BLKO TIM,[40]			;CLEAR THE PERFORMANCE COUNTER
	SETZM KLEPT+EPTPRF
	SETZM KLEPT+EPTPRF+1
	BLKO TIM,[001534,,777400]    ;COUNT EBOX TIME WAITING FOR MBOX IN USER MODE
>;IFN FTMTRACT
	CONO MTR,MTRENB!MTACEN!APRCHN	;RE-ENABLE ACCOUNTING METERS
	POPJ P,
>;IFKL10
