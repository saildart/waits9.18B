COMMENT ⊗   VALID 00009 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	LPTNEW LPTSTR LPTTBP LPTALT LPTCLR LPTDON LPTBSY LPTERR LPTLOV LPTCHB A B C D LPTNCC DELBIT SUPRFF LPTEN1 LPTDNG LPTERF LPTEN2 LPTCPL
C00007 00003	LPTDSP LPTINI LPTI.1 LPTBI LPTCLS LPTCL1 LPTINZ LPTREL
C00010 00004	LPTIOW LPTOUT LPTSET LPTSE2 LPTO3 LPTO3A LPTO1
C00015 00005	LPTHNG LPTHN UNHANG LPTHN1 LPTCLT
C00017 00006	LPTBF LPTBF1 LPTBF2 LPTBF3 LPTDB LPTDB1 LPTDL1 LPTDL0 LPTDEL LPT20T LPTD13 LPTDTF LPTD14 LPTD21 LPTD22 LPTCAR LPTCA2 LPTD12 LPT134 LPTDL2 LPTDL3 LPTD11 LPTD15 LPTICR LPTCN2 LPTCNX LPTCNC LPTBF LPTBFX LPTDB LPTBFY
C00030 00007	LPTCTB -- CHARACTER CONVERSION TABLE (SAIL)
C00033 00008	LPTCTB -- CHARACTER CONVERSION TABLE (CCRMA)
C00036 00009	LPTINT LPTIN2 LPTCF1 LPTXIT LPTIN1 LPMASK LPTCRF LPTCFX LPTCFF LPTOF LPTOF0 LPTOF1 LPTERH LPTLOI LPTLO1 LPTLO2 LPTLO3 LPTLO4 LPTBTB
C00046 ENDMK
C⊗;
;LPTNEW LPTSTR LPTTBP LPTALT LPTCLR LPTDON LPTBSY LPTERR LPTLOV LPTCHB A B C D LPTNCC DELBIT SUPRFF LPTEN1 LPTDNG LPTERF LPTEN2 LPTCPL

IFN LPTNUM,<	;Whole file

BEGIN LPTSER ↔ SUBTTL LINE PRINTER SERVICE ROUTINE
; NEW LINE PRINTER SERVICE ROUTINES - JAM 25 SEPT 68
; NEVER SETS IOACT BIT IN IOS
; DOES CHARACTER CONVERSION EXCEPT WHEN 100 BIT IN RH OF IOS IS ON
; FEATURES INTERNAL BUFFERING
; USERS BUFFERS ARE NOT ENTIRELY EMPTIED UNTIL (S)HE DOES THE 'CLOSE' UUO

; LPT PARAMETER ASSIGNMENTS
IFE FTF2,<
LPTNEW←←1	;SET FOR NEW STYLE LPT INTERFACE (REG 10/10/74)
IFNDEF FTPRNX,<	FTPRNX←←0 >	;Not a Printronix
>;IFE FTF2

IFN FTF2,<
LPTNEW←←0	;F2 uses old style
IFNDEF FTPRNX,<	FTPRNX←←1 >	;F2 uses Printronix, which lacks a proper VFU
>;IFN FTF2

; LPT CONTROL REGISTER
	LPTSTR←←100000		;(CONO) "PRESS START" AFTER IO RESET
	LPTTBP←←40000		;(CONI) TAB IN PROGRESS (USED BY LPTLOI)
				;CONI BITS 18,19,20 ARE CHARACTER-IN-WORD COUNTER
	LPTALT←←4000		;LAST CHAR WAS 177
	LPTCLR←←2000		;(CONO) CLEAR LPT HARDWARE REGISTERS
	LPTDON←←100		;LPT DONE FLAG
	LPTBSY←←200		;LPT BUSY FLAG
	LPTERR←←400		;(CONI) LPT ERROR, (OFFLINE)
	LPTLOV←←1000		;(CONI) LPT LINE OVERFLOW. (WILL HAPPEN)
	LPTCHB←←LPTCHN*11	;PIA FOR BOTH DONE AND ERROR

; ACCUMULATOR DEFINITIONS . . .
	A←TAC
	B←TAC1
	C←AC1
	D←DAT

; RH OF LPT IOS WORD
	LPTNCC←←100		; SET BY USER TO INHIBIT CHARACTER CONVERSION
;	HNGTRP←←200		; USER WANTS ERROR RETURN ON HUNG LPT (IN OUTER)
	DELBIT←←400		; LAST CHAR. BEFORE CONO-ING LPT OFF WAS 177
	SUPRFF←←1000		; SUPPRESS FF AT CLOSE AND RELEASE

; LH OF LPT IOS WORD
	LPTEN1←←200		; NEAR END OF LPT ACTIVITY FLAG
	LPTDNG←←400		; DANGLING 177 FLAG
	LPTERF←←4000		; ERROR BUBBLING UP FROM INTERRUPT LEVEL
	LPTEN2←←20000		;RELEASE BIT.

; STORAGE PARAMETERS
IFE FTF2,<
	↑LPTCPL←←=120		; NUMBER OF CHARACTERS PRINTED PER LINE
>;IFE FTF2
IFN FTF2,<
	↑LPTCPL←←=132		; NUMBER OF CHARACTERS PRINTER PER LINE
>;IFN FTF2
;LPTDSP LPTINI LPTI.1 LPTBI LPTCLS LPTCL1 LPTINZ LPTREL
;LPT SERVICE DISPATCH TABLE

	JRST	LPTINI		;INITILIZE
	JRST	LPTCLT		;HUNG TIMEOUT.  SET ERROR BIT IN IOS FOR LPTOUT.
↑LPTDSP:
	JRST	LPTREL		;RELEASE LPT
	JRST	LPTCLS		;CLOSE
	JRST	LPTOUT		;OUTPUT
	JRST	ILLINP		;INPUT

;INITIALIZE - CALLED FOR 200 RESTARTS
LPTINI:	CONO	LPT,LPTSTR	;SET LPT START FLAG - CLEARED BY IOB RESET
	SETOM	LPTBG1		;FLAG TO SEND CR FF FIRST
LPTI.1:	MOVSI	IOS,IO
	MOVEM IOS,DEVIOS(DDB)
	CONO	LPT,LPTCLR	;CLEAR HARDWARE REGISTERS.
	HLLZS	LPTCON		;CLEAR PI DISPATCH ADDRESS FOR NOW
	POPJ	P,

LPTBI:	POINT	7,LPTIBF	;LPTUBP - UUO LEVEL SYSTEM BUFFER BYTE POINTER
	LPTIBF			;LPTIBP - INTERRUPT LEVEL POINTER
	5*LPTBLN		;LPTCC  - TOTAL NUMBER OF FREE CHARACTER IN SYSTEM BUFFER
	LPTCPL			;LPTLCC - CHARACTER POSITION IN LINE

;CLOSE
LPTCLS:	MOVSI	IOS,IOEND	;SET OUR PRIVATE 'LAST UUO' FLAG
	ORB	IOS,DEVIOS(DDB)	;INCLUDE BIT IN HONEST IOS
	TLNN	IOS,LPTERF	;ARE WE HUNG?
	JRST	LPTCL1		;NO
	MOVSI	IOS,LPTERF	;YES. TRYING CLEARING HUNG CONDITION
	ANDCAB	IOS,DEVIOS(DDB)	;CLEAR ERROR BIT
	PUSHJ	P,LPTHNG	;CALL THE HUNG ROUTINE
LPTCL1:	PUSHJ	P,OUT		;NOW DO SOME OUTPUTS
	PUSHJ	P,WSYNC		;WAIT FOR LPT TO FINISH - THEN INITIALIZE FOR NEXT

;INITIALIZE IOS AND BYTE POINTERS, AND ALL THE COUNTS
LPTINZ:	MOVE	TAC,[XWD LPTBI,LPTUBP]
	BLT	TAC,LPTLCC		;BLT IN POINTERS AND COUNTS
	ANDI	IOS,SUPRFF!HNGTRP!LPTNCC!17	;CLEAR ALL BUT MODE&SPECIAL BITS
	TLO	IOS,IO			;
	MOVEM	IOS,DEVIOS(DDB)		;AND STORE IOS
	POPJ	P,

LPTREL:	TLNE	IOS,IOBEG		;HAVE WE DONE ANYTHING YET
	JRST	LPTI.1			;NO
	MOVSI	IOS,LPTEN2!IO		;TELL SEVICE ROUTINE
	PUSHJ	P,LPTO3			;WHO WILL SET THE WHEELS IN MOTION
	PUSHJ	P,WSYNC			;WAIT.
	JRST	LPTI.1			;INITIALIZE FOR NEXT USER.
;LPTIOW LPTOUT LPTSET LPTSE2 LPTO3 LPTO3A LPTO1
;LPT OUTPUT CODE, LPT MAY BE RUNNING NOW

;START LPT.  MAKE USER WAIT.
LPTIOW:	MOVSI	IOS,IO			;SET IO (DRD)   IOW WILL BE SET BY WSYNC
	PUSHJ	P,LPTO3			;START LPT.
	PUSHJ	P,WSYNC			;DROP HIM INTO IO WAIT - FALL INTO LPTOUT
LPTOUT:	TLZE	IOS,IOBEG		;CLEAR FIRST UUO FLAG
	MOVEM	IOS,DEVIOS(DDB)		;MAKE SURE IT'S SEEN IN IOS
	TRZE	IOS,IODERR		;HAS LPT BEEN HUNG?
	JRST	UNHANG			;YES, UNHANG IT
	CONSO	LPT,LPTERR		;CATCH ERRORS NOW!
	TLZE	IOS,LPTERF		;CHECK FOR INTERRUPT LEVEL ERROR
	JRST	LPTHNG			;HANG USER UNTIL IT IS FIXED

LPTSET:	PUSHJ	P,DEVSTU		;SET AC2 TO COUNT, AC3 TO BYTE POINTR
	JRST	LPTSE2			;THIS BUFFER HAS ALREADY BEEN EMPTIED!
	CAILE	AC2,LPTBLN		;COUNT BIGGER THAN SIZE OF SYSTEM BUFFER?
	JRST	BTLERR			;YES, LOSE.
	IMULI	AC2,5			;CHANGE WORD COUNT INTO CHARACTER COUNT
	MOVEI	A,(AC2)			;SEE IF WE CAN FIT A BUFFER IN NOW
	IMULI	A,101			;WORST CASE IS 2+(2/120) TIMES AS MANY CHARS
					;(ENTIRE BUFFER FULL OF BACKSLASHES)
	LSH	A,-5			;WHICH IS LESS THAN 65/32 TIMES AS MANY.
	CAML	A,LPTCC			;SEE IF THERE IS SPACE
	JRST	LPTSE2			;NO, PERFORM EXIT MAGIC
	PUSHJ	P,LPTBF			;TRANSFER DATA TO THE SYSTEM BUFFER
	PUSHJ	P,ADVBFE		;ADVANCE THE BUFFER DOWN THE RING
	JRST	LPTSE2			;NO MORE BUFFERS, EXIT, STAGE LEFT
	JRST	LPTSET			;SEE IF WE CAN SQUEEZE IN ANOTHER BUFFER

LPTSE2:	MOVE	A,LPTCC			;SEE IF WE HAVE TRANSFERRED ANYTHING
	CAIL	A,5*LPTBLN-4		;BY COMPARING WITH (NEARLY) EMPTY COUNT
	JRST	LPTO1			;LESS THAN 1 WORD IN BUFFER, RETURN TO USER
	TLNE	IOS,IOEND		;IS THIS THE LAST UUO?
	JRST	LPTIOW			;YES. WAIT FOR LPT TO FINISH
	PUSHJ	P,DEVCR			;CHECK RING USE BIT
	JRST	LPTIOW			;BUFFER BUSY, PUT USER IN IO WAIT
	MOVSI	IOS,IO			;OTHERWISE, JUST START UP LPT
LPTO3:	CONO	PI,LPTOFF		;SHUT OFF LPT CHANNEL
	IOR	IOS,DEVIOS(DDB)		;PICK UP OUR OWN IOS
LPTO3A:	MOVEI	A,LPTLOV+LPTERR+LPTDON
	HRRM	A,LPTCON		;SET UP INTERRUPT DISPATCH CONI BITS
	MOVEI	A,0			;ASSUME NOT BIT
	TRZE	IOS,DELBIT		;TRUE?
	TRO	A,LPTALT		;NO, SET BIT
	TLON	IOS,DEVSBB		;START LPT IF NEEDED
	CONO	LPT,LPTCHB+LPTDON(A)	;SET PIA AND DONE. WILL INTERRUPT
	MOVEM	IOS,DEVIOS(DDB)
	CONO	PI,LPTON		;RESTORE CHANNEL 5
	LDB	A,PDVTIM		;PICK UP HUNG COUNT TIME
	DPB	A,PDVCNT		;DEPOSIT IT, INITIATE  HUNG COUNTING
	POPJ	P,

; COME HERE IF THE SYSTEM BUFFER IS EMPTY

LPTO1:	TLNN	IOS,IOEND		;IS THIS THE LAST UUO?
	POPJ	P,			;NO, EXIT TO USER, STAGE LEFT
	MOVSI	IOS,IOEND		;AND NOW, ZERO THIS BIT FOR GOOD
	ANDCAB	IOS,DEVIOS(DDB)
	TLNE	IOS,IOBEG		;IS THIS REALLY THE BEGINNING?
	POPJ	P,			;YES, EXIT
	MOVSI	IOS,IO+LPTEN1		;PRINT CR-FF AT END.
	JRST	LPTO3			;START LPT AND LEAVE

;LPTHNG LPTHN UNHANG LPTHN1 LPTCLT
;COME HERE IF LINE PRINTER IS HUNG

;HERE AT UUO LEVEL - SOMEONE SET LPTERF FLAG.
LPTHNG:	TRNE	IOS,HNGTRP	;IS HE REQUESTING ERROR RETURN ON HUNG LPT
	JRST	LPTHN1		;YES
	PUSHJ	P,LPTHN		;HANG USER
	JRST	LPTOUT		;TRY AGAIN

LPTHN:	PUSHJ	P,HNGSTP			;PRINT "DEVICE LPT OK?" - HANG USER
UNHANG:	MOVE	IOS,[XWD LPTERF!DEVSBB,IODERR]	;SET TO CLEAR ERROR FLAGS
	CONO	PI,LPTOFF		;SHUT OFF LPT
	ANDCAB	IOS,DEVIOS(DDB)
	PUSHJ	P,LPTO3A		;START LPT, CONO CHANNEL BACK ON.
	JRST	LPTOUT			;DO SOME MORE OUTPUTS

LPTHN1:	TRO	IOS,IODERR		;USER WANTS TO HANDLE ERROR.
	IORB	IOS,DEVIOS(DDB)		;GIVE HIM A DEVICE ERROR BIT
	POPJ	P,

;HERE AT CLOCK LEVEL - HUNG TIMEOUT.  DDB AND IOS SETUP
LPTCLT:	MOVSI	IOS,LPTERF		;KILL THE ERROR BIT
	CONO	PI,LPTOFF		;WITH LPT OFF
	IORB	IOS,DEVIOS(DDB)		;SET ERROR BIT FOR UUO-LEVEL TO SEE
	TLZ	IOS,DEVSBB		;SYSTEM BUFFER IS NO LONGER BUSY
	TLZE	IOS,IOW			;ARE WE IN IO WAIT?
	PUSHJ	P,STTIOD		;YES, TAKE US OUT (PUT INTO TQ)
	MOVEM	IOS,DEVIOS(DDB)		;STORE IOS
	CONO	PI,LPTON		;RESTORE PI CHANNEL
	JRST	CPOPJ1			;SKIP, FORCE HNGCHK TO IGNORE US
;LPTBF LPTBF1 LPTBF2 LPTBF3 LPTDB LPTDB1 LPTDL1 LPTDL0 LPTDEL LPT20T LPTD13 LPTDTF LPTD14 LPTD21 LPTD22 LPTCAR LPTCA2 LPTD12 LPT134 LPTDL2 LPTDL3 LPTD11 LPTD15 LPTICR LPTCN2 LPTCNX LPTCNC LPTBF LPTBFX LPTDB LPTBFY
;TRANSFER BUFFERLOAD CHARACTER BY CHARACTER - DO CHARACTER CONVERSION REQUESTED

IFE LPTNEW,<	;CODE AS IT WAS BEFORE LPT INTERFACE MODS AND AS USED BY CCRMA

LPTBF:	TRNE	IOS,LPTNCC		;CHARACTER CONVERSION?
	SKIPA	A,[HLL A,LPTCTB(A)]	;NO.
	MOVE	A,[MOVE A,LPTCTB(A)]	;YES.
	MOVEM	A,LPTXCT		;SAVE INST TO XCT TO DO CONVERSION
	TLNE	IOS,LPTDNG		;DANGLING DELETE?
	  JRST	LPTDL0			;YES.  HANDLE IT.
LPTBF1:	SOJL	AC2,CPOPJ		;GET NEXT CHARACTER.  RETURN IF NONE
	XCTR	XLB,[ILDB A,AC3]	;GET CHARACTER
	XCT	LPTXCT			;CONVERT CHARACTER
	HLRZ	D,A			;GET DISPATCH ADDRESS, IF ANY
	JUMPN	D,(D)			;DISPATCH IF NEEDED.
LPTBF2:	SKIPG	LPTLCC			;NORMAL CHARACTER. ANY ROOM LEFT?
	  PUSHJ	P,LPTICR		;NO.  INSERT CRLF.
	SOS	LPTLCC			;DECREMENT COLUMN COUNT
LPTBF3:	PUSH	P,LPTDB1		;RETURN ADDRESS IS LPTBF1. FALL INTO LPTDB
LPTDB:	IDPB	A,LPTUBP		;STUFF THE BYTE IN THE SYSTEM BUFFER
	SOS	LPTCC			;COUNT ONE LESS CHARACTER FREE IN BUFFER
	MOVE	B,LPTUBP
	CAME	B,[POINT 7,LPTIBF+LPTBLN-1,34]	;WAS THAT THE LAST BYTE?
LPTDB1:  POPJ	P,LPTBF1			;NO. RETURN QUICK
	MOVE	B,LPTBI				;GET POINTER TO FRONT OF BUFFER
	MOVEM	B,LPTUBP			;YES. RESET POINTER TO FRONT.
	POPJ	P,


;'177 found at end of user buffer.  Remember this and return to user.
LPTDL1:	MOVSI	IOS,LPTDNG		;177 SEEN, THEN END OF BUFFER. SET
	IORB	IOS,DEVIOS(DDB)		;DANGLING DELETE FLAG. TO REENTER AT
	POPJ	P,			;LPTDL0 NEXT TIME.

;'177 found at end of previous buffer.
LPTDL0:	MOVSI	IOS,LPTDNG		;CLEAR DANGLING DELETE
	ANDCAB	IOS,DEVIOS(DDB)
;	\ /
;'177 seen.
LPTDEL:	SOJL	AC2,LPTDL1		;'177 SEEN.  GET NEXT CHR. JUMP IF NONE
	XCTR	XLB,[ILDB A,AC3]	;GET CHARACTER
	XCT	LPTXCT			;CONVERT CHARACTER
IFE FTF2,<
	CAIL	A,20
	CAILE	A,24
	  JRST	LPTDL2			;NORMAL CHARACTER FOLLOWING DELETE
	JRST	LPTDL3			;177-20 THRU 177-24 ARE VERTICAL CHRS.
					; (NON COLUMN-SPACING)
>;IFE FTF2
IFN FTF2,<
	CAML	A,LPTCTB+20
	CAMLE	A,LPTCTB+24
	  JRST	LPTCNC			;Check for control character after delete
IFE FTPRNX,<
	JRST	LPTDL3			;Issue character by itself
>;IFE FTPRNX
IFN FTPRNX,<
	XCT	LPT20T-220(A)		;Setup carriage control code or jump
	JRST	LPTCAR			;Go simulate carriage control tape

;Table of functions for '177 '2x
LPT20T:	JRST	LPTDTF			;'177 '20  Ch 2  Double top of form
	JRST	LPTD21			;'177 '21  Ch 3  Always line feed
	JRST	LPTD22			;'177 '22  Ch 4  Every three lines
	MOVEI	D,2			;'177 '23  Ch 5  Next half page
	MOVEI	D,6			;'177 '24  Ch 6  Next 1/6 page
;End of '177 '2x function table.

;VT
LPTD13:	MOVEI	D,3			;Ch 7  Next 1/3 page(??)
	JRST	LPTCAR

;'177 '20  Double top of form
LPTDTF:	MOVEI	A,20			;(VFU channel 2) This will almost get
	PUSHJ	P,LPTDB			;  us there.
;	\ /
;FF (VFU channel 1).  Use hardware and update position
LPTD14:	SETZM	LPTLIN			;Will be at top of form
	MOVEI	A,14			;Issue hardware FF
	JRST	LPTBF3

;'177 '21  Print over margins
LPTD21:	AOS	A,LPTLIN		;Advance line
	CAMGE	A,LPTPAP		;Are we on the next page yet?
	  JRST	LPTLF1			;  No, but clear column register
	SETZM	LPTLIN			;We now think it is at top of form
	JRST	LPTLF1			;

;'177 '22  Every three lines
LPTD22:	MOVE	A,LPTLIN		;Get current line
	MOVEI	D,3			;Force third line
	JRST	LPTCA2			;Rest is the same

;General carriage control.  D contains fraction of page to go to
LPTCAR:	MOVE	A,LPTPSZ		;Get current page size
	ADDI	A,-1(D)			;Round up!
	IDIVM	A,D			;Result is number of lines per section
	MOVE	A,LPTLIN		;Get current position
LPTCA2:	ADD	A,D			;Round up
	PUSH	P,B			;IDIV generates remainder as well
	IDIV	A,D			;Gives final position in D
	IMULM	A,D
	POP	P,B
	CAML	D,LPTPSZ		;Past end of page?
	  JRST	LPTD14			;  Yes, start new page
	SUB	D,LPTLIN		;Calculate number of lines to slew
	ADDM	D,LPTLIN		;Set new position
	MOVEI	A,7			;Special command to microcode to slew
	PUSHJ	P,LPTDB			;  N lines.
	SOS	A,D			;Microcode wants lines-1 to slew. Sigh.
	JRST	LPTD15			;Zero column position and stow character
	
;Routine to output LF to printer, checking for page overflow.  Clobbers D
LPTD12:	AOS	D,LPTLIN		;Advance to next line
	CAML	D,LPTPSZ		;Room left on page?
	  JRST	LPTD14			;  No, start new page
LPTLF1:	MOVEI	A,12			;Setup LF
	JRST	LPTD15			;Now, send LF and reset column counter

>;IFN FTPRNX
>;IFN FTF2

;"\" seen
LPT134:	TRNE	IOS,LPTNCC		;HERE FOR '134 (BACKSLASH)
	  JRST	LPTBF2			;DON'T CONVERT IT.  (SEND NORMALLY)
;'Hidden' character seen.  Update position and precede with '177 before sending
;to LPT.
LPTDL2:	SKIPG	LPTLCC			;ANY ROOM LEFT?
	  PUSHJ	P,LPTICR		;NO. INSERT CRLF
	SOS	LPTLCC			;COUNT COLUMN SPACE
;	\ /
;Continuation of 'hidden character' or carriage control ('177 '20, etc.)
LPTDL3:	PUSH	P,A
	MOVEI	A,177
	PUSHJ	P,LPTDB			;SEND DELETE
	POP	P,A			;POP SECOND CHARACTER
	JRST	LPTBF3			;AND GO SEND IT

;TAB seen.  Update column position and send a real tab
IFE LPTCPL∧7,<
LPTD11:	SKIPG	LPTLCC			;HERE FOR TAB
	  PUSHJ	P,LPTICR		;NO. ROOM.  INSERT CRLF
	SOS	D,LPTLCC
	ANDCMI	D,7
	MOVEM	D,LPTLCC		;ADJUST COLUMN POSITION
	JRST	LPTBF3			;GO SEND THE TAB
>;IFE LPTCPL∧7
IFN LPTCPL∧7,<
LPT11A:	PUSHJ	P,LPTICR		;Not enough space. Insert a CRLF and win
					;for sure next time.
LPTD11:	MOVE	D,LPTLCC		;Get number of characters remaining
	SUBI	D,(LPTCPL∧8)+1		;Rotate things so tab are xx0
	JUMPL	D,LPT11A		;Not enough left
	ANDCMI	D,7			;Force tab boundary
	ADDI	D,LPTCPL		;Undo rotation for tabs
	MOVEM	D,LPTLCC		;ADJUST COLUMN POSITION
	JRST	LPTBF3			;GO SEND THE TAB
>;IFN LPTCPL∧7

;CR seen.  Update column position
LPTD15:	MOVEI	D,LPTCPL
	MOVEM	D,LPTLCC		;RE-INITIALIZE THE COLUMN COUNT
	JRST	LPTBF3			;SEND CR

;Insert CRLF on line overflow
LPTICR:	PUSH	P,A		;OVERFLOW. INSERT CRLF. SAVE CURRENT CHARACTER
IFE FTPRNX,<
	MOVEI	A,15		;MAKE A CRLF
	PUSHJ	P,LPTDB
>;IFE FTPRNX
	MOVEI	A,12
	PUSHJ	P,LPTDB
IFN FTPRNX,<
	AOS	A,LPTLIN		;Advance line
	CAML	A,LPTPAP		;Are we on the next page yet?
	  SETZM	LPTLIN			;  We now think it is at top of form
>;IFN FTPRNX
	MOVEI	A,LPTCPL	;RESET LINE COUNT
	MOVEM	A,LPTLCC
	POP	P,A
	POPJ	P,

IFN FTF2,<
	PRINTX	Control characters converted for PRINTRONIX
;Temporary code until character PROMs are burned.  At that point, LPTCNX←LPTDL2
LPTCN2:	PUSHJ	P,LPTICR	;Insert CRLF due to line overflow from ↑x
LPTCNX:	SOSG	LPTLCC		;Account for ↑
	  JRST	LPTCN2		;  Won't fit
	SOS	LPTLCC		;Account for x+40
	PUSH	P,A
	MOVEI	A,"↑"
	PUSHJ	P,LPTDB		;SEND DELETE
	POP	P,A		;POP SECOND CHARACTER
	ADDI	A,"@"		;Convert ↑X into X
	JRST	LPTBF3		;AND GO SEND IT

LPTCNC:	TRNE	A,400000	;Special?
	  JRST	LPTBF3		;  Yes, pass it thru
	JRST	LPTCNX
>;IFN FTF2

>;IFE LPTNEW


IFN LPTNEW,<

;THIS CODE REQUIRES LPT INTERFACE MOD SO ON LINE OVERFLOW IT RETURNS VIA CONI:
; 1. CHARACTER COUNT IN FAILING WORD
; 2. TAB IN PROGRESS BIT.
;ALSO REQUIRES THE FOLLOWING MODS TO LPTCTB.
; LH OF ALL ENTRIES ZERO, EXCEPT:
; 1. LPTCTB+134/ 400000,,177
; 2. ENTRIES FOR 0,11,12,13,14,15 AND 177 HAVE BIT 1 ON.

;TRANSFER BUFFERLOAD CHARACTER BY CHARACTER - DO CHARACTER CONVERSION REQUESTED
LPTBF:	TRNN	IOS,LPTNCC		;CHARACTER CONVERSION?
	SKIPA	A,[SKIPGE A,LPTCTB(A)]	;YES.
	MOVSI	A,(<CAIA>)		;NO.
	MOVEM	A,LPTXCT		;SAVE INST TO XCT TO DO CONVERSION
	MOVE	B,LPTUBP
LPTBFX:	SOJL	AC2,LPTBFY		;GET NEXT CHARACTER.  JUMP IF NONE
	XCTR	XLB,[ILDB A,AC3]	;GET CHARACTER
	XCT	LPTXCT			;CONVERT CHARACTER
	JSP	D,LPTDB			;SPECIAL FOR 134.  INSERT 177
	MOVEI	D,LPTBFX		;SET RETURN ADDRESS. FALL INTO LPTDB
LPTDB:	IDPB	A,B			;STUFF THE BYTE IN THE SYSTEM BUFFER
	SOS	LPTCC			;COUNT ONE LESS CHARACTER FREE IN BUFFER
	CAMN	B,[POINT 7,LPTIBF+LPTBLN-1,34]	;AT END OF BUFFER?
	MOVE	B,LPTBI			;GET POINTER TO FRONT OF BUFFER
	JRST	(D)

LPTBFY:	MOVEM	B,LPTUBP		;STORE UPDATED BYTE POINTER
	POPJ	P,

>;IFN LPTNEW
;LPTCTB -- CHARACTER CONVERSION TABLE (SAIL)

IFE FTF2,<	;Whole page

IFN LPTNEW,<
;BIT 0 SET FOR 134 (NEED TO SEND 177,177)
LPT134←←400000

;BIT 1 SET FOR 0,11,12,13,14,15 AND 177 (CHARS WHICH PRECEDED BY 177 ARE NORMAL)
LPTBF1←←LPTD11←←LPTBF3←←LPTD15←←LPTDEL←←200000
>

LPTCTB:	LPTBF1,,0		;NULL, DOESN'T AFFECT POSITION ON LINE
	1
	2
	3
	4
	5
	6
	7
	10
	LPTD11,,11		;HORIZONTAL TAB, SCREWS UP LINE POSITION
	LPTBF3,,12		;LINE FEED, DOESN'T AFFECT POSITION
	LPTBF3,,13		;VERTICAL TAB
	LPTBF3,,14		;FORM FEED
	LPTD15,,15		;CARRIAGE RETURN, REINITIALIZES COLUMN COUNTER
	16
	17
	20
	21
	22
	23
	24
	25
	26
	27
	137			;137←30
	31
	134			;134←32
	33
	34
	35
	36
	37
	40
	41
	42
	43
	44
	45
	46
	47
	50
	51
	52
	53
	54
	55
	56
	57
	60
	61
	62
	63
	64
	65
	66
	67
	70
	71
	72
	73
	74
	75
	76
	77
	140			;140←100
	101
	102
	103
	104
	105
	106
	107
	110
	111
	112
	113
	114
	115
	116
	117
	120
	121
	122
	123
	124
	125
	126
	127
	130
	131
	132
	133
	LPT134,,177		;134 BECOMES 177-177 (IF CONVERTED)
	135
	32			; 32←136
	30			; 30←137
	100			; 100←140
	141
	142
	143
	144
	145
	146
	147
	150
	151
	152
	153
	154
	155
	156
	157
	160
	161
	162
	163
	164
	165
	166
	167
	170
	171
	172
	173
	176			; 176←174
	175
	175			; 175←176
	LPTDEL,,177		;177 MAKES NEXT CHARACTER SPECIAL.

>;IFE FTF2	;Whole page
;LPTCTB -- CHARACTER CONVERSION TABLE (CCRMA)

IFN FTF2,<	;Whole page

IFN LPTNEW,<
;BIT 0 SET FOR 134 (NEED TO SEND 177,177)
LPT134←←400000

;BIT 1 SET FOR 0,11,12,13,14,15 AND 177 (CHARS WHICH PRECEDED BY 177 ARE NORMAL)
LPTBF1←←LPTD11←←LPTBF3←←LPTD15←←LPTDEL←←200000
>

LPTCTB:	LPTBF1,,0		;NULL, DOESN'T AFFECT POSITION ON LINE
	LPTCNX,,201		;REQUIRES 177 PREFIX
	LPTCNX,,202
	LPTCNX,,203
	LPTCNX,,204
	LPTCNX,,400205		;PLOT MODE
	LPTCNX,,400206		;8 LPI
	LPTCNX,,207		;SPEW PAPER ESCAPE FOR MICROCODE
	LPTCNX,,400210		;ELONG CHAR
	LPTD11,,11		;HORIZONTAL TAB, SCREWS UP LINE POSITION
	LPTD12,,12		;LINE FEED, DOESN'T AFFECT POSITION
	LPTD13,,13		;VERTICAL TAB
	LPTD14,,14		;FORM FEED
	LPTD15,,15		;CARRIAGE RETURN, REINITIALIZES COLUMN COUNTER
	LPTCNX,,216		;REQUIRES 177 PREFIX
	LPTCNX,,217
	LPTCNX,,220
	LPTCNX,,221
	LPTCNX,,222
	LPTCNX,,223
	LPTCNX,,224
	LPTCNX,,225
	LPTCNX,,226
	LPTCNX,,227
	LPTCNX,,230
	LPTCNX,,231
	LPTCNX,,232
	LPTCNX,,233
	LPTCNX,,234
	LPTCNX,,235
	LPTCNX,,236
	LPTCNX,,237
	40
	41
	42
	43
	44
	45
	46
	47
	50
	51
	52
	53
	54
	55
	56
	57
	60
	61
	62
	63
	64
	65
	66
	67
	70
	71
	72
	73
	74
	75
	76
	77
	100
	101
	102
	103
	104
	105
	106
	107
	110
	111
	112
	113
	114
	115
	116
	117
	120
	121
	122
	123
	124
	125
	126
	127
	130
	131
	132
	133
	134
	135
	136		;Actually <circumflex> for now
	137		;Actually <underline> for now
	140
	141
	142
	143
	144
	145
	146
	147
	150
	151
	152
	153
	154
	155
	156
	157
	160
	161
	162
	163
	164
	165
	166
	167
	170
	171
	172
	173
	174
	176			; 176↔175
	175			; 175↔176
	LPTDEL,,177		;177 MAKES NEXT CHARACTER SPECIAL.

>;IFN FTF2	;Whole page
;LPTINT LPTIN2 LPTCF1 LPTXIT LPTIN1 LPMASK LPTCRF LPTCFX LPTCFF LPTOF LPTOF0 LPTOF1 LPTERH LPTLOI LPTLO1 LPTLO2 LPTLO3 LPTLO4 LPTBTB
SUBTTL LPTSER - INTERRUPT LEVEL ROUTINES
;THIS PART IS ENTIRELY AUTONOMOUS.
;IT DOES NOT REFERENCE USER CORE, BECAUSE IT ISN'T THERE!

↑LPTINT:
	JSR	LPTSAV		;SAVE ACCUMULATORS AND SET RETURN ADDRESS
	MOVEI	DDB,LPTDDB	;SET UP DDB ADDRESS FOR SETIOD AND PDVTIM
	MOVE	IOS,DEVIOS(DDB)	;GET IOS
	CONSZ	LPT,LPTLOV!LPTERR	;LINE OVERFLOW OR LPT TURNED OFF-LINE?
	JRST	LPTLOI			;YES. SEE WHICH.

	SKIPE	A,LPTBG2	;ANYTHING DANGLING FROM LAST TIME?
	JRST	LPTCFF		;YES.  PRINT IT FIRST
	MOVE	A,LPTCC		;FIRST, IS THERE ANYTHING TO PRINT
	CAIL	A,5*LPTBLN	;COMPARE WITH TOTAL COUNT
	JRST	LPTOF		;NOTHING TO PRINT, SHUT OFF LPT

	SKIPE	LPTBG1		;NEED TO SEND CR FF FIRST?
	JRST	LPTCFX		;YES.
	CAIL	A,4*LPTBLN	;CHECK FOR NEARLY EMPTY
	TLNE	IOS,LPTEN2!LPTEN1	;SKIP UNLESS WAITING FOR CLOSE OR RELEASE
	JRST	LPTIN2			;NOT NEARLY EMPTY, OR CLOSE OR RELEASE
	TLZE	IOS,IOW		;ARE WE IN AN IO WAIT?
	PUSHJ	P,STTIOD	;YES, GET US OUT!
LPTIN2:
	MOVEI	A,5		;WE WILL PRINT 5 CHARACTERS
	ADDB	A,LPTCC		;ADD IN COUNT
	CAILE	A,5*LPTBLN	;COMPARE WITH TOTAL COUNT
	JRST	LPTIN1		;FEWER THAN 5 CHARACTERS LEFT TO PRINT
	MOVE	A,@LPTIBP
	MOVEM	A,LPTDCN	;SAVE LAST WORD TRANSFERRED
	DATAO	LPT,A		;SEND WORD TO LINE PRINTER
	AOS	A,LPTIBP	;INCREMENT OUT POINTER
	CAIL	A,LPTIBF+LPTBLN	;CHECK FOR BUFFER OVERFLOW . . .
	MOVEI	A,LPTIBF	;AND RESET POINTER IF SO
	MOVEM	A,LPTIBP	;STORE POINTER FOR NEXT TIME
LPTCF1:	LDB	A,PDVTIM	;PICK UP HUNG COUNT TIME, DEFINED IN LOWCOR
	DPB	A,PDVCNT	;DEPOSIT IT, INITIATE HUNG COUNTING
LPTXIT:	MOVEM	IOS,DEVIOS(DDB)	;STORE IOS IN LPT DDB
	POPJ	P,		;AND EXIT, CHANNEL 5

;HERE WHEN THERE IS NOT A FULL WORD TO BE PRINTED
LPTIN1:	TLNN	IOS,LPTEN1!LPTEN2	;IS THIS CLOSE OR RELEASE?
	JRST	LPTOF0			;NO, JUST STOP LPT UNTIL USER PUTS MORE IN.
	SUBI	A,5*LPTBLN	;CALCULATE THE NUMBER OF CHRS NOT USED IN LAST WORD
	MOVE	A,LPMASK-1(A)	;COUNT IS FROM 1 TO 4. GET MASK FOR USEFUL BITS
	AND	A,@LPTIBP	;GET ONLY USEFUL PART OF THE WORD
	MOVEM	A,LPTDCN	;SAVE LAST WORD SENT.
	DATAO	LPT,A		;SEND PARTIAL WORD
	MOVEI	A,5*LPTBLN	;RESET COUNT TO MAXIMUM
	MOVEM	A,LPTCC
	JRST	LPTCF1		;NO WORRY ABOUT WRAP-AROUND EITHER

LPMASK:	BYTE(7)177,177,177,177		;KEEP 4 CHARACTERS
	BYTE(7)177,177,177		;KEEP 3 CHARACTERS /KEEP 2 4
	BYTE(7)177,177			;KEEP 2		   /KEEP 3 3
	BYTE(7)177			;KEEP 1		   /KEEP 4 2
	0				;USED AT LPTLOI	   /KEEP 5 1
	BYTE(7)177,177,177,177		;USED AT LPTLOI	   /KEEP 1 0
	-1				;USED AT LPTLOI    /KEEP 0 -1

LPTCRF:	CONO	LPT,LPTCHB+LPTALT+LPTDON	;SET ALT FLAG
IFE FTF2,<
	SKIPA	A,[BYTE(7) 20,177,20,177,20]	;3 TOP OF DOUBLE FORMS
LPTCFX:	MOVE	A,[BYTE(7) 15,177,20]		;CR TOP OF DOUBLE
>;IFE FTF2
IFN FTF2,<
	SKIPA	A,[BYTE(7) 20,14]		;1 TOP OF DOUBLE FORMS
LPTCFX:	MOVE	A,[BYTE(7) 15,20,14]		;CR TOP OF DOUBLE
	SETZM	LPTLIN				;NOW AT TOP OF FORM
>;IFN FTF2
LPTCFF:	MOVEM	A,LPTDCN			;SAVE LAST WORD SENT
	DATAO	LPT,A
	SETZM	LPTBG1
	SETZM	LPTBG2
	JRST	LPTCF1		;NO NEED TO ADVANCE FORM AT THE START

LPTOF:	TRNE	IOS,SUPRFF		;SUPPRESS FORM FEEDS?
	TLZ	IOS,LPTEN1!LPTEN2	;YES.  CLEAR THESE BITS
	TLZE	IOS,LPTEN2		;RELEASE?
	JRST	LPTCRF			;YES. GO MAKE SOME FFS AND WAIT.
	TLZE	IOS,LPTEN1		;IS THIS THE CLOSE?
	SETOM	LPTBG1			;YES. NEXT OUTPUT WILL BE PRECEDED BY CR FF.
	JRST	LPTOF1			;NOW STOP THE LPT AND WAKE THE USER

LPTOF0:	SUBI	A,5		;LESS THAN 1 WORD, BUT NOT DOING CLOSE.
	MOVEM	A,LPTCC		;ADJUST COUNT - WE DIDN'T REALLY TAKE ANYTHING.
LPTOF1:	TLZE	IOS,IOW		;ARE WE IN AN IO WAIT?
	PUSHJ	P,STTIOD	;YES, CHANGE TO WAIT SATISFIED!
	TLZ	IOS,DEVSBB	;SYSTEM BUFFER IS NO LONGER BUSY
				;FALL INTO LPTERH TO STOP LPT. WAIT FOR MORE STUFF

;HERE IF THE LPT IS STOPPED.  CLEAR LPT - WILL CAUSE "DEVICE LPT OK?" MESSAGE
LPTERH:	HLLZS	LPTCON
	CONSZ	LPT,LPTALT		;IS DELETE FLAG CURRENTLY SET?
	TRO	IOS,DELBIT		;YES, REMEMBER IT!
	CONO	LPT,0			;CLEAR LPT HARDWARE
	JRST	LPTXIT			;STORE IOS AND DISMISS.

;ERROR.  EITHER LINE OVERFLOW ERROR OR OFFLINE
LPTLOI:	CONSZ	LPT,LPTERR		;OFFLINE?
	JRST	LPTERH			;YES.  HANG UP.
IFE LPTNEW,<
	DATAO	LPT,[BYTE(7)15,12]	;SEND CRLF TO CLEAR LINE OVERFLOW
	JRST	LPTXIT
>;IFE LPTNEW

IFN LPTNEW,<
;THIS REQUIRES HARDWARE MOD AND NEW LPT TABLE.
;NEED ADDITIONAL HARDWARE MOD TO GET CONI BIT 21 - TAB IN PROGRESS TO APPEAR.
;MARK WITH BIT 1 IN LPTCTB THE FOLLOWING:  0,11,12,13,14,15,177
	CONI	LPT,A
	MOVEM	A,LPTBG2		;SAVE CONI BITS TEMPORARILY
	TRNE	A,LPTTBP		;TAB IN PROGRESS?
	JRST	LPTLO4			;YES. ARRANGE TO SKIP THE TAB.
	LDB	A,[POINT 3,LPTBG2,20]	;BITS 18-20 ARE CHARACTER COUNT (1,2,3,4,0)
	LDB	A,LPTBTB(A)		;GET THE CHR THAT CAUSED OVERFLOW
	LDB	A,[POINT 1,LPTCTB(A),1]	;GET SPECIAL BIT FOR THIS CHR.
	JUMPN	A,LPTLO3		;JUMP IF THIS BYTE NEEDS A 177 PRECEDING IT.
	LDB	A,[POINT 3,LPTBG2,20]	;GET THE COUNT AGAIN
LPTLO1:	DATAO	LPT,[BYTE (7)15,12]	;FIX LOV BY FORCING LINE TO PRINT.
	MOVN	A,A			;COUNT IS 1,2,3,4 OR 0. OR -1
	SETCM	A,LPMASK+5(A)		;GET CORRESPONDING MASK
LPTLO2:	AND	A,LPTDCN		;FORM WHAT WE NEED TO SEND NEXT.
	MOVEM	A,LPTBG2		;STORE IT.
	JRST	LPTXIT

LPTLO3:	LDB	A,[POINT 3,LPTBG2,20]	;GET THE CHARACTER COUNT
	JUMPG	A,.+2
	MOVEI	A,5			;0 BECOMES 5
	SOJG	A,LPTLO1		;2-5 ARE EASY.  JUST INCLUDE EXTRA BYTE.
	DATAO	LPT,[BYTE(7)15,12,0,0,177]	;SET ALT AT END OF THIS WORD
	SOJA	A,LPTLO2		;SET A TO -1.  SEND ENTIRE WORD AGAIN

LPTLO4:	LDB	A,[POINT 3,LPTBG2,20]	;GET THE COUNT
	JUMPE	A,[SOJA A,LPTLO1]	;0 BECOMES -1 
	CAIE	A,4			;NEXT TO LAST?
	AOJA	A,LPTLO1		;NO.  1,2,3 BECOME 2,3,4
	MOVEI	A,0
	JRST	LPTLO1			;4 BECOMES 0


LPTBTB:	POINT	7,LPTDCN,34		;0 IS LAST BYTE
	POINT 	7,LPTDCN,6		;1 IS FIRST BYTE
	POINT	7,LPTDCN,13
	POINT	7,LPTDCN,20
	POINT	7,LPTDCN,27
>;IFN LPTNEW

BEND LPTSER

>;IFN LPTNUM
