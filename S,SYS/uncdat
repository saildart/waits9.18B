COMMENT ⊗   VALID 00014 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	SIXPGT
C00004 00003	SYSBUF SATTAB BADORG XXX IDSAT P1OFF P2OFF SATEND SATSIZ USATSZ SAT2BK
C00010 00004	C1CMD C1MRT C1JMP C1TIO C1IWC C1BAK C1NATM C1BYTM C1CBYT C1SLE C1CEC C1NOC C1RPT C1ZERO C1APT C1BPT
C00013 00005	C1APH C1APHU C1BPH C1BPHU C1AEXH C1BEXH C1ASEF C1ASNF C1BSNF C1ARCF C1BRCF C1ZEND C1SNPP C1RCAL C1ASND C1BSND C1ASNP C1SNSL C1BSNP
C00016 00006	STRTBL STPTBL SELTBL RSTTBL
C00017 00007	LEBFR LEBFRB LEBFRD LEBFRL LEBJMP LLEBFR LCURB DDCURS DDCURB DDCURL CURB LDDCUR CZPNT CURZWD DDCRLF DDRUN DDERRS DDERRB DDERRD DDERRL COMEUP UPMSG LUPMSG UPMSG2 UPMSG3 UPMSG4 UPMSG5 WSERC WSERCB LWSERC DDHELP PDDREL
C00023 00008	DPYARN DPYAVL DPYAV2 DPYAV3 DPYAV1 AVLWHO DDWMES AVLWDD DDUNMS LWHDDQ DDDMES DDDME2 DDDME3
C00027 00009	DDSTRS DDSTRB DDSTRD DDSTRL DPYHLD GHEAD GPOGH GERS TITLE WTEND WTTYS WSEG WHFILE WLINK DMWCOP
C00032 00010	COMIII WHOSEL COMDD COMWHO LCOMNL LCOMDM DDDRT1 DDDRET
C00035 00011	MPXTAC MPXDDR MPXSTP MPXRST MPXCNI MPXDTI MPXZER MPXENB MPXDTO MPXJOB MPXZND LMPXDTO
C00037 00012	WTQK3
C00038 00013	PATCH PATEND
C00039 00014	DDB.CHAIN.DEFS
C00043 ENDMK
C⊗;
;SIXPGT

;THIS FILE CONTAINS ONLY UNCACHED DATA, FOR REFERENCE BY C1,DD,III,TV,MPX.
;THE FILE CACDAT CONTAINS DATA THAT IS CACHED (NOT REFERENCED BY ABOVE DEVICES).

;UNCDAT MUST START ON A PAGE BOUNDARY, AND SO MUST SIXPGT.

LOC <.+777>∧777000		;NEXT PAGE BOUNDARY

IFN FTSIX,<
SIXPGT:				;PAGE TABLE FOR P3 MEM FOR MAPPIPLEXOR
FOR I←0,P3PGS-1 <
	PWRT,,P3BASE+I		;uncached write access for all pages
>
>;IFN FTSIX
;SYSBUF SATTAB BADORG XXX IDSAT P1OFF P2OFF SATEND SATSIZ USATSZ SAT2BK

IFE FTSBP,<
↓↑SYSBUF:BLOCK SECSIZ		;RETRIEVAL PART OF SYSTEM BUFFER
	BLOCK BKDSIZ		;DATA PART
IFN FTMSYSBUF,<
REPEAT NPACKS-1,<
	BLOCK SECSIZ+BKDSIZ
>
>;IFN FTMSYSBUF
>;IFE FTSBP

;SAT TABLE AS STORED ON BLOCK 0 OF THE DISK
;THE SAT TABLE HAS TWO PARTS, THE BITS TABLE AND EVERYTHING ELSE.
;TRACK 0 ON THE DISK HAS SOME AMOUNT OF RANDOM INFORMATION (SUCH AS
;THE SATID AND NUMBER OF USED TRACKS, ETC.) FOLLOWED BY THE BEGINNING
;OF THE BIT TABLE.  IN THE 2 TRACK SAT SYSTEM, THE BIT TABLE CONTINUES
;AT RECORD SAT2RC IN THE SECOND SAT TRACK.  THE SAT WORD CALLED NXTSAT
;CONTAINS THE TRACK NUMBER OF THE SECOND SAT TRACK.

	DEFINE ZWD (A)<↑A←←.-SATTAB ↔ 0 >
	DEFINE ZLOC (A)<↑A←←.-SATTAB>

↑SATTAB:ZWD(DSKUSE)		;BLOCKS USED ON DISK
	ZWD(LSTBLK)		;NUMBER OF LAST BLOCK ASSIGNED
	ZWD(SATID)		;IDENT.NO. OF ALL DISK INFO
	ZWD(SATCHK)		;XOR CHECKSUM OF SAT BITS BELOW
	ZWD(BADCNT)		;NO. OF BAD TRACKS IN TABLE BELOW.
	ZWD(BADCHK)		;CHECK (SUM) OF TABLE.
	ZLOC(BADTRK)
BADORG::BLOCK BADMAX		;TABLE OF BAD LOGICAL BLOCK NUMBERS (TRACKS)
IFN FTECCT,<
	ZLOC(ECCTRK)
	BLOCK ECCTKS		;TABLE OF MARGINAL (DF ECC) TRACKS
>;IFN FTECCT
	ZWD(NXTSAT)		;TRACK NUMBER OF SECOND SAT TRACK
;ADD STUFF HERE
XXX←←BADSIZ-<.-BADORG>
IFL XXX,<.FATAL SATTAB FORMAT DISAGREES WITH BADSIZ>
IFG XXX,<BLOCK XXX>		;KEEP SAT FORMAT CONSTANT DESPITE BADMAX CHANGES
	ZWD(IDSAT)		;CONTAINS 'SATID ' FOR NEW UDPS
↓IDSAT←←IDSAT
	ZWD(DTIME)		;TIME SAT LAST WRITTEN
	ZWD(DDATE)		;DATE SAT LAST WRITTEN
↑P1OFF::	0		;# P1 POWER FAILURES	(MAIN SAT ONLY!)
↑P2OFF::	0		;# P2 POWER FAILURES	(MAIN SAT ONLY)
		0		;BUFFER WORD.			(NOT NEEDED)
	ZLOC(SATBIT)		;LOCATION OF THE BIT TABLE ITSELF
	BLOCK SATWCT	
↑SATEND:	0		;END OF MAIN BIT TABLE (UDP SATS ARE DIFFERENT SIZE)
↓↑SATSIZ←←SATEND-SATTAB
IFN UPACKS,<
↓↑USATSZ←←SATBIT+SATUWC+2	;+2 FOR GOOD MEASURE
>;IFN UPACKS
IFN FTF2,<
↓↑SATSIZ←←<SATSIZ+777>∧777000	;Make multiple of one page, for
↓↑USATSZ←←<USATSZ+777>∧777000	;efficient unbuffered F2 disk output
	BLOCK SATSIZ-<.-SATTAB>	;Space for unused part of SAT, to next page
>;IFN FTF2
↑SAT2BK←←SATTAB+BLKWDS		;ORIGIN IN CORE OF 2ND PART OF SAT FROM DISK.
SATDSZ←←IFN SAT2RC,<RECSIZ-SECSIZ+>2*BLKWDS-SAT2RC*RECSIZ

IFG SATSIZ-SATDSZ,<
.FATAL	SAT TOO BIG FOR THE DISK SPACE ALLOCATED.
>

;UDP model DDBs aren't cached in case it's used for disk input of, e.g., rtvl info

FOR @$ UNUM←1,UPACKS<
IFE FT8UNI,<
	REPEAT DDBSKW-2,<0>
>;IFE FT8UNI
IFN FT8UNI,<
	REPEAT DDBSKW-3,<0>
	UNUM⊗PUNITP		;UNIT NUMBER
>;IFN FT8UNI
	UDP$UNUM$DD+DEVIOS			;DEVSPT
	DEVSHR!DEVAOA!DEVLUP!DEVMAS!DEVSTS,,0
↑UDP$UNUM$DD:
	SIXBIT /UDP$UNUM/
IFE FT8UNI,<
	=30*HUNGST,,UNUM⊗PUNITP+201
>;IFE FT8UNI
IFN FT8UNI,<
	=30*HUNGST,,201		;HUNG COUNT, BUFFER SIZE+1
>;IFN FT8UNI
	0			
IFN UNUM-UPACKS,<
	CAT(CAT(UDP,\<UNUM+1>),DD),,DSKDSP
;>	UDP1.NX,,DSKDSP			;FOR OLD STYLE USE UDPDSP INSTEAD!
	XWD DVDSK!DVUDP!DVOUT!DVIN!DVDIR!DVLNG,154403	;DVDSK!
	0			
	0			
	0		
	0		
	
	BLOCK <DDBSIZ-UDP$UNUM$DD+.>		;MAKE SAME SIZE AS DSKDDB.
IfStructure,<
	$XYZZY==.
	ORG UDP$UNUM$DD+SDBPTR
	SDB$UNUM				;point to SDB for this DDB
	ORG UDP$UNUM$DD+DD.SSZ
	SECSIZ				;actual size in words of rtvl sector.
	ORG UDP$UNUM$DD+DD.RPB
	RCPBLK				;number of data records per block
	ORG UDP$UNUM$DD+DD.RTL
	40				;SYMBOL?   Number of RTVL words in use
	ORG UDP$UNUM$DD+DD.BPG
	BKPGRP				;Number of blocks per group
	ORG UDP$UNUM$DD+DD.RPG
	RCPGRP				;number of records per group
	ORG $XYZZY
	PURGE $XYZZY
>;IfStructure
>;FOR
;C1CMD C1MRT C1JMP C1TIO C1IWC C1BAK C1NATM C1BYTM C1CBYT C1SLE C1CEC C1NOC C1RPT C1ZERO C1APT C1BPT

;C1 CHANNEL DATA AREAS

COMMENT ⊗ FORMAT OF MRT COMMAND (MULIPLE RECORD TRANSFER)
MRT,READ OR MRT,WRITE
C,C,H,R
SEC,LAST REC,WRAP R,0
JUMP ADDR OF FIRST DATA POINTER
DATA POINTER
   .
   .
   .
DATA POINTER

EVERY RECORD MUST HAVE A NEW DATA POINTER WHICH IS FLAGGED
BY A ONE IN BIT 1 (NOT COUNTED AS PART OF THE COUNT FIELD)

THIS COMMAND WILL DO ALL THE SEEKS, SEARCHES AND SET SECTORS NECESSARY
TO TRANSFER ALL THE DATA.  UPON AN ERROR THE PC WILL POINT AT ONE OF
THE DATA WORDS WITH BIT 1 ON.
⊗

;CHANNEL PROGRAM DEFINITIONS
;LEFT HALF BITS
↓C1CMD←←100000			;BITS 0-3 = 10 MEANS (NON-MRT) COMMAND WORD
↓C1MRT←←040000			;BITS 0-3 = 04 MEANS MRT COMMAND WORD
↓C1JMP←←200000			;BITS 0-3 = 20 MEANS JUMP COMMAND WORD
↓C1TIO←←020000			;TEST I/O
↓C1IWC←←010000			;IGNORE WORD COUNT
↓C1BAK←←004000			;BACKWARDS
↓C1NATM←←000000			;NATURAL MODE (MODE IN BITS 7-8)
↓C1BYTM←←001000			;BYTE MODE
↓C1CBYT←←000400			;COUNT BYTES
				;BITS 10-17 ARE THE IBM COMMAND BYTE
;RIGHT HALF BITS
↓C1SLE←←20			;STOP ON LENGTH ERROR
↓C1CEC←←10			;CHANNEL END CONTINUE
↓C1NOC←←2			;NO CHAINING
↓C1RPT←←1			;REPEAT UNTIL STATUS MODIFIER IS ON IN ENDING STATUS

↓C1ZERO::			;ZERO FROM HERE TO C1ZEND AT DISKUP
;PROGRAM TABLE
↑C1APT:	BLOCK C1PPTR+NPACKS+1	;CHN CTL WD, INT WD, 1 PGM PTR PER DRIVE, 1 END MARK
↑C1BPT:	BLOCK C1PPTR+NPACKS+1	;PROGRAM TABLE FOR SECOND CHANNEL

;C1APH C1APHU C1BPH C1BPHU C1AEXH C1BEXH C1ASEF C1ASNF C1BSNF C1ARCF C1BRCF C1ZEND C1SNPP C1RCAL C1ASND C1BSND C1ASNP C1SNSL C1BSNP

↓C1APH:BLOCK FPACKS*C1PRGL	;PROGRAM HEADERS FOR FIRST CHANNEL FILE PACKS
↓C1APHU:BLOCK UPACKS*C1PRLU	;PROGRAM HEADERS FOR FIRST CHANNEL UDPS (NEW STYLE)
↓C1BPH:BLOCK FPACKS*C1PRGL	;PROGRAM HEADERS FOR SECOND CHANNEL FILE PACKS
↓C1BPHU:BLOCK UPACKS*C1PRLU	;PROGRAM HEADERS FOR SECOND CHANNEL UDPS (NEW STYLE)

↑C1AEXH:BLOCK NPACKS		;EXPECTED HALT ADDRESS FOR CHANNEL A
↑C1BEXH:BLOCK NPACKS		;EXPECTED HALT ADDRESS FOR CHANNEL B

↑C1ASEF:BLOCK 2			;FLAG FOR C1A(B)INT FROM SELECT ERROR CODE

↑C1ASNF:BLOCK NPACKS		;SENSE IN PROGRESS FLAG
↑C1BSNF:BLOCK NPACKS

↑C1ARCF:BLOCK NPACKS		;RECAL IN PROGRESS FLAG
↑C1BRCF:BLOCK NPACKS

↑C1ZEND::

↑C1SNPP:C1JMP,,C1ASNP		;JUMPS TO SENSE PROGRAMS
	C1JMP,,C1BSNP

;WCMAS FOR CONTROL COMMANDS
DEFINE C1WCMA (COUNT,ADDR)<
BYTE (1)1 (13)COUNT (22)ADDR
>


↑C1RCAL:C1CMD!23,,C1NOC			;UNCHAINED RECALIBRATE COMMAND
	0

↑C1ASND:BLOCK 6*NPACKS		;SENSE DATA FOR EACH PACK (24 BYTES)

↑C1BSND:BLOCK 6*NPACKS		;SENSE DATA FOR EACH PACK (24 BYTES)

↑C1ASNP:FOR I←0,NPACKS-1 <
	C1CMD!C1IWC!C1BYTM!4,,C1NOC	;UNCHAINED SENSE
	C1WCMA (0,C1ASND+6*I)
	0
>
↑C1SNSL←←<.-C1ASNP>/NPACKS

↑C1BSNP:FOR I←0,NPACKS-1 <
	C1CMD!C1IWC!C1BYTM!4,,C1NOC	;UNCHAINED SENSE
	C1WCMA (0,C1BSND+6*I)
	0
>
;STRTBL STPTBL SELTBL RSTTBL

IFE FTF2,<	;Whole page

;DPYSER DATA STORAGE

↑STRTBL:BLOCK DPYNUM	;THIS TABLE, INDEXED BY DISPLAY NO.,
			;GIVES NORMAL START POINT FOR ITS PROGRAM.

	0		;STPTBL(-1) FOR HOLDING MESSAGE
↑STPTBL:BLOCK DPYNUM	;SAME THING FOR STOP POINTS.
	0		;STPTBL(DPYNUM)	FOR IDLE STATE

↑SELTBL:BLOCK DPYNUM	;POINTERS TO SELECT WORDS
↑RSTTBL:BLOCK DPYNUM	;RESTART (I.E. BEGINNING OF PRGM) POINTS.

>;IFE FTF2	;Whole page
;LEBFR LEBFRB LEBFRD LEBFRL LEBJMP LLEBFR LCURB DDCURS DDCURB DDCURL CURB LDDCUR CZPNT CURZWD DDCRLF DDRUN DDERRS DDERRB DDERRD DDERRL COMEUP UPMSG LUPMSG UPMSG2 UPMSG3 UPMSG4 UPMSG5 WSERC WSERCB LWSERC DDHELP PDDREL

IFN FTDDKLU,< ↑LDDREL←←0 >		;Find max length DD prog to relocate

↑LEBFR:
IFN FTGRIN,<
	GW G.LDC,0,G.LSM,0	;Channel and subchannel masks inserted here
↑LEBFRB:GW G.LWM,1,G.LUM,12	;Write mode and update mode for Grinnell
↑LEBFRD:GW G.LEB,GRESIZ,G.LLB,0 ;Set delta-X and -Y for each char.
↑LEBFRL:GW G.LEA,GRESIZ,G.LLA,0 ;Set initial X and Y positions (stored later)
>;IFN FTGRIN
IFE FTGRIN,<	CW 1,46,2,0,3,2
		CW 3,2,4,0,5,0
>;IFE FTGRIN
↑LEBJMP:	0			;Space to erase line, or jump to DPY HDR
		0			;Halt here if didn't jump
IFN FTDDKLU,<
↑LLEBFR←←.-LEBFR	;Length of program to relocate
IFG LLEBFR-LDDREL,< ↑LDDREL←←LLEBFR >
>;IFN FTDDKLU

↑LCURB←←20	;Number of DD/Grinnell graphics wds needed for one scanline
↑DDCURS:
IFE FTGRIN,<	0
		CW 3,1,4,0,5,0
>;IFE FTGRIN
IFN FTGRIN,<
	GW G.LDC,0,G.LSM,0	;Channel and subchannel masks inserted here
↑DDCURB:GW G.LWM,1,G.LUM,12	;Write mode and update mode for Grinnell
	GW G.LEB,GRGSIZ,G.LLB,0 ;Set delta-X and -Y for each char.
↑DDCURL:GW G.LEA,GRESIZ,G.LLA,0 ;Set initial X and Y positions (stored later)
>;IFN FTGRIN
↑CURB←←.-DDCURS			;Offset of beginning of graphics buffer
		REPEAT LCURB,<2>
IFE FTGRIN,<	CW 0,0,3,1,3,1	;Execute for DD to force out line
>;IFE FTGRIN
		0			;Halt for cursor program
IFN FTDDKLU,<
↑LDDCUR←←.-DDCURS	;Length of program to relocate
IFG LDDCUR-LDDREL,< ↑LDDREL←←LDDCUR >
>;IFN FTDDKLU

↑CZPNT:		POINT 36,CURZWD-1,35
↑CURZWD:	BLOCK 4
↑DDCRLF:	REPEAT =40,<ASCID /  
/>
		0			;Halt for selected line erasing

↑DDRUN:		0	; TELLS IF DD IS CURRENTLY RUNNING
↑DDERRS:
IFE FTGRIN,<	CW 1,46,2,0,3,1
		CW 3,2,4,0,5,0
		DDCRLF,,DISJMP
>;IFE FTGRIN
IFN FTGRIN,<
	GW G.LDC,0,G.LSM,0	;Channel and subchannel masks inserted here
↑DDERRB:GW G.LWM,1,G.LUM,12	;Write mode and update mode for Grinnell
↑DDERRD:GW G.LEB,777-GRESIZ,G.LLB,0 ;Set width and height of erase
↑DDERRL:GW G.LEA,GRESIZ,G.LLA,G.W   ;Set initial X and Y positions (stored later)
		0		;Halt (graphic write caused by G.W bit above)
>;IFN FTGRIN

↑COMEUP:	0			;HOUR,,MINUTE when the system is coming up
↑UPMSG:		ASCID /  Up at 00:00            / ;SYSINI knows exact format of this!!
↑LUPMSG←←.-UPMSG
↑UPMSG2:	ASCID /  Up who knows when!     / ;All of these must be same length
↑UPMSG3:	ASCID /  Up shortly!            / ;Make same length too.
↑UPMSG4:	ASCID /  Up at 00:00 approx.    / ;Make same length too.
↑UPMSG5:	ASCID /  Up at 8pm or sooner.   / ;Make same length too; patch this msg

↑WSERC:
IFN FTGRIN,<	GW G.LDC,0,G.LSM,0	;Channel and subchannel masks inserted here
↑WSERCB:	GW G.LWM,1,G.LUM,12	;Write mode and update mode for Grinnell
		GW G.ERS,0,G.NOP,0	;Erase whole screen
>;IFN FTGRIN
IFE FTGRIN,<	CW 1,17,2,0,3,2
		CW 1,46,2,0,3,2
>;IFE FTGRIN
		0
IFN FTDDKLU,<
↑LWSERC←←.-WSERC	;Length of program to relocate
IFG LWSERC-LDDREL,< ↑LDDREL←←LWSERC >
>;IFN FTDDKLU

IFN FTDDKLU,<
↑DDHELP:	0	;Set this non-zero to relocate certain DD xfers
↑PDDREL:	0	;Pointer to (uncached) block LDDREL long for relocated prog
>;IFN FTDDKLU
;DPYARN DPYAVL DPYAV2 DPYAV3 DPYAV1 AVLWHO DDWMES AVLWDD DDUNMS LWHDDQ DDDMES DDDME2 DDDME3

IFE FTF2,<

↑DPYARN:	0	; DENOTES THAT 'CONSOLE AVAILABLE' MESSAGE HAS BEEN RUN THIS TICK

↑DPYAVL:	LVW -600,0,I,A,2,4
		770000,,DISSEL
		<BYTE (8)377>!DISSKP
		TTYLOK,,20!DISRST
		<BYTE (8)367,0,367>!DISKPN
		DPYAV2,,DISJMP
		MAINTMODE,,20!DISRST
		<BYTE (8)367,0,367>!DISSKP
		DPYAV1,,DISJMP
DPYAV2:		ASCID /SYSTEM IS DOWN!!!/
↑DPYAV3:	REPEAT LUPMSG, < 0 > ;SPACE FOR TIME COMING UP--SEE SYSINI
		0

DPYAV1:		ASCID /TAKE ME I'M YOURS!/
		0
;*** RPH PATCH TO CATCH LOSING DP
		.+1,,24
		0
		.-2,,20
;END PATCH
>;IFE FTF2

↑AVLWHO:
IFE FTGRIN,<	CW 1,17,2,0,1,6	;WE SEND AN ERASE DURING FIRST FIELD ONLY
		0		;DD CW goes here
		AVLWDD,,DISJMP	;Draw wholine and come back (via DDDRET)
		ASCID /

 
/
>;IFE FTGRIN
IFN FTGRIN,<
	GW G.LDC,0,G.LSM,0      ;Channel and subchannel masks inserted here
	GW G.LWM,0,G.LUM,12     ;Write mode and update mode for Grinnell
	GW G.LEB,GRESIZ,G.LLB,0 ;Set delta-X and -Y for each char.
	GW G.LEA,GRESIZ,G.LLA,0 ;Set initial X and Y positions (stored later)
		AVLWDD,,DISJMP	;Draw wholine and come back (via DDDRET)
		ASCID / 
/
		GW G.LWM,0,G.LUM,12     ;Write tall characters
>;IFN FTGRIN
↑DDWMES:	1		;PATCH HERE TO DISPLAY OTHERS
		ASCID /                                 Take Me I'm Yours!
/
		0

AVLWDD:
IFN FTGRIN,<	GW G.ERS,0,G.NOP,0	;Always erase available Grinnell first
		ASCID / LOAD DM GR JB,TCOR  R,RCOR UCOR  NL DQ DSKF
/
>;IFN FTGRIN
IFE FTGRIN,<
		ASCID / LOAD DM V DD JB,TCOR  R,RCOR UCOR  NL DQ DSKF

/
>;IFE FTGRIN
		COMDD,,DISJMP

IFE FTGRIN,<
↑DDUNMS:	ASCID /Q:                          No DD channels left; type ESC CALL to wait for one.
/
>;IFE FTGRIN
		0
↑LWHDDQ←←5	;Max number of DD lines we can display as in DD channel queue

;SYSINI DIDDLES DDDME2 AND DDDME3 TO INDICATE THE TIME SYSTEM IS COMING UP
↑DDDMES:	ASCID /                         /
↑DDDME2:	ASCID /          System Is Down!/ ;Put 1 into 1st 2 words to shift
↑DDDME3:	REPEAT LUPMSG,< 1 >	;PLACE FOR MESSAGE ABOUT WHEN WE COME UP
		ASCID /
/
		0
;DDSTRS DDSTRB DDSTRD DDSTRL DPYHLD GHEAD GPOGH GERS TITLE WTEND WTTYS WSEG WHFILE WLINK DMWCOP

IFN FTGRIN!FTDD,<
↑DDSTRS:
IFE FTGRIN,<	CW 1,66,2,0,3,2
		CW 3,2,4,1,5,11
>;IFE FTGRIN
IFN FTGRIN,<
	GW G.LDC,0,G.LSM,0	;Channel and subchannel masks inserted here
↑DDSTRB:GW G.LWM,1,G.LUM,12	;Write mode and update mode for Grinnell
↑DDSTRD:GW G.LEB,GRESIZ,G.LLB,0 ;Set delta-X and -Y for each char
↑DDSTRL:GW G.LEA,GRESIZ,G.LLA,0	;Set initial X and Y positions (stored later)
>;IFN FTGRIN
		ASCID /   ************ →HOLDING← ************   /
IFE FTGRIN,<	CW 0,0,3,2,3,2
>;IFE FTGRIN
		0

↑DPYHLD:	77,,DISSEL
		LVW (-600,660,I,A,2,2)
		ASCID /   ************ →HOLDING← ************/
		0
>;IFN FTGRIN!FTDD

IFN FTGRIN,<
;GENERAL-PURPOSE GRINNELL PROGRAM
;MUST BE SET UP FROM SCRATCH EACH TIME
GHEAD:	0	; G2W <LWM{!WMR}>,<LUM!UMEAB!UMLNC>
	0	; G2W <LEB!7>,<LEC!7>
	0	; G2W <LLB!=12>,<LLC!=48>
	DISJMP	; JUMP TO DDCW(DAT) (OR WHEREVER)

; USER DPY TRANSFERS FOR GRINNEL START HERE TO SET UP VARIOUS PARAMETERS
GPOGH:	0	;<GW G.LDC,0,G.LSM,0>      ;Channel and subchannel masks inserted here
	0	;<GW G.LWM,1,G.LUM,12>     ;Write mode and update mode for Grinnell
	0	;<GW G.LEB,GRESIZ,G.LLB,0> ;Set delta-X and -Y for each char.
	0	;<GW G.LEA,GRESIZ,G.LLA,0> ;Set initial X and Y positions (stored later)
	0	; HALT INSTRUCTION

GERS:	0	; G2W <GLLA!XXX>,<GLEA!0>
	0	; G2W <GLLB!XXX>,<GLEB!1777>
	0	; G2W GEGW,GNOP
>;IFN FTGRIN

;MODEL WHO LINE BLOCK (COPIED INTO FREE STORAGE)
↑TITLE:
IFE FTGRIN,<	0		;III JSRs to here.  FOR DD, COMMAND WORD GOES HERE
		BYTE(11)<-1000>,740(3)2,2(2)1,2(3)3 ;III POSITION WORD.  DDs PUT CMD WORD HERE
>;IFE FTGRIN
IFN FTGRIN,<
	GW G.LDC,0,G.LSM,0      ;(GWCOFF) Channel and subchannel masks inserted here
	GW G.LWM,1,G.LUM,12     ;Write mode and update mode for Grinnell
	GW G.LEB,GRESIZ,G.LLB,0 ;(DLTOFF) Set delta-X and -Y for each char.
	GW G.LEA,GRESIZ,G.LLA,0 ;(POSOFF) GW stored here to set X and Y positions
>;IFN FTGRIN
		COMDD,,DISJMP	;IIIs get a no-op deposited here.
↑WTEND←←.-TITLE
↑WTTYS:		REPEAT 6,<ASCID/     />	;SPACE FOR FIRST PART OF USER WHO LINE
		ASCID /  P        -             -              / ;8 wds w/constants
↑WSEG←←.-TITLE	REPEAT 4,<12>		;SPACE FOR SEGMENT NAME AND ALIAS
↑WHFILE←←.-TITLE   1↔1			;SPACE FOR TWO DEVICE DEPENDENT WORDS
		REPEAT 7,<1>		;SPACE FOR FILENAME AND USET POINTERS
		ASCID /
/					;CRLF TO FINISH USER LINE
↑WLINK←←.-TITLE
		0	;DD HALT.  FOR III, A JMP TO TITLE GETS PUT HERE

;DM user's previous wholine copied here by WHOSER to see if changed.
↑DMWCOP:	BLOCK WLINK-WTEND
;COMIII WHOSEL COMDD COMWHO LCOMNL LCOMDM DDDRT1 DDDRET

;DISPLAY SUBROUTINE FOR SYSTEM DATA ON FIRST LINE OF WHO LINE
;FOR III WHO LINE, COMIII IS CALLED FROM THE HOLDING MESSAGE.
↑COMIII:	BYTE(11)<-1000>,770(3)2,2(2)1,2(3)3	;III POSITION WORD.
↑WHOSEL:	770000,,DISSEL	;HERE WE SELECT WHICH III'S GET THE SYSTEM WHO LINE
↑COMDD:				;DDD PROCESSOR ENTRY POINT
↑COMWHO:ASCID/ 0.00 xx x+xx xx,xxxx xx,xxxx xxxxP 99%xx xxxxx mon dd /
	ASCID/wednesday⊗ xx:xx 120F -10C    
/ ;CONSTANTS IN SYSTEM LINE (4 extra spaces to erase DM line when date changes).
  ;In above COMWHO, lower case letters are variable and "⊗" means null goes there.
↑LCOMNL←←2	  ;Number of nulls at end of system wholine text
↑LCOMDM←←.-COMWHO ;Length of system part of wholine for DMs
IFE FTF2,<
		DISKPN		;SKIP ALWAYS, IF III
		DDDRT1,,DISJMP	;DD jumps to label below
		0		;III HALTS HERE
;*** RPH PATCH TO CATCH LOSING DP
		.+1,,24
		0
		.-2,,20
;END PATCH
DDDRT1:		CW (3,2,3,2,3,2);SELECT COL 2.  DISKPN ISN'T QUITE A NO-OP ON DDD!
>;IFE FTF2
↑DDDRET:	DISJMP		;DD JMP TO USER LINE OF WHO LINE.  ADR PLACED IN LH
IFN FTF2,<
;TTWHSY in TTYSER needs 0 word following system wholine.  Putting it here is OK,
;since DISJMP is a non-text word and will be skipped.
		0
>;IFN FTF2

comment \
What COMWHO looks like....
  "⊗" means null goes there;
  The day of the week is only thing deposited specially.

Byte numbers (within COMWHO, ref'd by WHOSBP macro in WHOSER):
00000000001111111112222222222333333333344444444445555555555666666666677777777778888888888
012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789

 0.00 xx x+xx xx,xxxx xx,xxxx xxxxP 99%xx xxxxx mon dd wednesday⊗ xx:xx 120F -10C    
11.03 10 0-31 63,9999 62,8888 4444P 10% 0 12345 Mar 14 Wednesday 00:35 100F -19C

end of comment \
;MPXTAC MPXDDR MPXSTP MPXRST MPXCNI MPXDTI MPXZER MPXENB MPXDTO MPXJOB MPXZND LMPXDTO

IFN FTMPX,<	;Whole page

BEGIN MPXDAT  -  DATA AREA FOR MAPPIPLEXOR

↑MPXTAC:0
↑MPXDDR:0		;FLAG TO DPYSER THAT DD GOT MPX ACCESS VIOLATION
↑MPXSTP:0		;FLAG FOR MPXINT
↑MPXRST:BLOCK 8		;-1 IF SHOULD RESET THIS DEVICE
↑MPXCNI:0		;CONI MPX AT MPXINT
↑MPXDTI:0		;DATAI MPX AT MPXINT

↑MPXZER::		;ZERO FROM HERE TO MPXZND AT INITIALIZATION
↑MPXENB:BLOCK 8		;-1 IF MAPPING ENABLED FOR DEVICE
↑MPXDTO:BLOCK 8		;LAST MPX DATAO FOR EACH DEVICE
↑MPXJOB:BLOCK 8		;JOB NUMBER THAT GOES WITH THE PAGE TABLE
↑MPXZND←←.-1
↑LMPXDTO:0		;LAST OF ALL THE MPX DATAOS

BEND MPXDAT

>;IFN FTMPX	;Whole page
;WTQK3

IFN ELFNUM,<
;Patchable no-op code to delay fast ELF output loop just enough.
;Here from WTQK2 in ELFSER.
↑WTQK3:	JFCL
	JFCL
	JRST WTQK2	;for now two JFCLs and a JRST are enough
	JRST WTQK2	;may want to slow down a little more someday
	JRST WTQK2
>;IFN ELFNUM
;PATCH PATEND
INTERN PATCH,PATEND
;PATCH - PATCH AREA FOR T. S. MONITOR

↑PATCH:	BLOCK 200
↑PATEND←←.-1
;DDB.CHAIN.DEFS

Comment ⊗  Here we make the definitions that link the DDBs into a nice chain.
DDB.CHAIN.DEFS:	;For E

This must come after all DDBs have been defined, so that we know when ones
exist UNDER THE CURRENT ASSEMBLY SWITCHES.  Note that no assembly switches
need be referenced on this page because of the way this is done, using
IFDEF to figure out which devices exist in the current configuration.
However, this means that a misspelling of a device name here, or the
failure of the name of the device's DDB to conform to the below standard
naming convention will cause the device chain to be screwed up, probably
omitting the screwed up device.

This page defines the order of devices in the chain, except that multiple
units of the same device always appear together and are so linked by the
code in the DDB definition.  For every device XXX, the last unit of that
device is linked to the DDB called XXX.NX, which is defined here.

The list below shows the devices in reverse order from that of the chain.
Only the first unit of each device is listed, as that is the unit that
the previous device must be linked to.  It is assumed that the name of
each DDB is made by appending "DDB" to the entry in the list below.

Note that there is probably some code (DEVCHK,...) that assumes that
devices DSK and UDP come first and other code (?) that assumes that
TTYs are last.  Also, the RESO code may try to do reasonable printing
by inserting CRLFs at specific devices.  Otherwise, the devices should
be permutable simply by changing the order below.  Mirabile dictu.

end of comment ⊗

NXT.NX ←← 0	;"Next" pointer for last device is null.
	;NOTE: Devices here are in REVERSE ORDER from the chain.
FOR @! DEV IN (SCN,VDJ,SIX,DAC,RTJ,POL,SAM,KIM,ADC,MTU,MTC,DTC,NUL,ELF,GRN,<ARM>
	       ,TV,CAR,PTP,PLT,PTR,VRN,XGP,LPT,DLN,DOM,IMP,PUP,UDP1,DSK)
{
    IFDEF DEV!DDB <
	DEV!.NX ←← NXT.NX
	NXT.NX ←← DEV!DDB
    >
}
;All that comment for such little FAIL code.  But read it!
