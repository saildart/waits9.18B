COMMENT ⊗   VALID 00015 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	 MTDC SEL IOSEOF IODT IOSLIC HASMT ERSLIC IOREW MTREDO SLICE SLEVEL ICR RDY ERF PER LPE RCE MIS TWL EFF BCT TLR TLP TEP RWD XNC LIF DCS ILC
C00013 00003	 MDUMP MIND MNZNOR MNZKLU MICFLG MICEOF MICTPE MICLNE HDWNLN HDWREW HDWFPT HDWBOT HDWRDY HDWEOT MTDOOP REWND WRTEOF FSPREC BSPREC WRTGAP FSPFIL BSPFIL MSETXX MSETAB
C00019 00004	 MTCDSP MTCREL
C00021 00005	 MTREWW REWLP REW0 REW2 REW3 MTCLOK MTCLK REWCK
C00027 00006	 DETMDC DETDC MTCXX1 MTCHEK MTCXXX MTCXX2 MTCHK2 MTCHK4 MTCHK5 QSTAT
C00033 00007	 MTAPEU MTAPE MTAPE2 NOSET MTGO1 MTGO2 MTXCT MTLEOT MTEOT2 SETRET
C00042 00008	 MTIN MTIN0 MTIN1 MDRT1 MTINDC MTINDD MTOUT MTOUT0 MTOUT1 MDWT1 MTNOPO MTNOP1 MTOUTE
C00055 00009	CLOSE OUTPUT  MTCLSO MTCINI MTHUNG
C00058 00010	 MTDCN1 MTDCN2 MTDCN3
C00062 00011	 MTCINT MTXNC MTNIO2 MTFIN MTNIO0 MTNIO1 ETCHK
C00066 00012	 MTEOR MTEORA MTEOR0 MTEOER MTEORI MTEORX MTEOR1 MTEOR2 MTERR MTERR0 MTERR1 MTERR2 MTERR3 MTERR4 MTPDUN DARTRS MXMIS MTPDU2 MTNOTI MTCONN MTEOFD MTEOF MTEND1 MTERST
C00086 00013	dump mode IO  MTDMPI MTDMPO MTDMP0 MTDMP1 MDRTRY MTDMP2 DMPDUN DMPDU1
C00092 00014	 F2MTGO F2MTWR F2BKTL F2MTRD F2MTER F2MTRX F2MBLW F2MBLR F2MTPG F2MTP2
C00099 00015	 MTUOUT MTUOU0 MTUNOP MTUIN MTUIN0 MTUBGO MTUGO MMTAP2 MT78ER MTUDI MTUDO MTUD2 MTUD3 MTUWCK MTUDX2 MTDDUN MTDDU1 MTUEOF MTUEO2 MTUFIN MTBDUN MTBDUZ MTBDUO MTUCON MTTDUN MTUCLO MTUINI MTUREL NOPBOT MMTDSP MTWEF MTSFR MTSBR MDMTP NMTAPE SELMOD SELMO2 MODCAP MMTAPE MMTAP0 MUWAIT UQSTAT MTUREW UREWLP UREW0 UREW2 UREW3 MTUCLK MTUCLP UREWCK MTUBFL MTUFFL MTUBF3 MTUEOT MTUUEO MTUDSP MTUHNG MTUBCK
C00135 ENDMK
C⊗;
;⊗ MTDC SEL IOSEOF IODT IOSLIC HASMT ERSLIC IOREW MTREDO SLICE SLEVEL ICR RDY ERF PER LPE RCE MIS TWL EFF BCT TLR TLP TEP RWD XNC LIF DCS ILC
IFN MTCNUM,<

BEGIN	MTCSER ↔ SUBTTL	MTCSER - MAGNETIC TAPE ROUTINES FOR PDP-6(516)
;	25-JUL-68 FROM DEC MTCSR6 OF 7-MAY-68

Comment ⊗ How MTCSER works:

Code in MTCSER runs at various different PI levels: UUO level, CH7, CH4, CH1.
    Data transfers are in CH1.
    Setting up of next operation or data transfer occurs in
	CH4 or UUO level generally.
    Hung timeout occurs in CH7.
    Calls to routines MTXCT and MTERST will return when the next
	MTC interrupt occurs, in CH4.  Thus these routines may
	change the PI level, e.g., from UUO level to CH4.

CH4 interrupts from MTC dispatch to the address in MTIDSP; see MTCINT.

Pieces of code are marked by comment lines that identify what PI level(s)
the code runs in.  These comment lines all start with ";**" followed by
one or more or "CH1", "CH4", "CH7" and "UUO", representing the PI levels
the code is capable of running in.  For instance,

;** CH4 CH7 UUO

means the LINE OF CODE IMMEDIATELY FOLLOWING runs in CH4, CH7 and UUO level.

;;NOTE: On the F2, all the code runs at UUO level only, despite CH4 comments!

end of comment ⊗


Comment % The hardware

MTC CONO BITS:
Function codes are:
	00 = NO OPERATION 
	01 = REWIND
	02 = WRITE
	03 = WRITE END-OF-FILE
	04 = READ-COMPARE (NOT USED)
	05 = READ
	06 = SPACE FORWARD RECORD
	07 = BACKSPACE RECORD
	10 = NO OPERATION (NOT USED)
	11 = REWIND AND UNLOAD (SAME AS REWIND AT STANFORD)
	12 = READ ACROSS RECORD (NOT USED)
	13 = WRITE THREE INCHES (APPROX) OF MAG TAPE
	14 = WRITE WITH LONG EOR (NOT USED)
	15 = READ BACKWARD (NOT USED)
	16 = SPACE FORWARD FILE
	17 = BACKSPACE FILE

Density Codes are:
	0 = 200 BPI
	1 = 556 BPI
	2 = 800 BPI
	3 = 556 BPI

Parity is:
	0 = EVEN
	1 = ODD

Slice level:
	0 = HIGH (NORMAL)
	1 = LOW	(new default, 7/87, since most tapes are old)

Magtape Control information.
Stanford 516 Magtape Controller, 521 interface, 570 Magtape drives

Device 220	MTC
Bit	CONO		CONI
18	unused		RD FER		False end of record
19	unused		WT EWC		Write Clock Enable
20	Slice level
21	Parity
22	density
23	density
24	function-8
25	function-4
26	function-2
27	function-1
28	pool 				Hold (don't pool) after completion
29	unit-4				Software Unit number comes from PUNIT
30	unit-2
31	unit-1
32	EOR 1 disable			maintenance only
33	PIA-4
34	PIA-2
35	PIA-1

Device 224	MTS
Bit	CONO 		CONI
18	INT CLR		CS ILC		Initial-Clear / Illegal command
19	unused		MD DCS		Motion Stop delay in progress
20	LIE		MD LIF		Load point interrupt Enable/Bit
21	XNE		CS XNC		Transfer next command Enable/Bit
22			T Rewinding
23			T End Point
24			T Load Point
25			TLR Last	Last operation was a Write
26			TFR A/B work	Local ∨ other controller is using this unit
27			EFF		End of File Flag
28			T Write Lock
29			RD MIS		Missed character
30			RD RCE		Read compare error
31			RD LPE		Long. Parity Error
32			PER		Lat. Parity Error
33	EFE		MD ERF		End of Record Flag Enable/Bit
34	Prog JNU	ST Ready	Tape Unit Ready
35	ICE		MD ICR		Interface & Control Enable/Ready

Device 230	MTM
Note--All CONO bit are ignored, however the CONO itself causes a programmed
CHP pulse to occur.

Bit			CONI
18			CS UPS		Up to speed
19			CS RIP		Record in Progress
20			CS ERM		End of record motion delay in progress
21			CS CON		Motion Continue Selected
22			CS CHF		Command Hold buffer Full
23			CS UNS		Unit selected new command
24			CM Function-8	Final function register
25			CM Function-4
26			CM Function-2
27			CM Function-1
28			CM Unit-4	Final Unit register
29			CM Unit-2
30			CM Unit-1
31			MD MOD		
32			RD FCD
33			RD ERD		Read End of Record delay
34			RD MCD
35			WT EWD		End of record Write delay

%


MTDC←←2		;MAG TAPE DATA CONTROL DEVICE NUMBER
SEL←←2		;UNIT TO COMMAND BUFFER (CALLED "PROGRAMMED JNU" IN H-516)

IOSEOF←←  4000	;SPACING ONE RECORD FORWARD FOUND EOF
IODT←←   10000	;SET FOR A DATA TRANSFER TYPE COMMAND (JOB HAS DC)
IOSLIC←← 20000	;A 1 IF SLICE LEVEL IS 1, OTHERWISE 0.
HASMT←←  40000	;SET FOR THIS JOB HAS THE MAG TAPE CONTROL
ERSLIC←←100000	;SET WHEN IOSLIC IS SET DUE TO READ-ERROR RECOVERY ATTEMPT.
IOREW←← 400000	;SIGN BIT.  SET WHILE OPERATION IS PENDING THE FINISH OF REWIND


↑MTREDO←←=7	;default NUMBER OF TIMES TO RETRY ON ERRORS

SLICE←←40	;SET SLICE LEVEL FROM SLEVEL - BIT IN MTAPE
SLEVEL←←20	;SET SLICE LEVEL TO THIS VALUE IF SLICE IS SET. - BIT IN MTAPE

;STATUS BITS IN MTS.  * MEANS CAUSES INTERRUPT WHEN ENABLED.
;NAMES ARE TAKEN FROM "MAGNETIC TAPE CONTROL 516 INSTRUCTION MANUAL" H-516

ICR←←1B35	;* INTERFACE AND CONTROL READY
RDY←←1B34	;  TAPE TRANSPORT READY
ERF←←1B33	;* END OF RECORD FLAG
PER←←1B32	;  LATERAL PARITY ERROR
LPE←←1B31	;  LONGITUDINAL PARITY ERROR
RCE←←1B30	;  READ COMPARE ERROR (NOT USED)
MIS←←1B29	;  TAPE MISSED CHARACTER
TWL←←1B28	;  TAPE WRITE-ENABLE LOCKOUT RING OUT
EFF←←1B27	;  END-OF-FILE SENSED
BCT←←1B26	;  OTHER COMPUTER USING TRANSPORT OR IN LOCAL
TLR←←1B25	;  LAST OPERATION WAS A WRITE (NOT USED)
TLP←←1B24	;  TAPE AT LOAD POINT
TEP←←1B23	;  TAPE AT END POINT
RWD←←1B22	;  TRANSPORT IS REWINDING
XNC←←1B21	;* TRANSFER NEW COMMAND
LIF←←1B20	;* LOAD POINT INTERRUPT FLAG (NOT USED)
DCS←←1B19	;  DATA CONTROL SELECTED (NOT USED)
ILC←←1B18	;  ILLEGAL COMMAND:
		;     WRITE OR WEF ON A WRITE-LOCKED TAPE
		;     BACKSPACE RECORD, BACKSPACE FILE, OR READ
		;	BACKWARDS WHILE AT BEGINNING OF TAPE
		;     ANY OPERATION ON A TRANSPORT BEING USED
		;	BY THE OTHER COMPUTER

;⊗ MDUMP MIND MNZNOR MNZKLU MICFLG MICEOF MICTPE MICLNE HDWNLN HDWREW HDWFPT HDWBOT HDWRDY HDWEOT MTDOOP REWND WRTEOF FSPREC BSPREC WRTGAP FSPFIL BSPFIL MSETXX MSETAB

IFN FTF2,<

; MTOP CODES

MDUMP←←51		; ENTER DUMP (NORMAL) MODE
MIND←←50		; ENTER INDUSTRY-COMPATIBLE (?) MODE
MNZNOR←←61		; PUT IT IN NORMAL MODE
MNZKLU←←60		; PUT CONTROLLER IN NRZI KLUDGE MODE

;MICROCODE TAPE STATUS BITS RETURNED IN LH AC AFTER MTRD AND MTWR and MTOP IOTS
MICFLG←←400000		;SOME FLAG IS BEING RETURNED BY THE MICROCODE
MICEOF←←200000		;EOF SEEN FLAG FROM MICROCODE
MICTPE←←100000		;TAPE PARITY ERROR FLAG FROM MICROCODE
MICLNE←←040000		;LENGTH ERROR FLAG FROM MICROCODE

;HARDWARE STATUS BIT DEFINITIONS RETURNED IN RIGHT HALF BY MTRS
HDWNLN←←000040		;UNIT IS ONLINE
HDWREW←←000020		;UNIT IS REWINDING
HDWFPT←←000010		;UNIT IS WRITE PROTECTED
HDWBOT←←000004		;UNIT IS AT LOAD POINT
HDWRDY←←000002		;UNIT IS READY
HDWEOT←←000001		;UNIT IS AT END OF TAPE


;ACTUAL MAGTAPE CONTROL ROUTINE.  CALLED WITH OP-CODE IN bits 24:27 of J.
; ONLY CALLED AT UUO LEVEL FROM MTAPE UUO
MTDOOP:	CAIE J,1B27		;REWIND?
	CAIN J,11B27		;OR REWIND-UNLOAD?
	JRST REWND		;YES, SAME FOR BOTH SINCE DRIVE WON'T UNLOAD
	CAIN J,3B27		;WRITE END OF FILE?
	JRST WRTEOF		;YES
	CAIN J,6B27		;FORWARD SPACE RECORD?
	JRST FSPREC		;YES
	CAIN J,7B27		;BACK SPACE RECORD?
	JRST BSPREC		;YES
	CAIN J,13B27		;WRITE GAP?
	JRST WRTGAP		;YES
	CAIN J,16B27		;FORWARD SPACE FILE?
	JRST FSPFIL		;YES
	CAIN J,17B27		;BACK SPACE FILE?
	JRST BSPFIL		;YES
;	CAIN J,20B27		;READ RECORD?
;	JRST MTREAD		;YES
;	CAIN J,21B27		;WRITE RECORD?
;	JRST MTWRIT		;YES
	PUSHJ P,BUGTRP		;Ain't ever supposed to fall through, actually!
	JRST MTFIN		;RETURN AND UPDATE STATUS

;REWIND AND REWIND-UNLOAD
REWND:	MTOP TAC,0		;EXECUTE REWIND
	JRST MTFIN		;DONE, RETURN AND UPDATE STATUS

;WRITE EOF
WRTEOF:	MTRS TAC		;FETCH HARDWARE STATUS BITS TO TAC
	TRNN TAC,HDWFPT		;IF NOT WRITE ENABLED IN HARDWARE, THIS IS NO-OP
	MTOP TAC,1		;ELSE DO IT, OP CODE #1
	JRST MTFIN		;RETURN AND UPDATE STATUS

;FOWARD SPACE RECORD
FSPREC:	MTOP TAC,5		;SKIP RECORD AND GET STATUS TO TAC
	TLNE TAC,MICEOF		;EOF SEEN?
	TDO IOS,[IOSEOF,,IODEND] ;SET IOS BITS TO SHOW END OF FILE
	JRST MTFIN		;UPDATE STATUS AND RETURN

;BACK SPACE RECORD
BSPREC:	MTOP TAC,6		;BACK SPACE RECORD
	JRST MTFIN		;UPDATE STATUS AND RETURN

;WRITE GAP
WRTGAP:	JRST MTFIN		;THIS IS CURRENTLY A NO-OP ON THE F3A

;FORWARD SPACE FILE
FSPFIL:	MTRS TAC		;GET STATUS TO TAC
	TRNE TAC,HDWRDY		;GONE UNREADY?
	TRNN TAC,HDWNLN		;OR GONE OFFLINE?
	JRST MTFIN		;YES, QUIT NOW
	MTOP TAC,5		;SKIP FILE AND GET STATUS TO TAC
	TLNN TAC,MICEOF		;EOF SEEN?
	JRST FSPFIL		;NO, KEEP LOOKING
	JRST MTFIN		;UPDATE STATUS AND RETURN

;BACK SPACE FILE
BSPFIL:	MTRS TAC		;GET STATUS TO TAC
	TRNE TAC,HDWBOT		;AT LOAD POINT?
	JRST MTFIN		;YES, DO NOTHING
	MTOP TAC,6		;BACK SPACE RECORD AND GET STATUS TO TAC
	TLNN TAC,MICEOF		;EOF SEEN?
	JRST BSPFIL		;NO, KEEP LOOKING
	JRST MTFIN		;UPDATE STATUS AND RETURN

MSETXX:	PUSHJ P,MTCHK2		;MAKE SURE SYSTEM IS AVAILABLE. (J IS PRESERVED)
	XCT MSETAB-100(UUO)	;DO FUNCTION FROM CODE IN USER'S UUO
	JRST MTFIN		;SHOULDN'T HAPPEN.

MSETAB:	MTOP MDUMP		;100 - PUT IT IN DUMP MODE
	MTOP MIND		;101 - PUT CONTROLLER IN INDUSTRY COMPATIBLE MODE
	MTOP MNZNOR		;102 - PUT IT IN NON-KLUDGE MODE
	MTOP MNZKLU		;103 - PUT CONTROLLER IN NRZI KLUDGE MODE

>;IFN FTF2
;⊗ MTCDSP MTCREL

;MTCDSP - DISPATCH TABLE, MTCREL - RELEASE UUO

	JRST MTCINI		;INITIALIZATION
	JRST MTHUNG		;HUNG TIMEOUT.  RELEASE DC, MTC, PRINT ERROR.
↑MTCDSP:JRST MTCREL		;RELEASE
	JRST MTCLSO		;CLOSE OUTPUT
	JRST MTOUT		;OUTPUT
	JRST MTIN		;INPUT
	JRST CPOPJ1		;ENTER IN DIRECTORY
	JRST CPOPJ1		;LOOKUP IN DIRECTORY
	JRST MTDMPO		;DUMP OUTPUT
	JRST MTDMPI		;DUMP INPUT
	POPJ P,			;SETO
	POPJ P,			;SETI
	POPJ P,			;GETF
	JRST CPOPJ1		;RENAME
	POPJ P,			;CLOSE INPUT
	POPJ P,			;UTPCLR
	JRST MTAPEU		;MTAPE UUO

;** UUO
MTCREL:	PUSHJ P,WAIT1		;WAIT FOR IOACT TO BE OFF.
	MOVE IOS,[ERSLIC!IOSLIC,,-1]
	ANDCAB IOS,DEVIOS(DDB)	;FLUSH LOTS OF BITS
IFN FTF2,<
	MTOP MDUMP		; PUT US BACK INTO DUMP MODE
	MTOP MNZNOR		; TAKE US OUT OF NRZI KLUDGE MODE
>;IFN FTF2
IFE FTF2,<
	SETOM MTCLSR(DDB)	;clear length of last short record read
>;IFE FTF2
	MOVEI TAC,MTREDO	;re-initialize retry count for this tape drive
	MOVEM TAC,MTCRET(DDB)	;store new retry count
	POPJ P,
;⊗ MTREWW REWLP REW0 REW2 REW3 MTCLOK MTCLK REWCK

;COUNT THE NUMBER OF UNITS THAT ARE WAITING FOR REWIND

;** CH4 CH7 UUO
MTREWW:	SETOM MTREWN		;SET COUNT TO NO. UNITS IN REW WAIT
	PUSH P,IOS
	PUSH P,DDB
	MOVEI DDB,MTCDDB	;GET BEGINNING OF MT DATA BLOCK CHAIN
;** CH4 CH7 UUO
REWLP:	MOVE IOS,DEVIOS(DDB)
	JUMPGE IOS,REW2		;is unit in a rewind wait (IOREW on)?
	PUSHJ P,REWCK		;YES,SEE IF FINISHED REW.
	 JRST .+3		;HAS FINISHED REWINDING
	 JRST .+2		;OFF.  WAKE HIM UP TO MAKE HIM LOSE.
	JRST REW0		;STILL REWINDING 
	TLZ IOS,IOREW		;NO LONGER IN REWIND WAIT.
	TLZE IOS,IOW		;SKIP UNLESS WE NEED TO WAKE HIM UP
	PUSHJ P,SETIOD		;START JOB UP AGAIN
	MOVEM IOS,DEVIOS(DDB)
	JRST REW2

;** CH4 CH7 UUO
REW0:	AOS MTREWN		;INCREMENT COUNT OF REW WAIT UNITS
REW2:	HLRZ DDB,DEVSER(DDB)	;LINK TO NEXT DDB
	JUMPE DDB,REW3		;LAST DDB?
	HRRZ DAT,DEVSER(DDB)	;NO. GET DEVICE SERVICE ROUTINE ADDRESS
	CAIN DAT,MTCDSP		;IS THIS A MAGTAPE?
	JRST REWLP		;YES. CONTINUE
REW3:	POP P,DDB
	POP P,IOS
	POPJ P,			;YES, DISMISS INTERRUPT OR RETURN TO MTCLOK

;HERE AT CLOCK LEVEL TO SEE IF ANY UNITS IN A REWIND WAIT HAVE FINISHED REWIND

;** CH7
↑MTCLOK:SKIPGE MTREQ		;IS MTC FREE?
	PUSHJ P,MTREWW		;YES.  CHECK ALL MAG TAPE UNITS TO SEE IF ANY THAT
				;WERE IN REWIND WAIT HAVE FINISHED REWINDING.
	SKIPGE MTREWN		;ARE ANY UNITS STILL IN REWIND WAIT?
	POPJ P,			;NO, EXIT WITHOUT REPLANTING CLOCK REQUEST.
;** CH7 UUO
MTCLK:	MOVE TAC1,[$MTCLOK,,JIFSEC/2]		;COME BACK IN HALF A SECOND
	CLKENQ(TAC1)		;Plant clock request
	POPJ P,


;REWCK- CHECK IF UNIT IS REWINDING.
;CALL	MOVE DDB,ADDRESS OF DDB
;	PUSHJ P,REWCK
;	 UNIT READY
;	 UNIT OFF
;	UNIT REWINDING

;THIS CODE REQUIRES THAT A) NO TAPES ARE CURRENTLY IN USE.
;			 B) THE TAPE CONTROL BELONGS TO THE TAPE YOU'RE QUERYING


;** CH4 CH7 UUO
REWCK:
IFN FTF2,<
	MTRS TAC		;GET TAPE UNIT STATUS TO TAC
	TRNN TAC,HDWNLN		;UNIT OFFLINE?
	  JRST CPOPJ1		;  YES, GIVE FAILURE RETURN
	TRNE TAC,HDWREW		;UNIT REWINDING?
	  JRST CPOPJ2		;  YES, PROBABLY NEED TO WAIT FOR IT
	TRNN TAC,HDWRDY		;NOT READY
	  JRST CPOPJ1		;  YES, GIVE FAILURE RETURN
	TRNE TAC,HDWBOT		;NOW AT LOAD POINT?
	  IORI IOS,IOBOT	;YES
	TRNE TAC,HDWEOT		;END POINT?
	  IORI IOS,IOTEND	;YES
>;IFN FTF2
IFE FTF2,<
	LDB TAC,PUNIT		;GET UNIT NUMBER
	ROT TAC,4		;MOVE TO CORRECT POSITION
	CONO MTC,MTCCHN(TAC)	;CONO A NOOP, UNIT, CORRECT PIA.
	CONO MTS,SEL		;JAM UNIT INTO COMMAND BUFFER ("PROGRAMMED JNU")
	CONSZ MTS,RWD		;SKIP IF REWIND MOTION OFF
	JRST CPOPJ2		;RETURN TO CALL+2 IF TAPE REWINDING
	CONSO MTS,BCT		;OTHER COMPUTER USING TRANSPORT, OR IN LOCAL?
	CONSO MTS,RDY		;IS UNIT READY?
	JRST CPOPJ1		;UNIT UNREADY OR UNAVAILABLE
	CONSZ MTS,TLP		;UNIT READY AND AVAILABLE IS IT AT LOAD POINT?
	IORI IOS,IOBOT		;YES.
	CONSZ MTS,TEP		;END POINT?
	IORI IOS,IOTEND		;YES.
>;IFE FTF2
	POPJ P,			;UNIT HAPPY. DIRECT RETURN


COMMENT $
THIS WORKS WITH THE FOLLOWING MOD TO 545 TRANSPORT:

DELETE 1B23K TO ??

ADD	1B16K TO 1B08K		REW(1)(GND) BUFFERED
	1B19S TO 1B08L		FWD/LP(1)(GND)
	1B08N TO 1B23K		(REW(1).OR.FWD/LP(1))

THIS MOD SETS IOB22(1) WHILE MAGTAPE IS REWINDING OR SPACING FORWARD
TO LOAD POINT- IE ENABLES THE PROCESSOR TO DISTINGUISH BETWEEN A
TAPE WHICH IS AT THE END OF A REWIND COMMAND, AND A TAPE WHICH IS
SWITCHED TO LOCAL, OR OFF

ADD	1B08U TO 1B08N		CLAMPED LOAD FOR LOCAL
	1B08R TO 1B10J		LOCAL (-3V)
	1B08S TO 1B15F		SELECT (-3V)
	1B08V TO P1-42		LOCAL STATUS TO OLD POOL STATUS BIT
	P1-42 TO P2-42		ADD THROUGH CONNECTION FOR DRIVES BEYOND

THIS MOD MAKES BIT 26 OF CONI 224,  A ONE IF THE SELECTED
DRIVE IS IN LOCAL.  IT USES A SPARE SECTION OF R111 IN EACH 545
AND LOGIC IN THE 516/521 USED FOR POOLING WITH 570 TAPE DRIVES.
$
;⊗ DETMDC DETDC MTCXX1 MTCHEK MTCXXX MTCXX2 MTCHK2 MTCHK4 MTCHK5 QSTAT

;DETMDC - TURN OFF HASMT.  IF HASMT WAS ON, DETACH MTC, AND CALL DETDC
;DETDC -  TURN OFF IODT, IF IODT WAS ON THEN DETACH DC.

;** CH4 CH7 UUO
DETMDC:	TLZN IOS,HASMT		;THIS JOB HAS MTC?
	JRST STOIOS		;NO (IT DOESN'T HAVE DC EITHER!)
	SETZM MTCUSR		;FLAG THERE IS NO ONE USING MT CONTROL
	SOSL MTREQ		;IS THERE ANYONE ELSE WAITING FOR IT?
	SETOM MTAVAL		;YES.  FLAG TO INDICATE IT IS NOW AVAILABLE.
	SETZM EXPGT+MTCEXP	;GIVE BACK ANY EXEC PAGES.
	SETZM EXPGT+MTCEXP+1
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,MTCEXP⊗9	;CLEAR PAGE TABLE RAM FOR MTCEXP
	BLKO KLPAG,<MTCEXP+1>⊗9	;CLEAR PAGE TABLE RAM FOR MTCEXP+1
>;IFKL10
;** CH4 CH7 UUO
DETDC:	TLZN IOS,IODT		;DOES JOB HAVE DATA CONTROL?
	JRST STOIOS		;NO.
	SOSL DCREQ		;ANYONE ELSE WAITING FOR IT?
	SETOM DCAVAL		;YES.  FLAG AS JUST BECOME AVAILABLE.
	JRST STOIOS

;GET CONTROL OF MTC AND DC.  MAKE SURE TAPE IS READY
;MUSTN'T STORE IOS HERE SINCE INT LEVEL MAY BE RUNNING AND IOS MAY BE STALE
;** UUO
MTCXX1:	PUSHJ P,MTCXXX		;BUG TRAP!
MTCHEK:	PUSHJ P,GETDCMT		;GET DATA AND MAG TAPE CONTROLS
	 AOSE MTREQ		;ARGUMENT
	SKIPE MTCUSR		;SKIP IF THERE REALLY IS NOONE USING MTC
	JRST MTCXX1		;BUG TRAP
	PUSH P,JOB
	POP P,MTCUSR
	MOVE IOS,DEVIOS(DDB)
	TLO IOS,IODT		;FLAG DATA TRANSFER
	PUSHJ P,MTCHK4		;WAIT FOR REWIND
	 JRST MTCHEK		;GET DC & MT AGAIN
	JRST SETACT		;SET DEV. ACTIVE BIT (STORES IOS)

;** UUO
MTCXXX:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /RETURNED FROM GETDCMT OR MTWAIT WITH MTCUSR NON-ZERO.
/
	DEBCHECK(POPACS)
	SETZM MTAVAL		;This is an attempt to fix things
	SYSPIN
	SOSL MTREQ
	SETOM MTAVAL
	POPJ P,

;GET CONTROL OF MTC ONLY.  MAKE SURE TAPE IS READY.
;MUSTN'T STORE IOS HERE SINCE INT LEVEL MAY BE RUNNING AND IOS MAY BE STALE
;** UUO
MTCXX2:	PUSHJ P,MTCXXX
MTCHK2:	AOSE MTREQ		;(THIS IS ALSO ARGUMENT TO MTWAIT)
	PUSHJ P,MTWAIT
	SKIPE MTCUSR
	JRST MTCXX2
	PUSH P,JOB
	POP P,MTCUSR
	MOVE IOS,DEVIOS(DDB)
	PUSHJ P,MTCHK4		;CHECK STATUS
	 JRST MTCHK2		;STATUS LOST.  GET MT AGAIN.
	POPJ P,

;** UUO
MTCHK4:	TLON IOS,HASMT		;THIS JOB NOW HAS MTC
	JRST MTCHK5
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /AT MTCHK4 WITH HASMT ALREADY SET IN DEVIOS.
/
	DEBCHECK(POPACS)
;** UUO
MTCHK5:	TLZE IOS,IOBEG		;FIRST OPERATION AFTER INIT 
;	TLZ IOS,IOSLIC		;YES, SET SLICE LEVEL TO 0.
	TLO IOS,IOSLIC		;YES, SET SLICE LEVEL TO 1 (most tapes are old!)
	TLZ IOS,IOREW		;CLEAR MAG TAPE REWINDING
	PUSHJ P,REWCK		;CHECK IF REWINDING?
	 JRST CPOPJ1		;NO - STATUS OK
	 JRST QSTAT		;QUERY STATUS
	PUSHJ P,DETMDC		;REWINDING- DETACH MTC, DC AND TURN OFF IODT & HASMT
	TLO IOS,IOREW+IOW	;SET REWIND WAIT, IO WAIT
	MOVEM IOS,DEVIOS(DDB)	;STORE IOS
	AOSG MTREWN		;ADD 1 TO REWIND WAIT COUNT SKIP IF CLREQ IN
	PUSHJ P,MTCLK		;MAKE A CLOCK REQUEST. THIS IS ONLY UNIT REWINDING
	PUSH P,J		;SAVE J
	LDB J,PJOBN		;GET THE JOB NUMBER OF TAPE OWNER
	MOVNI AC1,IOWQ		;REQUE THIS GUY
	MOVEM AC1,JOBQUE(J)	;TO IOWQ UNTIL MT REWINDS
	PUSHJ P,REQUE		;
	POP P,J			;RESTORE J
	PUSHJ P,WSCHED		;WAIT...
	MOVE IOS,DEVIOS(DDB)
	POPJ P,

;** UUO
QSTAT:	PUSHJ P,DETMDC		;DETACH MTC AND DC
	PUSH P,J
	LDB J,PJOBN		;LOAD UP JOB NUMBER
	PUSHJ P,HNGSTP		;CHECK STATUS (PULL FINGERS OUT, ETC)
	POP P,J
	POPJ P,
;⊗ MTAPEU MTAPE MTAPE2 NOSET MTGO1 MTGO2 MTXCT MTLEOT MTEOT2 SETRET

;THE FOLLOWING MTAPES ARE LEGAL:
C ←←0
C ←←C!1B35	;0 = NO-OP.  WAITS FOR THE CONTROL TO BE FREE, RELEASES IT AND
		;	RETURNS TO THE USER.  THIS PROVIDES THE ONLY WAY FOR A
		;	USER TO WAIT FOR A SPACING OPERATION TO COMPLETE.
		;	(SKIP, BACKSPACE, OR REWIND)
C ←←C!1B34	;1 = REWIND
C ←←C!1B26	;11= REWIND, UNLOAD
C ←←C!1B28	;7 = BACKSPACE RECORD
C ←←C!1B20	;17= BACKSPACE FILE
C ←←C!1B32	;3 = WRITE END OF FILE
C ←←C!1B29	;6 = SPACE FORWARD RECORD
C ←←C!1B21	;16= SPACE FORWARD FILE
C ←←C!1B24	;13= WRITE 3" OF BLANK TAPE
C ←←C!1B27	;10= SKIP TO LOGICAL EOT (PROGRAMMED - SEE MTLEOT)

IFN FTF2,<
;100 - PUT IT IN DUMP MODE
;101 - PUT CONTROLLER IN INDUSTRY COMPATIBLE MODE
;102 - PUT IT IN NON-KLUDGE MODE
;103 - PUT CONTROLLER IN NRZI KLUDGE MODE
>;IFN FTF2
;200:217 set retry count to N-200 (0:17).

;** UUO
MTAPEU:	MOVEI J,1		;CHECK FOR LEGAL MTAPE UUO
	MOVEI TAC,(UUO)		;GET FUNCTION CODE FROM USER'S UUO
	CAIL TAC,200		;200:217 means retry N-200 times on errors
	CAIL TAC,220
	CAIA
	JRST SETRET		;set retry count for read errors
IFN FTF2,<
	CAILE TAC,103		;Too big?
	 JRST UUOERR		;  Yes, complain
	CAIL TAC,100		;100 AND 101 ARE LEGAL ALSO
	 JRST MSETXX		;  SET INDUSTRY COMPATABLE OR DUMP MODE
>;IFN FTF2
	LSH J,(TAC)		;SHIFT BIT ACCORDING TO THE USER'S UUO
	CAIG TAC,17		;SKIP IF FUNCTION CODE OUT OF BOUNDS.
	TRNN J,C		;DID HE SPECIFY A LEGAL CODE ?
	JRST UUOERR		;NO--TYPE MONITOR ERROR MESSAGE.
	PUSHJ P,MTCHK2		;MAKE SURE SYSTEM IS AVAILABLE. (J IS PRESERVED)
	SOJE J,DETMDC		;FOR MTAPE 0 (SYNC WAIT), RELEASE DC&MT STORE IOS AND RETURN
	TRZ IOS,776000		;CLEAR ERROR BITS: IOF, IOACT, IOBOT AND IOTEND.
	SKIPA J,UUO		;CALL MTAPE2
;** UUO
MTAPE:	PUSHJ P,MTCHK2		;CHECK IF MAG TAPE CONTROL AVAIL.
MTAPE2:	TDZ IOS,[IODT!IOSEOF,,IOACT]	;THIS IS NOT A DATA TRANSFER OP.
	TRNN J,SLICE		;SET SLICE LEVEL THIS UUO?
	JRST NOSET		;NO
	TLZ IOS,IOSLIC		;YES, CLEAR LEVEL
	TRNE J,SLEVEL		;SET TO 1?
	TLO IOS,IOSLIC		;YES
;** UUO
NOSET:	LSH J,8			;MOVE CODE TO MT FUNCTION POSITION
	ANDI J,17B27		;LEAVE ONLY THE FUNCTION BITS
	CAIN J,10B27		;LOGICAL EOT?
	JRST MTLEOT		;YES. - THIS FUNCTION IS DONE BY PROGRAM
IFE FTF2,<
	CONSO MTS,TLP		;AT LOAD POINT?
	JRST MTGO1		;NOT AT LOAD POINT.
>;IFE FTF2
IFN FTF2,<
	MTRS TAC		;Get status
	TRNN TAC,HDWBOT		;Unit at load point?
	JRST MTDOOP		;No, go do magtape op
>;IFN FTF2
	CAIE J,7B27		;YES, BACKSPACE RECORD?
	CAIN J,1B27		;NO, REW?
	JRST MTFIN		;AVOID BACKWARDS MOTION WHEN AT LOAD POINT (STORE IOS)
	CAIN J,17B27		;NO. BACKSPACE FILE?
	JRST MTFIN		;YES. AVOID BACKWARDS MOTION FROM LOAD POINT. (STORE IOS)
IFN FTF2,<
	JRST MTDOOP		;Go do F2 magtape op
>;IFN FTF2
IFE FTF2,<
;** CH4 UUO
MTGO1:	LDB TAC,PUNIT		;HERE FOR IO UUOS, AND INTERRUPT FOR NEXT RECORD
	DPB TAC,[POINT 3,J,31]	;FORM COMMAND IN J. STORE UNIT NUMBER.
	LDB TAC,[POINT 3,IOS,28];DENSITY PARITY
	TRNN TAC,7		;NO DENSITY OR PARITY SPECIFIED?
	IORI TAC,STDENS		;YES, USE STANDARD
	XORI TAC,5		;ODD, 556
	DPB TAC,[POINT 3,J,23]
	MOVEI TAC,MTCCHN(J)	;ADD PI CHANNEL TO COMMAND
	TLNE IOS,IOSLIC		;SLICE LEVEL A 1?
	TRO TAC,100000		;YES, SET COMMAND.
	SETZM MTEOFF		;CLEAR EOF FLAG
	HRRZM DDB,MTDEV
	HRLM TAC,MTDEV		;COMMAND,,DDB ADDRESS INTO MTDEV
	MOVEI TAC1,MTNIO2	;ASSUME NON-DATA TRANSFER
	TLNN IOS,IODT		;IS THIS A DATA TRANSFER OPERATION  REQUIRING DC?
	JRST MTGO2		;NO, MUST BE SPACING OPERATION
	CONO DC,@MDCSAV		;YES, ATTACH DC TO MAGTAPE
	CONO PI,DCTON		;TURN DC PI CHANNEL ON
	SETZM MISSED		;CLEAR DATA MISSED FLAG
	MOVEI TAC1,MTXNC	;ON INTERRUPT, GO TO MTXNC
;** CH4 UUO
MTGO2:	PUSH P,TAC1		;SAVE DISPATCH ADDRESS
	PUSH P,TAC
	PUSHJ P,STOIOS		;INIT HUNG COUNT.  THIS IS THE MAIN STORE OF IOS BEFORE MTC BECOMES ACTIVE
	POP P,TAC		;FALL INTO MTXCT
;HERE TO INITIATE THE EXECUTION OF AN MTAPE FOR THE ERROR ROUTINES.
;CALLED FROM I-LEVEL, WITH INTERFACE & CONTROL READY
;** CH4 UUO
MTXCT:	POP P,MTIDSP		;STORE RETURN ADDRESS
	MOVEI TAC1,XNC		;RETURN ON XNC
	SYSPIFF
	CONO MTC,(TAC)		;ISSUE THE OPERATION
	CONO MTS,XNC		;ENABLE THE HARDWARE FOR XNC INT
	HRRM TAC1,MTCCON	;AND THE SOFTWARE
	SYSPIN		;ALLOW INTERRUPTS AGAIN
	POPJ P,			;RETURN TO UUOCON OR DISMISS INTERRUPT
>;IFE FTF2

;LOGICAL END OF TAPE LOOP - IMPLEMENTS  MTAPE 10
;POSITIONS THE TAPE BETWEEN THE TWO EOFS THAT MARK THE EOT.
;THIS CODE IS EXECUTED AT UUO LEVEL

;** UUO
MTLEOT:	MOVEI J,7		;BACKSPACE
	PUSHJ P,MTAPE2		;START COMMAND
	PUSHJ P,MTCHK2		;WAIT FOR COMMAND TO FINISH BY CALLING INTERLOCK.
				;PICKUP IOS WHEN PREVIOUS TASK FINISHES.
;** UUO
MTEOT2:	MOVEI J,16		;SPACE ONE FILE
	PUSHJ P,MTAPE2		;START IT
	MOVEI J,6		;SPACE ONE RECORD
	PUSHJ P,MTAPE		;WAIT FOR SPACE FILE THEN START SPACE RECORD
	PUSHJ P,MTCHK2		;WAIT FOR SPACE RECORD BY CALLING INTERLOCK
				;RETURN WHEN SPACING DONE WITH NEW IOS
	TLNN IOS,IOSEOF		;WAS EOF DETECTED?
	JRST MTEOT2		;NO, RESUME SPACING.
	MOVEI J,7		;PREPARE FOR BACKSPACE MTAPE
	JRST MTAPE2		;BACKSPACE, LOGICAL EOT FOUND RETURN TO CALLER

;Set retry count for tape read errors (actually, sets try count, including 1st try).
;We don't bother interlocking against current read.
SETRET:	SUBI TAC,200		;subtract off the base MTAPE number.
	CAMLE TAC,MTCRMX	;less than maximum retry count?
	MOVE TAC,MTCRMX		;no, use max
	MOVEM TAC,MTCRET(DDB)	;store new retry count
	POPJ P,
;⊗ MTIN MTIN0 MTIN1 MDRT1 MTINDC MTINDD MTOUT MTOUT0 MTOUT1 MDWT1 MTNOPO MTNOP1 MTOUTE

;BUFFERED IO

;** UUO
MTIN:	PUSHJ P,MTCHEK			;INPUT UUO.  IS SYSTEM AVAILABLE?
	TLZ IOS,IO			;SET READING.
;** CH4 UUO
;HERE AT I-LEVEL TO DO NEXT RECORD
MTIN0:	MOVE TAC,MTCRET(DDB)		;get retry count for next record
;	MOVNI TAC,MTREDO
	MOVEM TAC,MTERCN
	TLZE IOS,ERSLIC			;CLEAR SLICE LEVEL SET VIA ERROR RECOVERY
	TLC IOS,IOSLIC			;IF ERSLIC WAS SET, COMPLEMENT IOSLIC
;** CH4 UUO
MTIN1:	HRRZ TAC,DEVIAD(DDB)		;(RETRY FAILED RECORD) GET BUFFER ADDRESS
	XCTR XR,[SETCM TAC,(TAC)]	;-(SIZE+1)-1 IN LEFT HALF.
	HRR TAC,DEVIAD(DDB)		;-SIZE-2,,DATA BUFFER RELATIVE ADDRESS-2
	ADD TAC,[2,,1]			;-SIZE,,RELATIVE DATA ADDRESS-1 = IOWD
IFN FTF2,<
	JRST F2MTGO			;Read it
>;IFN FTF2
IFE FTF2,<
;** CH4 UUO
MDRT1:	MOVEI J,5B27			;READ COMMAND
	MOVE TAC1,[BLKI DC,4000!<MTDC*10>!DCTCHN]	;BLKI,,DC INITIAL CONO
;ALL I/O OPS COME THROUGH HERE TO BE STARTED (OR RETRIED)
;** CH4 UUO
MTINDC:	CONO PI,DCTOFF			;TURN DATA CONTROL PI CHANNEL OFF
	MOVEM TAC,DCWRD			;STORE BLKI/O POINTER
	HRRZM TAC1,MDCSAV		;SAVE DC COMMAND (INITIAL CONO BITS)
	HRRI TAC1,DCWRD			;SET UP ADDRESS PART OF BLKI/O INSTR.
;;	MOVEM TAC1,@DCLOC		;STORE BLKI/O INSTRUCTION
	MOVEM TAC1,MTDIN2		;STORE BLKI/O INSTRUCTION
;;	MOVE TAC1,[JSR MTDCND]
	MOVE TAC1,[JSR MTDINT]		;We JSR to the place where the BLKI/O is
;;	MOVEM TAC1,@DCLOC1		;STORE BLKI/O OVERFLOW INSTR.
	MOVEM TAC1,@DCLOC		;STORE interrupt instruction
	HLRO AC3,DCWRD			;GET -WC
	HRRZ TAC1,DCWRD			;GET FIRST ADDRESS-1
	MOVEI AC1,MTBLK			;ADDRESS TO STUFF PARTIAL IOWDS
	MOVEM AC1,MTBLKP		;INITIAL POINTER TO IOWD LIST
;** CH4 UUO
MTINDD:	MOVEI TEM,777
	ANDI TEM,(TAC1)
	CAIN TEM,777
	MOVNI TEM,1
	SUBI TEM,1777			;-(NUMBER OF WORDS BEFORE END OF 2ND PAGE)
	CAMGE TEM,AC3			;IS MAX WC (TEM) LARGER THAN REMAINING WC?
	MOVE TEM,AC3			;YES, REDUCE IT (THIS IS THE LAST ONE)
	HRLZM TEM,(AC1)			;STORE -WC.
	HRRM TAC1,(AC1)			;STORE ADDRESS-1
	ADDI AC1,1			;INCREMENT COMMAND LIST POINTER.
	CAIL AC1,MTBLKP			;ARE WE STILL IN BOUNDS?
	JRST MTDMP2			;LOSE - GIVE ADDRESS ERROR.
	SUB AC3,TEM			;DECREMENT WC BY THE AMOUNT WE JUST NIBBLED
	SUB TAC1,TEM			;AND ADVANCE THE CORE ADDRESS BY THE SAME
	JUMPL AC3,MTINDD		;LOOP UNLESS WE'RE DONE WITH THIS IOWD
	SETZM (AC1)			;STORE A ZERO TO END THE LIST.
IFE FTMPP2,<
	LDB TAC1,PJOBN
	MOVE TAC1,JBTMAP(TAC1)
	LSH TAC1,9
	MOVEM TAC1,MTCMAP	
>;IFE FTMPP2
IFN FTMPP2,<
	PUSH P,J
	PUSH P,AC1
	LDB J,PJOBN
	MOVEI AC1,MTUEXP		;EXEC VIRTUAL PAGE TO GET UPMP
	PUSHJ P,JOBEVP
	 JFCL
	POP P,AC1
	POP P,J
>;IFN FTMPP2
	MOVE TAC,MTBLK
	ADDI TAC,1			;FIRST CORE ADDRESS
	MOVEM TAC,DCWRD			;SAVE BLKI/O POINTER+1
	LDB TAC,[POINT 9,DCWRD,26]	;AC2←PAGE NUMBER OF FIRST WORD
	MOVEI TAC1,MTCEXP		;NUMBER OF FIRST EXEC PAGE FOR MTC
	DPB TAC1,[POINT 9,DCWRD,26]	;STORE EXEC PAGE NUMBER INSTEAD
	SOS DCWRD			;RE-CONVERT TO IOWD FORMAT
IFE FTMPP2,<
	ADD TAC,MTCMAP			;POINTER TO USER'S PAGE MAP ENTRY
>;IFE FTMPP2
IFN FTMPP2,<
	ADDI TAC,MTUEXP⊗9
>;IFN FTMPP2
	MOVE TAC1,(TAC)
	MOVEM TAC1,EXPGT+MTCEXP		;MAKE EXEC MAP POINT TO USER'S PAGES
	MOVE TAC1,1(TAC)
	MOVEM TAC1,EXPGT+MTCEXP+1
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,MTCEXP⊗9		;CLEAR PAGE TABLE RAM FOR MTCEXP
	BLKO KLPAG,<MTCEXP+1>⊗9		;CLEAR PAGE TABLE RAM FOR MTCEXP+1
>;IFKL10
	IORI IOS,IOACT			;SET IOACT
	JRST MTGO1			;GO START OPERATION
>;IFE FTF2

;** UUO
MTOUT:	PUSHJ P,MTCHEK			;OUTPUT UUO.  IS SYSTEM AVAILABLE
	TLO IOS,IO			;SET WRITING.
IFE FTF2,<
	CONSZ MTS,TWL			;IS FILE PROTECT RING IN?
	JRST MTOUTE			;NO, ERROR CANT WRITE.
>;IFE FTF2
IFN FTF2,<
	MTRS TAC			;GET HARDWARE STATUS
	TRNE TAC,HDWFPT			;WRITE PROTECTED?
	JRST MTOUTE			;YES, ERROR, CAN'T WRITE
>;IFN FTF2
;** CH4 UUO
;HERE AT I-LEVEL TO DO NEXT RECORD
MTOUT0:	MOVE TAC,MTCRET(DDB)		;get retry count for next record
;	MOVNI TAC,MTREDO
	MOVEM TAC,MTERCN
	TLZE IOS,ERSLIC			;CLEAR SLICE LEVEL SET VIA ERROR RECOVERY
	TLC IOS,IOSLIC			;IF ERSLIC WAS SET, COMPLEMENT IOSLIC
;** CH4 UUO
MTOUT1:	HRRZ TAC,DEVOAD(DDB)		;(RETRY FAILING RECORD) GET BUFFER ADDRESS
	XCTR XR,[MOVN TAC1,1(TAC)]	;-WD COUNT
	JUMPE TAC1,MTNOPO		;IF WC=0, DONT DO ANYTHING
	HRL TAC,TAC1			;-WD CNT,BUFFER = -WC,,DATA ADDRESS-2
	ADDI TAC,1			;-WC,,DATA ADDRESS-1 = IOWD
IFN FTF2,<
	JRST F2MTGO			;Write data to MTA
>;IFN FTF2
IFE FTF2,<
;** CH4 UUO
MDWT1:	MOVEI J,2B27			;WRITE COMMAND
	MOVE TAC1,[BLKO DC,3400!<MTDC*10>!DCTCHN]	;BLKO,,DC INITIAL CONO
	JRST MTINDC
>;IFE FTF2

;** CH4 UUO
MTNOPO:	PUSHJ P,ADVBFE			;ADVANCE OVER THE EMPTY BUFFER
	 JFCL				;IGNORE CONTINUE INDICATION
;** CH4 UUO
MTNOP1:	PUSHJ P,ETCHK			;JUST IN CASE
	TLZE IOS,IOW			;UNWAIT THE JOB
	PUSHJ P,SETIOD
	PUSHJ P,CLRACT
	JRST DETMDC			;DETACH EVERYTHING AND RETURN

;** UUO
MTOUTE:	TRO IOS,IOIMPM			;WRITE LOCK, DEVICE ERROR
	JRST MTNOP1			;DETACH DC AND MTC. RETURN TO UUOCON

;CLOSE OUTPUT ;⊗ MTCLSO MTCINI MTHUNG

;CLOSE
;** UUO
MTCLSO:	TLNN DDB,OUTPB		;HAS AN OUTPUT BEEN DONE?
	POPJ P,			;NO. DONT WRITE ON TAPE.
	LDB TAC,PIOMOD		;DUMP MODE?
	CAIGE TAC,DR
	PUSHJ P,OUT		;BUFFERED MODE - OUTPUT LAST PARTIAL BUFFER
	PUSHJ P,WAIT1		;WAIT FOR OUTPUT TO FINISH
	MOVEI J,3		;WRITE EOF
	PUSHJ P,MTAPE
	MOVEI J,3		;WRITE EOF
	PUSHJ P,MTAPE
	MOVEI J,7		;BSP
	PUSHJ P,MTAPE
	LDB J,PJOBN		;RESTORE J AS JOB NUMBER
	POPJ P,


;SYSTEM INITIALIZATION
;** UUO
MTCINI:	SETOM MTREWN		;SET CLOCK REQUEST COUNT TO -1
IFN FTF2,<
	MTOP MDUMP		; SET US IN DUMP (NORMAL) MODE
>;IFN FTF2
NOKL10,<
	MOVEI TAC,40+DCTCHN*2
IFE FTMAOFF,<
	IORI TAC,MATOFF		;INCLUDE OFFSET OF 0 OR 100
>;IFE FTMAOFF
IFN FTMAOFF,<
	CONSZ APR,MAOFF		;TRAP OFFSET?
	IORI TAC,100		;YES, OFFSET ADDRESS
>;IFN FTMAOFF
>;NOKL10
IFKL10,<
	MOVEI TAC,KLEPT+40+DCTCHN*2 ;ADDRESS FOR INTERRUPTS
>;IFKL10
	MOVEM TAC,DCLOC
	ADDI TAC,1
	MOVEM TAC,DCLOC1
	SETZM DEVIOS(DDB)	;A NICE WAY TO START.
	JRST MTNIO1

;HUNG TIMEOUT
;** CH7
MTHUNG:	TLNN IOS,HASMT
	POPJ P,			;HOW DID WE GET HERE IF HE DIDN'T HAVE IT?
IFN FTMTHMESS,<
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF MESSAGE ON CTY
	 SIXBIT /MTA/
	PUSHJ P,DISMES
	ASCIZ/Hung timeout on MTA/
	LDB TAC,PUNIT
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	POPACS
>;IFN FTMTHMESS
	SYSPIFF
	MOVE IOS,DEVIOS(DDB)	;GET CURRENT IOS SINCE INT LEVEL MAY HAVE CHANGED IT
IFE FTF2,<
	CONO MTS,400000		;FLUSH CURRENT COMMAND. STOP/INITIALIZE TAPE CONTROL
	HLLZS MTCCON		;NO MORE INTERRUPTS
>;IFE FTF2
	SYSPIN
IFE FTF2,<
	TLNN IOS,IODT		;DOES HE HAVE THE DATA CONTROL?
	JRST MTNIO0		;NO.  GO CLEAN UP THE STATE OF THINGS
	CONO DC,0		;HOLD DATA CONTROL
	CONO PI,DCTOFF		;SHUT OFF DC
>;IFE FTF2
	JRST MTNIO0		;CLEAN UP STATES OF THINGS
;⊗ MTDCN1 MTDCN2 MTDCN3

IFE FTF2,<	;Whole page

;MTDCN1 - BLK COUNTED OUT (HERE IN CHANNEL 1)

;** CH1
↑MTDCN1:MOVEM TAC,MTTAC		;SAVE TAC
	AOS TAC,MTBLKP		;ADVANCE TO NEXT IOWD IN COMMAND LIST
	SKIPN TAC,(TAC)
	JRST MTDCN2
	MOVEM TAC1,MTTAC1
	ADDI TAC,1		;FIRST CORE ADDRESS
	MOVEM TAC,DCWRD		;SAVE BLKI/O POINTER+1
	LDB TAC,[POINT 9,DCWRD,26]	;TAC←PAGE NUMBER OF FIRST WORD
	MOVEI TAC1,MTCEXP	;NUMBER OF FIRST EXEC PAGE FOR MTC
	DPB TAC1,[POINT 9,DCWRD,26]	;STORE EXEC PAGE NUMBER INSTEAD
	SOS DCWRD		;RE-CONVERT TO IOWD FORMAT
IFE FTMPP2,<
	ADD TAC,MTCMAP		;POINTER TO USER'S PAGE MAP ENTRY
>;IFE FTMPP2
IFN FTMPP2,<
	ADDI TAC,MTUEXP⊗9
>;IFN FTMPP2
	MOVE TAC1,(TAC)
	MOVEM TAC1,EXPGT+MTCEXP	;MAKE EXEC MAP POINT TO USER'S PAGES
	MOVE TAC1,1(TAC)
	MOVEM TAC1,EXPGT+MTCEXP+1
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,MTCEXP⊗9	;CLEAR PAGE TABLE RAM FOR MTCEXP
	BLKO KLPAG,<MTCEXP+1>⊗9	;CLEAR PAGE TABLE RAM FOR MTCEXP+1
>;IFKL10
	MOVE TAC1,MTTAC1
	JRST MTDCN3

;** CH1
;here when last IOWD in command list has run out
MTDCN2:	CONO PI,DCTOFF		;SHUT OFF DC CHANNEL
IFE FTDCBUG,<
	CONSZ DC,10000		;DATA MISSED?
	SETOM MISSED		;YES. OOPS
>;IFE FTDCBUG
IFN FTDCBUG,<
	MOVE TAC,UPTIME		;remember when this was
	MOVEM TAC,DCTMA1 ;+176	;time of last IOWD run out
	MOVE TAC,DCLUZ1	 ;+175	;get bits indicating losses
	LSH TAC,1		;assume no loss this time
	MOVEM TAC,DCLUZ1 ;+175	;bits indicating sequence of wins/losses
	CONI DC,TAC		;get DC status
	MOVEM TAC,DCCON1 ;+174	;remember final DC status
	TRNN TAC,10000		;data missed?
	JRST MTDCN3		;no
	MOVEI TAC,1		;turn on low-order bit to
	IORM TAC,DCLUZ1	 ;+175	;  indicate we lost this time
	AOS DCMIS1	 ;+173	;yes, count number of losses
	MOVE TAC,UPTIME		;and remember time of
	MOVEM TAC,DCTMB1 ;+172	;  last data miss
	SETOM MISSED		;tell someone we lost
	CONI MTS,MTSCN1	 ;+171	;save magtape coni on loss
>;IFN FTDCBUG
;** CH1
MTDCN3:	MOVE TAC,MTTAC
;	JRST 12,@MTDCND		;DISMISS INTERRUPT.
	JRST 12,@MTDINT		;DISMISS INTERRUPT.

>;IFE FTF2
;⊗ MTCINT MTXNC MTNIO2 MTFIN MTNIO0 MTNIO1 ETCHK

IFE FTF2,<	;Most, but not all, of page

;LOW PRIORITY (CH4) INTERRUPTS FROM MTC COME HERE
;** CH4
↑MTCINT:JSR MTCSAV			;SAVE AC'S
	HRRZ DDB,MTDEV			;SET UP DDB POINTER
	LDB J,PJOBN			;JOB NUMBER
	MOVE IOS,DEVIOS(DDB)

;ALL I-LEVEL DISPATCHES BETWEEN MTXNC AND MTFIN ARE FOR NON-DATA OPERATIONS

	HRRZ TAC,MTIDSP			;GET THE DISPATCH ADDRESS
	CAIL TAC,MTXNC
	CAILE TAC,MTFIN
	PUSHJ P,MAPSET			;DATA XFER OP  SETUP MAP.
	PUSHJ P,@MTIDSP			;DISPATCH TO WHOMEVER
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

;HERE ON FIRST INTERRUPT FROM DATA TRANSFER OPERATION (XNC)
;** CH4
MTXNC:	MOVEI TAC,ERF		;ENABLE SOFTWARE FOR ERF - END OF RECORD
	HRRM TAC,MTCCON
	MOVEI TAC,MTEOR		;SET DISPATCH ADDRESS TO MTEOR
	MOVEM TAC,MTIDSP
	CONO MTS,ERF		;ENABLE HARDWARE FOR ERF
	POPJ P,			;DISMISS INTERRUPT

;HERE ON XNC INTERRUPT FROM NON-DATA TRANSFER.
;** CH4
MTNIO2:	PUSHJ P,MTERST		;RETURN WHEN ICR
	HLRZ TAC,MTDEV		;COMMAND
	ANDI TAC,17B27
	CAIE TAC,6B27		;SPACING ONE RECORD?
	JRST MTFIN		;NO.
	CONSZ MTS,EFF		;EOF?
	TDO IOS,[IOSEOF,,IODEND]	;SET IOS BITS TO SHOW END OF FILE
	;Fall thru
>;IFE FTF2
	;Fall thru
;** CH4 UUO
MTFIN:	TLZE IOS,IOW		;CLEAR WAIT
	PUSHJ P,SETIOD
;** CH4 CH7 UUO
MTNIO0:	PUSHJ P,DETMDC		;DETACH MTC (IF HASMT SET) AND DC (IF IODT)
	PUSHJ P,ETCHK		;CHECK FOR END OF TAPE
	PUSHJ P,CLRACT		;RESTORE BITS,CLEAR IOACT
;** CH4 CH7 UUO
MTNIO1:
IFE FTF2,<
	CONO MTS,0		;CLEAR MAG TAPE ENABLES. (HERE FROM MTCINI)
	CONO MTC,MTCCHN		;CLEAR MAG TAPE CONTROL.
	HLLZS MTCCON		;CLEAR THE INTERRUPT MASK BITS.
>;IFE FTF2
	SKIPL MTREWN		;SOME OTHER UNIT REWINDING WITH A COMMAND HELD UP?
	JRST MTREWW		;YES.  SEE IF IT HAS FINISHED REWINDING.
	POPJ P,			;NO, DISMISS INTERRUPT

;** CH4 CH7 UUO
ETCHK:
IFN FTF2,<
	PUSH P,TAC		;Save an AC
	MTRS TAC		;Get status
	TRNE TAC,HDWEOT		;EOT seen?
	IORI IOS,IOIMPM!IOTEND	;YES. SET FLAGS.
	TDZ IOS,[IOREW,,IOBOT]	;NO LONGER REWINDING
	TRNE TAC,HDWREW		;UNLESS
	TRO IOS,IOBOT		;IS REALLY REWINDING
	POP P,TAC		;Restore AC
>;IFN FTF2
IFE FTF2,<
	CONSZ MTS,TEP		;EOT SEEN?
	IORI IOS,IOIMPM!IOTEND	;YES. SET FLAGS.
;TEP SHOULDN'T REALLY BE AN ERROR
	TDZ IOS,[IOREW,,IOBOT]	;NO LONGER REWINDING
	CONSZ MTS,RWD!TLP	;UNLESS
	TRO IOS,IOBOT		;IS REALLY REWINDING
>;IFE FTF2
	POPJ P,			;EXIT
;⊗ MTEOR MTEORA MTEOR0 MTEOER MTEORI MTEORX MTEOR1 MTEOR2 MTERR MTERR0 MTERR1 MTERR2 MTERR3 MTERR4 MTPDUN DARTRS MXMIS MTPDU2 MTNOTI MTCONN MTEOFD MTEOF MTEND1 MTERST

IFE FTF2,<	;First part of page only

;MTEOR - HERE ON ERF INTERRUPT FROM DATA TRANSFER OPERATION
;** CH4
MTEOR:	CONO PI,DCTOFF		;TURN OFF DC IN CASE BLKI/BLKO DIDNT OVERFLOW
IFE FTDCBUG,<
	CONSZ DC,10000		;DATA MISS?
	SETOM MISSED		;YES.
>;IFE FTDCBUG
IFN FTDCBUG,<
	CONI MTS,MTSCON	 ;+160	;remember MTS coni at last EOR
	MOVE TAC,UPTIME		;remember when this was
	MOVEM TAC,DCTMA4 ;+166	;time of last EOR
	MOVE TAC,DCLUZ4  ;+165	;get bits indicating losses
	LSH TAC,1		;assume no loss this time
	MOVEM TAC,DCLUZ4 ;+165	;bits indicating sequence of wins/losses
	CONI DC,TAC1		;get DC status
	MOVEM TAC1,DCCON4;+164	;remember final DC status
	TRNN TAC1,10000		;data missed?
	JRST MTEORA		;no
	MOVEI TAC,1		;turn on low-order bit to
	IORM TAC,DCLUZ4  ;+165	;  indicate we lost this time
	AOS DCMIS4	 ;+163	;yes, count number of losses
	MOVE TAC,UPTIME		;and remember time of
	MOVEM TAC,DCTMB4 ;+162	;  last data miss
	SETOM MISSED		;tell someone we lost
	CONI MTS,MTSCN4	 ;+161	;save magtape coni on loss
MTEORA:
>;IFN FTDCBUG
	CONSZ MTS,EFF		;END-OF-FILE?
	SETOM MTEOFF		;YES. SET FLAG
repeat 0,<	;old buggy code, used to ignore MISSED on input!
	SKIPE @MTBLKP		;DID WE EXHAUST ALL THE IOWDS?
	TLNN IOS,IO		;NO, NOT EXHAUSTED.  SKIP IF OUTPUT
	JRST MTEOR0		;INPUT OR ALL IOWDS WERE EXHAUSTED.
	SETOM MISSED		;SET DATA MISSED. - OUTPUT FAILED TO EXHAUST IOWDS
	JRST MTEOR2		;ERROR.

;** CH4
MTEOR0:
IFE FTDCBUG,<
	CONSO DC,160000		;DATA REMAINING IN DC?
	JRST MTEOR1		;NO.
>;IFE FTDCBUG
IFN FTDCBUG,<
	TRNN TAC1,160000	;DATA REMAINING IN DC?
	JRST MTEOR1		;NO.
>;IFN FTDCBUG
	TLNN IOS,IO		;OUTPUT?
	SKIPE MISSED		;NO.  DATA MISSED?
	JRST MTEOR2		;YES (OUTPUT OR DATA MISSED).  ERROR.
	;fall into code that reads last data from DC
>;repeat 0 	;old buggy code
repeat 1,<	;new good code
;check for various possible errors
	TLNN IOS,IO		;skip if doing output
	JRST MTEORI		;input -- different error checks
	CONSO DC,160000		;data remaining in DC?
	SKIPE @MTBLKP		;no, skip if finished all IOWDs
	JRST MTEOER		;output data left in DC, or left over output IOWDs
	JRST MTEOR1		;finish checking by looking at MTS flags

;** CH4
MTEOER:	SETOM MISSED		;output error, make sure it gets counted
;check possible input errors
MTEORI:	SKIPE MISSED		;skip unless data missed
	JRST MTERR		;data missed -- go report error
	CONSO DC,160000		;skip if data remaining in DC
	JRST MTEOR1		;finish checking by looking at MTS flags
>;repeat 1	;new good code
IFE FTDCBUG,<
	CONI DC,TAC1		;FETCH DC STATUS BITS
>;IFE FTDCBUG
	LSH TAC1,-15		;SHIFT CHARACTER COUNT TO LSBITS
	IMULI TAC1,-6		;-NO OF BITS TOO FAR RIGHT
	CONO DC,@MDCSAV		;?? IF DON SAYS SO, WELL, OK (JUST)
	DATAI DC,TAC		;FETCH LAST PART-WORD OF DATA
	LSH TAC,44(TAC1)	;SHIFT LAST CHARACTERS TO LEFT END
	SKIPG J,DCWRD		;GET THE IOWD FOR INPUTTING LAST ITEM
	JRST MTEORX		;IS ALREADY OK.
	SKIPN @MTBLKP		;ARE WE AT THE END OF IOWD LIST YET?
	JRST MTEOR1		;YES.  CAN'T DO ANY MORE.
	AOS J,MTBLKP		;GET NEXT IOWD.
	SKIPN J,(J)
	JRST MTEOR1
	ADDI J,1		;FIRST CORE ADDRESS
	LDB AC2,[POINT 9,J,26]	;AC2←PAGE NUMBER OF FIRST WORD
	MOVEI AC3,MTCEXP	;NUMBER OF FIRST EXEC PAGE FOR MTC
	DPB AC3,[POINT 9,J,26]	;STORE EXEC PAGE NUMBER INSTEAD
	SUBI J,1		;RE-CONVERT TO IOWD FORMAT
IFE FTMPP2,<
	ADD AC2,MTCMAP		;POINTER TO USER'S PAGE MAP ENTRY
>;IFE FTMPP2
IFN FTMPP2,<
	ADDI AC2,MTUEXP⊗9
>;IFN FTMPP2
	MOVE AC3,(AC2)
	MOVEM AC3,EXPGT+MTCEXP	;MAKE EXEC MAP POINT TO USER'S PAGES
NOKL10,<CONO PAG,1
>;NOKL10
IFKL10,<BLKO KLPAG,MTCEXP⊗9	;CLEAR PAGE TABLE RAM FOR MTCEXP
>;IFKL10
;** CH4
MTEORX:	ADD J,[1,,1]		;BUMP DATA POINTER
	MOVEM TAC,(J)		;STORE LAST WORD
	MOVEM J,DCWRD		;LET USER SEE LAST WORD.
	CONO DC,0		;SHUT DOWN DC.

;** CH4
MTEOR1:	CONSZ MTS,LPE!PER!ILC!MIS	;IF END OF RECORD, CHECK ERROR FLAGS
MTEOR2:	SKIPE MTEOFF			;ERRORS.  BUT IS THERE END-OF-FILE?
	JRST MTPDUN			;END OF FILE OR THERE'S NO ERROR.
;** CH4
MTERR:	SETOM MTCLSR(DDB)	;real error, don't be confused by prev short rec
MTERR0:				;enter here to retry after a "short" rec seen
IFN FTDCBUG,<
	AOS MTERRA	;+167	;count all errors
	TLNE IOS,IO		;skip if reading
	AOS MTERRW	;+170	;count write errors
>;IFN FTDCBUG
;	MOVEI J,0
	CONSZ MTS,LPE		;LONGITUDINAL PARITY ERROR?
	AOS MTCLPE(DDB)		;yes, count one for this drive
;	TLO J,1000		;YES, COUNT IN QUARTER 1
	CONSZ MTS,PER		;LATERAL PARITY ERROR?
	AOS MTCPER(DDB)		;yes, count one for this drive
;	TLO J,1			;YES, COUNT IN QUARTER 2
	CONSZ MTS,ILC		;ILLEGAL OP?
	AOS MTCENT(DDB)		;yes, count one for this drive
;	TRO J,1000		;YES, COUNT IN QUARTER 3
	CONSZ MTS,MIS		;tape drive miss a char?
	AOS MTCMIS(DDB)		;yes, count one for this drive
	SKIPE MISSED		;DC DATA MISSED?
	AOS MTDCMS(DDB)		;yes, count one for this drive
;	TRO J,1			;YES, COUNT IN QUARTER 4
;	ADDM J,MTCENT(DDB)	;ADD TO ERROR COUNTS FOR THIS DRIVE
	TRNE IOS,IONRCK		;DOES USER WANT TO SUPPRESS ERROR HANDLING?
	JRST MTERR4		;YES, GIVE HIM HIS ERROR BITS
	PUSHJ P,MTERST		;RETURN ON ICR
	TLNE IOS,IO		;READING OR WRITING?
	JRST MTERR1		;WRITING.  WRITE BLANK TAPE OVER ERROR RECORD.
;	AOSL MTERCN		;TRIED ENOUGH TIMES YET?
	SOSG MTERCN		;TRIED ENOUGH TIMES YET?
	JRST MTERR4		;YES. GIVE ERROR TO USER.
	TLC IOS,ERSLIC!IOSLIC  	;COMPLEMENT STATE OF SLICE LEVEL EACH TIME
	JRST MTERR2		;READING.  GO BACKSPACE TAPE AND RETRY.

;** CH4
MTERR1:	CONSZ MTS,TEP		;WRITING.  TAPE AT END POINT YET?
	JRST MTEND1		;YES.  GIVE UP. (EXIT GRACEFULLY?)
MTERR2:	HLRZ TAC,MTDEV		;GET THE COMMAND.
	ANDCMI TAC,17B27	;MASK OUT ALL FUNCTION BITS
	MOVEI TAC,7B27(TAC)	;SET FUNCTION TO BSP
	PUSHJ P,MTXCT		;INITIATE THE OPERATION
	PUSHJ P,MTERST		;AND WAIT UNTIL BSR FINISHES.
	TLNN IOS,IO		;WRITING?
	JRST MTERR3		;NO. READING.
	HLRZ TAC,MTDEV		;GET BACK COMMAND
	ANDCMI TAC,17B27
	MOVEI TAC,13B27(TAC)	;WRITE 3" OF BLANK TAPE
	PUSHJ P,MTXCT		;INITIATE OPERATION
	PUSHJ P,MTERST		;WAIT FOR WRITE BLANK TAPE TO COMPLETE.
;** CH4
MTERR3:	LDB TAC,PIOMOD		;RE-ISSUE COMMAND THAT FAILED.  GET MODE.
	CAIL TAC,DR		;DUMP MODE?
	JRST MDRTRY		;YES.
	TLNE IOS,IO		;INPUT OR OUTPUT?
	JRST MTOUT1		;OUTPUT
	JRST MTIN1		;INPUT

;HERE AFTER TOO MANY READ RETRIES.  ASSUME ERROR IS PERMANENT.
;** CH4
MTERR4:	CONSO MTS,ILC!MIS	;SET IODERR IF ILLEG OR MISSED CHAR FLAGS
	SKIPE MISSED		;SET IODERR IF DATA MISSED
	TRO IOS,IODERR
	CONSZ MTS,LPE!PER	;SET IODTER IF LONG OR LAT PARITY
	TRO IOS,IODTER		;SET FLAG, SIMULATE BEING SUCCESSFULLY DONE.
	;fall thru
>;IFE FTF2
	;fall thru
;HERE IF SUCCESSFULLY DONE (OR AFTER TOO MANY RETIRES).  DO NEXT RECORD.
;** CH4
MTPDUN:	AOS MTCBKN(DDB)		;SUCCESSFULLY DONE.  COUNT OPS DONE BY THIS DRIVE
	LDB TAC,PIOMOD
	CAIL TAC,DR
	JRST DMPDUN		;DUMP
	TLNE IOS,IO
	JRST MTNOTI		;WRITING
	SKIPE MTEOFF		;NOT EOF?
	JRST MTEOF
IFE FTF2,<	;For F2, word count is already in TAC1
	HRRZ TAC1,MTBLKP	;TAC1←ADDRESS OF MTBLK+N OF ZERO AT END OF LIST
	HRRZ TAC,(TAC1)		;TAC←FIRST WORD MOVED IN THIS XFER-1
	SKIPN TAC
	HRRZ TAC,-1(TAC1)
	ADDI TAC,1		;TAC←USER'S ADDRESS OF FIRST WORD WRITTEN
	TRZ TAC,777		;TAC←FIRST ADDR OF FIRST PAGE WRITTEN INTO
	HRRZ TAC1,DCWRD		;TAC1←LAST WORD WRITTEN, IN EXEC SPACE
	SUBI TAC1,<MTCEXP⊗=9>	;TAC1←LAST WORD WRITTEN RELATIVE TO 2 PAGES
	ADD TAC1,TAC		;TAC1←USER'S ADDR OF LAST WORD WRITTEN
	HRRZ TAC,MTBLK		;TAC←ADDR OF FIRST WORD WRITTEN-1
	SUB TAC1,TAC		;TAC1←WC
;Here if record read OK -- check to see if maybe the word count is a little short!
;For some reason, we often words of data from the tape without noticing it.
;Here we consider rereading a record if we didn't get the standard word count.
;If we see a short record, we reread it, but if we get the same (short) length
;twice in a row, we assume that that length is correct, so we don't reread more.
;I have the feeling we always miss whole words, not just bytes, so perhaps the
;real problem is that the DC sometimes fails to indicate data missed. -- ME 6/87
DARTRS←←2400	;standard size of Dart records for 800 bpi tapes.
MXMIS←←40	;maximum number of words we expect to be missed w/o explicit error
	CAIGE TAC1,DARTRS	;assume Dart tape record size, see if normal
	CAIGE TAC1,DARTRS-MXMIS	;skip if maybe missed some data
	JRST MTPDU2		;all OK, or way off, probably really a short rec
	TRNE IOS,IONRCK!IODERR!IODTER ;skip unless real error or suppressing retries
	JRST MTPDU2		;don't reread specially
	CAMN TAC1,MTCLSR(DDB)	;see if this is same length we read previously
	JRST MTPDU1		;don't reread specially again!
	MOVE TAC,MTERCN		;get retry count
	CAME TAC,MTCRET(DDB)	;was this the first read
	AOS MTCNS2(DDB)		;no, count a reread that seems to have lost
	SKIPL MTCLSR(DDB)	;skip if didn't see this short record previously
	AOS MTCNS3(DDB)		;count multiple failures of same (?) short record
	SOJLE TAC,MTPDU2	;jump if tried enough times, don't flag error
	MOVEM TAC1,MTCLSR(DDB)	;remember length of potential short record
	AOS MTCNSR(DDB)		;count a probable short record read
	JRST MTERR0		;go reread the record

MTPDU1:	AOS MTCNS4(DDB)		;count re-read records that are really short
MTPDU2:	SETOM MTCLSR(DDB)	;clear length of last short record read
>;IFE FTF2
	HRRZ TAC,DEVIAD(DDB)	;BUFFER ADDRESS
	JUMPE TAC,MTEND1	;JUMP IF RELEASE HAS WIPED OUT BUFFERS
	XCTR XRW,[HRRM TAC1,1(TAC)]	;STORE WORD COUNT IN INPUT BUFFER.
	PUSHJ P,ADVBFF
	 JRST MTEND1		;NEXT BUFFER FULL
	JRST MTCONN		;CONTINUE MODE

;** CH4
MTNOTI:	PUSHJ P,ADVBFE		;WRITING
	 JRST MTEND1
;** CH4
MTCONN:
IFN FTF2,<
	MTRS TAC		;Get hardware status
	TRC TAC,HDWNLN!HDWRDY
	TRNE TAC,HDWEOT!HDWNLN!HDWRDY ;If end of tape, not on line, or not ready,
	JRST MTEND1		      ; then stop the xfer
>;IFN FTF2
IFE FTF2,<
	CONSZ MTS,TEP!BCT	;END OF TAPE OR IN LOCAL?
	JRST MTEND1		;STOP TAPE
	CONO DC,0		;CLEAR DATA CONTROL
>;IFE FTF2
	TLZE IOS,IOW
	PUSHJ P,SETIOD
	MOVEM IOS,DEVIOS(DDB)
	TLNN IOS,IO		;INPUT OR OUTPUT?
	JRST MTIN0		;CALL INPUT SUBROUTINE
	JRST MTOUT0		;CALL OUTPUT SUBROUTINE

;** CH4
MTEOFD:	IORI IOS,IODEND
MTEOF:	TLO IOS,IOEND		;EOF SEEN DURING LAST RECORD
	SETZM MTEOFF		;CLEAR EOF FLAG
;DUMP MODE LIST EXHAUSTED, OR NO FREE BUFFERS, OR END OF FILE SEEN.
;** CH4 UUO
MTEND1:
IFE FTF2,<
	CONO DC,0		;TURN OFF DATA CONTROL
	CONO PI,DCTOFF
>;IFE FTF2
	PUSHJ P,DETDC		;DETACH DC (IF ASSIGNED)
	PUSHJ P,ETCHK		;CHECK FOR END OF TAPE (FOR DUMP MODE OUT)
	PUSHJ P,CLRACT		;CLEAR IOACT, STORE IOS
	HRRZM DDB,MTDEV		;STORE DDB ADDRESS (DUMP MODE)
IFE FTF2,<
	PUSH P,[MTFIN]		;SET NEXT DISPATCH ADDRESS TO MTFIN
;** CH4 UUO
MTERST:	POP P,MTIDSP		;STORE RETURN ADDRESS.
	MOVEI TAC,ICR		;RETURN ON ICR
	HRRM TAC,MTCCON
	CONO MTS,ICR		;ENABLE HARDWARE FOR ICR
	POPJ P,			;DISMISS INTERRUPT
>;IFE FTF2
IFN FTF2,<
	JRST MTFIN		;On F2, done now, no waiting
>;IFN FTF2
;dump mode IO ;⊗ MTDMPI MTDMPO MTDMP0 MTDMP1 MDRTRY MTDMP2 DMPDUN DMPDU1

;** UUO
MTDMPI:	PUSHJ P,COMCHK		;INPUT UUO. CHECK COMMAND LIST.
	JRST ADRERR
	PUSHJ P,MTCHEK
	TLZ IOS,IO		;READING
	TRNE IOS,IODEND		;END-OF-FILE ALREADY?
	JRST MTEND1		;YES. GIVE BACK MAG TAPE.
	JRST MTDMP0		;SETUP TAC AND DO IT

;** UUO
MTDMPO:	PUSHJ P,COMCHK		;OUTPUT UUO.  CHECK COMMAND LIST
	JRST ADRERR
	PUSHJ P,MTCHEK		;IS SYSTEM AVAILABLE
	TLO IOS,IO		;SET WRITING.
IFE FTF2,<
	CONSZ MTS,TWL		;TAPE WRITE LOCKED?
	JRST MTOUTE		;YES. -- LOSE
>;IFE FTF2
IFN FTF2,<
	MTRS TAC		;GET HARDWARE STATUS
	TRNE TAC,HDWFPT		;WRITE PROTECTED?
	JRST MTOUTE		;YES, ERROR, CAN'T WRITE
>;IFN FTF2
;** UUO
MTDMP0:	HRRZ TAC,UUO		;COMMAND LIST POINTER
	PUSH P,[WAIT1]		;SET RETURN ADDRESS FROM MTINDC
;** CH4 UUO
MTDMP1:	LDB J,PJOBN		;(HERE IN CH4 FOR NEXT COMMAND)
	HLRZ DAT,JBTPAG(J)
	LSH DAT,9		;DAT←SIZE OF LOWER 
	CAIG DAT,(TAC)		;CHECK ADDRESS OF NEXT COMMAND WORD.
	JRST MTDMP2		;IT IS NOT LEGAL.
	HRRZM TAC,MTCMDP	;SAVE COMMAND POINTER
	XCTR XR,[SKIPN TAC,(TAC)]	;PICKUP COMMAND WORD
	JRST MTEND1		;ZERO STOPS LIST
	TLNN TAC,-1		;ZERO IN LEFT HALF IS A JUMP
	JRST MTDMP1		;CHANGE COMMAND SEQUENCE (USE RIGHT HALF)
;INPUT MAY CLOBBER COMMAND LIST, SO CHECK EACH IOWD AT I-LEVEL.
	HLROM TAC,SVCNTR	;SAVE NEGATIVE WORD COUNT COUNTER
	MOVEI TAC,(TAC)		;GET ADDRESS PART ONLY
	MOVEI DAT,JOBPFI	;USER'S LOWEST LEGAL IO ADDRESS.
	HLL DAT,UUOPC(J)	;USER OR EXEC OPERATION?
	TLNN DAT,USRMOD		;SKIP IF USER OP
	MOVEI DAT,JOBSAV	;MONITOR GETS TO DO IO AT LOWER ADDRESSES.
	CAIGE TAC,(DAT)		;IS THIS ADDRESS BELOW PROTECTED PART?
	JRST MTDMP2		;NO. LOSE.
	SUB TAC,SVCNTR		;CALCULATE ENDING ADDRESS
	HLRZ DAT,JBTPAG(J)
	LSH DAT,9		;DAT←SIZE OF LOWER
	CAIL TAC,(DAT)		;YES. LESS THAN END?
	JRST MTDMP2		;NO. LOSE.
	MOVE TAC,MTCRET(DDB)	;get retry count for next record
;	MOVNI TAC,MTREDO	;INITIALIZE RETRY COUNT FOR THIS RECORD.
	MOVEM TAC,MTERCN
	TLZE IOS,ERSLIC		;CLEAR SLICE LEVEL SET VIA ERROR RECOVERY
	TLC IOS,IOSLIC		;IF ERSLIC WAS SET, COMPLEMENT IOSLIC
	XCTR XR,[MOVE TAC,@MTCMDP]	;GET IOWD. 
	MOVEM TAC,MTWCMA	;SAVE IN CASE OF SUBSEQUENT RETRY
IFN FTF2,<
	JRST F2MTGO		;Go do the read or write
>;IFN FTF2
IFE FTF2,<
;HERE IN CH4 IF THE PREVIOUS RECORD FAILED. RETRY OPERATION.
;** CH4 UUO
MDRTRY:	MOVE TAC,MTWCMA		;GET OLD WCMA
;GO SETUP TAC1 AND J.  CALL MTINDC. IF CALLED FROM UUO THEN RETURN THRU WAIT1
	TLNN IOS,IO
	JRST MDRT1		;READ
	JRST MDWT1		;WRITE
>;IFE FTF2

;DUMP MODE ADDRESS ERROR.
;** CH4 UUO
MTDMP2:	PUSHJ P,MTEND1		;STOP THE TAPE AS IF END OF COMMAND LIST
	JRST ADRERR		;MAKE A LOSE MESSAGE

;HERE IN CH4 TO CONTINUE DUMP MODE IO AFTER A SUCCESSFUL RECORD
;** CH4
DMPDUN:	AOS TAC,MTCMDP		;ADVANCE TO NEXT IOWD
	TLNE IOS,IO		;IN OR OUT?
	JRST DMPDU1		;OUT
	SKIPE MTEOFF		;END OF FILE?
	JRST MTEOFD		;YES. SET IODEND AND STOP
	PUSHJ P,ETCHK		;CHECK FOR END OF TAPE
	JRST MTDMP1		;START NEXT READ OR WRITE

;** CH4
DMPDU1:
IFE FTF2,<
	CONSZ MTS,TEP		;SKIP UNLESS END OF TAPE
	JRST MTEND1		;END OF TAPE.  STOP OUTPUT
>;IFE FTF2
IFN FTF2,<
	MTRS TAC		;Get status
	TRNE TAC,HDWEOT		;End of tape?
	JRST MTEND1		;END OF TAPE.  STOP OUTPUT
	MOVE TAC,MTCMDP		;No, get back address of next IOWD
>;IFN FTF2
	PUSHJ P,ETCHK		;CHECK FOR END OF TAPE
	JRST MTDMP1		;START NEXT READ OR WRITE
;⊗ F2MTGO F2MTWR F2BKTL F2MTRD F2MTER F2MTRX F2MBLW F2MBLR F2MTPG F2MTP2

IFN FTF2,<
;Here to do an F2 magtape read or write, using User IOWD in TAC
F2MTGO:	HLRE TAC1,TAC		;Get negative word count
	MOVN TAC1,TAC1		;Make it positive
	CAILE TAC1,F2MTMX	;Is it bigger than max record size allowed?
	JRST F2BKTL		;Yes, won't fit in our system buffer, error
	MOVEI AC1,F2MTBF	;Address of system buffer to read into
	TLNN IOS,IO		;Skip if doing output
	JRST F2MTRD
;User IOWD is in TAC, word count in TAC1, system buffer address in AC1.
F2MTWR:	PUSHJ P,F2MBLW		;Blt data from user into system for write
	SYSPIFF		;Prevent page refills during tape operation
	PUSHJ P,F2MTPG		;Touch all pages of xfer now to avoid page refills
	MTWR AC1,(TAC1)		;Write starting at (AC1), using word count (TAC1)
	SYSPIN
	JUMPGE AC1,MTPDUN	;Jump if microcode reports nothing special
	TLNN AC1,MICTPE		;Parity error seen?
	JRST MTPDUN		;No
PRINTX Here we should backspace tape and write blank tape over losing spot.
	JRST MTPDUN		;But for now, the microcode can't write blank tape!

;Here if user asked to read or write a record bigger than system buffer.
F2BKTL:	TRO IOS,IOBKTL		;Give an error bit that resembles this error
	MOVEI TAC1,0		;Return zero word count if reading
	JRST MTPDUN		;Don't do xfer

;User IOWD is in TAC, word count in TAC1, system buffer address in AC1.
F2MTRD:	SYSPIFF		;Prevent page refills during tape operation
	PUSHJ P,F2MTPG		;Touch all pages of xfer now to avoid page refills
	MTRD AC1,(TAC1)		;Read starting at (AC1), using word count (TAC1)
	SYSPIN
	JUMPGE AC1,F2MTRX	;Jump if microcode reports nothing special
	TLNE AC1,MICEOF		;EOF seen?
	SETOM MTEOFF		;Yes, flag it
	TLNN AC1,MICEOF		;EOF seen?
	TLNN AC1,MICTPE		;Tape parity error?
	JRST F2MTRX		;EOF seen, or no errors
	AOS MTCENT(DDB)		;Count an error on this drive
	TRNN IOS,IONRCK		;Does user want to suppress error handling?
;	AOSL MTERCN		;No, tried enough times yet?
	SOSG MTERCN		;No, tried enough times yet?
	JRST F2MTER		;Suppressing retries, or retried enough already
	MTOP AC1,6		;BACK SPACE RECORD, so we can re-read it
	MOVEI AC1,F2MTBF	;Set up system buffer address for xfer again
	JRST F2MTRD		;And retry (other parameters still in ACs)
	
F2MTER:	TRO IOS,IODTER		;Parity error
F2MTRX:	SUBI AC1,F2MTBF		;See how much was read
	CAILE TAC1,(AC1)	;Hope we didn't read more than user asked for!
	MOVEI TAC1,(AC1)	;Nope, put actual count of words read into TAC1
	JUMPE TAC1,MTPDUN	;No blt if word count is zero
	PUSHJ P,F2MBLR		;Blt data from system to user
	JRST MTPDUN		;Rejoin KL code, with word count in TAC1

;Blt data from user to system buffer for writing on magtape.
;User IOWD is in TAC, word count in TAC1, system buffer address in AC1.
F2MBLW:	MOVE AC2,AC1		;Copy system buffer address, dest of blt
	HRLI AC2,1(TAC)		;Get first user address as source of blt
	MOVE AC3,AC1		;Starting system addr again, for end addr calc
	ADDI AC3,-1(TAC1)	;Add word count - 1 to get ending address
	XCTR XR,[BLT AC2,(AC3)]	;Blt magtape data from user to system
	POPJ P,

;Blt data from system buffer to user after reading from magtape.
;User IOWD is in TAC, word count in TAC1.
F2MBLR:	MOVSI AC2,F2MTBF	;Address of system buffer, source of blt
	HRRI AC2,1(TAC)		;Get first user address as dest of blt
	MOVE AC3,AC2		;Starting user addr again, for end addr calc
	ADDI AC3,-1(TAC1)	;Add word count - 1 to get ending address
	XCTR XW,[BLT AC2,(AC3)]	;Blt magtape data from system to user
	POPJ P,

;Touch all pages of xfer, to avoid page refills during xfer
F2MTPG:	PUSH P,TAC1		;Save word count
	PUSH P,AC1		;Save starting address
F2MTP2:	TLNE IOS,IO		;Skip if reading tape
	SKIPA (AC1)		;Writing tape means reading core
	MOVES (AC1)		;Reading tape means writing core
	ADDI AC1,1000		;Next page address
	SUBI TAC1,1000		;Reduce word count
	JUMPG TAC1,F2MTP2	;Loop through pages of xfer
	ADD AC1,TAC1		;Back up address to word after end of xfer
	TLNE IOS,IO		;Skip if reading tape
	SKIPA -1(AC1)		;Writing tape means reading core, ref last page
	MOVES -1(AC1)		;Reading tape means writing core, ref last page
	POP P,AC1
	POP P,TAC1
	POPJ P,
>;IFN FTF2

>;IFN MTCNUM
;⊗ MTUOUT MTUOU0 MTUNOP MTUIN MTUIN0 MTUBGO MTUGO MMTAP2 MT78ER MTUDI MTUDO MTUD2 MTUD3 MTUWCK MTUDX2 MTDDUN MTDDU1 MTUEOF MTUEO2 MTUFIN MTBDUN MTBDUZ MTBDUO MTUCON MTTDUN MTUCLO MTUINI MTUREL NOPBOT MMTDSP MTWEF MTSFR MTSBR MDMTP NMTAPE SELMOD SELMO2 MODCAP MMTAPE MMTAP0 MUWAIT UQSTAT MTUREW UREWLP UREW0 UREW2 UREW3 MTUCLK MTUCLP UREWCK MTUBFL MTUFFL MTUBF3 MTUEOT MTUUEO MTUDSP MTUHNG MTUBCK

IFN MTUNUM,<

;Routines for RH-20/TU-78 magtape control; calls PHYSIO (via MTMTGO in PHYDAT)
;to do the work.

;In PHYDAT:
EXTERN MTIOSS, MTMTGO, MODCAP
EXTERN US.REW, US.WLK, US.OFS, US.MAI, US.BOT
EXTERN IRFBSB, IRFFSB, IRFREW, IRFWTM, IRFRUN, IRFERG
EXTERN UDBCHR

;Used in PHYDAT:
INTERN MT78ER, DR, IOTEND, IOSEOF, IOBOT, IONRCK, IO

;Things to fix:
;   Can we reset the channel after a hung timeout (and flush IORB from queue)?
;   (Or will a hung timeout in the PHYSIO code cause a fatal system crash anyway?)

;The DEVIBF bit in DEVCMD(DDB) is used to indicate whether we are starting an
;data transfer or a spacing operation (including writing EOF).  For spacing
;operations, DEVIBF is on and WSYNC waits for DEVSBB to clear for data
;transfers, DEVIBF is off and WSYNC waits for IOACT to clear.  We set either
;DEVSBB (spacing) or IOACT (data) here when starting the operation.  This code
;depends on only one operation being in the PHYSIO queue at a time, as the
;interrupt routines turn off DEVSBB or IOACT assuming nothing is left in the
;queue.  If we counted queue entries and only cleared the bits when the our
;entries were all gone from the queue, then we could perhaps get away with
;queuing a second operation before the first finished.

;Buffered output
;Note that UUOCON won't call us here if IOACT is still on (but DEVSBB could be on).
;** UUO
MTUOUT:	PUSHJ P,MUWAIT		;wait for any previous spacing operation to finish
	TLO IOS,IO		;mark operation as a write
	JSP AC1,MTUWCK		;give UUO error quickly if write locked
;** CH6 & UUO
MTUOU0:	HRRZ TAC,DEVOAD(DDB)	;get buffer address
	XCTR XR,[MOVN TAC1,1(TAC)] ;-wd count
	JUMPE TAC1,MTUNOP	;if WC=0, dont do anything
	HRL TAC,TAC1		;-wd cnt,buffer = -wc,,data address-2
	ADDI TAC,1		;-wc,,data address-1 = IOWD
	JRST MTUBGO		;join input code

;Here upon attempt to output an empty buffer -- ignore the buffer.
MTUNOP:	PUSHJ P,ADVBFE		;ADVANCE OVER THE EMPTY BUFFER
	 JFCL			;IGNORE CONTINUE INDICATION
	JRST MTUFIN		;all done, wake us up, just in case?

;Buffered input
;Note that UUOCON won't call us here if IOACT is still on (but DEVSBB could be on).
;** UUO
MTUIN:	PUSHJ P,MUWAIT		;wait for any previous spacing operation to finish
	TLZ IOS,IO		;mark operation as a read
;** CH6 & UUO
MTUIN0:	HRRZ TAC,DEVIAD(DDB)	;get user buffer address
	XCTR XR,[SETCM TAC,(TAC)] ;-(size+1)-1 in left half.
	HRR TAC,DEVIAD(DDB)	;-size-2,,data buffer relative address-2
	ADD TAC,[2,,1]		;-size,,relative data address-1 = IOWD
MTUBGO:	MOVEI AC1,MTBDUN	;routine to call upon xfer completion
MTUGO:	MOVEM AC1,MTUIRB+IRBIVA(DDB) ;store in the IORB (within the DDB)
	PUSHJ P,JOBMAP		;get UPMP into exec virtual addr space
	 JRST UADRER		;must be a UPMP
	LSH AC1,9		;exec virtual address of map in AC1
	MOVEI AC2,IRFRED	;assume function is read
	TLNE IOS,IO		;skip if device read
	MOVEI AC2,IRFWRT	;function is write
	MOVSI AC3,DEVIBF	;we're transferring data, so
	ANDCAM AC3,DEVCMR(DDB)	; make sure WSYNC waits for IOACT (not DEVSBB)
	IORI IOS,IOACT		;indicate data transfer in progress
MMTAP2:	PUSH P,TAC		;save IOWD (or zero)
	PUSHJ P,STOIOS		;store IOS and reset hung count
	POP P,TAC		;restore IOWD (or zero)
	PUSHJ P,MTMTGO		;call PHYDAT to finish making IORB and queue it
	POPJ P,

;Here after error return from MT78GO, inside MTMTGO.  That error can only happen
;if IOLOCK fails (e.g., if transfer too long), which can only happen if this
;is a data transfer -- so, we don't clear DEVSBB, it shouldn't be on here.
MT78ER:	MOVEI IOS,IOBKTL	;set an error bit
	IORM IOS,DEVIOS(DDB)	;transfer too long or system error
	MOVEI IOS,IOACT
	ANDCAB IOS,DEVIOS(DDB)	;no IO active now
	POPJ P,

;Dump mode input
;** UUO
MTUDI:	PUSHJ P,MUWAIT		;wait for any previous spacing operation to finish
	TLZ IOS,IO		;mark operation as a read
	PUSHJ P,COMCHK		;INPUT UUO. check command list.
	 JRST ADRERR
	TRNE IOS,IODEND		;end-of-file already?
	POPJ P,			;yes, return immediately
	JRST MTUD2		;setup TAC and do it

;Dump mode output
;** UUO
MTUDO:	PUSHJ P,MUWAIT		;wait for any previous spacing operation to finish
	TLO IOS,IO		;mark operation as a write
	JSP AC1,MTUWCK		;give UUO error quickly if write locked
	PUSHJ P,COMCHK		;OUTPUT UUO.  check command list.
	 JRST ADRERR
;** UUO
MTUD2:	HRRZ TAC,UUO		;command list pointer
	PUSH P,[WAIT1]		;set return address from MTINDC	????
;** CH4 UUO
MTUD3:	LDB J,PJOBN		;(HERE IN CH4 FOR NEXT COMMAND)
	HLRZ DAT,JBTPAG(J)
	LSH DAT,9		;DAT←SIZE OF LOWER 
	CAIG DAT,(TAC)		;CHECK ADDRESS OF NEXT COMMAND WORD.
	JRST MTUDX2		;IT IS NOT LEGAL.
	HRRZM TAC,MTUMDP(DDB)	;SAVE COMMAND POINTER
	XCTR XR,[SKIPN TAC,(TAC)] ;PICKUP COMMAND WORD
	JRST MTUFIN		;ZERO STOPS LIST
	TLNN TAC,-1		;ZERO IN LEFT HALF IS A JUMP
	JRST MTUD3		;CHANGE COMMAND SEQUENCE (USE RIGHT HALF)
;INPUT MAY CLOBBER COMMAND LIST, SO CHECK EACH IOWD AT I-LEVEL.
	HLROM TAC,SVCNTR	;SAVE NEGATIVE WORD COUNT COUNTER
	MOVEI TAC,(TAC)		;GET ADDRESS PART ONLY
	MOVEI DAT,JOBPFI	;USER'S LOWEST LEGAL IO ADDRESS.
	HLL DAT,UUOPC(J)	;USER OR EXEC OPERATION?
	TLNN DAT,USRMOD		;SKIP IF USER OP
	MOVEI DAT,JOBSAV	;MONITOR GETS TO DO IO AT LOWER ADDRESSES.
	CAIGE TAC,(DAT)		;IS THIS ADDRESS BELOW PROTECTED PART?
	JRST MTUDX2		;NO. LOSE.
	SUB TAC,SVCNTR		;CALCULATE ENDING ADDRESS
	HLRZ DAT,JBTPAG(J)
	LSH DAT,9		;DAT←SIZE OF LOWER
	CAIL TAC,(DAT)		;YES. LESS THAN END?
	JRST MTUDX2		;NO. LOSE.
	XCTR XR,[MOVE TAC,@MTUMDP(DDB)] ;GET IOWD. 
	MOVEI AC1,MTDDUN	;routine to call upon xfer completion
	JRST MTUGO		;join buffered mode code

;Check for write locked tape.  Call with JSP AC1,MTUWCK.
;Doesn't return if write locked (POPs up a level with error bit set).
;** UUO
MTUWCK:	LDB TAC,PUNIT		;get WAITS unit nbr from DDB
	HRRZ TAC,MTCUTB(TAC)	;get the UDB address for checking write protect
	MOVE TAC,UDBSTS(TAC)	;get latest UDB status
	TDNN TAC,[US.WLK]	;skip if write locked
	JRST (AC1)		;return to caller
	TRO IOS,IOIMPM		;Write locked, give error for output attempt
	MOVEM IOS,DEVIOS(DDB)	;make sure error bit is remembered
	POPJ P,			;RETURN TO UUOCON

;DUMP MODE ADDRESS ERROR.
;** CH4 UUO
MTUDX2:	PUSHJ P,MTUFIN		;STOP THE TAPE AS IF END OF COMMAND LIST
	JRST ADRERR		;MAKE A LOSE MESSAGE

;HERE IN CH6 TO CONTINUE DUMP MODE IO AFTER A SUCCESSFUL RECORD
;Here with P4/IORB ( = DDB+MTUIRB ).
;** CH6
MTDDUN:	PUSHJ P,STKACS		;save the TOPS-20 ACs
	MOVEI DDB,-MTUIRB(P4)	;get DDB from IORB
	SKIPE AC1,MTUCFS(DDB)	;get FS address of CCW list's block
	PUSHJ P,FSGIVE		;return FS
	SETZM MTUCFS(DDB)	;no FS here any more
	MOVEI P4,MTUIRB(DDB)	;set up IORB address for MTIOSS (clob'd by FSGIVE)
	PUSHJ P,MTIOSS		;set DEVIOS bits from IORB status (clobs T1-T3)
	MOVE IOS,DEVIOS(DDB)	;get latest status bits
	TRNE IOS,IOIMPM!IODERR!IODTER!IOBKTL ;any error yet?
	JRST MTUFIN		;yes, quit now
	AOS MTUBKN(DDB)		;SUCCESSFULLY DONE.  COUNT OPS DONE BY THIS DRIVE
	AOS TAC,MTUMDP(DDB)	;ADVANCE TO NEXT IOWD
	TLNE IOS,IO		;IN OR OUT?
	JRST MTDDU1		;OUT
	TLZE IOS,IOSEOF		;END OF FILE (set or cleared by MTIOSS)?
	JRST MTUEOF		;YES. SET IODEND AND STOP
	LDB J,PJOBN		;JOB NUMBER
	PUSHJ P,MAPSET		;DATA XFER OP  SETUP MAP.
	JRST MTUD3		;START NEXT READ OR WRITE

;Here after record done to continue outputting data in dump mode.
;** CH6
MTDDU1:	TRNN IOS,IOTEND		;end of tape?
	JRST MTUD3		;START NEXT READ OR WRITE
	JRST MTUFIN		;yes, quit writing now

;Here upon EOF (tape mark) seen during dump mode read.  Quit reading.
MTUEOF:	IORI IOS,IODEND		;tell user EOF now
MTUEO2:	TLO IOS,IOEND		;EOF SEEN DURING LAST RECORD
;Dump mode list exhausted, or no free buffers, or end of file seen, or eot, or no-op
MTUFIN:	TLZE IOS,IOW		;CLEAR WAIT
	PUSHJ P,SETIOD
	JRST CLRACT		;RESTORE BITS,CLEAR IOACT

;Here upon done interrupt for buffered input.
;Here with P4/IORB ( = DDB+MTUIRB ).
;(Also, though not used here: P1/CDB, P2/KDB, P3/UDB.)
;** CH6
MTBDUN:	PUSHJ P,STKACS		;save the TOPS-20 ACs
	MOVEI DDB,-MTUIRB(P4)	;get DDB from IORB
	SKIPE AC1,MTUCFS(DDB)	;get FS address of CCW list's block
	PUSHJ P,FSGIVE		;return FS
	SETZM MTUCFS(DDB)	;no FS here any more
	MOVEI P4,MTUIRB(DDB)	;set up IORB address for MTIOSS (clob'd by FSGIVE)
	PUSHJ P,MTIOSS		;set DEVIOS bits from IORB status (clobs T1-T3)
	MOVE IOS,DEVIOS(DDB)	;get latest status bits
	TRNE IOS,IOIMPM!IODERR!IODTER!IOBKTL ;any error yet?
	JRST MTUFIN		;yes, quit now
	AOS MTUBKN(DDB)		;SUCCESSFULLY DONE.  COUNT OPS DONE BY THIS DRIVE
	TLNE IOS,IO
	JRST MTBDUO		;WRITING
	SKIPN TAC1,MTUIRB+IRBCNT(DDB) ;TAC1←WC
	JRST MTBDUZ		;Don't advance buffer for zero WC
	HRRZ TAC,DEVIAD(DDB)	;BUFFER ADDRESS
	JUMPE TAC,MTUFIN	;JUMP IF RELEASE HAS WIPED OUT BUFFERS
	LDB J,PJOBN		;JOB NUMBER
	PUSHJ P,MAPSET		;DATA XFER OP  SETUP MAP.
	XCTR XRW,[HRRM TAC1,1(TAC)] ;STORE WORD COUNT IN INPUT BUFFER.
	PUSHJ P,ADVBFF		;get next buffer
	 JRST MTUFIN		;NEXT BUFFER FULL
	TLZE IOS,IOSEOF		;EOF (from MTIOSS)?
	JRST MTUEO2		;yes
	JRST MTUCON		;no, continue reading into next buffer

;Here with zero word count from tape.  Probably EOF.
MTBDUZ:	TLZE IOS,IOSEOF		;EOF (from MTIOSS)?
	JRST MTUEO2		;yes
	JRST MTUFIN		;no, quit without advancing buffer (no data)

;** CH6
MTBDUO:	LDB J,PJOBN		;JOB NUMBER
	PUSHJ P,MAPSET		;DATA XFER OP  SETUP MAP.
	PUSHJ P,ADVBFE		;WRITING, get next buffer
	 JRST MTUFIN		;none available
;** CH6
MTUCON:	TLZE IOS,IOW		;wake up user program if waiting
	PUSHJ P,SETIOD
	MOVEM IOS,DEVIOS(DDB)
	TLNN IOS,IO		;INPUT OR OUTPUT?
	JRST MTUIN0		;input next buffer
	JRST MTUOU0		;output next buffer

;Here when MTAPE operation is finished.
;Here with P4/IORB ( = DDB+MTUIRB ).
;** CH6
MTTDUN:	PUSHJ P,STKACS		;save the TOPS-20 ACs
	MOVEI DDB,-MTUIRB(P4)	;get DDB from IORB
	PUSHJ P,MTIOSS		;set DEVIOS bits from IORB status (clobs T1-T3)
	MOVE IOS,DEVIOS(DDB)	;get latest status bits
	TLZE IOS,IOW		;CLEAR WAIT
	PUSHJ P,SETIOD		;wake up waiting user job
	MOVE TAC,MTULMT(DDB)	;get code of last MTAPE
	TLNE IOS,IOSEOF		;did we see end of file (set by MTIOSS)?
	CAIE TAC,MTSFR		;yes, was it during space-forward-record?
	CAIA			;no
	TRO IOS,IODEND		;set IOS bit to show end of file
	TLZ IOS,DEVSBB		;indicate no spacing op going any more
	JRST STOIOS		;store IOS and clear hung count

;CLOSE OUTPUT
;** UUO
MTUCLO:	TLNN DDB,OUTPB		;HAS AN OUTPUT BEEN DONE?
	POPJ P,			;NO. DONT WRITE ON TAPE.
	LDB TAC,PIOMOD		;DUMP MODE?
	CAIGE TAC,DR
	PUSHJ P,OUT		;BUFFERED MODE - OUTPUT LAST PARTIAL BUFFER
	MOVEI UUO,MTWEF		;cmd to write EOF 
	PUSHJ P,MMTAPE		;start op after waiting for IO inactive
	MOVEI UUO,MTWEF		;cmd to write EOF
	PUSHJ P,MMTAPE		;start op after waiting for previous op
	MOVEI UUO,MTSBR		;cmd to backspace record
	PUSHJ P,MMTAPE		;start op after waiting for previous op
	POPJ P,

;System initialization.
MTUINI:	SETZM DEVIOS(DDB)	;clear all status
	SETZM MTUDMD(DDB)	;select default mode
	SETOM MTURWN		;indicate no one is waiting for rewind
	POPJ P,

;Release UUO.
;** UUO
MTUREL:	PUSHJ P,WAIT1		;WAIT FOR IOACT or DEVSBB TO BE OFF.
	MOVEI IOS,-1
	ANDCAB IOS,DEVIOS(DDB)	;flush mode and error bits
	SETZM MTUDMD(DDB)	;reselect default mode
	POPJ P,

;Table for MTAPE UUO.
;If sign bit is on, right half is dispatch address.
;If sign bit is off, right half contains PHYSIO function to execute.
NOPBOT←←200000	;in LH, means the opcode is a no-op if tape is at BOT.
;A zero word means that that MTAPE opcode is illegal.
MMTDSP:	400000,,CPOPJ	;0  no-op
	NOPBOT,,IRFREW	;1  REWIND (no-op if at BOT)
	0		;2  (undefined)
MTWEF←←3 IRFWTM		;3  WRITE END OF FILE
	0		;4  (undefined)
	0		;5  (undefined)
MTSFR←←6 IRFFSB		;6  SPACE FORWARD RECORD
MTSBR←←7 NOPBOT,,IRFBSB	;7  BACKSPACE RECORD (no-op if at BOT)
	400000,,MTUEOT	;10 SKIP TO LOGICAL EOT (PROGRAMMED)
	IRFRUN		;11 REWIND & UNLOAD
	0		;12 (undefined)
	IRFERG		;13 WRITE BLANK TAPE (erase gap)
	0		;14 (undefined)
	0		;15 (undefined)
	400000,,MTUFFL	;16 SPACE FORWARD FILE (programmed)
	400000!NOPBOT,,MTUBFL ;17 BACKSPACE FILE (programmed, no-op if at BOT)
MDMTP←←20 400000,,SELMOD ;20 select data mode 0 (default, see modes below)
	400000,,SELMOD	;21 select data mode 1 (MTAPEs 20:25 skip on success)
	400000,,SELMOD	;22 select data mode 2
	400000,,SELMOD	;23 select data mode 3
	400000,,SELMOD	;24 select data mode 4
	400000,,SELMOD	;25 select data mode 5
NMTAPE←←.-MMTDSP	;number of MTAPE codes
;Note that codes 200:217 are reserved for setting retry count, currently no-ops.

;Modes for reading/writing data on tape.
;The UDBCHR word in the UDB indicates which of these are valid for a given unit.
;.SJDDM==:0			;SYSTEM DEFAULT DATA MODE
;.SJDMC==:1			;CORE DUMP MODE
;.SJDM6==:2			;SIX BIT BYTE MODE (FOR 7-TRACK DRIVES)
;.SJDMA==:3			;ANSI ASCII MODE (7 BITS IN 8 BIT BYTE)
;.SJDM8==:4			;INDUSTRY COMPATIBLE MODE
;.SJDMH==:5			;HI-DENSITY MODE (9 EIGHT BIT BYTES IN 2 WORDS)
;The default mode is .SJDMC (see PHYDAT).

;Routine for MTAPEs 20:25.  Sets the data mode from the MTAPE number - 20.
;Skips if the mode is legal, otherwise selects the default mode by storing zero.
SELMOD:	MOVEI UUO,-MDMTP(UUO)	;get just the mode number
	JUMPE UUO,SELMO2	;mode zero specifies the default, so always legal
	MOVE AC1,MODCAP-1(UUO)	;get characteristics bit for this mode
	LDB TAC,PUNIT		;get unit number
	HRRZ TAC,MTCUTB(TAC)	;get UDB ptr
	TDNN AC1,UDBCHR(TAC)	;skip if desired mode is available on this drive
	TDZA UUO,UUO		;not available, select default mode and don't skip
SELMO2:	AOS (P)			;take skip return on success
	HRRZM UUO,MTUDMD(DDB)	;store new mode to use
	POPJ P,

;MTAPE UUO.
;** UUO
MMTAPE:	PUSHJ P,MUWAIT		;wait for any previous operation to be done
	TRZ IOS,772000		;CLEAR ERROR BITS: IOF, IOACT AND IOTEND (not iobot)
	PUSHJ P,STOIOS		;store new bits
MMTAP0:	MOVEI TAC,(UUO)		;GET FUNCTION CODE FROM USER'S UUO
	CAIL TAC,200		;200:217 normally means retry N-200 times on errors
	CAIL TAC,220		;  but here they are no-ops
	CAIA
	POPJ P,			;no-op (normally set retry count for read errors)
	CAIGE TAC,NMTAPE	;SKIP IF FUNCTION CODE OUT OF BOUNDS.
	SKIPN AC2,MMTDSP(TAC)	;get dispatch or function, skip if legal code
	JRST UUOERR		;NO--TYPE MONITOR ERROR MESSAGE.
	TLZE AC2,NOPBOT		;is this function a no-op at BOT?
	TRNN IOS,IOBOT		;yes, see if we're at BOT now
	TDZA TAC,TAC		;flag non-data function (transfer size of zero)
	POPJ P,			;yes, don't backup from beginning of tape
	HRRZM UUO,MTULMT(DDB)	;remember last MTAPE function
	JUMPL AC2,(AC2)		;dispatch if sign bit set
	MOVEI AC1,MTTDUN	;routine to call upon operation completion
	MOVEM AC1,MTUIRB+IRBIVA(DDB) ;store in the IORB (within the DDB)
	MOVSI AC3,DEVIBF	;we're not transferring data, so be safe and
	IORM AC3,DEVCMR(DDB)	; make sure WSYNC waits for DEVSBB (not IOACT)
	TLZ IOS,IOSEOF		;no EOF seen during spacing yet
	TLO IOS,DEVSBB		;indicate spacing operation in progress
	PUSHJ P,MMTAP2		;prepare function for PHYSIO, opcode in AC2
	POPJ P,

;Wait for any previous spacing operation or data transfer on this drive to finish.
;Returns latest DEVIOS in IOS (which WSYNC & WAIT1 set up after waiting).
;Also ensures that IOBOT has been set up from US.BOT in the UDB before returning.
;(If we wanted to install a bugtrap here, we could check for DEVSBB being on
;and DEVIBF off; that combination shouldn't happen.)
;Clobbers AC1,AC2,AC3.
MUWAIT:	MOVE IOS,DEVIOS(DDB)	;check for either spacing or data op in progress
	TDNE IOS,[DEVSBB,,IOACT] ;skip if no op still going
	PUSHJ P,WAIT1		;wait until not active
;now we check to see if unit is rewinding or offline.
	TLZ IOS,IOREW		;CLEAR MAG TAPE REWINDING
	MOVEM IOS,DEVIOS(DDB)	;make sure IOREW is off in DEVIOS
	PUSHJ P,UREWCK		;CHECK IF REWINDING?
	 JRST MTUBCK		;no -- status OK, check IOBOT and then return
	 JRST UQSTAT		;not ready, stop job
	TLO IOS,IOREW!IOW	;SET REWIND WAIT, IO WAIT
	MOVEM IOS,DEVIOS(DDB)	;STORE IOS
	AOSG MTURWN		;ADD 1 TO REWIND WAIT COUNT SKIP IF CLREQ IN
	PUSHJ P,MTUCLP		;MAKE A CLOCK REQUEST. THIS IS ONLY UNIT REWINDING
;here we put this job into IOWQ until the rewind has finished.
	PUSH P,J		;SAVE J
	LDB J,PJOBN		;GET THE JOB NUMBER OF TAPE OWNER
	MOVNI AC1,IOWQ		;REQUE THIS GUY
	MOVEM AC1,JOBQUE(J)	;TO IOWQ UNTIL MT REWINDS
	PUSHJ P,REQUE		;
	POP P,J			;RESTORE J
	PUSHJ P,WSCHED		;WAIT...
	JRST MUWAIT		;and check again

;** UUO
UQSTAT:	PUSH P,J
	LDB J,PJOBN		;LOAD UP JOB NUMBER
	PUSHJ P,HNGSTP		;CHECK STATUS (PULL FINGERS OUT, ETC)
	POP P,J
	JRST MUWAIT		;check again if continued

;COUNT THE NUMBER OF UNITS THAT ARE WAITING FOR REWIND

;** CH4 CH7 UUO
MTUREW:	SETOM MTURWN		;SET COUNT TO NO. UNITS IN REW WAIT
	PUSH P,IOS
	PUSH P,DDB
	MOVEI DDB,MTUDDB	;GET BEGINNING OF MT DATA BLOCK CHAIN
;** CH4 CH7 UUO
UREWLP:	MOVE IOS,DEVIOS(DDB)
	JUMPGE IOS,UREW2	;is unit in a rewind wait (IOREW on)?
	PUSHJ P,UREWCK		;YES,SEE IF FINISHED REW.
	 JFCL			;HAS FINISHED REWINDING
	 TLZA IOS,IOREW		;OFF, WAKE HIM TO MAKE HIM LOSE, no long rew wait
	JRST UREW0		;STILL REWINDING 
	TLZE IOS,IOW		;SKIP UNLESS WE NEED TO WAKE HIM UP
	PUSHJ P,SETIOD		;START JOB UP AGAIN
	MOVEM IOS,DEVIOS(DDB)
	JRST UREW2

;** CH4 CH7 UUO
UREW0:	AOS MTURWN		;INCREMENT COUNT OF REW WAIT UNITS
UREW2:	HLRZ DDB,DEVSER(DDB)	;LINK TO NEXT DDB
	JUMPE DDB,UREW3		;LAST DDB?
	HRRZ DAT,DEVSER(DDB)	;NO. GET DEVICE SERVICE ROUTINE ADDRESS
	CAIN DAT,MTUDSP		;IS THIS A MAGTAPE?
	JRST UREWLP		;YES. CONTINUE
UREW3:	POP P,DDB
	POP P,IOS
	POPJ P,			;YES, DISMISS INTERRUPT OR RETURN TO MTCLOK

;HERE AT CLOCK LEVEL TO SEE IF ANY UNITS IN A REWIND WAIT HAVE FINISHED REWIND

;** CH7
↑MTUCLK:
	PUSHJ P,MTUREW		;CHECK ALL MAG TAPE UNITS TO SEE IF ANY THAT
				;WERE IN REWIND WAIT HAVE FINISHED REWINDING.
	SKIPGE MTURWN		;ARE ANY UNITS STILL IN REWIND WAIT?
	POPJ P,			;NO, EXIT WITHOUT REPLANTING CLOCK REQUEST.
;** CH7 UUO
MTUCLP:	MOVE TAC1,[$MTUCLK,,JIFSEC/2] ;COME BACK IN HALF A SECOND
	CLKENQ(TAC1)		;Plant clock request
	POPJ P,


;Check for rewinding or offline magtape.
;Direct return if online, not rewinding.
;Skip return if offline.
;Double skip if rewinding.
;** CH4 CH7 UUO
UREWCK:	LDB AC1,PUNIT		;get unit number
	HRRZ AC1,MTCUTB(AC1)	;get UDB
	MOVE AC1,UDBSTS(AC1)	;get unit status
	TDNE AC1,[US.OFS!US.MAI] ;skip unless offline (or in maint mode)
	AOSA (P)		;skip return to indicate offline
	TDNN AC1,[US.REW]	;skip if rewinding
	POPJ P,			;direct return for online and not rewinding
	JRST CPOPJ2		;double skip for rewinding

;The forward and backward file routines below are slow because they run the
;user after every record to check for EOF.  This code could be made faster
;by using a different exit routine (instead of MTTDUN) from PHYSIO, to
;check for EOF at interrupt level and re-entering the record spacing op if
;no EOF has appeared yet, without running the user.

;Space backward file
;** UUO
MTUBFL:	MOVEI UUO,MTSBR		;set to backspace a record at a time
	PUSHJ P,MMTAP0		;start spacing (clears IOSEOF unless IOBOT on)
	PUSHJ P,MUWAIT		;wait for it, get latest IOS
	TLZN IOS,IOSEOF		;did we see EOF?
	TRNE IOS,IOBOT		;or beginning of tape?
	JRST MTUBF3		;yes, stop here
	JRST MTUBFL		;nope, keep going

;Space forward file
;** UUO
MTUFFL:	MOVEI UUO,MTSFR		;space forward one record
	PUSHJ P,MMTAP0		;start spacing (clears IOSEOF before starting)
	PUSHJ P,MUWAIT		;wait for it, get latest IOS
	TLZN IOS,IOSEOF		;did we see EOF?
	JRST MTUFFL		;nope, keep going
MTUBF3:	TRZ IOS,IODEND		;yes, clear EOF
	MOVEM IOS,DEVIOS(DDB)	;store latest IOS
	POPJ P,

;Logical end of tape loop.
;Positions the tape between the two EOFs that mark the EOT.
;** UUO
MTUEOT:	MOVEI UUO,MTSBR		;backspace record (in case already betw two EOFs)
	PUSHJ P,MMTAP0		;start backspace record
	PUSHJ P,MUWAIT		;have to wait for it, before calling MTUFFL
;** UUO
MTUUEO:	PUSHJ P,MTUFFL		;space forward one file (waits for it)
	MOVEI UUO,MTSFR		;command to space one record forward
	PUSHJ P,MMTAP0		;start space record
	PUSHJ P,MUWAIT		;wait for space record, get latest status in IOS
	TLNN IOS,IOSEOF		;WAS EOF DETECTED?
	JRST MTUUEO		;NO, RESUME SPACING.
	MOVEI UUO,MTSBR		;PREPARE FOR BACKSPACE record
	PUSHJ P,MMTAP0		;BACKSPACE, LOGICAL EOT FOUND
	POPJ P,			;don't bother waiting for it

;Dispatch table for RH-20/TU-78 magtapes.
	JRST MTUINI		;INITIALIZATION
	JRST MTUHNG		;HUNG TIMEOUT
↑MTUDSP:JRST MTUREL		;RELEASE
	JRST MTUCLO		;CLOSE OUTPUT
	JRST MTUOUT		;OUTPUT
	JRST MTUIN		;INPUT
	JRST CPOPJ1		;ENTER IN DIRECTORY
	JRST CPOPJ1		;LOOKUP IN DIRECTORY
	JRST MTUDO		;DUMP OUTPUT
	JRST MTUDI		;DUMP INPUT
	POPJ P,			;SETO
	POPJ P,			;SETI
	POPJ P,			;GETF
	JRST CPOPJ1		;RENAME
	POPJ P,			;CLOSE INPUT
	POPJ P,			;UTPCLR
	JRST MMTAPE		;MTAPE UUO

;Here on hung timeout (for data or spacing op).
;** Note ** We presumably still have an IORB in PHYSIO's queue, waiting     **
;** for completion of the operation; it'd be nice if we could abort it now. **
;** Also, would be nice (after flushing IORB from queue), to set IOS bits   **
;** from unit status, for EOT, BOT.					    **
MTUHNG:
IFN FTMTHMESS,<
	PUSHACS
	PUSHJ P,DISUSR		;PRINT TIME OF MESSAGE ON CTY
	 SIXBIT /MTU/
	PUSHJ P,DISMES
	ASCIZ/Hung timeout on TU-78 -- /
	MOVE TAC1,DEVNAM(DDB)
	PUSHJ P,DISSIX		;print device name
	MOVE DDB,DEVIOS(DDB)	;see which kind of operation hung
	MOVEI AC1,[ASCIZ/ -- spacing operation/]
	TLNE DDB,DEVSBB
	PUSHJ P,DISSTR
	MOVEI AC1,[ASCIZ/ -- data operation/]
	TRNE DDB,IOACT
	PUSHJ P,DISSTR
	PUSHJ P,DISCRLF
	POPACS
>;IFN FTMTHMESS
	MOVE IOS,[DEVSBB,,IOACT] ;get bits for both spacing and data xfer active
	ANDCAM IOS,DEVIOS(DDB)	;and clear them both
	LDB TAC,PDVTIM		;reset NO. OF SECONDS
	DPB TAC,PDVCNT		;  TO WAIT BEFORE DEVICE IS HUNG (unnecessary?)
	;fall into MTUBCK to check IOBOT
;Routine to set IOBOT in IOS and DEVIOS from US.BOT in UDB status for the unit.
MTUBCK:	LDB AC1,PUNIT		;get unit number
	HRRZ AC1,MTCUTB(AC1)	;get UDB adr
	MOVE AC1,UDBSTS(AC1)	;get UDB status bits
	MOVEI IOS,IOBOT		;SET UP TO TEST CONDITIONS
	TDNN AC1,[US.BOT]	;AT BEGINNING OF TAPE?
	ANDCAB IOS,DEVIOS(DDB)	;no, clear the bit
	TDNE AC1,[US.BOT]	;AT BEGINNING OF TAPE?
	IORB IOS,DEVIOS(DDB)	;yes, set bit
	POPJ P,

IFE FTMPP2,<
.FATAL This switch should never be off any more!
>;IFE FTMPP2

>;IFN MTUNUM

BEND MTCSER
