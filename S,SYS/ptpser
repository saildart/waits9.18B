COMMENT ⊗   VALID 00010 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	A B D COUNT POINTR PTPFT PTPEN1 PTPPDN PTPERR PTPBG1 PTPDON PTPNOT PLTENB PLTDON PTPDSP PLTDSP
C00005 00003	PTPREL PTPINI PLTINI PTPINX PTPCLS PTPOUT PTPO2 PTPSKD PTPSKE PTPSKA PTPSKB PTPSKC PTPT1 PTPT2 PTPT3
C00011 00004	PTPSOS PTPS1 PTPSTD PTPSOD PTPSD1 PTPXIT XPOPJ PTPIOW PTPSOW
C00014 00005	PTPCLT PTPP1H PLTP1H PTPP1 PLTP1
C00017 00006	PTPK2B PTPK2 PTPK2C
C00020 00007	PTPK1 PTPK3 PTPK1F PTPK1B PTPK2A PTPK1A PTPK4A PTPK1D PTPK1C
C00022 00008	PTPK4B PTPK4C PTPK4 CKS12A
C00025 00009	PTPBBI PTPZZ0 PTPZZ1 PTPBB1 PTPBB2 PTPBB3 PTPBB4
C00029 00010	PTPOF1
C00030 ENDMK
C⊗;
;A B D COUNT POINTR PTPFT PTPEN1 PTPPDN PTPERR PTPBG1 PTPDON PTPNOT PLTENB PLTDON PTPDSP PLTDSP

IFN FTP2,<	;Whole file

BEGIN	PTPSER ↔ SUBTTL	PTPPLT - COMBINED PTP/PLT SERVICE ROUTINES
; ROUTINES DESIGNED TO SERVE DUAL-PROCESSOR PUNCH SYSTEM

HISYS

; PARAMETER ASSIGNMENTS . . .

; ACCUMULATORS
	A←←TAC
	B←←TAC1
	D←←TEM
	COUNT←←AC2
	POINTR←←AC3

; IOS BITS
	PTPFT←←200		; FEED AFTER EVERY BUFFERLOAD IS PUNCHED
	PTPEN1←←2000		; LAST BUFFERLOAD, FEED WHEN DONE
	PTPPDN←←4000		; PUNCH DELETE CODE NEXT
	PTPERR←←10000		; DEVICE PTP HUNG BIT
	PTPBG1←←20000		; SPECIAL 2ND LEVEL IOBEG FLAG

;PTP CONO BITS
	PTPDON←←10		; DONE FLAG
	PTPNOT←←100		; 'OUT OF TAPE' FLAG

;PLT CONO BITS
	PLTENB←←10		;ENABLE DONE INTERRUPT 
	PLTDON←←20		;DONE BIT.

;PTP SERVICE DISPATCH TABLE

	JRST	PTPINI		;INITIALIZE
	JRST	PTPCLT		;HUNG TIME OUT, SET ERROR BIT
↑PTPDSP:JRST	PTPREL
	JRST	PTPCLS		;CLOSE
	JRST	PTPOUT		;OUTPUT
	JRST	ILLINP		;INPUT ILLEGAL

IFG PLTNUM,<
;PLT SERVICE DISPATCH TABLE
	JRST	PLTINI		;INITIALIZE
	JRST	PTPCLT		;HUNG TIME OUT, SET ERROR BIT
↑PLTDSP:JRST	PTPREL
	JRST	PTPCLS		;CLOSE
	JRST	PTPOUT		;OUTPUT
	JRST	ILLINP		;INPUT ILLEGAL
>;IFG PLTNUM
;PTPREL PTPINI PLTINI PTPINX PTPCLS PTPOUT PTPO2 PTPSKD PTPSKE PTPSKA PTPSKB PTPSKC PTPT1 PTPT2 PTPT3

PTPREL:	MOVSI	IOS,DEVSBB+PTPERR
	ANDCAM	IOS,@DEVSPT(DDB)
	POPJ	P,

PTPINI:	SYNINI	PTPCSC			;CLEAR CONTROL CELLS
	MOVEI DAT,PTPDAT		;SET UP DATA AREA POINTER
	PUSHJ	P,PTPINX		;DEVSER, MUST INITIALIZE THEM BOTH HERE


	CONO	PTP,0			;SETTLE PTP CONTROL REGISTER
	POPJ	P,

IFG PLTNUM,<
PLTINI:	MOVEI	DDB,PLTDDB
	MOVEI DAT,PLTDAT
NOKL10,<SETOM	PTPMOD(DAT)		>;NOKL10.  FLAG OPERATION ON P2.
	CONO	PLT,0
	SYNINI	PLTCSC			;CLEAR CONTROL CELLS.  FALL INTO PTPINX
>;IFG PLTNUM

;FALLS THRU FROM ABOVE
;INITIALIZE CODE, RESET ALL REGISTERS
PTPINX:	MOVSI	A,PTPZBG(DAT)
	HRRI	A,PTPZBG+1(DAT)
	SETZM	PTPZBG(DAT)	;SET UP BLT POINTER TO ZERO DATA AREA
	BLT	A,PTPSID(DAT)
	POPJ	P,

;CLOSE UUO
PTPCLS:	MOVE DAT,DDBDAT(DDB)	;SET UP DATA AREA POINTER
	SETZ	A,		;SET THE 'LAST UUO' BIT IN IOS
	HRLZI	IOS,IOEND	;THIS BIT
	PUSHJ	P,PTPSOS	;THIS ROUTINE HANDLES THAT
	JRST	OUT		;KICK UUOCON TO MOVE ALL BUFFERS TO DEVICE.

;PTP/PLT OUTPUT UUO CODE

PTPOUT:	MOVE DAT,DDBDAT(DDB)	;SET UP DATA AREA POINTER
	TLNE	IOS,IOBEG	;FIRST UUO?
	TLZ	IOS,PTPERR	;YES, ZERO HUNG DEVICE BIT
	TLNN	IOS,PTPERR	;CHECK FOR HUNG DEVICE
	JRST	PTPO2		;DEVICE IS OK.
	PUSHJ	P,HNGSTP	;PRINT 'DEVICE PTP OK?' AND HANG HIM UP
	SETZ	IOS,		;DON'T SET ANYTHING
	MOVSI	A,PTPERR+DEVSBB	;CLEAR ERROR FLAG NOW
	PUSHJ	P,PTPSOD	;AFTER IT'S OVER, START UP AGAIN
PTPO2:	TLZN	IOS,IOBEG	;FIRST OUTPUT?
	JRST	@PTPUDS(DDB)	;NO. DISPATCH TO APPROPRIATE CONFIGURATION.
	PUSHJ	P,PTPINX	;INITIALIZE TABLES
	ANDI	IOS,117		;LEAVE ONLY THE MODE BITS IN IOS
	TLO	IOS,IO+PTPBG1	;SET OUTPUT BIT AND FEED BIT
	MOVEM	IOS,DATIOS(DAT)
	LDB	A,PIOMOD	;PICK UP MODE BITS, BOTTOM 4 BITS IN IOS
	JUMPE	A,PTPSKA	;MODES 0 AND 1 ARE IDENTICAL
	CAIN	A,1
	JRST	PTPSKA		;7-BIT BYTES IN USER BUFFER. SAME IN SYSTEM.
	CAIN	A,10		;MODE 10 - IMAGE MODE, 1 BYTE PER WORD
	JRST	PTPSKB
	CAIN	A,13		;MODE 13 - BINARY, NO CHECKSUMMING
	JRST	PTPSKC
PTPSKD:	TRNE	IOS,100		;MODE 14 - BINARY WITH CHECKSUM
	JRST	PTPSKC		;100 BIT HERE MEANS SOMETHING ENTIRELY DIFFERENT
	MOVEI	A,PTPK4		;UUO LEVEL KIND 4, CHECKSUM A LOT
	MOVEI	B,PTPT1		;INT. LEVEL TYPE 1, PUT IN 8TH HOLE ALWAYS
	MOVSI	AC1,440600	;SET FOR 6 BIT BYTES
	HRRI	AC1,PTPBUF(DAT)	;IN SYSTEM BUFFER
PTPSKE:	MOVEM	A,PTPUDS(DDB)	;UUO-LEVEL DISPATCH ADDRESS
	MOVE B,PTPP2D(B)	;GET P2-RELATIVE DISPATCH ADDRESS
	SUBI AC1,P2VORG		;MAKE P2-RELATIVE BUFFER ADDR
	MOVEM	B,PTPIDS(DAT)		;INTERRUPT-LEVEL DISPATCH ADDRESS
	MOVEM	AC1,PTPIBP(DAT)		;INTERRUPT-LEVEL BYTE POINTER
	MOVEI	A,PTPBUF(DAT)		;SET UP UUO-LEVEL BUFFER POINTER
	MOVEM	A,PTPUBP(DDB)		;NOT A BYTE POINTER, JUST AN ADDRESS
	SETZM	PTPBCN(DAT)		;BUFFER IS EMPTY, CLEAR COUNT
	JRST	@PTPUDS(DDB)		;DISPATCH TO UUO OUTPUT ROUTINE

PTPSKA:	MOVEI	A,PTPK1			;UUO LEVEL KIND 1
	MOVSI	AC1,440700		;7 BIT BYTES AT INTERRUPT LEVEL
	HRRI	AC1,PTPBUF(DAT)
	MOVEI	B,PTPT2			;INTERRUPT LEVEL TYPE 2
	TRNE	IOS,100			;CHECK FOR ALTERNATE MODES
	MOVEI	B,PTPT1			;ILEVEL TYPE 1 - NON-PARITY 8TH HOLE, NO DELETES AFTER TABS
	JRST	PTPSKE

PTPSKB:	MOVEI	A,PTPK2			;UUO KIND 2, PACK USER BUFFER INTO SYSTEM BUFFER
	MOVEI	B,PTPT3			;INT LEVEL TYPE 3, 8-BIT BYTES
	MOVSI	AC1,441000		;8 BIT BYTES
	HRRI	AC1,PTPBUF(DAT)
	JRST	PTPSKE

PTPSKC:	MOVEI	A,PTPK3			;UUO LEVEL KIND 3, BINARY MODES
	MOVEI	B,PTPT1			;INT. LEVEL TYPE 1, PUNCH 8TH HOLE
	MOVSI	AC1,440600		;6 BIT BYTES, 6 TO A WORD
	HRRI	AC1,PTPBUF(DAT)
	TRNE	IOS,100	
	MOVEI	B,PTPT3			;THIS MEANS DON'T PUNCH 7TH OR 8TH HOLE AT ALL
	JRST	PTPSKE

;OFFSETS INTO PTPP2D DISPATCH TABLE, WHICH CONTAINS P2 ADDRESSES
;THIS MUST MATCH THE TABLE, WHICH IS IN P2COMM
↑PTPT1←←0
↑PTPT2←←1
↑PTPT3←←2
;PTPSOS PTPS1 PTPSTD PTPSOD PTPSD1 PTPXIT XPOPJ PTPIOW PTPSOW

LOSYS


;SET AND CLEAR BITS IN IOS - FOR TWO PROCESSORS.
; PUT BITS YOU WANT SET IN IOS, BITS YOU WANT CLEARED IN A (IN TAC)

PTPSOS:

NOKL10,<SKIPE	PTPMOD(DAT)	;ARE WE IN 1 OR 2 PROCESSOR MODE
	JRST	PTPS1		;2-PROCESSORS, HARDER
	CONO	PI,PTPOFF	;SLOW DOWN PTP
	ANDCAM	A,DATIOS(DAT)	;ZERO OUT BITS IN A
	IORB	IOS,DATIOS(DAT)	;OR BITS BACK IN
	CONO	PI,PTPON	;SPEED UP PTP
	POPJ	P,
>;NOKL10

PTPS1:	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	IOR	IOS,DATIOS(DAT)	;OR IN IOS BITS
	ANDCM	IOS,A		;TAKE OUT REQUESTED BITS
	MOVEM	IOS,DATIOS(DAT)	;RESTORE IOS
	JRST	XPOPJ		;DESYNCHRONIZE AND POPJ

;ROUTINE TO SET BITS IN IOS AND START DEVICE
;CALL WITH IOS←BITS TO SET IN DEVIOS, A←BITS TO CLEAR IN DEVIOS

PTPSTD:	SETZB	A,IOS		;START DEVICE, SET NO IOS BITS
PTPSOD:	TLO	IOS,IO		;SET OUTPUT BIT
PTPSD1:	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	IOR	IOS,DATIOS(DAT)		;SET BITS
	ANDCM	IOS,A			;CLEAR APPROPRIATE BITS
	TLON	IOS,DEVSBB		;SET DEVICE RUNNING NOW BIT.
	SETOM	PTPACT(DAT)		;TELL P2 TO START DEV.
PTPXIT:	PUSHJ	P,STOIOS	;STORE IOS. FIX HUNG COUNT.
XPOPJ:	XSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GIVE CONTROL OF DEVIOS
	POPJ	P,

;SET BITS IN IOS, START DEVICE, AND WAIT FOR DEVICE TO FINISH

PTPIOW:	SETZB	A,IOS		;START DEVICE WITHOUT CHANGING IOS BITS
PTPSOW:	PUSHJ	P,PTPSOD	;STORE IOS BITS AND START DEVICE
	JRST	WSYNC		;WAIT FOR DEVICE TO FINISH

;PTPCLT PTPP1H PLTP1H PTPP1 PLTP1

;CLOCK LEVEL ROUTINES FOR PTP- PTPCLT - PTPP1 - PTPP2

HISYS

;HERE AT CLOCK LEVEL FOR HUNG TIMEOUT.
PTPCLT:	MOVE DAT,DDBDAT(DDB)	;GET POINTER TO SHARABLE DATA AREA
	MOVSI	IOS,PTPERR	;ERROR BIT WE WANT TO SET
	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	CONO	PI,PTPOFF	;SHUT OFF PTP (IN CASE IT'S ON P1)
	IORB	IOS,DATIOS(DAT)	;OR IN ERROR BIT
	TLZE	IOS,IOW		;ARE WE IN AN IO WAIT?
	PUSHJ	P,STTIOD	;YES, GET US OUT!
	MOVEM	IOS,DATIOS(DAT)	;RESTORE IOS
	CONO	PI,PTPON	;RESTORE PI SYSTEM
	AOS	(P)		;SETUP SKIP RETURN
	JRST	XPOPJ		;RELEASE SYNCHRONIZE. SKIP RETURN

;P1 HERE AT CLOCK LEVEL TO RESET HUNG TIME COUNT
↑PTPP1H:MOVEI DDB,PTPDDB
	SETZM PTPDAT+PTPSHT	;CLEAR FLAG THAT GOT US HERE
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT
	POPJ P,

IFG PLTNUM,<
;P1 HERE AT CLOCK LEVEL TO RESET HUNG TIME COUNT
↑PLTP1H:MOVEI DDB,PLTDDB
	SETZM PLTDAT+PTPSHT	;CLEAR FLAG THAT GOT US HERE
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT
	POPJ P,
>;IFG PLTNUM

;P1 HERE AT CLOCK LEVEL.  TEST TO SEE IF P2 HAS FINISHED ITS BUFFER.
↑PTPP1:	SKIPN DETFLG
	POPJ P,			;NO PTP/PLT IF NO P2
	SKIPN	PTPSID+PTPDAT
	JRST	PLTP1
	MOVEI	DDB,PTPDDB	;SETUP DDB
	MOVEI DAT,PTPDAT	;AND DATA AREA PTR
	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	MOVE	IOS,PTPIOS
	PUSHJ	P,PTPOF1	;KICK USER IF NEEDED.
PLTP1:
IFG PLTNUM,<
	SKIPN	PTPSID+PLTDAT
	POPJ	P,
	MOVEI	DDB,PLTDDB	;SET UP DDB
	MOVEI DAT,PLTDAT	;AND DATA AREA PTR
	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	MOVE	IOS,PLTIOS
	JRST	PTPOF1		;KICK USER IF NEEDED.
>;IFG PLTNUM
IFE PLTNUM,<
	POPJ P,
>;IFE PLTNUM

LOSYS
;PTPK2B PTPK2 PTPK2C

;OUTPUT ROUTINES ARE DIVIDED INTO PARTS AND KINDS, DEPENDING ON
; MODE OF OPERATION AND OTHER SUCH STUFF

HISYS

;IN THIS MODE, WE BRING 1 CHAR PER WORD IN AND PACK 4 TO A WORD
;IN THE SYSTEM BUFFER.  ENTER AT PTPK2

PTPK2B:	PUSHJ	P,PTPIOW	;START DEVICE. WAIT. TRY AGAIN.
PTPK2:	PUSHJ	P,DEVSTU	;SET UP POINTR TO USER BUFFER
	JRST	PTPK2A		;NOTHING THERE, LEAVE
	CAILE	COUNT,PTPBLN	;CAN THIS FIT IN SYSTEM BUFFER?
	JRST	BTLERR		;NO.
	MOVN	A,PTPBCN(DAT)	;IS THERE ROOM?
	ADD	A,COUNT		;ADD IN NUMBER OF WORDS TO BE TRANSFERRED
	CAIL	A,4*PTPBLN	;COMPARE WITH TOTAL CHAR COUNT
	JRST	PTPK2B		;CAN'T DO IT NOW. KICK PTP AND WAIT
	MOVSI	A,(<POINT 8,0>)	;SET UP POINTER TO SYSTEM BUFFER
	HLLZ	B,PTPUBP(DDB)	;GET POINTER THAT IS ALREADY THERE
	JUMPN	B,.+2		;IF NOT ALREADY SET UP . . .
	HLLM	A,PTPUBP(DDB)			;SET IT UP!
	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	MOVE	B,PTPUBP(DDB)			;COPY TO AC FOR SPEED
	HRLI	POINTR,444400			;BYTE POINTER TO WORDS IN U. BUFFER
	PUSH	P,AC1
	MOVSI	AC1,(<POINT 8,0,31>)
	HRRI	AC1,PTPBUF+PTPBLN-1(DAT)	;ENDING BYTE POINTER
PTPK2C:	CAMN	B,AC1				;ANY ROOM AT THE END?
	JRST	[MOVSI	B,441000		;RESET TO FRONT OF BUFFER
		HRRI	B,PTPBUF(DAT)
		JRST	.+1]
	XCTR	XLB,[ILDB A,POINTR]		;PICK UP WORD (CHARACTER)
	IDPB	A,B				;PACK INTO SYSTEM BUFFER
	SOS	PTPBCN(DAT)			;UPDATE CHARACTER COUNT
	SOJG	COUNT,PTPK2C			;LOOP AROUND
	POP	P,AC1
	MOVEM	B,PTPUBP(DDB)			;STORE THIS FOR NEXT TIME
	XSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GIVE CONTROL OF DEVIOS
	PUSHJ	P,ADVBFE	;LOAD IN ANOTHER BUFFER IF POSSIBLE
	JRST	PTPK2A		;NOT POSSIBLE, EXIT
	JRST	PTPK2		;GO THROUGH THE ENTIRE BIT AGAIN
;PTPK1 PTPK3 PTPK1F PTPK1B PTPK2A PTPK1A PTPK4A PTPK1D PTPK1C

;HERE FOR ASCII AND IMAGE BINARY.

PTPK1:	SKIPA	A,[5]		;ASCII MODE - 5 CHARS/WORD
PTPK3:	MOVEI	A,6		;BINARY MODE - 6 CHARS/WORD
	MOVEM	A,PTPCPW(DDB)	;STORE NUMBER OF CHARACTERS PER WORD.
PTPK1F:	PUSHJ	P,DEVSTU	;SET UP COUNT AND POINTR TO USER'S CORE
	JRST	PTPK1A
	PUSHJ	P,PTPBBI	;BLT BUFFER INTO SYSTEM CORE
	JRST	PTPK1B		;NO ROOM IN THE INN . . .
	PUSHJ	P,ADVBFE	;FIT AS MANY BUFFERS IN NOW AS IS POSSIBLE
	JRST	PTPK1A
	JRST	PTPK1F

PTPK1B:	PUSHJ	P,PTPIOW	;START PTP AND WAIT
	JRST	PTPK1F		;BACK TO SQUEZE MORE USER BUFFERS INTO SYSTEM BUF

PTPK2A:
PTPK1A:	SKIPGE	PTPBCN(DAT)	;IS SYSTEM BUFFER EMPTY?
	JRST	PTPK1C		;NO, START DEVICE AND LEAVE
PTPK4A:	TLNN	IOS,IOEND	;LAST UUO?
	POPJ	P,		;NO, LET HIM GIVE ANOTHER ONE
PTPK1D:	SETZ	A,		;SET THE 'PTP DISCONNECT' BIT IN IOS
	MOVSI	IOS,PTPEN1	;TELLS INTERRUPT SERVICE TO FEED A LITTLE
	JRST	PTPSOD		;START DEVICE AND LEAVE

PTPK1C:	TLNE	IOS,IOEND	;LAST UUO?
	JRST	PTPK1D		;YES, GO START DEVICE
	PUSHJ	P,DEVCR		;DOES HE HAVE ANOTHER BUFFER TO FILL
	JRST	PTPIOW		;NO, WAIT FIRST AND THEN LEAVE
	JRST	PTPSTD		;START DEVICE AND LEAVE.  LET USER FILL MORE BUFFERS
;PTPK4B PTPK4C PTPK4 CKS12A

;BINARY MODE WITH CHECKSUM
;COMPUTE WC AND CHECKSUM WORD AND PUT THAT IN THE SYSTEM BUFFER.
;THEN APPEND THE USER BUFFER TO THE WC/CHECK WORD.  PUNCH THE BUFFER
;FOLLOWED BY FEEDER

;NOTE THAT THIS VERSION OF THE CHECKSUM MUST AGREE WITH THE ONE IN PTRSER.

;ENTER AT PTPK4

PTPK4B:	MOVEI	A,6			;BINARY MODE, 6 CHARS PER WORD
	MOVEM	A,PTPCPW(DDB)
	PUSHJ	P,PTPBBI		;BRING IN A SINGLE BUFFER
	JSP	DAT,UERROR		;THERE BETTER BE ROOM!!
	SKIPL	PTPBCN(DAT)		;ANYTHING IN BUFFER?
	JRST	PTPK4C			;YES, PUNCH IT
	MOVSI	IOS,PTPFT		;THIS IS A 'FEED-WHEN-TERMINATING' SITUATION
	SETZ	A,			;SO TELL THE INTERRUPT SERVICE ABOUT IT
	PUSHJ	P,PTPSOW		;START DEVICE AND WAIT FOR IT TO STOP
PTPK4C:	PUSHJ	P,ADVBFE		;NO, IS THERE ANOTHER BUFFER?
	POPJ	P,			;NO, LET HIM FILL ONE
PTPK4:	HRRZ	TAC1,DEVOAD(DDB)	;ADDRESS OF USER'S BUFFER.
	XCTR	XR,[HRRZ TAC,1(TAC1)]	;GET BUFFER WC.
	MOVN	TAC,TAC			;-WC
	ADDI	TAC1,2			;POINT TO FIRST DATA WORD.
	HRL	TAC1,TAC		;TAC1←-WORD COUNT,,REL ADDR OF FIRST DATA
	MOVEI	TAC,0			;INITIALIZE TWO'S COMPLEMENT SUM
CKS12A:	XCTR	XR,[ADD	TAC,(TAC1)]	;FORM TWO'S COMPLEMENT SUM
	AOBJN	TAC1,CKS12A		;LOOP UNTIL DONE.
	LSHC	TAC,-30
	LSH	TAC1,-14
	ADD	TAC,TAC1
	LSHC	TAC,-14
	LSH	TAC1,-30
	ADD	TAC,TAC1
	TRZE	TAC,770000
	ADDI	TAC,1
	HRLZ	TAC,TAC			;CHECKSUM TO LEFT SIDE OF TAC
	HRRZ	TAC1,DEVOAD(DDB)	;ADDRESS OF THE BUFFER AGAIN
	XCTR	XRW,[HLLM TAC,1(TAC1)]	;STORE CHECKSUM IN LH. OF WC WORD.
	PUSHJ	P,DEVSTU		;SET UP POINTR AND COUNT
	JRST	PTPK4A			;NO BUFFERS TO EMPTY?
	ADDI	COUNT,1			;INCLUDE THE CHECKSUM AND WC WORD
	SOJA	POINTR,PTPK4B		;INCLUDE THE CHECKSUM AND WC WORD
;PTPBBI PTPZZ0 PTPZZ1 PTPBB1 PTPBB2 PTPBB3 PTPBB4

;PTPBBI - FIT THE USER'S BUFFER INTO SYSTEM BUFFER.

PTPBBI:	JUMPE	COUNT,CPOPJ1	;ZERO-LENGTH BUFFER IS AN AUTOMATIC SUCCESS
	CAILE	COUNT,PTPBLN	;SEE IF HE WANTS MORE THAN WE CAN GIVE
	JRST	BTLERR		;YES, SCREW HIM!

NOKL10,<SKIPE	PTPMOD(DAT)	;P1 OR P2?
	JRST	PTPZZ0		;P2.
	CONO	PI,PTPOFF	;P1
	AOS	(P)		;ASSUME PTPZZ1 WILL SKIP
	PUSHJ	P,PTPZZ1
	SOS	(P)		;DIDN'T SKIP. MAKE PTPBBI NOT SKIP.
	CONO	PI,PTPON
	POPJ	P,
>;NOKL10

PTPZZ0:	PSYNC1	<HRRZ TAC,DEVCMR(DDB)>	;GET CONTROL OF DEVIOS
	AOS	(P)
	PUSHJ	P,PTPZZ1
	SOS	(P)
	JRST	XPOPJ

PTPZZ1:	HRRZ TAC,PTPIBP(DAT)	;TAC=A
	PUSHJ P,P2ADCK
	 JRST DEVHNG		;ADDRESS NOT IN P2COMM
	MOVE	A,PTPIBP(DAT)	;ILEVEL BYTE POINTER
	ADDI A,P2VORG			;CONVERT P2 ADDR TO P1 VIRTUAL SPACE
	IBP	A
	HRRZ	A,A			;A←ADDRESS OF NEXT BYTE TO TAKE.
	MOVEI	B,PTPBUF+PTPBLN(DAT)	;B←END OF BUFFER ADDRESS
	SUB	B,PTPUBP(DDB)		;B←#OF WORDS BEFORE END OF BUFFER.
	SUB	A,PTPUBP(DDB)		;A←DISTANCE OF TAKER-PUTTER
	JUMPG	A,PTPBB1	;JUMP IF TAKER IS AHEAD. A=NUMBER OF FREE WORDS
	JUMPL	A,.+2		;OTHERWISE, A+PTPBLN=NUMBER OF FREE WORDS, UNLESS
	SKIPN	PTPBCN(DAT)	;A IS ZERO.  BUFFER EITHER EMPTY OR FULL.
	ADDI	A,PTPBLN	;ADD IN TOTAL BUFFER LENGTH A=NUMBER OF FREE WORDS.
PTPBB1:	CAMGE	A,COUNT		;SKIP IF THERE'S ENOUGH ROOM RIGHT NOW.
	POPJ	P,		;SYSTEM BUFFER IS TOO FULL. NON-SKIP RETURN.
	MOVSI	AC1,(POINTR)	;BLT WORD.  SOURCE FROM USER CORE
	HRR	AC1,PTPUBP(DDB)	;DESTINATION IS SYSTEM BUFFER.
	CAIG	COUNT,(B)	;SKIP IF WE NEED TWO BLTS (WON'T FIT BEFORE END)
	JRST	PTPBB3		;ONE BLT WILL DO.
	JUMPE	B,PTPBB2	;JUMP IF SPECIAL CASE OF WRAP - NO ROOM AT END.
	XCTR	XBLTR,[BLT AC1,PTPBUF+PTPBLN-1(DAT)] ;FIRST, BLT TO END OF SYSTEM BUFFER
PTPBB2:	ADDI	POINTR,(B)	;UPDATE SOURCE OF NEXT TRANSFER
	SUBM	COUNT,B		;B←NUMBER OF WORDS LEFT TO TRANSFER.
	MOVSI	AC1,(POINTR)	;SOURCE IN USER CORE.
	HRRI	AC1,PTPBUF(DAT)	;DESTINATION - FIRST LOC OF SYSTEM BUFFER.
	HRRZM	AC1,PTPUBP(DDB)	;STORE PUT POINTER.
	JRST	PTPBB4		;AC1=BLT POINTER. B=NUMBER OF WORDS TO MOVE.

PTPBB3:	MOVEI	B,(COUNT)	;B←NUMBER OF WORDS TO TRANSFER.
PTPBB4:	ADDB	B,PTPUBP(DDB)	;UPDATE PUT POINTER.  END OF BLT+1
	XCTR	XBLTR,[BLT AC1,-1(B)]	;MOVE DATA FROM USER TO SYSTEM BUFFER
	IMUL	COUNT,PTPCPW(DDB)	;UPDATE BUFFER CHARACTER COUNT TOO
	MOVN	COUNT,COUNT	;NEGATE (PTPBCN = -NUMBER OF CHARS IN BUFFER)
	ADDM	COUNT,PTPBCN(DAT) 	;INCLUDE NEW CHARACTERS WITH OLD.
	JRST	CPOPJ1			;SET SKIP RETURN. SUCCESS.
;PTPOF1

PTPOF1:	SETZM	PTPSID(DAT)	;HERE ON P1, AT CLOCK LEVEL IF PUNCH IS ON P2
	TLZE	IOS,IOW		;ARE WE IN AN IO WAIT?
	PUSHJ	P,STTIOD	;YES, SET IO DONE
	TLZ	IOS,DEVSBB	;CLEAR BUSY FLAG.
	JRST	PTPXIT

BEND PTPSER

>;IFN FTP2	;Whole file
