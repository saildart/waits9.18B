COMMENT ⊗   VALID 00013 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	 SYSINI SYS.I1 HIMOV SINI0A SYSIN1 NONETS SYSIN2
C00015 00003	 SYS1
C00016 00004	INITIALIZE ALL IO DEVICES  IOGO IOG0X IOG0 IOG01
C00025 00005	 IOG2
C00027 00006	 IOG3DD IOG3C IOG3 IOG3A SETTOP
C00033 00007	INITIALIZE SWAPPING/XCOR DDT  SYIDDT SYIDD3
C00035 00008	POWER DOWN ROUTINES  PWROFF MCELTB NMCELS
C00037 00009	 ONCEP2 MAPP2X MAPP2L P1G1 P2OPRD P2NOK P2OK P2LOST ONP2NO P2DWN1 KILLP2 GTXCOR GTXCON GTXCOM PLCSET MIDBAK PLCSE2 NONXTM AMBGTM AMBGT2 PLCCHK PDTSET SUNSET LASSUN TBAD TBAD1 TOKNOW TOKNW2 CTPUTU
C00055 00010	 OPOUT OPOUT1 TYONCE OPOUT2 TODATE DATPTR TIMEM UTIMEM
C00057 00011	 GETLIN GET1 DELETE DELET1 TYINCE
C00059 00012	GET DATE AND TIME FROM CTY  DATLOP TIMLOP TIMLP2 DECIN DECIN1
C00063 00013	BEND SYSINI
C00064 ENDMK
C⊗;
;⊗ SYSINI SYS.I1 HIMOV SINI0A SYSIN1 NONETS SYSIN2

BEGIN	SYSINI ↔  SUBTTL INITIALIZE SYSTEM DATA STORAGE

IFN FTRH,<	EXTERN	PHYINI	>

↑SYSINI:JSP TAC,.+1		;HERE FOR STARTING VIRGIN SYSTEM AT 200
	TLNE TAC,USRMOD		;USER MODE?
	JRST START		;YES. SOMEONE IS RUNNING THE DMP COPY.
	CONO APR,200000		;I/O RESET AGAIN.
	CONO PI,10400		;CLEAR PI SYSTEM
	SETZM SCNCNT		;Don't let anyone turn on Scanner too soon!
	MOVEI TAC,NDBCNT	;Init the debug-mode error count down
	MOVEM TAC,DEBCNT	;We call DDT if this hits zero
IFKL10,<
	DATAO KLPAG,[400100,,0]	;START OUT WITH SOME DECENT ACS
	CONSZ APR,SWEEPB	;WAIT FOR SWEEP BUSY TO FALL
	JRST .-1
	CONSO KLPAG,600000	;IS THE CACHE ON ALREADY?
	JRST SYS.I1		;NO.
	BLKO CCA,		;VALIDATE CORE
	CONSZ APR,SWEEPB
	JRST .-1
SYS.I1:	CONO KLPAG,KLEPT⊗-9	;TURN OFF CACHE. SET EPT. TURN OFF MAP
	DATAI CCA,0		;SWEEP CACHE.  INVALIDATE ALL.
	CONSZ APR,SWEEPB	;WAIT FOR SWEEP BUSY TO FALL
	JRST .-1
	DATAO KLPAG,[100000,,400000+KLUPT⊗-9]	;SET UPT
	MOVEI TAC,60000+KLEPT⊗-9 ;ptr to Exec Proc Table, enable microcode paging
	MOVEM TAC,KLPCON	;SAVE AS USUAL KLPAG CONO
	MOVE P,[-ERRPLN,,ERRPD-1] ;Need stack for BUGTRP and DTXINI
IFN FT215C,<
	MOVE TAC,215		;See if 215 is clobbered yet
	CAIE TAC,UPTIME		;Should be uptime pointer
	PUSHJ P,BUGTRP		;Stop, get help
>;IFN FT215C
IFN FTNDTE,<
	PUSHJ P,DTXINI		;Initialize DTE cmd buf, before ever calling DTEXX
>;IFN FTNDTE
>;IFKL10
	MOVE TAC,[IDPB TEM,DAT]	;make typeout use special buffer LINBUF for now
	MOVEM TAC,CONTYO	;see LINEP in CACDAT
	MOVE TAC,[ILDB TEM,DAT]
	MOVEM TAC,CONTYI
	XCT ONCEI		;DO ONCE-ONLY DIALOGUE
	MOVE P,[-ERRPLN,,ERRPD-1]
IFN FTDDT,<
	PUSHJ P,SYIDDT		;INITIALIZE DDT
>;FTDDT
IFKL10,<
	MOVEI TAC,DTRCDW	;READ KL10 CLOCK DEFAULT WORD
	PUSHJ P,DTEXXW		;Wait for response
	LDB TAC,[POINT 4,TAC,3]	;GET THE CACHE ENABLES
	TRO TAC,600000
	TRZE TAC,17		;SKIP IF NO CACHES ENABLED
	IORM TAC,KLPCON		;INCLUDE CACHE LOOK AND LOAD IN KLPAG CONO

IFN FTHSYS,<
;HERE, ONCE ONLY, WE BLT THE SYSTEM HIGH SEGMENT INTO HICORE.
;DDT INITIALIZATION SETS FHIPAG.
IFE FTKLB,<
	BLKI KLPAG,[	EXPGT⊗-9	;SET UP PAGE TABLE POINTERS
			400000,,0 ]
>;IFE FTKLB
IFN FTKLB,<
	PUSHJ P,SECINI		;set up section pointers (particularly section 0)
>;IFN FTKLB
	MOVEI TAC,INITRP
	MOVEM TAC,KLUPT+KLPFNP		;NEW PC WORD FOR PAGE FAULTS
	MOVSI TAC,PWRT			;read-execute-write access pager bits
	HRR TAC,FHIPAG			;FIRST PAGE NUMBER OF DESTINATION
	MOVE TAC1,[400000,,DDTEXP⊗9]	;INITIAL BLT POINTER
	MOVEI AC2,0+(HIEND-400000)⊗-9
;THE FOLLOWING CODE COPIES 400000 TO FHIPAG FF.
HIMOV:	CONO KLPAG,@KLPCON		;CLEAR ARS MAPPING EXEC PAGES
	MOVEM TAC,EXPGT+DDTEXP		;CLOBBER MAP FOR PAGE DDTPG TO HIGH CORE
	MOVE AC1,TAC1			;GET BLT POINTER
	BLT AC1,DDTEXP⊗9+777		;MOVE PAGE OF SYSTEM INTO PAGE DDTPG
	ADD TAC1,[1000,,]		;UPDATE SOURCE OF BLT (DEST. IS DDTEXP⊗9+777)
	ADDI TAC,1			;UPDATE PAGE TABLE POINTER TO HIGH CORE
	SOJG AC2,HIMOV			;LOOP, COUNTING DOWN PAGES MOVED.
	AOS TAC,EXPGT+DDTEXP
	SETZM EXPGT+DDTEXP
	HRRZM TAC,FHUPAG		;SAVE PAGE NUMBER OF "FIRST HIGH USER PAGE"
	CONO KLPAG,KLEPT⊗-9		;TURN THE MAP OFF NOW!
>;IFN FTHSYS
>;IFKL10

	MOVE TAC,SYSSIZ		;SYSTEM SIZE (SET BY DDT INITIALIZATION)
	PUSHJ P,SETTOP		;Set SYSTOP and SYSPAG
	MOVEI TAC,FSLIMP	;ARBITRARY FS LIMIT FOR HI FS AND FRIENDS
	MOVEM TAC,FSLIMIT
	SUBI TAC,1
	MOVEM TAC,FSLIM1
	ADDI TAC,1
	LSH TAC,9
	MOVEM TAC,FSLIM9
	PUSHJ P,PAGINI		;(NEEDS SYSTOP SET UP)

NOKL10,<MOVE TAC,[700000,,PSB⊗-9]
	SETZM PAGREG		;ZERO THE JOB NUMBER IN THE RIGHT HALF
	MOVEM TAC,BBN71
	HLLZM TAC,BBN72
	MOVE TAC,[JSR PAGINT]	;PAGER TRAP INSTRUCTION
	MOVEM TAC,BBN70		;STORE FOR SYSTEM
	CONO PAG,0
	CONO PAG,7
IFN FTDDT,<
	SETOM MAPON		;LET DDT KNOW THE MAP IS ON
>;IFN FTDDT
>;NOKL10
IFKL10,<
IFE FTKLB,<
	DMOVE J,[EXPGT⊗-9 ↔ 400000,,0]
	SETZB DDB,PROG
	SETZB TEM,DSER
	BLKI KLPAG,J		;SET UP PAGE TABLE POINTERS
	MOVE TAC,[PCU,,KLPFTR]			;PAGE FAIL TRAP HANDLER
>;IFE FTKLB
IFN FTKLB,<
;The page table pointer is already set up, since it 
;is really a section 0 ptr in the KLEPT, set by PAGINI.
	MOVEI TAC,KLPFTR			;PAGE FAIL TRAP HANDLER
>;IFN FTKLB
	MOVEM TAC,KLUPT+KLPFNP
	CONO KLPAG,@KLPCON			;TURN ON MAPPING
	DATAO KLPAG,[100000,,400000+KLUPT⊗-9]	;SET UPT
>;IFKL10
IFN FTHSYS,<
	JRST SINI0A

HISYS

SINI0A:
>;IFN FTHSYS

IFN FT215C,<
	MOVE TAC,215		;See if 215 is clobbered yet
	CAIE TAC,UPTIME		;Should be uptime pointer
	PUSHJ P,BUGTRP		;Stop, get help
>;IFN FT215C
IFN FTADRB,<
	PUSHJ P,ADRBCK		;Maybe set up an address break address
>;IFN FTADRB
IFN FTCMDBUG,<
	MOVEI TAC,COMTIM	;NUMBER OF CONSECUTIVE CALLS TO COMMAND BEFORE STOP
	MOVEM TAC,COMAGN	;INITIALIZE COMCNT BUGTRAP
>;FTCMDBUG
	SETZM SYSBEG		;ZERO SYSTEM STORAGE
	MOVE TAC,[SYSBEG,,SYSBEG+1]
	BLT TAC,SYSEND		;CLEAR IT
	SETZM STBEG
	MOVE TAC,[STBEG,,STBEG+1]
	BLT TAC,STEND
	SETZM UPTIME
	SETZM DPYMAP
	MOVE TAC,[DPYMAP,,DPYMAP+1]
	BLT TAC,DPYMAP+JOBN-1
	SETZM JBTSWP
	MOVE TAC,[JBTSWP,,JBTSWP+1]
	BLT TAC,JBTSWP+JOBN-1
	SETZM JB2SWP
	MOVE TAC,[JB2SWP,,JB2SWP+1]
	BLT TAC,JB2SWP+JOBN-1
NOKL10,<DATAI TAC		;RETURN APR DATA SWITCHES >;NOKL10
IFKL10,<PUSHJ P,RSWITCH		;GET PDP-11'S VERSION OF SWITCHES >;IFKL10
IFE FTF2,<
	SETZM COMEUP			;ASSUME FLAGS NOT BEING SET BY SWITCHES
					;READ TIME FROM OPERATOR
>;IFE FTF2
	TLC TAC,37
	TLNE TAC,37			;DO WE HAVE TO TAKE THESE SERIOUSLY?
	JRST SYSIN2			;NO
	TRNE TAC,1			;DOES HE WANT DDT NOW?
	PUSHJ P,DDTCAL			;YES GET IT FOR HIM.
IFE FTF2,<
	SETZ TAC1,
	ROTC TAC,7			;TOP 7 BITS HOUR WHEN SYSTEM COMES BACK UP
	HRLM TAC1,COMEUP
	SETZ TAC1,
	ROTC TAC,6			;NEXT 6 ARE MINUTE
	HRRM TAC1,COMEUP
	ROTC TAC,-=13			;RESTORE TAC (MINUS THE TOP 7 BITS)
>;IFE FTF2
	MOVSI TAC1,-NMCELS	
SYSIN1:	SKIPGE MCELTB(TAC1)		;SKIP IF NORMAL SENSE
	TRC TAC,400000			;INVERSE SENSE. COMPLEMENT THE BIT
	TRNN TAC,400000			;SKIP IF WE'RE SETTING.
	SETZM @MCELTB(TAC1)		;¬ SETTING: CLEAR THE CELL
	TRNE TAC,400000			;SKIP IF ¬ SETTING
	SETOM @MCELTB(TAC1)		;SET THE CELL
	ROT TAC,1			;SHIFT TO INSPECT MORE BITS
	AOBJN TAC1,SYSIN1		;LOOP

IFN FTSWPC,<
	SKIPN MAINTM
	SKIPE SWPCH2
	SETOM SWPCHK
>;IFN FTSWPC

SYSIN2:
IFG NINUM,<			;Mark net interfaces up unless debugging
	SKIPN MAINTMODE
	SKIPE TTYLOK
	JRST NONETS
	MOVE AC1,[-NINUM,,NILIST]
	MOVE TAC,(AC1)		;Point to info block for an interface
	SETOM NI.UP(TAC)	;Mark it wanted up
	AOBJN AC1,.-2
NONETS:
>;IFG NINUM
	PUSHJ P,CORINI		;INITIALIZE CORE TABLES (but not FS)
	PUSHJ P,ONCEP2		;NOW WE'RE MAPPED, WE CAN SET UP P2, get time/date
	MOVE TAC,[PUSHJ P,OUTCHS]	;DWP FOR TTYSER
	MOVEM TAC,CONTYO		;DWP
	MOVE TAC,[PUSHJ P,GETCHR]
	MOVEM TAC,CONTYI		;DWP
IFN FTDMAP,<
	PUSHJ P,DDXINI		;Maybe move DDT into extra core (must be mapped)
>;IFN FTDMAP
IFN FTP2,<
	SETZM NOP2HG		;ALLOW HUNG TIMEOUT ON P2 DEVICES
>;IFN FTP2
	PUSHJ P,ZSHAD		;ZERO SHADOW MEMORY FOR GOOD MEASURE (AND IIIS)
	 JFCL			;May skip
	MOVEI TAC,[ASCIZ /System initialized on /]
	SKIPN INIMES		;JUST LOADED? (INIMES IS IN OUTER)
	MOVEM TAC,INIMES	;NO. STORE MESSAGE.

;FALLS THROUGH
;⊗ SYS1

;FALLS THROUGH

	MOVE TAC,[DVDIRIN+TTYATC,,ASSCON+ASSPRG]
	HLRZ DDB,DEVLST		;SCAN ALL DEVICES
SYS1:	ANDCAM TAC,DEVMOD(DDB)	;CLEAR DEVICE BITS
				;DIRECTORY IN CORE, ASSIGNED BY CONSOLE, PROGRAM
	SETZM DEVLOG(DDB)	;CLEAR LOGICAL NAME
	HLRZ DDB,DEVSER(DDB)	;LINK ONWARDS
	JUMPN DDB,SYS1
IFN FTP2,<
	SETOM P1NUM		;START UP P2
>;IFN FTP2
IFN FTSUAI,<
	CONO CAR,OFFRED!OFFYEL	;turn off red and yellow crash lights
>;IFN FTSUAI

;FALLS THROUGH
;INITIALIZE ALL IO DEVICES ;⊗ IOGO IOG0X IOG0 IOG01

;FALLS THROUGH

IOGO:	MOVE P,[-ERRPLN,,ERRPD-1]

NOKL10,<
	CONO APR,733550+APRCHN		;RESET, CLEAR FLAGS, ENABLE CLOCK INT
	CONO PI,11577			;CLEAR PI SYSTEM
>;NOKL10
IFKL10,<
	CONO APR,700000+APRCHN		;APR RESET (IO RESET)
	CONO PI,31577			;CLEAR PI SYSTEM.  (DROP PROGRAM REQUESTS)
	DATAO KLPAG,[700000,,400000+KLUPT⊗-9]	;SET UPT (sets prev cont sect to 0)
	CONO KLPAG,@KLPCON
	PUSHJ P,DTEINI			;Initialize DTE data, give DTE a PI channel
>;IFKL10
	MOVE AC1,TIME			;GET THE CURRENT TIME
	MOVE AC2,THSDAT			;AND THE DATE
	MOVE DDB,PSTIME
	MOVE DSER,PSDATE
	MOVE TAC,[P1DATA,,P1DATA+1]
	SETZM P1DATA			;ZERO DATA AREA FOR P1
	BLT TAC,P1DATA+PDATALEN-1
	SETZM RTIME			
	SETZM TTIME			;CLEAR NULL TIME TOO.
	SETZB TAC,TAC1
NOKL10,<SETZM MTRETIME
	SETZM MTRETIME+1
>;NOKL10
IFKL10,<DMOVEM TAC,MTRETIME
>;IFKL10
IFN FTMTRACT,<
	DMOVEM TAC,MTRMTIME
	DMOVEM TAC,MTRTTIME
>;IFN FTMTRACT
IFN FTMTRTIME,<
	DMOVEM TAC,MTRRTIME
>;IFN FTMTRTIME
	SETZM LASTDISASTER		;AND LAST DISASTER TIME
	MOVEM AC1,TIME			;RESTORE THE TIME
	MOVEM AC2,THSDAT		;SAVE THE DATE TOO
	MOVEM DDB,PSTIME
	MOVEM DSER,PSDATE
	IDIVI AC1,JIFSEC		;CONVERT TIME TO SECONDS
	HRL AC1,THSDAT			;PUT DATE IN LEFT HALF OF AC1
	MOVEM AC1,TIMDAT		;AND SAVE <DATE>,,<TIME IN SECS>
IFN DAT-DDB-1,<.FATAL ACs DDB and DAT are not contiguous as required here.>
	IDIVI DDB,JIFSEC
	HRL DDB,PSDATE
	MOVEM DDB,PSTDAT
	SKIPE INIMES			;SKIP IF THIS IS A RESTART
	MOVEM AC1,INITIM		;SAVE TIME OF (RELOAD OR 203 RESTART).
	MOVEI TAC,=10*JIFSEC		;WAIT 10 SECONDS 
	MOVEM TAC,BATYET		;BEFORE STARTING THE PHANTOM JOBS
	SETZM ALFRED			;ZERO WAKEUP TIME FOR ALL PHANTOMS
	MOVE TAC,[ALFRED,,ALFRED+1]
	BLT TAC,ALFRED+BATLEN-1
IFKL10,<
IFN FTKLB,<
	MOVEI TAC,KLLUUB		;set up ptr to block for user LUUOs from
	MOVEM TAC,KLUPT+KLLUUP		; nonzero sections to save info in
	MOVEI TAC,UUOWRD		;for extended KL, UUO reconstructed here
	MOVEM TAC,UUOLOC		;set up pointer to saved UUO
>;IFN FTKLB
IFE FTKLB,<
	MOVEI TAC,KLUPT+KLUUOW
	MOVEM TAC,UUOLOC		;pointer to saved UUO
>;IFE FTKLB
>;IFKL10
NOKL10,<
	MOVE TAC,[JRST UUO1]		;SET UP PROCESSOR DATA STORAGE
	MOVEM TAC,UUO0+1
	MOVE TAC,[JRST UUO3]
	MOVEM TAC,UUO2+1
IFE FTMAOFF,<
	MOVEI TAC,40+MATOFF
>;IFE FTMAOFF
IFN FTMAOFF,<
	MOVEI TAC,40
	CONSZ APR,MAOFF
	IORI TAC,100
>;IFN FTMAOFF
	MOVEM TAC,UUOLOC
	ADDI TAC,20			;THE 60-TRAPS
	MOVEM TAC,UU2LOC
>;NOKL10
	MOVE TAC,[JRST PIERR1]
	MOVEM TAC,PIERR+1
	MOVE TAC,[POINT 36,CIPWT-1,35]
	MOVEM TAC,CLOCKP
	MOVEI TAC,CAT(CH,\CLKCHN)
	MOVEM TAC,CLKCH
	MOVEI TAC,CLKSAVE
	MOVEM TAC,CLKSV
	MOVEI TAC,CLKESAVE
	MOVEM TAC,CLKESV
	MOVE TAC,[JRST 12,@UUO0]
	MOVEM TAC,UUOXIT
	MOVEM TAC,UUOXI
	MOVEI PID,P1PID
	MOVEM PID,APRID
	MOVE P,[-ERRPLN,,ERRPD-1]
	MOVEM P,ERRPDL
	MOVE TAC,[-APRPLN,,APRPD-1]
	MOVEM TAC,APRPDL
	MOVE TAC,[-INEPLN,,INEPD-1]
	MOVEM TAC,INEPDL
	SETOM JBTMSK
	MOVE TAC,[JBTMSK,,JBTMSK+1]
	BLT TAC,JBTMSK+JOBN-1
	SETOM JBTWKM
	MOVE TAC,[JBTWKM,,JBTWKM+1]
	BLT TAC,JBTWKM+JOBN-1

;CORE IS INITIALIZED.
	PUSHJ P,FSINIT		;AND FREE STORAGE SYSTEM
IFN FTIP,<
;Set up one huge block from high FS for subdivisional use as IMP buffers
	MOVEI AC3,IMPTBS	;Amount of free storage needed for IMP-buffers block
	PUSHJ P,HFSGET		;get all the core for IMP buffers
	 PUSHJ P,BUGTRP		;better not fail
	MOVEM AC1,IMPBUF	;store pointer to beginning of block, for IP/TCP
	ADDI AC1,IMPTBS		;get address one beyond end of block
	MOVEM AC1,IMPBFE	;store end-of-buffer address
>;IFN FTIP
	PUSHJ P,NXTINI		;INITIALIZE SCHEDULER FIRST
				;SO DEVICES MAY RESET QUEUES IF DESIRED
	PUSHJ P,SPWINI		;INITIALIZE SPACEWAR SERVICE
	PUSHJ P,QINI		;INITIALIZE QUEUE STRUCTURE
	PUSHJ P,DISINIT		;INITIALIZE DISASTER TYPEOUT SYSTEM.
IFN FTMPX,<
	PUSHJ P,MPXINI
>;IFN FTMPX
IFN FTRH,<
	PUSHJ P,PHYINI		;Initialize RH devices
>;IFN FTRH

;HERE WE INITIALIZE ALL THE DEVICES IN THE DEVICE LIST
;NOTE THAT FREE STORAGE MUST BE SET UP
;ALSO NOTE THAT EACH DEVICE MUST CORRECTLY LINK TO
;THE NEXT BEFORE RETURNING

IOG0X:	HLRZ DDB,DEVLST		;GO UP THE DEVICE LIST, DOING GOOD THINGS
	SETZM SAVITM		;DSP OF LAST DEVICE
IOG0:	HRRZ TAC,DEVSER(DDB)	;GET THE DEVICE SERVICE DISPATCH
	CAMN TAC,SAVITM		;SAME AS LAST MEANS INITIALIZED ALREADY.
	JRST IOG01		;YES
	MOVEM TAC,SAVITM	;SAVE THE DEVICE DISPATCH
	PUSH P,DDB
	PUSHJ P,DINI(TAC)	;INITIALIZE THE DEVICE
	POP P,DDB
IOG01:	MOVEI TAC,ASSPRG
	ANDCAB TAC,DEVMOD(DDB)	;TURN OF ASSIGNED BY PROG BIT
	LDB TAC1,PJOBN		;MAYBE WE WANT TO SAVE THE JOB NUMBER
	PUSH P,TAC1
	HRLOI TAC1,77		;MAKE MASK FOR MODE BITS AND HUNG COUNT
	ANDM TAC1,DEVCHR(DDB)	;GLONK!
	MOVEI TAC1,0
	DPB TAC1,PJOBN		;ASSUME WANT TO CLEAR JOB NUMBER IN DDB
	POP P,TAC1		;GET BACK JOB NUMBER
	TDNE TAC,[TTYATC,,ASSCON] ;IF ASSIGNED BY CONSOLE THEN OR ATTACHED
	DPB TAC1,PJOBN		;SAVE JOB NUMBER ALSO
	SETZM DEVBUF(DDB)
	HLRZ DDB,DEVSER(DDB)	;LINK ON MACDUFF
	JUMPN DDB,IOG0		;LOOP TO NEXT DEVICE

IFE FTNSWP,<			;OLD UDP SWAPPER
	MOVEI TAC,ASSPRG!ASSCON
	SKIPE DDB,SWPDDB	;IF SWAPPING ON THE UDP
	IORM TAC,DEVMOD(DDB)	;MAKE SURE NO ONE CAN ATTACH/ASSIGN IT.
>;IFE FTNSWP

	PUSHJ P,SWPINI		;INITIALIZE THE SWAPPER AFTER DEVICES

	MOVE TAC,[RSTBEG,,RSTBEG+1]
	BLT TAC,RSTEND-1
;⊗ IOG2

;NORMALIZE ALL JOB SLOTS.

	MOVEI J,JOBN-1
IOG2:	MOVSI TAC,JERR
	MOVEM TAC,JBTSTS(J)
	SOJGE J,IOG2
	SETZM JOB

;FORM INITIAL CHECKSUM.
	
	MOVE TAC,[CHKBEG-CHKEND-1,,CHKBEG]	;AOBJN POINTER
	MOVEM TAC,MONPTR
	PUSHJ P,CHECK
	MOVEM TAC1,MONSUM

IFN FTHSYS,<
	MOVE TAC,[400000-HIEND,,400000]	;AOBJN POINTER TO HISYS
	MOVEM TAC,HMNPTR
	PUSHJ P,CHECK
	MOVEM TAC1,HMNSUM
>

IFN FTSTAT, <
	MOVE TAC,[POINT 18,STATS]	;INITIALIZE STATISTICS POINTER
	MOVEM TAC,STATPTR
>;IFN FTSTAT

	XCT PICON			;PION, CH 3-7 AND PARITY ERROR ENABLE
IFKL10,<MOVEI TAC,7740			;ALL APR ERROR BITS
	HRRM TAC,KLPARC			;ENABLE APR CONSZ
	CONO APR,127760+APRCHN		;ENABLE EVERYTHING
>;IFKL10
;⊗ IOG3DD IOG3C IOG3 IOG3A SETTOP

;RANDOM INITIAL MESSAGES -- SET UP COMING UP TIME ON DD/III

	SKIPN MAINTMODE
	SKIPE TTYLOK
	SKIPN COMEUP		;IF COMEUP = 0 DON'T CHANGE DOWN MESSAGE
	JRST IOG3C
;PUT TIME COMING UP ON DD AND III CONSOLES
;Possible coming-up messages and PDP-11 switch settings to get them:
;	System is down!				Byte (2)0 (1)0 (6)0  (6)0  3(7)
;  System is down!  Up who knows when!		Byte (2)0 (1)0 (6)40 (6)0  3(7)
;  System is down!  (patchable at UPMSG5)	Byte (2)0 (1)0 (6)30 (6)0  3(7)
;  System is down!  Up shortly!			Byte (2)0 (1)0 (6)0  (6)77 3(7)
;  System is down!  Up at 20:15 approx		Byte (2)0 (1)1 (6)hr (6)mn 3(7)
;  System is down!  Up at 20:15			Byte (2)0 (1)0 (6)hr (6)mn 3(7)
	MOVEI J,1
	MOVEM J,DDDME2		;Overwrite some leading spaces to shift the
	MOVEM J,DDDME2+1	; "Down" message to the left a little on DD
	HLRZ TAC,COMEUP		;Get hour
	MOVEI TAC1,UPMSG2	;"Up who knows when" msg
	TRNE TAC,40		;"Who knows when" bit on?
	JRST IOG3DD		;Yes, up who knows when
	MOVEI TAC1,UPMSG5	;Patchable (on disk) message
	TRZ TAC,100		;Clear "approx" bit
	CAIL TAC,=24		;Reasonable hour?
	JRST IOG3DD		;No, use patchable message
	HRRZ DDB,COMEUP		;Get minutes
	MOVEI TAC1,UPMSG3	;"Up shortly"
	CAIL DDB,=60		;Reasonable minutes?
	JRST IOG3DD		;No, up shortly
	HLRZ TAC,COMEUP		;Get hour again
	TRZE TAC,100		;Time approximate?
	SKIPA J,[POINT 7,UPMSG4+1,20] ;Use "approx" msg
	MOVE J,[POINT 7,UPMSG+1,20]   ;For stuffing in actual time specified
	IDIVI TAC,=10		;Hours digits
	ADDI TAC,"0"
	IDPB TAC,J
	ADDI TAC1,"0"
	IDPB TAC1,J
	IBP J			;Skip over ":"
	HRRZ TAC,COMEUP
	IDIVI TAC,=10
	ADDI TAC,"0"		;Minutes digits
	IDPB TAC,J
	ADDI TAC1,"0"
	IDPB TAC1,J
	MOVEI TAC1,-1-1(J)	;Message to use on DD and III (UPMSG or UPMSG4)
IOG3DD:	HRLI TAC,(TAC1)
	HRRI TAC,DDDME3
	BLT TAC,DDDME3+LUPMSG-1	;PUT TIME COMING UP INTO DD MESSAGE
IFN FTSUAI,<
	HRLI TAC,(TAC1)
	HRRI TAC,DPYAV3
	BLT TAC,DPYAV3+LUPMSG-1	;PUT TIME COMING UP INTO III MESSAGE
>;IFN FTSUAI
IOG3C:	MOVEI TAC,[ASCIZ /System started on /]
	SKIPN INIMES		;LOAD OR INITIALIZE?
	MOVEM TAC,INIMES	;NO, IT MUST BE A START
	MOVSI J,-TCONLN-1	;NO. OF TTY LINES(REAL ONES).
IOG3:	SKIPN DDB,TTYTAB(J)	;GET DDB FOR NEXT TTY.
	JRST IOG3A		;OOPS, NO DDB.
	PUSHJ P,CRLF		;TYPE A CRLF
	MOVE TAC1,DEVNAM(DDB)
	PUSHJ P,PRNAME		;PRINT NAME OF CONSOLE
	MOVEI TEM,40
	XCT TYO			;SPACE
	MOVEI TAC,[ASCIZ/(DOWN) /]
	SKIPN MAINTMODE
	SKIPE TTYLOK
	PUSHJ P,CONMES		;TELL THEM THAT WE'RE DOWN
	MOVE TAC,INIMES		;GET THE ADDRESS OF MESSAGE
	PUSHJ P,CONMES		;SEND IT
	PUSHJ P,DAYT2		;TIME OF DAY
	PUSHJ P,PRCNTC
	PUSHJ P,TTYSTR		;START THE TTY TYPING
IOG3A:	AOBJN J,IOG3		;SEND MESSAGE TO ALL TTY'S.

IFN FTDDT,<
	SETZM CTYMAR		;DON'T INDENT
	PUSHJ P,DISMES		;IN CASE LOWCOR GETS CLOBBERED.
	ASCIZ /DDT STARTS AT /
	HRRZ TAC,SYSDSP+1
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	MOVE TAC,SYSDSP+1
	MOVEM TAC,441		;TELL KLDCP DDT COMMAND WHERE TO START KL TO GET DDT
>;IFN FTDDT

;	MOVE TAC,THSDAT		;APRIL 1 HACK.
;	IDIVI TAC,=12*=31	;DIVIDE TO GET YEARS IN TAC, DAY OF YEAR IN TAC1
;	CAIN TAC1,=31*3		;APRIL 1?
;	SETOM AFOOL		;YES.
	
	SETZM INIMES		;CLEAR FOR NEXT TIME
	SETZB J,JOB		;INDICATE JOB ZERO
	MOVEI PID,P1PID		;INDICATE P1
	JRST NULJOB		;START THE NULL JOB.

↑SETTOP:ADDI TAC,777		;Get here with SYSSIZ (words) in TAC
	TRZ TAC,777		;Make it even pages worth of words
	MOVEM TAC,SYSTOP	;AND SAVE IT
	LSH TAC,-9
	MOVEM TAC,SYSPAG	;FIRST PAGE OF FREE STORAGE
	POPJ P,
;INITIALIZE SWAPPING/XCOR DDT ;⊗ SYIDDT SYIDD3

LOSYS

IFN FTDDT,<

SYIDDT:
NOKL10,<DATAI TAC		;RETURN APR DATA SWITCHES >;NOKL10
IFKL10,<PUSHJ P,RSWITCH		;GET PDP-11'S VERSION OF SWITCHES >;IFKL10
	TLC TAC,37		;COMPLEMENT 5 BITS ON THE LEFT
	TLNN TAC,37		;DO WE HAVE TO TAKE THESE SERIOUSLY?
	TRNN TAC,2		;Yes, DOES HE WANT NO DDT?
	JRST SYIDD3		;SWITCHES DON'T SAY NO DDT
	SETOM NOTDDT		;FLAG TO GET RID OF DDT
IFN FTDMAP,<
	SETZM DDTXCOR		;NO DDT OUTSIDE OF FIRST PHYSICAL MOBY (NO DDT!)
>;IFN FTDMAP
	MOVE TAC1,[HALT AUTOLOAD]	;MAKE A HALT 
	MOVEM TAC1,DDT			;AND PLANT IT ON TOP OF DDT
	MOVEI TAC1,DDT+1		;GET THE ADDRESS BEYOND DDT
	MOVEM TAC1,SYSSIZ		;SAVE AS SYSSIZ
	SETZM DDTSYM			;NO SYMBOL TABLE POINTER
	POPJ P,				;CONTINUE

SYIDD3:	SKIPN NOTDDT			;DOES HE WANT DDT?
	PUSHJ P,DDTINI			;YES INITIALIZE DDT
IFN FTHSYS,<
	SKIPN DDTXCOR			;SKIP IF DDT IS IN HIGH CORE
	TDZA TAC1,TAC1
	HLRE TAC1,XDDPTR		;-NUMBER OF PAGES USED BY DDT AND SYMBOLS
	MOVN TAC1,TAC1
	ADDI TAC1,1000			;FIRST PAGE FOR HISYS
	MOVEM TAC1,FHIPAG
>;IFN FTHSYS
	MOVEI TAC1,-1
	MOVEM TAC1,37			;INITIAL SYSTEM JOBREL FOR DDT
	POPJ P,
>;FTDDT
;POWER DOWN ROUTINES ;⊗ PWROFF MCELTB NMCELS

NOKL10,<
↑PWROFF:
	SYSPIFF		; NO MORE INTERRUPTS NOW
	EXCH 17,PWRCNT		; AND COUNT DOWN
	SOJG 17,.		;LOOP
	MOVEI 17,-1		; COUNT DONE, NO POWER DOWN AFTER ALL
	EXCH 17,PWRCNT		;RESTORE 17
	AOS P1OFF		;COUNT FAILURES
	SYSPIN		;ENABLE INTERRUPTS
	JRST 12,@APRCHL
>;NOKL10

MCELTB:	TTYLOK		;18 400000
	MAINTM		;19 200000
IFE FTF2,<DDOFF;>0	;20 100000
IFKL10,<IIIOFF;>LITOFF	;21 40000	;On F2, suppress DATAO PI, to display job in lights
	DEBMOD		;22 20000
	0		;23 10000	;(formerly EXPMOD)
	NOLOGIN		;24 4000	;SET TO PREVENT LOGIN
	0		;25 2000	;(formerly IMPDIE)
	0		;26 1000	;(formerly IMPPMS)
	BLTSWP		;27 400		;SET FOR BLT AFTER SWAPIN
	0		;28 200
IFN FTSWPC,<SWPCHK;>0	;29 100		;CHECKSUM EVERY SWAP OP
IFN FTSWPC,<SWPCH2;>0	;30 40		;CHECKSUM EVERY SWAP OP AFTER SWAP OUT TOO
	0		;31 20		;(formerly NOP2)
	CORNXM		;32 10		;Ignore NXMs and go on automatically
	0		;33 4		;(formerly ETHDIE)
	0		;34 2
; no cell for low bit	;35 1		;Enter DDT from SYSINI before SYSIN1
NMCELS←←.-MCELTB
;⊗ ONCEP2 MAPP2X MAPP2L P1G1 P2OPRD P2NOK P2OK P2LOST ONP2NO P2DWN1 KILLP2 GTXCOR GTXCON GTXCOM PLCSET MIDBAK PLCSE2 NONXTM AMBGTM AMBGT2 PLCCHK PDTSET SUNSET LASSUN TBAD TBAD1 TOKNOW TOKNW2 CTPUTU

;Initialize P2 and (sic) set up P1's time/date (sigh).
ONCEP2:
IFN FTP2,<
IFG XGPNUM,<
	MOVEI DDB,P2XNUM	;HOW MANY P2 XGP BUF PAGES WE GET IN MAP
	MOVEI TAC,P2BASE+P2XBPG	;PHYSICAL FIRST PAGE OF P2 XGP BUF
	MOVEI TAC1,P2XEXP	;P1 VIRTUAL FIRST PAGE OF P2 XGP BUF
MAPP2X:	PUSHJ P,ADDEMP		;GET A PAGE
	MOVEI TAC,1(TAC)
	MOVEI TAC1,1(TAC1)
	SOJG DDB,MAPP2X
>;IFG XGPNUM
repeat 0,<
	SKIPE NOP2			;IS THERE A NXM IN P2 MEMORY?
	JRST ONP2NO			;YES, NO P2 TODAY (***)
>;repeat 0
	MOVEI DDB,P2MNUM	;HOW MANY P2 PAGES WE GET IN MAP
	MOVEI TAC,P2BASE	;PHYSICAL FIRST PAGE OF P2 MEMORY
	MOVEI TAC1,P2MEXP	;P1 VIRTUAL FIRST PAGE OF P2 MEMORY
MAPP2L:	PUSHJ P,ADDEMP		;GET A PAGE
	MOVEI TAC,1(TAC)
	MOVEI TAC1,1(TAC1)
	SOJG DDB,MAPP2L
	SETZM P1NUM			;TELL P2 WE'RE NOT READY
	SETZM P2NUM			;IT WILL SETOM THIS WHEN IT'S READY
	SETZM DETFLG			;IT WILL SETOM THIS EVEN LATER
	SETZM XFCJN			;AVOID CRASHING THE SYSTEM LATER
	MOVEI TAC,100000		;IS P2 STARTED?
	SKIPN TAC1,P2NUM
	SOJGE TAC,.-1
	JUMPN TAC1,P2OK			;YES. SKIP CTY TYO
	MOVE DAT,LINEP			;ASK OPERATOR TO START UP P2
	MOVEI TAC,[ASCIZ /Start other processor at /]
	PUSHJ P,CONMES
	MOVEI TAC,SYSDSP+4
	PUSHJ P,OCTPNT
;;	MOVEI TAC,[ASCIZ /, else type D if it's down or U if it's up./]
;;PIG0:	PUSHJ P,CONMES
	PUSHJ P,CRLF
	PUSHJ P,OPOUT			;DUMP CTY BUFFER ONTO THE CTY
	JRST P2LOST
repeat 0,< ;no separate P2 memory, so don't bother with this question
	MOVEI AC1,=10000		;ADJUST THIS FOR A MINUTE OR SO
P1G1:	SKIPE TAC,P2NUM			;WAIT FOR P2 TO START
	JRST P2OK			;P2 HAS BEEN STARTED OK.
	SOJL AC1,P2LOST			;HE WANTS A P2 BUT COULDN'T START IT
	PUSHJ P,CTGETC			;LOOK FOR TYPEIN.
	 JRST P1G1			;NONE.
	PUSHJ P,CTPUTU		;make the char upper case and echo it with CRLF
	MOVE DAT,LINEP
	CAIN TAC,"D"
	JRST P2OPRD
	CAIN TAC,"U"
	JRST P2LOST
	MOVEI TAC,[ASCIZ /
You must type D or U!/]
	JRST PIG0
>;repeat 0

repeat 0,< ;no separate P2 memory, so flush this
P2OPRD:	SETOM NOP2			;DON'T LET A USER RESTART IT LATER
	MOVE TAC,[JRST 4,SYSDSP+4]
	MOVEM TAC,P2VORG(TAC)		;EVEN FROM HERE
	MOVEM TAC,P2VORG+140		;ZAP P2'S TRAP LOCATIONS
	MOVE DAT,[P2VORG+140,,P2VORG+141]
	BLT DAT,P2VORG+161		;NORMALLY A NO-NO BUT INTS OFF HERE
	MOVE DAT,LINEP
	JRST P2DWN1			;USE DIFFERENT CORE
>;repeat 0

P2NOK:
>;IFN FTP2
IFN FT11CLK,<
	SETZM KLEPT+DTTIME	;NO TIME YET
	PUSHJ P,S11CLW		;TELL PDP11 TO START STORING BATTERY TIME, WAIT
	MOVEI TAC,400000	;Don't wait forever, but don't start without time
	SKIPN KLEPT+DTTIME	;SKIP IF PDP11 HAS NEW TIME FOR US
	SOJG TAC,.-1		;NO TIME YET
	JUMPLE TAC,TBAD		;JUMP IF FAILED TO GET TIME FROM 11 IN TIME
	PUSHJ P,G11TIM		;PICK UP TIME AND DECODE IT
	 JRST TBAD
	MOVEM J,TIME
	MOVEM DAT,THSDAT
	MOVEM J,PSTIME
	MOVEM DAT,PSDATE
	PUSHJ P,PDTSET
	JRST TOKNOW
>;IFN FT11CLK
IFE FT11CLK,<
	JRST TBAD		;F2 HERE, GETS TIME FROM OPERATOR
>;IFE FT11CLK

IFN FTP2,<
P2OK:	AOJE TAC,P2NOK			;P2NUM MUST BE EXACTLY -1 OR WE LOST
P2LOST:	MOVEI TAC,['P2LOAD'↔'  1  2'↔<REAPRV!ACWPRV,,0>↔0]
	PUSHJ P,FIREUP			;GET USER LEVEL TO RELOAD THE KA
	 JFCL				;NEVER MIND ERROR
	JRST P2NOK

repeat 0,<
ONP2NO:	MOVE DAT,LINEP
	MOVEI TAC,[ASCIZ /NXM in P2 memory, can't run P2 today./]
	PUSHJ P,CONMES
	PUSHJ P,CRLF
	PUSHJ P,OPOUT			;DUMP CTY BUFFER ONTO THE CTY
;We now get three random pages to use for P2COMM cells instead of P2 memory.
P2DWN1:	PUSHJ P,KILLP2		;SUBROUTINE SO CAN BE DONE IN FLYING SYSTEM
	 JFCL			;IF THERE AREN'T THREE PAGES IT WON'T RUN ANYWAY
	JRST P2NOK
>;repeat 0

↑KILLP2:MOVEI DDB,P2MNUM	;HOW MANY P2 PAGES WE GET IN MAP
	MOVEI TAC1,P2MEXP	;P1 VIRTUAL FIRST PAGE OF P2 MEMORY
	PUSHJ P,GTXCOR		;GET PHYSICAL PAGES FOR SUBSTITUTE "P2 MEM"
	 POPJ P,		;FAILED
	MOVNI TAC,P2MNUM⊗9	;NUMBER OF WORDS WE JUST TOOK FROM USER CORE
	PUSHJ P,ADJCOR		;FIX CORMAX AND USRMAX
	SETZM P2VORG		;NOW CLEAR THE NEW "SHARED" AREA
	MOVE TAC,[P2VORG,,P2VORG+1]
	BLT TAC,P2VORG+<P2MNUM⊗9>-1
	JRST CPOPJ1
>;IFN FTP2

IFN FTP2!FTDMAP,<	 ;Here from DDT&SETXC and from KILLP2 above
;Here to get (DDB) pages of physical core and setup exec map to point there,
;starting at exec page number in TAC1.  Skips iff successful.  Direct return
;on failure, with DDB indicating number of pages not found (pages found will
;have been mapped, caller may want to unmap them).  Clobbers various ACs.
;Caller should call ADJCOR after success return from GTXCOR.
↑GTXCOR:MOVE DSER,FSLIMIT	;FIRST POSSIBLE FREE PHYSICAL PAGE
GTXCON:	LDB TAC,COREP		;SEE IF THIS PHYSICAL PAGE IN USE
	JUMPE TAC,GTXCOM	;NO, OK
	CAIGE DSER,GOODPG-1	;SKIP IF NO MORE PAGES TO TRY
	AOJA DSER,GTXCON	;ELSE FIND ANOTHER PAGE
	POPJ P,			;Take failure return

GTXCOM:	SKIPE EXPGT(TAC1)	;IF THE P2 MEMORY IS PHYSICALLY THERE,
	PUSHJ P,DELEMP		; WE WILL HAVE ALREADY ASSIGNED IT THIS VIRTUAL ADDR
	MOVEI TAC,(DSER)	;PHYSICAL PAGE TO ASSIGN
	PUSHJ P,ADDEMP		;GET A PAGE
	SOS HIFREE
	MOVEI TAC,SYSCUS	;CODE FOR IN USE BY SYSTEM
	DPB TAC,COREP
	MOVEI DSER,1(DSER)
	MOVEI TAC1,1(TAC1)
	SOJG DDB,GTXCON
	JRST CPOPJ1		;Success return
>;IFN FTP2!FTDMAP

;Here after operator entered local time, may be PST or PDT, figure out which!
PLCSET:	PUSHJ P,SUNSET		;Set APRSUN and OCTSUN
	PUSHJ P,PDTCHK		;Assume time entered in PST!
	SKIPN DAYLIT		;Did routine decide this must be PDT?
	JRST PLCCHK		;No, must be PST after all, unless ambiguous
	MOVN TAC,[=60*JIFMIN]	;Yes, in that case, back up PSTIME (user's PDT)
	ADDB TAC,PSTIME		; by one hour
	JUMPGE TAC,PLCSE2	;Jump unless back to previous day
	ADD TAC,[=24*=60*JIFMIN] ;Time forward a day
	MOVEM TAC,PSTIME
MIDBAK:	MOVEI IOS,0		;IOS←0 (FOR DIVI BELOW)
	SOS TAC,PSDATE		;DECREMENT DAY
	IDIVI TAC,=31		;TAC1←DAY OF MONTH -1
IFN TAC-IOS-1,<.FATAL ACs IOS and TAC are not contiguous as required here.>
	DIVI IOS,=12		;IOS←YEAR-1964, TAC←MONTH-1 (0=JAN)
	LDB TAC,PMONTB		;TAC←(NUMBER OF DAYS IN MONTH)-1
	CAIL TAC,(TAC1)		;SKIP IF PAST THE END OF THE MONTH.
	JRST PLCSE2		;(STILL INSIDE OF THIS MONTH)
	CAIN TAC,=27		;SKIP IF THIS IS NOT FEB.
	TRNE IOS,3		;FEB. SKIP IF LEAP YEAR
	JRST MIDBAK		;BACKUP DATE TO LAST DAY OF MONTH
	CAIE TAC1,=28		;ALLOW FEB 29 TO EXIST
	JRST MIDBAK		;BACKUP TO LAST REAL DAY OF MONTH
PLCSE2:	MOVE TAC,PSTIME		;Get newly calculated PST time
	MOVEM TAC,TIME		;Now assume again that we are using PST
	MOVE TAC,PSDATE		;Copy PST date
	MOVEM TAC,THSDAT	; into local date
	SETZM DAYLIT		;Make look like really PST
	PUSHJ P,PDTCHK		;Now see if we become PDT again
	SKIPE DAYLIT		;Skip if not PDT after all!!
	JRST CPOPJ1		;Phew, made it, really PDT
;User gave us an impossible time of 2-3am on first Sunday in April, so now
;it looks like 1-2am PST.
	MOVE DAT,LINEP
	MOVEI TAC,NONXTM	;Tell user he blew it
	PUSHJ P,CONMES
	JRST OPOUT		;Type error message and take error return

NONXTM:	ASCIZ/πImpossibleπ time, neither PSTπ nor PDT!π  At 2am, time became 3am.
/

AMBGTM:	ASCIZ/πAmbiguousπ time, could be either PST or PDT -- assuming PDT.
/
AMBGT2:	ASCIZ/If time is really PST, use SETTIME command to advance local time an hour.
/

;Here with time presumably PST.  See if ambiguous 1-2am on last Oct Sunday.
PLCCHK:	MOVE TAC,PSDATE
	CAME TAC,OCTSUN		;Possible ambiguity?
	JRST CPOPJ1		;Nope, we're home free!
	MOVE TAC,PSTIME		;Today is last Sunday in Oct, what time is it?
	CAMLE TAC,[2*=60*JIFMIN] ;Before 2am (ambiguous if so)?
	JRST CPOPJ1		;No, all OK, must be really PST
;(Must be after 1am or PDTCHK would have said it was PDT.)
	SUBI TAC,=60*JIFMIN	;Back up an hour, user can advance time to
	MOVEM TAC,PSTIME	; correct if we guess wrong this way.
	MOVE DAT,LINEP
	MOVEI TAC,AMBGTM	;Warn user of ambiguity
	PUSHJ P,CONMES
	PUSHJ P,OPOUT		;Type warning message
	MOVE DAT,LINEP
	MOVEI TAC,AMBGT2	;Second part of warning message
	PUSHJ P,CONMES
	PUSHJ P,OPOUT		;Type warning message
	JRST CPOPJ1		;Take success return anyway

PDTSET:	PUSHJ P,SUNSET		;Set APRSUN and OCTSUN
	JRST PDTCHK		;CHECK DAYLIGHT SAVINGS TIME

;From 1966 to 1986, daylight saving time went from the last Sunday in April to
;the last Sunday in October.  A 1986 law changed the start to the first Sunday
;in April.
SUNSET:	MOVEI TAC,(DAT)
	IDIVI TAC,=31*=12	;GET YEAR IN TAC
	IMULI TAC,=31*=12	;DON'T YOU WISH WE WERE IN BASE =31*=12
	PUSH P,TAC
	ADDI TAC,<4-1>*=31+=7-1	;APRIL 7, THIS YEAR
	PUSHJ P,LASSUN		;FIND first SUNDAY IN APRIL
	MOVEM TAC,APRSUN	;STORE DATE OF first SUNDAY IN APRIL
	POP P,TAC
	ADDI TAC,<=10-1>*=31+=31-1 ;OCTOBER 31, THIS YEAR
	PUSHJ P,LASSUN		;FIND LAST SUNDAY IN OCTOBER
	MOVEM TAC,OCTSUN	;STORE DATE OF LAST SUNDAY IN OCTOBER
	POPJ P,

;Find last Sunday on or before a given date.
LASSUN:	PUSH P,TAC
	PUSHJ P,DAYCNT		;DAYS FROM 0 TILL THEN
	IDIVI TAC,7		;TAC1←DAYS FROM WEDNESDAY (SUNDAY=4)
	SUBI TAC1,4		;SUBTRACT SUNDAY
	SKIPGE TAC1		;SKIP IF SUNDAY, MONDAY OR TUESDAY
	ADDI TAC1,7		;MAKE WED-SAT POSITIVE
	POP P,TAC		;Get date back
	SUBI TAC,(TAC1)		;System date of last Sunday on or before date
	POPJ P,

TBAD:
IFKL10,<
skipe maintm	;ignore clock unless in maint mode
	PUSHJ P,VENTIM			;READ 11'S TIMEBASE (IN PST)
	 JRST TBAD1
	MOVEM J,PSTIME
	MOVEM DAT,PSDATE
	MOVEM J,TIME			;STORE TIME
	MOVEM DAT,THSDAT
	PUSHJ P,PDTSET			;SET UP APRSUN, OCTSUN AND DAYLIT
	MOVE TAC,TIME
	IDIVI TAC,JIFSEC
	HRL TAC,THSDAT
	MOVEM TAC,TIMDAT		;<DATE>,,<TIME IN SECONDS> FOR DAYT2
	MOVE DAT,LINEP			;TELL OPERATOR WHAT WE DID
	MOVEI TAC,[ASCIZ /PDP-11 (local time) timebase is /]
	PUSHJ P,CONMES
	PUSHJ P,DAYT2			;IN CLKSER
	MOVEI TAC,[ASCIZ /Type Y if this is ok:  /]
	PUSHJ P,CONMES
	PUSHJ P,OPOUT			;DUMP CTY BUFFER ONTO THE CTY
	PUSHJ P,CTGETC			;LOOK FOR TYPEIN.
	JRST .-1			;NONE.
	PUSH P,TAC			;SAVE CHARACTER
	PUSHJ P,CTPUTC			;ECHO THE CHARACTER
	MOVE DAT,LINEP
	PUSHJ P,CRLF
	PUSHJ P,OPOUT
	POP P,TAC
	CAIE TAC,"Y"
	CAIN TAC,"Y"+40
	POPJ P,
>;IFKL10
TBAD1:	SETZM DAYLIT			;HE DIDN'T.  START OVER
	PUSHJ P,DATLOP			;GET IT FROM THE OPERATOR INTO THSDAT
	PUSHJ P,TIMLOP			;INTO TIME
	MOVE TAC,TIME
	MOVEM TAC,PSTIME
	MOVE DAT,THSDAT
	MOVEM DAT,PSDATE		;PDTSET needs date in DAT and elsewhere!
	PUSHJ P,PLCSET			;SET APRSUN, OCTSUN, DAYLIT
	 JRST TBAD1			;Impossible time, try again

TOKNOW:
NOKL10,<
	SKIPN MAINTMODE			;Is it being loaded down?
	SKIPE TTYLOK
	  CAIA				;  Yes
	 JRST TOKNW2			;  No, don't set time to come up
	MOVEI TAC,UTIMEM		;Prompt
	PUSHJ P,TIMLP2
	  TDZA TAC1,TAC1		;Only gets one chance.
	HRL TAC1,TAC
	MOVEM TAC1,COMEUP
TOKNW2:
>;NOKL10
IFKL10,<
	MOVE TAC,PSDATE			;STORE PST IN PDP11 TIMEBASE
	PUSHJ P,DAYCNT			;CONVERT TO DAY COUNT
	MUL TAC,MIDNIT			;TIMES JIFFIES PER DAY
	MOVEI AC1,0
	MOVE AC2,PSTIME
	DADD TAC,AC1
	DMOVEM TAC,KLTIME
	PUSHJ P,STIMBS			;SET PDP-11'S TIMEBASE
>;IFKL10
	POPJ P,

IFKL10,<	;called from CORE
;Make a typed-in char upper case and echo it with CRLF
↑CTPUTU:CAIL TAC,140
	SUBI TAC,40		;make upper case
	PUSH P,TAC
	MOVE DAT,LINEP		;initialize output byte ptr
	PUSHJ P,CTPUTC		;echo the char
	PUSHJ P,CRLF		;acknowledge receipt of the letter
	PUSHJ P,OPOUT		;type out output buffer
	POP P,TAC		;return upper case char
	POPJ P,
>;IFKL10
;⊗ OPOUT OPOUT1 TYONCE OPOUT2 TODATE DATPTR TIMEM UTIMEM

;ROUTINE TO TYPE A LINE ON OPERATOR CONSOLE
;ECHO CHECK STOPS LINE AND RETURNS
;CALL:	DAT SET TO END OF MESSAGE

↑OPOUT:	PUSHJ P,CTGETC		;READ CHARACTER TO CLEAR INPUT, IF ANY
	JFCL			;IGNORE
	MOVE TAC,LINEP
OPOUT1:	CAMN TAC,DAT
	POPJ P,
	PUSH P,TAC
	PUSHJ P,CTGETC		;DID OPR TYPE ANYTHING?
	JRST OPOUT2		;NO.
	SUB P,[1,,1]		;YES.  ADJUST STACK
	MOVEI CHR,15
	PUSHJ P,TYONCE
	MOVEI CHR,12
↑TYONCE:PUSH P,TAC
	MOVE TAC,CHR
	PUSHJ P,CTPUTC
	JRST TPOPJ

OPOUT2:	ILDB CHR,(P)		;GET NEXT CHARACTER
	PUSHJ P,TYONCE
	POP P,TAC
	JRST OPOUT1

TODATE:	ASCIZ /
Type today's date as mm-dd-yy: /

DATPTR:	POINT 7,SYSDAT		;POINTER TO SYSTEM DATE

TIMEM:	ASCIZ /
Enter local time in 24-hour format: /

NOKL10,<
UTIMEM:	ASCIZ /
Reload for users at: /
>;NOKL10
;⊗ GETLIN GET1 DELETE DELET1 TYINCE

;ROUTINE TO READ A LINE FROM OPERATORS CONSOLE
;CALL:	PUSHJ P,GETLIN
;	JUST A CR TYPED IN
;	A LINE TYPED IN,TAC SET AS BYTE POINTER


GETLIN:	MOVE TAC,LINEP
	MOVEI J,0
GET1:	PUSHJ P,TYINCE
	CAIN TAC1,177		;RUBOUT?
	JRST DELETE
	MOVE CHR,TAC1		;NO, ECHO CHAR.
	PUSHJ P,TYONCE
	IDPB TAC1,TAC		;AND STORE CHAR.
	CAIE TAC1,15
	AOJA J,GET1
	MOVEI CHR,12		;OUTPUT LF
	PUSHJ P,TYONCE		;TYPE OUT
	MOVE TAC,LINEP		;RESET BYTE POINTER
	JUMPN J,CPOPJ1		;NULL LINE?
	POPJ P,			;YES, DON'T SKIP RETURN

DELETE:	JUMPE J,DELET1		;AT BEGINNING OF LINE?
	ADD TAC,[070000,,0]	;NO, BACK UP BYTE POINTER
	TLNE TAC,400000		;FINISHED THIS WORD YET?
	ADD TAC,[347777,,-1]	;YES, BACK UP ADDRESS
	MOVEI CHR,134		;OUTPUT BACK SLASH
	PUSHJ P,TYONCE
	SOJA J,GET1

DELET1:	MOVEI CHR,15
	PUSHJ P,TYONCE
	MOVEI CHR,12
	PUSHJ P,TYONCE
	JRST GETLIN

;WAIT FOR CHARACTER.  RETURN IT IN TAC1

TYINCE:	PUSH P,TAC
	PUSHJ P,CTGETC		;GET A CHARACTER
	JRST .-1		;NONE THERE YET.  TRY AGAIN
	MOVE TAC1,TAC
	JRST TPOPJ
;GET DATE AND TIME FROM CTY ;⊗ DATLOP TIMLOP TIMLP2 DECIN DECIN1

;ASK FOR TODAY'S DATE AND CONVERT
;DATE STORED AS ((Y-64)*12.+M-1)*31.+D-1

↑DATLOP:MOVE DAT,LINEP
	MOVEI TAC,TODATE
	PUSHJ P,CONMES
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN
	JRST DATLOP
	PUSH P,TAC		;SAVE INPUT BYTE POINTER
	MOVEI IOS,11		;STORE DATE TYPED IN ON TOP OF DATE OF SYSTEM
	MOVE J,DATPTR		;MAX. OF 11 CHAR. INCL. CR
	ILDB TAC1,TAC		;CLOBBER SYSDAT
	IDPB TAC1,J
	CAIE TAC1,15
	SOJG IOS,.-3
	POP P,TAC		;RESTORE INPUT BYTE POINTER
	JUMPLE IOS,DATLOP	;TOO MANY CHARS?
	MOVEI TAC1,0		;STORE NULL ON TOP OF CR
	DPB TAC1,J
	PUSHJ P,DECIN		;MONTH
	JRST DATLOP		;ERROR
	SKIPE TAC1
	CAILE TAC1,=12
	JRST DATLOP
	SUBI TAC1,1
	IMULI TAC1,=31
	MOVEM TAC1,THSDAT
	PUSHJ P,DECIN		;DAY
	JRST DATLOP
	SKIPE TAC1
	CAILE TAC1,=31
	JRST DATLOP
	SUBI TAC1,1
	ADDM TAC1,THSDAT
	PUSHJ P,DECIN		;YEAR
	JRST DATLOP
	CAIL TAC1,=80
	CAILE TAC1,=99
	JRST DATLOP
	SUBI TAC1,=64		;YEAR ZERO
	IMULI TAC1,=12*=31
	ADDM TAC1,THSDAT
	POPJ P,

↑TIMLOP:SETZM TIME		;GET TIME OF DAY
	MOVEI TAC,TIMEM
	PUSHJ P,TIMLP2
	  JRST TIMLOP
	IMULI TAC,=60
	ADD TAC,TAC1		;TAC←NUMBER OF MINUTES PAST MIDNIGHT.
	IMULI TAC,JIFSEC*=60	;CONVERT MINUTES TO JIFFIES
	MOVEM TAC,TIME
	POPJ P,

TIMLP2:	MOVE DAT,LINEP
	PUSHJ P,CONMES
	PUSHJ P,OPOUT
	PUSHJ P,GETLIN
	  POPJ P,		;JUST A CR
	PUSHJ P,DECIN
	  POPJ P,		;  Bad number for time.
	MOVE TAC,TAC1
	IDIVI TAC,=100		;HOURS IN TAC, MINUTES IN TAC1
	CAIGE TAC,=24		;ERROR (SKIP) IF HOURS EXCEED 23
	CAILE TAC1,=59		;ERROR (NO SKIP) IF MINUTES EXCEED 59
	  POPJ P,		;  Not a reasonable time
	AOS (P)			;Sucess.  Take skip return.
	POPJ P,

DECIN:	ILDB TAC1,TAC	;FIRST, SKIP NULLS, SPACES, AND TABS
	JUMPE TAC1,DECIN
	CAIE TAC1," "
	CAIN TAC1,11
	JRST DECIN
	CAIG TAC1,"9"
	CAIGE TAC1,"0"
	POPJ P,
	SUBI TAC1,"0"
DECIN1:	ILDB AC1,TAC
	CAIE AC1,"-"
	CAIN AC1,"/"
	JRST CPOPJ1
	CAIE AC1,15
	CAIN AC1,12
	JRST CPOPJ1
	CAIG AC1,"9"
	CAIGE AC1,"0"
	POPJ P,
	SUBI AC1,"0"
	IMULI TAC1,=10
	ADD TAC1,AC1
	JRST DECIN1
BEND SYSINI

HISYS		;HIGH CORE
