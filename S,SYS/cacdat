COMMENT ⊗   VALID 00094 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00028 00002	 SYSDSP
C00031 00003	LOWCOR 210 
C00036 00004	 KLEPT KIEPT TO11BP TO10BP DTEVEC EPT143 KLEOVT KLEPDT KLET3T DTFLG DTCLK DTTIME DTT11 DTF11 DTCMD DTCHR DTMTD DTMTI DTSWR DTQMP DTQM2 EPTTB EPTPRF KLITVC KLESEC NKLSEC KLUPT KLLUUP KLUOVT KLUPDT KLUT3T KLUUFG KLUUPC KLUUEA KLCNTX KLUUOW KLUUPC KLCNTX KLKNTW KLKTW KLSNTW KLSTW KLCNTW KLCTW KLPNTW KLPTW KLPFW KLPFFG KLPFPC KLPFNP KLPFW KLPFPC KLPFNP UPTEBX UPTMBX KLSBDI KLUSEC CSTDEF CST EXPGT PSB
C00045 00005	 PUSHIT PUSHOK POPIT
C00047 00006	 FDDTCA XDDTCA WDDTCA FDDTC2 DDTCALL DDTCL1 DDTBAG NODBEL NXDDT DDTPAC WFMES WMES DMES
C00050 00007	 AUTOLOAD AUTOP1 RSTPNT
C00051 00008	 ...TM2 ...TM3 ..PDL DDTTYPE DDTTY1 DDTTY4 DDTTY2
C00053 00009	 P2DDB NOP2 DIDLOD P2ADBD PWRCNT XJBPFI REFLAG MAINTMODE NOLOGIN BLTSWP SYSSIZ DEBMOD NDBCNT DEBCNT
C00055 00010	 PICON INIMES SAVITM DEVLST
C00056 00011	 CTGETC CTPUTC LINEP LINBUF SYSDAT TYO CONTYO CONTYI
C00058 00012	 CH1 SAMHJ CH1SPR CH2 SAMLJ CH3PCP CH3 DPYCON KLPARC CH4 DTCCON MTCCON IMPOTS IMPCTS CH5 LPTCON IMPETS IMPOTS IMPCTS KIMCNI CH6 IOPCON SIXICN SIXIJM SIXOCN SIXOJM CH7
C00073 00013	 INTPLN CH5PDL CH1SAV SAMSVH CH1RET CH2SAV SAMSVL CH2RET DTCSAV CH4SAV CH4RET SCNSAV CH5SAV CH5RET CH5OK CH5OK2 CH5LUZ CH5LU2 CH5LU3 CH7CHK SCNTAC CH7LUZ OFSPDL TVSAV CH6SAV CH6RET
C00081 00014	 CH1PDL CH2PDL CH4PDL CH5PDL CH6PDL CH1SAC CH2SAC CH3SAC CH4SAC CH5SAC CH6SAC MPIPI MPEPI MPPPI MPIPI MPEPI MPPPI IMPBTS
C00083 00015	SIZE DATA FOR DISKS, ETC.  MAXUIS MXSTRU DSKAB DTYPLN MXPGUN MXPGUN MXPGUN MAXRPB NAME DSKSZ1 DSKSZ2 DSKSZZ DSKSZZ
C00091 00016	 CUADDR DSKADR SNSLEN NSWCYL NSWCYL PACKAD ZZZ TTRK ZZZ LSTBIT SATWCT LSTUBT SATUWC LSTADR LSTTRK NCYL CUDVAD RCLTAB
C00095 00017	 SAT2RC BADMAX ECCTKS BADSIZ DSTCNT DSTPUT DSTBLN DSTBUF DSTBLN DSTBUF INTRTN UUOACS UUOACS UUOACS DSKPDL DSKSV ACDDB SWPDDB UFDUSE UFDWAT UFDWAK SATDIR SATADR TSATSZ BFSET BFSETS LSTRKT DKDBML LSTBTB UDPOWN UDPCNT SATMOD SDB0 ST.NAM ST.SAD ST.SSZ ST.BFS ST.BSS ST.LAD ST.RPB ST.RTS ST.MDB ST.BTB ST.LSA ST.JOB ST.CNT ST.SMD ST.MFA ST.STA ST.STB ST.STN ST.TYP SDB$UNUM ST.NAM ST.SAD ST.SSZ ST.BFS ST.BSS ST.LAD ST.RPB ST.RTS ST.MDB ST.BTB ST.LSA ST.JOB ST.CNT ST.SMD ST.MFA ST.STA ST.STB ST.STN ST.TYP RHSDB ST.NAM ST.SAD ST.SSZ ST.BFS ST.BSS ST.LAD ST.RPB ST.RTS ST.MDB ST.BTB ST.LSA ST.JOB ST.CNT ST.SMD ST.MFA ST.STA ST.STB ST.STN ST.TYP ST.RPC ST.BPC ST.SCW ST.RPU ST.STS ST.NSS ST.FSS ST.UIS ST.PUC ST.UIL ST.LEN SDBUDB SDBNUM SDBSTS SDBNSS SDBNAM SDBSIZ SDBRXB SDBFSS SDBTYP SDBPUC SDBADR STRTAB STRMAX STRN SBWLH SBWLT SBACNT SBATAB
C00111 00018	 A A DSKDDB C1PDLL IRBLEN NPPXFR DQLEN DDBSIZ RHDBSZ FWRTVL
C00122 00019	 DSKOPS DSKOVC SATID2 DSKHNG NECCS PRTLOG SATID1 RTRHCT NECCTK FXTRKN ECCTKT ECCEND ECCAOB ECCMSG ECCMS2 LECCQU ECCQUI
C00126 00020	 SECTBL ERRCL0 ERRCL1 ERRCL2 ERRCL3 ERRCL4
C00127 00021	 MAXCL0 MAXCL1 MAXCL2 MAXCL3 MAXCL4 TYMSK0 TYMSK1 TYMSK2 TYMSK3 TYMSK4 TOTCL0 TOTCL1 TOTCL2 TOTCL3 TOTCL4 TYPCL0 TYPCL1 TYPCL2 TYPCL3 TYPCL4
C00129 00022	 DEATH TYPANY WNTTYP SNSTYP CSTOP HNGFLG DSKFLG REGOFL T1SAV NTSTART NSWPOP SWPTWC DSKTWC DKTIME DKATIM DKTIMT NDRDOP NDWDOP NDWROP NDRROP DSKNUM UIWCNT SBWCNT
C00131 00023	 SWPJOB SWPNXT SWPNX2 SWPPRV SWFRST BNDTSZ BNDTSZ MINSBS RHSBSZ NSSUN FSSUN RHSUNP RHSCYP RHSBNP SWBAND
C00134 00024	 C1PHP C1PTP C1EXHP C1PHPU C1SNDP C1CIFI C1SNFP C1RCFP C1RMRT C1WMRT C1NOP C1CUAD C1WCHN PQUEUE PSWAPR PCURCY PTARG PACTIV PSYSBF PSYSBA NC1UP NC1RET NC1RLD NC1DED PQZEND C1CHAN C1ASAV C1ERAD C1PKSV C1DDBS C1LREC C1LSPC C1PRGS C1XPNT SNSDAT SB0SUP SB7SUP C1CCW C1ISW C1PTPE C1PTNX C1IQF C1PPTR C1PCW C1BW C1STA C1HLT C1LE C1SE C1PE C1NXM C1BPE C1SSE C1PCMA C1STB C1STC C1INST C1OVHW C1PRGL NRCCRP C1PRLU C1UDPL C1ALSV C1ADSV C1APSV C1AGSV C1BLSV C1BDSV C1BPSV C1BGSV C1SAVE HBRKPT HBRKVL F2DRED F2DCYL C1DSKA C1DSK2 F2C1PT F2DDSP F2BLTA F2BLT2 F2DCOR F2DSKA F2DCMD DSKTRY PRECAL NXTDAS DKERMS NXTDA NXTMA NXTCMD CURDA CURMA CURCMD F2PRER F2DSER F2RECT F2DAC2 F2DBF0 F2DBF1 N2DBUF N2READ N2WRIT N2PRER N2RBLT N2WBLT PACBSY LSTPAK F2DACT F2DUNF F2DERF DSKLUN ERRBIT NROVRNS NWOVRNS NRECALS
C00147 00025	RH Support  MTAN BUGPLN CHNN RHDTWC RHDTWO RHDTRO RHDRWO RHDRRO RHDDWO RHDDRO TODCLK WREQ MTAJB0 PSKED FACTSW JB0FLG MTPSFK MTCUTB PHYPZS MTINDX PWRDWN DSPSFK PHYTIM CHNTAB MAXCHN PHYSEC ZSEND VSMFLG CTYLNO LSTERR NSKED PHYARG PHYAR2 LPHIPD LPHYPD UIOLST UDIORB PHYACS PHYIPD PHYPDL PHYSVP CHBUDB CHBODT CHBLUC CHBIRB CHBCCL CHBHB1 CHBHB2 BUGHLT BUGCHK BUGINF BUGACS BUGACU BUGPDL BUGLCK BUGNUM PRSNUM FSIPPA FSIPPG IRTNP DMXQTM DMXQWC RHDDBQ RHDQTB RHDQTX
C00152 00026	 DTEINX KLTINX KLCLKF KLECON KLPCON KLITCN SCTERR KLTIME EPDLOV ETRPAC ETRPDL ETRPD PFPARF PFTAC SVPFPC SVPFW SVPFFG KLTPC KLTPCF RLOD11 KLPDL KLPD KLLUUT KLLUUB
C00155 00027	 mtrlst mtrptr MTRLNK MTRDAT MTRVAL MTRTOT MTRCNT MTRREC MTRTMP MTRNUT MTRNUR MTRNUP MTRNUL MTRLNK MTRDAT MTRVAL MTRTOT MTRCNT MTRREC MTRTMP MTRNUT MTRNUR MTRNUP MTRNUL MTRSIZ MTRSWP MTRSHF MTRWST MTRCST MTRMAP MTRNXT MTRPWT MTRXWT MTRWSC MTRSPR CH3MSV CH4MSV CH5MSV CH6MSV CH7MSV MTCSHX MTRJBP MTRCNM MTRCNW MTRPTR MTRCOD MTRJOB MTRNSC MTRBKG MTRDS2 MTRDS3 MTRDTN MTRDSK MTRDS1 MTRLST
C00164 00028	 DISNOP DPYHDR BUFL ZZQ MAXPT RDPYLN
C00177 00029	 IIIOFF DRUNCT SAVTAC DPCNI LCPDL SVDPDT BUGDPL DPYPDL CLKPD CLKQUE CLKQ WTFLG SVAC DPYMAP NBS NBS TBL ERRP FREEHD FSWTHD FSWT2H FREEC FREETL FRETOT FSWC CLKLVL CLKQTMP FSW2C NDPMAK DPYMF1 DPYMF2 NREDET MACROC MACROP
C00180 00030	 DDSTART DDCNT DDDSP DDRET DDRTN DDSAC1 DDSAC2 DDSAC3 DDSTAC DDSDAT NDDILL DDNXT DDCUR DDCURT DDCURQ DDCOL DDLST DDOFF DDQUE DDSQ DDLFD DDTYPE DDNBR DDTOT DDMAX DDREST GRNGEN GFIII GIII GDD GENX GNOSP GDARK GDHEI GDWID GTEXT GADD GDDSR GARG GSEA GSEB GSEC GSLA GSLB GSLC GIDSP GRNADR GRTN GTMO GCOM GTMP GCTMP G177 GPTR GCCNT GOFF GMASK GRNCHG GXPOS GYPOS GLMODE GSETCM GVECS GLLUM GLLWM GSENDX GNEEDC
C00186 00031	 DELCS DMMCNT DMMAXG DELRS DMLFS DMSTR LDMSTR TABSET LTABSE AVLFST AVLLN AVLVP WHOKLU WHOTX WHOF2
C00189 00032	 DDQSIZ DDQTAI DDQDLY DDTAB DDFLST DDFCNT AVLCHN AVLCH2 AVLBIT VDMAP VDPRM VDTIE TVIBEG TVWAIT TVTUNE TVCHAN TVIEND TUNEIT DDSPCH LQBLTB LQBLPP LQBLMS LQBLPI LQBLSQ LSMFTB LSMFMS LSMFFD LSMFFM
C00192 00033	 ZZ DTCDDB DLINK UNIT UNIT
C00195 00034	 BLKPTR DMPPTR DMPLST DTOTAL DFTOTAL DTTAC DTUNIT ERRFLG RBNCNT UBUF UERRCN UTCMAP DTTAC1 USVDB BLKCNT UBKN BNDISP CONSZ1 RDBN WTRV RDRV ENPT1 ENPT DMPADV DCLOC DCLOC1
C00200 00035	 LPTDDB LPTIOS LPTDCN LPTBG1 LPTBG2 LPTXCT SYSPDL LPTIBF LPTUBP LPTIBP LPTCC LPTLCC LPTLIN LPTPSZ LPTPAP
C00202 00036	 CARDDB CARALR CARBPT CARDEF CARAC1 CARBUF
C00204 00037	 XGPDDB XFCJN1 XMSET XGPMDP XGPNXC
C00206 00038	 VRNDDB
C00207 00039	 PTRDDB PTRADR PTRBTP
C00208 00040	 A A PTPDON PTPNOT PTPDDB PTPCPW PTPUBP PTPUDS DDBDAT PLTDDB
C00211 00041	
C00217 00042	 TTPLEN TTPSIX SCNDDB TTYLST
C00222 00043	 COMAGN NLCOMS LCOMS LDDBS LTIMS FRCFLG ATTDEV LINSAV LINSV1 SCNCNT SCNCN2 SCNBUG SCNBU3 OFSPD1 OFSPDL OFSPD TTYLOK DKBCHR PTLBUL PTLBUF PTLPTR PTLTKR RUBLUZ RECLUZ LINTAB HOMEPT PTYJOB PTYIMP DPYDES DPYNAM EDITKY PADCNT TTYENB DKBBAD KIMTAB KIMSVA KIMSV1 KIMNHM KIMNSM
C00231 00044	 GRCALL GRCHAN NGRCHN GRASUP GRELSZ GRSCSK GRTPSK GRSCSK GRTPSK GRNDIM GRSKIP MCKBBW MCWD0 MCWD1 MCWD2 MCSHF1 MCSHF2 MCTOP1 MCTOP2 MCCTL1 MCCTL2 MCMET1 MCMET2 MCCAPS
C00236 00045	 ABRIDL LS110 LS134 LS150 LS300 LS600 LS1200 LS1800 LS2400 LS4800 LS9600 LS1512 LS55 LS75 LSEXT LS1218
C00242 00046	 DCADP0 DCATAB FPORDM NPORDM FPO12A NPO12A FPO12B NPO12B DCANUM DCADP0 DCATAB FPORDM NDC10E NPORDM NDC10E NPORDM DLSNUM DCANUM NNODLS DCADP0 DCATAB FPORDM NDC10E NPORDM DLSNUM DCANUM NNODLS DCABEG NPORTD NDCAER NDCAIN CDCAIN KBDNXT FONTTY NNOREP NNOPOR DCAPIN DCACIN DCAREC DCAINN DCAMIN DCAOER DCABER KBDCHR DCAEND MAXBER CHKDCA
C00254 00047	 DILLIN DILTAC DILJ DILZBG DILJOB DILCNI DILIDS DCLKNM VDITOC VDISTS VDILST DILZND DILINN
C00256 00048	 ADCDDB DACDDB KIMDDB SAMDDB RTJDDB DUMDSP
C00259 00049	 SIXDDB SIXMDL SIXDLN SIXDAT SIXBKO SIXOUL SIXBKI SIXHD1 SIXHD2 SIXFSB SIXINL SIXSVA SIXSV1 SIXSEQ SIXFSL SIXNIW SIXFSD SIXNWW SIXNNF SIXTMF SIXFDW SIXILI SIXILO SIXN6B SIXNJE SIXNON SIXNME SIXNN6 SIXLME SIXFP SIXCLW SIXPDP SIXSVP SIXWTW SIXDTL SIXLDN SIXICN SIXIJM SIXOCN SIXOJM
C00265 00050	 SAMDDB SAMDAT SAMDLN SAMCNA MASKB SAMSAV SAMSV1 SAMSV2 SAMPI SAMSTE SAMHON SAMLON SAMGAG SAMTII SAMTIC SAMOOP SAMCTA SAMCTB CIQLEN CIQ CIQAVL CIQIP CIQOP CIQFUL SAMMNW SAMDT SAMSEQ SAMDTL SAMLSA SAMLSD SAMLSW SAMLSX SAMPTB SAMDRB SAMWBG SOFLEN SAMCD SAMRD SAMWD
C00271 00051	 POLDDB POLDAT POLDLN
C00273 00052	 MTCDDB DLINK MTCENT MTCLPE MTCPER MTCENT MTCMIS MTDCMS MTCBKN MTCSSV MTCRET MTCLSR MTCNSR MTCNS2 MTCNS3 MTCNS4
C00277 00053	 MTEOFF MTDEV DCWRD MISSED MTERCN MTREWN MTCMDP SVCNTR MTWCMA MDCSAV MTIDSP MTCUSR MTCRMX MTBLK MTBLKP MTTAC MTTAC1 MTCMAP MTDINT MTDIN2 MTQBG1 DCTMA1 DCLUZ1 DCCON1 DCMIS1 DCTMB1 MTSCN1 DCTMA4 DCLUZ4 DCCON4 DCMIS4 DCTMB4 MTSCN4 MTSCON MTERRA MTERRW F2MTMX F2MTBF
C00283 00054	 MTUDDB DLINK MTURWN
C00289 00055	 SPWA SPWSAC USRSAC SPWBUT SPWACT SPWGO JBTST2
C00291 00056	 SCHMQT JOBQUE CPFAC1 CPFAC2 BTSIZ BTTIM SCHBEG JLCYET JLFACTOR RJLFACTOR OINTIME OUTIME JLRIT ORDYET JBTPRI JBTNPR JBTPL JBTJL JBTJLH JBTICP SCHEND GCBITS JBTQ JBTSCS SWPCHK SWPCH2 SWPJMX SWPMXP SWPLMX SWPLMJ JBTSWP JB2SWP CORPTR FINISH FORCE FIT XPANDF FULCNT SEGWAIT MAXSIZ MAXJBN MAXRSZ MAXRJB MAXSSZ MAXSJB SUMCOR NEEDED LASTIN ESEGNO AVALTB CALLTB
C00298 00057	 REQTAB QJOB XJOB SQREQ SQREQ1 SERA SWPCNT SERACT CORMX CORHMX ISONE
C00300 00058	 SYSTOP SYSPAG CORNXM CORBEG CORTAB LOFREE HIFREE HIUSED FSTOP FSPAG LOKTOT CORMAX USRMAX HIFSEV HIFSBG COREND %SWPL SWAPLI JBTPLN ARMBEG ARMBEG ARMLEN MEMCON LMEMCON MEMNXT
C00305 00059	 FSNINIT FSHINIT HFSPAG TSHF TRIVIAL NFSB FSBEG FSCNT FSLIST JBTPDL FSCLKF FSGVKF FSRTL FSNEWK FSCKCT FSBUSY HFSBSY FSHCLK FSHJOB HFSAVB FSAVB FSHOFS FSRPQ FSBLUZ FSNCLK FSIPTR FSOPTR FSHUNG FSGTUF SPFSNT FSMPLH FSEND FSLIMIT FSLIM1 FSLIM9 FSVBXX
C00309 00060	 SFSIZE SFLINK SPFSN SFLOSS LSBK SFNWT NSPLN SFHEAD DDFS TTYFS DHFS LPFS PPFS IMPFS BIBFS FMBFS SDBFS RHDBFS DPYFS
C00313 00061	 TVBLEN TVDDB TVBUF TVBUFP TVMARG TVARGS IOPCNI IOPBSY IOPHCT IOPWCM
C00315 00062	 ELFDDB ELFLOC ELFDLN ELFCUR ELFDDB ELFLOC ARMDDB GRNDDB
C00317 00063	 FSCSZ NFSCSZ FSCFLG FSCADR FSCCNT BATMAN BATLEN ROBIN ALFRED GORDON BATCAR BATYET BATPNT PRIJOB PRIEXT NSPLRS
C00329 00064	 JOBNM1 TSAVUU TSAVJ ONCEI SYSTHERE DAMESS DISMON MONPTR MONSUM HMNPTR HMNSUM FIXBUF ERRYET TIMDAT PSTDAT INITIM DAYLIT APRSUN OCTSUN PDTCNT PITFLG USTIME UUTIME SFTIME SAC2SH PAGREG PAGINT PAGPLN PAGPDL PAGPD PFPDL PFPD PFLTPI
C00333 00065	 P1DATA SPWRAN SPWUUF SPWTMO SPWBLO SPWXCT SPXITF INTACT INTNF INTACS INTSAC INTDISP INTSP INTREQ INTQUANT INEPLN INEPDL INEPD CLKSV CLKESV ...TMP APRTAC APRTC1 APRAC1 APRAC2 APRJ APRIN1 APRIN2 APRIN3 APRID APRERR APRPC PAGFLG F2ILM APRPLN APRPDL APRPD ERRPLN ERRPDL ERRPD DSFLAG JOB SJOB
C00336 00066	 USRPRT USRHCU USRPC USRDDT USRJDA USRLO USRLO1 USRHI CHKYET UUO0 UUO2 PIERR ESVPID UUOWRD UUOLOC UU2LOC CLOCKP NULDAT PALIVE NULBAD CIPWT USRSAV CLKFLG CLKS17 USAVPC CLKPDL CLKCH TIMEFF TIMEF TIME THSDAT UPTIME INTIME PSTIME PSDATE SCHEDF COMFLG UUOXIT UUOXI PDATALEN P1PID
C00341 00067	 SYSBEG BIGTIM BIGJMP NINTS1 NINTS CH1SPU CH2SPU CH3SPU CH4SPU CH5SPU CH6SPU CH7SPU LPROGR NPROGR PROGR PROGF PROGP NDDLUZ NDDNXM NDDCLK NCLRSP UUO.SA ...TAC LASTDI LASTRE COMCNT HNGTIM ASSLGN ASSJBN LDPWR LDSHF LDAVG DQAVG DCAAVG DQCNT DQTOT NDQTOT APRLST ESTINT PFIOEF PFIOT1 PFIOFG
C00346 00068	 DDBCNT JBTCSH JBTSTS JBTDVW JBTGSL NJOBS CJOBS UUOPC UUOOPC JBTUPC JBTPAG JBTMAP JBTMA2 WRKSET JBTSWA SWPDDB JBTSWS SWOCNT PFFLDC SWPPSV JBTPR2 JBTLIN JBTPRV JB2PRV JBTPPN PRJPRG DSKPPN SLRMAX SLCOST SLNRES SLRES
C00350 00069	 JOBNAM JOBPPN JOBCRD JBTUFD CUSLOC JOBDEV JOBLOG JBTKCJ JBTBTM RTIME TTIME FTIME XTIME JBTRNB JBTWAT JB2WAT MTRETIME MTRMTIME MTRTTIME MTRXTIME MTRRNB MTRRTIME NSCHOF LXRTIM JBTMSC JBTDDB JBTIOW STIME ASTAB ASBTAB ASHTAB PAGNOW DDFSPC ESCDIF GOTARG RSPLOK PHYLIN LITOFF
C00355 00070	 PCHRES PNUMES PSGNES PHIDDN DDQREQ DDQLNK LSTESC IRMCNT PRGESC LETAB TTYTAB CRMCPT TIME11 DATE11 CONYET CONALV RSTBEG JBTIOP JBTSIN SAVSAI JBTDTS JBTGLU JBTFS JBTMAIL JBTTCR JBTMSK JBTIEN JBTIRQ JBTWKM JBTIRU JBTIIP INTDTM UUOPTR RSTEND STATS STATNUM STATIM FATALE POPUPF
C00360 00071	 LDDWQ DDWQ LDMWQ DMWQ DMWQNX MXJCOR LASTUP LASTNL JBSRUN WHONXT WHDDNX NEXTDM NXTPTY WHOPTR WHDMPT WHODAT SPCWRD WHOJOB FREWAT FRETAB T15CNT DKBCNT NDDXOL NDDLOL NDSTAT BADADR SYSEND STATPTR AUTOSYNC BRKMAX BRKTAC BRKAC1 BRKNUM BRKTAB ADRBRA ADRBRO ADRBRC SCNCTY SUPCTY SUICTY DISLEN DISBUF DISPTR DISOPT DISCTR CTYCUR CTYMAR CTYUSR CTYJOB CTYLFS CTYJTM ITHERM OTHERM NMAPLS TTDDCK TTDDCN
C00366 00072	 CLKSAVE CLKSV0 CLKSV1 CLKESAVE CLKES2 INITRP
C00371 00073	 P1RFLG P2SA ERRLOC ERRDAT RERLOC PARPSA ERRPC SYSERR NPARER NPARIN LASLOS ERRJOB GOTNXM NXMPC PARREG
C00373 00074	 STBEG NCORCALLS NFSGETS NFSGIVES NCOMS NDLYCMS NUUOS NSCHEDS NQXFERS NOUTSWPS NINSWPS NDDQUE NNUUOS NFSWAITS NFSLP1 NNULLJS NJSWITCHES NWSCHEDS NTMOS NJRNULLS NPWAITS NLERRS NSAERR NLREQS NLRERS NFSGFA NABFE NABFF NFSLP2 NPUSHD NDDFRM NDDLCT NDDLMX NDDXCT NDDXMX NDDL1C NIOTS NSCALL HGNMAX HGXMAX HGSET HGYET HGCNTS HGCH2 IBMTWC FBTTWC HGCH6 HGSYS HGUSR HGUUO HGSPW HGNULL HGIDLE HGCODE STEND AMC1 AMC2 AMC3 AMC4 AMC5 AMC6 AMC7 AMC8 AMC9 AMC10 AMC11 AMC12 AMC13 AMC14 AMC15 AMC16 AMC17 AMC18
C00380 00075	 NULDDB NULDLN
C00381 00076	IMPDDB  CLSTP RFNMTP ALLTP RFCTP INPTP IDLETP
C00386 00077	IMPSER data  IMPCNT SVRNAM SVRPRV SVRDDB SERVOK IMPST IMPOUM RFNMCT BADNOP ETHINM ETHOUM IMPQLN IMPADR IMPPTR IMPQST IMPQCT IMPQFL IMPSTN
C00389 00078	Misc IP/TCP data  IMPBFT IMPBFX IMPBFX IMPBUF IMPBFE
C00391 00079	NETSUB data  ImpDat MESTYP EPLcnt EPLmax INCcnt INCmax BADIMP BDMLNK BDMMES BDMRFM NORFNM SIZERR ImpHDC HSTCNT BUFERR BUFNUM BUFAVG BIBCnt SIZHST IPELed IPEPrt IPEVer IPEChk IPEUOp IPEFTL IPOpt IPFrag IPFDun ICMNLd ICMDEr ICMChk ICMUnT ICMTyp TCELed TCEMes TCEChk TCEPrt TCEDDB TCEITY TCEUOP TCPOpt TCENIT TCPPRT TCPZRT TCPFTS TCPFTU TCPMNW TCPWFT TCPWET TCEIPC TCPFMB TCPITy TCPOTy IMPDCN
C00408 00080	IMPINT data  BLKIPT INPON DUMMY BLKOPT OUTACT IMPJ OUTBGN
C00409 00081	IPSER data  IpLen IpIBHd IpIBuf IpOBuf ICMPln ICMNLL ICMPIB ICMPOB NxtLBf NxtLvl FstFdb LstId RcvTim IpOptn PrGate IpPDDB ICMBDG ICMBDN ICMBDP
C00412 00082	TCPSER data  OptMSS TCPMax TcpLen TCPIBH TCPIBf TCPObf TCPDat SktNum TCPDDB TCPDCN
C00414 00083	IMPMAC data  HTISiz HTIWds newfrm IMPQLN HDTLEN HDTOVR MS.HGD ZERO INHALT IBFHLT INBUFP MESSIZ impihd LEADER BUFADR FLTFLG STOPFL TESTHS OLINKP NowOut IMPQ IMPQTP IMPQTC IMPQPP IMPQPC IMPREQ CLKSEC DEDFLG PSDDDB ReDirt TikHst HSTLAS LASCHK HOSTS ZERON
C00420 00084	UDPSER data  UDRPRT UDFPRT UDPMSG UDEPRT UDELED UDEMES UDECHK
C00422 00085	 DLNDDB UNIT UNIT DFSWC NINPKT NOUPKT NORPKT NFRERR NCKERR NRCERR NSNERR NRNERR NDOERR NNSERR NRSERR NDLERR NSQERR NRPERR NCRTRN DFWC DIDS DODS DPID DIWS DOWS UUOPDB INTPDB DILIST DOLIST DXLIST DIWIN DOWIN DACK DSEQ DNUMP DNUM DREP DLWC DLINK DLNDLN
C00427 00086	 DLNUTB PDBFL PDBFLN PDBRPN
C00428 00087	 %%NOP %%ECHR %%ECHM %%ENMG %%ENAD %%DTMG %%ENBC %%DTMX ENHADM DTQ%LK DTQ%WC DTQ%XC DTQ%RT DTQ%OL DTQ%MS DTQ%XX TO11QH TO11QT TO11QC TO11MA TO11BE TO11EF DO11ER N11BPE N11TMB N11TMO N10TMO NTO11 NTO10 TO11HC TO10HC QMP11E QMP11M TO10MA QMP10E QMP10M QMPSIZ DTQECH ENINQM ENBCCF HADREQ DTINQH DTINQT DTINQC DTINQM TO10QC TO10QH TO10QT DTEWAT DTECNT DTETMO LDTBUF DTEBUF DTEBEG DTEEND DTEPTR DTETKR DTEBSY DTECCT NDTHIT SDTHIT SD2HIT NDTHNG ND2HNG NDTFUL DTEWAT DTECNT DTETMO DTEWA2 DTECN2 DTETM2 KLEAR KLEAR2 KLPDTO KLPDAT
C00437 00088	 PUPBSZ PUPDDB PTIMES PUPILS PUPBAL PUPMAL PUPNBA PUPNMA PUPRII PUPSII PUPHBA PUPHMA PUPIBC PUPICN PUPPMX PUPOLS PUPOCN PUPCID PUPRID PUPSID PUPLNK PUPCSB PUPTMO PUPMOD PUPDLS PUPDLN
C00441 00089	 PUPMLK PUPCBG PUPLDB PUPLSK PUPFSK PUPHST PUPSTB PUPLKS PUPMH0 PUPNML PUPNPM PUPSMS PUPB11 PUPLMS PUPILF PUPPH0 PUPWHS PUPNXL PUPIPT PUPNER PUPBMS PUPNFS PUPBCK PUPBRD PUPBEN PUPBER PUPIRB PUPNEA PUPUNK PUPEFR LOC PPUPMN PPUPMX XPUPIB XPUPOB XPUPOE XPUPOC PUPFLG NPPMSS PPERCN PUPTEL PUPYET PUPHYT PUPCEN SUENNM SUEHST ENHADR ENNADR SUENNM SUEHST ENHADR ENNADR PUPIRT .PUPON SUSLNM ENNAD2 ENBADR ENBAD2 PSKMAP PUPSVR PUPPRV PUPERF PUPHDW ROUNET ROUGTW ROUINT ROUSIZ
C00453 00090	 PIOFFS PILOST
C00454 00091	 WHOIMP WHOPUP WHOALL NETLST NNETS HSTLST NHOSTS NETARP NI.NAM NI.FNM NI.NAM NI.FNM NI.UP NI.OK NI.IP NI.PUP NI.NTN NI.NSN NI.IPA NI.NTM NI.NSM NI.TMX NI.GTW NI.GTN NI.PGW NI.GWT NI.RTS NI.PRE NI.REL NI.MAK NI.OUT NI.FNA NI.MRL IMPUP OKFLAG MYSITE NETETH NI.NAM NI.FNM NI.UP NI.OK NI.IP NI.PUP NI.NTN NI.NSN NI.IPA NI.NTM NI.NSM NI.NTM NI.NSM NI.TMX NI.GTW NI.GTN NI.PGW NI.GWT NI.RTS NI.PRE NI.REL NI.MAK NI.OUT NI.FNA NI.MRL NETETH NI.NAM NI.FNM NI.UP NI.OK NI.IP NI.PUP NI.NTN NI.NSN NI.IPA NI.NTM NI.NSM NI.NTM NI.NSM NI.TMX NI.GTW NI.GTN NI.PGW NI.GWT NI.RTS NI.PRE NI.REL NI.MAK NI.OUT NI.FNA NI.MRL NILIST NINUM
C00467 00092	 DBGPTR DBGBE0 DBGBEG DBGEND DBGCNT UFDTS0 UFDTS1 UFDCT0 UFDCT1 NUFDLK UFDULO UFDLNO UFDUSO
C00469 00093	 DOMDDB DOMRRS DOMRRL DOMRRP DOMDLN RRLIST RRREFC RRLENG RR.HDR RRTYPE RRCLAS RRTTL RRDLEN RRNAME TY.XA TY.CNAME TY.ALL CL.ALL
C00473 00094	 CACEND
C00474 ENDMK
C⊗;
;⊗ SYSDSP

SUBTTL FIRST 19 JULY 67

;SEE OUTER FOR MORE DEFINITIONS

.AUXIL			; FOR @

;SYSDSP SYSTEM INITIALIZATION DISPATCH TABLE, STARTING AT LOC 200
;THIS SUBROUTINE MUST BE LOADED FIRST
;ROUTINE "ONCE" IS ONCE ONLY CODE. IT CONVERTS THE DATE
;AND SETS UP IO SERVICE CHAIN,

	HIINI		;INITIALIZE TWO-SEGMENT SYSTEM ASSEMBLY (INTO LOWSEG)

IFN FTDDT,<
	LOC 74		;CONVINCE SAVE COMMAND TO SAVE ENTIRE CORE IMAGE
	0,,DDT		;AFTER LOADING WITH SYMBOLS
>;FTDDT

;SEE THE FILE ONCE[S,SYS] FOR SET UP OF INTERRUPT AND UUO AND PAGER TRAP LOCATIONS

IFN FTDDT,<
	LOC 162		;POINTERS INTO DDT FOR UEDDT ONLY (DON'T ANYONE ELSE USE!)
	SYMLOC		;162
	DDTXCOR		;163
	DDTMAP		;164	THESE POINTERS ARE INITIALIZED BY ONCE!
	(RDDTA+777)&777000 ;165/DDTA loader bug here we come (external, in DDT)
>;IFN FTDDT

LOC 200		; THE SYSTEM IS AN ABSOLUTE ASSEMBLY, STARTING AT 200

SYSDSP::JRST SYSINI	;200 - INITIALIZE EVERYTHING. (JRST SYSIN0)

IFN FTDDT,<JRST DDT>	;201 - GO INTO EXEC DDT
IFE FTDDT,<HALT .>	;201 - IF THERE'S NO DDT

IFE FTSCTY,<
	HALT .		;202 - (USED TO BE SYSMAK-MAKE NEW SYSTEM OF JOB 1)
>;IFE FTSCTY
IFN FTSCTY,<
	JRST [	SETOM SCNCTY ↔ JRST DDT ] ;202 ENTRY FOR DDT, FLUSHING SCANNER CTY
>;IFN FTSCTY

	HALT .		;203 - INITIALIZE EVERYTHING. (JRST SYSIN0)

	HALT .		;204 - (P2 RESTART ADDRESS.  P2 DOESN'T USE THIS FILE.)

	HALT .		;205 - BRING MACHINE UP IN MAINTENANCE MODE

	HALT .		;206 - WRITE OUT SYSTEM ON THE SWAPPING DISK

	HALT .		;207 - ERROR STOP - WRITES OUT SAT AND STOPS
;LOWCOR 210 ;⊗

; AT LOCATION 210 BEGINS THE LIST OF USEFUL LOCATIONS
;IN THE SYSTEM USED BY SYSTAT.

;210-217
0,,JBTSTS ↔ PRJPRG ↔ JBTSWP ↔ SPWGO ↔ TTIME ↔ UPTIME ↔ CORMAX ↔ DEVLST
;(0,, IS TO AVOID ASSEMBLING AS JBTSTS UUO)

;220-227
TTYTAB ↔ <BYTE(9)SCNNUM,DPYNUM,DDNUM,PTYNUM> ↔ JOBN-1 ↔ CHKBEG ↔ JBTQ ↔ JOBNAM
	JOB ↔ CONFIG

;230-237
0 ↔ JOBQUE ↔ IFN FTPRIQ,<JBTPRI> IFE FTPRIQ <0> 
  JBTJL ↔ NQUES ↔ QNAMS ↔ JBTLIN ↔ LETAB+DPYL0

;240-247
JBTJLH
IFN FTSTAT, <	STATS ↔ JBTGSL ↔ STATLEN ↔ STATPTR ↔ STATNUM >
IFE FTSTAT, <	    0 ↔ JBTGSL ↔ 0 ↔ 0 ↔ 0	>
							INTIME ↔ STBEG

;250-257
JBTKCJ ↔ JBTBTM ↔ DQCNT ↔ TTYLOK ↔ MAINTMODE ↔ CORPTR ↔ LASTDISASTERTIME ↔ TIMDAT

;260-267
STEND2 ↔ DAYLIT ↔ 0 ↔ WATCPU,,WATSIT ↔ FSRPQ ↔ SYSTOP ↔ CORTAB ↔ NOLOGIN

;270-277
PTYJOB ↔ JBTPRV ↔ UCLLEN⊗9+UCLDLN,,UCLTAB ↔ 0,,DSKPPN ↔ FTIME
		NJOBS ↔ DSKOPS ↔ INITIM
;(0,, IS TO AVOID ASSEMBLING AS DSKPPN UUO)

;300-307
-DISPL,,COMTAB ↔ 0 ↔ LINTAB ↔ ASTAB ↔ JB2PRV ↔ -LFTLEN,,LFTTAB
		-RHTLEN,,RHTTAB ↔ JBTSIN

;310-317
JBTGLU ↔ JOBNM1 ↔ DDFCNT ↔ DSTBLN,,DSTBUF ↔ COMWHO ↔ NPARIN 
		 JBTMAP ↔ IFN FTP2*XGPNUM,<XMSET;>0

;320-327
RTRHCT ↔ TBLKPT,,TPJMP ↔ DPHPOS,,PPCALL ↔ PPRJMP,,PPNO ↔ JBTPAG ↔
		IFKL10,<MTRLST> NOKL10,<0> ↔ SKIPP1 ↔ SKIPP2

;330-337
LEBUF ↔ LDSHF*1000+LDPWR,,LDAVG ↔ DDQSIZ ↔ DDQREQ,,LSTESC ↔ LEPOS ↔ VDTIE 
		DDTAB ↔ JB2SWP

;340-347
;346 gets changed by the RH initialization code (IFN FTRH)
PRGNUM ↔ DDBCNT ↔ DCACAR,,DCATAB ↔ NOKL10,<PSB-EXPGT,,>EXPGT
	IFN FTP2,<XGPAOK> IFE FTP2,<0> ↔ DISLEN,,DISPTR ↔ <RCPBLK+1>,,BKDSIZ
	POINT JOBNSZ,DEVJBN,JOBNPS

;350-357
POINT PUNITS,DEVUNI,35-PUNITP 
	-NDOMSR,,DOMSRV	;351 aobjn ptr to list of default domain servers
	WHOIMP,,WHOPUP	;352 ptrs to blocks for IMP and PUP values
	0		;353 obsolete WHOIMP predecessor
	-NNETS,,NETLST	;354 aobjn ptr to list of networks our host is on
	-NHOSTS,,HSTLST	;355 aobjn ptr to HOSTS3 format host numbers of ours
	WHOALL,,DOMNAM	;356 ptr to block of misc values for WHO,,domain/host name
	SPLBTS		;357 bits for spoolers on this system, see OUTER

;360-367
MTCLPE			;360 for Dart to find error counts after tape during copy


BLOCK 2	;PATCH AREA FOR INTERESTING NEW POINTERS

;THE LAST ALLOWABLE LOCATION FOR LOW CORE POINTERS IS 417
;I wish someone had documented the reason for this restriction.
;I imagine that it has something to do with locations above 417
;that are used by the PDP-11 before the system sets the address of the EPT.
;Thus, if you're really desperate, you could have more pointers here
;by BLTing them here after establishing the new location of the EPT.  REG
IFG .-417,<.FATAL Too many lowcore pointers>
;⊗ KLEPT KIEPT TO11BP TO10BP DTEVEC EPT143 KLEOVT KLEPDT KLET3T DTFLG DTCLK DTTIME DTT11 DTF11 DTCMD DTCHR DTMTD DTMTI DTSWR DTQMP DTQM2 EPTTB EPTPRF KLITVC KLESEC NKLSEC KLUPT KLLUUP KLUOVT KLUPDT KLUT3T KLUUFG KLUUPC KLUUEA KLCNTX KLUUOW KLUUPC KLCNTX KLKNTW KLKTW KLSNTW KLSTW KLCNTW KLCTW KLPNTW KLPTW KLPFW KLPFFG KLPFPC KLPFNP KLPFW KLPFPC KLPFNP UPTEBX UPTMBX KLSBDI KLUSEC CSTDEF CST EXPGT PSB

IFKL10,<
;KL10 EXEC PROCESS TABLE, USER PROC TABLE, EXEC PAGE TABLE, 
; CORE STATUS TABLE, PROCESS STORAGE BLOCK

	INTERN	KLEPT,KIEPT	;for PHYSIO etc.

LOC 1000

↓KLEPT:	BLOCK 1000		;EXEC PROCESS TABLE FOR KL10
KIEPT==KLEPT
;ALL OF THE FOLLOWING ARE RELATIVE TO THE KL10'S EPT
;Locations 0 through 37 are used (4 at a time) for RH20 channel initial
; command pointers, and channel logout area.  Locations ending in 3 (and 7)
; are used by software for interrupt transfer instructions
;
;Locations 60:63 are used to supply data in write fill operations.
; Such operations are used to pad channel transfers to a sector boundary.
; You might leave them zero.

	TO11BP←←140		;TO11 byte pointer; known to the microcode!
	TO10BP←←141		;TO10 byte pointer; known to the microcode!
	DTEVEC←←142		;VECTORED INTERRUPT LOCATION FOR DTE0
	EPT143←←143		;a magic location, known to the DTBOOT loader.
	KLEOVT←←421		;EXEC ARITH OVERFLOW TRAP INSTRUCTION ADDRESS
	KLEPDT←←422		;EXEC PDL OV TRAP INSTRUCTION ADDRESS
	KLET3T←←423		;EXEC TRAP-3 TRAP INSTRUCTION ADDRESS
	DTFLG←←444		;DTE20 OPERATION COMPLETE FLAG
	DTCLK←←445		;      CLOCK INTERRUPT FLAG
	DTTIME←←446		;      TIME AND DATE (FROM BATTERY BACKUP CLOCK)
	DTT11←←447		;      TO 11 ARGUMENT
	DTF11←←450		;      FROM 11 ARGUMENT
	DTCMD←←451		;      TO 11 COMMAND WORD
	DTCHR←←454		;      LAST KEY STRUCK ON CTY
	DTMTD←←455		;      MONITOR TTY OUTPUT COMPLETE FLAG
	DTMTI←←456		;      MONITOR TTY INPUT FLAG
	DTSWR←←457		;      PDP-10 SWITCH REGISTER (DEPOSITED HERE
				;		BY THE 11 EVERY TICK)
	DTQMP←←460		;      11 tells 10 size of a to10 xfer
IFN FTDTBG,<
	DTQM2←←461		;      status of to11 xfer (0 busy, -1 overrun)
>;IFN FTDTBG
	EPTTB←←510		;TIMEBASE IS EPT 510-511
	EPTPRF←←512		;PERFORMANCE COUNTER IS EPT 512-513
	KLITVC←←514		;INTERVAL TIMER VECTOR INTERRUPT LOCATION
IFN FTKLB,<
	KLESEC←←540		;540:577 is array of ptrs for exec sections 0:37
	  NKLSEC←←40		;number of sections (both user and exec)
>;IFN FTKLB


LOC 2000

↓KLUPT:	BLOCK 1000		;USER PROCESS TABLE FOR KL10
IFN FTKLB,<
	KLLUUP←←420		;ADDRESS OF BLOCK FOR USER LUUOS FROM NONZERO SECT
>;IFN FTKLB
	KLUOVT←←421		;USER ARITH OVERFLOW TRAP INSTRUCTION ADDRESS
	KLUPDT←←422		;USER PDL OV TRAP INSTRUCTION ADDRESS
	KLUT3T←←423		;USER TRAP-3 TRAP INSTRUCTION ADDRESS
IFN FTKLB,<
	KLUUFG←←424		;WORD WHERE MUUO STORES FLAGS,,OPCODE&AC&PrvContSec
	KLUUPC←←425		;WORD WHERE PC+1 IS STORED ON MUUO
	KLUUEA←←426		;EFFECTIVE ADDRESS OF MUUO IS STORED HERE
	KLCNTX←←427		;MUUO PROCESS CONTEXT WORD
>;IFN FTKLB
IFE FTKLB,<
	KLUUOW←←424		;WORD WHERE MUUO IS STORED
	KLUUPC←←425		;WORD WHERE PC+1 IS STORED ON MUUO
	KLCNTX←←426		;MUUO PROCESS CONTEXT WORD
>;IFE FTKLB
	KLKNTW←←430		;KERNEL , NO TRAP MUUO NEW PC WORD
	KLKTW←←431		;KERNEL ,    TRAP MUUO NEW PC WORD
	KLSNTW←←432		;SUPERV , NO TRAP MUUO NEW PC WORD
	KLSTW←←433		;SUPERV ,    TRAP MUUO NEW PC WORD
	KLCNTW←←434		;CONCEAL, NO TRAP MUUO NEW PC WORD
	KLCTW←←435		;CONCEAL,    TRAP MUUO NEW PC WORD
	KLPNTW←←436		;PUBLIC , NO TRAP MUUO NEW PC WORD
	KLPTW←←437		;PUBLIC ,    TRAP MUUO NEW PC WORD
IFN FTKLB,<
	KLPFW←←500		;PAGE FAIL WORD
	KLPFFG←←501		;PAGE FAIL FLAGS
	KLPFPC←←502		;PAGE FAIL OLD PC
	KLPFNP←←503		;PAGE FAIL NEW PC
>;IFN FTKLB
IFE FTKLB,<
	KLPFW←←500		;PAGE FAIL WORD
	KLPFPC←←501		;PAGE FAIL PC
	KLPFNP←←502		;PAGE FAIL NEW PC WORD
>;IFE FTKLB
	UPTEBX←←504		;EBOX COUNTER IS UPT 504-505
	UPTMBX←←506		;MBOX COUNTER IS UPT 506-507
	KLSBDI←←510		;KLSER code uses 510,511 for SBUS diag (BLKO PI,)
IFN FTKLB,<
	KLUSEC←←540		;540:577 is array of ptrs for user sections 0:37
>;IFN FTKLB
>;IFKL10

NOKL10,<
;P1 EXEC PAGE TABLE (PAGES 600-777 ARE IN PSB ON KA)
LOC EXPGT		;MUST BE 3000 ON KA (defined in OUTER)
XLIST
FOR I←0,777 <
	PWRT,,I		;uncached write access for all pages is default
>
LIST
>;NOKL10

LOC 4000

;CORE STATUS TABLE AND CORTAB
;Bits 0:8 are AGE
;Bit 9 or 35 (FTKLB) is the MODIFICATION BIT
;Bit 18 (MCA25, microcode version 400) must be on to allowing writing the page.
;Bits 21-32 (MCA25) are the usage code, byte pointer COREP (index by LOC=DSER).
;Note that the usage byte defined in COREP also appears in COREPA byte ptr.

CSTDEF←←<100000,,400000>	;default word for CST entries
↓CST:
XLIST
	REPEAT PHYMEM*2,<CSTDEF>
LIST

LOC <.+777>∧777000		;NEXT PAGE BOUNDARY

IFKL10,<
↓EXPGT:				;P1 EXEC PAGE TABLE
XLIST
FOR I←0,777 <
	PWRT,,I		;uncached write access for all pages is default
>
LIST
>;IFKL10

NOKL10,<
 IFN PSB-.,<.FATAL PSB address defined in OUTER is wrong, as figured in CACDAT.>
>;NOKL10
IFKL10,<
↓PSB:
>;IFKL10
	PWRT,,0		;THIS IS ALSO THE USER MODE PAGE TABLE FOR P2
	BLOCK 577
XLIST
FOR I←600,777 <
	PWRT,,I		;uncached write access for all pages
>
LIST
;⊗ PUSHIT PUSHOK POPIT

↑↑PUSHIT:
	PUSH P,0	;SAVE 0
	HLRE 0,P	;PICK UP COUNT
	ADDI 0,20	;ADD IN DISPLACEMENT
	XOR 0,P		;IF SIGNS ARE DIFFERENT, NOT ENOUGH STACK
	JUMPGE 0,PUSHOK
	POP P,0		;CAN'T DO IT, LOSE BIG
	PUSH P,TAC
	MOVE TAC,[POINT 7,[ASCIZ⊗NOT ENOUGH ROOM TO PUSH ACS - FATAL.
FIND A WIZARD OR RELOAD.  ⊗]]
	JSR DDTTYPE
	POP P,TAC
	JRST DDTCALL

PUSHOK:	POP P,0		;GET BACK 0
	EXCH 0,(P)	;SAVE 0 AND GET RETURN.
	MOVEM 0,20(P)	;GEE, THIS WAY WE RETURN WITH A POPJ
	MOVEI 0,1(P)
	HRLI 0,1
	BLT 0,17(P)
	ADD P,[20,,20]
	POPJ P,		;RETURN TO SENDER

↑↑POPIT:MOVSI 0,-17(P)
	HRRI 0,1
	BLT 0,17
	MOVE 0,20(P)
	EXCH 0,(P)
	POPJ P,
;⊗ FDDTCA XDDTCA WDDTCA FDDTC2 DDTCALL DDTCL1 DDTBAG NODBEL NXDDT DDTPAC WFMES WMES DMES
	INTERN	FDDTCA,XDDTCA,DDTCALL,WDDTCA

;DDTCALL - THIS PRINTS "YOU'RE IN DDT" AND ENTERS DDT.

FDDTCA:	MOVEM TAC,DDTPAC
	MOVE TAC,[POINT 7,WFMES]	;FIND A WIZARD!
	JRST FDDTC2

;Check for fatal error, print right msg, skip if not fatal
XDDTCA:	SKIPE FATALE
	JRST FDDTCA			;Fatal
	AOS (P)				;Non-fatal, take skip return when done
WDDTCA:	MOVEM TAC,DDTPAC
	MOVE TAC,[POINT 7,WMES]		;FIND A WIZARD OR TYPE $P
FDDTC2:	JSR DDTTYPE
	JRST DDTCL1

DDTCALL:MOVEM TAC,DDTPAC
DDTCL1:
IFN FTSUAI,<
	MOVE TAC,TIMDAT		;see how long since last disaster
	SUB TAC,LASTDISASTER
	SKIPN MAINTM		;don't ring bell in maintenance mode
	CAIG TAC,=2*=60		;don't ring bell if rang it recently
	JRST NODBEL		;don't ring
	PUSH P,[2]		;how many times to ring it
DDTBAG:	CONO CAR,ONBEL		;hit the bell
	MOVEI TAC,=20000	;about 1 tick
	SOJG TAC,.		;wait till we've hit it
	CONO CAR,OFFBEL		;remove power from bell ringer
	MOVEI TAC,-1		;about 13 ticks
	SOJG TAC,.		;wait till we've pulled back
	SOSLE (P)		;rung enough?
	JRST DDTBAG		;no, again
	ADJSP P,-1		;fix stack
NODBEL:
>;IFN FTSUAI
IFN FT11CLK,<
	SETZM CONALV		;Make sure 11 is giving us the time
	SETZM CONYET		;Quickly ask 11 for time after proceeding
>;IFN FT11CLK
IFN FTDDT,<
	SKIPE NOTDDT		;ANY DDT?
	JRST NXDDT		;NO
	MOVE TAC,[POINT 7,DMES]	;You're in DDT
	JSR DDTTYPE
	MOVEI TAC,CPOPJ
	MOVEM TAC,PROCPC	;ALLOW $P TO PROCEED
	MOVE TAC,DDTPAC
	JRST DDT
>;IFN FTDDT

NXDDT:	MOVE TAC,[POINT 7,[ASCIZ/NO DDT
/]]
	JSR DDTTYPE
	MOVE TAC,DDTPAC
	POPJ P,

DDTPAC:	0
	0

WFMES:	ASCIZ /Find a WIZARD!  /
WMES:	ASCIZ /Find a WIZARD or type "$P".  $ means ESC.  /
DMES:	ASCIZ /You're in DDT
/
;⊗ AUTOLOAD AUTOP1 RSTPNT

;AUTOLOAD  THIS PART HANDLES AUTOMATIC RELOADS AND RESTARTS

AUTOLOAD:
AUTOP1:	EXCH P,ERRPDL
	PUSHACS
	PUSHJ P,DISFLUSH
	POPACS
	SKIPE DEBMOD
	PUSHJ P,DDTCALL
	CONO APR,200000		;IOB RESET
	CONO PI,10400		;RESET PI SYSTEM
IFN FTDSKM,<
	CONSZ MPX,MBUSY
	JRST .-1
>;IFN FTDSKM
	PUSHJ P,DSKSTP		;WRITE OUT SAT (IN DSKSER)
	CONO APR,200000
	CONO PI,10400		;RESET PI SYSTEM
	MOVE TAC,RSTPNT
	JSR DDTTYPE
	JRST 4,.

RSTPNT:	POINT 7,.+1
	ASCIZ /
PLEASE RELOAD THE SYSTEM
/
;⊗ ...TM2 ...TM3 ..PDL DDTTYPE DDTTY1 DDTTY4 DDTTY2

;DDTTYPE - TYPE ON THE CTY -  ENTER WITH BYTE PTR TO ASCIZ IN TAC.

...TM2:	0			;TEMPORARY CELL
...TM3:	0
..PDL:	BLOCK 20
DDTTYPE:0			;JSR TO HERE.
	MOVEM TAC1,...TM2	;SAVE TAC1
	MOVEM P,...TM3		;SAVE P (MAY OR MAY NOT BE A STACK)
	MOVEI P,..PDL-1		;NEED A STACK
	MOVE TAC1,TAC		;BYTE POINTER TO TAC1
DDTTY1:	ILDB TAC,TAC1		;GET BYTE
	JUMPE TAC,DDTTY2	;NULL ENDS THE MESSAGE
	PUSHJ P,CTPUTC		;WRITE CHARACTER ON CTY.
	PUSHJ P,CTGETC		;WAS ANYTHING TYPED ON CTY?
	JRST DDTTY1		;NO.
	PUSHJ P,CTPUTC		;YES.  ECHO THAT CHARACTER
	CAIE TAC1,15		;WAS IT A CR?
	JRST DDTTY4		;NO.
	MOVEI TAC1,12
	PUSHJ P,CTPUTC		;ADD LF AFTER CR.
DDTTY4:	ILDB TAC,TAC1		;FLUSH UNTIL NULL BYTE
	JUMPN TAC,.-1		;BECAUSE SOME PEOPLE RETURN TO 1(TAC)
DDTTY2:	MOVE TAC,TAC1		;RETURN UPDATED BYTE POINTER IN TAC
	MOVE TAC1,...TM2	;RESTORE TAC1
	MOVE P,...TM3		;RESTORE P
NOKL10,<
	CONSZ CTY,20		;WAIT FOR OUTPUT BUSY TO BE OFF.
	JRST .-1		;BECAUSE SOME CALLERS DON'T WAIT.
>;NOKL10
	JRST @DDTTYPE
;⊗ P2DDB NOP2 DIDLOD P2ADBD PWRCNT XJBPFI REFLAG MAINTMODE NOLOGIN BLTSWP SYSSIZ DEBMOD NDBCNT DEBCNT

;OTHER SYSTEM DATA STORAGE
;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE

IFN FTP2,<
IFN FTVRN,<
P2DDB:	0			;CONTAINS XGPDDB OR VRNDDB WHEN DEVICE IS INITED
>;IFN FTVRN
NOP2:	0			;-1 TO DISALLOW LOADING P2
DIDLOD:	0			;-1 TO TELL CLKSER NOT TO FIREUP P2LOAD
P2ADBD:	0			;-1 IF P2ADCK HAS DETECTED AN ERROR
>;IFN FTP2
PWRCNT:	1B17			; POWER FAILURE COUNT DOWN
XJBPFI:	JOBPFI,,0
				;JOBPFI=HIGHEST LOC. IN USER JOB DATA AREA
				;PROTECTED FROM IO
REFLAG:	0	;IF REFLAG IS NON-ZERO (SET BY REFRESH CODE IN ONCE) THEN THE
		;FIRST USER TO TYPE "LOGIN" IS GIVEN THAT NUMBER AS HIS PPN
MAINTMODE:	0		; IF MAINTMODE≠0, ONLY GOD MAY LOG IN.
NOLOGIN:	0		; SET ≠ 0 TO PREVENT LOGINS
BLTSWP:		0		;IF ≠ 0 THEN BLT CORE IMAGE AFTER SWAPIN

SYSSIZ:		0		;SIZE OF MONITOR(FIRST LOC NOT USED)

DEBMOD:		0		;NON-ZERO CAUSES DEBCHECK TO CALL DISFLUSH AND DDT
NDBCNT←←5
DEBCNT:		NDBCNT		;Number of debmod hits before we call DDT
;⊗ PICON INIMES SAVITM DEVLST

PICON:
IFKL10,<CONO PI,012237		;KL10 PI ENB CHN 3-7
>;IFKL10
NOKL10,<CONO PI,652237		;KA
>;NOKL10

INIMES:	.+1
	ASCIZ	/System loaded on /
SAVITM:	0			; SOMEWHERE IN IOINIT

DEVLST:	DSKDDB,,0		; DDB LIST HEADER
;⊗ CTGETC CTPUTC LINEP LINBUF SYSDAT TYO CONTYO CONTYI

;CTGETC, CTPUTC,  BASIC ROUTINES FOR CTY COMMUNICATION
;THESE ASSUME THAT PI'S ARE OFF.

;CALL:	PUSHJ P,CTGETC
;	<NO CHARACTER HAS BEEN TYPED>	;(TAC MAY BE CLOBBERED)
;	<CHARACTER RETURNED IN TAC>	;ONLY TAC IS CLOBBERED.

;CALL:	MOVE TAC,<CHARACTER>
;	PUSHJ P,CTPUTC
;	<RETURN HERE ALWAYS>

CTGETC:
IFN FTSCTY,<
IFN FTDDT,<
	SKIPN NOTDDT		;ANY DDT?
	JRST CTGETT		;YES, USE DDT CHAR ROUTINE (GET CHAR IN TAC)
>;IFN FTDDT
>;IFN FTSCTY
IFKL10,<
	JRST KLCGET			;TYPEOUT FOR KL10.
>;IFKL10
NOKL10,<
	CONSO CTY,40			;SKIP IF INPUT DONE
	POPJ P,				;NOBODY HOME
	DATAI CTY,TAC
	ANDI TAC,177
	JRST CPOPJ1
>;NOKL10

CTPUTC:
IFN FTSCTY,<
IFN FTDDT,<
	SKIPN NOTDDT		;ANY DDT?
	JRST CTPUTT		;YES, USE DDT CHAR ROUTINE (CHAR IN TAC)
>;IFN FTDDT
>;IFN FTSCTY
IFKL10,<
	JRST KLCPUT			;USE DTE20 FOR TYPEOUT
>;IFKL10
NOKL10,<
	CONSZ CTY,20			;WAIT UNTIL NOT OUTPUT BUSY
	JRST .-1
	DATAO CTY,TAC
	POPJ P,
>;NOKL10

LINEP:	POINT	7,LINBUF	;INPUT AND OUTPUT LINE BUFFER
LINBUF:	BLOCK	30
SYSDAT:	BLOCK	2

TYO:
CONTYO: PUSHJ	P,OUTCHS	;***PATCHED BY ONCE

CONTYI:	PUSHJ	P,GETCHR	;***PATCHED BY ONCE.
;⊗ CH1 SAMHJ CH1SPR CH2 SAMLJ CH3PCP CH3 DPYCON KLPARC CH4 DTCCON MTCCON IMPOTS IMPCTS CH5 LPTCON IMPETS IMPOTS IMPCTS KIMCNI CH6 IOPCON SIXICN SIXIJM SIXOCN SIXOJM CH7

SUBTTL	IOINIT	CHANNEL LINKAGES AND SAVE ROUTINES.  J. SAUTER 4-8-68

;INTERRUPT ROUTINE LINKAGES.  IF THE CHANNEL OF A DEVICE IS CHANGED,
; THEN THE CODE HERE MUST BE CHANGED AS WELL.

;USED IN ONCE

↓CH1:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
IFN FTSAM,<
;	CONSZ SAMA,200000	; COMMAND EXHAUSTED? (DON'T BOTHER - TOO SLOW)
SAMHJ:	JRST SAMHI		; SYNTHESIZER HIGH PRIORITY CHANNEL
>; IFN FTSAM
CH1SPR:	AOS CH1SPU		;Count spurious interrupts per channel
IFN FTXADR,<
	XJEN CH1		;ONLY ONE DEVICE AT A TIME ON CH1
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH1		;ONLY ONE DEVICE AT A TIME ON CH1
>;IFE FTXADR

↓CH2:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
IFN FTF2,<
IFE FTAPR4,<
IFN FTMSYSBUF,<
	SKIPE UFDWAK	;SEE IF ANY UFD WAITER NEEDS TO WAKE UP
	JRST UFDINT	;MUST BE BEFORE NORMAL DISK INTERRUPTS
>;IFN FTMSYSBUF
	SKIPE F2DERF	;HERE TO PROCESS AN ERROR FOR F2 DISK?
	JRST F2DERI	;YES
	SKIPE F2DUNF	;F2 DISK XFER DONE?
	JRST F2DXIT	;YES, TAKE CARE OF THAT
	DCONSZ DSKIFG	;IS THE F2 DISK INTERRUPTING?
	JRST F2DINT	;YES
>;IFE FTAPR4
>;IFN FTF2
IFN FTSAM,<
SAMLJ:	JRST SAMLO	; SYNTHESIZER LOW PRIORITY CHANNEL
		; THERE IS NO CONVENIENT WAY TO MAKE A CONSZ HERE
		; SINCE ANY CONI SAMA, CLEARS CERTAIN ERROR BITS
>; IFN FTSAM
	AOS CH2SPU	;Count spurious interrupts per channel
IFN FTXADR,<
	XJEN CH2
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH2
>;IFE FTXADR

CH3PCP:	0

;INTERRUPTS ARE INITIATED INTO CHANNEL 3 FROM 2 PLACES:
;FROM A CLOCK TIC (WHICH DOES A VECTORED INTERRUPT TO KLTINT)
;AND FROM A PARITY ERROR PAGE FAULT.  IN THE FIRST CASE DSFLAG
;IS SET, IN THE SECOND CASE PFPARF WILL BE SET.
;
;ON AN F2, THE DISK IS IN CHANNEL 3 AND PROCESSOR INTERRUPTS IN CHANNEL 4.
;THE DISK WAS MOVED FROM CHANNEL 2 BECAUSE IT SPENT TOO MUCH TIME THERE AND
;WOULD INTERFERE WITH THE SAMSON BOX.  EVENTUALLY, THE DISK INTERRUPTS MAY
;HAVE TO BE SPLIT INTO TWO PI LEVELS, SO THAT IT DOES NOT INTERFERE WITH
;HIGH SPEED TTYS (SUCH AS MIGHT BE USED FOR NETWORKING).
↓CH3:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
	CHKPIS (GEN,3)

	MTRCON (CH3,P2NOCK)

;;;	CLRPCP		;DO IT IN THE ROUTINES THAT NEED IT OFF (I.E. DO XCTRS)
IFE FTF2,<
	CONSZ MPX,MINT		;MPX?
	JRST MPXINT		;YES.
DPYCON:	CONSZ DPY,400000	;III PROCESSOR? (CHANGED TO CONSZ DPY,0 IF IIIOFF)
	JRST DPYINT		;YES
>;IFE FTF2
IFN FTDD,<
	CONSZ DDD,20		;DATA DISK?
	JRST DDINT		;YES
>;IFN FTDD

IFN FTF2,<
IFN FTAPR4,<
IFN FTMSYSBUF,<
	SKIPE UFDWAK	;SEE IF ANY UFD WAITER NEEDS TO WAKE UP
	JRST UFDINT	;MUST BE BEFORE NORMAL DISK INTERRUPTS
>;IFN FTMSYSBUF
	SKIPE F2DERF	;HERE TO PROCESS AN ERROR FOR F2 DISK?
	JRST F2DERI	;YES
	SKIPE F2DUNF	;F2 DISK XFER DONE?
	JRST F2DXIT	;YES, TAKE CARE OF THAT
	DCONSZ DSKIFG	;IS THE F2 DISK INTERRUPTING?
	JRST F2DINT	;YES
	jfcl		;*** For debugging
>;IFN FTAPR4
>;IFN FTF2

NOKL10,<			;FOR KA10 BASED SYSTEM
IFE FTAPR4,<	;If processor is in channel 3
	CONSZ PI,400000		; POWER FAILURE?
	JRST PWROFF		; OH DEAR?
	CONSZ PI,200000		;KA10 PARITY ERROR?
	JRST PARINT		;YES.
IFN FTF2,<
	SKIPL PAGFLG		;Skip if pager error requested this interrupt
>;IFN FTF2
IFE FTF2,<
PRINTX	CONSO APR,400 never skips on an unmodified KA10?
>;IFE FTF2
	CONSO APR,400		;THIS IS THE KA10 NOT APR INTERRUPT BIT
	JRST APRINT		;YES.
>;IFE FTAPR4
>;NOKL10

IFKL10,<			;FOR KL10 BASED SYSTEM
KLPARC:	CONSZ APR,7740		;ANY HARDWARE ERROR? (MODIFIED FROM PARSER)
	JRST ERRINT		;YES.
	CONSZ APR,SWEEPD	;SWEEP DONE?
	JRST SWEEPI		;YES.
	CONO PI,20000!(1⊗(7-APRCHN)) ;Clear requested interrupt on APR channel
	AOSN PFPARF
	JRST PARINT		;PARITY ERROR FROM AR/ARX PAGE FAULT
>;IFKL10

	MTRCOF (CH3,P2NOCK)

	AOS CH3SPU		;Count spurious interrupts per channel
IFN FTXADR,<
	XJEN CH3
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH3
>;IFE FTXADR
IFN FTF2,<
IFN FTAPR4,<
	BLOCK 10		;Special patch area for channel 3 interrupts
>;IFN FTAPR4
>;IFN FTF2

↓CH4:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
	CHKPIS (GEN,4)
	CLRPCP

IFN FTAIP,<			;ARPAnet (or MILnet)
	MOVEM J,IMPJ↑		;Get an AC
	CONI IMP,J		;Save doing a lot of CONIs
	TRNE J,FULL↑		;Input done?
	JRST MPIINT↑		;Yes, handle it (in IMPINT.MAC)
IMPETS:	TRNE J,ENDIN↑		;Input end?
	JRST MPEINT↑		;Yes
IMPOTS:	TRNE J,EMPTY↑		;Output done?
	JRST MPPINT↑		;Yes
IMPCTS:	MOVE J,IMPJ↑		;Restore saved AC
>;IFN FTAIP

IFG DTCNUM,<
DTCCON:	CONSZ DTS,0		;DEC TAPE CONTROLLER?
	JRST DTCINT		;YES.
>;IFG DTCNUM

REPEAT 0,<
IFE DTCNUM+MTCNUM,<
	SKIPE DTCFLAG		;DEC TAPE - MAG TAPE STARTUP INTERRUPT?
	JRST DTCINT		;YES.
>;IFE DTCNUM+MTCNUM
>;REPEAT 0

IFG MTCNUM,<
IFE FTOTAP*FTF2,<
IFE FTF2,<
MTCCON:	CONSZ MTS,0		;MAG TAPE CONTROLLER?
>;IFE FTF2
IFN FTF2,<
	CONSZ F2M,10		;F2 Tape operation complete?
>;IFN FTF2
	JRST MTCINT		;YES.
>;IFE FTOTAP*FTF2
>;IFG MTCNUM

IFN FTAPR4,<	;If processor is in channel 4
	CONSZ PI,400000		; POWER FAILURE?
	JRST PWROFF		; OH DEAR?
	CONSZ PI,200000		;KA10 PARITY ERROR?
	JRST PARINT		;YES.
IFN FTF2,<
	SKIPL PAGFLG		;Skip if pager error requested this interrupt
>;IFN FTF2
IFE FTF2,<
PRINTX	CONSO APR,400 never skips on an unmodified KA10?
>;IFE FTF2
	CONSO APR,400		;THIS IS THE KA10 NOT APR INTERRUPT BIT
	JRST APRINT		;YES.
>;IFN FTAPR4
	AOS CH4SPU		;Count spurious interrupts per channel
IFN FTXADR,<
	XJEN CH4
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH4
>;IFE FTXADR

↓CH5:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
	CHKPIS (GEN,5)
	CLRPCP

IFN LPTNUM,<
LPTCON:	CONSZ LPT,0		;LINE PRINTER?
	JRST LPTINT		;YES.
>;IFN LPTNUM

NOKL10,<CONSZ CTY,50		;CONSOLE TELETYPE (KA10 ONLY)
	JRST CTYINT		;YES.
>;NOKL10

IFE FTDLS,<
	CONSZ DCA,400		;DCA SCANNER?
	JRST DCAINT		;YES
>;IFE FTDLS
IFN FTDLS,<
	CONSZ DLS,30		;DLS XMT OR RCV INTERRUPT?
	JRST DLSINT		;Yes
>;IFN FTDLS
IFN FTKIM,<
KIMCNI:	CONSZ KIM,10		;PARALYZER FROM KIM
	JRST KIMINT
>;IFN FTKIM
IFN PKNUM,<
	CONSZ PK,7		;PIA?
	CONSO PK,10		;INTERRUPT BIT?
	CAIA			;Let's not optimize for spurious interrupts
	JRST PKINT		;(TELEPHONE) PAGING KLUDGE (IN TTYSER)
>;IFN PKNUM
	AOS CH5SPU		;Count spurious interrupts per channel
IFN FTXADR,<
	XJEN CH5
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH5
>;IFE FTXADR


;SCNINT IS PLACED EARLY IN THE CONSZ CHAIN BECAUSE DISCONNECTED
;TELETYPES RUN OPEN, FLOODING THE SYSTEM WITH INTERRUPTS.  SINCE THE
;VAST MAJORITY OF CH5 INTERRUPTS ARE OF THIS NATURE TTYS SHOULD BE
;CHECKED EARLY.  SIMILARLY, DKBINT IS PLACED JUST AFTER SCNINT.
;LPTINT IS FIRST SINCE THE LPT GENERATES INTERRUPTS AT A
;VERY HIGH RATE WHILE LOADING THE BUFFER. 

↓CH6:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
	CHKPIS (GEN,6)
	CLRPCP
IFE FTF2,<
IFN FTMSYSBUF,<
	SKIPE UFDWAK		;SEE IF ANY UFD WAITER NEEDS TO WAKE UP
	JRST UFDINT		;MUST BE BEFORE NORMAL DISK INTERRUPTS
>;IFN FTMSYSBUF
	CONSZ C1A,CIF
	JRST C1AINT
	CONSZ C1B,CIF
	JRST C1BINT
	SKIPE HNGFLG
	JRST C1HUNG

IFN TVNUM,<
IOPCON:	CONSZ IOP,0		;IO PROCESSOR FOR TV CAMERA?
	JRST IOPINT
>;IFN TVNUM
>;IFE FTF2

IFN DILNUM,<
IFE FTVDIL,<
	CONSZ DIL,20
	JRST DILINT		;DIALER INTERRUPT
>;IFE FTVDIL
>;IFN DILNUM

IFN ELFNUM,<			;BO 6-MAY-74
	CONSZ ELF,770000	;ERROR INTERRUPT FROM THE PDP-11?
	JRST ELFINT
>;ELFNUM

IFN FTSIX,<
SIXICN:	CONSZ SIX,1000		; ANY INPUT FOR US?
SIXIJM:	JRST SIXFSI		; YES, GO TO INPUT ROUTINE FOR FIRST WORD
SIXOCN:	CONSZ SIX,10		; ANY OUTPUT FOR US?
SIXOJM:	JRST SIXIER		; YES, GO TO OUTPUT INTERRUPT ROUTINE
>;IFN FTSIX

IFN FTP2,<
	SKIPE NOP2
	CONO P2D,P2CLR		;NO P2 DEVICE IF NO P2
	CONSZ P2D,P2INTB
	JRST P2DINT		;P2 WANTS XGP DUMP MODE DATA
>;IFN FTP2
IFN FTGRIN,<
	SKIPGE DDCNT		;HAS GRINNELL TIMED OUT??
	  JRST DDCLK		;YES, GO FLUSH IT
	SKIPN DDRUN		; GRINNELL RUNNING?
	  JRST .+3		; NO, DON'T CHECK FOR IT
	CONSZ GRN,20		; GRINNEL INTERFACE?
	  JRST DDINT		; YES
	SKIPE DDSTART		;DO WE NEED TO START IT UP?
	  JRST DDSTRT		;YES, DO SO.
>;IFN FTGRIN
IFN FTPOLY,<
printx *** You'd better put an instruction here to skip if POLY not interrupting.
	skipa
	  JRST POLINT
>;IFN FTPOLY
IFN PUPNUM*FTF2,<
	jfcl			;FOONET interface?
	SKIPE PUPFLG		;or forced interrupt
	 JRST PUPSV		;  Yes, go pretend we're FOONEX for awhile.
>;IFN PUPNUM*FTF2

	AOS CH6SPU		;Count spurious interrupts per channel
IFN FTXADR,<
	XJEN CH6
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH6
>;IFE FTXADR

↓CH7:	0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
	CHKPIS (GEN,7)

	MTRCON (CH7,P2NOCK)

	CLRPCP
IFKL10,<CONO PI,20000+1⊗(7-CLKCHN)	;CLEAR INTERRUPT
	AOSN KLTPCF
	JRST KCLKIN
>;IFKL10
	SKIPLE CLKFLG		;CLOCK INTERRUPT?
	JRST CLKINT		;YES.
	SKIPGE CLKFLG
	JRST CLKIN0		;SPECIAL ENTRY FOR USRXIT KLUDGE

	MTRCOF (CH7,P2NOCK)

	AOS CH7SPU		;Count spurious interrupts per channel
;bugtrap to detect getting here at UUO level
	CONSO PI,400⊗(7-CLKCHN)	;really in CH7?
	JRST NOTCH7		;no, bug!
IFN FTXADR,<
	XJEN CH7
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH7
>;IFE FTXADR
;⊗ INTPLN CH5PDL CH1SAV SAMSVH CH1RET CH2SAV SAMSVL CH2RET DTCSAV CH4SAV CH4RET SCNSAV CH5SAV CH5RET CH5OK CH5OK2 CH5LUZ CH5LU2 CH5LU3 CH7CHK SCNTAC CH7LUZ OFSPDL TVSAV CH6SAV CH6RET

;CHANNEL SAVE AND RESTORE CODE. CH7LUZ CH5LUZ CH7CHK
;  AGAIN, THESE DEPEND ON THE CHANNEL VALUES.

↓INTPLN←←100		;LENGTH OF I-LEVEL PUSHDOWN LISTS
↓CH5PLN←←INTPLN		;Length of channel 5 pdl.  (Used to be longer, when IMP
			;interrupts and packet handling were in channel 5.)

CH1SAV:	0		;JSR HERE
IFN FTSAM,<
SAMSVH:			; AC SAVE ROUTINE FOR SYNTHESIZER HIGH PRIORITY CHAN
>; IFN FTSAM
	MOVEM 17,CH1SAC+17
	MOVEI 17,CH1SAC
	BLT 17,CH1SAC+16
	MOVE P,[-INTPLN,,CH1PDL-1]
	MOVEI PID,P1PID
	PUSHJ P,@CH1SAV
CH1RET:	MOVSI 17,CH1SAC
	BLT 17,17
IFN FTXADR,<
	XJEN CH1
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH1
>;IFE FTXADR

IFN FTSAM,<
CH2SAV:	0		;JSR HERE
SAMSVL:
	MOVEM 17,CH2SAC+17
	MOVEI 17,CH2SAC
	BLT 17,CH2SAC+16
	MOVE P,[-INTPLN,,CH2PDL-1]
	MOVEI PID,P1PID
	PUSHJ P,@CH2SAV
CH2RET:	MOVSI 17,CH2SAC
	BLT 17,17
IFN FTXADR,<
	XJEN CH2
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH2
>;IFE FTXADR
>; IFN FTSAM

DTCSAV::MTCSAV::
IFN FTAIP,<IMPSAV::>
CH4SAV:	0		;JSR HERE
	MOVEM 17,CH4SAC+17
	MOVEI 17,CH4SAC
	BLT 17,CH4SAC+16
	MOVE P,[-INTPLN,,CH4PDL-1]
	MOVEI PID,P1PID
	PUSHJ P,@CH4SAV
CH4RET:	MOVSI 17,CH4SAC
	BLT 17,17
IFN FTXADR,<
	XJEN CH4
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH4
>;IFE FTXADR


SCNSAV::LPTSAV::PKSAV::DTESAV::
IFN ¬FTF2*PUPNUM,<PUPSAV::>
CH5SAV:	0		;JSR HERE.
	MOVEM 17,CH5SAC+17
	MOVEI 17,CH5SAC
	BLT 17,CH5SAC+16
	MOVE TAC,SCNCNT
	MOVEM TAC,SCNCN2		;SAVE SCANNER LEVEL COUNT UPON ENTRY TO CH5
	MOVE P,[-CH5PLN,,CH5PDL-1]
	MOVEI PID,P1PID
	SKIPLE MACROC			;Make sure not expanding macro upon entry
	PUSHJ P,CH5LU3			;Error!  Tell someone, and fix it.
	PUSHJ P,@CH5SAV
CH5RET:	MOVE TAC,SCNCNT
	CAME TAC,SCNCN2		;BETTER NOT HAVE CHANGED IN CH5
	JRST CH5LUZ
CH5OK:	SKIPLE MACROC		;BETTER NOT STILL THINK WE'RE EXPANDING MACRO
	JRST CH5LU2
CH5OK2:	MOVSI 17,CH5SAC
	BLT 17,17
IFN FTXADR,<
	XJEN CH5
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH5
>;IFE FTXADR

CH5LUZ:	SYSPIF
	EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /At CH5RET with SCNCNT different from value at CH5 entry.
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	PUSH P,TAC
	MOVE TAC,SCNCN2		;FIX IT I HOPE
	MOVEM TAC,SCNCNT
	POP P,TAC
	CONO PI,SCNON		;FIX BOTH CASES OF LOSSAGE
	EXCH P,APRPDL
	SYSPIN
	JRST CH5OK

CH5LU2:	SYSPIF
	EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /At CH5RET with MACROC positive (still expanding macro)!
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	SETZM MACROC		;FIX IT I HOPE
	EXCH P,APRPDL
	SYSPIN
	JRST CH5OK2

CH5LU3:	SYSPIFF
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /At CH5SAV with MACROC positive (PTY macro expansion must not have finished)!
/
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	SETZM MACROC		;FIX IT I HOPE
	SYSPIN
	POPJ P,

IFN FTSCNBUG <	;BUG TRAP FOR SCNCNT CONSISTENCY IN CH7 AND UUO LEVEL

;JSR CH7CHK  FROM USRXIT IN UUOCON AND FROM CIP8A7 IN CLKSER

CH7CHK:	0
	MOVEM TAC,SCNTAC	;SAVE AN AC
	MOVE TAC,SCNCNT
	AOJN TAC,CH7LUZ
	SKIPG MACROC		;Better not still be expanding macro
	CONSO PI,4		;CH5 ACTIVE?
	JRST CH7LUZ
	MOVE TAC,SCNTAC		;RESTORE
	JRST 2,@CH7CHK		;ALL OK

SCNTAC:	0

CH7LUZ:	SYSPIFF
	MOVE TAC,SCNTAC		;RESTORE
	EXCH P,APRPDL
	PUSHACS
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISERR
	[ASCIZ /
Exiting from UUO level or CH7 (or at WSCHED or CLKWAT) with
    Scanner off  or  SCNCNT not -1  or  MACROC positive.
OFSPDL has OFFSCN-ONSCN stack.
Caller = /]
	DISARG LOC,CH7CHK
	[ASCIZ/    SCNCNT = /]
	DISARG DCP,SCNCNT
	[ASCIZ/    MACROC = /]
	DISARG DCP,MACROC
	[ASCIZ /
OFSPDL: /]
	DISARG LOC,OFSPD
	[ASCIZ /, /]
	DISARG LOC,OFSPD+1
	[ASCIZ /, /]
	DISARG LOC,OFSPD+2
	[ASCIZ /, /]
	DISARG LOC,OFSPD+3
	[ASCIZ /, /]
	DISARG LOC,OFSPD+4
	[ASCIZ /, /]
	DISARG LOC,OFSPD+5
	[ASCIZ /, /]
	DISARG LOC,OFSPD+6
	[ASCIZ /, /]
	DISARG LOC,OFSPD+7
	[ASCIZ/
PI CONI = /]
	-1
	CONI PI,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISCRL
	PUSHJ P,DISFLUSH
	POPACS
	PUSHJ P,WDDTCA
	SETOM SCNCNT		;FIX COUNT
	PUSH P,OFSPD1		;FIX PDL
	POP P,OFSPDL
	SETZM MACROC		;Fix macro count/flag
	CONO PI,SCNON		;MAKE SURE SCANNER ON NOW
	EXCH P,APRPDL
	SYSPIN
	JRST 2,@CH7CHK
>;IFN FTSCNBUG

TVSAV:P2DSAV:
IFN ELFNUM <ELFSAV:ELDSAV:>
IFN FTSIX,<SIXSAV:>
IFN FTGRIN,<GRNSAV:>
IFN FTPOLY,<POLSAV:>
IFN FTF2*PUPNUM,<PUPSAV::>
CH6SAV:	0			;JSR HERE.
	MOVEM 17,CH6SAC+17
	MOVEI 17,CH6SAC
	BLT 17,CH6SAC+16
	MOVE P,[-INTPLN,,CH6PDL-1]
	MOVEI PID,P1PID
	PUSHJ P,@CH6SAV
IFN FTGRIN,<GRNRET:>
CH6RET:	MOVSI 17,CH6SAC
	BLT 17,17
IFN FTXADR,<
	XJEN CH6
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@CH6
>;IFE FTXADR
;⊗ CH1PDL CH2PDL CH4PDL CH5PDL CH6PDL CH1SAC CH2SAC CH3SAC CH4SAC CH5SAC CH6SAC MPIPI MPEPI MPPPI MPIPI MPEPI MPPPI IMPBTS

;P1 AND P2 INTERRUPT LEVELS AC STORAGE AND PD LISTS

ife ftxadr,< ;Turned off ONLY to generate list of undefs of ...CHL cells ref'd,
	     ;  all of which need to be changed under ftxadr.
DEFINE X ! (A,B) <
A!CHL←←CH!B
>;DEFINE X

;CHNDEF is defined in OUTER and associates a PI chan with each device.
;It repeatedly calls the macro X with two args: A=device name, B=PI chan.
CHNDEF
>;ife ftxadr

CH1PDL:	BLOCK INTPLN
IFN FTSAM,<
CH2PDL:	BLOCK INTPLN
>;IFN FTSAM
CH4PDL:	BLOCK INTPLN
CH5PDL:	BLOCK CH5PLN		;IP needs big stack for all its saved ACs
CH6PDL:	BLOCK INTPLN

CH1SAC:	BLOCK 20
IFN FTSAM!FTF2,<
CH2SAC:	BLOCK 20
>;IFN FTSAM!FTF2
IFN FTAPR4,<
CH3SAC:	BLOCK 20
>;IFN FTAPR4
CH4SAC:	BLOCK 20
CH5SAC:	BLOCK 20
CH6SAC:	BLOCK 20

IFN FTAIP,<		;Define symbols for TOPS-10 code in IMPINT.MAC
FOR @' DEV IN (MPI,MPE,MPP)<
DEV'CHL←←IMPCHL
DEV'SAV←←IMPSAV
>;FOR
IFN FTF2,<
MPIPI←←IMPCHN
MPEPI←←IMPCHN⊗8
MPPPI←←IMPCHN⊗4
>;IFN FTF2
IFE FTF2,<
MPIPI←←IMPCHN
MPEPI←←IMPCHN
MPPPI←←IMPCHN
>;IFN FTF2

IMPBTS←←1⊗<7-IMPCHN>
>;IFN FTAIP
;SIZE DATA FOR DISKS, ETC. ;⊗ MAXUIS MXSTRU DSKAB DTYPLN MXPGUN MXPGUN MXPGUN MAXRPB NAME DSKSZ1 DSKSZ2 DSKSZZ DSKSZZ

INTERN MAXUIS,MXSTRU,DSKAB
MAXUIS==4			;Number of units in a structure.  Size of ST.UIL
MXSTRU==MAXUIS			;MAX # OF PACKS IN A STRUCTURE
DSKAB==<40,,0>			;Again, LOADER will alert as to conflicts

;RESIDENT TABLES OF SIZE DATA FOR DISKS BASED ON TYPE.  DSKSIZ IS
;PARALLEL TO DSKUTP (DEFINED IN PHYSIO), WHICH CONTAINS CODES FOR THE
;KNOWN DISK TYPES.  WHEN AN ENTRY IS ADDED TO DSKUTP, A CORRESPONDING
;ENTRY MUST BE ADDED TO DSKSIZ TO POINT TO THE CORRECT SIZE DATA FOR
;THAT TYPE OF DISK.  DO NOT CHANGE THE ORDER OF THE SIZE DATA, SINCE
;THE MSTR JSYS USES A BLT TO COPY IT FOR THE .MSRNU FUNCTION.



;Macro to define disk parameters.  The arguments are used to generate
; a table of derived quantities for each disk, and also to define global
; offsets for Referencing the tables.  All Arguments are in **DECIMAL**.
;
;SEPPG	  NUMBER OF SECTORS PER PAGE (ASSUMED TO BE A POWER OF 2 IN DSKALC)
;SEPSU	  NUMBER OF SECTORS PER SURFACE (TRACK) (elsewhere "RECORD" means "SECTOR")
;SUPCY	  NUMBER OF SURFACES PER CYLINDER
;CYPUN	  NUMBER OF CYLINDERS PER UNIT
;LATUNI	  MICROSECONDS PER LATOPT SECTOR UNIT
;RPBUNI	  Number of data records per block (plus one for retrieval)
;RTSUNI	  Number of words in the retrieval record (Size of physical record)
;RTLUNI	  Number of data words of retrieval in the rtvl record. (logical length)
;BPGUNI	  Number of blocks per group.  (Either 32 half-words or 112 full words)
;NEWFORM  0: old (blocks don't cross tracks); 1: new (blocks don't cross cylinders)

DEFINE DSKTAB(SEPPG,SEPSU,SUPCY,CYPUN,LATUNI,RPBUNI,RTSUNI,RTLUNI,BPGUNI,NEWFORM),<

PHASE	0		;INITIALIZE OFFSET

;** The order of these entries is visible to users of the UNITYP UUO (MTAPE 31)

DSKDAT (SECPAG,<SEPPG>,<SECTORS PER PAGE>)	;** MUST BE A POWER OF TWO **
DSKDAT (SECCYL,<<<SEPSU*SUPCY>/SEPPG>*SEPPG>,<SECTORS PER CYLINDER>)
DSKDAT (PAGCYL,<$SECCYL/$SECPAG>,<PAGES PER CYLINDER>)
DSKDAT (CYLUNT,<CYPUN>,<CYLINDERS PER UNIT>)
DSKDAT (SECUNT,<$SECCYL*$CYLUNT>,<SECTORS PER UNIT>)
DSKDAT (BTWCYL,<<$PAGCYL+35>/36>,<NUMBER OF BIT WORDS PER CYLINDER IN BITTABLE>)
DSKDAT (LPPCYL,<SEPSU*SUPCY-$SECCYL>,<LOST SECTORS PER CYLINDER>)
DSKDAT (MINFPG,<$PAGCYL/3>,<MINIMUM FREE PAGES FOR FREE CHOICE>)
DSKDAT (MAXFPU,<$PAGCYL*CYPUN>,<MAXIMUM FREE PAGES BEFORE TURNING POINT>)
DSKDAT (SECSRF,<SEPSU>,<SECTORS PER SURFACE>)
DSKDAT (USSECU,<LATUNI>,<MICROSECONDS PER LATOPT SECTOR UNIT>)
IFE NEWFORM,<
DSKDAT (UNIBPC,<SUPCY*BKPTRK>,<Blocks per Cylinder - Old format only!>)
>;IFE NEWFORM
IFN NEWFORM,<
DSKDAT (UNIBPC,<<SEPSU*SUPCY>/<RPBUNI+1>>,<Blocks per Cylinder - New Format only!>)
>;IFN NEWFORM
DSKDAT (UNIRPB,<RPBUNI>,<Number of data records per block>)
DSKDAT (UNIRTS,<RTSUNI>,<Size in words of Retrieval record>)
DSKDAT (UNIRTL,<RTLUNI>,<Length in words of data area of RTVL record>)
DSKDAT (UNIBPG,<BPGUNI>,<Number of blocks per group>)
DTYPLN::			;Length of a disk size table
	DEPHASE

IFG $UNIRPB-MAXRPB,<MAXRPB=$UNIRPB>

IFG <MXSTRU*$PAGCYL*$CYLUNT-MXPGUN>,<	;;MAXIMUM PAGES IN STRUCTURE INCREASED?
 MXPGUN==<MXSTRU*$PAGCYL*$CYLUNT>>	;;YES, DEFINE VALUE LARGER
IFGE <MXPGUN*$SECPAG-DSKAB>,<		;;BUT SEE IF SECTOR ADDRESS TOO LARGE
 MXPGUN==<<DSKAB-1>/$SECPAG>>		;;YES, REDUCE SO SECTOR ADDRESS FITS
>;DSKTAB Macro

	MXPGUN==0		;DEFINE INITIAL VALUE
	MAXRPB==0		;Maximum records per block of all disk types
INTERN MXPGUN

;MACRO USED TO DO ACTUAL WORK.  IT DEFINES THE OFFSET FOR THIS DATA,
;REMEMBERS THE VALUE OF THIS DATA FOR USE IN LATER EXPRESSIONS, AND
;DUMPS THE DATA.

DEFINE DSKDAT ' (NAME,VALUE,TEXT)<
	INTERNAL NAME
	RADIX	5+5
$'NAME==VALUE			;;CONDENSE THE EXPRESSION
NAME::	$'NAME			;TEXT
	RADIX	4+4
>;end DSKDAT


;NOW DUMP OUT THE TABLES FOR EACH KIND OF DISK:


IFN FTRH,<
INTERN DSKSZ1,DSKSZ2
;	DSKSZ0:	DSKTAB (4,20,19,411,13,9,128,128,112,1)	;DATA FOR RP04 AND RP05

;DSKSZ1:	DSKTAB (4,20,19,815,13,9,128,128,112,1)	;real DATA FOR RP06
DSKSZ1:	DSKTAB (4,18,19,815,13,8,128,128,112,1)	;DATA FOR RP06 so we can boot there
DSKSZ2:	DSKTAB (4,43,32,629,7,8,128,128,112,1)	;DATA FOR RP07

;	DSKSZ3:	DSKTAB (4,30,5,820,8)		;DATA FOR RM03
;	DSKSZ4:	DSKTAB (1,6,30,1119,8)		;DATA FOR RP20

>;IFN FTRH

IFN FTSUAI,<
DSKSZZ:	DSKTAB (4,19,19,815,13,18,32,32,32,0)	;Ampex DM330 for SAIL
>;FTSUAI

IFN FTF2,<
DSKSZZ:	DSKTAB (4,32,19,815,13,31,128,32,32,0)	;CDC disks for Foonly
>;FTF2
	purge	dskdat				;not to be confused w/DDB cell
;⊗ CUADDR DSKADR SNSLEN NSWCYL NSWCYL PACKAD ZZZ TTRK ZZZ LSTBIT SATWCT LSTUBT SATUWC LSTADR LSTTRK NCYL CUDVAD RCLTAB

SUBTTL DATA AREA FOR SAUNDERS DISK SERVICE - JAM 10-20-69
;TEMP STORAGE &C. FOR DSKSER

IFN FTAMPD,<
↓CUADDR←←6		;CONTROL UNIT ADDRESS
↓DSKADR←←<CUADDR,,0>	;FILE DISK DEVICE ADDRESS
↓SNSLEN←←=24		;NUMBER OF SENSE BYTES
>;IFN FTAMPD

IFN NPACKS,<
IFN FTNSWP,<
IFE FTF2,<
↓NSWCYL←←=18		;NUMBER OF CYLINDERS PER PACK FOR SWAPPING
>;IFE FTF2
IFN FTF2,<
↓NSWCYL←←=34		;NUMBER OF CYLINDERS PER PACK FOR SWAPPING
>;IFN FTF2
>;IFN FTNSWP

;PACKAD IS A TABLE THAT CONTAINS THE LAST LEGAL PHYSICAL TRACK NUMBER FOR
;ANY GIVEN DISK PACK.
	-1		;FOR REFERENCE TO PACKAD-1
PACKAD:
ZZZ←←0			;PACK NUMBER
TTRK←←0			;TOTAL TRACKS SO FAR
;  CAUTION: IF UDPS ARE NOT ALL THE SAME SIZE, ONE OF THE LARGEST MUST BE UDP1
IFN FTSUAI,<DEFINE XX <FOR @' I IN (=815)> >	;must match OUTER's # of packs
IFN FTCCRMA,<DEFINE XX <FOR @' I IN (=815,=815,=815)> > ;match OUTER
IFN FTLLL,<DEFINE XX <FOR @' I IN (=815,=815,=815)> >	;match OUTER
XX <
CAT(↓NCYL,\ZZZ)←←I			;NUMBER OF CYLINDERS FOR THIS PACK
CAT(↓NTRK,\ZZZ)←←I*TRKCYL		;NUMBER OF TRACKS FOR THIS PACK
CAT(↓TTRK,\ZZZ)←←TTRK←←TTRK+I*TRKCYL	;TOTAL TRACKS
ZZZ←←ZZZ+1
	TTRK-1				;LAST LEGAL TRACK IN THIS PACK
>
IFN .-PACKAD-NPACKS,<
	.FATAL NPACKS ≠ NUMBER OF PACKS AT PACKAD
>

↓LSTBIT←←CAT(TTRK,\<FPACKS-1>)-1	;LAST LOGICAL TRACK # IN FILE SYS (NOT UDP)
↓SATWCT←←LSTBIT/=36+1			;NUMBER OF WDS IN SAT BITTABLE FOR FILE DSK
IFN UPACKS,<
↓LSTUBT←←CAT(NTRK,\FPACKS)-1		;LAST LOGICAL TRACK # IN FIRST UDP
↓SATUWC←←LSTUBT/=36+1		;NUMBER OF WORDS IN SAT BIT-TABLE FOR UDP
>;IFN UPACKS
↓LSTADR←←TTRK-1			;LAST LOGICAL TRACK NUMBER (INCLUDING UDP)
↓LSTTRK←←TTRK-1			;LAST LEGAL PHYSICAL TRACK NUMBER (INCLUDING UDP)

;NCYL IS A TABLE CONTAINING THE NUMBER OF CYLINDERS FOR EACH PACK
↓NCYL:	
FOR @' I ← 0,NPACKS-1 <
	<NCYL'I>
>

CUDVAD:	<DSKADR⊗-=14>!0		;CONTROL UNIT NUMBER AND PACK NUMBER
IFE FTSUAI,<
	<DSKADR⊗-=14>!1
	<DSKADR⊗-=14>!2
>;IFE FTSUAI
IFN .-CUDVAD-NPACKS,<.FATAL GUESS WHAT YOU FORGOT TO CHANGE>

;TABLE OF WCMA INCREMENTS CORRESPONDING TO EACH RECORD OF A TRACK.
RCLTAB:
REPEAT BKPTRK,<
	SECSIZ,,SECSIZ
REPEAT RCPBLK,<
	RECSIZ,,RECSIZ
>
>
>;IFN NPACKS
;⊗ SAT2RC BADMAX ECCTKS BADSIZ DSTCNT DSTPUT DSTBLN DSTBUF DSTBLN DSTBUF INTRTN UUOACS UUOACS UUOACS DSKPDL DSKSV ACDDB SWPDDB UFDUSE UFDWAT UFDWAK SATDIR SATADR TSATSZ BFSET BFSETS LSTRKT DKDBML LSTBTB UDPOWN UDPCNT SATMOD SDB0 ST.NAM ST.SAD ST.SSZ ST.BFS ST.BSS ST.LAD ST.RPB ST.RTS ST.MDB ST.BTB ST.LSA ST.JOB ST.CNT ST.SMD ST.MFA ST.STA ST.STB ST.STN ST.TYP SDB$UNUM ST.NAM ST.SAD ST.SSZ ST.BFS ST.BSS ST.LAD ST.RPB ST.RTS ST.MDB ST.BTB ST.LSA ST.JOB ST.CNT ST.SMD ST.MFA ST.STA ST.STB ST.STN ST.TYP RHSDB ST.NAM ST.SAD ST.SSZ ST.BFS ST.BSS ST.LAD ST.RPB ST.RTS ST.MDB ST.BTB ST.LSA ST.JOB ST.CNT ST.SMD ST.MFA ST.STA ST.STB ST.STN ST.TYP ST.RPC ST.BPC ST.SCW ST.RPU ST.STS ST.NSS ST.FSS ST.UIS ST.PUC ST.UIL ST.LEN SDBUDB SDBNUM SDBSTS SDBNSS SDBNAM SDBSIZ SDBRXB SDBFSS SDBTYP SDBPUC SDBADR STRTAB STRMAX STRN SBWLH SBWLT SBACNT SBATAB

SAT2RC←←7		;REST OF SAT BIT TABLE BEGINS AT REC 7 ON SECOND TK
↑BADMAX←←=10		;MAX NO. OF BAD TRACKS.
ECCTKS←←=34		;USE UP REMAINING SPACE FOR ECC MARGINAL TRACKS
			;ONE WORD RESERVED FOR NXTSAT
BADSIZ←←=45		;SPACE ALLOCATED IN SAT FOR BAD TRACKS
;CAREFUL!!! CHANGING BADSIZ CHANGES THE SAT TABLE!
IFG <BADMAX+ECCTKS+1-BADSIZ>,<.FATAL BADMAX+ECCTKS MUST BE LESS THAN BADSIZ>

IFN FTDSTT,<		;DATA AREA FOR DISK STATISTICS
↑DSTCNT:0		;COUNT OF THE NUMBER OF TIMES WE'VE WRAPPED
↑DSTPUT:0		;PUTTER FOR SYSTEM TO STUFF THINGS INTO.
↑DSTBLN←←300		;MUST BE A MULTIPLE OF 10 (NUMBER OF THINGS/ENTRY)
↑DSTBUF:BLOCK DSTBLN
>;IFN FTDSTT
IFE FTDSTT,<
↑DSTBLN←←0
↑DSTBUF←←0
>;IFE FTDSTT

INTERN INTRTN
↑INTRTN:0			;WHERE TO GO TO DISMISS INTERRUPT
	GLOBAL CH6SAC
IFE FTF2,<
↑UUOACS←←CH6SAC
>;IFE FTF2
IFN FTF2,<
IFE FTAPR4,<
↑UUOACS←←CH2SAC
>;IFE FTAPR4
IFN FTAPR4,<
↑UUOACS←←CH3SAC
>;IFN FTAPR4
>;IFN FTF2

↑DSKPDL:BLOCK 50		;PRIVATE PDL FOR DSKSER INTERRUPT LEVEL

↑DSKSV:	0
	MOVEM 17,UUOACS+17
	MOVEI 17,UUOACS
	BLT 17,UUOACS+16	;SAVE USER'S ACS IN COMMON INTERRUPT LEVEL AREA.
	MOVE P,[-50,,DSKPDL-1]
	PUSHJ P,@DSKSV		;SERVICE INTERRUPT.  MUST RETURN IN PROG ON DSKCHL
	MOVSI 17,UUOACS		;RETURN HERE TO DISMISS;
	BLT 17,17		;RESTORE USER'S AC'S.
NOKL10,<			;SIMULATE CONTINUING DSKCHN INTERRUPT IF REQUESTED
IFN FTMSYSBUF,<
	SKIPE UFDWAK		;SEE IF ANY UFD WAITER NEEDS TO WAKE UP
	JRST UFDINT		;MUST BE BEFORE NORMAL DISK INTERRUPTS
>;IFN FTMSYSBUF
IFN FTF2,<
	SKIPE F2DERF		;HERE TO PROCESS AN ERROR FOR F2 DISK?
	JRST F2DERI		;YES
	SKIPE F2DUNF		;F2 DISK XFER DONE?
	JRST F2DXIT		;YES, TAKE CARE OF THAT
>;IFN FTF2
>;NOKL10
IFN FTXADR,<
	XJEN DSKCHL
>;IFN FTXADR
IFE FTXADR,<
	JRST 12,@DSKCHL
>;IFE FTXADR

↑ACDDB:	0			;LAST DDB FOR BAD AUDIT
IFE FTDMDP,<
↑SWPDDB:0			;Address of the DISK DDB FOR SWAPPING
>;IFE FTDMDP

IFN FTMSYSBUF,<
↑UFDUSE:0			;POINTER TO UFD USERS
↑UFDWAT:0			;POINTER TO UFD WAITERS
↑UFDWAK:0			;POINTER TO UFD WAKERS
>;IFN FTMSYSBUF

↑SATDIR:-1			;I/O DIRECTION. USED BY ACISAT ETC.
				;-1:READ    0:WRITE	THE SAT TABLE.

NOSTRUC,<
;HERE ARE THE MAGIC TABLES FOR MULTIPLE FILE STRUCTURES.
↑SATADR:	SATTAB			;CORE ADDRESS OF SAT FOR EACH STRUCTURE
	REPEAT UPACKS,<0>
↑TSATSZ:	SATSIZ			;LENGTH OF SAT FOR EACH STRUCTURE
	REPEAT UPACKS,<USATSZ>

↑BFSET:		0			;BLOCK NUMBER OFFSET TO FIRST BN IN STR
FOR UNUM←1,UPACKS<
	CAT(TTRK,\<FPACKS+UNUM-2>)	;OFFSET TO FIRST BLOCK OF THIS UDP
>
↑BFSETS:	0⊗6			;SAME AS BFSET ONLY SHIFTED LEFT 6 BITS
FOR UNUM←1,UPACKS<
	CAT(TTRK,\<FPACKS+UNUM-2>)⊗6
>
↑LSTRKT:	LSTTRK			;MAX TRK FOR GODMOD--DSK GETS ALL PACKS
FOR UNUM←1,UPACKS<
	CAT(NTRK,\<FPACKS+UNUM-1>)-1	;BUT EACH UDP ONLY GETS ITSELF
>

↑DKDBML:	DSKDDB			;ADDRESSES OF MODEL DDBS
FOR @$ UNUM←1,UPACKS<
		UDP$UNUM$DD
>;FOR

↑LSTBTB:	LSTBIT			;number of bits in the sat table
REPEAT UPACKS,<	LSTUBT
>

↑UDPOWN:	REPEAT UPACKS,<-1>	;JOB # OF PRIVATE OWNER.  -1 IF PUBLIC

;UDPCNT THRU SATMOD+UPACKS ZEROED BY DSKINI
↑UDPCNT:	BLOCK UPACKS		;# DDBS REFERENCING THIS UDP
↑SATMOD:	BLOCK UPACKS+1		;-1 IF SAT NEEDS TO BE WRITTEN
					;+ IF ON WAY IN OR OUT
>;NOSTRUCTURE

;This is the new way to do multiple structures
;  One table, indexed by structure number (PUNIT), addresses the structure
;  data block.   Each SDB contains fields as follows:

IFSTRUCTURE,<

INTERN	SDBADR,STRMAX

IFN NPACKS,<
SDB0:		Phase 0
ST.NAM::	'DSK   '		;Sixbit name of the current structure
ST.SAD::	SATTAB			;Address of the in-core SAT Table
ST.SSZ::	SATSIZ			;Size of the SAT Table
ST.BFS::	0			;Address of first block in structure
ST.BSS::	0⊗6			;Address of first block, Shift by 6
ST.LAD::	LSTTRK			;Number of addressable blocks
					; For DSK: this includes the UDPs as well
ST.RPB::	RCPBLK			;Number of data records per block
ST.RTS::	SECSIZ			;Size of retrieval in words
ST.MDB::	DSKDDB			;Address of the model DDB
ST.BTB::	LSTBIT			;number of bits in the sat table
ST.LSA::	LSTBIT+1		;First non-ex address in structure
ST.JOB::	-1			;Job # of private owner; -1 Public; 0 DET
ST.CNT::	0			;Number of DDBs using this UDP
ST.SMD::	0			;-1 if SAT was changed: we must write it.
ST.MFA::	1			;Block number of the MFD in structure
ST.STA::	0			;Block number of the SAT in Structure
ST.STB::	SAT2RC			;Rec number in the second SAT block
ST.STN::	0			;Structure number
ST.TYP::	DSKSZZ			;Internal type of disk units in str
		DEPHASE

;Note the use of the labels below.  In case you screw up, FAIL won't let you escape
FOR @$ UNUM←1,UPACKS<
SDB$UNUM:	Phase 0
ST.NAM::	0			;Sixbit name of the current structure
ST.SAD::	0			;Address of the in-core SAT Table
ST.SSZ::	USATSZ			;Size of the SAT Table
ST.BFS::	CAT(TTRK,\<FPACKS+UNUM-2>)   ;Address of first block in structure
ST.BSS::	CAT(TTRK,\<FPACKS+UNUM-2>)⊗6 ;As above, Shift left by 6
ST.LAD::	CAT(NTRK,\<FPACKS+UNUM-1>)-1 ;last addressable block
ST.RPB::	RCPBLK			;Number of data records per block
ST.RTS::	SECSIZ			;Size of retrieval in words
ST.MDB::	UDP$UNUM$DD		;Address of Model DDB
ST.BTB::	LSTUBT			;Number of bits in the sat table
ST.LSA::	LSTUBT+1		;First non-ex address in structure
ST.JOB::	-1			;Job # of private owner; -1 Public; 0 DET
ST.CNT::	0			;Number of DDBs using this UDP
ST.SMD::	0			;-1 if SAT was changed: we must write it.
ST.MFA::	1			;Block number of the MFD in structure
ST.STA::	0			;Block number of the SAT in Structure
ST.STB::	0			;extra SAT not needed in UDP
ST.STN::	UNUM			;Structure number
ST.TYP::	DSKSZZ			;Internal type of disk units in str
		DEPHASE
>;FOR UNUM, etc
>;IFN NPACKS

IFN FTRH,<
;Note the use of the labels below.  In case you screw up, FAIL won't let you escape
;This is the prototype RH-based SDB
RHSDB::		Phase 0
ST.NAM::	0			;Sixbit name of the current structure
ST.SAD::	0			;Address of the in-core SAT Table
ST.SSZ::	0			;Size of the SAT Table
ST.BFS::	0			;Address of first block in structure
ST.BSS::	0			;As above, Shift left by 6
ST.LAD::	0			;first non-addressable record = last+1
ST.RPB::	0			;Number of data records per block
					;Add one more to get # of actual R per B
ST.RTS::	0			;Retrieval size
ST.MDB::	0			;Address of Model DDB
ST.BTB::	0			;Number of bits in the sat table
ST.LSA::	0			;First non-ex address in structure = LAD
ST.JOB::	-1			;Job # of private owner; -1 Public; 0 DET
ST.CNT::	0			;Number of DDBs using this UDP
ST.SMD::	0			;-1 if SAT was changed: we must write it.
ST.MFA::	0			;Block number of the MFD in structure
ST.STA::	0			;Block number of the SAT in Structure
ST.STB::	0			;1B0+CHAN/UNIT/RECORD for SAT address
ST.STN::	0			;Structure number
ST.TYP::	0			;Internal type of disk units in str
;below here, anything goes for RH-based SDB
ST.RPC::	0			;number of records/cyl from SECCYL
ST.BPC::	0			;blocks/cylinder from .RPC/.RPB
ST.SCW::	0			;1,,CCW list address for SAT Write
ST.RPU::	0			;Number of records per unit.
ST.STS::	0			;Status
ST.NSS::	0			;number of swapping sectors
ST.FSS::	0			;number of first swapping sector
ST.UIS::	0			;number of units in structure
ST.PUC::	0			;"pack unique code"
ST.UIL::	BLOCK MAXUIS		;Table of UDB address for each U in STR
ST.LEN::				;minimum length for an SDB
		DEPHASE
		ORG RHSDB
		PURGE RHSDB
;Transliterations
SDBUDB==ST.UIL		;list of UDBs(Logical Unit#) for each unit in S
SDBNUM==ST.UIS		;Numberof units in structure
SDBSTS==ST.STS		;Status
SDBNSS==ST.NSS		;number of swapping sectors
SDBNAM==ST.NAM		;STRUCTURE NAME
SDBSIZ==ST.RPU		;SIZE IN SECTORS OF EACH UNIT IN STR
SDBRXB==ST.MFA		;ADDRESS OF ROOT DIR INDEX BLOCK
SDBFSS==ST.FSS		;FIRST SWAPPING SECTOR PER UNIT
SDBTYP==ST.TYP		;ADDRESS OF DSKSIZ TABLE FOR THIS TYPE OF DISK
SDBPUC==ST.PUC		;"Pack Unique Code"

INTERN	SDBUDB,SDBNUM,STRTAB,SDBSTS,SDBNSS,SDBNAM,SDBSIZ,SDBRXB,SDBFSS,SDBTYP,SDBPUC

INTERN	ST.STS,ST.UIS,ST.UIL,ST.LEN,MAXUIS,ST.NSS,ST.RPU,ST.FSS,ST.SCW,ST.BPC,ST.RPC
>;IFN FTRH
INTERN	ST.NAM,ST.SAD,ST.SSZ,ST.BFS,ST.BSS,ST.LAD,ST.MDB,ST.BTB,ST.JOB,ST.CNT,ST.LSA
INTERN  ST.SMD,ST.MFA,ST.STA,ST.STB,ST.STN,STRN,ST.RTS,ST.RPB,ST.TYP

SDBADR:					;Table of SDB addresses
STRTAB==SDBADR
FOR @$ UNUM←0,UPACKS<
	SDB$UNUM
>;For
	0				;Room for a couple more?
	0
	0
	0
STRMAX←←.-SDBADR			;Number of Structures we can accomodate
STRN==STRMAX		;MAXIMUM NUMBER OF STR'S ALLOWED


;temporary to make sure we get rid of all the old ones
DEFINE	SATADR	<↔.FATAL>		;st.SAD
DEFINE	TSATSZ	<↔.FATAL>		;st.SSZ
DEFINE	BFSET	<↔.FATAL>		;st.BFS
DEFINE	BFSETS	<↔.FATAL>		;st.BSS
DEFINE	LSTRKT	<↔.FATAL>		;st.LAD
DEFINE	DKDBML	<↔.FATAL>		;st.MDB
DEFINE	LSTBTB	<↔.FATAL>		;st.btb
DEFINE	UDPOWN	<↔.FATAL>		;st.JOB
DEFINE	UDPCNT	<↔.FATAL>		;st.CNT
DEFINE	SATMOD	<↔.FATAL>		;st.SMD
>;IFSTRUCTURE

;Data structures for the SBA Free List and SB wait list
SBWLH:	0				;Head of list of DDBs waiting for SB
SBWLT:	SBWLH-DD.SBW			;Tail of list of DDBs waiting
SBACNT:	0				;Number of valid entries in SBATAB
SBATAB:	BLOCK	NSBUFS			;AOBJN pointers to valid SYS Buffers
;⊗ A A DSKDDB C1PDLL IRBLEN NPPXFR DQLEN DDBSIZ RHDBSZ FWRTVL

INTERNAL TFRSEC,TFRCTL,TFRIOW,C1ACS

;DSKDDB--THE DUMMY DEVICE DATA BLOCK IS THE FIRST ONE IN THE CHAIN.
LALL

	DEFINE ZWD (A)<
	↑A←.-DSKDDB
;	INTERNAL A
	0	>

	DEFINE ZLOC (A)<
	↑A←.-DSKDDB
;	INTERNAL A
	>

REPEAT DDBSKW-2,<0>
	DSKDDB+DEVIOS				;DEVSPT
	DEVAOA!DEVSHR!DEVSTS,,0			;DEVCMR
↑DSKDDB:SIXBIT /DSK/				;DEVNAM
	=60*HUNGST,,RECSIZ+1			;DEVCHR  PUNIT=0!
	0					;DEVIOS
	DSK.NX,,DSKDSP				;DEVSER. NEXT DDB IS UDP.
	DVOUT+DVIN+DVDIR+DVDSK+DVLNG,,154403	;DEVMOD
	0					;DEVLOG
	0					;DEVBUF
	0					;DEVIAD
	0					;DEVOAD

;FROM HERE THROUGH USETP ARE LOOKED AT BY WHO
;NEXT 8 LOCATIONS COPIED AT AUDINF
	ZWD FILNAM←		;FILNAM THRU DMPTIM MUST STAY TOGETHER IN ORDER!
	ZWD FILEXT←		;THESE DENOTE THE FILE THAT IS CURRENTLY ACCESSED
	ZWD FILPRO←
	ZWD FILPPN←
	ZWD FILLOC←
	ZWD FILLNG←
	ZWD REFTIM←
	ZWD DMPTIM←

IFN FTLUFD,<			;THESE 5 LOCATIONS ALSO COPIED AT AUDINF
	ZWD FILIN0←		;FILIN0 THRU FILOFF MUST BE TOGETHER.
	ZWD FILIN1←		;THEY FURTHER DENOTE THE FILE CURRENTLY ACCESSED
	ZWD FILIN2←
	ZWD FILIN3←
	ZWD FILOFF←
>;IFN FTLUFD
IfStructure,<
Intern SDBPTR,DD.SSZ,DD.RPB,DD.RTL,DD.BPG,DD.RPG
	ZLOC SDBPTR←
	SDB0			;Make DDB point to structure descriptor block
	ZLOC DD.SSZ←
	SECSIZ			;actual size in words of rtvl sector.
	ZLOC DD.RPB←
	RCPBLK			;number of data records per block
	ZLOC DD.RTL←
	40			;SYMBOL?   Number of RTVL words in use
	ZLOC DD.BPG←
	BKPGRP			;Number of blocks per group
	ZLOC DD.RPG←
	RCPGRP			;number of records per group
>;IfStructure

	ZWD USETP←
	ZWD UFDPRO←		;PROTECTION OF THE UFD FROM WHICH FILE CAME
	ZWD UFDPR1←		;TEMP COPY OF ABOVE WHILE DOING RENAME
				;ALSO, RH← LH(DQINFO+3) OF UFD LAST ACCESSED
	ZWD UFDPPN←		;PPN OF LAST UFD USED
	ZWD UFDADR←		;DISK ADDR OF LAST UFD USED

	ZWD ACCNAM←		;ACCNAM THRU ACCPPN MUST STAY TOGETHER IN ORDER
	ZWD ACCEXT←		;DENOTE THE ARGUMENTS TO LOOKUP,ENTER,RENAME
	ZWD ACCPRO←
	ZWD ACCPPN←

	ZWD SRCNAM←		;ARGUMENTS FOR SEARCHING MFD AND UFD
	ZWD SRCEXT←
	ZWD SRCPRO←
	ZWD SRCLOC←
	ZWD SRCTMP←
IFN FTLUFD,<
	ZWD SRCDAT←
>;IFN FTLUFD

IFN FTSIX,<
	ZWD IOWDSX←		;IOWD FOR XFER TO P3 MEMORY
	ZWD ECCSIX←		;AOBJN POINTER TO USER AREA FOR ECC BYTES TO P3
	ZWD ECCLOS←		;FIRST P3 LOCATION OF RECORD WHOSE ECC INFO IS LOST
>;IFN FTSIX
	ZWD PQFOR←		;PACK QUEUE FORWARD POINTER
	ZWD PQBAK←		;PACK QUEUE BACKWARD POINTER
	ZWD PQTIM←		;PACK QUEUE ENTRY TIME
	ZWD PQCYL←		;PACK QUEUE DESIRED CYLINDER
	ZWD PQHHR←		;PACK QUEUE HEAD AND RECORD NUMBERS AND WRAP REC #
	ZWD PQPACK←		;PACK QUEUE PACK NUMBER
	ZWD DSKLRN←		;-1 → SATOP, -1,,ADDR → SWAP OR OLD UDP OP,ELSE ADDR

	ZWD UFDNAM←		;NAME OF UFD FOR UFD INTERLOCK
	ZWD UFDLNK←		;LINK IN UFDUSE OR UFDWAT LIST
	ZWD WAKLNK←		;link in UFDWAK list
IFN FTLUFD,<
	ZWD UFDTRK←		;DISK ADDRESS AT LAST SUCCESSFUL DIRSRC (NON-MFD)
	ZWD UFDMEM←		;CORE ADDRESS OF UFD ENTRY FOUND BY DIRSRC
	ZWD DATWRT←		;EXTENDED DATE LAST WRITTEN FOR UFD ENTRY
>;IFN FTLUFD
C1PDLL←←60
	ZWD C1PDL←		;PUSH DOWN LIST FOR INT LVL ROUTINES
	BLOCK C1PDLL
	ZWD C1ACS←		;INT LEVEL ACS SAVED HERE ON CALLS TO TGO
	BLOCK 20
IFN FTDCSH,<
	ZWD CSHBUF←		;POINTERS TO FS FOR USER UNCACHED PAGES
>;IFN FTDCSH
	ZWD UDPBUF←		;POINTER TO FS FOR CHANNEL PROG FOR OLD UDP
	ZWD BUFBUF←		;BUFFER FOR POINTERS TO USER BUFFERS
	ZWD DMPBUF←		;NEW DDB GET CLEARED THROUGH HERE (SEE SETDDB)
	ZWD SNSSTA←		;SAVED STAT A WORD BEFORE SENSE COMMAND ISSUED
	ZWD DRAUFO←		;FLAG THAT DRAUFD FAILED.

	ZWD TFRSEC←		;TRANSFER SECTOR (TRACK AND RECORD)
	ZWD TFRIOW←		;WCMA FOR TRANSFER
	ZWD TFRCTL←		;DENOTES INPUT, OUTPUT, MAPPED, ETC.

	ZWD DSKFAD←
	ZWD DSKLAD←
	ZWD CORFAD←
	ZWD CORLAD←

	ZWD DD.SBA←		;-WC,,MEM ADDR for SYSBUF in use by this DDB.
	ZWD DD.SBB←		;-WC,,MEM ADDR for in-use part of SYSBUF
	ZWD DD.SBW←		;Chain list of DDBs waiting for SB assignments
	ZWD DD.ULK←		;Set to PC of called of UFDREQ
IfN FTRH,<
Intern DSKQTM,DSKQWC
	ZLOC DSKQTM←		;high precision time when XFER starts
	BLOCK 2
	ZWD DSKQWC←		;WC of RH xfer
IRBLEN==7
INTERN IRBLEN			;again, barf if disagrees with PHYPAR
INTERN DD.IRB,DD.MAP,DD.CCP
	ZLOC DD.IRB←
	BLOCK IRBLEN		;IORB for this ddb
;The maximum number of CCWs needed for a transfer:
;We doing one block transfers, sector by sector, in buffered mode.
;  In buffered mode, each sector could be split across a page boundary
;  in user space (2 CCW words per sector).  In buffered output, we sometimes
;  write rtvl from DDB (which could likewise cross a page boundary in exec space).
;  So the length of the CCW list is likely to be 2*<MAXRPB+1>.  Plus,
;  we need a halt CCW. (In preference to halting on the last data CCW.)
;  These 2*MAXRPB+3 words can't be split across a page boundary, so
;  we'll leave room for twice as many as this.  Plus one for the AOBJN
;  pointer to the CCW list.  1+2*<2*MAXRPB+3> = 4*MAXRPB+7
NPPXFR==<4*MAXRPB>+7		;space allocated to the CCW list
	ZWD DD.MAP←		;Exec Address of Map for this XFER.+1B0 if DEV READ
	ZWD DD.CCP←		;Pointer for storing into CCW list.
	ZLOC DD.CCW←		;Aobjn pointer to CCW List for current transfer
	BLOCK NPPXFR		;followed by the CCWs themselves
;Note: for the RH-swapping DDB, the data at DSKDAT isn't needed and the
;      CCW list may overflow into DSKDAT.  Nothing should intervene
;      between DD.CCW and DSKDAT
>;IfN FTRH
	

	ZLOC DSKDAT←	;BEGIN GROUP-DEPENDENT PART OF DDB (RETRIEVAL)
			;HERE THROUGH DDMPTM ARE COPIED FROM FILNAM THROUGH DMPTIM
	ZWD DDNAM←	;FILE NAME
	ZWD DDEXT←	;EXT,,HIDATE-1 DATE-2
	ZWD DDPRO←	;PRO,MODE,TIME,LODATE-1
	ZWD DDPPN←	;PPN
	ZWD DDLOC←	;NUMBER OF THE FIRST TRACK OF THIS FILE
	ZWD DDLNG←	;POSITIVE LENGTH OF THIS FILE, IN WORDS
	ZWD DREFTM←	;REFERENCE DATE AND COUNT
	ZWD DDMPTM←	;DUMP DATE WORD
	ZWD DGRP1R←	;FIRST USER RCRD NO. THIS GRP
	ZWD DNXTGP←	;BLOCK NUMBER OF FIRST TRACK OF NEXT GROUP
	ZWD DSATID←	;SATID
	ZWD DQINFO←	;START OF SPECIAL STORAGE FOR LOGIN ETC.
	ZWD DQINF1←
	ZWD DQINF2←
	ZWD DQINF3←
↑↑DQLEN←←.-DSKDDB-DQINFO
	ZWD DOFFST←	;RECORD OFFSET
IFN .-DSKDDB-DDNAM-20,<.FATAL RETRIEVAL DEFINITIONS WRONG AT DSKDAT
>
	ZLOC DPTR←	;RETRIEVAL DATA,
	BLOCK 20	;2 BLK NO.'S/WORD
IFG SECSIZ-40,<	;REALLY, FOR FTF2, WHERE SECSIZ IS 200, NOT 40
	BLOCK SECSIZ-.+DSKDAT+DSKDDB ;ROOM FOR UNUSED SPACE IN RETRIEVAL RECORD
PRINTX Maybe fix F2 system to read only 40 wds of retrieval into DDB, saving FS.
>;IFN SECSIZ		;DSKSER READS SECSIZ WDS OF RETRIEVAL RIGHT INTO DDB
	ZLOC DDEND←
↑DDBSIZ←←.-DSKDDB+DDBSKW

IFN FTRH,<
↑RHDBSZ←←DDBSIZ+<RECSIZ-SECSIZ>		;DDBs for RH disks use full record of RTVL info

IFN DSKDAT-<DD.CCW+NPPXFR>,<.FATAL See comment following DD.CCW>
>;IFN FTRH

IfStructure,<
↑FWRTVL←←RECSIZ-<DPTR-DSKDAT>		;112.  If DD.BPG (Blocks per Group) equals
					; this value, then we're using full word
					; record numbers as disk addresses
>;IfStructure
;⊗ DSKOPS DSKOVC SATID2 DSKHNG NECCS PRTLOG SATID1 RTRHCT NECCTK FXTRKN ECCTKT ECCEND ECCAOB ECCMSG ECCMS2 LECCQU ECCQUI

;HERE ARE VARIOUS PIECES OF DATA.

↑DSKOPS:	BLOCK JOBN	;NUMBER OF DISK OPERATIONS FOR EACH JOB
↑DSKOVC:	0		;COUNT OF TIMES OVERWRITE CHECKER PROHIBITED WRITE

IFN NPACKS,<

↑SATID2:	0		;SECOND COPY OF SATID
↑DSKHNG:	BLOCK 2		;DISK HUNG COUNTING CELLS, COUNTED DOWN BY DEVCHK

IFN FTSECC,<
↑NECCS:		0		;NUMBER OF ECCS IN ENTIRE SYSTEM UPTIME
>;IFN FTSECC
↑PRTLOG:	0		;-1 TO PRINT ERROR LOGGING INFORMATION
↑SATID1:	0		;FIRST COPY OF SATID
↑RTRHCT:	BLOCK TRKCYL*NPACKS	;COUNT OF RETRIES/HEAD/PACK

IFN FTECCT,<
↑NECCTK←←5			;NUMBER OF DISTINCT ECC CYLS PER PK/HD ALLOWED
↑FXTRKN:	0		;ECC TRACK NUMBER SAVED HERE
↑ECCTKT:	BLOCK NECCTK*TRKCYL*NPACKS	;<COUNT*100>,,<CYL #> OF ECC TKS
↑ECCEND←←ECCTKT+<NECCTK*TRKCYL*FPACKS>-1	;LAST WORD TO BLT TO 0 AT DSKINI
↑ECCAOB:	-ECCTKS,,ECCTRK	;AOBJN POINTER INTO SATTAB
↑ECCMSG:	0		;INDEX INDICATING DISPOSITION OF ECC FOR MSG TYPED
>;IFN FTECCT

IFN FTQECC,<
↑ECCMS2:	0	;-1 IF SUPPRESSING LATER ECC MSGS FOR CURRENT ECC TRACK
↑LECCQU←←12		;NBR OF TRACKS WE CAN SUPPRESS ECC MSGS FOR PER UNIT
↑ECCQUI:
	BLOCK <UPACKS+1>*LECCQU-<.-ECCQUI> ;LECCQU CONTIGUOUS WORDS PER DISK UNIT
;To suppress DF ECC messages for a given track on a given disk unit (i.e., either
;in the system file structure (unit 0), or on UDPn (unit n), set any of the
;LECCQU words for that unit to the track number.  The first subsequent ECC on that
;track will be typed out, along with "LATER ECCs SUPPRESSED", and thereafter
;no ECCs messages are printed for that track, but a count of any ECCs on that
;track is kept in the 777700,,0 bits of the word that holds the track number in
;the above table.  Should there be 7777 ECCs on that track, the next two
;will again be listed and subsequent ones suppressed.

;The monitor command (where track numbers are in octal)
;	ECC trk1,trk2,...,trkN
;puts the given N tracks into the table (if there is room) for the system packs.
;A plain old command
;	ECC
;types out the contents of the table for the system packs (or at least as
;much as fits in your tty output buffer).
>;IFN FTQECC

>;IFN NPACKS
;⊗ SECTBL ERRCL0 ERRCL1 ERRCL2 ERRCL3 ERRCL4

IFN NPACKS,<
DEFINE SECTRS
<FOR I IN (0,6,15,23,32,41,50,56,65,74,103,111,120,127,136,144,153,162,171)>

IFN FTSETSEC,<
↑SECTBL:SECTRS <I		;SECTOR NUMBERS CORRESPONDING TO RECORDS
>
>;IFN FTSETSEC

;COLLECT ERROR COUNTS HERE
↑ERRCL0:	BLOCK NPACKS*2
↑ERRCL1:	BLOCK NPACKS*2
↑ERRCL2:	BLOCK NPACKS*2
↑ERRCL3:	BLOCK NPACKS*2
↑ERRCL4:	BLOCK NPACKS*2
>;IFN NPACKS
;⊗ MAXCL0 MAXCL1 MAXCL2 MAXCL3 MAXCL4 TYMSK0 TYMSK1 TYMSK2 TYMSK3 TYMSK4 TOTCL0 TOTCL1 TOTCL2 TOTCL3 TOTCL4 TYPCL0 TYPCL1 TYPCL2 TYPCL3 TYPCL4

IFN NPACKS,<
;THESE ARE THE HARD ERROR MAXIMUMS!
↑MAXCL0:	100
↑MAXCL1:	100
↑MAXCL2:	4		;USED TO BE 100 BUT THAT'S RIDICULOUS
↑MAXCL3:	100
↑MAXCL4:	100

;THESE ARE THE MASKS FOR WHEN TO PRINT AN ERROR CLASS
;THEY MUST BE -2**N-1 FOR TDNE
↑TYMSK0:	¬10
↑TYMSK1:	¬10
↑TYMSK2:	¬10
↑TYMSK3:	¬10
↑TYMSK4:	¬20

;COLLECT TOTAL COUNTS HERE
↑TOTCL0:	0
↑TOTCL1:	0
↑TOTCL2:	0
↑TOTCL3:	0
↑TOTCL4:	0

;SET THESE FLAGS TO FORCE TYPEOUT OF EVERY ERROR
↑TYPCL0:	0
↑TYPCL1:	0
↑TYPCL2:	0
↑TYPCL3:	0
↑TYPCL4:	0
>;IFN NPACKS
;⊗ DEATH TYPANY WNTTYP SNSTYP CSTOP HNGFLG DSKFLG REGOFL T1SAV NTSTART NSWPOP SWPTWC DSKTWC DKTIME DKATIM DKTIMT NDRDOP NDWDOP NDWROP NDRROP DSKNUM UIWCNT SBWCNT

IFN NPACKS,<
↑DEATH:		0	;ERROR ROUTINE HAS DECREED DEATH TO THE INFIDEL'S
↑TYPANY:	0
↑WNTTYP:	0
↑SNSTYP:	0
↑CSTOP:		0
↑HNGFLG:	0
↑DSKFLG:	0
↑REGOFL:	0
>;IFN NPACKS

T1SAV:		0

↑NTSTART:	0	;NUMBER OF CALLS ON TSTART IN DSKSER
↑NSWPOP:	0	;NUMBER OF DISK OPS INITIATED FOR SWAPPING
↑SWPTWC:	0	;TOTAL NUMBER OF WORDS SWAPPED
↑DSKTWC:	0	;TOTAL NUMBER OF WORDS TRANSFERRED
IFKL10,<
↑DKTIME:	BLOCK 2	;TOTAL TIME DISK IS ACTIVE
↑DKATIM:	BLOCK 2	;TIME AT CALL TO DKTIMA
↑DKTIMT:	BLOCK 2	;TEMPORARY AT DKTIMB
>;IFKL10

↑NDRDOP:	0	;NUMBER OF DISK READ DATA OPS
↑NDWDOP:	0	;NUMBER OF DISK WRITE DATA OPS
↑NDWROP:	0	;NUMBER OF DISK WRITE RETRIEVAL OPS
↑NDRROP:	0	;NUMBER OF DISK READ RETRIEVAL OPS

↑DSKNUM:	0	;unit number of primary disk (for WHOLINE's use of DSKRES)
↑UIWCNT:	0	;Ufd Interlock Wait Count
↑SBWCNT:	0	;System Buffer Wait Count
;⊗ SWPJOB SWPNXT SWPNX2 SWPPRV SWFRST BNDTSZ BNDTSZ MINSBS RHSBSZ NSSUN FSSUN RHSUNP RHSCYP RHSBNP SWBAND
IFN FTNSWP,<
;SWAPPING BANDS TABLE
;RIGHT HALF IS POINTER TO FIRST TRACK IN THE BAND.
;EVEN NUMBERED BANDS ARE 9 TRACKS LONG, ODD NUMBERED BANDS ARE 10 TRACKS LONG.
;LEFT HALF BITS 9-17 ARE THE POINTER TO THE NEXT BAND FOR THE JOB
;THAT OWNS THIS ONE.  JBTSWP LEFT HALF POINTS TO THE FIRST BAND FOR
;A JOB.  BITS (8-JOBNSZ+1) TO 8 CONTAIN THE JOB NUMBER THAT OWNS THE BAND.
;BIT 0 ON MEANS THIS IS THE LAST BAND IN THE LIST.

↑SWPJOB:	POINT JOBNSZ,SWBAND(TAC),8
;Make sure JOBNSZ isn't too big for available byte in SWBAND entry.
IFG JOBNSZ-8,<.FATAL JOBNSZ is too big for available byte in SWBAND.>
↑SWPNXT:	POINT 9,SWBAND(TAC),17
↑SWPNX2:	POINT 9,AC2,17
↑SWPPRV:	POINT 9,SWBAND(AC2),17
↑SWFRST:	POINT 9,SWBAND-1,17

IFE FTRH,<
↑BNDTSZ==2*SWPAKS*NSWCYL	;Size of Band Table for non-RH system
>;IFE FTRH

IFN FTRH,<
↑BNDTSZ== =256			;Size of Band Table for RH system
↑MINSBS== =40*=512		;Minimum size of a swapping band
↑RHSBSZ:  0			;Actual size of swapping band
↑NSSUN:  0			;number of swapping sectors
↑FSSUN:	 0			;first swapping sector
↑RHSUNP:	POINT 6,SWBAND(TAC),23		;Unit # of swapping band
↑RHSCYP:	POINT 6,SWBAND(TAC),29		;Cyl in Unit of swapping band
↑RHSBNP:	POINT 6,SWBAND(TAC),35		;Band in Cyl of swapping band
DEFINE SWDSIZ <↔.FATAL ref to SWDSIZ>
DEFINE SWPAKS <↔.FATAL ref to SWPAKS>
DEFINE NSWCYL <↔.FATAL ref to NSWCYL>
>;IFN FTRH

		0		;FOR DPB SWPPRV WHEN AC2 IS -1
↑SWBAND:	BLOCK BNDTSZ	;BYTE(1)LastBForJ(8)Job(9)NextBForJ(18)DiskAdr
>;IFN FTNSWP
;⊗ C1PHP C1PTP C1EXHP C1PHPU C1SNDP C1CIFI C1SNFP C1RCFP C1RMRT C1WMRT C1NOP C1CUAD C1WCHN PQUEUE PSWAPR PCURCY PTARG PACTIV PSYSBF PSYSBA NC1UP NC1RET NC1RLD NC1DED PQZEND C1CHAN C1ASAV C1ERAD C1PKSV C1DDBS C1LREC C1LSPC C1PRGS C1XPNT SNSDAT SB0SUP SB7SUP C1CCW C1ISW C1PTPE C1PTNX C1IQF C1PPTR C1PCW C1BW C1STA C1HLT C1LE C1SE C1PE C1NXM C1BPE C1SSE C1PCMA C1STB C1STC C1INST C1OVHW C1PRGL NRCCRP C1PRLU C1UDPL C1ALSV C1ADSV C1APSV C1AGSV C1BLSV C1BDSV C1BPSV C1BGSV C1SAVE HBRKPT HBRKVL F2DRED F2DCYL C1DSKA C1DSK2 F2C1PT F2DDSP F2BLTA F2BLT2 F2DCOR F2DSKA F2DCMD DSKTRY PRECAL NXTDAS DKERMS NXTDA NXTMA NXTCMD CURDA CURMA CURCMD F2PRER F2DSER F2RECT F2DAC2 F2DBF0 F2DBF1 N2DBUF N2READ N2WRIT N2PRER N2RBLT N2WBLT PACBSY LSTPAK F2DACT F2DUNF F2DERF DSKLUN ERRBIT NROVRNS NWOVRNS NRECALS

IFN NPACKS,<
↑C1PHP:	C1APH			;POINTERS TO PRG HEADERS INDEXED BY CHANNEL NUMBER
	C1BPH

↑C1PTP:	C1APT			;POINTERS TO PRG TABLES INDEXED BY CHANNEL NUMBER
	C1BPT

↑C1EXHP:TAC,,C1AEXH		;POINTERS TO EXEPECTED HALT TABLES
	TAC,,C1BEXH

IFE FTF2,<
↑C1PHPU:C1APHU			;POINTERS TO PRG HEADERS FOR UDPS INDEX BY CH NUMBER
	C1BPHU

↑C1SNDP:C1ASND			;POINTERS TO SENSE DATA
	C1BSND

↑C1CIFI:CONO C1A,C1SCH!C1CCIF		;INST TO CLEAR CIF INDEXED BY CHANNEL NUMBER
	CONO C1B,C1SCH!C1CCIF

↑C1SNFP:TAC,,C1ASNF		;POINTERS TO SENSE IN PROGRESS FLAGS
	TAC,,C1BSNF

↑C1RCFP:TAC,,C1ARCF		;POINTERS TO RECAL IN PROGRESS FLAGS
	TAC,,C1BRCF
>;IFE FTF2

↑C1RMRT:C1MRT!C1NATM!6,,0		;MRT READ COMMAND
↑C1WMRT:C1MRT!C1NATM!5,,0		;MRT WRITE COMMAND
↑C1NOP:	C1CMD!3,,C1NOC			;UNCHAINED NOP COMMAND

;TABLE OF CONTROLLER ADDRESSES INDEXED BY CHANNEL.  EACH CHANNEL IS CONNECTED TO
;A UNIQUE CONTROLLER
↑C1CUAD:CUADDR⊗4
	<CUADDR+1>⊗4

;TABLE OF WHICH DRIVE IS ON WHICH CHANNEL, 0 FOR C1A, 1 FOR C1B
↑C1WCHN:
IFE FTF2,<
	1
>;IFE FTF2
IFN FTF2,<
	0
	0
	0
IFE FTLLL,<
>;IFE FTLLL
>;IFN FTF2
IFN .-C1WCHN-NPACKS,<.FATAL GUESS WHAT YOU FORGOT TO CHANGE>

↑PQUEUE:BLOCK NPACKS		;ZERO FROM HERE TO PQZEND
↑PSWAPR:BLOCK NPACKS		;DDB FOR SWAP REQUEST
↑PCURCY:BLOCK NPACKS
↑PTARG:	BLOCK NPACKS
↑PACTIV:BLOCK NPACKS		;DDB IF PACK HAS A TRANSFER ACTIVE
IFN FTMSYSBUF,<
↑PSYSBF:BLOCK NPACKS		;DDB OF THIS PACK'S SYSBUF USER
↑PSYSBA:BLOCK NPACKS		;DISK ADDRESS REFERENCED BY DDB IN PSYSBF
>;IFN FTMSYSBUF
NC1UP:	0			;Number of times DISKUP has been called
NC1RET:	0			;Number of retries DISKUP has made
NC1RLD:	0			;Number of times DISKUP has reloaded C1 microcode
NC1DED:	0			;Number of times DISKUP gave up fixing C1
↑PQZEND::

;LOCATIONS USED AS TEMPORARIES IN C1SYNI
↑C1CHAN:0			;WHICH CHANNEL HAS THE ERROR
↑C1ASAV:0			;SAVED STAT A
↑C1ERAD:0			;SAVED STAT B OR STAT C (DEPENDS ON C1PCMA BIT)
↑C1PKSV:0			;SAVED PACK NUMBER
↑C1DDBS:0			;SAVED DDB
↑C1LREC:0			;CURRENT RECORD # TRANSFERRED IN MRT (FROM STATC)
↑C1LSPC:0			;PC FOR FIXERR (FROM STAT C)
↑C1PRGS:0			;SAVED ADDRESS OF PROGRAM HEADER
↑C1XPNT:0			;POINTER TO FIRST WCMA IN DATA CHAIN AT FIXERR
↑SNSDAT:BLOCK 6			;COPY OF CURRENT SENSE BYTES

IFN FTSBSUP,<
↑SB0SUP:20			;Hex 10 is expected value of sense byte 0
↑SB7SUP:40			;Hex 20 is expected value of sense byte 7
>;IFN FTSBSUP

;PROGRAM TABLE DEFS
↓C1CCW←←0			;RELATIVE ADDRESS OF CHANNEL CONTROL WORD
↓C1ISW←←1			;INTERRUPT SOURCE WORD
   ↓C1PTPE←←100000		;PARITY ERROR IN PROGRAM TABLE
   ↓C1PTNX←←40000		;NXM IN PROGRAM TABLE
   ↓C1IQF←←20000		;INTERRUPT QUEUE FULL
↓C1PPTR←←2			;FIRST PROGRAM POINTER

;PROGRAM HEADER AND PROGRAM
↓C1PCW←←0			;RELATIVE ADDRESS OF PROGRAM CONTROL WORD
   ↓C1BW←←100			   ;BUSY WAIT BIT IN PCW
↓C1STA←←1			;STATUS A
  ;RIGHT HALF BITS
   ↓C1HLT←←400000		;PROGRAM EXECUTED A HALT
   ↓C1LE←←200000		;LENGTH ERROR
   ↓C1SE←←100000		;SELECT ERROR
   ↓C1PE←←040000		;PARITY ERROR
   ↓C1NXM←←020000		;NXM
   ↓C1BPE←←010000		;IBM BUS PARITY ERROR
   ↓C1SSE←←002000		;SIGNAL SEQUENCE ERROR
  ;LEFT HALF BITS
   ↓C1PCMA←←100000		;1→ERROR POINTER TO BY PC, 0→POINTED TO BY MA
↓C1STB←←2			;STATUS B
↓C1STC←←3			;STATUS C
↓C1INST←←4			;FIRST INSTRUCTION OF CHANNEL PROGRAM
↓C1OVHW←←7		;PROGRAM OVERHEAD WDS (MRT CMD, JMP AT BEG,0 AT END, PDL OV)
↓C1PRGL←←C1INST+RCPBLK*BKPTRK*=10+C1OVHW	;LEAVE ROOM FOR 10 TRACK MRT
NRCCRP←←<BLKWDS+1000>/1000	;Number of records that might cross page boundary
↓C1PRLU←←C1INST+RCPTRK+NRCCRP+C1OVHW	;LEAVE ROOM FOR 1 TK (INCL RTVL) MRT
↓C1UDPL←←C1INST+<RCPTRK+NRCCRP>*TRKCYL+C1OVHW	;1 CYLINDERS WORTH

IFN FTC1BUG,<
C1ALSV:	BLOCK 10
C1ADSV:	BLOCK 100+10
C1APSV:	BLOCK C1PPTR+NPACKS+1
C1AGSV:	BLOCK NPACKS*C1INST		;PROGRAM HEADERS
C1BLSV:	BLOCK 10
C1BDSV:	BLOCK 100+10
C1BPSV:	BLOCK C1PPTR+NPACKS+1
C1BGSV:	BLOCK NPACKS*C1INST		;PROGRAM HEADERS
C1SAVE::
HBRKPT:	0
HBRKVL:	0
>;IFN FTC1BUG

IFN FTF2,<

;; Data for F2's C1 simulator
F2DRED:	BLOCK NPACKS	;Non-zero if doing a read, zero if doing a write
REPEAT 0,<	;Cylinder number not used until seek code exists.
F2DCYL:	BLOCK NPACKS	;Cylinder position of heads on each pack
>;REPEAT 0
C1DSKA:	BLOCK NPACKS	;First parameter word from current MRT being simulated
C1DSK2:	BLOCK NPACKS	;Second parameter word from current MRT being simulated
F2C1PT:	BLOCK NPACKS	;Address of next C1 data ptr word to be examined
F2DDSP:	BLOCK NPACKS	;Dispatch address upon seek or data xfer completion by pack
F2BLTA:	BLOCK NPACKS	;Address of first data ptr word for blting current read
F2BLT2:	BLOCK NPACKS	;Address of first data ptr word for blting next read/write
F2DCOR:	BLOCK NPACKS	;Core address of next xfer
F2DSKA:	BLOCK NPACKS	;Disk address (formatted for F2 controller) of next xfer
F2DCMD:	BLOCK NPACKS	;Disk command for next transfer, indicates read or write
DSKTRY:	BLOCK NPACKS	;Error retry counter for each drive
PRECAL:	BLOCK NPACKS	;Non-zero to force Recal before starting given pack
NXTDAS:	0		;Next disk address with select bit, for interrupt level
;Following four locations must be in order.
DKERMS:	0		;Error mask for special instruction (set by DISKUP)
NXTDA:	0		;Next disk address, for interrupt level
NXTMA:	0		;Next core address, for interrupt level
NXTCMD:	0		;Next disk command, for interrupt level
;Preceding four locations must be in order.
CURDA:	0		;Current disk address, for retries
CURMA:	0		;Current core address, for retries
CURCMD:	0		;Current disk command, for retries
F2PRER:	0		;Non-zero means F2 record must be pre-read before write
F2DSER:	0		;Non-zero at DERROR means this is a disk startup error
F2RECT:	0		;Count of number of times we got losing recalibrate indication
F2DAC2:	0		;Saved value of AC2 in DSKCHN fast code
F2DBF0:	BLOCK 1000	;First special buffer, length is one F2 disk record size
F2DBF1:	BLOCK 1000	;Second special buffer
N2DBUF:	0		;Number of special buffers used, low bit tells last one
N2READ:	0		;Number of F2 pages read
N2WRIT:	0		;Number of F2 pages written
N2PRER:	0		;Number of F2 pages pre-read before being written
N2RBLT:	0		;Number of F2 pages BLTed from special buffers
N2WBLT:	0		;Number of F2 pages BLTed into special buffers

;Cells from PACBSY to F2DERF are zeroed by DISKUP.
PACBSY:	BLOCK NPACKS	;Positive hung time countdown in seconds when pack busy.
LSTPAK:	0		;Number of last pack read or written
F2DACT:	0		;If non-zero, RH is drive currently reading or writing.
F2DUNF:	0		;Non-zero to flag generated interrupt for xfer done
F2DERF:	0		;Non-zero to flag generated interrupt on DSKCHN, for error
;Cells from PACBSY to F2DERF are zeroed by DISKUP.

;; Data for Foonly disk code.
DSKLUN:	0		;LOGICAL UNIT NUMBER OF DRIVE WE EXPECT TO INTERRUPT
ERRBIT:	0
NROVRNS:0		;NUMBER OF READ OVERRUN ERRORS
NWOVRNS:0		;NUMBER OF WRITE OVERRUN ERRORS
NRECALS:0		;Number of recalibrates done
;;;RCNT:	0
;DINTFG:	0

>;IFN FTF2
>;IFN NPACKS
;RH Support ;⊗ MTAN BUGPLN CHNN RHDTWC RHDTWO RHDTRO RHDRWO RHDRRO RHDDWO RHDDRO TODCLK WREQ MTAJB0 PSKED FACTSW JB0FLG MTPSFK MTCUTB PHYPZS MTINDX PWRDWN DSPSFK PHYTIM CHNTAB MAXCHN PHYSEC ZSEND VSMFLG CTYLNO LSTERR NSKED PHYARG PHYAR2 LPHIPD LPHYPD UIOLST UDIORB PHYACS PHYIPD PHYPDL PHYSVP CHBUDB CHBODT CHBLUC CHBIRB CHBCCL CHBHB1 CHBHB2 BUGHLT BUGCHK BUGINF BUGACS BUGACU BUGPDL BUGLCK BUGNUM PRSNUM FSIPPA FSIPPG IRTNP DMXQTM DMXQWC RHDDBQ RHDQTB RHDQTX

IFN FTRH,<
MTAN==MTUNUM		;number of magtape units supported by software
IFLE MTAN,<MTAN==1>	;must be positive
BUGPLN==50		;stack length of the bug pdl
CHNN==10		;Number of RH20 massbus controllers in system (max)

RHDTWC:	0	;RH Disk Total Word Count
RHDTWO:	0	;RH Disk Total Write Op
RHDTRO:	0	;RH Disk Total Read Op
RHDRWO:	0	;RH Disk Retrieval Write Operations
RHDRRO:	0	;RH Disk Retrieval Read Operations
RHDDWO:	0	;RH Disk Data Write Operations
RHDDRO:	0	;RH Disk Data Read Operations

TODCLK:	0
WREQ:	0
MTAJB0:	0
PSKED:	0
FACTSW:	0
JB0FLG:	0
MTPSFK:	0
MTCUTB:	BLOCK MTAN		;Magtape CDB,,UDB index by logical unit number
PHYPZS:	BLOCK 100
MTINDX:	0
PWRDWN:	0
DSPSFK:	0
PHYTIM:	0
CHNTAB:	BLOCK	CHNN	;one entry per 'channel' (Massbus controller)
MAXCHN:	0
PHYSEC: 0
ZSEND:	0
VSMFLG:	0
CTYLNO: 0
LSTERR::0
NSKED::	0

PHYARG:	0			;These two together.  remembered args to
PHYAR2:	0			;PHYSIO called from CH6.

Intern LPHIPD,LPHYPD
LPHIPD==120				;Length of interrupt level stack
LPHYPD==55				;Length of UUO level local stack for PHYSIO
UIOLST:	0
UDIORB:	BLOCK	170
PHYACS:	BLOCK	20
PHYIPD:	BLOCK	LPHIPD			;Interrupt-level stack for PHYSIO
PHYPDL:	BLOCK	LPHYPD			;UUO-Level stack for PHYSIO
PHYSVP:	0				;Save P upon PHYSIO entry
CHBUDB:	0
CHBODT:	0
CHBLUC:	0
CHBIRB:	BLOCK	6
CHBCCL:	BLOCK	2
CHBHB1:	BLOCK	176
CHBHB2:	BLOCK	2

;BUG stuff
BUGHLT:	0
	JRST	BUGH0		;in PHYDAT

BUGCHK:	0
BUGINF:	0

BUGACS:	BLOCK	20		;Bughalt ACs.
BUGACU:	BLOCK	20		;previous context ACS
BUGPDL:	BLOCK	BUGPLN
BUGLCK:	-1
BUGNUM:	0


;Storage for RH based file system
PRSNUM:	0			;number of the primary structure
FSIPPA:	0			;page number of physical page for CHKHOM
FSIPPG:	0			;address of physical page for CHKHOM
IRTNP:	0			;P for PHYSIO return
DMXQTM:	BLOCK 2			;Longest duration transfer
DMXQWC:	0			;WC corresponding to longest duration Xfer.

Intern MTAN,BUGPLN,CHNN,TODCLK,WREQ,MTAJB0,PSKED,FACTSW,JB0FLG
Intern MTPSFK,MTCUTB,PHYPZS,MTINDX,PWRDWN,DSPSFK,PHYTIM,CHNTAB,MAXCHN,PHYSEC
Intern ZSEND,VSMFLG,CTYLNO,LSTERR,NSKED
Intern UIOLST,UDIORB,PHYACS,PHYPDL,PHYSVP,PHYIPD,CHBUDB,CHBODT,CHBLUC,CHBIRB,CHBCCL
Intern CHBHB1,CHBHB2,BUGHLT,BUGCHK,BUGINF,BUGACS,BUGACU,BUGPDL,BUGLCK,BUGNUM
Intern PRSNUM,FSIPPA,FSIPPG,NSSUN,FSSUN,IRTNP
INTERN PHYARG,PHYAR2

INTERN FSGET
Extern BUGH0

Intern DMXQWC,DMXQTM
INTERN RHDDBQ,RHDQTB,RHDQTX
RHDDBQ:	RHDQTB-1
RHDQTB:	BLOCK	100
RHDQTX==.


>;IFN FTRH
;⊗ DTEINX KLTINX KLCLKF KLECON KLPCON KLITCN SCTERR KLTIME EPDLOV ETRPAC ETRPDL ETRPD PFPARF PFTAC SVPFPC SVPFW SVPFFG KLTPC KLTPCF RLOD11 KLPDL KLPD KLLUUT KLLUUB

IFKL10,<
SUBTTL	KLDAT	DATA AREA FOR KLSER	;REG 5/1/76

DTEINX:	0				;VECTORED INTERRUPT JSRs TO HERE.
	CLRPCP
	JRST	DTEINT

KLTINX:	0				;VECTORED INTERRUPT FROM INTERVAL TIMER
	CLRPCP
	JRST	KLTINT

KLCLKF:	0				;SET TO -1 FOR "CLOCK TICK"
KLECON:	0				;SIMULATED CONI BITS
KLPCON:	0				;USUAL CONO BITS FOR KLPAG (660000+KLEPT⊗-9)
KLITCN:	0				;CLOCK TICK PHASE. TWO LONGS AND A SHORT
IFN FTKLB,<
SCTERR:	0				;PC sector number of last error in KLEINT
>;IFN FTKLB

KLTIME:	BLOCK	2			;DOUBLE WORD TIMEBASE FROM PDP-11

EPDLOV:	0				;EXEC MODE PDLOV
	JRST	EPDLV1

ETRPAC:	BLOCK	20
ETRPDL:	-100,,ETRPD-1
ETRPD:	BLOCK	100

PFPARF:	0				;FLAG TO CHANNEL 3 FOR AR/ARX PARITY ERROR
PFTAC:	0				;SAVED TAC AT BEGINNING OF PAGE FAULT
SVPFPC:	0				;SAVED PAGE FAULT PC
SVPFW:	0				;SAVED PAGE FAULT WORD
IFN FTKLB,<
SVPFFG:	0				;SAVED PAGE FAULT PC FLAGS
>;IFN FTKLB

KLTPC:	0				;PC SAVED HERE BY KLEINT FOR CH7
KLTPCF:	0				;FLAG THAT KLEINT WANTS CH7 TO USE KLTPC

RLOD11:	0		;NON-ZERO IF DTELOD UUO IS RELOADING THE 11, SEE DTEXX

KLPDL:	-100,,KLPD-1
KLPD:	BLOCK 100

IFE PRCONF-2,<				;IF KA IS P2, P1 NEEDS TO SETUP LUUO TRAP
KLLUUT:	0				;LOCATION 40 CONTAINS JSR KLLUUT
	JRST	KLLUUO
>;PRCONF=2

IFN FTKLB,<
KLLUUB:	BLOCK 3		;block for user LUUO from nonzero section
	KLUUON		;new PC for such LUUO (should never happen)
>;IFN FTKLB
>;IFKL10
;⊗ mtrlst mtrptr MTRLNK MTRDAT MTRVAL MTRTOT MTRCNT MTRREC MTRTMP MTRNUT MTRNUR MTRNUP MTRNUL MTRLNK MTRDAT MTRVAL MTRTOT MTRCNT MTRREC MTRTMP MTRNUT MTRNUR MTRNUP MTRNUL MTRSIZ MTRSWP MTRSHF MTRWST MTRCST MTRMAP MTRNXT MTRPWT MTRXWT MTRWSC MTRSPR CH3MSV CH4MSV CH5MSV CH6MSV CH7MSV MTCSHX MTRJBP MTRCNM MTRCNW MTRPTR MTRCOD MTRJOB MTRNSC MTRBKG MTRDS2 MTRDS3 MTRDTN MTRDSK MTRDS1 MTRLST

IFKL10,<

;MTRDAT - DATA AREA FOR PERFORMANCE ANALYSIS METER SERVICE

COMMENT ⊗

The performance metering can be operated in two modes: user and background.
In user mode the meter is under the control of a system program while in
background mode it takes a fixed set of statistics as assembled in below.
The background mode is further divided into things that can be metered with
the help of "microcode state 1" and those that cannot.  For those that use it
there is a set of macros called MTRON and MTROFF which are inserted in the
code in the system that is being metered.

The data structure is:
mtrlst:	pointer to head of list of meter blocks
mtrptr:	pointer to current meter block
a meter block looks like:
MTRLNK:	link		(1 word) to next meter block.  zero for end of list.
				left half is stored in MTRCNM.
MTRDAT:	datum		(1 word) for BLKO TIM, i.e., the thing to measure
MTRVAL:	last val	(2 words) last BLKI TIM for standard period
MTRTOT:	cumulative val	(2 words) sum of all previous BLKI TIMs for this block
MTRCNT:	val count	(1 word)  number of previous values
MTRREC:	recent past	(2 words) total of some 64 recent samples
MTRTMP:	more recent 	(2 words) accumulates 64 samples for MTRREC
MTRNUT:	# of MTRONs 	(1 words) counted each time SETUS1 is done (total)
MTRNUR:	# of MTRONs 	(1 words) counted each time SETUS1 is done (recent)
MTRNUP:	# of MTRONs 	(1 words) counted each time SETUS1 is done (temp recent)
MTRNUL:	# of MTRONs 	(1 words) counted each time SETUS1 is done (last)

The reason the list is linked is because someday a UUO will allow meter requests
to be added to the list.  New meter blocks in free storage could be added.

⊗


MTRLNK←←0
MTRDAT←←1
MTRVAL←←2
MTRTOT←←4
MTRCNT←←6
MTRREC←←7
MTRTMP←←11
MTRNUT←←13
MTRNUR←←14
MTRNUP←←15
MTRNUL←←16
MTRSIZ←←17		;SIZE OF A METER BLOCK


;TYPES OF THINGS METERED BY MICROCODE STATE 1
MTRSWP←←1			;WAIT FOR CACHE SWEEP
MTRSHF←←2			;TIME DURING SHUFFLE
MTRWST←←3			;WASTED TIME
MTRCST←←4			;TIME DURING "CSHSET" ROUTINE
MTRMAP←←5			;TIME DURING APRMAP
MTRNXT←←6			;TIME DURING NXTJOB
MTRPWT←←7			;TIME DURING PWAIT
MTRXWT←←10			;TIME DURING XWAIT
MTRWSC←←11			;TIME DURING WSCHED
MTRSPR←←12			;SPARE FOR PATCHING

IFE FTMTRACT,<
CH3MSV:	0
CH4MSV:	0
CH5MSV:	0
CH6MSV:	0
CH7MSV:	0

MTCSHX:	142000,,		;TURN ON BIT IF CHANNEL HAS CACHE HIT METERING CODE
MTRJBP:	0			;PERF COUNTER BLKO WHEN MTRJOB SET UP
>;IFE FTNTRACT

MTRCNM:	0			;index for last microcode-state-1 event begun
MTRCNW:	0			;index of m-s-1 event, if any, now being monitored
MTRPTR:	0			;POINTS AT CURRENT METER BLOCK

;KEEP THESE IN ORDER FOR THE "METER" PROGRAM:

IFE FTMTRACT,<
MTRCOD:	0			;METER IS IN "CODE" MODE	MTRLST-14
MTRJOB:	0			;JOB TO METER			MTRLST-13
MTRNSC:	0			;COUNTED AT WSCHED FOR METERED JOB (MTRJOB)
>;IFE FTMTRACT
MTRBKG:	-1			;SEE COMMENT IN KLSER		MTRLST-11
MTRDS2:	0			;MAX TIME SPENT IN D2INT	MTRLST-10
MTRDS3:	0			;D2X CORRESPONDING TO MTRDS2	MTRLST-7
MTRDTN:	BLOCK 2			;TEMP CELLS FOR D2INT=TIMEBASE	MTRLST-6
MTRDSK:	BLOCK 2			;CUMULATIVE D2INT TIME		MTRLST-4
MTRDS1:	BLOCK 2			;1 SAMPLE OF D2INT TIME		MTRLST-2
MTRLST:	.+MTRSIZ		;HEAD OF METER REQUEST LIST
	1502,,777200		;THIS IS SUPPOSED TO COUNT EVERYTHING
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,400200		;CHANNEL 0
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,200200		;CHANNEL 1
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,100200		;CHANNEL 2
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,040200		;CHANNEL 3
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,020200		;CHANNEL 4
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,010200		;CHANNEL 5
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,004200		;CHANNEL 6
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,002000		;CHANNEL 7
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,001000		;NO PI, EXEC MODE (UUO)
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1502,,001400		;NO PI, USER MODE (USER CODE)
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1534,,777200		;EBOX TIME WAITING FOR MEMORY
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1554,,777200		;EBOX TIME WAITING BECAUSE OF CACHE MISS
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1564,,777200		;EBOX WAITING BECAUSE OF E BOX INDUCED WRITEBACK
	BLOCK MTRSIZ-2
	.+MTRSIZ
	1570,,777200		;EBOX WAITING BECAUSE OF SWEEP WRITEBACK
	BLOCK MTRSIZ-2
	MTRSWP,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - SWEEP WAIT
	BLOCK MTRSIZ-2
	MTRWST,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - WASTED TIME
	BLOCK MTRSIZ-2
	MTRSHF,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - SHUFFLE
	BLOCK MTRSIZ-2
	MTRCST,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - CSHSET
	BLOCK MTRSIZ-2
	MTRMAP,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - APRMAP
	BLOCK MTRSIZ-2
	MTRNXT,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - NXTJOB
	BLOCK MTRSIZ-2
	MTRPWT,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - PWAIT
	BLOCK MTRSIZ-2
	MTRXWT,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - XWAIT
	BLOCK MTRSIZ-2
	MTRWSC,,.+MTRSIZ
	1102,,777200		;MICROCODE STATE 1 - WSCHED
	BLOCK MTRSIZ-2
	MTRSPR,,0
	1102,,777200		;MICROCODE STATE 1 - SPARE
	BLOCK MTRSIZ-2
>;IFKL10
;⊗ DISNOP DPYHDR BUFL ZZQ MAXPT RDPYLN

SUBTTL III AND DATA DISC DATA STORAGE

IFE FTF2,<	;NOTE: LINED AND WHOSER USE A DIFFERENT NO-OP!!
DISNOP←←14	;ACTUALLY RST, BUT A GOOD NOP WITH ALL BITS OFF.
>;IFE FTF2

COMMENT ⊗   NOW THE DPY PROGRAM HEADERS.  
 THERE IS ONE OF THESE FOR EACH DPY PROGRAM
 IN EXISTENCE; IN GENERAL, ONE FOR EACH CONSOLE PLUS
 ONE FOR EACH DETACHED JOB DOING DPY OUTPUT. THE HEADERS
 AND THE START,RESTART, AND STOP TABLES ARE THE ONLY PARTS
 OF THE WHOLE INCREDIBLE DPYSER DATA STRUCTURE WHICH DO NOT
 GO IN FREE STORAGE.
DPYHDR:	LABEL FOR NDFAIL
⊗

↑BUFL←←40		; EDITING BUFFER IS THIS MANY WORDS LONG
		ZZQ←←.
		DEFINE Z(FOO){↑FOO←.-ZZQ
}		
 	
		XWD .+4,DISRST+40
			;PRGM. NORMALLY STARTED HERE. 
			;  RESTORE PRIOR STATE OF DP.
Z(PSELC←)	BYTE (12),7777,DISSEL		;FIRST DESELECT ALL CONSOLES
Z(PSELA←)	BYTE (12)1⊗(=11-0),,DISSEL	;THEN RESTORE OLD SELECTION
Z(PRGSTP←)	0	;PRGM IS STOPPED BY A JMS TO HERE.
Z(PRGSAV←)	0	;DISRST uses this word to restore position
Z(WHOCALL←)	DISNOP	;CALL WHO LINE(IF ANY).
Z(PPCALL←)	DISNOP	;HERE IS A JMP TO PAGE 0 OF PP.
Z(LEDPOS←)	DISNOP	;HERE WE SET UP LINE EDITOR POSITION AT END OF CURRENT PP
Z(LEPOS←)	DISNOP	;HERE WE SET UP LINE EDITOR POSITION FROM LEYPOS UUO
Z(LEJMS←)	XWD ZZQ+LEB,DISJMS	;CALL THE LINE EDITOR.
Z(PGCALL←)	DISNOP	;HERE A JMP TO PIECE OF GLASS CONT. BLK.
		0	;HERE PRGM NORMALLY HALTS.
Z(PSELB←)	BYTE (12)1⊗(=11-0),¬(1⊗(=11-0)),DISSEL
			;ANOTHER COPY OF SELECT WORD. PRGM RESTARTS HERE.
Z(RTJMP←)	XWD WHOCALL+ZZQ,DISJMP

IFN FTGRIN,<
Z(PGFLAG←)	0	; FLAGS FOR XFR - SAYS WHAT KIND OF PROGRAM IT IS ETC
Z(PGUUO←)	0	; SAVED COPY OF UPGIOT UUO (CLOBBERED IN SPCCHK)
>;IFN FTGRIN
Z(PRGNUM←)	0	;DD channel,,TTY line number
Z(BLKTOT←)	-7	;NO. OF BLOCKS OF STORAGE HE CAN USE.
Z(CURPP←)	0	;PTR. TO CTRL. BLK. OF SELECTED P OF P.
Z(CURPG←)	0
Z(PRGACT←)	400000	;BITS TELL STATE OF ACTIVATION OF P OF P'S.
Z(USRACT←)	0	;SAVED VERSION OF PRGACT.
Z(LSTPG←)	0	;HIGHEST PG IN USE BY USER.
Z(LECLIN←)	0	; FLAG THAT SAYS THIS BLOCK HAS A CLOCK REQUEST IN TO HAVE ITSELF KILLED, WHEN IT BECOMES FREE
Z(DPRLSF←)	0	; FLAG THAT SAYS THIS PROGRAM HEADER BELONGS TO A DETACHED JOB AND IS TO BE RELEASED
Z(PRGCW←)	0	; COMMAND WORD FOR USER GRAPHICS TRANSFERS
Z(PRGJMP←)	0	; JUMP TO USER PROGRAM
Z(PRGCNT←)	0	; DUMMY COUNT WORD
Z(DPHOLD←)	0	; -1 IF HOLDING
Z(GWORD←)	0	; GARBAGE WORD. HOLDS EVERYTHING WHAT WON'T FIT ELSEWHERE
			; B0 1-PAGE PRINTER SIZE SET LAST BY CONSOLE COMMAND, 0-BY UUO
			; B1 SAME FOR PAGE PRINTER Y-POSITION.
			; B2 SAME FOR LINE HOLD COUNT
			; B3 SAME FOR GLITCH HOLD COUNT
			; B9-17 LINE HOLD COUNT
			; B18-26 GLITCH HOLD COUNT
			; B27-35 CHAR WHICH ACTIVATED LINED
Z(LHCNT←)	0	; LINE HOLD COUNTDOWN, HOLD WHEN NON-POSITIVE
Z(GLHCNT←)	0	; GLITCH HOLD COUNTDOWN, HOLD WHEN EXACTLY ZERO
Z(LEB←)

		0	;DP DOES A JMS TO HERE TO DISPLAY EDITOR BUFFER.
		0
Z(LEPPV←)	0	;POINTER POSITION VECTOR FOR EDITOR POINTER.
Z(III←)		LVW (-5,-14)	;(WILL BE 0 ON DD, DM) DRAW THE POINTER.
Z(VDTMP←)	LVW (12,0)	;TEMP MAPPING STORED HERE ON DD
Z(PPHPOS←)	LVW (-5,14)	;USED AS TEMP FOR DD CURSOR ROUTINES
		XWD ZZQ+LEB+1,DISRST+40 ;RESTORE BEAM POSTION.
Z(LELMAR←)	LVW(0,0,I) ;LEFT MARGIN VECTOR... USED FOR SHIFTING LONG LINES.
Z(LEBUF←)	REPEAT BUFL,<XWD ZZQ+LEB,DISJMP> ;THE EDITOR BUFFER.
↑MAXPT←←LEBUF+BUFL-1-3	;MAXIMUM RELATIVE VALUE OF LELWD (I.E., END OF BUFFER).
			;THE SPARE THREE WORDS OF BUFFER AFTER MAXPT ALLOW FOR
			;INSERTION OF (1) A TAB REPRESENTED AS TWO TABS WITH
			;8 SPACES BETWEEN AND (2) A "LONG-LINE" CRLF WITH ITS
			;SURROUNDING TABS, FOR A TOTAL OF 14 CHARS USED OUT OF
			;THE 3*5=15 7-BIT BYTES AVAILABLE BEYOND MAXPT.
z(ledmz←)  0  	;demilitarized zone, for catching bugs of overflow from LEBUF
Z(LEHPOS←)	0	;HORIZONTAL POSITION OF POINTER (IN COLUMNS).
Z(CCPOS←)	0	;LOGICAL POSITION OF POINTER, IN CHRS. FROM START OF LINE.
Z(FCPOS←)	0	;NO. OF CHRS. IN LINE.
Z(LELWD←)	0	;POINTER TO LAST WORD OF BUFFER IN USE (ONE BEFORE THE RETURN JMP).
Z(LSTHP←)	0	; SAVED HORIZONTAL POSITION
Z(LEENQ←)	0	; NUMBER OF LINE EDITOR TASKS IN THE QUEUE
Z(LEENQ2←)	0	; NUMBER OF SCREEN REFRESH AND/OR HELP TASKS IN QUEUE.
Z(LECHPS←)	0	; SAVED VALUE OF HORIZONTAL POSITION
Z(NUMARG←)	0	;REPEAT ARGUMENT.
Z(LEARG←)	0	; REPEAT ARGUEMENT SAVED FOR <ESC>G COMMAND AND ITS FRIENDS
Z(LESVCH←)	0	;SAVED CHAR & FLAG FOR CTRL R (REPEATS LAST SEARCH OR KILL)
Z(LEPNT1←)	0	;BYTE POINTER CORRESPNDING TO EDITOR POINTER.
Z(SVPNT1←)	0	;SAVED COPY OF LEPNT1 FOR PARTIAL LINE EDITOR ACTIVATION
Z(NTABPT←)	0	;BYTE PTR. TO NEXT TAB IN LINE TO RIGHT OF CURRENT POS.
Z(NTABCT←)	0	;NUMBER OF SPACES IN NEXT TAB.
Z(NTABHP←)	0	;HORIZONTAL POSITION OF NEXT TAB, FOR FIXING THAT TAB ON DMS
Z(LEACT←)	0	; LINE EDITOR TELLS DPYKILL THAT A CHARACTER HAS BEEN TYPED HERE
Z(LEINV←)	0	; MEANS LINE EDITOR BUFFER IS NOW INVALID
Z(LEWAKE←)	0	; THIS IS SET BY A TRANSFER THAT IS ABORTED BECAUSE OF INVALID BUFFER
Z(NCRS←)	0	; NUMBER OF LONG-LINE CRLFS IN LINE
Z(LEVP←)	0	; VERTICAL POSITION OF LINE EDITOR LAST TIME IT WENT OUT
Z(LEHP←)	0	; HORIZONTAL POSITION OF LINE EDITOR
Z(LENCRS←)	0	; NUMBER OF LINES IT TOOK LAST TIME IT WENT OUT.
Z(LECVP←)	0	; LAST CURSOR VERTICAL POSITION
Z(LECHP←)	0	; LAST CURSOR HORIZONTAL POSITION
Z(LECLK←)	0	; MEANS CLOCK REQUEST IS IN
Z(LETXC←)	0	; MEANS LINE EDITOR TEXT HAS CHANGED
Z(LEMISS←)	0	; INDICATES A TRANSFER MISSED DUE TO BUFFER INVALID
Z(LECC←)	0	; SAYS WHETHER AN <ESC>C HAS BEEN TYPED
Z(LELINE←)	0	; LINE NUMBER OF LINE EDITOR
Z(CVP←)		0	; CURRENT CURSOR VERTICAL POSITION
Z(CHP←)		0	; CURRENT CURSOR HORIZONTAL POSITION
Z(WHOTAB←)	0	; WHO LINE TIME,,JOB #
Z(WHORUN←)	0	; TIME WHEN RUN TIME SHOULD BE UPDATED ON WHO LINE
Z(NPPXFR←)	0	; NUMBER OF PP TRANSFERS IN PROGRESS, USED BY PPWAIT
Z(JPPWAT←)	0	; NUMBER OF JOB WAITING FOR NPPXFR TO GO TO ZERO

;Here are the cells created for DMs
Z(DMQKCT←)	0	; Count of number of quicky char waiting for output on DM
Z(DMQKPT←)	0	; Byte pointer used to pick up quicky chars
Z(DMQKBF←)	BLOCK 14 ; Buffer for holding DM quicky chars
Z(UCOUNT←)	0	; <Job>,,<Run flag addr> for clearing User DM prog run flag
Z(DMLEPT←)	0	; Header of queue of Line Editor incremental xfers
Z(DMSPPT←)	0	; Header of special queue (holding/unholding, tab-setting)
Z(DMPPPT←)	0	; Header of queue of Page Printer xfers
Z(DMUSER←)	0	; Header of queue of User display program xfers
Z(DMWHO←)	0	; Header of queue of Wholine xfers
Z(DMFLAG←)	0	; Flag word for actual state of DM display
Z(DMXY←)	0	; Actual X-Y position of DM cursor
Z(DMLEXY←)	0	; X-Y position for next LE char output
Z(DMFS←)	0	; Pointer to free storage block for holding copy of LEBUF
Z(DMCLK←)	0	; -1 if clock request in for DMLED0 waiting for FS
Z(DMLEFL←)	0	; LH has DM state flags for line editor
Z(DPTYCL←)	0	; -1 if clock request for DPYTYP is already in for DM
Z(DMUSXY←)	0	; User-specified X-Y position for cursor when LE empty
IFN FTRANGE,<
Z(DMBEG←)	0	; Beginning col for user output
Z(DMEND←)	0	; Ending col for user output
>;FTRANGE
Z(LEYVAL←)	0	; Line editor position set by LEYPOS UUO

Z(NEVECT←)	BLOCK 15 ; Dispatch for variable (macro) characters.

Z(DPYHGT←)	HGTIII	; Number of lines on display's screen (valid for all dpys)
Z(DPYWID←)	LINELN	;Number of columns of text on display's screen

Z(RPTSIZ←)	0	;NUMBER OF BYTES IN REPEATING OUTPUT STRING FOR DM
Z(RPTPTR←)	0	;BYTE POINTER TO BEGINNING OF REPEATING STRING
Z(RPTCNT←)	0	;COUNTDOWN TO END OF REPEATING STRING
Z(DPYBTS←)	0	;BITS TO DESCRIBE THE DISPLAY TERMINAL--SEE VDPSER

Z(LETBPT←)	0	;PTR. TO THE LETAB ENTRY FOR THIS DPY.
			; SIGN BIT ON IF VDSMAP TEMP IN EFFECT
Z(LCH←)		0	;
IFN FTGRIN,<
Z(DCHWID←)	0	;Character width in pixels, including character spacing
Z(DCHHGT←)	0	;Character height in scanlines, including spacing
>;IFN FTGRIN
IFN FTVBEEP,<
Z(VBEEP←)	0	;Count down for complimenting WHO line
>;IFN FTVBEEP
Z(DPYLEN←)
↑RDPYLN←←<<DPYLEN+1>!7>+1 ;Real size of FS block for dpy hdrs

ORG ZZQ			; DON'T LOSE ANY STORAGE OVER THESE DEFINITIONS
;⊗ IIIOFF DRUNCT SAVTAC DPCNI LCPDL SVDPDT BUGDPL DPYPDL CLKPD CLKQUE CLKQ WTFLG SVAC DPYMAP NBS NBS TBL ERRP FREEHD FSWTHD FSWT2H FREEC FREETL FRETOT FSWC CLKLVL CLKQTMP FSW2C NDPMAK DPYMF1 DPYMF2 NREDET MACROC MACROP

↑IIIOFF:	0	;SET TO -1 TO PREVENT SYSTEM FROM RUNNING III
↑DRUNCT:	0	; NUMBER OF CURRENTLY RUNNING DISPLAY
↑SAVTAC:	0	; DPY NUMBER DURING ERROR TYPEOUT
↑DPCNI:		0	; DP CONI BITS
↑LCPDL←←CLKPLN		;LENGTH OF CLOCK PUSHDOWN LIST.
↑SVDPDT:	0	;*****SAVED DAT FOR DPYPDL BUG TRAP
↑BUGDPL:	0	;*****SAVED DPYPDL AT ENTRY TO DPYCLK
↑DPYPDL:	-LCPDL,,CLKPD-1
			;SPECIAL CLOCK LEVEL PDL.
↑CLKPD:		BLOCK LCPDL+1
		0
↑CLKQUE:	BLOCK 6*<DPYNUM+DDNUM>
IFN FTF2,<	BLOCK 600
>;IFN FTF2

↑CLKQ:		POINT 36,CLKQUE-1,35
			;MAIN PTR. TO CLK QUE.

↑WTFLG:		0	;IF -1, WE ARE SUSPENDING NORMAL CLK. SERVICE TO WAIT FOR FREE STG.

↑SVAC:		BLOCK 20
↑DPYMAP:	BLOCK JOBN
IFE FTGRIN,<
↑NBS←←=100
>;IFE FTGRIN
IFN FTGRIN,<
;;;↑NBS←←=500	; THESE THINGS CAN GET QUITE BIG
↑NBS←←=250	; THESE THINGS CAN GET QUITE BIG
>;IFN FTGRIN
↑TBL:		BLOCK NBS+1
			; PLACE TO BUILD BLOCK MAP FOR UPGMOVE
↑ERRP:		0	; ROUTINE THAT IS ENTERED WITH A JSA
		JRST ERRP2
↑FREEHD:	0
↑FSWTHD:	0
↑FSWT2H:	0
↑FREEC:		0
↑FREETL:	0
↑FRETOT:	0
↑FSWC:		0
↑CLKLVL:	0	; SAYS WE ARE AT CLOCK LEVEL
↑CLKQTMP:	0	; TEMP CELL
↑FSW2C:		0
↑NDPMAK:	0	; NUMBER OF TIMES WE HAD TO DO MAKE DPY HDR AT DPYTYP
↑DPYMF1:	0	;NUMBER OF TIMES DPYMAKE FAILED BECAUSE NO DPY HDR FS
↑DPYMF2:	0	;NUMBER OF TIMES DPYMAKE FAILED BECAUSE NO PP FS
↑NREDET:	0	;NUMBER OF TIMES HAD TO RETRY DETACH UPON TTY HANGUP

↑MACROC:	0	; NUMBER OF CHARS TO PROCESS IN CHAR MACRO (ZERO OTHERWISE)
↑MACROP:	0	; BPT TO MACRO CHARACTER STRING
;⊗ DDSTART DDCNT DDDSP DDRET DDRTN DDSAC1 DDSAC2 DDSAC3 DDSTAC DDSDAT NDDILL DDNXT DDCUR DDCURT DDCURQ DDCOL DDLST DDOFF DDQUE DDSQ DDLFD DDTYPE DDNBR DDTOT DDMAX DDREST GRNGEN GFIII GIII GDD GENX GNOSP GDARK GDHEI GDWID GTEXT GADD GDDSR GARG GSEA GSEB GSEC GSLA GSLB GSLC GIDSP GRNADR GRTN GTMO GCOM GTMP GCTMP G177 GPTR GCCNT GOFF GMASK GRNCHG GXPOS GYPOS GLMODE GSETCM GVECS GLLUM GLLWM GSENDX GNEEDC

IFN FTGRIN!FTDD,<	;Whole page

;III, DATA DISC, AND DATAMEDIA DATA STORAGE

↑DDSTART:	0	; UUO LEVEL SETS THIS TO START UP DD. SEEN BY APRINT.
↑DDCNT:		3B2	; NUMBER OF TIX THIS PROGRAM IS ALLOWED TO RUN BEFORE IT IS TIMED OUT.
↑DDDSP:		0	; THIS IS THE I-LEVEL DISPATCH ADDRESS.
IFN FTDD,<
↑DDRET:		0	; WE JUMP INDIRECT HERE TO RETURN FROM I-LEVEL
↑DDRTN:		0	; EVERYONE JSRS HERE TO RETURN
		JRST @DDRET
↑DDSAC1:	0	; ACCUMULATORS . . .
↑DDSAC2:	0
↑DDSAC3:	0
↑DDSTAC:	0
↑DDSDAT:	0
↑NDDILL:	-1	; count of times at DDILL in DPYSER (unexpected DD int)
>;IFN FTDD
↑DDNXT:		0	; ADDRESS OF NEXT TASK TO BE DONE
↑DDCUR:		0	; DATA BLOCK ADDRESS CURRENTLY IN USE
↑DDCURT:	0	; TASK BLOCK ADDRESS CURRENTLY IN USE
↑DDCURQ:	0	; THIS IS WHERE I-LEVEL PUTS THE CONTROL BLOCK ADDRESS BEFORE DISMISSING
↑DDCOL:		0	; HERE WE KEEP COLUMN ADDRESSES
↑DDLST:		0	; ADDRESS OF LAST FRAME LOOKED AT
↑DDOFF:		0	; SET TO -1 TO INHIBIT DD TRANSFERS
↑DDQUE:		0	; HERE LIES THE DATA DISC QUEUE
↑DDSQ:		0	; WE SAVE THE ENTIRE TASK QUEUE HERE
↑DDLFD:		0	; WE SAVE THE FIELD WORD OF THE LAST FRAME HERE.
↑DDTYPE:	0	;TYPE OF CURRENTLY RUNNING DD TASK
↑DDNBR:		BLOCK NDDTYP	;NUMBER OF TASKS STARTED, PER TYPE
↑DDTOT:		BLOCK NDDTYP	;TOTAL TICKS BEFORE TASK STARTED, PER TYPE
↑DDMAX:		BLOCK NDDTYP	;MAXIMUM TICKS BEFORE GIVEN TASK STARTED, PER TYPE
↑DDREST:	BLOCK NDDTYP	;TOTAL UNUSED TICKS FOR ALL TASKS, PER TYPE

IFN FTGRIN,<
↑GRNGEN←←4000+1⊗(7-GRNCHN)	; CONO PI,GRNGEN GENERATES AN INTERRUPT
↑GFIII:	0		; 0 = NO III DONE YET, -1 = SOME III DONE NOW
↑GIII:	0		; -1 = SIMULATING III DISPLAY
↑GDD:	0		; -1 = SIMULATING DD DISPLAY
↑GENX:	0		; DD SIM - ERASE NEXT CHANNEL SELECT
↑GNOSP:	0		; DD SIM ≠0 MEANS CHRS ARE OVERSTRUCK
↑GDARK:	-1		; DD SIM ≠0 MEANS DARK BACKGROUND
↑GDHEI:	0		; DD SIM ≠0 MEANS DOUBLE HEIGHT
↑GDWID:	0		; DD SIM ≠0 MEANS DOUBLE WIDTH
↑GTEXT:	0		; DD SIM ≠0 MEANS GRAPHIC MODE
↑GADD:	0		; DD SIM ≠0 MEANS ADDITIVE GRAPHICS
↑GDDSR:	0		; DD SIM - RETURN ADDRESS
↑GARG:	0		; DD SIM - SAVED ARGUMENT OVER SCHEDULING
↑GSEA:	0		; GRN SIM - EA REGISTER
↑GSEB:	0		; GRN SIM - EB REGISTER
↑GSEC:	0		; GRN SIM - EC REGISTER
↑GSLA:	0		; GRN SIM - LA REGISTER
↑GSLB:	0		; GRN SIM - LB REGISTER
↑GSLC:	0		; GRN SIM - LC REGISTER
↑GIDSP:	0		; RETURN ADDRESS FROM ISYNC
↑GRNADR:0		; ADDRESS OF PROGRAM
↑GRTN:	0		; -1 MEANS MAKEV RETURNS TO GSHV RATHER THAN GRNLOP
↑GTMO:	0		; MEANS INTERFACE TIMED OUT
↑GCOM:	0		; NEXT COMMAND TO GO OUT
↑GTMP:	0		; TEMP TO SAVE OVER INTERRUPT DISMIS
IFN FTSIMCHR,<
↑GCTMP:	0		; TEMP FOR CHR GENERATOR
Printx Flush GCTMP when Grinnell gets chr PROMs
>;IFN FTSIMCHR
↑G177:	0		; -1 IF LAST CHR WAS 177
↑GPTR:	0		; BYTE POINTER FOR CHARACTER HANDLER
↑GCCNT:	0		; 5 COUNT FOR ASCII WORD HANDLER
↑GOFF:	400		; OFFSET FOR CENTER ORIGIN - 1000 FOR 1024X SYSTEM
↑GMASK:	777		; MASK FOR COORDINATES - 1777 FOR 1024X SYSTEM
↑GRNCHG:=12		; CHARACTER HEIGHT - =14 FOR 1024X SYSTEM
↑GXPOS:	0		; CURRENT X COORDINATE
↑GYPOS:	0		; CURRENT Y COORDINATE
↑GLMODE:0		; LAST MODE WORD THAT WENT OUT
  ↑GSETCM←←1		; TEXT MODE
↑GVECS:	0		; VECTOR MODE HAS CLOBBERED EB AND LB REGISTERS
↑GLLUM:	0		; LAST "LOAD UPDATE MODE" COMMAND
↑GLLWM:	0		; LAST "LOAD WRITE MODE" COMMAND
↑GSENDX:0		; Return address for GSENDC, stored if it has to wait
↑GNEEDC:0		; Non-zero if need clear to end of line (also eol ret adr).
>;IFN FTGRIN

>;IFN FTGRIN!FTDD
;⊗ DELCS DMMCNT DMMAXG DELRS DMLFS DMSTR LDMSTR TABSET LTABSE AVLFST AVLLN AVLVP WHOKLU WHOTX WHOF2

↑DELCS:	REPEAT 20,<BYTE (7)10,10,10,10,10> ;Delete-char chars for line ed.
DMMCNT←←15
↑DMMAXG←←5*DMMCNT	;Max number of lines we can glitch at once
↑DELRS:	REPEAT DMMCNT,<BYTE (7)32,32,32,32,32> ;Delete-row chars for DM glitching
↑DMLFS:	REPEAT DMMCNT,<BYTE (7)12,12,12,12,12> ;LFs to erase lines or add rows

↑DMSTR:		ASCID /  ******* HOLDING *******/  ;DM holding message
↑LDMSTR←←.-DMSTR
;↑DMCLR:	ASCID /                         /  ;Clears DM holding message
↑TABSET:BYTE (7)14,150,140,"→",14,160,140,"→",14,170,140,"→"," "," ","W"
	BYTE (7)"A","I","T","S"," ","→","D","i","s","p","l","a","y"," ","→"
	BYTE (7)"S","e","r","v","i","c","e"," ","→",14,130,140,"→",14,40
	BYTE (7)140,"→",14,50,140,"→",14,60,140,"→",14,70,140,"→"
↑LTABSE←←.-TABSET

↑AVLFST:	-1		;SETOMED AT WHOINI, AOSNED AT WHOQUE
↑AVLLN:		0		;XWD FIRST,SECOND TEXT LINE FOR AVL MSG

↑AVLVP:
IFE FTGRIN,<	CW 3,2,4,2,5,4	;GETS CLOBBERED BY PHANTOM STARTER
>;IFE FTGRIN
IFN FTGRIN,<	GW G.LEA,GRESIZ,G.LLA,0 ;Random starting position is stuck here
>;IFN FTGRIN

↑WHOKLU:	0		;COUNTS DOWN TO AVL MSG SHIFT OR -1 TO GOOSE WHOSER
↑WHOTX:		0		;Ticks till next WHOSER activation
IFN FTGRIN,<
↑WHOF2:		0		;Number of next F2 TTY to get wholine updated
>;IFN FTGRIN
;⊗ DDQSIZ DDQTAI DDQDLY DDTAB DDFLST DDFCNT AVLCHN AVLCH2 AVLBIT VDMAP VDPRM VDTIE TVIBEG TVWAIT TVTUNE TVCHAN TVIEND TUNEIT DDSPCH LQBLTB LQBLPP LQBLMS LQBLPI LQBLSQ LSMFTB LSMFMS LSMFFD LSMFFM

↑DDQSIZ:	0	;SIZE OF DD CHANNEL QUEUE
↑DDQTAI:	0	;LINE NO. OF LAST ENTRY IN DDCHAN QUEUE
↑DDQDLY:	0	;Delay for DPYKIL when giving someone channel from queue

↑DDTAB:	BLOCK 40	;CHANNEL TABLE, see field defs in DPYSER
↑DDFLST:	0	;FREE LIST HEADER, MUST FOLLOW DDTAB
↑DDFCNT:	0	;# FREE CHANS
↑AVLCHN:	16	;CHAN FOR AVAIL MSG
↑AVLCH2:	16	;Alternate channel
↑AVLBIT:	0	;BIT for avail chan
↑VDMAP:	BLOCK DDNUM	;THE UNTIED MAP
	BLOCK DPYNUM	;CELLS FOR "SHADOW" CHANNELS
↑VDPRM:	BLOCK DDNUM	;THE PERMANENT MAP
	BLOCK DPYNUM	;I DON'T BELIEVE THESE ARE EVER USED, BUT ... (SHADOW CHNLS)
↑VDTIE:	BLOCK DDNUM	;RH IS LINE NUMBER WHOSE DPY HEADER WE WATCH
			;SIGN BIT SET BY ESC T TYPE COMMANDS
REPEAT DPYNUM,<0↔>	;THESE ARE ALWAYS ZERO (FOR VDSMAP OF SHADOW CHANNELS)
IFN FTSUAI,<
↑TVIBEG←←.		;beginning of area initialized to zero at TTYINI
↑TVWAIT:	0	;ticks to wait after relay gets turned off, iff relay on
↑TVTUNE:BLOCK TVMAX	;neg nbr of tunings needed, positive if reset needed first
↑TVCHAN:BLOCK TVMAX	;currently tuned-in broadcast channel on each TV
↑TVIEND←←.-1		;end of area initialized to zero at TTYINI
↑TUNEIT:	-1	;non-negative if CLKTUN clock tuning routine running
>;IFN FTSUAI
;;↑DDDETQ:	-1	;CHANNEL TO DETACH WHEN IT'S KILLED. SEE DDDDDD.  BH
IFE FTF2,<
↑DDSPCH:	0	;if non-zero, holds -1,,<DD chan> chan to give next DD line
>;IFE FTF2

IFN FTDDBG,<
↑LQBLTB:	0
↑LQBLPP:	0
↑LQBLMS:	0
↑LQBLPI:	0
↑LQBLSQ:	0
↑LSMFTB:	0
↑LSMFMS:	0
↑LSMFFD:	0
↑LSMFFM:	0
>;IFN FTDDBG


;END DPYDAT
;⊗ ZZ DTCDDB DLINK UNIT UNIT

IFE FTF2,<	;Whole page

BEGIN DTCDDB
SUBTTL	DTCDDB 06-AUG-68 DECTAPE DATA BLOCK

;DTA DEVICE DATA BLOCKS

DEFINE CAT6'(A,B),<SIXBIT /A'B/>
	
DEFINE DTCDDX!(UNIT),<
IFE FT8UNI,<
	REPEAT DDBSKW-2,<0>
>;IFE FT8UNI
IFN FT8UNI,<
	REPEAT DDBSKW-3,<0>
	<UNIT+1>⊗PUNITP		;UNIT NUMBER
>;IFN FT8UNI
	.-DEVSPT+DEVIOS		;DEVSPT
	DEVLUP,,0		;DEVCMR
	ZZ←←.
IFE UNIT,<
↑DTCDDB←.>
	CAT6(DTA,\<UNIT+1>)
IFE FT8UNI,<
	=10*HUNGST,,200+<UNIT+1>⊗PUNITP	;LONG HUNG COUNT IS INSERTED WHEN A DUMP
					;MODE OPERATION HAPPENS.
>;IFE FT8UNI
IFN FT8UNI,<
	=10*HUNGST,,200		;LONG HUNG COUNT IS INSERTED WHEN A DUMP
				;MODE OPERATION HAPPENS.
>;IFN FT8UNI
	0
	IFE UNIT-(DTCNUM-1),<DTC.NX,,DTCDSP;>DLINK,,DTCDSP
	DLINK←←.-4
	DVDIR+DVIN+DVOUT+DVDTA+DVLNG,,154403
	0
	0
	0
	0
	XP DTNEXT,.-ZZ		;LH=NEXT OUTPUT BLOCK NO., RH NEXT INPUT BLOCK NO.
	0
	XP DTERR,.-ZZ		;ERROR COUNT OF FATAL ERRORS
	0
	XP CURENT,.-ZZ		;POINTER TO CURRENT DIR ENTRY(ABSOLUTE)
	0
	XP DMPFST,.-ZZ		;POINTER TO FIRST WORD OF DUMP MODE COMMAND LIST
	0
	XP UFREE,.-ZZ		;RH=LAST BLOCK USED. 1 FOR A CLEARED DIRECTORY
	0,,0			;LH=BLKCNT WHILE TAPE INACTIVE, INIT AT BLD TIME
	XP UDIR,.-ZZ		;LINK TO DIRECTORY
	.+1			;ADDRESS OF DTA DIRECTORY IN DDB
	BLOCK 200		;CONTAINS DTA DIRECTORY
>

UNIT←←DTCNUM-1
; THE FOLLOWING EXPANSION OF THE MANY DECTAPE DEVICE DATA BLOCKS
; HAS BEEN XLIST'ED OUT FOR YOUR READING CONVENIENCE.
; THEY ACTUALLY LOOK LIKE THIS:
; REPEAT DTCNUM,<DTCDDX(UNIT)
;         UNIT←←UNIT-1>
XLIST
REPEAT DTCNUM,<DTCDDX(UNIT)
	UNIT←←UNIT-1>
LIST

>;IFE FTF2	;Whole page
;⊗ BLKPTR DMPPTR DMPLST DTOTAL DFTOTAL DTTAC DTUNIT ERRFLG RBNCNT UBUF UERRCN UTCMAP DTTAC1 USVDB BLKCNT UBKN BNDISP CONSZ1 RDBN WTRV RDRV ENPT1 ENPT DMPADV DCLOC DCLOC1

IFE FTF2,<	;Most of page

;STORAGE FOR DECTAPE SERVICE

↑BLKPTR:	0	;BLKI/BLKO POINTER.
↑DMPPTR:	0	;DUMP MODE BLKI/BLKO POINTER MOVED TO BLKPTR AT INTERRUPT
↑DMPLST:	0	;RELATIVE POINTER TO CURRENT DUMP MODE COMMAND LIST WORD
↑DTOTAL:	0	;TOTAL ERROR COUNT FOR SYSTEM SINCE IT WAS LOADED
			;(COUNT NOT CLEARED AT SYSTEM INITIALIZATION)
↑DFTOTAL:	0	;TOTAL FATAL ERROR COUNT FOR SYSTEM SINCE LOADED
			;I.E., OPS THAT FAILED DTTRY (USUALLY 3) TIMES

↑DTTAC:		0	;PLACE TO SAVE TAC ON DC CHANNEL
↑DTUNIT:	0	;DT UNIT IN BITS 30-32, DT PIA BITS 33-35
↑ERRFLG:	0	;DATA MISSED BY DC IF NON-ZERO
↑RBNCNT:	0	;COUNT DOWN NUMBER OF REVERSALS SEEKING BLOCK
↑UBUF:		0	;ABS. ADR. OF SECOND WORD OF USER BUFFER
↑UERRCN:	0	;NO. OF ERROR SO FAR ON THIS OPERATION

IFE FTMPP2,<
↑UTCMAP:	0	;ADDRESS OF THE JBTMAP FOR THE CURRENTLY ACTIVE USER
>;IFE FTMPP2
↑DTTAC1:	0	;TEMP CELL FOR CH1

↑USVDB:		0	;DDB ADDRESS FOR CURRENTLY ACTIVE UNIT
↑BLKCNT:	0	;COUNT OF NO. OF BLOCKS WHICH CURRENT JOB
			;USING DECTAPES CAN DO BEFORE HAVING TO GIVE
			;DTC TO ANOTHER JOB IF ONE IS WAITING
			;THIS IS SETUP AT UUO LEVEL AND DECREMENTED AT
			;JOB DONE TIME AT INTERRUPT LEVEL
			;IF TAPE MUST SEARCH FOR BLOCK, COUNT IS SET TO ZERO
			;MEANING THAT QUANTUM IS EXCEEDED IMMEDIATELY


↑UBKN:		0	;BLOCK NUMBER FOR BN SEARCH
↑BNDISP:	0	;DISPATCH WHEN CORRECT BN IS FOUND
↑CONSZ1:	0	;DTS ERROR MASK (116 FOR BUFFERED MODE, 16 FOR DUMP)

↑RDBN:		0		;JSR HERE FOR BN XFER DURING BN SEARCH
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
		JRST RDBN1

↑WTRV:		0		;JSR HERE FOR DATA XFER FOR WRITE BLOCK IN REVERSE
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
		JRST WTRV1

↑RDRV:		0		;JSR HERE FOR DATA XFER FOR READ BLOCK IN REVERSE
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
		JRST RDRV1

;Here from within DTCSER, not from PI interrupt directly.
↑ENPT1:		0		;JSR HERE TO STOP TAPE.  DON'T DISMISS INT!
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
		JRST ENPT2	;RETURNS VIA JRST @ENPT1, DOESN'T DISMISS!

↑ENPT:		0		;JSR HERE (FORWARD, BUFFERED I/O) TO STOP TAPE.
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
IFN FTXADR,<
		XPCW ENPT1
		XJEN ENPT
>;IFN FTXADR
IFE FTXADR,<
		JSR ENPT1
		JRST 12,@ENPT
>;IFE FTXADR

↑DMPADV:	0		;JSR HERE WHEN ONE DUMP MODE COMMAND WORD EXHAUSTS
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
		JRST DMPA0

	BEND DTCDDB

>;IFE FTF2

↑DCLOC:		0		;ADDRESS OF THE DC channel interrupt instruction
↑DCLOC1:	0		;ADDRESS OF THE second int instr (ABOVE PLUS 1)
;⊗ LPTDDB LPTIOS LPTDCN LPTBG1 LPTBG2 LPTXCT SYSPDL LPTIBF LPTUBP LPTIBP LPTCC LPTLCC LPTLIN LPTPSZ LPTPAP

IFN LPTNUM,<	;Whole page

BEGIN LPTDDB
SUBTTL LPTDDB - 10 SEPT 68 - JAM


;LPT  DEVICE DATA BLOCK
REPEAT DDBSKW-2,<0>	; PUT IN PROPER NUMBER OF ZEROS FOR SKEW PURPOSES
		LPTIOS		;DEVSPT
		DEVIBF!DEVLUP,,0		;INTERNALLY BUFFERED DEVICE
↑LPTDDB:	SIXBIT	/LPT/
		=10*HUNGST,,LPTSIZ+2
↑LPTIOS:	0
		LPT.NX,,LPTDSP
		DVOUT!DVLPT,,4403	;MODES 13,10,1,0
		0
		0
		0
		0
↑LPTDCN:	0		;LAST WORD SENT TO LPT
↑LPTBG1:	0		;SET TO EJECT FORMS BEFORE FIRST OPERATION
↑LPTBG2:	0		;CONTAINS DANGLING CHARS TO SEND BEFORE ANYTHING ELSE
↑LPTXCT:	0		;INSTR. TO XCT FOR CHARACTER CONVERSION

↑SYSPDL:		;PDL FOR SYSINI
↑LPTIBF:	BLOCK LPTBLN	; SYSTEM BUFFER
↑LPTUBP:	POINT 7,LPTIBF	;UUO LEVEL POINTER
↑LPTIBP:	LPTIBF		;INTERRUPT LEVEL POINTER
↑LPTCC:		5*LPTBLN	;TOTAL CHARACTER COUNT
↑LPTLCC:	LPTCPL		;CHARS PER LINE
IFN FTF2,<
↑LPTLIN:	0		;Current line number (for simulating VFU)
;Note:  Following are variables because a Printronix can be eiter 6 LPI or 8 LPI
↑LPTPSZ:	=54		;Number of lines/normal page
↑LPTPAP:	=66		;Number of lines/physical page
>;IFN FTF2

BEND LPTDDB

>;IFN LPTNUM	;Whole page
;⊗ CARDDB CARALR CARBPT CARDEF CARAC1 CARBUF

BEGIN CARDDB ↔ SUBTTL CART DDB - 16 MAY 75 - REG/HPM
IFN CARNUM,<

	REPEAT	DDBSKW-2,<0>
		CARDDB+DEVIOS	;DEVSPT
		DEVLUP!DEVIBF,,0
↑CARDDB:	SIXBIT	/CAR/	;device name
		0,,=21		;hung time,,buffer size
		0		;io status word
		CAR.NX,,CARDSP	;next device,,dispatch table
		DVOUT,,0400	;for DEVCHR uuo, output device, mode 10 only
		0		;device logical name
		0		;user address of output buffer header
		0
		0

↑CARALR:	377777,,777777	;cart alarm, when next state change is due
↑CARBPT:	0,,CARBUF	;a pointer to next thing in system cart buffer
↑CARDEF:	=30,,0		;idle activation interval,,cart default state.
↑CARAC1:	0		;Temporary storage for saving AC1 in CARNXT

↑CARBUF:	BLOCK	=20	;cart command buffer. entries are of the form
				; duration,,action  the 9 low order bits of
				; action don't concern the cart
>;IFN CARNUM
BEND CARDDB
;⊗ XGPDDB XFCJN1 XMSET XGPMDP XGPNXC

IFN FTP2,<	;Whole page
IFG XGPNUM,<	;Most of page

BEGIN XGPDDB ↔ SUBTTL DATA STORAGE FOR XGP SERVICE
;REG JAN 11 1973.  REVISED THRU 8 JUNE 1973

REPEAT DDBSKW-2,<0>
		XGPIOS				;DEVSPT
		DEVIBF!DEVLUP!DEVP2,,XGPCSC	;DEVICE HAS INTERNAL BUFFER.
						;(SOMETIMES)
↑XGPDDB:	SIXBIT /XGP/
		5*HUNGST,,401			;RH = BUFFER SIZE.
		0				;DEVIOS (NOT USED HERE)
		XGP.NX,,XGPDSP
		DVLPT!DVLNG!DVOUT,,104401	;MODES 0,10,17,13
		0				;DEVLOG
		0				;DEVBUF
		0				;DEVIAD
		0				;DEVOAD
		0
		0
		0

↑XFCJN1:	0		;CORE'S VERSION OF XFCJN (FC JOB NUMBER)

;DEFAULT MARGINS AND OTHER PARAMETERS FOR THE XGP.  THE ORDER OF ITEMS
;HERE MUST MATCH THE ORDER IN P2COMM STARTING AT XGPPS1.
↑XMSET:	=200		;TMAR
	=1800		;PMAR
	=200		;BMAR
	=200		;LMAR
	=1650		;RMAR
	=4		;XLINES
	NTNODE		;XTNODE
	NVNODE		;XVNODE
	XGPBL1		;SIZE OF BUFFER - FOR WIZARDS ONLY!
	0		;INTER-CHARACTER SPACING

BEND	XGPDDB

>;IFG XGPNUM

↑XGPMDP:	0		;POINTER TO CURRENT DUMP COMMAND
↑XGPNXC:	0		;POINTER TO NEXT DUMP COMMAND

>;IFN FTP2	;Whole page
;⊗ VRNDDB

IFN FTP2,<
IFN FTVRN,<
BEGIN VRNDDB ↔ SUBTTL DATA STORAGE FOR VRN SERVICE

REPEAT DDBSKW-2,<0>
		VRNIOS				;DEVSPT
		DEVLUP!DEVP2,,XGPCSC		;DEVICE HAS NO INTERNAL BUFFER.
						;(SOMETIMES)
↑VRNDDB:	SIXBIT /VRN/
		=60*HUNGST,,401			;RH = BUFFER SIZE.
		0				;DEVIOS (NOT USED HERE)
		VRN.NX,,VRNDSP
		DVLPT!DVLNG!DVOUT,,100000	;MODE 17 ONLY FOR NOW
		0				;DEVLOG
		0				;DEVBUF
		0				;DEVIAD
		0				;DEVOAD
		0
		0
		0


BEND	VRNDDB
>;IFN FTVRN
>;IFN FTP2
;⊗ PTRDDB PTRADR PTRBTP

IFN FTP2,<	;Whole page

BEGIN PTRDDB ↔ SUBTTL PTRDDB - PAPER TAPE READER DEVICE DATA BLOCK

		REPEAT DDBSKW-2,<0>	; PUT IN ALL THE EXTRA WORDS
		PTRIOS			;SPT
		DEVIBF!DEVLUP!DEVP2,,PTRCSC ;CMR    SPECIAL BITS & SYNCHRONIZER CELLS
↑PTRDDB:	'PTR   '		;NAM
		=10*HUNGST,,41		;CHR    HUNG TIME,,BUFFER SIZE+1
		0			;IOS
		PTR.NX,,PTRDSP		;SER
		DVPTR!DVIN,,14403	;MOD
		0			;LOG
		0			;BUF
↑PTRADR:	0			;IAD ADR
		0			;OAD PTR

;THIS CONTAINS A P2-SPACE ADDRESS!
↑PTRBTP:	0			;POINTER TO TAKER BUFFER

BEND PTRDDB

>;IFN FTP2	;Whole page
;⊗ A A PTPDON PTPNOT PTPDDB PTPCPW PTPUBP PTPUDS DDBDAT PLTDDB

IFN FTP2,<	;Whole page

BEGIN PTPDDB ↔ SUBTTL PTPDDB  PTP AND PLT DEVICE DATA BLOCKS
;JAM - 10-NOV-68.  REG 1975, 1976.

DEFINE	ZWD (A)<
↑A←←.-PTPDAT
0	>

DEFINE	ZLOC (A)<
↑A←←.-PTPDAT >

;PTP CONO BITS
	PTPDON←←10		; DONE FLAG
	PTPNOT←←100		; 'OUT OF TAPE' FLAG

		REPEAT DDBSKW-2,<0>	;PUT IN PROPER NUMBER OF SKEW WORDS
		PTPIOS			;DEVSPT
		DEVIBF!DEVLUP!DEVP2,,PTPCSC ;INTERNALLY BUFFERED, CONTROL CELLS.
↑PTPDDB:	SIXBIT /PTP/		;DEVNAM
		=20*HUNGST,,41		;DEVCHR
		0			;DEVIOS -- UNUSED, SEE PTPIOS
		PTP.NX,,PTPDSP		;DEVSER
		DVPTP+DVOUT,,14403
		0			;DEVLOG
		0			;DEVBUF
		0			;DEVIAD
		0			;DEVOAD
↑PTPCPW←←.-PTPDDB
		0			;CHARACTERS PER WORD
↑PTPUBP←←.-PTPDDB
		0			;UUO-LEVEL POINTER.
↑PTPUDS←←.-PTPDDB
		0			;UUO-LEVEL DISPATCH LOCATION
↑DDBDAT←←.-PTPDDB
		PTPDAT			;POINTER TO SHARABLE DATA AREA

IFG PLTNUM,<
		REPEAT DDBSKW-2,<0>	;PUT IN PROPER NUMBER OF SKEW WORDS
		PLTIOS			;DEVSPT
		DEVIBF!DEVLUP!DEVP2,,PLTCSC ;INTERNALLY BUFFERED, CONTROL CELLS.
↑PLTDDB:	SIXBIT /PLT/		;DEVNAM
		XWD =20*HUNGST,41	;DEVCHR
		0			;DEVIOS -- UNUSED
		PLT.NX,,PLTDSP		;DEVSER
		XWD DVPTP+DVOUT,14403
		0			;DEVLOG
		0			;DEVBUF
		0			;DEVIAD
		0			;DEVOAD
		0			;PTPCPW
		0			;PTPUBP
		0			;PTPUDS
		PLTDAT			;POINTER TO SHARABLE DATA AREA
>;IFG PLTNUM
BEND PTPDDB

>;IFN FTP2	;Whole page
;⊗

BEGIN SCNDDB

;THE FUNCTIONS OF THE FIRST EIGHT WORDS ARE AS DESCRIBED IN THE
;COMMENTS IN THE SYSTEM PARAMETER TAPE( FILE NAME S). LOCATIONS 11
;THROUGH 27 (OCTAL) RELATIVE TO SCNDDB PERTAIN DIRECTLY TO THE
;SCANNER SERVICE BUFFERING SCHEME. THE SUBSEQUENT 2*20(OCTAL) LOCATIONS
;ARE CURRENTLY THE TWO TELETYPE BUFFERS. THEY NEED NOT BE IN THE DDB
;AS LONG AS THEIR ADDRESSES ARE PLACED IN THE RIGHT HALF OF TTIBUF,
;AND TTOBUF EITHER AT ASSEMBLY, BUILD OR RUN TIME. IF DYNAMIC
;BUFFER CONSTRUCTION IS TO BE ADDED THESE BUFFERS MAY BE PLACED ANYWHERE IN
;FRE CORE STORAGE, AND THE RIGHT HALF OF THE REQUIRED TTXBUF(WHERE "X"
;MAY BE "I" OR "O")MAY BE LOADED ONLY WHEN THAT BUFFER IS REQUIRED.

;THERE ARE TWO BUFFERS, EACH OF WHICH IS A "RING" UNTO ITSELF:
;INPUT---POINTED TO BY TTIBUF
;	ALL CHARACTERS TYPED GO INTO THIS BUFFER. IN ADDITION, ALL
;OTHER COMMANDS TO BE READ BY THE COMMAND INTERPRETER IN COMCON
;(APRSER) ARE STORED HERE.
;OUTPUT BUFFER---POINTED TO BY TTOBUF
;	ALL CHARACTERS THAT ARE OUTPUT ARE PLACED SEQUENTIALLY IN THIS
;BUFFER; THIS INCLUDES ECHOED CHARACTERS AS WELL AS NORMAL OUTPUT OF
;CHARACTER STRINGS.

;THERE ARE NINE BUFFER PARAMETER WORDS ASSOCIATED WITH EACH BUFFER
;(EXCEPT FOR THE OUTPUT BUFFER, WHICH ONLY NEEDS SIX). THE LAST
;FOUR CHARACTERS IN THE MNEMONIC DESCRIBES THE FUNCTION OF THE WORD
;WHILE THE FIRST TWO CHARACTERS IDENTIFY WHICH BUFFER THAT THE
;FUNCTION APPLIES TO. THE FORMULA FOR THESE WORDS IS TX'FUNC, WHERE
;THE RELATIVE POSITION OF ALL TX'FNC1 TO TTX'BUF IS THE SAME FOR
;ALL BUFFERS.  IN THIS MANNER, THE ADDRESS OF TTX'BUF IS LOADED INTO
;ACCUMULATOR DAT, AND THE RELATIVE POSITIONS FUNCT1-FUNCT9 ARE
;DEFINED TO BE 0-10 (OCTAL); I.E., FUNCT(DAT) WILL IDENTIFY THE DESIRED
;BUFFER PARAMETER WORD REGARDLES OF BUFFER.

;FOLLOWING ARE DEFINITIONS OF THE RELATIVE BUFFER PARAMETER WORDS:
;TTX'BUF OR BUF(DAT)---THE LEFT HALF CONTAINS NUMBER OF BYTES IN BUFFER AND THE RIGHT
;	HALF THE ADDRESS OF THE FIRST WORD OF THE BUFFER. THIS WORD IS
;	ONLY READ BY THE CURRENT CODE.  UPON THE ADDITION OF DYNAMIC
;	BUFFER ALLOCATION, THIS WORD WOULD BE LOADED IN THE SAME FORMAT
;	AT THE TIME THAT THE BUFFER WOULD BE BUILT.
;
;SCNINI SETS BUFFERS TO LENGTH TTYCHR AT PRESENT. ALSO
;PRESENT CODE OCCASIONALLY USES TTYCHR RATHER THAN READING LH
;OF TTXBUF
;
;TX'PUTR OR PUTR(DAT)---BYTE POINTER USED TO PLACE CHARACTERS INTO THE
;	BUFFER. IT MUST ALWAYS BE AHEAD OF OR EQUAL TO THE TAKER POINTER.
;TX'PCTR OR PCTR(DAT)---COUNT OF NUMBER OF TIMES THAT PUTR MAY BE INCREMENTED
;	BEFORE REACHING THE LAST BYTE IN THE LAST WORD OF THE BUFFER
;	(NOT THE AMMOUNT OF FREE SPACE LEFT)
;TX'TAKR OR TAKR(DAT)---BYTE POINTER USED BY ALL ROUTINES TO PICK UP
;	CHARACTERS FROM THE BUFFER. WHEN THE TAKR IS EQUAL TO THE PUTR,
;	THE BUFFER IS "EMPTY".
;TX'TCTR OR TCTR(DAT)---COUNT OF THE NUMBER OF TIMES THAT THE TAKR CAN
;	BE INCREMENTED BEFORE REACHING THE PHYSICAL END OF THE BUFFER.
;TX'FCTR OR FCTR(DAT)---FREE CHARACTER COUNT; I.E., HOW MANY TIMES MAY THE
;	PUTR BE INCREMENTED BEFORE IT WOULD COME AROUND AND "STEP ON"
;	THE TAKR. WHEN THE FREE CHAR. COUNT IS ZERO, NO MORE CHARACTERS
;	MAY BE PLACED IN THE BUFFER (USUAL RESULT IS GOING INTO IO WAIT)
;TX'SYNC OR TSYNC(DAT)---COUNT OF NUMBER OF "LINES" THAT HAVE BEEN TYPED
;	INTO INPUT BUFFER.
;⊗ TTPLEN TTPSIX SCNDDB TTYLST

;SCANNER DEVICE DATA BLOCK.
;REMAINING SCN DDB'S ARE GENERATED
;OUT OF LINE AT BUILD TIME.
;THIS DDB IS USED FOR THE CTY AND NEVER KILLED   BH 5/6/74

↑TTPLEN←←SCNNUM+DPYNUM+DDNUM+PTYNUM+1

DEFINE FOO (XXX)<
↑TTPSIX←←'XXX'
>
FOO (\TTPLEN)
;THIS DEPENDS ON THERE BEING 3 DIGITS' WORTH OF TTYS

IFE FT8UNI,<
	REPEAT DDBSKW-2,<0>
>;IFE FT8UNI
IFN FT8UNI,<
	REPEAT DDBSKW-3,<0>
	TCONLN⊗PUNITP		;UNIT NUMBER
>;IFN FT8UNI
	SCNDDB+DEVIOS			;DEVSPT
	DEVSTS!DEVAOA,,0	;IGNORE IOACT FOR OUTPUT UUO, CALL TTYICK
↑SCNDDB:
↑TTYLST:
	ZZ ←← .
	'CTY   '			;DEVNAM
IFE FT8UNI,<
	TCONLN⊗PUNITP+UTTYBF+1		;DEVCHR(NO HUNG TIME),,BUFFER SIZE+1
>;IFE FT8UNI
IFN FT8UNI,<
	UTTYBF+1			;DEVCHR(NO HUNG TIME),,BUFFER SIZE+1
>;IFN FT8UNI
	0				;DEVIOS
	SCN.NX,,SCNDSP			;DEVSER (LAST DEVICE IN CHAIN)
	DVTTY+DVIN+DVOUT,,15403		;DEVMOD (MODES 0,1,10,11,13,14)
	0				;DEVLOG
	0				;DEVBUF
	0				;DEVIAD
	0				;DEVOAD
	XP	ACTBTS,.-ZZ		;BREAK TABLE
	-1
	777700,,37600
	374000
	XP	ACTMOD,.-ZZ		;END OF TABLE AND SPECIAL BITS
	7,,600000
	XP	TTYPTR,.-ZZ		;TTYPTR
	0
	XP	TTIBUF,.-ZZ
	XP	TTICHR,STTIBF*4		;9 BIT CHARACTERS FOR INPUT
	TTICHR,,TTYLST+TIBF-1
	XP	TIPUTR,.-ZZ
	1100,,TTYLST+TIBF
	XP	TIPCTR,.-ZZ
	1
	XP	TITAKR,.-ZZ
	1100,,TTYLST+TIBF
	XP	TITCTR,.-ZZ
	1
	XP	TIFCTR,.-ZZ
	TTICHR
	XP	TISYNC,.-ZZ
	0
	XP	TTOBUF,.-ZZ
	XP	TTOCHR,STTOBF*<44/OBYTSZ> ;BH 1/5/78 9-BIT BYTE SIZE (DEF IN OUTER)
	TTOCHR,,TTYLST+TOBF-1
	XP	TOPUTR,.-ZZ
	700,,TTYLST+TOBF
	XP	TOPCTR,.-ZZ
	1
	XP	TOTAKR,.-ZZ
	700,,TTYLST+TOBF
	XP	TOTCTR,.-ZZ
	1
	XP	TOFCTR,.-ZZ
	TTOCHR
	XP	PTYPTR,.-ZZ
	0
	XP	SAVDDB,.-ZZ		;FOR FILES COMMAND
	0
	XP	IMLHAC,.-ZZ
	0
;IMLHAC 35    FLAGS ↑←L COMMAND, SO NEXT CHAR IS CHAR TO BACK UP TO
;	34    TTY NO DEL: INTERCHANGE ↑H AND RUBOUT ON INPUT
;       26:33 HOLD TTY WIDTH (PTTYWD)
;	25    ↑← HAS BEEN TYPED, NEXT CHAR IS SPECIAL
;	24    TEMPORARY GAG MODE, CLEARED BY RESET (TTYRST)
;	23    TTY GAG MODE
;	22    CONVERT ASCII TO SAIL CHAR SET
;	21    PK SHOULDN'T DISPLAY PASSWORD IN INPUT BUFFER
;	20    TTY GLASS, ECHO RUBOUT AS BS SP BS
;	19    TURN ON CONTROL (200) BIT FOR NEXT CHARACTER
;	18    TURN ON META (400) BIT FOR NEXT CHARACTER
;	7:17  ARGUMENT (JOB NUMBER, SO FAR) FOR FORCED COMMAND
;	1:6   INDEX INTO FORCED COMMAND TABLE
;	0     FORCED COMMAND BEING PROCESSED

	XP	TTYBTS,.-ZZ	;MORE SPECIAL BITS (THESE WILL GO WITH JOB)
	0
;TTYBTS: ONLY BITS USED SO FAR ARE DUPLICATED FROM DEVIOS, NAMELY: DDTM!SNKWAT

IFN FTMONCIP,<
	XP	MONCIP,.-ZZ
	0
>;IFN FTMONCIP
IFN FTDTTYBUG,<
	XP	CRETIM,.-ZZ	;DATE,,TIME IN SECS WHEN THIS DDB CREATED
	0
	XP	CRELIN,.-ZZ	;LINE NUMBER THIS DDB CREATED FOR
	0
	XP	CREADR,.-ZZ	;LH/CALLER OF DDBSRC  RH/NEXT STACK ADDR AT DDBSRC
	0
	XP	CREAD2,.-ZZ	;LH/3RD ADDR ON DDBSRC STACK  RH/4TH ADDR ON STACK
	0
>;IFN FTDTTYBUG
	XP	TIBF,.-ZZ
	BLOCK	STTIBF			;THE ACTUAL INPUT BUFFER
	XP	TOBF,.-ZZ
	BLOCK	STTOBF			;THE ACTUAL OUTPUT BUFFER
;NO. OF CHAR. IN MON. BUF.
	XP	SCNDDS,.-ZZ		;SIZE OF SCN DDB
;⊗ COMAGN NLCOMS LCOMS LDDBS LTIMS FRCFLG ATTDEV LINSAV LINSV1 SCNCNT SCNCN2 SCNBUG SCNBU3 OFSPD1 OFSPDL OFSPD TTYLOK DKBCHR PTLBUL PTLBUF PTLPTR PTLTKR RUBLUZ RECLUZ LINTAB HOMEPT PTYJOB PTYIMP DPYDES DPYNAM EDITKY PADCNT TTYENB DKBBAD KIMTAB KIMSVA KIMSV1 KIMNHM KIMNSM

IFN FTCMDBUG,<
↑COMAGN:	1000	;COUNTED DOWN TOWARD ZERO EACH TIME WE CALL COMMAND
↑NLCOMS←←20		;NUMBER OF RECENT COMMANDS TO REMEMBER, MUST BE POWER OF 2
↑LCOMS:		BLOCK NLCOMS	;RECENT COMMAND DISPATCH ADDRESSES
↑LDDBS:		BLOCK NLCOMS	;DDBS FOR RECENT COMMANDS
↑LTIMS:		BLOCK NLCOMS	;UPTIME AT TIME OF EACH RECENT COMMAND
>;FTCMDBUG
↑FRCFLG: 0			;FORCED COMMAND IN PROGRESS IN CLKSER
↑ATTDEV: 0			;NAME OF DEVICE BEING RE-ATTACHED TO SYSTEM
↑LINSAV: 0
↑LINSV1: 0
↑SCNCNT: -1			;Level counter for SCNOFF and SCNON
↑SCNCN2: -1			;COPY OF SCNCNT SAVED DURING CH5
↑SCNBUG:	0
		JRST SCNBU2	;SCNCNT WAS ≤ -2
↑SCNBU3:	0
		JRST SCNBU4	;HERE FROM CH5 INTERRUPT IF SCNCNT IS ≥ 0
↑OFSPD1:	-10,,OFSPD-1
↑OFSPDL:	-10,,OFSPD-1
↑OFSPD:		BLOCK 10
↑↑TTYLOK:	0
↑DKBCHR:	0
↑PTLBUL←←40
↑PTLBUF:	BLOCK PTLBUL	;BUFFER FOR USER TYPEAHEAD DURING PTLOAD
↑PTLPTR:	0		;BPT FOR STUFFING STUFF INTO PTLBUF
↑PTLTKR:	0		;BPT FOR GOBBLING GOBS OUT OF PTLBUF
↑RUBLUZ:	0		;COUNT OF UNECHOED GLASS RUBOUTS FROM ↓← CMDS
↑RECLUZ:	0		;COUNT OF TIMES ALL FREE DDS IN DD QUEUE AT RECCHK

GLOBAL TTPLEN
;Left half holds current line characteristics bits for the logical line.
;Low bits of right half hold line number this physical line is mapped to.
	 0		;LINTAB(-1) FOR DDBSRC
↑LINTAB: BLOCK TTPLEN	;LH is for logical line, RH is for physical line (sorry)
;Now a byte pointer into LINTAB(LINE)
↑HOMEPT←←<POINT PUNITS,LINTAB,26> ;Home line number for ESC M command (DDs only).
;High bits of right half hold home line number for this physical line.

GLOBAL PTYNUM
↑PTYJOB:	BLOCK PTYNUM
IFN FTIP,<
↑PTYIMP:	BLOCK PTYNUM		;IMP DDBs for IMP PTYs
>;IFN FTIP


;To assemble in a permanent local DM-type display, set the DMLIN bit for the
;TTY's LINBIT entry (in TTYSER) AND set the right value for the TTY in
;each of the tables DPYDES, DPYNAM, EDITKY and PADCNT.  Zero in any of
;these will get you the default (basically what a DM 2500 needs), so you
;can avoid setting up entries where the default is desired (like currently
;in EDITKY and PADCNT).  To set the four table entries for a given TTY, you
;diddle the DPYXXX macro by changing a DUNDEF to an XX macro or just by
;diddling the parameters in an old XX macro.

;macro for undefined dpy types, all fields omitted.  FIRST and LAST are TTY nbrs.
DEFINE DUNDEF(FIRST,LAST) <
IFN FIRST-<.-XXX>,<.fatal 1st argument of DUNDEF(FIRST,LAST) is inconsistent>
REPEAT LAST-<FIRST>+1,<XX(,,,,)>
>;DEFINE DUNDEF

GLOBAL TTPLEN	;GRRRRR

DEFINE DPYXXX <
	XXX ←← .		;remember location of start of table for ending it
IFN FTSUAI,< ;Permanent DMs at SAIL
	DUNDEF(0,14)		;0:14 are unspecified
	XX(<NO177!PADID!NOIDCU,,DM2500>,DM2500) ;TTY15
	DUNDEF(16,30)		;16:30 are unspecified
	XX(<DMWAITS!DM3025!NO177!ALTNEQ!DM128!NOIDCU,,DM2500>,DMWAITS) ;TTY31
	XX(<DMWAITS!DM3025!NO177!ALTNEQ!DM128!NOIDCU,,DM2500>,DMWAITS) ;TTY32
	DUNDEF(33,33)		;33 normal
	XX(<DMWAITS!DM3025!NO177!ALTNEQ!DM128!NOIDCU,,DM2500>,DMWAITS) ;TTY34
	XX(<DMWAITS!DM3025!NO177!ALTNEQ!DM128!NOIDCU,,DM2500>,DMWAITS) ;TTY35
	DUNDEF(36,54)		;36:54 are unspecified
	XX(<PADID!NOIDCU,,DM2500>,DM2500) ;TTY55
	XX(<DMWAITS!DM3025!NO177!ALTNEQ!DM128!NOIDCU,,DM2500>,DMWAITS) ;TTY56
>;IFN FTSUAI
IFN FTCCRMA,< ;Assemble in the types of permanent local DMs at CCRMA
	DUNDEF(0,3)		;TTYs 0:3 are unspecified
>;IFN FTCCRMA
IFN FTLLL,<
	XX(<DMWAITS!DM3025!NO177!ALTNEQ!DM128!NOIDCU,,DM2500>,DMWAITS) ;TTY0
    REPEAT 17,<
	XX(<NO177!PADID!NOIDCU,,DM2500>,DM2500) ;TTYS 1-17 are standard DM 2500, without BS
    >;REPEAT
>;IFN FTLLL
	DUNDEF(.-XXX,TTPLEN-1) ;Fill in rest of table with undefined displays
>;DEFINE DPYXXX

;Now we create the four tables, using the list in the DPYXXX macro defined above.

    DEFINE XX(DESC,NAME,EDIT,PDBAUD,PDCHAR)< IFDIF <><DESC>,<DESC;>0  >
↑DPYDES:DPYXXX			;Bits,,ptr to dpy descriptor table for given line

    DEFINE XX(DESC,NAME,EDIT,PDBAUD,PDCHAR)< <SIXBIT\NAME\>  >
↑DPYNAM:DPYXXX			;Sixbit name of display type for each line

    DEFINE XX(DESC,NAME,EDIT,PDBAUD,PDCHAR)< IFDIF <><EDIT>,<EDIT;>0  >
↑EDITKY:DPYXXX			;No-edit-key flags.  Negative if no edit key.

    DEFINE XX(DESC,NAME,EDIT,PDBAUD,PDCHAR)< IFDIF <><PDCHAR>,<
BYTE (18)0(9)PDBAUD,PDCHAR ;> BYTE (18)0(9)PDBAUD,0  >	;STUPID FAIL
↑PADCNT:DPYXXX			;LH: negative count of padding chars needed
				;RH: high-order 9 bits: baud rate to pad for
				;RH: low-order 9 bits: padding char to use


↑TTYENB:	BLOCK 4		;BITS FOR LINES ENABLED DESPITE TTYLOCK
IFG <<TTPLEN+=35>/=36>-<.-TTYENB>,<.FATAL TTYENB table doesn't hold all TTYs!>
;TTYENB is assumed fixed size for all possible TTPLEN values, see TTYINI.
REPEAT 0,<
↑DKBBAD:	BLOCK 2		;BITS FOR MARKING LINES WE'VE SEEN BAD CHARS FROM
>;REPEAT 0

IFN FTKIM,<
; KIM PARALYZER INTERFACE

↑KIMTAB:	44,,0		; TTY124
		55,,0		; TTY135
		16,,0		; TTY76 ALSO (SERIALIZER PORT)
		57,,0		; TTY137 FIRST (NO OTHER KBD ATTACHED)
		-1,,0		; ONE WORD FOR EACH TTY ON THE KIM
		-1,,0		; LH = TTY LINE NUMBER MINUS DPYL0
		-1,,0		; RH = CURRENT STATE (FOR SPW MODE)
		-1,,0		; LH=-1 FOR NOT IN USE

↑KIMSVA:0		; SAVE US AN ACCUMULATOR AT INTERRUPT LEVEL
↑KIMSV1:0		; ANOTHER SAVED ACCUMULATOR

; ERROR COUNTERS

↑KIMNHM:0		; NUMBER OF TIMES THE HARDWARE DATA MISSED BIT ON
↑KIMNSM:0		; NUMBER OF TIMES THE SOFTWARE DATA MISSED BIT ON
>;IFN FTKIM
;⊗ GRCALL GRCHAN NGRCHN GRASUP GRELSZ GRSCSK GRTPSK GRSCSK GRTPSK GRNDIM GRSKIP MCKBBW MCWD0 MCWD1 MCWD2 MCSHF1 MCSHF2 MCTOP1 MCTOP2 MCCTL1 MCCTL2 MCMET1 MCMET2 MCCAPS

IFN FTGRIN,<
;Table to map from Grinnell line number to Grinnell 2-cmd word specifying
;the line's channel and subchannel.

↑GRCALL:GW G.LDC,7,G.LSM,17	;Channel select of all screens for available msg

DEFINE XX(C,S) <GW G.LDC,1⊗C,G.LSM,1⊗S>
;First arg is channel, second is subchannel, index with 0-base line number.
↑GRCHAN:XX 0,0
	XX 0,1
	XX 0,2
	XX 0,3
	XX 1,0
	XX 1,1
	XX 1,2
	XX 1,3
	XX 2,0
	XX 2,1
	XX 2,2
	XX 2,3
↑NGRCHN←←.-GRCHAN	;Number of Grinnell screens (lines).

;The following array can be diddled with UEDDT or EDDT to keep the available
;message from going out on selected screens (e.g., ones in use by programs
;not actually running on the given Grinnell).  Someday the DDCHAN UUO might
;grant a user ownership of a Grinnell screen and set the screen's word here.
↑GRASUP:BLOCK NGRCHN	;Non-zero entry means suppress available msg on screen

;Table of Element and Line sizes for different Grinnell screens.
;LH is Char width in pixels, RH is Line height in scanlines
;If you want to experiment with changing the height, you have to change
;GRNCHG too, as the Grinnell simulator uses GRNCHG as the height.
;This table is only looked at by DPYMAK, so a display must go available
;and be created again for changes here to be seen, for experimentation.
↑GRELSZ:REPEAT NGRCHN,<GRESIZ,,GRLSIZ>	;Initialize all to normal default.

REPEAT 0,<
↑GRSCSK←←60	;Number of scanlines to avoid using off bottom of monitor
↑GRTPSK←←51	;Number of scanlines to avoid using off top of monitor
>;REPEAT 0
↑GRSCSK←←2	;Number of scanlines to avoid using off bottom of monitor
		;Must be at least one so cursor can fit in bottom
↑GRTPSK←←0	;Number of scanlines to avoid using off top of monitor
;Table of Grinnell resolutions: pixels per scanline,,scanlines per screen
↑GRNDIM:REPEAT NGRCHN,<1000,,1000-GRSCSK-GRTPSK> ;Assume all are 512x512

;Number of scanlines at bottom to avoid because they are off monitor's screen
↑GRSKIP:GRSCSK		;Skip some scanlines at bottom

↑MCKBBW←←=36	;Number of bits per word used in following tables (one bit per key)
;Index into following tables with line number - DDL0.
↑MCWD0:	BLOCK DDNUM	;Table of first 36 keys per microswitch kbd
↑MCWD1:	BLOCK DDNUM	;  "    " second ...
↑MCWD2:	BLOCK DDNUM	;  "    " third ...

;Macro takes key number as arg and generates byte pointer to key's bit in table.
DEFINE MCBPT (C)<
..BPOS ←← =35-<C ∂ MCKBBW> ;Figure byte position. "∂" is FAIL's remainder op!
	POINT 1,CAT(MCWD,\C/MCKBBW)-DDL0(TAC1),..BPOS
>

↑MCSHF1:MCBPT(111)	;First shift key
↑MCSHF2:MCBPT(125)	;Second shift key
↑MCTOP1:MCBPT(112)	;First top key
↑MCTOP2:MCBPT(124)	;Second top key
↑MCCTL1:MCBPT(134)	;First control key
↑MCCTL2:MCBPT(136)	;Second control key
↑MCMET1:MCBPT(133)	;First meta key
↑MCMET2:MCBPT(137)	;Second meta key
↑MCCAPS:MCBPT(132)	;Caps lock key
>;IFN FTGRIN
;⊗ ABRIDL LS110 LS134 LS150 LS300 LS600 LS1200 LS1800 LS2400 LS4800 LS9600 LS1512 LS55 LS75 LSEXT LS1218

COMMENT ⊗
DCATAB is a table of one-word entries indexed by DCA scanner port number.
The left half contains bits which can be modified by the monitor, and the
right half contains bits which are constant.  The format is:
   BYTE (1)DTR,DSR,CAR(6)BAU(1)DIL,CDN,SYI,0,SPW,BKF(3)BKY
	(1)DLB,DPB,BDB,PRM,DWN(2)0(4)SPD(7)LIN
where	DTR	Data Terminal Ready, normally always on
	DSR	Data Set Ready, set by modem
	CAR	Carrier Detect, set by modem
	BAU	automatic baud detect state, initially ABRIDL
	DIL	set this bit when dialing out, to prevent auto baud detect
	CDN	this bit set for 1/2 sec after carrier down, to detect glitch
	SYI	set at sysini time if car is on, hangs up after 3 min if no talk
	SPW	last character received had the SPW bit on
	BKF	on if we have bucky bits pending for next char (also called STR)
	BKY	three bucky bits to apply to next character
(rh bit)DLB	on if this is a Dialnet line, not a TTY
	DPB	on if this is a display (bucky bit) terminal
	BDB	on if this is an auto baud detect line
	PRM	on if this is a "permanent" line (no sysini hangup)
	DWN	set this bit to reject interrupts from this port
	SPD	a code for the port's speed.  Set to 600 for auto baud detect.
	LIN	the TTYSER or DLNSER line number for this port

Codes are defined for the following speeds:
	55,75,110,134[134.5],150,300,600,1200,1800,2400,4800,9600,1512[150/1200],
		and 1218[1200/1800]
The following macros create DCATAB entries.
⊗;END COMMENT

ABRIDL←←1	;BYTE arg can't be global

LS110←←0	;ditto.  must agree with TTYSER.
LS134←←1
LS150←←2
LS300←←3
LS600←←4
LS1200←←5
LS1800←←6
LS2400←←7
LS4800←←10
LS9600←←11
LS1512←←12		;INDEX FOR 150/1200 SPLIT SPEED
LS55←←13		;55 BAUD
LS75←←14		;75 BAUD
LSEXT←←15		;EXTERNAL CLOCK
LS1218←←16		;1800/1200 FOR IMLACS


;If DTR is off in the initial DCATAB entry for a port, then that port will be
;hung up by system initialization.  (DTR is the sign bit of the DCATAB entry.)

;General macro to set up an entry in DCATAB, for a dialup line.
DEFINE XDCA'(TTY,SPEED,DETECT,BUCKY,DOWN)<
	BYTE (1)1(2)0(6)ABRIDL(9)0(1)0,BUCKY,DETECT,0,DOWN(2)0(4)LS'SPEED(7)TTY>

;Macro to set up an entry in DCATAB for a permanent line (no phone to hangup).
DEFINE XPRM'(TTY,SPEED,DETECT,BUCKY,DOWN)<
	BYTE (1)1(2)0(6)ABRIDL(9)0(1)0,BUCKY,DETECT,1,DOWN(2)0(4)LS'SPEED(7)TTY>

;Macro to set up an entry within the block of serialized DDs (BUCKY is on).
;DCADP0 is the port number of the first line in the block of IIIs and DDs.
DEFINE XSER <XPRM(<DPYL0+.-DCATAB-DCADP0>,1200,0,1)>

;Macro to set up a DOWN entry within the block of serialized DDs (BUCKY is on).
;This is just like XSER above, but with DCADWN on to mark the port down.
DEFINE DXSER <XPRM(<DPYL0+.-DCATAB-DCADP0>,1200,0,1,1)>

;Macros for LLL lines.
;;; Use the following if you want LLL lines down initially.
;;;DEFINE XLLL'(TTY,SPEED,DETECT,BUCKY)<
;;;	BYTE (1)0(2)0(6)ABRIDL(4)0(1)1(4)0(1)0,BUCKY,DETECT,1(3)0(4)LS'SPEED(7)TTY>
;;; Use the following if you want LLL lines up initially.
DEFINE XLLL'(TTY,SPEED) <XPRM(TTY,SPEED,0,0)>

;Macro for Dialnet lines.
DEFINE XDLN'(TTY,SPEED,PERM)<
	BYTE (3)0(6)ABRIDL(9)0(1)1,0,0,PERM(3)0(4)LS'SPEED(7)TTY>

;Macro for DM dialup lines.
IFE FTDSYI,<
DEFINE XDM (TTY) <XDCA(TTY,1512,0,0)>
>;IFE FTDSYI
IFN FTDSYI,<
DEFINE XDM (TTY) <BYTE (1)0(2)0(6)ABRIDL(9)0(1)0,0,0,0(3)0(4)LS1512(7)TTY>
>;IFN FTDSYI - DM LINES MUST START HUNG UP BECAUSE MODEM THINKS DIAL TONE IS CARRIER

;Macro for Auto-baud-detect lines.
DEFINE XABD (TTY) <XDCA(TTY,600,1,0)>

;Macro for ports not in use.  Set up likely default speed just in case.
DEFINE XDOWN'(TTY,SPEED) <DCAABI,,DCAPRM!DCADWN!<LS'SPEED*DCASNX>!TTY>
;⊗ DCADP0 DCATAB FPORDM NPORDM FPO12A NPO12A FPO12B NPO12B DCANUM DCADP0 DCATAB FPORDM NDC10E NPORDM NDC10E NPORDM DLSNUM DCANUM NNODLS DCADP0 DCATAB FPORDM NDC10E NPORDM DLSNUM DCANUM NNODLS DCABEG NPORTD NDCAER NDCAIN CDCAIN KBDNXT FONTTY NNOREP NNOPOR DCAPIN DCACIN DCAREC DCAINN DCAMIN DCAOER DCABER KBDCHR DCAEND MAXBER CHKDCA

;The pairings of DCA port numbers and TTY line numbers have been set up
;so that, initially, for all TTYs, the TTY line number = the DCA port number.
;However, this need not be maintained; it is just there to make it easier
;to remember the numbers.  The lines below are in order by DCA port
;number, with the TTY number being a parameter of the macros.  At LINBIT in
;TTYSER, the lines are in order by TTY number, with the DCA port number
;being a parameter of the macros.

IFN FTSUAI,<

;IF YOU ADD A TTY TO THIS PORT TABLE, YOU HAVE TO PUT THAT PORT IN THE TTY
;TABLE AT LINBIT IN TTYSER

↑DCADP0←←60		;First port in block of serialized III/DD lines

↑DCATAB:
XDM(0)			;PORT 0		SECRET DCL DM	1200/150
 ↑FPORDM←←.	;First public DM port
XDM(1)			;PORT 1		497-0081	1200/150
XDM(2)			;PORT 2		497-0082	1200/150
XDM(3)			;PORT 3		497-0083	1200/150
XDM(4)			;PORT 4		497-0084	1200/150
XDM(5)			;PORT 5		497-0085	1200/150
XDM(6)			;PORT 6		497-0086	1200/150
XDM(7)			;PORT 7		497-0087	1200/150
XDM(10)			;PORT 10	497-0088	1200/150
XDM(11)			;PORT 11	497-0089	1200/150
XDM(12)			;PORT 12	497-0080	1200/150
 ↑NPORDM←←.-FPORDM ;number of consecutive DM ports, for WHOSER and LINBIT
;;Note: ACCT's DMNUM and (assuming TTY=port) SMERGE's DMLIN have NPORDM compiled in.
XPRM(13,300,0,0,1)	;PORT 13	(unused, starts DOWN)
XPRM(14,1200)		;PORT 14	Racal-Vadic MACS dialer
XDM(15)			;PORT 15	LGC leased line	1200/150
XPRM(16,55)		;PORT 16	ASSOC. PRESS	--/55
XPRM(17,75)		;PORT 17	NEW YORK TIMES	--/75

XPRM(20,1200,0,0,1)	;PORT 20	(unplugged) IMLAC-JMC	1200/1200
XPRM(21,1218,0,0,1)	;PORT 21	(unplugged) IMLAC-RWW	1800/1200
XPRM(22,300,0,0,1)	;PORT 22	(unplugged at DCA)
 ↑FPO12A←←.	;First public 1200/1200 port in first group
XABD(23)		;PORT 23	324-9030	110-150-300-1200
XABD(24)		;PORT 24	324-9031	110-150-300-1200
XABD(25)		;PORT 25	324-9032	110-150-300-1200
XABD(26)		;PORT 26	324-9034	110-150-300-1200
XABD(27)		;PORT 27	324-9035	110-150-300-1200
 ↑NPO12A←←.-FPO12A ;nbr of consecutive 1200/1200 ports in first group, for WHOSER
XPRM(30,1200)		;PORT 30	PONY TTY
XPRM(31,1800)		;PORT 31	ERL-A
XPRM(32,1800)		;PORT 32	ERL-B
XPRM(33,1200,0,0,1)	;PORT 33	was TI 990, starts DOWN
XPRM(34,1800)		;PORT 34	ERL-C
XPRM(35,1800)		;PORT 35	ERL-D
 ↑FPO12B←←.	;First public 1200/1200 port in second group
XABD(36)		;PORT 36	324-9036	110-150-300-1200
XABD(37)		;PORT 37	324-9037	110-150-300-1200
 ↑NPO12B←←.-FPO12B ;nbr of consecutive 1200/1200 ports in second group, for WHOSER

XDOWN(40,2400)		;PORT 40	"DLN0" (not really wired, only in software)
XDOWN(41,2400)		;PORT 41	unused
XPRM(42,9600,0,0,1)	;PORT 42	Frost (030D), starts DOWN
XPRM(43,9600,0,0,1)	;PORT 43	Paper tape punch and reader, starts DOWN
XPRM(44,2400)		;PORT 44	JMC home #0
XPRM(45,2400)		;PORT 45	JMC home #1
XPRM(46,2400)		;PORT 46	JMC home #2 (spare)
XPRM(47,4800)		;PORT 47	JMC home #3 (printer)
XDCA(50,2400)		;PORT 50	321-5616
XDCA(51,2400)		;PORT 51	321-5617
XDCA(52,2400)		;PORT 52	321-5618
XDCA(53,2400,0,0,1)	;PORT 53	321-5619 down till all NEC modems repaired
XPRM(54,2400,0,0,1)	;PORT 54	NA term room (320), for HP terminals (DLB)
XPRM(55,1200)		;PORT 55	alternate CTY
XPRM(56,2400,0,0,1)	;PORT 56	Malachi (YM), MJH324, DOWN
XPRM(57,9600,0,0,1)	;PORT 57	Canon connection, DOWN
IFN .-DCATAB-DCADP0,<.FATAL Wrong number of DCA ports before III/DD ports!>
;Here come the III and DD serializer ports.  DXSER means the port is down, XSER up.
REPEAT KBDNUM,<
XSER			;Ports 60 thru 157.  Start with all kbds enabled.
>;REPEAT
↑DCANUM←←.-DCATAB	;Total number of DCA ports in use, size of DCATAB table.
>;IFN FTSUAI

IFN FTCCRMA,<
;IF YOU ADD A TTY TO THIS PORT TABLE, YOU HAVE TO PUT THAT PORT IN THE TTY
;TABLE AT LINBIT IN TTYSER

↑DCADP0←←4		;First port in block of serialized III/DD lines

↑DCATAB:
PRINTX Maybe the 300 baud dialups ought to be autobaud detect, if possible.
XDCA(0,300)		;PORT 0		low speed dialup
 ↑FPORDM←←.	;First DM port
XDM(1)			;PORT 1		1200/150 dialup
IFN DLNNUM,<
XDM(2)			;PORT 2		1200/150 dialup
 ↑NDC10E←←.-DCATAB	;Number of lines with modem control
 ↑NPORDM←←.-FPORDM ;NUMBER OF CONSECUTIVE DM PORTS, FOR WHOSER
XDLN(0,1200,0)		;PORT 3		DIALNET
>;IFN DLNNUM
IFE DLNNUM,<
XPRM(2,4800,0,0,1)	;PORT 2		Canon connection, starts DOWN
XDM(3)			;PORT 3		1200/150 dialup
 ↑NDC10E←←.-DCATAB	;Number of lines with modem control
 ↑NPORDM←←.-FPORDM ;NUMBER OF CONSECUTIVE DM PORTS, FOR WHOSER
>;IFE DLNNUM
XSER			;PORT 4		Rest are microswitch kbds for Grinnells
XSER			;PORT 5			...
XSER			;PORT 6
XSER			;PORT 7
XSER			;PORT 10
XSER			;PORT 11
XSER			;PORT 12
XSER			;PORT 13
XSER			;PORT 14
XSER			;PORT 15
XSER			;PORT 16
XSER			;PORT 17
↑DLSNUM←←.-DCATAB
↑DCANUM←←.-DCATAB	;Total number of DCA ports in use, size of DCATAB table.

↑NNODLS:	0	;Number of DLS interrupts with invalid port number
>;IFN FTCCRMA

IFN FTLLL,<
;IF YOU ADD A TTY TO THIS PORT TABLE, YOU HAVE TO PUT THAT PORT IN THE TTY
;TABLE AT LINBIT IN TTYSER

↑DCADP0←←0		;First port in block of serialized III/DD lines

↑DCATAB:
 ↑FPORDM←←.	;First DM port
 ↑NDC10E←←.-DCATAB	;Number of lines with modem control
FOR I←0,SCNNUM-1 <
XPRM(I,9600)		;PORTS 0:SCNNUM-1
>;FOR
 ↑NPORDM←←.-FPORDM ;number of consecutive DM ports, for WHOSER and LINBIT
;;Note: ACCT's DMNUM and (assuming TTY=port) SMERGE's DMLIN have NPORDM compiled in.
↑DLSNUM←←.-DCATAB
↑DCANUM←←.-DCATAB	;Total number of DCA ports in use, size of DCATAB table.

↑NNODLS:	0	;Number of DLS interrupts with invalid port number
>;IFN FTLLL

↑DCABEG←←.	;BEGINNING OF DATA AREA ZEROED BY DCAINI
↑NPORTD:	0		;Total count of interrupts from Down ports
↑NDCAER:	0		;Total count of framing/parity errors
↑NDCAIN:	0		;TOTAL COUNT OF DCA INTERRUPTS SEEN
↑CDCAIN:	0		;Copy of NDCAIN saved at clock tick, for avg'ing
↑KBDNXT:	0		;Microswitch kbd (not port number) to check next
↑FONTTY:	0		;TTY number of line to check next at CKFONE
↑NNOREP:	0		;Total count of interrupts with No Reply
↑NNOPOR:	0		;Total count of interrupts with illegal port nbr
↑DCAPIN:	BLOCK DCANUM	;Count of all interrupts per port
↑DCACIN:	BLOCK DCANUM	;Copy of DCAPIN at last "minute" point
↑DCAREC:	BLOCK DCANUM	;Recent interrupt count (in previous "minute")
↑DCAINN:	BLOCK DCANUM	;COUNT OF CHARACTERS INPUT FOR CH3 TRAP (shutdown)
↑DCAMIN:	BLOCK DCANUM	;COUNT OF MODEM INTERRUPTS
↑DCAOER:	BLOCK DCANUM	;COUNT OF OVERRUN ERRORS PER PORT
↑DCABER:	BLOCK DCANUM	;COUNT OF FRAMING/PARITY ERRORS PER PORT
↑KBDCHR:	BLOCK DCANUM	;Data for TTREAD, see bit defs in OUTER
↑DCAEND←←.-1	;END OF DATA AREA ZEROED BY DCAINI

↑MAXBER←←3	;Max nbr of framing errors on microswitch kbd before failing test

IFN FTDCHK,<
↑CHKDCA:	-1	;MANUALLY SET TO PORT NUMBER TO TYPE ITS STATUS ON CTY
>;IFN FTDCHK

BEND SCNDDB
;⊗ DILLIN DILTAC DILJ DILZBG DILJOB DILCNI DILIDS DCLKNM VDITOC VDISTS VDILST DILZND DILINN

;DIALER DATA AREA
BEGIN DILDAT

;AC SAVE LOCS
↑DILLIN:	0
↑DILTAC:	0
↑DILJ:		0

;THIS PART ZEROED AT DILINI
↑DILZBG←←.
↑DILJOB:	BLOCK DILNUM	;JOB # OF JOB OWNING THIS DIALER
IFE FTVDIL,<
↑DILCNI:	BLOCK DILNUM	;LAST CONI BITS FROM DILINT
↑DILIDS:	BLOCK DILNUM	;DILINT DISPATCH ADDRESS
>;IFE FTVDIL
IFN FTVDIL,<
↑DCLKNM:	0		;sequence nbr of clock req for dialer timeouts
↑VDITOC:	0		;number of dialer timeouts, for debugging
↑VDISTS:	0		;status of dialer, 0 for idle, else job,,dialer
↑VDILST:	BLOCK DILNUM	;last status for this dialer (char from adapter)
>;IFN FTVDIL
↑DILZND←←.-1

IFE FTVDIL,<
↑DILINN:	BLOCK DILNUM	;Max number of Dialer ints, FOR RUNAWAY CHECK
>;IFE FTVDIL

BEND DILDAT
;⊗ ADCDDB DACDDB KIMDDB SAMDDB RTJDDB DUMDSP

BEGIN DACDDB ↔ SUBTTL DACDDB - DDB FOR NEW AD/DA CONVERTER (JAM 2-5-74)

; DUMMY DEVICE SERVICE ROUTINES FOR DAC/ADC/KIM/SAM/RTJ

IFN FTSIX,<
	REPEAT DDBSKW-2,<0>
	ADCDDB+DEVIOS
	0
↑ADCDDB:SIXBIT /ADC/		;ADC ONLY.
	77*HUNGST,,0
	0			;IOS
	ADC.NX,,DUMDSP
	DVIN,,000001
	0
	0
	0
	0

	REPEAT DDBSKW-2,<0>
	DACDDB+DEVIOS
	0
↑DACDDB:SIXBIT /DAC/		;DAC ONLY.
	77*HUNGST,,0
	0			;IOS
	DAC.NX,,DUMDSP
	DVOUT,,000001
	0
	0
	0
	0

	REPEAT DDBSKW-2,<0>
	KIMDDB+DEVIOS
	0
↑KIMDDB:SIXBIT /KIM/		;KIM ONLY.
	77*HUNGST,,0
	0			;IOS
	KIM.NX,,DUMDSP
	DVIN,,000001
	0
	0
	0
	0

	REPEAT DDBSKW-2,<0>
	SAMDDB+DEVIOS		;DEVSPT
	0
↑SAMDDB:SIXBIT /SAM/		;SAM ONLY.
	77*HUNGST,,0
	0			;IOS
	SAM.NX,,DUMDSP
	DVIN,,000001
	0
	0
	0
	0

	REPEAT DDBSKW-2,<0>
	RTJDDB+DEVIOS		;DEVSPT
	0
↑RTJDDB:SIXBIT /RTJ/		;RTJ ONLY.
	77*HUNGST,,0
	0			;IOS
	RTJ.NX,,DUMDSP
	DVIN,,000001
	0
	0
	0
	0

	POPJ P,		;INITIALIZE
	POPJ P,		;HUNG TIME OUT
DUMDSP:	POPJ P,		;RELEASE
	POPJ P,		;CLOSE
	JRST ILLOUT	;OUTPUT ILLEGAL TOO
	JRST ILLINP	;INPUT ILLEGAL
	JRST CPOPJ1	;ENTER
	JRST CPOPJ1	;LOOKUP
	JRST ILLOUT	;DMP MODE OUTPUT
	JRST ILLINP	;DMP MODE INPUT
	POPJ P,		;USETO
	POPJ P,		;USETI
	POPJ P,		;UGETF
	JRST CPOPJ1	;RENAME
	POPJ P,		;CLOSE INPUT
	POPJ P,		;UTPCLR
	JRST UUOERR	;MTAPE
	JRST UUOERR
>;IFN FTSIX

BEND DACDDB
;⊗ SIXDDB SIXMDL SIXDLN SIXDAT SIXBKO SIXOUL SIXBKI SIXHD1 SIXHD2 SIXFSB SIXINL SIXSVA SIXSV1 SIXSEQ SIXFSL SIXNIW SIXFSD SIXNWW SIXNNF SIXTMF SIXFDW SIXILI SIXILO SIXN6B SIXNJE SIXNON SIXNME SIXNN6 SIXLME SIXFP SIXCLW SIXPDP SIXSVP SIXWTW SIXDTL SIXLDN SIXICN SIXIJM SIXOCN SIXOJM

BEGIN SIXDDB

IFN FTSIX,<

;MODEL DDB FOR SIX CONNECTIONS

DEFINE Z(NAME,VAL) <↑NAME←←.-SIXMDL ↔ VAL>

	REPEAT DDBSKW-2,<0>
	SIXMDL+DEVIOS		; DEVSPT
	DEVIBF!DEVSHR,,0	; DEVCMR
↑SIXDDB::			;FOR DDB CHAIN MACRO IN UNCDAT
↑SIXMDL:SIXBIT /SIX/
	3*HUNGST,,0		; BETTER HAPPEN WITHIN 3 SECONDS!
	0			;IOS (SET DEVSBB IN LH TO WAIT)
	SIX.NX,,SIXDSP
	DVOUT!DVIN!DVLNG,,140000
	0			; DEVLOG
	0			; DEVBUF
	0			; DEVIAD
	0			; DEVOAD
	0			; DEVFIL
	0			; DEVEXT
	Z(SIXIPL,0)		; INPUT LIST, <LAST BLOCK>,,<FIRST BLOCK>
	Z(SIXNI,0)		; NUMBER OF ENTRIES IN INPUT QUEUE
	Z(SIXNO,0)		; NUMBER OF ENTRIES IN OUTPUT QUEUE
				; SIXNO MUST BE LAST BECAUSE SIXSET USED IT
				;    TO CREATE DDBS WITH
↑SIXDLN←←.-SIXMDL+1

↑SIXDAT←←.
↑SIXBKO:0	; CURRENT OUTPUT IOWD
↑SIXOUL:0	; LIST OF BLOCKS TO BE OUTPUT
		; <ADR OF LAST BLOCK>,,<ADR OF CURRENT BLOCK>
		; NOTE THAT THIS CELL (NOT SIXBKO) IS USED TO TELL
		; IF THE INTERFACE IS RUNNING NOW.
↑SIXBKI:0	; CURRENT INPUT IOWD
↑SIXHD1:0	; INPUT HEADER WORD 1
↑SIXHD2:0	; INPUT HEADER WORD 2
↑SIXFSB:0	; CURRENT INPUT F.S. BLOCK
↑SIXINL:0	; INPUT LIST - READ AT CLOCK LEVEL

↑SIXSVA:0	; SAVED ACCUMULATOR OVER SHORT INTERRUPTS
↑SIXSV1:0	; SAVED ACCUMULATOR OVER SHORT INTERRUPTS

↑SIXSEQ:0	; OUTPUT-GOING SEQUENCE NUMBER

↑SIXFSL:20000	; FREE STORAGE LIMIT FOR INCOMING MESSAGES FROM SIX

; STUFF FOR WAITING FOR F.S. FROM INTERRUPT LEVEL

↑SIXNIW:0	; NUMBER OF TIMES WE HAD TO WAIT FOR F.S. AT I-LEVEL
↑SIXFSD:0	; DISPATCH ADDRESS WHEN F.S. IS AVAILABLE
↑SIXNWW:0	; NUMBER OF WORDS WE ARE WAITING FOR
		; (THIS CELL IS CHECKED AT CLOCK LEVEL)

; ERROR COUNTERS

↑SIXNNF:0	; NUMBER OF INPUT HEADER WORDS WITH NO 37TH BIT ON (ARE IGNORED)
↑SIXTMF:0	; GOT 37TH BIT ON IN SECOND WORD OF HEADER
↑SIXFDW:0	; 37TH BIT ON DATA WORD
↑SIXILI:0	; ILLEGAL RECEIVER INTERRUPT
↑SIXILO:0	; ILLEGAL TRANSMITTER INTERRUPT
↑SIXN6B:0	; INCOMMING MESSAGE WITHOUT F6TO10 BIT ON IN TYPE CODE
↑SIXNJE:0	; INCOMMING MESSAGE REFERRING TO NON-EX JOB NUMBER
↑SIXNON:0	; INCOMMING MESSAGE WITH ILLEGAL CODE OR FORMAT SOMEHOW
↑SIXNME:0	; NUMBER OF P3 MEMORY ERRORS DETECTED
↑SIXNN6:0	; NUMBER OF "NONSENSE" MESSAGES P3 HAS GIVEN US!

↑SIXLME:0	; LAST MEMORY ERROR CODE WORD

; DATA ASSOCIATED WITH WAITING FOR F.S. AT CLK LEVEL

↑SIXFP:0	; FIRST PD POINTER STORED HERE ON ENTERING SIXCLK
↑SIXCLW:0	; FLAG SAYING WE ARE WAITING FOR F.S.
↑SIXPDP:0	; SAVED COPY OF PD POINTER (MAKES PUSHACS AND POPACS WORK!)
↑SIXSVP:BLOCK CLKPLN	; SAVED COPY OF CLK-LEVEL PDL
↑SIXWTW:0	; NUMBER OF WORDS WE ARE WAITING FOR

; END OF DATA AREA

↑SIXDTL←←.-SIXDAT	; LENGTH OF DATA AREA

↑SIXLDN:0
	JRST SIXLD1	; JSR SIXLDN TO APPEND INPUT BLOCK ONTO LIST (SIXINL)

COMMENT ⊗
WE ALSO EXPECT THE FOLLOWING IN THE CH6 (OR WHATEVER) ROUTINES

SIXICN:	CONSZ SIX,1000	; ANY INPUT FOR US?
SIXIJM:	JRST SIXFSI	; YES, GO TO INPUT ROUTINE FOR FIRST WORD
SIXOCN:	CONSZ SIX,10	; ANY OUTPUT FOR US?
SIXOJM:	JRST SIXIER	; YES, GO TO OUTPUT INTERRUPT ROUTINE

WE ALSO EXPECT THE FOLLOWING IN CH7

	SKIPE SIXINL	; ANYTHING IN INPUT LIST?
	PUSHJ P,SIXCLK	; YES, GO SCAN IT.
	SKIPE SIXNWW	; WAITING FOR F.S.?
	PUSHJ P,SIXFSW	; YES, GO SEE IF IT IS COME YET
⊗

>;IFN FTSIX

BEND SIXDDB
;⊗ SAMDDB SAMDAT SAMDLN SAMCNA MASKB SAMSAV SAMSV1 SAMSV2 SAMPI SAMSTE SAMHON SAMLON SAMGAG SAMTII SAMTIC SAMOOP SAMCTA SAMCTB CIQLEN CIQ CIQAVL CIQIP CIQOP CIQFUL SAMMNW SAMDT SAMSEQ SAMDTL SAMLSA SAMLSD SAMLSW SAMLSX SAMPTB SAMDRB SAMWBG SOFLEN SAMCD SAMRD SAMWD

BEGIN SAMDDB

IFN FTSAM,<

;DDB FOR SYSTEMS CONCEPTS DIGITAL SYNTHESIZER

DEFINE Z(NAME,VAL) <↑NAME←←.-SAMDDB ↔ VAL>

	SAMDDB+DEVIOS		; DEVSPT
	DEVIBF,,0		; DEVCMR
↑SAMDDB::			;FOR DDB CHAIN MACRO IN UNCDAT
	SIXBIT /SAM/
	3*HUNGST,,0		; BETTER HAPPEN WITHIN 3 SECONDS!
	0			;IOS (SET DEVSBB IN LH TO WAIT)
	SAM.NX,,SAMDSP
	DVOUT!DVIN!DVLNG,,140000
	0			; DEVLOG
	0			; DEVBUF
	0			; DEVIAD
	0			; DEVOAD
	0			; DEVFIL
	0			; DEVEXT
↑SAMDAT←←.	; START OF AREA THAT IS CLEARED BY THE SYSTEM
	Z(SAMIPL,0)		; INPUT LIST, <LAST BLOCK>,,<FIRST BLOCK>
	Z(SAMNI,0)		; NUMBER OF ENTRIES IN INPUT QUEUE
↑SAMDLN←←.-SAMDDB+1

↑SAMCNA:0		; PLACE TO PUT THE CONI-A
↑MASKB:	0		; MASK FOR CONI-B ABOUT INTERRUPTS WE WANT TO SEE
;CONIB:	0		; PLACE TO PUT THE CONI-B
↑SAMSAV:0		; ACCUMULATORS SAVED AT INTERRUPT LEVEL
↑SAMSV1:0
↑SAMSV2:0
↑SAMPI:	0		; ERROR PI AT NONACT
↑SAMSTE:0		; Enable interrupt (message) on SAM stopped

IFN FTREAD,<
↑SAMHON:0		; NUMBER OF TIMES WE INTERRUPTED TO HI CHAN ROUTINES
↑SAMLON:0		; NUMBER OF TIMES WE INTERRUPTED TO LO CHAN ROUTINES
↑SAMGAG:0		; NUMBER OF TIMES TO LO CHAN WITHOUT GOOD CAUSE!
↑SAMTII:0		; TIME AT INTERRUPT
↑SAMTIC:0		; TIME AT CLOCK HANDLER
↑SAMOOP:0		; HOW MANY TIMES ABOVE TWO TIMES NOT CLOSE ENOUGH
>;FTREAD

↑SAMCTA:0		; COUNT DOWN FOR PE'S AND ME'S BETWEEN CLOCK TICKS
↑SAMCTB:0		; COUNT DOWN FOR I1-I5'S BETWEEN CLOCK TICKS

↑CIQLEN←←20		; NUMBER OF CONI'S WE WILL HOLD
↑CIQ:	BLOCK CIQLEN
↑CIQAVL:CIQLEN		; NUMBER OF ENTRIES AVAILABLE IN CIQ
↑CIQIP:	0		; POINTER (INDEX) TO PUT THINGS IN (INC AFTER DEPOSIT)
↑CIQOP:	0		; POINTER TO GET THINGS OUT (FETCH THEN INC)
↑CIQFUL:0		; NUMBER OF TIMES WE FOUND THE QUEUE FULL

↑SAMMNW:0		; NUMBER OF DATA WORDS IN INCOMING MESSAGE
↑SAMDT:	0		; FIRST DATA WORD IN INCOMING MESSAGE
↑SAMSEQ:0		; SEQUENCE NUMBER OF INCOMING MESSAGE
↑SAMDTL←←.-SAMDAT	; END OF EXPLICITLY ZEROED DATA AREA

↑SAMLSA:0		; ADDRESS OF PARITY ERROR
↑SAMLSD:0		; DATA WORD ON PARITY ERROR
↑SAMLSW:0		; USER'S WORD ON PARITY ERROR
↑SAMLSX:0		; XOR OF USER'S WORD AND DATA WORD
↑SAMPTB:0		; PARITY BIT

↑SAMDRB:60000		; SET DIAGNOSTIC READBACK ADDRESS FROM CONSOLE SWITCHES

; WCMA HANDLING STUFF
;*** NOTE: THESE THINGS ARE IN A VERY SPECIAL ORDER. THEY ARE
;*** INITIALIZED IN SAMINI BY BLT'TING ONE PRE-ASSEMBLED BLOCK INTO HERE
;*** IF YOU CHANGE ANYTHING HERE, YOU MUST CHANGE IT THERE TOO

↑SAMWBG←←.		; BEGINNING OF WCMA DATA AREA

; OFFSETS INTO DATA AREAS

;ACTIVE←←0	; ZERO OR BIT TO TEST FOR THIS KIND OF EXHAUSTED INTERRUPT
;QCNT←←1	; NUMBER OF UNUSED WC/CA'S AVAILABLE IN QUEUE
;QHEAD←←2	; FIRST,,LAST FOR WC/CA QUEUE
;QPNTR←←3	; POINTER INTO QUEUE, IOWD FOR COMMANDS
;WRTCHK←←4	; (READONLY) NON-ZERO IF WCMA NEEDS WRITE ACCESS, ZERO FOR READ
;EXHBIT←←5	; (READONLY) CONI-A BIT TO USE FOR ACTIVE
;ENAXE←←6	; (READONLY) CONO-B TO ENABLE WC EXHAUSTED INTERRUPTS
;CADOB←←7	; (READONLY) DATAO-B TO COMBINE WITH CORE ADDRESS
;WCDOB←←10	; (READONLY) DATAO-B TO COMBINE WITH WORD COUNT
;MXDONE←←11	; (READONLY) DONE MESSAGE TO SEND FOR EACH WC EXHAUSTED
;BPIOFF←←12	; (READONLY) SHIOFF OR SLOOFF
;BPION←←13	; (READONLY) SHION OR SLOON
;SCHAN←←14	; (READONLY) NOPIA!SHICHN OR NOPIB!SLOCHN
↑SOFLEN←←15


↑SAMCD:	BLOCK SOFLEN	; ORIGIN OF DATA AREA FOR COMMANDS
↑SAMRD:	BLOCK SOFLEN	; ORIGIN OF DATA AREA FOR READ DATA
↑SAMWD:	BLOCK SOFLEN	; ORIGIN OF DATA AREA FOR WRITE DATA


>;IFN FTSAM

BEND SAMDDB
;⊗ POLDDB POLDAT POLDLN

BEGIN POLDDB

IFN FTPOLY,<

;DDB FOR POLYCEPHALOS SIGNAL PROCESSOR (DAC/ADC)

DEFINE Z(NAME,VAL) <↑NAME←←.-POLDDB ↔ VAL>

	POLDDB+DEVIOS		; DEVSPT
	DEVIBF,,0		; DEVCMR
↑POLDDB::			;FOR DDB CHAIN MACRO IN UNCDAT
	SIXBIT /POL/
	3*HUNGST,,0		; BETTER HAPPEN WITHIN 3 SECONDS!
	0			;IOS (SET DEVSBB IN LH TO WAIT)
	POL.NX,,POLDSP
	DVOUT!DVIN!DVLNG,,140000
	0			; DEVLOG
	0			; DEVBUF
	0			; DEVIAD
	0			; DEVOAD
	0			; DEVFIL
	0			; DEVEXT
↑POLDAT←←.	; START OF AREA THAT IS CLEARED BY THE SYSTEM
	Z(POLXXX,0)		; [Example variable declaration]
↑POLDLN←←.-POLDDB+1

>;IFN FTPOLY

BEND POLDDB
;⊗ MTCDDB DLINK MTCENT MTCLPE MTCPER MTCENT MTCMIS MTDCMS MTCBKN MTCSSV MTCRET MTCLSR MTCNSR MTCNS2 MTCNS3 MTCNS4

IFN MTCNUM,<

BEGIN MTCDDB  --  DEVICE DATA BLOCK FOR MAG TAPES.
SUBTTL MTCDDB - J. SAUTER, STANFORD, MAG. TAPE DEVICE DATA BLOCKS

DEFINE CAT6'(A,B) <SIXBIT /A'B/>

DEFINE MTCDDX(UNIT) <
IFE FT8UNI,<
	REPEAT DDBSKW-2,<0>
>;IFE FT8UNI
IFN FT8UNI,<
	REPEAT DDBSKW-3,<0>	;SKEW ZEROES
	<UNIT>⊗PUNITP		;UNIT NUMBER
>;IFN FT8UNI
	.-DEVSPT+DEVIOS		;DEVSPT
IFE FTF2,<
	DEVLUP,,0
>;IFE FTF2
IFN FTF2,<
	DEVIBF!DEVLUP,,0
>;IFN FTF2
	ZZ ←←.
IFE UNIT,<
↑MTCDDB←.>
CAT(↑MTCDD,\UNIT)←.
	CAT6(MTA,\UNIT)
IFE FT8UNI,<
	=60*HUNGST,,MTSIZ+1+<UNIT>⊗PUNITP
>;IFE FT8UNI
IFN FT8UNI,<
	=60*HUNGST,,MTSIZ+1
>;IFN FT8UNI
	0
	IFE UNIT-(MTCNUM-1),<MTC.NX,,MTCDSP;>DLINK,,MTCDSP
	DLINK←←.-4
	DVMTA!DVIN!DVOUT!DVLNG,,154403
	0
	0
	0
	0
repeat 0,<
↑MTCENT←←.-ZZ	0	;ERROR COUNT FOR THIS UNIT:
			;0-8 = LOGN. P.E.
			;9-17 = LAT. P.E.
			;18-26 = ILL OP.
			;27-35 = DATA MISSED.
>;repeat 0
;Don't change the order of the next 5 cells (LPE,PER,ENT,MIS,DCMS), because
;Dart knows about this order for reporting types of errors.
↑MTCLPE←←.-ZZ	0	;error count for this unit: longitudinal parity error
↑MTCPER←←.-ZZ	0	;error count for this unit: lateral parity error
↑MTCENT←←.-ZZ	0	;error count for this unit: ill op
↑MTCMIS←←.-ZZ	0	;error count for this unit: tape drive missed data
↑MTDCMS←←.-ZZ	0	;error count for this unit: DC missed data

↑MTCBKN←←.-ZZ	0	;RECORD COUNTER
IFN FTF2,<
↑MTCSSV←←.-ZZ	0	;SAVED STATUS FROM LAST TAPE INTERRUPT
>;IFN FTF2
IFE FTF2,<
↑MTCRET←←.-ZZ	MTREDO	;re-read retry count for each record, user settable
↑MTCLSR←←.-ZZ	<-1>	;length of last "short" record read, for Dart retry hack
↑MTCNSR←←.-ZZ	0	;number of "short" records re-read for/Dart retry hack
↑MTCNS2←←.-ZZ	0	;number of "short" records seen during retries
↑MTCNS3←←.-ZZ	0	;number of "short" records seen repeatedly (?)
↑MTCNS4←←.-ZZ	0	;number of "short" records seen that are really short
>;IFE FTF2
>;DEFINE MTCDDX
;⊗ MTEOFF MTDEV DCWRD MISSED MTERCN MTREWN MTCMDP SVCNTR MTWCMA MDCSAV MTIDSP MTCUSR MTCRMX MTBLK MTBLKP MTTAC MTTAC1 MTCMAP MTDINT MTDIN2 MTQBG1 DCTMA1 DCLUZ1 DCCON1 DCMIS1 DCTMB1 MTSCN1 DCTMA4 DCLUZ4 DCCON4 DCMIS4 DCTMB4 MTSCN4 MTSCON MTERRA MTERRW F2MTMX F2MTBF

;More magtape data
	UNIT ←← MTCNUM-1
; THE FOLLOWING IS XLIST'ED OUT FOR YOUR READING CONVENIENCE
; IT ACTUALLY LOOKS LIKE THIS:
; REPEAT MTCNUM,<MTCDDX(UNIT)
;       UNIT ←← UNIT-1>
XLIST
	REPEAT MTCNUM,<MTCDDX(UNIT)
	UNIT ←← UNIT-1>
LIST

;TEMP CELLS AND CONTROL DATA
↑MTEOFF:	0	;EOF FLAG
↑MTDEV:		0	;XWD COMMAND,DDB ADDR
↑DCWRD:		0	;BLKO/BLKI POINTER FOR DC
↑MISSED:	0	;-1 IF DC DATA MISS FLAG IS SET.
↑MTERCN:	0	;ERROR COUNTER
↑MTREWN:	0	;UNITS REWINDING AND IN IOW -1=NONE, 0=ONE
↑MTCMDP:	0	;DUMP COMMAND LIST POINTER
↑SVCNTR:	0	;DUMP COMMAND IOWD NEG. WORD COUNT
↑MTWCMA:	0	;DUMP COMMAND BLKI/O POINTER IN CASE OF RETRY
↑MDCSAV:	0
↑MTIDSP:	0	;ADDRESS TO TRANSFER TO ON NEXT MAG TAPE INTERRUPT
↑MTCUSR:	0	;JOB NUMBER OF JOB WHO IS USING MT CONTROL. 0 IF FREE.
↑MTCRMX:	MTREDO	;maximum number of retries allowed on MTA drives

↑MTBLK:	BLOCK 200	;TABLE OF 2-PAGE (MAXIMUM) IOWDS FOR THIS COMMAND
↑MTBLKP:	0	;POINTER INTO MTBLK (MUST BE IMMEDIATELY AFTER MTBLK)
↑MTTAC:		0	;TEMP CELL FOR DC CHANNEL

↑MTTAC1:	0	;TEMP CELL FOR DC CHANNEL
IFE FTMPP2,<
↑MTCMAP:	0	;JBTMAP ADDRESS FOR CURRENT MT USER.
>;IFE FTMPP2


IFE FTF2,<
;;The interrupt channel does a JSR to here immediately, instead of doing
;;a BLKI/O as the interrupt instruction, because the latter apparently tickles
;;some KL microcode bug (on hardware page fault?) which ends up causing the
;;the system to jump to randomness when the old magtapes are in use.
;;This seems to have avoided the problem (although the problem has been
;;observed a few times since this code was created).
↑MTDINT:	0	;JSR here from interrupt in DC (DCT) channel
		CONSZ DC,1B26	;bit 26 says interrupt requested (DB RQ), should be on
		SKIPL DCWRD	;bugtrap -- should be IOWD here
		JRST MTDINE	;bug, maybe interrupt by non DC device in CH1
		;Compensate for KL-10 Model B microcode bug, where a BLKI may cause
		;an extra DATAI unless we do this.  (Avoids hardware page fail.)
		EXCH J,DCWRD	;Save AC, get DCWRD
		SETMM 1(J)	;Reference the word being input or output
		EXCH J,DCWRD	;Restore AC and DCWRD
↑MTDIN2:	JFCL		;BLKI/O DC,DCWRD goes here (instead of KLEPT+42)
		 JRST MTDCN1	;here when BLKI/O counted out
		JRST 12,@MTDINT ;data block not finished, dismiss interrupt

;;Avoid using BLKI/O as interrupt instruction because of KL microcode page trap bug.
;;↑MTDCND:	0	;JSR HERE WHEN BLKO/BLKI COUNTED OUT
;;		JRST MTDCN1
>;IFE FTF2

IFN FTMQBUG,<	↑MTQBUG:	0	;NON-ZERO TO ENABLE BUG TRAP 
		↑MTQBG1:	0	;NON-ZERO TO TRAP ON ADDR BREAK>

IFE FTF2,<
IFN FTDCBUG,<
;debugging information
↑DCTMA1:	0	;time of last IOWD run out
↑DCLUZ1:	0	;bits indicating sequence of wins/losses
↑DCCON1:	0	;remember final DC status
↑DCMIS1:	0	;number of losses
↑DCTMB1:	0	;last data miss
↑MTSCN1:	0	;save magtape coni on loss
↑DCTMA4:	0	;time of last IOWD run out
↑DCLUZ4:	0	;bits indicating sequence of wins/losses
↑DCCON4:	0	;remember final DC status
↑DCMIS4:	0	;number of losses
↑DCTMB4:	0	;last data miss
↑MTSCN4:	0	;save magtape coni on loss
↑MTSCON:	0	;remember MTS coni at last EOR
↑MTERRA:	0	;count all errors
↑MTERRW:	0	;count write errors
>;IFN FTDCBUG
>;IFE FTF2

IFN FTF2,<
PRINTX	Consider getting pages for MTA as needed.
↑F2MTMX←←=4096	;Max record size for F2 magtape, must fit in system buffer
↑F2MTBF:	BLOCK F2MTMX	;Buffer for holding one magtape record
>;IFN FTF2

	BEND MTCDDB

>;IFN MTCNUM
;⊗ MTUDDB DLINK MTURWN

IFN MTUNUM,<

BEGIN MTUDDB  --  device data block for PHYSIO mag tapes.
SUBTTL MTUDDB

DEFINE XX(NAME,DATA)<
↑NAME ←← .-ZZ
	DATA
>;DEFINE XX

DEFINE CAT6'(A,B) <SIXBIT /A'B/>

DEFINE MTUDDX(UNIT) <
IFE FT8UNI,<
	REPEAT DDBSKW-2,<0>
>;IFE FT8UNI
IFN FT8UNI,<
	REPEAT DDBSKW-3,<0>	;SKEW ZEROES
	<UNIT>⊗PUNITP		;UNIT NUMBER
>;IFN FT8UNI
	.-DEVSPT+DEVIOS		;DEVSPT
	DEVLUP,,0
	ZZ ←←.
IFE UNIT,<
↑MTUDDB←.>
CAT(↑MTUDD,\UNIT)←.
	CAT6(MTU,\UNIT)
IFE FT8UNI,<
	=60*HUNGST,,MTSIZ+1+<UNIT>⊗PUNITP
>;IFE FT8UNI
IFN FT8UNI,<
	=60*HUNGST,,MTSIZ+1
>;IFN FT8UNI
	0
	IFE UNIT-(MTUNUM-1),<MTU.NX,,MTUDSP;>DLINK,,MTUDSP
	DLINK←←.-4
	DVMTA!DVIN!DVOUT!DVLNG,,154403
	0
	0
	0
	0
XX(MTUBKN,0)		;RECORD COUNTER
GLOBAL IRBLEN		;GRRR
XX(MTUIRB,BLOCK IRBLEN)	;space for IORB for PHYSIO
XX(MTUDMD,0)		;current mode (core dump, indust compat, hi dens)
XX(MTUMDP,0)		;dump mode command pointer
XX(MTUOC,0)		;record's original data transfer count given by user program
XX(MTUCFS,0)		;address of FS containing CCW list
XX(MTULMT,0)		;function number of last MTAPE started
>;DEFINE MTUDDX

;For use in PHYSIO and/or PHYDAT:
EXTERN MTUCFS, MTUIRB, MTUOC, MTUDMD

;Misc storage (not in DDB).
↑MTURWN:-1		;count of jobs waiting for rewind

;Here we actually define the MTU DDB(s).
	UNIT ←← MTUNUM-1
	REPEAT MTUNUM,<MTUDDX(UNIT)
	UNIT ←← UNIT-1>

BEND MTUDDB

>;IFG MTUNUM
;⊗ SPWA SPWSAC USRSAC SPWBUT SPWACT SPWGO JBTST2

BEGIN SPWDAT -- DATA FOR SPACEWAR
SUBTTL SPWDAT - JAM, STANFORD, 7-NOV-68, DATA FOR SPACEWAR SERVICE


↑SPWA:	BLOCK 20	;P1 SYSTEM ACCUMULATORS SAVED DURING SPW
NOKL10,<
↑SPWSAC:BLOCK 20	;USER'S SPW ACCUMULATORS SAVED HERE DURING UUO
>;NOKL10
IFN FTF2,<
↑USRSAC:BLOCK 20	;USER-LEVEL ACS SAVED HERE DURING SPW RUN
>;IFN FTF2

↑SPWBUT:0		; SPACEWAR BUTTONS
↑SPWACT:0		; FLAG MEANING A SPACEWAR JOB EXISTS

;WARNING! DON'T CHANGE POSITION OF SPWGO,JBTST2 - SEE SPWINI - REG
↑SPWGO:	BLOCK	JOBN
↑JBTST2:BLOCK	JOBN

;SPWGO fields
;Bits 0 to JOBNSZ-1 are link to next SPW job (SPWGO+0 is header).
;Bits 10:13 are number of ticks to next activation
;Bits 14:17 are number of ticks between activation (specified by user)
;RH is user address at which to start SPW process.

;Now make sure the job link field doesn't overlap the two tick fields.
IFG JOBNSZ+4+4-=18,<.FATAL JOBNSZ is too big for SPWGO tick fields.>

	BEND SPWDAT
;⊗ SCHMQT JOBQUE CPFAC1 CPFAC2 BTSIZ BTTIM SCHBEG JLCYET JLFACTOR RJLFACTOR OINTIME OUTIME JLRIT ORDYET JBTPRI JBTNPR JBTPL JBTJL JBTJLH JBTICP SCHEND GCBITS JBTQ JBTSCS SWPCHK SWPCH2 SWPJMX SWPMXP SWPLMX SWPLMJ JBTSWP JB2SWP CORPTR FINISH FORCE FIT XPANDF FULCNT SEGWAIT MAXSIZ MAXJBN MAXRSZ MAXRJB MAXSSZ MAXSJB SUMCOR NEEDED LASTIN ESEGNO AVALTB CALLTB

;SCHEDULER DATA AREA . . .
BEGIN SCHDAT
SUBTTL	SCHDAT 11 SEPT 67 SCHEDULER DATA AREA

;SCHEDU DATA


↑SCHMQT:	QQMQT
↑JOBQUE:	BLOCK JOBN	; MINUS THE QUEUE NUMBER THE JOB IS IN
; TABLES FOR JOB PRIORITY CALCULATIONS

↑CPFAC1:	1⊗=8		;1/4 TICK PER PAGE
↑CPFAC2:	=30⊗=10		;PLUS 30 TICKS FOR OVERHEAD

↑BTSIZ:		=80		;80 PAGES IS THRESHOLD FOR BATCH CONSIDERATION
↑BTTIM:		=15*=60		;15 SECONDS RUNTIME SINCE LAST INTERACTION

↑SCHBEG:			;HERE TO SCHEND ZEROED BY NXTINI
↑JLCYET:	0
↑JLFACTOR:	0		;JLFACTOR/JLTIME = USEFUL PROCESSOR LEVEL
↑RJLFACTOR:	0		;RECIPROCAL JLFACTOR
↑OINTIME:	0		;HERE WE SAVE INTIME+P1PID FROM LAST JLCAL CYCLE
↑OUTIME:	0		;HERE WE SAVE UPTIME+P1PID FROM LAST JLCAL CYCLE
↑JLRIT:		0		;RECENT INTERUPT FRACTION *1000
IFN FTPRIQ,<
↑ORDYET:	0
↑JBTPRI:	BLOCK JOBN	; JOB'S PRIORITY
↑JBTNPR:	BLOCK JOBN	; JOB'S NEW PRIORITY
↑JBTPL:		BLOCK JOBN	;time-weighted processor level this job has used
>;IFN FTPRIQ
↑JBTJL:		BLOCK JOBN	; POINTER TO FS TABLE OF INSTANTANEOUS JOB LOAD
↑JBTJLH:	BLOCK JOBN	; OLDEST JOB LOADING.
↑JBTICP:	BLOCK JOBN	;IN-CORE PROTECT TIME
↑SCHEND←←.-1

↑GCBITS:	BLOCK 2		;BIT TABLE FOR GCMCK ROUTINE

; QUEUE TABLES . . .
		BLOCK MXQUE
↑JBTQ:		BLOCK JOBN

; SWAPPER TABLES . . .

IFN FTSWPC!FTUPCLB,<
↑JBTSCS:	BLOCK JOBN	;JOB CHECKSUM BEFORE BEING SWAPPED
>;IFN FTSWPC!FTUPCLB
IFN FTSWPC,<
↑SWPCHK:	0		;SET NON-ZERO TO CHECKSUM JOBS
↑SWPCH2:	0		;SET NON-ZERO TO CHECKSUM AFTER SWAPOUT TOO
>;IFN FTSWPC

↑SWPJMX:	0
↑SWPMXP:	0
↑SWPLMX:	0
↑SWPLMJ:	0
↑JBTSWP:	BLOCK JOBN	;LH IS JOB NUMBER IF SWAPPING ON THE SWAPPING PACK
				;(FTNSWP=0).  IT IS 400000 + FIRST SWAPPING BAND
				;(INDEX INTO SWBAND) IF SWAPPING ON THE FILE PACKS
				;(FTNSWP=1)
				;18-26 IMGOUT (SIZE OF CORE IMAGE ON DISK)
				;27-35 IMGIN (IN CORE IMAGE SIZE)
↑JB2SWP:	BLOCK JOBN	;LH UNUSED
				;30-35 DATA DISC CHANNEL LIST.
				;26-29 RETRY COUNT FOR SWPCHK
				;18-25 CORE SIZE FOR SWPCHK AT SWAPOUT TIME
;LEAVE NEXT LOCS IN ORDER FOR WHO
↑CORPTR:	0
↑FINISH:	0		;FINISH,FORCE,FIT AND XPANDF ARE FLAGS IN SWAP
↑FORCE:		0		; NUMBER OF THE JOB THAT WILL GO OUT NEXT
↑FIT:		0		; NUMBER OF THE JOB THAT WILL COME IN NEXT
↑XPANDF:	0
↑FULCNT:	0		;PRINT DISK IS FULL EVERY 30 SECONDS
↑SEGWAIT:	0		; NUMBER OF JOB WAITING FOR UPPER SEGMENT
↑MAXSIZ:	0		;SIZE OF LARGEST JOB WHICH MIGHT BE SWAPPED OUT
↑MAXJBN:	0		;NUMBER OF THAT JOB
↑MAXRSZ:	0		; SIZE OF LARGEST RUNNABLE JOB
↑MAXRJB:	0		; JOB NUMBER OF LARGEST RUNNABLE JOB.
↑MAXSSZ:	0		; SIZE OF LARGEST SEGMENT.
↑MAXSJB:	0		; JOB NUMBER OF LARGEST SEGMENT.
↑SUMCOR:	0		; THE SWAPPER TOTALS THE CORE SIZES OF THE JOBS
				; IT IS CONSIDERING FOR SWAPOUT AND PUTS THAT TOTAL HERE
↑NEEDED:	0		;THE AMOUNT NEEDED TO SWAP JOB IN FIT IN
↑LASTIN:	0		;NUMBER OF LAST JOB SWAPPED IN

IFN FTELOK,<
↑ESEGNO:	0		;SEGMENT NUMBER OF E UPPER SEGMENT, 0 IF NONE
>;IFN FTELOK


;SHARABLE DEVICE JUST BECOME AVAILABLE(EXTENDED TO OTHER QUEUES TOO)
;APPROPRIATE ENTRY IS SET NON-ZERO WHEN SCHEDULER SHOULD LOOK
;AT THAT QUEUE TO FIND A JOB TO RUN
;WSAVAL CONTAINS THE NO. OF JOBS WITH IO WAIT SATISFIED(0=NONE)

DEFINE X!(A)
<
↑A!AVAL:	0
>

↑AVALTB:	QUEUES		;GENERATE THE AVAL FLAGS

;AFTER A JOB NUMBER IS PICKED FROM A QUEUE AND PLACED IN RUNQ, ITS CALLTB
;FLAG IS SET.  AT SETSTP, IF THIS FLAG IS SET FOR A JOB, THAT JOB IS REQUEUED
;TO THE WAIT QUEUE THAT IT CAME FROM, AND THE CALL IS PROCESSED.  THE FLAG IS
;CLEARED WHEN THE JOB IS RUN.
DEFINE X (A)
<0>

↑CALLTB:	QUEUES
;⊗ REQTAB QJOB XJOB SQREQ SQREQ1 SERA SWPCNT SERACT CORMX CORHMX ISONE

;SHARABLE DEVICE REQUEST TABLE(GENERALIZED FOR OTHER QUEUES TOO)
;CONTAINS THE NUMBER OF JOBS WAITING TO USE SHARBLE DEVICE
;WSREQ AND RNREQ ARE UNUSED

DEFINE X!(A)
<↑A!REQ:	0
>

↑REQTAB:	QUEUES	;GENERATE REQ TABLE

;WORDS USED TO "REMEMBER" JOB NUMBERS
;BITS 35--9 CORRESPOND TO JOB NO'S 1--27


↑QJOB:	BLOCK JOBN	;Q TRANSFERS AT OTHER THAN CLOCK LEVEL
↑XJOB:	BLOCK JOBN	;CORE EXPANSION BY SWAPOUT-IN

;DATA AND STORAGE AREA USED FOR SWAPPING.

↑SQREQ:	0			;C(LH)=NEG. OF SIZE OF READ/WRITE
				;C(RH)=LOC. OF FIRST WORD TO READ/WRITE
IFN FTNSWP,<
↑SQREQ1:0			;COPY OF SQREQ FOR SQGOX
>;IFN FTNSWP
↑SERA:	0			;SIGN IS 1 IF A READ
				;C(RH)=BLOCK NUMBER BEFORE READING,
				;    ERROR BITS AFTER READING.
↑SWPCNT:	0		;SWAPPER COUNTER.  WHEN LEQ 0, RESET TO
				;INITIAL VALUE AND RUN SWAPPER.
↑SERACT:	0			;COUNTER FOR ERRORS
↑CORMX:		0			; MAXIMUM CORE AVAILABLE TO LOSERS
↑CORHMX:	0			;WORDS ABOVE FSLIMIT AVAILABLE TO USERS
↑ISONE:		0			; BOOLEAN SAYING THERE IS A JOB WHICH CAN FIT IN WITH THIS UPPER

XP CONVMD,3
	;CONVERSION FROM 1K CORE BLOCKS TO DISK BLOCKS
	;(SHIFT COUNT)
	BEND SCHDAT
;⊗ SYSTOP SYSPAG CORNXM CORBEG CORTAB LOFREE HIFREE HIUSED FSTOP FSPAG LOKTOT CORMAX USRMAX HIFSEV HIFSBG COREND %SWPL SWAPLI JBTPLN ARMBEG ARMBEG ARMLEN MEMCON LMEMCON MEMNXT

SUBTTL	DATA AREA FOR CORE MANAGEMENT SYSTEM

SYSTOP:	0		;NUMBER OF WORDS IN SYSTEM, FIRST WORD OF FREE STORAGE
SYSPAG:	0		;NUMBER OF PAGES IN SYSTEM, FIRST PAGE OF FREE STORAGE
CORNXM:	0		;-1 IF PROCEED FROM UNEXPECTED NXM

CORBEG←←.		;HERE TO COREND ZEROED BY CORINI

CORTAB←←CST		;1 WORD PER PAGE OF MEMORY

LOFREE:	0		;NUMBER OF FREE PAGES BELOW FSLIMIT
HIFREE:	0		;NUMBER OF FREE PAGES ABOVE FSLIMIT
HIUSED:	0		;NUMBER OF PAGES USED BY USERS ABOVE FSLIMIT
FSTOP:	0		;FIRST WORD NOT USED BY FREE STORAGE (FIRST USER WORD)
FSPAG:	0		;FIRST PAGE NOT USED BY FREE STORAGE (FIRST USER PAGE)
LOKTOT:	0		;TOTAL NUMBER OF LOCKED IN PAGES (ABOVE FSLIMIT)
CORMAX:	0		;TOTAL NUMBER OF WORDS ABOVE FS (NOT INCLUDING IO PAGES)
USRMAX:	0		;MAXIMUM NUMBER OF WORDS IN A USER JOB
IFN FTHIFS,<
HIFSEV:	0		;NEXT EXEC VIRTUAL PAGE NUMBER TO BE USED FOR HIGH FS
HIFSBG:	0		;FIRST EXEC VIRTUAL PAGE NUMBER USED FOR HIGH FS
>;IFN FTHIFS
COREND←←.-1		;END OF AREA ZEROED BY CORINI

↓%SWPL←←=256*2000	;SWAPPING LIMIT - MAX JOB SIZE
SWAPLI:	%SWPL		;CORE CELL WITH SWAPPING LIMIT SET.
↓JBTPLN←←156		;SIZE OF JOB PDL HELD IN FREE STORAGE.
			;SOME OF THE JOBPDL IS RESERVED FOR JOBDATA AREA

;MEMORY CONFIGURATION TABLE
;EACH ENTRY CORRESPONDS TO A LOCATION THAT IS EXPECTED TO EXIST

DEFINE MEMWDS<

IFN FTF2,<
XX(100,F2)
XX(101,F2)
XX(102,F2)
XX(103,F2)
XX(40100,F2)
XX(400100,F2)
XX(440100,F2)
IFG PHYMEM-400,<
XX(1000100,F2)
XX(1040100,F2)
XX(1400100,F2)
XX(1440100,F2)
>;IFG PHYMEM-400
>;IFN FTF2

IFE FTF2,<
XX(100,MG-10)
XX(101,MG-10)
XX(102,MG-10)
XX(103,MG-10)
XX(40100,MG-10)
XX(400100,MG-10)
XX(440100,MG-10)

IFN FTARM10M,<
IFN FTMGS,<
↓ARMBEG←←1000000	;For CORINI in case of parity errors: beginning ARM address
>;IFN FTMGS
IFE FTMGS,<
↓ARMBEG←←0		;For CORINI in case of parity errors: beginning ARM address
>;IFE FTMGS
↓ARMLEN←←10000000	; ditto, length of ARM-10M memory
XX(1000100,ARM10M)
XX(1000101,ARM10M)
XX(1000102,ARM10M)
XX(1000103,ARM10M)
XX(3000100,ARM10M)
XX(4000100,ARM10M)	;let's be sure to check P2 memory!
XX(5000100,ARM10M)
XX(7000100,ARM10M)
XX(7000101,ARM10M)
XX(7000102,ARM10M)
XX(7000103,ARM10M)
IFN FTMGS,<
XX(10400100,ARM10M)
XX(10400101,ARM10M)
XX(10400102,ARM10M)
XX(10400103,ARM10M)
>;IFN FTMGS
>;IFN FTARM10M
>;IFE FTF2

>;DEFINE MEMWDS

DEFINE XX(A,B)<
IFGE <A⊗-9>-GOODPG,<.FATAL MEMWDS/MEMCON addr: A is inconsistent with GOODPG from OUTER>
	A
>

MEMCON:	MEMWDS
LMEMCON←←.-MEMCON

DEFINE XX(A,B)<
	[ASCIZ /B LOC A/]
>

MEMNXT:	MEMWDS
;⊗ FSNINIT FSHINIT HFSPAG TSHF TRIVIAL NFSB FSBEG FSCNT FSLIST JBTPDL FSCLKF FSGVKF FSRTL FSNEWK FSCKCT FSBUSY HFSBSY FSHCLK FSHJOB HFSAVB FSAVB FSHOFS FSRPQ FSBLUZ FSNCLK FSIPTR FSOPTR FSHUNG FSGTUF SPFSNT FSMPLH FSEND FSLIMIT FSLIM1 FSLIM9 FSVBXX

SUBTTL	FREE STORAGE PARAMETERS
FSNINIT←←1		;NUMBER OF K TO CLAIM INITIALLY
IFN FTHIFS,<
IFE FTIP,<
HFSPAG←←4		;NUMBER OF HIGH FS pages TO CLAIM INITIALLY
>;IFE FTIP
IFN FTIP,<
↓HFSPAG←←<TOPHIP-FSLIMP> ;Pages of possible HiFS, claimed initially for "IMP buffers"
>;IFN FTIP
>;IFN FTHIFS
TSHF←←3			;COARSENESS OF FREE STORAGE (EXPONENT OF 2)
↓TRIVIAL←←1⊗TSHF	;SIZE OF MINIMUM BLOCK
NFSB←←20		;NUMBER OF DISTINGUISHABLE BLOCK SIZES
FSBEG←←.		;ADDRESS TO ZERO AT FSINI
FSCNT:	0		;COUNT OF PEOPLE WAITING FOR F.S.
FSLIST:	BLOCK	JOBN	;AND THEIR JOB NUMBERS
JBTPDL:	BLOCK	JOBN	;PDL POINTER FOR UUO PDL FOR EACH JOB
FSCLKF:	0		;FLAG TO THE SWAPPER THAT FS IS EXPANDING
FSGVKF:	0		;FLAG TO SAY LOOK FOR A K TO GIVE BACK
FSRTL:	0		;LIST OF BLOCKS TO BE RETURNED
FSNEWK:	0		;SET TO -1 WHEN MERGING IN A NEW 1K CHUNK
FSCKCT:	0		;COUNT TICKS UNTIL COMPUTING CHECKERBOARDING
FSBUSY:	0		;AMOUNT OF FS THAT'S IN USE RIGHT NOW.
IFN FTHIFS,<
HFSBSY:	0		;IN USE COUNT FOR HIFS
FSHCLK:	0		;SET TO N TO REQUEST N HIGH FS PAGES FROM CLK LVL
FSHJOB:	0		;SET TO N WHEN JOB N IS BEING SWAPPED OUT FOR HIGH FS
HFSAVB:	BLOCK	2*NFSB	;BASES FOR LISTS OF HIGH FS BLOCKS
>;IFN FTHIFS		;MUST COME BEFORE FSAVB!!
FSAVB:	BLOCK	2*NFSB	;BASES FOR LISTS OF FREE BLOCKS
IFN FTHIFS,<
FSHOFS←←FSAVB-HFSAVB	;OFFSET BETWEEN LOW AND HIGH FS LIST HEADS
>;IFN FTHIFS
FSRPQ:	BLOCK	NFSB	;COUNT OF FS REQUESTS BY SIZE
FSBLUZ:0		;COUNT NUMBER OF TIME FSBUSY IS FUCKED UP.
FSNCLK:	0		;SET WHEN YOU NEED FSCLK CALLED.
			;OR OF FSRTL,FSCLKF, AND FSGVKF
FSIPTR:	FSLIST		;POINTER TO ADD JOBS TO FSLIST
FSOPTR:	FSLIST		;POINTER TO TAKE JOBS FROM FSLIST
FSHUNG:	0		;SET TO -1 TO INDICATE A DISASTER.
FSGTUF:	0		;FLAG FOR SPECIAL FSGET
SPFSNT:	0		;TOTAL # SPARES NEEDED
FSMPLH:	0		;LIST HEADER FOR 512-WORD FREE PAGE MAP BLOCKS
FSEND←←.-1		;END OF BLOCK ZEROED BY FSINI

;FSMAXP←←=200		;MAXIMUM POSSIBLE NUMBER OF PAGES OF FREE STORAGE
FSLIMIT:	0	;PAGE NUMBER OF FIRST PAGE THAT CAN'T BE FREE STORAGE
FSLIM1:		0	;FSLIMIT-1
FSLIM9:		0	;FSLIMIT⊗9
IFN FTFSAVBUG,<
FSVBXX:	0
	SYSPIFF
	JRST FSVBXY
>;IFN FTFSAVBUG
;⊗ SFSIZE SFLINK SPFSN SFLOSS LSBK SFNWT NSPLN SFHEAD DDFS TTYFS DHFS LPFS PPFS IMPFS BIBFS FMBFS SDBFS RHDBFS DPYFS

;SPARE LIST CONTROL BLOCKS
;FORMAT OF SPARE LIST HEADER

		;WD0 LIST HEADER
SFSIZE←←1	;B0 AVOID REG FS, 1-8 # TO KEEP, RH SIZE
SFLINK←←2	;HEADER LINK (BOTH WAYS)
SPFSN←←3	;# SPARES CURRENTLY NEEDED
SFLOSS←←4	;LH TYPE (TEXT) RH LOSS COUNT
LSBK←←5		;length of each spares control block
		;LSBK is used to simplify assembly of the links in the control
		;blocks, which blocks must therefore be consecutive, as done below.

SFNWT←←200000	;PREVENTS WAITING AT UUO LEVEL
IFN FTHIFS,<SFHI←←100000>	;SAYS HIGH CORE FS IS OK (NOT FOR KA-10 USE)
IFE FTHIFS,<SFHI←←0>

NSPLN←←3	;# SPARES OF STUFF ALLOC PER LINE

SFHEAD:	DPYFS,,DDFS	;THE HEADER HEADER

DDFS:	0		;DD Q BLOCKS
	400000+NDDSPQ⊗9,,QLENGT
	TTYFS
	0
	[ASCIZ /DATA DISK QUEUE/],,

TTYFS:	0		;TTY DDBS
	NSPLN⊗9,,SCNDDS+DDBSKW+1
	DDFS,,DHFS
	0
	0

DHFS:	0		;DPY HEADERS
	NSPLN⊗9,,DPYLEN
	TTYFS,,LPFS
	0
	0

LPFS:	0		;LINE PNTR TABLES
	NSPLN⊗9,,=80
	DHFS,,PPFS
	0
	0

PPFS:	0		;PAGE PRINTER INITIAL BLOCKS
	NSPLN*2⊗9,,BLKSIZ	;2 OF THESE PER PP
	LPFS,,PPFS+LSBK
	0
	0

IFN FTIP,<
IMPFS:	0		;IMP DDBs
	NSPLN⊗9,,IMPDLN
	IMPFS-LSBK,,BIBFS
	0
	0

BIBFS:	0		;BIBs for IP (one BIB per stream)
	NSPLN*10⊗9,,BIBLEN↑
	IMPFS,,FMBFS
	0
	0

FMBFS:	0		;FMBs for TCP (Future Message Blocks)
	NSPLN*4⊗9,,FMBLEN↑
	IMPFS,,FMBFS+LSBK
	0
	0
>;IFN FTIP

IFN FTRH,<
SDBFS:	0		;SDBs for RH structures
	NSSDB⊗9,,ST.LEN↑
	SDBFS-LSBK,,RHDBFS
	0
	[ASCIZ /RH disk SDB/],,

RHDBFS:	0		;DDBs for RH disk
	NSSDB⊗9,,RHDBSZ
	SDBFS,,RHDBFS+LSBK
	0
	[ASCIZ /RH disk DDB/],,
>;IFN FTRH

DPYFS:	0		;RANDOM DPYSER DATA
	BLKSIZ
	DPYFS-LSBK,,0	;make this the last spares block
	0
	0

;NOTE: The last control block above is not under any assembly switch,
;so that it will always be the last one and the others will always have
;non-zero forward pointers.  This simplifies the text for the assembling
;of the pointers (which use LSBK, the length of a control block).
;⊗ TVBLEN TVDDB TVBUF TVBUFP TVMARG TVARGS IOPCNI IOPBSY IOPHCT IOPWCM

IFN TVNUM,<	;Whole page

BEGIN TVDDB -- TV CAMERA DEVICE DATA BLOCK
SUBTTL TVDDB - J. SAUTER, STANFOR, 25-FEB-68, TV CAMERA DEVICE DATA BLOCK

IFN FTTVBUF,<
;525 scanlines of 286 pixels each,for 16,800 words max TV picture
↑TVBLEN←←=525*<1+=286/9> 	;Max number of words per TV input (1 for round up)
>;IFN FTTVBUF


	REPEAT DDBSKW-2,<0>	; EXTRA STANDARD DDB WORDS
	TVDDB+DEVIOS		;DEVSPT
	IFN FTTVBUF,<DEVIBF!>DEVLUP,,0
↑TVDDB:	SIXBIT /TV/
	2*HUNGST,,0
	0			;TVIOS, NOT USED.
	TV.NX,,TVDSP
	DVTV!DVIN!DVLNG,,100000
	0
	0
	0
	0
	0
	0
	0			;DEVACC
	0			;DEVCNT
	0			;DEVBLK
	0			;DEVBKO
	0			;DSKBUF
	0			;DSKCNT
	0			;SETCNT
IFN FTTVBUF,<
IFE FTTVFS,<
↑TVBUF:	BLOCK TVBLEN
>;IFE FTTVFS
>;IFN FTTVBUF

IFN FTTVFS,<
↑TVBUFP:0			;POINTER TO TV BUFFER
↑TVMARG:30			;WORDS OF PROTECTION LEST TV DROP ADDR BITS
>;IFN FTTVFS

↑TVARGS:	BLOCK 3		;COPY OF ARGUMENTS TO INPUT UUO
↑IOPCNI:	0		;CONI FROM TV AT TVIN1
↑IOPBSY:	-1		;IOP DISPATCH ADDRESS
↑IOPHCT:	0		;HUNG TIMEOUT COUNT.
↑IOPWCM:	0		;IOP WCMA FOR PARITY ERROR, DATA MISS.

BEND TVDDB

>;IFN TVNUM	;Whole page
;⊗ ELFDDB ELFLOC ELFDLN ELFCUR ELFDDB ELFLOC ARMDDB GRNDDB

IFN ELFNUM <SUBTTL ELFDDB - PDP-11 BARE MACHINE MODE
BEGIN ELFDDB - 7 MAY 74 BO; made sharable MAY 1980 by ME.

REPEAT DDBSKW-2,<0>
		ELFDDB+DEVIOS		;DEVSPT
		DEVSHR!DEVIBF!DEVLUP,,0	;It sort of has an internal buffer
↑ELFDDB:	SIXBIT /ELF/		;(at least, it doesn't set IOACT).
		0
		0
		ELF.NX,,ELFDSP
		DVOUT+DVIN+DVLNG,,140000 ;Dump mode only for now.
		0
		0
		0
		0
↑ELFLOC:	0			;ELFSER defines its variables
		0			;in terms of ELFLOC.
		0
		0
		0		;ELFRQ, for debugging
↑ELFDLN←←.-ELFDDB+DDBSKW

↑ELFCUR:	0		;Job,,DDB of current ELF interlock user

BEND ELFDDB
↓ELFDDB←ELFDDB
↓ELFLOC←ELFLOC

IFG ARMNUM,<
	REPEAT DDBSKW-2,<0>
	ARMDDB+DEVIOS
	0
↑ARMDDB:SIXBIT /ARM/		;INTERLOCK DEVICE ONLY.  DOES NO I/O.
	77*HUNGST,,0
	0			;IOS
	ARM.NX,,ARMDSP
	DVOUT,,000001
	0
	0
	0
	0

	REPEAT DDBSKW-2,<0>
	GRNDDB+DEVIOS
	0
↑GRNDDB:SIXBIT /GRN/		;INTERLOCK DEVICE ONLY.  DOES NO I/O.
	77*HUNGST,,0
	0			;IOS
	GRN.NX,,ARMDSP		;uses same no-op dispatch table as ARM
	DVOUT,,000001
	0
	0
	0
	0
>;IFG ARMNUM

>;IFN ELFNUM
;⊗ FSCSZ NFSCSZ FSCFLG FSCADR FSCCNT BATMAN BATLEN ROBIN ALFRED GORDON BATCAR BATYET BATPNT PRIJOB PRIEXT NSPLRS

BEGIN APRDAT	↔	SUBTTL	APRDAT 7 NOV 68	APRSER DATA

IFN FTFSCALL,<
FSCSZ←←40
↑NFSCSZ←←-FSCSZ
↑FSCFLG:	0
↑FSCADR:	BLOCK FSCSZ
↑FSCCNT:	BLOCK FSCSZ
>;IFN FTFSCALL

;Phantom definitions.  Zero in either BATMAN or ROBIN means no run!
;Args to PHANTM macro:
;	JobName,PPN,Privs,SpoolExtension,PrinterName
;Last two args define a spooler if SpoolExtension is nonzero (see PRINAM).

DEFINE PHANTS<
REPEAT NFIRES,<
	PHANTM(0,0,0,0,0)	;Nonstandard phantoms, must be first
>;REPEAT NFILES
	PHANTM('[ONCE]','  1  2',<ACWPRV!DEVPRV!LUPPRV,,0>,0,0)
				;System startup helper.  ACW for payday
	PHANTM('<RMND>','RMDSYS',<REAPRV!WRTPRV!LUPPRV,,0>,0,0)
				;Reminder
	PHANTM('BELLS ','RMDSYS',<ACWPRV!LUPPRV,,0>,0,0)
				;Bells on CTY, DAY.TXT, ACW for payday
IFN FTHG,<
	PHANTM('*-HG-*',' HGSYS',<ACWPRV!LUPPRV,,0>,0,0)
				;Statistics gatherer (diddles HGYET)
>;IFN FTHG
	PHANTM('*SPY* ','ACTSYS',<REAPRV!PROPRV!MESPRV!LUPPRV,,0>,0,0)
				;Accounting (privs for autologout)
	PHANTM('*-SL-*',' SLSYS',<SSLPRV!LUPPRV,,0>,0,0)
				;Service level monitor
IFN FTCCRMA,<
	PHANTM('FONDLE','  FACT',<LUPPRV,,0>,0,0)
				;Personnel file mangler
>;IFN FTCCRMA
IFN FTLLL,<
	PHANTM('FONDLE','PERACT',<LUPPRV,,0>,0,0)
				;Personnel file mangler
>;IFN FTLLL
	;(SAIL runs PEOPLE in a batch job, not FONDLE phantom.)
IFE FTCCRMA,<
	PHANTM('DSKACT','DSKACT',<REAPRV!LUPPRV,,0>,0,0)
				;Disk accounter
>;IFE FTCCRMA
IFN FTIP,<
	PHANTM('[RSLV]','NETSYS',<LUPPRV,,0>,0,0)
				;Domain name resolver
>;IFN FTIP
IFN PUPNUM,<
	PHANTM('PUPSRV','NETSYS',<ACWPRV!LUPPRV,,0>,0,0)
				;PUP routing table maint (ACW), misc. PUP servers
>;IFN PUPNUM
IFN FTNEWS,<
	PHANTM('[-NS-]',' NS NS',<LUPPRV,,MASPRV>,0,0)
				;News service
	PHANTM('[DOER]',' NS NS',<LUPPRV,,MASPRV>,0,0)
				;News service categorizer
>;IFN FTNEWS
IFN FTCCRMA,<
	PHANTM('[LIST]','SPLSYS',<REAPRV!LUPPRV,,0>,'SPX',LPT)
				;LPT spooler
>;IFN FTCCRMA
IFN FTCCRMA,<
	PHANTM('[XSPL]','SPLSYS',<REAPRV!LUPPRV,,0>,'XSP',XGP)
				;XGP spooler
>;IFN FTCCRMA
IFN FTSUAI,<
	PHANTM('BOISE!','SPLSYS',<REAPRV!LUPPRV,,0>,'BSP',Boise)
				;Boise spooler
	PHANTM('DOVER!','SPLSYS',<DOVPRV!REAPRV!LUPPRV,,0>,'DSP',Dover)
				;Dover spooler
	PHANTM('ROVER!','SPLSYS',<DOVPRV!REAPRV!LUPPRV,,0>,'RSP',Rover)
				;Rover spooler
	PHANTM('MAPLE!','SPLSYS',<REAPRV!LUPPRV,,0>,'MSP',Maple)
				;Maple spooler (Imagen on Ethernet)
	PHANTM('STRDL!','SPLSYS',<REAPRV!LUPPRV,,0>,'SSP',Strudel)
				;Strudel spooler (Apple on Navajo)
	PHANTM('SZEGO!','SPLSYS',<REAPRV!LUPPRV,,0>,'4SP',Szego)
				;Szego spooler (LPS40 via Polya)
	PHANTM('PNCAK!','SPLSYS',<REAPRV!LUPPRV,,0>,'QSP',Pancake)
				;Pancake spooler (Apple on TIP)
	PHANTM('LATHR!','SPLSYS',<REAPRV!LUPPRV,,0>,'LSP',<Lathrop(private)>)
				;Lathrop spooler (Imagen at JMC's house)
;;	PHANTM('[ISPL]','SPLSYS',<REAPRV!LUPPRV,,0>,'ISP',Imprint)
				;IMPRINT spooler (Imagen on TTY line)
	PHANTM('ESPLO!','SPLSYS',<LUPPRV,,0>,0,0)
				;ESP accounting logger
	PHANTM('PONY  ','PNYACT',<LUPPRV,,0>,0,0)
				;Prancing Pony
	PHANTM('THERMO','  TACT',<LUPPRV,,0>,0,0)
				;Thermometer recorder
	PHANTM('WHOPHN','RMDSYS',<UPGPRV!LUPPRV,,0>,0,0)
				;WHO phantom
	PHANTM('<RM2D>','RM2SYS',<REAPRV!WRTPRV!LUPPRV,,0>,0,0)
				;alternate Reminder
	PHANTM('<TEST>','ERRSYS',<REAPRV!WRTPRV!LUPPRV,,0>,0,0)
				;test Reminder
>;IFN FTSUAI
;Nonzero spooler "extensions" in patch spaces below allow patching spooler tables.
;Spooler name (last macro arg) is left null in these definitions -- see PRIEXT.
	PHANTM(0,0,0,1000000,)	;Patch space
	PHANTM(0,0,0,1000000,)	;Patch space
	PHANTM(0,0,0,1000000,)	;Patch space
>;DEFINE PHANTS

↑BATMAN:			;Phantom names
DEFINE PHANTM(A,B,C,D,E)<A>
PHANTS
↑BATLEN←←.-BATMAN

↑ROBIN:				;Phantom PPNs
DEFINE PHANTM(A,B,C,D,E)<B>
PHANTS

;Alfred, the faithful butler
↑ALFRED:BLOCK BATLEN		;Space for time requests

;Police Commissioner Gordon Memorial Table (please remove your feet)
↑GORDON:			;Privileges for phantoms
DEFINE PHANTM(A,B,C,D,E)<C>
PHANTS

;Only FIREUP phantoms use BATCAR, which holds the DDB to assign to the
;job being started up.
↑BATCAR:			;DDB assignments
REPEAT NFIRES,<
	0
>;REPEAT NFIRES

↑BATYET:=10*JIFSEC		;Start after 10 seconds
↑BATPNT:0			;Pointer into BATMAN etc.

;Spooler information, for SPOOLR UUO.
;All spoolers in the phantom tables above (i.e., phantoms with a nonzero
;spooler extension argument) are collected here for lookup by SPOOLR UUO.

;Special spoolers with no phantoms or with duplicate names.
DEFINE SPCSPL<
IFN FTSUAI,<
PHANTM('MAPLE!',0,0,'MSP',ESpool) ;old name for Maple spooling
PHANTM(0,0,0,'.SP',Self)	;self spooler, assumes Imagen printer on own TTY
>;IFN FTSUAI
>;SPCSPL

↑PRIJOB:			;job name of spooler
DEFINE PHANTM(A,B,C,D,E)<IFN D,<A>>
PHANTS
SPCSPL

↑PRIEXT:			;spooler cmd file extension,,ptr to asciz name
DEFINE PHANTM(A,B,C,D,E)<IFN D,<D,,[ASCIZ /E/]>>
PHANTS
SPCSPL
↑NSPLRS←←.-PRIEXT ;number of spoolers in these tables
;⊗ JOBNM1 TSAVUU TSAVJ ONCEI SYSTHERE DAMESS DISMON MONPTR MONSUM HMNPTR HMNSUM FIXBUF ERRYET TIMDAT PSTDAT INITIM DAYLIT APRSUN OCTSUN PDTCNT PITFLG USTIME UUTIME SFTIME SAC2SH PAGREG PAGINT PAGPLN PAGPDL PAGPD PFPDL PFPD PFLTPI

↑JOBNM1:	JOBN-1		;MAXIMUM JOB NUMBER (reduce manually if desired)
↑TSAVUU:	0		;SAVED UUO FOR UUOERR
↑TSAVJ:		0		;SAVED J FOR UUOERR

↑ONCEI:		JSR ONCE
↑SYSTHERE:	0			;-1 = SYSTEM IS ON THE L'SCOPE DISK

↑DAMESS:	ASCIZ /-JAN-/
↑DISMON:	ASCIZ /-JAN-/		;RPH FOR DISDATE
↑MONPTR:	0
↑MONSUM:	0

IFN FTHSYS,<
↑HMNPTR:	0			;POINTER AND CHECKSUM FOR HISYS
↑HMNSUM:	0
>

↑FIXBUF:	BLOCK FIXLEN
↑ERRYET:	-1

↑TIMDAT:	0		;<DATE>,,<TIME IN SECS>
↑PSTDAT:	0		;SAME AS TIMDAT BUT IN PACIFIC STANDARD TIME
↑INITIM:	0		;AS TIMDAT, TIME OF LAST RELOAD/RE-INITIALIZATION.
↑DAYLIT:	0		;-1 IF DAYLIGHT SAVINGS TIME
;From 1966 to 1986, daylight saving time went from the last Sunday in April to
;the last Sunday in October.  A 1986 law changed the start to the first Sunday
;in April.
↑APRSUN:	0		;DATE OF first SUNDAY IN APRIL
↑OCTSUN:	0		;DATE OF LAST SUNDAY IN OCTOBER
↑PDTCNT:	0		;COUNTDOWN FOR DAYLIGHT SAVINGS TIME CHECK

↑PITFLG:	-1		;non-zero makes following counts be kept in APRCHN
;The following counts are incremented in APRCHN to see how much time is
;spent in various lower channels, and how much with scanner channel off.
;;;This table must parallel that at PITNAM in CLKSER.
↑USTIME:	0		;number of times clk interrupted user level
↑UUTIME:	0		;number of times clk interrupted UUO level
		BLOCK 7-APRCHN	;number of times clk interrupted channel 7,6,...
↑SFTIME:	0		;times clk int'd with scanner chan off & below it

;FOR THE KL10, PAGREG IS <BITS+UBR>,,MBR.  THE BITS ARE AS FOLLOWS:
; 400000   NO USER BASE REGISTER, I.E., THE NULL JOB, MUST BE SIGN BIT
↑SAC2SH←←200000	;DON'T COPY AC BLK 1 TO SHADOW AT ACTOSH (SET FROM SPWSER)
;The right half of PAGREG no longer holds the MBR (KL) nor the PSB (KA),
;but is entirely reserved for the job number, which is stored in the
;high bits of the RH.
;For the KA, note that PAGREG is no longer the actual word (71) used by
;the pager, but a word used only by the monitor.
↑PAGREG:	0

NOKL10,<
↑PAGINT:	0
		JRST PAGTRP
>;NOKL10

↑PAGPLN←←100
↑PAGPDL:	-PAGPLN,,PAGPD-1
↑PAGPD:		BLOCK PAGPLN
↑PFPDL:		-PAGPLN,,PFPD-1
↑PFPD:		BLOCK PAGPLN
↑PFLTPI:	0
;⊗ P1DATA SPWRAN SPWUUF SPWTMO SPWBLO SPWXCT SPXITF INTACT INTNF INTACS INTSAC INTDISP INTSP INTREQ INTQUANT INEPLN INEPDL INEPD CLKSV CLKESV ...TMP APRTAC APRTC1 APRAC1 APRAC2 APRJ APRIN1 APRIN2 APRIN3 APRID APRERR APRPC PAGFLG F2ILM APRPLN APRPDL APRPD ERRPLN ERRPDL ERRPD DSFLAG JOB SJOB
	Intern JOB

; BEGINNING 2-PROCESSOR SPLIT DATA AREAS

↑P1DATA:
↑SPWRAN:	0		;SET WHEN U2S IS CALLED FOR SPACEWAR RUN
↑SPWUUF:	0		;SET WHEN SPACEWAR IS ACTIVE
↑SPWTMO:	0		;SPACEWAR TIMEOUT COUNT
↑SPWBLO:	0		;LOCATION OF BLOWN UP SPACEWAR JOB
↑SPWXCT:	0		;CONTAINS JRST 2,@UUO0 OR JRST SPWTMO
↑SPXITF:	0		;FLAG TO SPCLK1/2 FOR SPACEWAR EXITING
↑INTACT:	0
↑INTNF:		0
↑INTACS:	BLOCK 20
↑INTSAC:	BLOCK 20
↑INTDISP:	0
↑INTSP:		0
↑INTREQ:	0
↑INTQUANT:	0
↑INEPLN←←60
↑INEPDL:	-INEPLN,,INEPD-1
↑INEPD:		BLOCK INEPLN
↑CLKSV:		CLKSAVE
↑CLKESV:	CLKESAVE
↑...TMP:	0
↑APRTAC:	0		;Saved TAC in APR chan
↑APRTC1:	0		;Saved TAC1 in APR chan
↑APRAC1:	0
↑APRAC2:	0
↑APRJ:		0
↑APRIN1:	0
↑APRIN2:	0
↑APRIN3:	0
↑APRID:		P1PID
↑APRERR:	0		;APR ERROR BITS ON NON-EX MEM, ETC.
				;SET BY APRSER, CLEARED BY CLK ROUTINE(CLOCK)
↑APRPC:		0		;PC WHEN APR ERROR DETECTED
NOKL10,<
↑PAGFLG:	0		;FLAG TO APRSER SET AT PAGTRP
>;NOKL10
IFN FTF2,<
↑F2ILM:		0		;Software simulation of KA's CONI APR,ILM bit
>;IFN FTF2
↑APRPLN←←140
↑APRPDL:	-APRPLN,,APRPD-1
↑APRPD:		BLOCK APRPLN
↑ERRPLN←←200
↑ERRPDL:	-ERRPLN,,ERRPD-1
↑ERRPD:		BLOCK ERRPLN
↑DSFLAG:	0
↑JOB:		0
↑SJOB:		0
;⊗ USRPRT USRHCU USRPC USRDDT USRJDA USRLO USRLO1 USRHI CHKYET UUO0 UUO2 PIERR ESVPID UUOWRD UUOLOC UU2LOC CLOCKP NULDAT PALIVE NULBAD CIPWT USRSAV CLKFLG CLKS17 USAVPC CLKPDL CLKCH TIMEFF TIMEF TIME THSDAT UPTIME INTIME PSTIME PSDATE SCHEDF COMFLG UUOXIT UUOXI PDATALEN P1PID

;LOCATIONS COPIED FROM JOB DATA AREA INTO MONITOR WHEN A JOB RUNS
;THIS PREVENTS THE USER FROM CLOBBERING THEM AND MAKES IT
;EASIER FOR THE MONITOR TO LOCATE THESE QUANTITIES WHEN IT
;NEEDS TO FOR THE CURRENT JOB
;CONTENTS ARE COPIED BACK WHEN JOB BECOMES INACTIVE(SEE CLOCK)
;COMPARE WITH JOB DATA AREA(SEE JOBDAT)

↑USRPRT:			;FIRST LOC. OF PROTECTED JOB DATA
↑USRHCU:	0		;HIGHEST USER IO CHANNEL IN USE
				;0 MEANS EITHER NONE OR CHAN. 0 IN USE
				;NEG, MEANS SAVE-GET HAS ACTIVE IO EVEN THOUGH USRJDA
				;TABLE IS OVERWRITTEN BY GET.
				;RH=ADR. OF SAVE-GET DEVICE(USED BY ANY ACT ROUT. IN
				;IN CORE SHUFFLER
				;ONLY CHAN. ASSIGNMENTS IN USE ARE COPIED INTO
				;MONITOR WHEN JOB RUNS
↑USRPC:		0		;JOB PC WHEN SCHEDULER IS CALLED
↑USRDDT:	0		;RH=STARTING ADR. OF USER DDT,LH UNUSED
↑USRJDA:	BLOCK	20	;RH=JOB DEVICE ASSIGNMENTS (DEVICE DATA BLOCK ADDRESSES)
				;LH=UUOS DONE SO FAR FOR THIS CHANNEL(SEE SYSPAR)
				;0 MEANS NO DEVICE INITIALIZED ON THIS CHANNEL
↑USRLO←←USRJDA
				; FIRST LOC CLEARED BY SETUSR ROUTINE
				;ON A CALL [SIXBIT /RESET/]
				;ALSO CLEARS USRHCU
↑USRLO1←←USRLO+1		; FIRST LOC+1
↑USRHI←←.-1			; FIRST LOC CLEARED BY SETUSR

↑CHKYET:	0
↑UUO0:		0
NOKL10,<	JRST UUO1	>
IFKL10,<	JRST 4,.	>;P2 needs this cell in its copy of this data area
↑UUO2:		0		;JSR HERE FOR OPCODES 100-127
		0		;(JRST UUO3 in KA10 system)
↑PIERR:		0
IFN FTXADR,< 0 ↔ 0 ↔ .+1 >	; make 4-wd block for XPCW
		JRST PIERR1	;(FOR P2 THIS IS JRST PIERR2  - SEE SYSINI)
↑ESVPID:	0		;SAVE PID AT CALLS ON PIERR
IFN FTKLB,<
↑UUOWRD:	0		;UUO is reconstructed here, assuming section 0
>;IFN FTKLB
↑UUOLOC:	140		;UUO TRAP LOCATION
↑UU2LOC:	160		;ILLEGAL INSTRUCTION TRAPS
↑CLOCKP:	POINT 36,CIPWT-1,35
↑NULDAT:	BLOCK 140	;JOB DATA AREA FOR NULL JOB
↑PALIVE:	0
↑NULBAD:	0
↑CIPWT:		BLOCK 2*JOBN
↑USRSAV:	0		;TEMPORARY FOR UUO HANDLER(IMPURE ROUTINE!)
↑CLKFLG:	0		;NON-ZERO WHEN CLK INTERRUPT FORCED FOR ANY REASON
↑CLKS17:	0
↑USAVPC:	0		; SAVED PC ON ILM TRAPS
↑CLKPDL:	BLOCK CLKPLN
↑CLKCH:		CLKCHL
↑TIMEFF:	0
↑TIMEF:		0		;NON-ZERO FOR CLOCK INTERRUPT ON APR
				;SET BY APRSER, TESTED AND CLEARED BY CLK ROUTINE
↑TIME:		0		; TIME OF DAY IN TICKS SINCE MIDNIGHT
↑THSDAT:	0		;TODAY'S DATE((Y-1964)*12+M-1))*31+(D-1)
↑UPTIME:	0
↑INTIME:	0
↑PSTIME:	0		;LIKE TIME BUT IN PACIFIC STANDARD TIME
↑PSDATE:	0		;LIKE THSDAT BUT IN PACIFIC STANDARD TIME
↑SCHEDF:	0		;FORCED RESCHEDULING FLAG FOR CLK ROUTINE
				;USED TO FORCE RESCHEDULING WHEN JOB IS IN EXEC MODE
↑COMFLG:	0		;FORCE CALL TO COMMAND EVEN THOUGH NOT TIME INT
↑UUOXIT:	JRST 12,@UUO0	;UUO EXIT INST, SOMETIMES CONO PI,PIOFF (SEE USRXIT CODE)
↑UUOXI:		JRST 12,@UUO0	;BACKUP COPY FOR RESTORING ABOVE

↑PDATALEN←←.-P1DATA

↑P1PID←←0
;⊗ SYSBEG BIGTIM BIGJMP NINTS1 NINTS CH1SPU CH2SPU CH3SPU CH4SPU CH5SPU CH6SPU CH7SPU LPROGR NPROGR PROGR PROGF PROGP NDDLUZ NDDNXM NDDCLK NCLRSP UUO.SA ...TAC LASTDI LASTRE COMCNT HNGTIM ASSLGN ASSJBN LDPWR LDSHF LDAVG DQAVG DCAAVG DQCNT DQTOT NDQTOT APRLST ESTINT PFIOEF PFIOT1 PFIOFG

↑SYSBEG←←.		;HERE TO SYSEND ZEROED AT RELOAD OR INITIALIZATION
↑BIGTIM:	0	;used to detect/accept big time jumps (see DATEOK in CLKSER)
↑BIGJMP:	0	;biggest jump in time of day seen at TIMEOK
↑NINTS1:	0	;Count of times JFFO failed to find user interrupt bit
↑NINTS:		BLOCK =36 ;Count user interrupts for each int bit, index by bit nbr
↑CH1SPU:	0	;Count of spurious PI interrupts per channel
↑CH2SPU:	0
↑CH3SPU:	0
↑CH4SPU:	0
↑CH5SPU:	0
↑CH6SPU:	0
↑CH7SPU:	0	;Count of spurious PI interrupts per channel
IFN FTFBI,<
↑LPROGR←←40
↑NPROGR:	0		;NUMBER OF PROGRAMS IN FOLLOWING LIST
↑PROGR:		BLOCK LPROGR	;LIST OF PROGRAMS DOING SOMETHING PARTICULAR
↑PROGF:		BLOCK LPROGR	;NUMBER OF FEATURE USED BY EACH SUCH PROGRAM
↑PROGP:		BLOCK LPROGR	;PPN OF DUMP FILE FOR PROGRAMS RECORDED BY FBI
>;FTFBI
↑NDDLUZ:	0	;NUMBER OF TIMES DD MISSED A WORD FROM MEMORY
↑NDDNXM:	0	;NUMBER OF TIMES DD GOT A NXM
↑NDDCLK:	0	;NUMBER OF TIMES DD TIMED OUT
↑NCLRSP:	0	;NUMBER OF TIMES DDBSRC LOST FOR DETACH/FORK CMDS
;↑AFOOL:	0	;PART OF APRIL 1 HACK
↑UUO.SA:	BLOCK 20	;HACK TO SAVE AC'S AT THE VERY LAST UUO.
↑...TAC:	0
↑LASTDI:	0	;LAST DISASTER TIME
↑LASTRE:	0	;LAST RESTART TIME
↑COMCNT:	0	;# OF COMMANDS TYPED-IN BUT NOT DECODED.
			;SET BY SCNSER, DECREMENTED BY COMCON
↑HNGTIM:	0	;HUNG DEVICE TIME COUNT CHECK FOR HUNG IO
			;DEVICES WHEN THIS GOES TO ZERO (ONCE A SECOND)
↑ASSLGN:	0	;TEMP FOR ASSIGN COMMAND FOR LOGICAL NAME
↑ASSJBN:	0	;TEMP FOR ASSIGN COMMAND FOR JOB # OF PART MATCH DDB

↑LDPWR←←15		;Power of two of ticks in load avg interval (136.5 secs)
↑LDSHF←←12		;Location of binary point in ldavg
;Next three must be in this order (LDAVG,DQAVG,DCAAVG) for lowcore pointer access.
↑LDAVG:		0	;avg number of jobs awaiting running * 2↑(LDSHF+LDPWR)
↑DQAVG:		0	;Average disk queue size, avg'd like load avg
↑DCAAVG:	0	;Average DCA interrupt rate, avg'd like load avg
↑DQCNT:		0	;NUMBER OF LOSERS CURRENTLY IN DISK QUEUE
INTERN DQCNT			;for RH disks, used in PHYDAT
↑DQTOT:		0	;Total of disk queue samples for long-term avg
↑NDQTOT:	0	;Number of samples in DQTOT

↑APRLST:	0		; CLOCK INTERRUPT LIST
↑ESTINT:	0		; -1 → GOT INTO CH7 FROM ESTOP WITH INTACT SET

IFKL10,<
↑PFIOEF:	0		;SET IF POSSIBILITY OF PAGE FAULT FROM PF HANDLER
↑PFIOT1:	0		;TEMP FOR PFIOUU
IFN FTKLB,<
↑PFIOFG:	0		;saved PC flags for PFIOUU
>;IFN FTKLB
>;IFKL10
;⊗ DDBCNT JBTCSH JBTSTS JBTDVW JBTGSL NJOBS CJOBS UUOPC UUOOPC JBTUPC JBTPAG JBTMAP JBTMA2 WRKSET JBTSWA SWPDDB JBTSWS SWOCNT PFFLDC SWPPSV JBTPR2 JBTLIN JBTPRV JB2PRV JBTPPN PRJPRG DSKPPN SLRMAX SLCOST SLNRES SLRES

↑DDBCNT:	BLOCK JOBN	;NUMBER OF DEVICES/FILES OPEN
IFKL10,<
↑JBTCSH:	BLOCK JOBN	;STATUS OF CACHE FOR EACH JOB
>;IFKL10
↑JBTSTS:	BLOCK JOBN	;JOB STATUS BITS
↑JBTDVW:	BLOCK JOBN	;DDB ADDRESS OF DEVICE THIS JOB WAITS FOR
↑JBTGSL:	BLOCK JOBN	;JOB'S GUARANTEED SERVICE LEVEL
↑NJOBS:		BLOCK JOBN	;NUMBER OF JOBS POINTING TO THIS SEGMENT
↑CJOBS:		BLOCK JOBN	;COUNT DOWN TABLE FOR SCHEDU
↑UUOPC:		BLOCK JOBN	;THIS IS WHERE THE UUO-LEVEL PC IS STORED
↑UUOOPC:	BLOCK JOBN	;THIS IS WHERE THE UUO PC ONE BACK IS SAVED
↑JBTUPC:	BLOCK JOBN	;SAVE UUO-LEVEL PC HERE FOR DEBREAK
↑JBTPAG:	BLOCK JOBN	;NUMBER OF PAGES,,# PGS ABOVE FSLIMIT
↑JBTMAP:	BLOCK JOBN	;PAGE NUMBER OF PAGE MAP FOR THIS USER
IFN FTMAPP,<
↑JBTMA2:	BLOCK JOBN	;PAGE NUMBER OF PAGE TO BE ALWAYS USED FOR JOB'S MAP
>;IFN FTMAPP
IFN FTDMDP,<
↑WRKSET:	BLOCK JOBN*4	;JOB'S WORKING SET
↑JBTSWA:	BLOCK JOBN*100	;ADDRESSES OF SWAPED OUT 4-PAGE GROUPS
↑SWPDDB:	BLOCK DDBSIZ*JOBN	;DISK DDB FOR JOB SWAPPING
↑JBTSWS:	BLOCK JOBN	;JOB'S SWAP STATE
↑SWOCNT:	0		;COUNTDOWN TO RUNNING SWAPOUT MGR
↑PFFLDC:	0		;NUMBER OF TIMES COULDN'T GET CORE OR DDB FOR SWAPIN
>;IFN FTDMDP
IFN FTACBUG,<
↑SWPPSV:	BLOCK JOBN
>;IFN FTACBUG
↑JBTPR2:	BLOCK JOBN	;PEEK-POKE TABLE
↑JBTLIN:	BLOCK JOBN	;TTY LINE NO. OF JOB. (=-1 IF DETACHED.)
↑JBTPRV:	BLOCK JOBN	;JOB ACTIVE PRIVELEGE BITS
↑JB2PRV:	BLOCK JOBN	;JOB PASSIVE PRIVELEGE BITS
↑JBTPPN←←.			;WHAT DEC CALLS PRJPRG THESE DAYS
↑PRJPRG:	BLOCK JOBN	;PROJECT PROGRAMMER NAME OF JOB OWNER
↑DSKPPN:	BLOCK JOBN	;DISK ALIAS PPN
↑SLRMAX←←20			;MAXIMUM NUMBER OF SL RESERVATIONS
IFN FTSLCORE,<
↑SLCOST:	0		;=0,1,2 DEPENDS ON TIME OF DAY,TIME OF WEEK
>;IFN FTSLCORE
↑SLNRES:	0		;NUMBER OF SL RESERVATIONS
↑SLRES:		BLOCK SLRMAX	;TABLE OF SL RESERVATIONS
;⊗ JOBNAM JOBPPN JOBCRD JBTUFD CUSLOC JOBDEV JOBLOG JBTKCJ JBTBTM RTIME TTIME FTIME XTIME JBTRNB JBTWAT JB2WAT MTRETIME MTRMTIME MTRTTIME MTRXTIME MTRRNB MTRRTIME NSCHOF LXRTIM JBTMSC JBTDDB JBTIOW STIME ASTAB ASBTAB ASHTAB PAGNOW DDFSPC ESCDIF GOTARG RSPLOK PHYLIN LITOFF

↑JOBNAM:	BLOCK JOBN	;NAME OF CURRENT PROGRAM (FOR WHO)
↑JOBPPN:	BLOCK JOBN	;DIRECTORY CURRENT PGM CALLED FROM
↑JOBCRD:	BLOCK JOBN	;PROGRAM'S CREATION DATE (FROM FILE RETRIEVAL)
↑JBTUFD:	BLOCK JOBN	;LOGICAL ADDR OF USER'S UFD.
↑CUSLOC:	0		;SAME OF [1,3] UFD.
↑JOBDEV:	BLOCK JOBN	;DEVICE THAT JOB WAS CALLED IN FROM
↑JOBLOG:	BLOCK JOBN	;LOGICAL DEVICE NAME
↑JBTKCJ:	BLOCK JOBN	;KILO CORE JIFFIES USED BY THIS JOB
↑JBTBTM:	BLOCK JOBN	;LOGIN TIME FOR A JOB
↑RTIME:		BLOCK JOBN	;RUN TIME AT LAST "TIME" COMMAND
↑TTIME:		BLOCK JOBN	;TOTAL RUN TIME
↑FTIME:		BLOCK JOBN	;<DATE>,,<TIME IN SECS> WHEN JOB LAST RUN
↑XTIME:		BLOCK JOBN	;RUN TIME WHEN LAST ACTIVATED OUT OF TTY INPUT WAIT
↑JBTRNB:	BLOCK JOBN	;CPU TIME USED SINCE JOB'S LAST PRIORITY CALCULATION
↑JBTWAT:	BLOCK JOBN	;TIME WAITING FOR SYSTEM (NOT IN IOWQ OR STOPQ)
↑JB2WAT:	BLOCK JOBN	;RECENTLY SAVED VALUE OF JBTWAT (FOR WHO LINE)
↑MTRETIME:	BLOCK JOBN*2	;DOUBLE WORD EBOX COUNTER VALUE FOR THIS JOB
IFN FTMTRACT,<
↑MTRMTIME:	BLOCK JOBN*2	;EBOX TIME WAITING FOR MBOX FOR JOB SINCE LOGIN
↑MTRTTIME:	BLOCK JOBN*2	;EBOX+MBOX TIME IN USER MODE FOR JOB SINCE LOGIN
↑MTRXTIME:	BLOCK JOBN*2	;RUN TIME WHEN LAST ACTIVATED OUT OF TTY INPUT WAIT
↑MTRRNB:	BLOCK JOBN	;TICS SINCE LAST TIME AT JLCA3
>;IFN FTMTRACT
IFN FTMTRTIME,<
↑MTRRTIME:	BLOCK JOBN*2	;RUN TIME AT LAST "TIME" COMMAND
>;IFN FTMTRTIME
↑NSCHOF:	BLOCK JOBN	;NUMBER OF TIMES THIS JOB SCHEDULED OFF
IFN FT2LVL,<
↑LXRTIM:	BLOCK JOBN	;RUNTIME AT TIME OF LAST INTERACTION (SXTIM2)
>;IFN FT2LVL
↑JBTMSC:	BLOCK JOBN	;MISC JOB BITS--SEE DESCRIPTIONS IN OUTER

↑JBTDDB:	BLOCK JOBN	;ADDRESS OF DDB TO DISPLAY ON WHOLINE FOR THIS JOB
↑JBTIOW:	BLOCK JOBN	;ADDRESS OF DDB WSYNC IS WAITING FOR, FOR WHOLINE
↑STIME:		BLOCK JOBN	;SET TO -1 WHEN CORE IMAGE IS MODIFIED
GLOBAL TTPLEN
;This prob. should be under FTAS. I think it is in the F4 source yet to be merged.
↑ASTAB:		BLOCK DDNUM+DPYNUM	;MAPPING TABLE FOR AUDIO SWITCH
↑ASBTAB:	BLOCK DDNUM+DPYNUM	;BEEP DURATION
IFN FTF2*FTAS,<
;CCRMA has a 32x16 switch.  Some switch points are not associated to with local
;terminals, like shadow channels on DD's video switch.
↑ASHTAB:	BLOCK =32	;Special table for microcode to use.  Technically
				;  this should be in UNCDAT, but F2/F4 should never
				;  reference this table.
>;IFN FTF2*FTAS
↑PAGNOW:	0		;-1 = PAGING NOW
IFN FTDDFSBUG,<
↑DDFSPC:	0		;LAST PC OF WRITER OF DDFS
		0		;LETAB-1 SEEMS TO GET CLOBBERED SOMETIMES
>;FTDDFSBUG
↑ESCDIF:	0		;-1, 0, or +1 increment of current escape arg
↑GOTARG:	0		;Flag indicating to LINED if esc arg is non-null
↑RSPLOK:	0		;Flag for DDBSRC,TTYKL9 not to touch responsible tty
↑PHYLIN:	0		;Characteristics and line number of physical typer
NOKL10,<
↑LITOFF:	0		;Set non-zero to suppress DATAO PI, of job number
>;NOKL10
;⊗ PCHRES PNUMES PSGNES PHIDDN DDQREQ DDQLNK LSTESC IRMCNT PRGESC LETAB TTYTAB CRMCPT TIME11 DATE11 CONYET CONALV RSTBEG JBTIOP JBTSIN SAVSAI JBTDTS JBTGLU JBTFS JBTMAIL JBTTCR JBTMSK JBTIEN JBTIRQ JBTWKM JBTIRU JBTIIP INTDTM UUOPTR RSTEND STATS STATNUM STATIM FATALE POPUPF

;NOW SOME BYTE POINTERS INTO LSTESC(LINE)
↑PCHRES←←000700			;BITS 29-35 : LAST ASCII ESCAPE CHARACTER
↑PNUMES←←071000			;BITS 21-28 : LAST ESCAPE ARG (MAGNITUDE)
↑PSGNES←←170100			;BIT 20	: SIGN BIT OF LAST ESC CMD (ON FOR BREAK)
↑PHIDDN←←200100			;BIT 19 : ON IF TTY IS HIDDEN
;;Bit 18 is currently unused.
↑DDQREQ←←<(<POINT PUNITS,0,17>)> ;BITS 9-17: DD CHAN REQUESTOR OR RESPONSIBLE TTY
↑DDQLNK←←<(<POINT PUNITS,0,8>)>  ;BITS 0-8: DD CHAN QUEUE LINK OR PREV RESP TTY
IFG PUNITS-9,<.FATAL PUNITS is too big for DDQREQ/LNK bytes in LSTESC>
		0		;LSTESC-1 IS HEADER FOR DD WAIT QUEUE
↑LSTESC:	BLOCK TTPLEN	;Last ESC cmd, DD queue, hidden bit, ... (see above)
IFN FTIRMA,<
↑IRMCNT:	BLOCK TTPLEN	;COUNT OF IRMAS WITHIN A MINUTE OR SO
>;IFN FTIRMA
↑PRGESC:	BLOCK TTPLEN	;RH is programmer name for ESC [prg] command
↑LETAB:		BLOCK TTPLEN	;LINE EDITOR HEADERS ARE HERE
↑TTYTAB:	BLOCK TTPLEN	;Pointers to DDBs (RH), flags and talk link (LH)
↑CRMCPT:	BLOCK TTPLEN	;Pointer to FS block of ptrs to macro defs

IFN FT11CLK,<
↑TIME11:	0		;last time received from 11's realtime clock
↑DATE11:	0		;last date received from 11's realtime clock
↑CONYET:	0
↑CONALV:	0
>;IFN FT11CLK
↑RSTBEG←←.			;THIS AREA CLEARED ON RESTARTS
↑JBTIOP:	BLOCK JOBN	;IO PUSH/POP POINTERS
↑JBTSIN:	BLOCK JOBN	;SWAPIN LIST FOR COMMAND DECODER, INTS, ETC.
↑SAVSAI:	BLOCK JOBN
↑JBTDTS:	BLOCK JOBN	;Pointer to FS block with detached segment numbers
↑JBTGLU:	BLOCK JOBN	;NON-ZERO GLUES JOB IN PLACE IN CORE.
↑JBTFS:		BLOCK JOBN	; TEMPORARY FREE STORAGE
↑JBTMAIL:	BLOCK JOBN	;PTR. TO LETTER ADDRESSED TO JOB.
↑JBTTCR:	BLOCK JOBN	;PNTR TO TMPCOR FILES
↑JBTMSK:	BLOCK JOBN	;NEW STYLE INTERRUPT SYSTEM MASKS
↑JBTIEN:	BLOCK JOBN	; INTERRUPT ENABLINGS
↑JBTIRQ:	BLOCK JOBN	; REQUESTS PENDING
↑JBTWKM:	BLOCK JOBN	; TELLS WHICH BITS CAUSE WAKEUP
↑JBTIRU:	BLOCK JOBN	;TELLS WHICH BITS CAUSE I-LEVEL TO RUN
↑JBTIIP:	BLOCK JOBN	; INTERRUPT IN PROGRESS
↑INTDTM:	BLOCK JOBN	; DATUM OF INTERUPT
↑UUOPTR:	BLOCK JOBN	;PNTR TO UUO SIMULATOR TABLE

↑RSTEND←←.			;END OF AREA CLEARED ON RESTARTS

IFN FTSTAT, <
↑STATS:		BLOCK STATLEN	; STATISTICS GATHERING SERVICE
↑STATNUM:	0		; NUMBER OF TIMES WE'VE WRAPPED AROUND
↑STATIM:	0		;SAVED "TIME" AT WHICH LAST STATS WERE SENT.
>;IFN FTSTAT

↑FATALE:	0		;Non-zero at BUGTRP/FATTRP means fatal error
↑POPUPF:	0		;BUGTRP flag meaning pop up level after DDT
;⊗ LDDWQ DDWQ LDMWQ DMWQ DMWQNX MXJCOR LASTUP LASTNL JBSRUN WHONXT WHDDNX NEXTDM NXTPTY WHOPTR WHDMPT WHODAT SPCWRD WHOJOB FREWAT FRETAB T15CNT DKBCNT NDDXOL NDDLOL NDSTAT BADADR SYSEND STATPTR AUTOSYNC BRKMAX BRKTAC BRKAC1 BRKNUM BRKTAB ADRBRA ADRBRO ADRBRC SCNCTY SUPCTY SUICTY DISLEN DISBUF DISPTR DISOPT DISCTR CTYCUR CTYMAR CTYUSR CTYJOB CTYLFS CTYJTM ITHERM OTHERM NMAPLS TTDDCK TTDDCN

; WHO LINE DATA STORAGE

↑LDDWQ←←4
↑DDWQ:		BLOCK LDDWQ

↑LDMWQ←←4
↑DMWQ:		BLOCK LDMWQ
↑DMWQNX:	0		;Like WHDMPT, except for special wholine request

↑MXJCOR:	0		;MAXIMUM TOTAL USER CORE DISPLAYED ON WHOLINE
↑LASTUP:	0		; NEGATIVE UPTIME WHEN SYSTEM WHO LINE LAST DONE
↑LASTNL:	0		; RECENT VALUE OF NEGATIVE RUN TIME FOR NULL JOB
↑JBSRUN:	BLOCK <JOBN+43>/44 ; BITS FOR JOBS THAT HAVE BEEN RUN LATELY
↑WHONXT:	0		; NUMBER OF THE III WHOSE WHO LINE WAS DONE LAST
↑WHDDNX:	0		; NUMBER OF NEXT DATA DISK CHANNEL TO GET WHO LINE
↑NEXTDM:	0		; NUMBER OF NEXT TTY TO GET WHO LINE (IF IS DM)
↑NXTPTY:	0		; NUMBER OF NEXT PTY TO GET WHO LINE (IF IS DM)
↑WHOPTR:	0		; POINTER TO THE DD THAT WAS DONE LAST (SEE DPYSER&WHOQUE)
↑WHDMPT:	0		; LINE NUMBER OF DM WHOSE WHOLINE NEEDS QUEUEING
↑WHODAT:	0		; DATE ON CURRENT WHO LINE
↑SPCWRD:			;BEGINNING OF TABLE OF SPECIAL JOBS FOR WHOAMI UUO
↑WHOJOB:	0		;JOB NUMBER OF MINI-WHO PHANTOM IF ANY
				;END OF TABLE OF SPECIAL JOBS
↑FREWAT:	0		; FREE STORAGE RELEASE WAIT LIST
↑FRETAB:	BLOCK TTPLEN	; FREE STORAGE POINTER FOR EACH WHO LINE
↑T15CNT:	0		;COUNT FOR 1/4 TH SECOND CLOCK
↑DKBCNT:	0		;WHEN THIS GOES NEGATIVE, DKB HARDWARE
				;  IS CHECKED (CODE IS IN CLKSER).
↑NDDXOL:	0		;OLD VALUE OF NDDXCT
↑NDDLOL:	0		;OLD VALUE OF NDDLCT
↑NDSTAT:	0		;COUNTS DOWN TO RUN FROB IN 5 SECONDS.
↑BADADR:	0		;ADDRESS TO SET BAD PARITY IN
↑SYSEND←←.
IFN FTSTAT,<
↑STATPTR:	POINT 18,STATS	;BYTE POINTER TO STATISTICS TABLE
>;IFN FTSTAT
↑AUTOSYNC:	0

;;ADDRESS BREAK CRAP . . .
↑BRKMAX←←20			;MAXIMUM NUMBER OF LEGAL PCS
↑BRKTAC:	0
↑BRKAC1:	0
↑BRKNUM:	0		;CURRENT NUMBER OF LEGAL PCS
↑BRKTAB:	BLOCK BRKMAX	;PUT GOOD PCS HERE

IFN FTADRB,<
;If ADRBRA contains a non-negative value, then clock level will
;do a DATAO APR, with that value to enable address breaks.
↑ADRBRA:	2,215		;Address to put addr break on: initial value
PRINTX Initial address break set up for Writes to low-core 215
↑ADRBRO:	0		;Data of current Addr Break enabling
↑ADRBRC:	0		;Flag to force addr brk read: DATAI APR,ADRBRO
>;IFN FTADRB

; DISASTER MESSAGE BUFFERS AND STUFF

IFN FTSCTY,<
↑SCNCTY:	-1		;NON-NEGATIVE IF THE CTY IS ON TTY SCANNER
↑SUPCTY:			;Non-zero to suppress real CTY output thru DTE
IFE FTCCRMA,<	-1
>;IFE FTCCRMA
IFN FTCCRMA,<	0		;I want to see things by default. TVR/Feb82
>;IFN FTCCRMA
↑SUICTY:	-1		;Non-zero to suppress real CTY input thru DTE
>;IFN FTSCTY
↑DISLEN←←400
↑DISBUF:	BLOCK DISLEN
↑DISPTR:	POINT 7,DISBUF	;PK KNOWS THAT THIS CELL FOLLOWS THE BUFFER
↑DISOPT:	POINT 7,DISBUF
↑DISCTR:	5*DISLEN
↑CTYCUR:	0		;COLUMN OF CTY OUTPUT, 0 IS LEFT MARGIN
↑CTYMAR:	0		;COLUMN WHERE SOMEONE WANTS CTY OUTPUT TO BE
↑CTYUSR:	0		;SIXBIT NAME OF LAST USER OUTPUTTING TO CTY
↑CTYJOB:	0		;JOB NUMBER OF LAST JOB TO OUTPUT TO CTY
↑CTYLFS:	0		;NUMBER OF LFS OUTPUT TO CTY SINCE LAT PRINTING CHAR
↑CTYJTM:	0		;TIME OF DAY (IN TICKS) WHEN JOB LAST OUTPUT TO CTY

↑ITHERM:	0		;INSIDE TEMPERATURE  (KEEP THESE IN ORDER)
↑OTHERM:	0		;OUTSIDE TEMPERATURE     (  "  )
↑NMAPLS:	0		;NUMBER OF TIMES MAP WRONG AT CIP8AA
IFN FTDTTYBUG,<
↑TTDDCK:	-1		;DEFAULT IS ENABLED LOST TTY DDB BUGTRAP
↑TTDDCN:	0		;COUNT OF LOST TTY DDBS
PRINTX LOST TTY DDB bugtrap is initially enabled.
>;IFN FTDTTYBUG
;⊗ CLKSAVE CLKSV0 CLKSV1 CLKESAVE CLKES2 INITRP

;ACCUMULATOR SAVE ROUTINE FOR CLOCK LEVEL, CLKSAVE,CLKESA,INITRP
;WHEN THE CH7 RUNS, THE HARDWARE ACS ARE STORED IN 20-37 OF THE CURRENT
;JOB'S DATA AREA.  IF THE CURRENT JOB IS IN USER MODE, THESE ARE HIS
;ACS.  IF THE CURRENT JOB IS RESCHEDULING FROM EXEC MODE, THESE ARE
;THE SYSTEM'S UUO-LEVEL ACS.

↑CLKSAVE:				;JSR HERE. 17 SAVED IN CLKS17.
	0
	SKIPE 17,JOB			;SKIP IF NULL JOB
	SKIPN JBTPAG(17)		;SKIP UNLESS CORE 0 ON OLD JOB
	JRST CLKSV1			;SPECIAL FOR NULL JOB OR CORE 0
	MOVEI 17,JOBDAC			;SOURCE,,DESTINATION
	XCTR XBLTW,[BLT 17,JOBD16]	;RELOCATE DESTINATION. STORE ACS IN JOBDAC
	MOVE 17,CLKS17
	XCTR XW,[MOVEM 17,JOBD17]	;STORE AC17 IN JOBD17.
IFKL10,<

;BUT FIRST, A BUG TRAP.
	DATAI KLPAG,TAC
	SKIPN TAC1,USAVPC
	SKIPE TAC1,CLKCHL
	CAIA
	TLO TAC1,USRMOD			;SPECIAL CASE FOR EXIT UUO.
	AND TAC1,[USRMOD,,0]
	LSH TAC1,-3			;MOVE 10000 TO 1000
	XOR TAC,TAC1
	TLNN TAC,7000			;AC CONTEXT AND USRMOD SHOULD AGREE
	JRST CLKSV0			;OK
	TLO TAC1,400100			;SET PREVIOUS CONTEXT = USER (ALWAYS RIGHT)
	MOVE P,ERRPDL
	PUSH P,TAC1			;STORE IN ERRPD
	PUSHJ P,DISGST		;PRINT TIME OF NEW MESSAGE ON CTY
	PUSHJ P,DISMES
	ASCIZ /AC context bad at CLKSAV.  Context = /
	DATAI KLPAG,TAC
	PUSHJ P,DISOCH
	PUSHJ P,DISMES
	ASCIZ /  PC = /
	SKIPN TAC,USAVPC
	MOVE TAC,CLKCHL
	PUSHJ P,DISOCH
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	PUSHJ P,DDTCALL
	MOVSI 17,JOBDAC
	XCTR XBLTR,[BLT 17,17]
	DATAO KLPAG,ERRPD
	JRST CLKSAV+1


CLKSV0:	XCTR XR,[DMOVE TAC,JOBDAC+TAC]	;RESTORE ACS WE CLOBBERED
	DATAO KLPAG,[400100,,0]		;SET AC CONTEXT 0=CURRENT, 1=PREVIOUS
>;IFKL10
	MOVEI PID,P1PID
	JRST @CLKSAVE

CLKSV1:	MOVEI 17,NULDAT			;NO, USE NULL JOB'S DATA AREA.
	MOVEM 16,JOBD16(17)		;SAVE 16.
	MOVEI 16,JOBDAC(17)		;CURRENT ACS TO JOBDAC
	BLT 16,JOBD15(17)
	MOVE 16,CLKS17
	MOVEM 16,JOBD17(17)
IFKL10,<
	MOVE 16,JOBD16(17)		;CURRENT AC BLOCK = 1, SO LET'S KEEP
	MOVE 17,JOBD17(17)		;THE ACS HONEST
	DATAO KLPAG,[400100,,0]		;SET CURRENT=0, PREVIOUS=1
>;IFKL10
	MOVEI PID,P1PID
	JRST @CLKSAVE

;SIMILAR TO CLKSAVE, BUT THIS IS CALLED FOR ERRORS FROM USER I-LEVEL
;CONTEXT: AC17 IS SAVED IN CLKS17.  17 NOW CONTAINS PID.

↑CLKESAVE:
	0
	MOVEI 17,JOBDAC			;0,,JOBDAC  SOURCE,,DEST OF BLT.
	XCTR XBLTW,[BLT 17,JOBD16]	;STORE 0 TO 16 IN JOBDAC
	MOVE 17,CLKS17
	XCTR XW,[MOVEM 17,JOBD17]	;STORE 17 IN JOBD17
IFKL10,<DATAO KLPAG,[400100,,0]		;SET CONTEXT TO CURRENT 0 PREVIOUS 1
>;IFKL10
	MOVEI PID,P1PID
	MOVE J,JOB
	SKIPN TAC,USAVPC
	MOVE TAC,@CLKCH
	SETZM USAVPC
	TLNN TAC,USRMOD			;IS PC IN EXEC?
	JRST CLKES2			;YES, CAN'T SAVE HIS PC.
	XCTR XW,[MOVEM TAC,JOBPC]	;SAVE USER'S PC.
	CAMN J,SJOB
	MOVEM TAC,USRPC
CLKES2:	MOVE P,INEPDL			;USE OWN USER-INTERRUPT LEVEL ERR PDL
	JRST @CLKESAVE

↑INITRP:0				;HERE IF THERE'S A PAGE TRAP FROM SYSINI
	CONO	APR,200000
	MOVE	TAC,[POINT 7,[ASCIZ/PAGE TRAP FROM SYSINI. LOSE.
/]]
	JSR	DDTTYPE
	JRST	6,INITRP		;RETURN IF CONTINUE IS TYPED?

BEND APRDAT
;⊗ P1RFLG P2SA ERRLOC ERRDAT RERLOC PARPSA ERRPC SYSERR NPARER NPARIN LASLOS ERRJOB GOTNXM NXMPC PARREG

;DATA AREA FOR PARITY SERVICE (PARSER)

P1RFLG:	0			;SET BY P1 ERRINT WHEN THERE IS NO PAGE FAULT
P2SA:	0			;PLACE FOR P2RINT TO SAVE AN AC
ERRLOC:	-1			;IF .GT. 0 THEN LAST LOC SEEN WITH BAD PARITY
ERRDAT:	0			;ERROR DATUM
RERLOC:	0			;RELATIVE ERROR LOCATION.
PARPSA:	0			;SAVE P HERE WHILE WE USE APRPDL
ERRPC:	-1			;PC AT TIME OF ERROR

SYSERR:	0			;LEFT SIDE = -1 WHEN PARITY ERROR IS FOUND
				;IN THE SYSTEM (OR INDETERMINATE)
				;RIGHT SIDE = APR CONI BITS TO PRESERVE 
				;STATE OF SYS WR REF KLUGE.

NPARER:	0			;TOTAL NUMBER OF PARITY ERRORS
NPARIN:	0			;COUNT OF INDETERMINATE PARITY ERRORS

LASLOS:	0			;SET TO JOB NUMBER OF LAST JOB THAT LOST
ERRJOB:	BLOCK <JOBN+37>/40	;BIT TABLE OF JOBS THAT HAVE LOST DURING
				;THIS PASS THROUGH CORE.  ROUND UP BLOCK SIZE.
GOTNXM:	0			;-1 IF GOT A NXM, NOT A PARITY ERROR
NXMPC:	0			;USER PC CAUSING NXM

IFN FTF2,<
PARREG:	0			;ERROR WHICH WE THINK CAUSED THE INTERRUPT
>;IFN FTF2
;⊗ STBEG NCORCALLS NFSGETS NFSGIVES NCOMS NDLYCMS NUUOS NSCHEDS NQXFERS NOUTSWPS NINSWPS NDDQUE NNUUOS NFSWAITS NFSLP1 NNULLJS NJSWITCHES NWSCHEDS NTMOS NJRNULLS NPWAITS NLERRS NSAERR NLREQS NLRERS NFSGFA NABFE NABFF NFSLP2 NPUSHD NDDFRM NDDLCT NDDLMX NDDXCT NDDXMX NDDL1C NIOTS NSCALL HGNMAX HGXMAX HGSET HGYET HGCNTS HGCH2 IBMTWC FBTTWC HGCH6 HGSYS HGUSR HGUUO HGSPW HGNULL HGIDLE HGCODE STEND AMC1 AMC2 AMC3 AMC4 AMC5 AMC6 AMC7 AMC8 AMC9 AMC10 AMC11 AMC12 AMC13 AMC14 AMC15 AMC16 AMC17 AMC18

; STATISTICS COUNTERS
;  CAUTION:  THE RELATIVE ORDER OF THESE COUNTERS SHOULD NOT BE CHANGED,
;    BECAUSE THE PROGRAM MONUSE THINKS IT KNOWS WHERE THINGS ARE

IFN FTHG,<
	HGXMAX,,HGNMAX	;STBEG-2 CONTAINS # OF EACH KIND OF HG CNTR
	HGCNTS		;STBEG-1 POINTS TO HISTOGRAM COUNTERS!
>;IFN FTHG
STBEG::
NCORCALLS:	0	; NUMBER OF CALLS ON THE CORE ROUTINES
NFSGETS:	0	; NUMBER OF TIMES FREE STORAGE IS GOTTEN
NFSGIVES:	0	; NUMBER OF TIMES FREE STORAGE IS RELEASED
NCOMS:		0	; NUMBER OF COMMANDS THAT HAVE BEEN DISPATCHED TO
NDLYCMS:	0	; NUMBER OF COMMANDS THAT HAVE BEEN DELAYED
NUUOS:		0	; NUMBER OF UUOS
NSCHEDS:	0	; NUMBER OF TIMES WE HAVE ENTERED THE JOB SCHEDULING LOOP
NQXFERS:	0	; NUMBER OF QUEUE TRANSFERS
NOUTSWPS:	0	; NUMBER OF SWAPOUTS - 10
NINSWPS:	0	; NUMBER OF SWAPINS
NDDQUE:		0	; NUMBER OF TASKS CREATED FOR THE DATA DISC QUEUE
NNUUOS:		0	; NUMBER OF NEW UUO DISPATCHES
NFSWAITS:	0	; NUMBER OF TIMES WE HAD TO WAIT FOR FREE STORAGE
NFSLP1:		0	; NUMBER OF LOOPS (TYPE 1) IN FSGET
NNULLJS:	0	; NUMBER OF SCHEDULINGS THAT CHOSE THE NULL JOB
NJSWITCHES:	0	; NUMBER OF TIMES JOBS WERE SWITCHED
NWSCHEDS:	0	; NUMBER OF TIMES JOBS TURN THEMSELVES OFF - 20
NTMOS:		0	; NUMBER OF TIMES JOBS GET TIMED OUT
NJRNULLS:	0	; NUMBER OF TIMES A JOB IS RUNNABLE WHILE THE NULL JOB IS RUNNING
NPWAITS:	0	; NUMBER OF FAILURES IN SYNCHRONIZATION
NLERRS:		0	; NUMBER OF TIMES THROUGH FININ1 WITH ERRORS
NSAERR:		0	; NUMBER OF TIMES THROUGH FININ1 WITH SUCCESS AFTER ERROR RETRIES
NLREQS:		0	; NUMBER OF TRANSFERS
NLRERS:		0	; NUMBER OF TRANSFERS PLUS NUMBER OF ERROR RETRIES
NFSGFA:		0	;NUMBER OF FAILURES FROM FSGET - 30
NABFE:		0	; NUMBER OF TIMES WE ADVANCED AN OUTPUT BUFFER
NABFF:		0	; NUMBER OF TIMES WE ADVANCED AN INPUT BUFFER
NFSLP2:		0	;NUMBER OF LOOPS (TYPE 2) IN FSGET
NPUSHD:		0	;MAXIMUM PUSH DOWN DEPTH USED IN A UUO PDL.
NDDFRM:		0	; NUMBER OF FRAMES CREATED FOR THE DATA DISC QUEUE
NDDLCT:		0	;-(NUMBER OF LINES SENT TO DD)
NDDLMX:		0	;MAX COUNT FOR 5 SECONDS
NDDXCT:		0	;NUMBER OF ENTRIES MADE TO DD QUEUE.-40
NDDXMX:		0	;MAX COUNT FOR 5 SECONDS
NDDL1C:		0	;COUNT OF 1 AND 2 LINE TRANSFERS TO DD.
↑NIOTS:		0	;HOW MANY NEW UUOS (700-777) HAVE BEEN CALLED
↑NSCALL:	0	;HOW MANY STANFORD CALLIS HAVE BEEN CALLED
STEND2 ←← .-1		;END OF STATISTICS SECTION (FOR *SPY*)
IFN FTHG,<
HGNMAX←←60		;NUMBER OF "NORMAL" HISTOGRAM COUNTERS
HGXMAX←←3		;NUMBER OF "EXTRA" COUNTERS
HGSET:		0	;RESET VALUE FOR HGYET
HGYET:		0
HGCNTS:	BLOCK HGNMAX	;HISTOGRAM COUNTERS - INCREMENTED IN HG ROUTINE
			;EXTRA COUNTERS - NOT INCREMENTED IN HG ROUTINE
HGCH2:		0	;CH2 (IBM DISK XFER) ACTIVE TIME
IBMTWC:		0	;NUMBER OF WORDS XFERED (IBM DISK)
FBTTWC:		0	;NUMBER OF WORDS XFERED (L'SCOPE DISK)
	BLOCK .-HGCNTS-HGNMAX-HGXMAX		;MAKE BLOCK UP TO HGNMAX+HGXMAX
HGCH6:		0	;NUMBER OF TIMES CH5 ENTERED WITH CH6 ACTIVE
			;IF HGCH6 ISN'T INCREMENTED, THEN ONE OF NEXT 4 IS:
HGSYS:		0	;# OF OCCURRENCES OF ¬(USRMOD) ∧  (CH7 ACTIVE)
HGUSR:		0	;# OF OCCURRENCES OF  (USRMOD) ∧ ¬(CH7 ACTIVE)
HGUUO:		0	;# OF OCCURRENCES OF ¬(USRMOD) ∧ ¬(CH7 ACTIVE)
HGSPW:		0	;# OF OCCURRENCES OF  (USRMOD) ∧  (CH7 ACTIVE)
HGNULL:		0	;NUMBER OF TIMES NULL JOB RUNNING ∧ ∃ JOB WAITING
HGIDLE:		0	;NUMBER OF TIMES NULL JOB RUNNING W/ EMPTY RUNQ
HGCODE:		0	;VARIOUS CLKINT SUBROUTINES SET THIS VARIOUSLY
>;IFN FTHG
STEND←←.-1		;END OF STATISTICS SECTION

AMC1:	0		;APRMAP CALL COUNTERS
AMC2:	0
AMC3:	0
AMC4:	0
AMC5:	0
AMC6:	0
AMC7:	0
AMC8:	0
AMC9:	0
AMC10:	0
AMC11:	0
AMC12:	0
AMC13:	0
AMC14:	0
AMC15:	0
AMC16:	0
AMC17:	0
AMC18:	0
;⊗ NULDDB NULDLN

BEGIN NULDDB ↔ SUBTTL NULDDB NUL Device Data Block
; MRC 4/24/78

; Model DDB for NUL device

	REPEAT DDBSKW-2,<0>	; words not used
	NULDDB+DEVIOS		; DEVSPT
	DEVSHR,,0		; DEVCMR
↑NULDDB:SIXBIT/NUL/		; DEVNAM
	RECSIZ+1		; DEVCHR, buffer size same as for DSK
	0			; DEVIOS
	NUL.NX,,NULDSP		; DEVSER
	DVLNG!DVIN!DVOUT,,154403; DEVMOD
	0			; DEVLOG
	0			; DEVBUF
	0			; DEVIAD
	0			; DEVOAD
↑NULDLN←←.-NULDDB+DDBSKW

BEND NULDDB
;IMPDDB ;⊗ CLSTP RFNMTP ALLTP RFCTP INPTP IDLETP

IFN FTIP,<			;Several pages

BEGIN IMPDDB ↔ SUBTTL IMPDDB IMP Device Data Block and data area

; JAM September, '71
; MRC May, '78 for new extended leader IMPSER
; ME,JJW April, '83 for IP/TCP

; Model DDB for IMP connections (some fields must agree with PUP DDB)
.INSERT IMPDDB

;IMPSER data ;⊗ IMPCNT SVRNAM SVRPRV SVRDDB SERVOK IMPST IMPOUM RFNMCT BADNOP ETHINM ETHOUM IMPQLN IMPADR IMPPTR IMPQST IMPQCT IMPQFL IMPSTN

;Whole page IFN FTIP

;Data areas for the IP/TCP code are defined over the next few pages.
;Constant data that should be write-protected is mostly in LOWCOR.

IFN FTAIP,<
↑IMPCNT:-1			;Counter for OFFIMP/ONIMP
>;IFN FTAIP

;Storage for server startup code.  (Written by GOSERV in IMPSER.)
↑SVRNAM:SIXBIT/TCP000/		;TCP servers are called TCPnnn (decimal)
	SIXBIT/NETSYS/		;They live on NET,SYS
↑SVRPRV:LUPPRV,,0 		;All get LUP (GOSERV sets others if needed)
↑SVRDDB:0			;DDB to be given to phantom being started up

↑SERVOK:0			;Nonzero if OK to start up servers when system down

↑IMPST←←.			;Beginning of IMP data area to be cleared

IFN FTAIP,<
repeat 0,<↑XDEBUG:0>		;Non-zero to print trace messages
↑IMPOUM:0			;Count of output data messages
				;(MESTYP+0 counts input data messages)
↑RFNMCT:0			;Number of output messages not yet RFNMed
↑BADNOP:0			;Number of IMP no-ops with bad host number
>;IFN FTAIP

IFN FTEIP,<
↑ETHINM:0			;Count of Ethernet IP input messages
↑ETHOUM:0			;Count of Ethernet IP output messages
>;IFN FTEIP

↑IMPQLN←←40			;Size of packet input queue
↑IMPADR:BLOCK IMPQLN		;Queue of packet service addresses
↑IMPPTR:BLOCK IMPQLN		;Queue of packet pointers
↑IMPQST:0			;Variables for manipulating queue
↑IMPQCT:0
↑IMPQFL:0

↑IMPSTN←←.-IMPST		;Number of words to clear
;Misc IP/TCP data ;⊗ IMPBFT IMPBFX IMPBFX IMPBUF IMPBFE

;Whole page IFN FTIP

;Miscellaneous data for TOPS-10 IP/TCP code, taken from several MACRO
;source files and converted to FAIL.

DEFINE XX(SYM,VAL)<SYM↑←← VAL>	;define symbols internal

XX IMPBFS,=37			;SIZE OF EACH "IMP BUFFER" (MUST BE ODD)
XX IMPBFN,<<HFSPAG*1000-2>/IMPBFS> ;number of IMP buffers that fit in all of HiFS
XX IMPB36,<<IMPBFN+=35>/=36>	;1/36TH NUMBER OF BUFFERS
XX IMPM36,-IMPB36		;NEGATIVE FOR AOBJN COUNTS
XX IMPB%4,IMPBFN/4		;1/4TH NUMBER OF BUFFERS
XX MMPBFS,-IMPBFS		;NEGATIVE OF BUFFER SIZE
XX MIMBS1,-IMPBFS+1
XX MIMBS2,-IMPBFS+2
XX IMPTBS,IMPBFN*IMPBFS		;TOTAL WORDS RESERVED FOR IMP BUFFERS

PURGE XX

↑IMPBFT:BLOCK IMPB36		;IMP buffer allocation table
IFN FTEIP,<
IFE IMPBFN∂=36,<		;Table fits exactly
	-1			;Indicate end of table for BLKGET in NETSUB.MAC
↑IMPBFX←←0			;Have INI store 0 in last real word of table
>;IFE IMPBFN∂=36
IFN IMPBFN∂=36,<
↑IMPBFX←←<-1⊗-<IMPBFN∂=36>>	;Last word with zeros only in available slots
>;IFN IMPBFN∂=36
>;IFN FTEIP
↑IMPBUF:0			;POINTER TO FIRST IMP BUFFER
↑IMPBFE:0			;POINTER PAST END OF IMP BUFFERS

IMPRQF↑:0			;IMP request flag. Set when IMP/TTY processing
				;is desired at clock level
;NETSUB data ;⊗ ImpDat MESTYP EPLcnt EPLmax INCcnt INCmax BADIMP BDMLNK BDMMES BDMRFM NORFNM SIZERR ImpHDC HSTCNT BUFERR BUFNUM BUFAVG BIBCnt SIZHST IPELed IPEPrt IPEVer IPEChk IPEUOp IPEFTL IPOpt IPFrag IPFDun ICMNLd ICMDEr ICMChk ICMUnT ICMTyp TCELed TCEMes TCEChk TCEPrt TCEDDB TCEITY TCEUOP TCPOpt TCENIT TCPPRT TCPZRT TCPFTS TCPFTU TCPMNW TCPWFT TCPWET TCEIPC TCPFMB TCPITy TCPOTy IMPDCN

;Whole page IFN FTIP

;Data from NETSUB.MAC.  There it is organized as a table of subtables for
;TOPS-10's GETTAB UUO, but we don't have any such fanciness.  Some symbols
;defining the names and sizes of these subtables have been removed.

ImpDat↑:	; beginning of data area to be zeroed at init time.

IFN FTAIP,<

;SUBTABLE 0  %ISIHM  IMP-HOST MESSAGE COUNTS.  INDEX BY MESSAGE TYPE
MESTYP↑:BLOCK	mesdln

; subtable 1 %isEPL	gives count of error in previous leader
; messages (message type 1) received from IMP, broken into error codes.
EPLcnt↑:block	1	; 0  %isec0	error flip-flop set
	block	1	; 1  %isec1	message too small (less than 80 bits)
	block	1	; 2  %isec2	message of illegal type.
	block	1	; 3  %isec3	message in wrong format:
	block	1	; 4  %isec4	illegal leader style
	block	1	; 5  %isec5	wrong leader style
	; expansions should go here.
EPLmax↑←←.-EPLcnt	; the highest number we know about
	block	1	; ?  %isecu	unknown error code

; subtable 2 %isINC	gives count of incomplete transmission
; messages (message type 9 ) received from IMP, broken down into error codes.
INCcnt↑:block	1	; 0 %isin0	Dest Host didn't accept quickly
			;		enough
	block	1	; 1 %isin1	Message too long
	block	1	; 2 %isin2	Host took to long to transmit
			;		message to IMP
	block	1	; 3 %isin3	Message lost in network due to
			;		IMP or circuit failures
	block	1	; 4 %isin4	IMP couldn't accept the entire
			;		message within 15 sec because of
			;		unavailable resources
	block	1	; 5 %isin5	Source IMP I/O failure
	block	1	; 6 %isin6	connection setup delay
	block	1	; 7 %isin7	end-to-end flow control
	block	1	; 8 %isin8	destination IMP buffer space shortage
	block	1	; 9 %isin9	congestion control
	block	1	; 10 %isinA	local resource shortage
INCmax↑←←.-INCcnt	; Max length of table
	block	1	; Unknown error codes


;SUBTABLE 3  %ISDMF  DATA MESSAGE FAULTS.  INDEX BY ITEM NUMBER
BADIMP↑:BLOCK	1	; 0  %ISIHF  IMP INTERFACE HARDWARE FAULTS
BDMLNK↑:BLOCK	1	; 1  %ISBDL  BAD DATA LINK NUMBERS
BDMMES↑:BLOCK	1	; 2  %ISBMT  BAD MESSAGE TYPES
BDMRFM↑:BLOCK	1	; 4  %ISDDR  DISCARDED DATA RFNMS
NORFNM↑:BLOCK	1	; 4  %ISSDR  SIMULATED (TIMED OUT) DATA RFNMS
SIZERR↑:BLOCK	1	; 5  %ISBMS  BAD MESSAGE SIZE ERRORS
ImpHDC↑:block	1	; 6 %ishdc  number of times tops-10 told the IMP
			;		service that an IMP was hung.
HSTCNT↑:BLOCK	1	; 7 %ishst  COUNT OF HOSTS IN THE host TABLE

>;IFN FTAIP

;SUBTABLE 4  %ISBHS  IMP BUFFER HANDLING STATISTICS.  INDEX BY ITEM NUMBER
BUFERR↑:BLOCK	1	; 0  %ISIBO  IMP BUFFER OVERRUNS (RAN OUT OF BUFFERS)
BUFNUM↑:BLOCK	1	; 1  %ISNFB  NUMBER OF FREE BUFFERS
BUFAVG↑:BLOCK	1	; 2  %ISAFB  10↑4 * AVERAGE BUFFER UTILIZATION
BIBCnt↑:Block	1	; 3  %isBIB  number of BIBs in use

;SUBTABLE 5  %ISHMS  HISTOGRAM OF RECEIVED TCP MESSAGE SIZES.
;		     INDEX BY POWER OF 2 bytes.
SIZHST↑:BLOCK	=24

; subtable 6	%ISIPE	internet protocol errors
IPELed↑:	block	1	; %isipl  byte stream shorter than IP leader
IPEPrt↑:	block	1	; %isipp  IP protocol field contained a
				;	  protocol we don't understand.
IPEVer↑:	block	1	; %isipv  IP version was not the one we
				;	  understand.
IPEChk↑:	block	1	; %isipc  checksum of IP leader failed.
IPEUOp↑:	block	1	; %isipu  unknown option seen
;added in WAITS
IPEFTL↑:	BLOCK 1		;IP fragments too large

; subtable 7	%isIPD	data collected about IP activities
IPOpt↑:		block	1	; %isIPO  number of IP messages with options
IPFrag↑:	block	1	; %isIPF  number of fragmented messages seen
IPFDun↑:	block	1	; %isIFD  number of fragmented messages
				;	  actually reassembled.

; subtable 10	%isICE	error counts for ICMP
ICMNLd↑:	block	1	; %isicn  not enough data for ICMP leader.
ICMDEr↑:	block	1	; %isicd  not enough data in stream for
				;		ICMP message.
ICMChk↑:	block	1	; %isicc  checksum of ICMP message failed.
ICMUnT↑:	block	1	; %isicu  ICMP message type unknown.

;SUBTABLE 11  %ISICM  count of ICMP message types.  INDEX BY MESSAGE TYPE
ICMTyp↑:BLOCK	ICMLen

; subtable 12	%ISTCE	transmission control protocol errors
TCELed↑:	block	1	; %istcl  data ends before TCP leader
TCEMes↑:	block	1	; %istcm  data ends before TCP message
TCEChk↑:	block	1	; %istcc  checksum error in TCP leader
				;	  and/or message.
TCEPrt↑:	block	1	; %istcp  incoming connection attempted
				;	  on a port which we don't service.
TCEDDB↑:	block	1	; %istcd  no DDB when needed
TCEITY↑:	block	1	; %istci  no ITY when needed
TCEUOP↑:	block	1	; %istcu  unknown option in TCP leader
TCPOpt↑:	block	1	; %istco  TCP leader with options seen
TCENIT↑:	block	1	; %istcn  not in tranmission queue
TCPPRT↑:	block	1	; %istcr  packet retransmitted due to time
repeat 0,< ;JJW - taken out, no longer used in TCPSER
TCPZRT↑:	block	1	; %istcz  packet retransmitted due to zero
				;		send window.
>;repeat 0
TCPFTS↑:	block	1	; %istfs  future seen
TCPFTU↑:	block	1	; %istfu  future used
TCPMNW↑:	block	1	; %istmo  message out of window
TCPWFT↑:	block	1	; %istmf  message front truncated
TCPWET↑:	block	1	; %istme  message end truncated
TCEIPC↑:	block	1	; %istip  sending IPCF packet failed for
				;	  perpetual listen.
TCPFMB↑:	block	1	; %istfm  future message blocks in use

; subtable 13	%isTCI	TCP input message types.  each word is incremented
;			whenever a TCP message comes in with the corresponding
;			bit on.  note that any message can have several
;			different bits on, all of which will be counted.
TCPITy↑:	block	6	; six different bits

; subtable 14	%isTCO	TCP output message types.  each word is incremented
;			whenever a TCP message is sent with the corresponding
;			bit on.  note that any message can have several
;			different bits on, all of which will be counted.
TCPOTy↑:	block	6	; six different bits

↑IMPDCN←←.-IMPDAT	;Number of words to clear
;IMPINT data ;⊗ BLKIPT INPON DUMMY BLKOPT OUTACT IMPJ OUTBGN

;Whole page IFN FTIP

IFN FTAIP,<

;Data from IMPINT.MAC.

BLKIPT↑:0			;BLKI POINTER
INPON↑:	0			;-1 IF INPUT SHOULD BE ACTIVE
DUMMY↑:	0			;PLACE TO PUT DISCARDED INPUT DATA

BLKOPT↑:0			;BLKO POINTER
OUTACT↑:0			;-1 IF OUTPUT IS ACTIVE

;Following added for WAITS:

IMPJ↑:	0			;Temporary to save J
IFE FTF2,<
OUTBGN↑:0			;-1 if next word begins a message
>;IFE FTF2

>;IFN FTAIP
;IPSER data ;⊗ IpLen IpIBHd IpIBuf IpOBuf ICMPln ICMNLL ICMPIB ICMPOB NxtLBf NxtLvl FstFdb LstId RcvTim IpOptn PrGate IpPDDB ICMBDG ICMBDN ICMBDP

;Whole page IFN FTIP

;Data from IPSER.MAC/4P.

IpLen↑←←5			; number of words in an IP leader (not
				;  including options).


IpIBHd↑:block	NBHLen		; header in case ICMP has to send this
				;  leader back out.
IpIBuf↑:block	IpLen		; words needed for header

; the following block is used and removed under ScnOff.
IpOBuf↑:block	NBHLen+IpLen	; buffer for forming IP leaders
				;  for output.

;Data from IPSER.MAC/23P.

ICMPln↑←←2			; number of words in an ICMP leader.
ICMNLL↑←←=8			; number of bytes of the next level's leader with
				;  an ICMP reply message


ICMPIB↑:block	ICMPLn		; words needed for header

; the following block is used and removed under ScnOff.
ICMPOB↑:xwd	ICMPLn*4,0	; pseudo leader in case needed
	block	ICMPLn		; buffer for forming ICMP leaders
				;  for output.

NxtLBf↑:xwd	ICMNLL,0	; number of bytes here.
NxtLvl↑:block	ICMNLL/4	; space for 64 bit of leader
				;  for the next level protocol
				;  if needed for ICMP message.

;Data from IPSER.MAC/33P.

FstFdb↑:0			; first FDB in system chain.
LstId↑:	0			; last IP ID given.
RcvTim↑:0			; time the latest ICMP message was received.
IpOptn↑:0			; incoming IP options point if option buffers
				;  have not yet been deleted.
repeat 0,<		;We do routing differently
PrGate↑:GatTbl			; address of network address of current prime gateway.
>;repeat 0

IpPDDB↑←←.-PDBTop		; define hypothetical start of our pseudo DDB
	block	PDBBot-PDBTop+1	; number of words we really use

;Data for extra code added in WAITS.
ICMBDG↑:BLOCK 10		;Gateways that have sent bad ICMP redirects
ICMBDN↑←←.-ICMBDG		;Number of entries in ICMBDG
ICMBDP↑:0			;Pointer to next free entry
;TCPSER data ;⊗ OptMSS TCPMax TcpLen TCPIBH TCPIBf TCPObf TCPDat SktNum TCPDDB TCPDCN

;Whole page IFN FTIP

;Definitions needed for following data.  (These need to be available for
;the BYTE pseudo-op; LOADER will check consistency.)

OptMSS↑←←2			;TCP Option code for maximum segment size
TCPMax↑←←=536			;Default TCP max segment size

;Data from TCPSER.MAC/7P.

TcpLen↑←←5			; number ofwords in an TCP leader (not including options)

TCPIBH↑:block	NBHLen		; buffer header.
TCPIBf↑:block	TCPLen		; words needed for header

; the following block is used to create a TCP leader for output.
;  it is filled and then converted to 36 bit buffers all under ScnOff.
TCPObf↑:block	NBHLen+TCPLen	; output buffer for forming leader
	byte	(8)OptMSS,4(16)TCPMax	; option word for max segment size.
					;  sent only with SYN bit messages.


;Data from TCPSER.MAC/83P.

TCPDat↑:			; where to start zeroing on INIT.

SktNum↑:block	1		; number of last free port assigned.


; DDB used for random TCP hacking
TCPDDB↑←←.-IBfTop		; hypothetic start of this DDB
	block	IBfBot-IBfTop+1	; allocate words needed

↑TCPDCN←←.-TCPDAT	;Number of words to clear
;IMPMAC data ;⊗ HTISiz HTIWds newfrm IMPQLN HDTLEN HDTOVR MS.HGD ZERO INHALT IBFHLT INBUFP MESSIZ impihd LEADER BUFADR FLTFLG STOPFL TESTHS OLINKP NowOut IMPQ IMPQTP IMPQTC IMPQPP IMPQPC IMPREQ CLKSEC DEDFLG PSDDDB ReDirt TikHst HSTLAS LASCHK HOSTS ZERON

;Whole page IFN FTIP

IFN FTAIP,<

;Definitions for following data.  Note that we use 32-bit words for all
;IMP messages, while TOPS-10 uses 36.

HTISiz↑←←=96			; the length of the leader is 96.
HTIWds↑←←<HTISiz+<net.wd-1>>/net.wd	; number of words in a H-T-I leader.

newfrm↑←←<byte(4)0,=15>		; second 4 bit byte is decimal 15
IMPQLN↑←←=10			;MAXIMUM NUMBER OF MESSAGES AT A TIME
HDTLEN↑←←4			;Length of Host Data Table entry
HDTOVR↑←←2			;Number of "overhead" words in Host Data Table

;Data from IMPMAC.MAC/32P.

;These words are modified by code in IMPSER.
MS.HGD↑:			;Three word host going down message
	NEWFRM ! <2 ⊗ 4>	;New format + host going down
	THSITE ⊗ 4		;Host/IMP address
	BYTE(12)7776(4)15	;Down time not known, unspecified reason
>;IFN FTAIP

;Data from IMPMAC.MAC/113P.

	ZERO↑←←.

IFN FTAIP,<

INHALT↑:0		;-1 IF INPUT INTERRUPTED FOR LACK OF BUFFER
IBFHLT↑:0		;-1 IF BUFFER STILL NEEDED
INBUFP↑:0		;POINTS TO MESSAGE BEING INPUT(FIRST,,LAST BUFFER)
MESSIZ↑:0		;HAS DATA MESSAGE SIZE IN BITS
impihd↑:block	HTIWds	;[96bit] location to store imp to host leader
			;	 while it's coming in.  first word = 0
			;	 flags host-host message.
LEADER↑:0		;TEMPORARY STORAGE OF LEADER
BUFADR↑:0		;NEW BUFFER ADDRESS
FLTFLG↑:0		;-1 IF HARDWARE ERROR
STOPFL↑:0		;-1 IF IMP GOING DOWN
TESTHS↑:0		;IF NON-ZERO, ONLY MESSAGES FROM
			;  SPECIFIED HOST ARE ACCEPTED.


OLINKP↑:XWD 0,0			;ADDRESS OF OUTPUT data BUFFER POINTER.
NowOut↑:0			; buffer now being output.

IMPQ↑:	BLOCK IMPQLN		;QUEUE FOR HIGH PRIORITY HOST-IMP
				;  MESSAGES.
IMPQTP↑:0		;TAKE POINTER
IMPQTC↑:0		;TAKE COUNTER
IMPQPP↑:0		;PUT POINTER
IMPQPC↑:0		;PUT COUNTER

IMPREQ↑:0		;NUMBER OF MESSAGES TO BE SENT

CLKSEC↑:0			;IF POSITIVE, COUNTS DOWN TO NEXT TEST
DEDFLG↑:0			;-1 IF IMP IS(OR WAS JUST) DEAD

>;IFN FTAIP

PSDDDB↑←←.-PDBTop		; define hypothetical start of our pseudo DDB
	block	PDBBot-PDBTop+1	; number of words we really use

IFN FTAIP,<
;TEMPORARY STORAGE
repeat 0,<
ReDirt↑:block	1	; 0 or IMP address to redirect message now being sent.
>;repeat 0
TikHst↑:block	1	; number of secounds until the next host check.
HSTLAS↑:BLOCK	1	;TABLE ENTRY ADDRESS FOR LAST HOST TO TRANSMIT
LASCHK↑:BLOCK	1	;TABLE ENTRY ADDRESS FOR LAST HOST TO BE CHECKED

HOSTS↑:	BLOCK	HDTLen+HDTOvr	; start of HOST TABLE.
				; see HDT description for explanation
>;IFN FTAIP

↑ZERON←←.-ZERO		;Number of words to clear
;UDPSER data ;⊗ UDRPRT UDFPRT UDPMSG UDEPRT UDELED UDEMES UDECHK

↑UDRPRT←←400			;Reserve ports 0-377

↑UDFPRT:BLOCK 1			;Last UDP free port assigned
UDPMSG↑:BLOCK 1			;UDP messages seen
UDEPRT↑:BLOCK 1			;Unknown port
UDELED↑:BLOCK 1			;Leader error
UDEMES↑:BLOCK 1			;Error reading message in
UDECHK↑:BLOCK 1			;Checksum wrong

;Data from UDPSER.MAC/4P.

UDPLen↑←←2			;number of words in an UDP leader.

UDPIBH↑:block	NBHLen		; buffer header.
UDPIBf↑:block	UDPLen		; words needed for header
; the following block is used to create a UDP leader for output.
;  it is filled and then converted to 36 bit buffers all under ScnOff.
UDPObf↑:block	NBHLen+UDPLen	; output buffer for forming leader

BEND IMPDDB

>;IFN FTIP	;Last of several whole pages
;⊗ DLNDDB UNIT UNIT DFSWC NINPKT NOUPKT NORPKT NFRERR NCKERR NRCERR NSNERR NRNERR NDOERR NNSERR NRSERR NDLERR NSQERR NRPERR NCRTRN DFWC DIDS DODS DPID DIWS DOWS UUOPDB INTPDB DILIST DOLIST DXLIST DIWIN DOWIN DACK DSEQ DNUMP DNUM DREP DLWC DLINK DLNDLN

BEGIN DLNDDB ↔ SUBTTL DLNDDB Dialnet DDB and data area
; Mark Crispin, September '79

; DDB for DLN device

Comment ⊗			; for E directory
DLNDDB:	end of comment ⊗

UNIT←←DLNNUM			; initialize unit counter

DEFINE DEV'(X)<IFE X,<↑DLNDDB:>↑DL'X'DDB:IFN DLNNUM-1,<SIXBIT/DLN'X/;>SIXBIT/DLN/>
DEFINE DLNUTX'(X)<DL'X'DDB>

REPEAT DLNNUM,<
UNIT←←UNIT-1
IFE FT8UNI,<
	REPEAT DDBSKW-2,<0>
>;IFE FT8UNI
IFN FT8UNI,<
	REPEAT DDBSKW-3,<0>
	UNIT⊗PUNITP		;UNIT NUMBER
>;IFN FT8UNI
	DLNUTX(\UNIT)+DEVIOS	; DEVSPT
	DEVIBF,,0		; DEVCMR
	DEV(\UNIT)		; DEVNAM
IFE FT8UNI,<
	UNIT⊗PUNITP		; DEVCHR
>;IFE FT8UNI
IFN FT8UNI,<
	0			; DEVCHR
>;IFN FT8UNI
	0			; DEVIOS
	IFE UNIT-(DLNNUM-1),<DLN.NX,,DLNDSP;>DLINK,,DLNDSP	;DEVSER
	DVLNG!DVIN!DVOUT,,100000 ; DEVMOD
	BLOCK 4			; DEVLOG/DEVBUF/DEVIAD/DEVOAD
	PHASE DEVOAD+1
↑DFSWC←←.			; first word cleared at sys init (statistics)
↑NINPKT::BLOCK 1		; # of packets read
↑NOUPKT::BLOCK 1		; # of packets sent
↑NORPKT::BLOCK 1		; # of retransmitted packets
↑NFRERR::BLOCK 1		; # of framing errors
↑NCKERR::BLOCK 1		; # of checksum errors
↑NRCERR::BLOCK 1		; # of local errors reported by remote
↑NSNERR::BLOCK 1		; # of remote errors we reported
↑NRNERR::BLOCK 1		; # of NAK's received
↑NDOERR::BLOCK 1		; # of data overruns (probably user error)
↑NNSERR::BLOCK 1		; # of MAKPDB failures due to no FS
↑NRSERR::BLOCK 1		; # of REPFPL failures due to no FS
↑NDLERR::BLOCK 1		; # of dialer abort failures
↑NSQERR::BLOCK 1		; # of sequence errors
↑NRPERR::BLOCK 1		; # of redundant packet errors
↑NCRTRN::BLOCK 1		; # of clock-level retransmissions
↑DFWC←←.			; first word cleared at DLNRLS
↑DIDS::	BLOCK 1			; I-level input coroutine PC
↑DODS::	BLOCK 1			; I-level output coroutine PC
↑DPID::	BLOCK 2			; Dialnet PID
↑DIWS::	BLOCK 1			; input window size
↑DOWS::	BLOCK 1			; output window size (must be after DIWS)
↑UUOPDB::BLOCK 1		; UUO PDB
↑INTPDB::BLOCK 1		; I-level PDB
↑DILIST::BLOCK 1		; input PDB list
↑DOLIST::BLOCK 1		; output PDB list
↑DXLIST::BLOCK 1		; acknowledgement pending PDB list
↑DIWIN::BLOCK 1			; input window free
↑DOWIN::BLOCK 1			; output window free (must be after DIWIN)
↑DACK::	BLOCK 1			; last consecutive packet received
↑DSEQ::	BLOCK 1			; current output packet sequence number
↑DNUMP::BLOCK 1			; pointer to phone number
↑DNUM::	BLOCK 4			; phone number
↑DREP::	BLOCK 1			; dialing reply
↑DLWC←←.-1			; last word cleared at DLNRLS
	DEPHASE
DLINK←←DLNUTX(\UNIT)
>;REPEAT DLNNUM

IFN DLNNUM,<
↑DLNDLN←←DLWC+2			; size of DDB
>;IFN DLNNUM
;⊗ DLNUTB PDBFL PDBFLN PDBRPN

IFN DLNNUM,<
; Unit/DDB conversion table for I-level routines

↑DLNUTB:REPEAT DLNNUM,<DLNUTX(\UNIT) ↔ UNIT←←UNIT+1>

; PDB free list stuff

↑PDBFL:	BLOCK 1			; PDB free list
↑PDBFLN:BLOCK 1			; less than 0 → number of PDB's PDBFL wants to get
↑PDBRPN:BLOCK 1			; -1 → okay to queue a REPFPL request
>;IFN DLNNUM

BEND DLNDDB
;⊗ %%NOP %%ECHR %%ECHM %%ENMG %%ENAD %%DTMG %%ENBC %%DTMX ENHADM DTQ%LK DTQ%WC DTQ%XC DTQ%RT DTQ%OL DTQ%MS DTQ%XX TO11QH TO11QT TO11QC TO11MA TO11BE TO11EF DO11ER N11BPE N11TMB N11TMO N10TMO NTO11 NTO10 TO11HC TO10HC QMP11E QMP11M TO10MA QMP10E QMP10M QMPSIZ DTQECH ENINQM ENBCCF HADREQ DTINQH DTINQT DTINQC DTINQM TO10QC TO10QH TO10QT DTEWAT DTECNT DTETMO LDTBUF DTEBUF DTEBEG DTEEND DTEPTR DTETKR DTEBSY DTECCT NDTHIT SDTHIT SD2HIT NDTHNG ND2HNG NDTFUL DTEWAT DTECNT DTETMO DTEWA2 DTECN2 DTETM2 KLEAR KLEAR2 KLPDTO KLPDAT

IFKL10,<	;Whole page

;Data area for the 10/11 Queued message protocol

;10/11 message types.
↓%%NOP==0	;no-operation
↓%%ECHR==1	;echo response
↓%%ECHM==2	;EchoMe
↓%%ENMG==3	;ethernet message. next byte is the 11 word count of packet
↓%%ENAD==4	;ethernet address message
↓%%DTMG==5	;dectape message
↓%%ENBC==6	;specify broadcast handling (disable/enable broadcast packets)
↓%%DTMX==%%ENBC	;maximum valid message number (change KLDCP if you change this!)

>;IFKL10
IFN PUPNUM,<

;Prototype DTQ free storage block.  (This block also contains a message)
	400000!EFSGET,,0	;fake FS hdr at ENHADM-1 to satisfy bugtraps in KLSER
ENHADM:		PHASE	0
↓DTQ%LK::	0		;link to next message on the queue, or zero
↓DTQ%WC::	1		;length of message in PDP-11 words.
↓DTQ%XC::
  IFN FTF2,<0;>	PUSHJ P,CLRADM	;notification instruction. (via XCT)
↓DTQ%RT::	0		;retry count (outgoing)
↓DTQ%OL::	0		;xwd PUPDDB ptr,link to next in DDB's own queue
				;pointer to BIB for this message, for Ethernet IP
		0		;spare
		0		;spare
↓DTQ%MS::
 IFN FTF2,< 0;>	BYTE(16)%%ENAD	;text of message starts here, two left-justified
				;16-bit bytes per word.
↓DTQ%XX==.
		DEPHASE

>;IFN PUPNUM
IFKL10,<	;Rest of page

TO11QH:	0
TO11QT:	TO11QH
TO11QC:	0			;count of to11 messages in queue
TO11MA:	0			;current message address
TO11BE:	0			;expected ending byte pointer for to-11 xfer
IFN FTT11BELL,<
TO11EF:	0			;error seen
>;IFN FTT11BELL
DO11ER:	0			;nonzero if want FN11ES to type error data
N11BPE:	0			;number of times had wrong final byte pointer
N11TMB:	0			;number of timeouts with bad byte pointers
N11TMO:	0			;number of timeouts for to-11 xfers
N10TMO:	0			;number of timeouts for to-10 xfers
NTO11:	0			;number of to-11 xfers started
NTO10:	0			;number of to-10 xfers started
;;CNTO10: 0			;saved copy of NTO10 at last 1-second clk time
;;CNTO11: 0			;saved copy of NTO11 at last 1-second clk time
;;QC11MA: 0			;previous clock's TO11MA
TO11HC:	-1			;hung timeout for to-11 xfers
TO10HC:	-1			;hung timeout for to-10 xfers
QMP11E:	0			;total to-11 errors
QMP11M:	0			;total to-11 messages queued

TO10MA:	0			;current message address
;;QC10MA: 0			;previous clock's TO10MA
QMP10E:	0			;total to-10 errors
QMP10M:	0			;total to-10 messages received

QMPSIZ:	0			;size of to-10 message
DTQECH:	0			;latest echo response from 11

ENINQM:	0			;total count of ethernet messages received

ENBCCF:	0			;old broadcast control word from 11

HADREQ:	0			;-1 means a request for en addr was sent

DTINQH:	0			;dectape input queue header
DTINQT:	DTINQH			;dectape input queue trailer
DTINQC:	0			;count of messages in dectape input q.
DTINQM:	0			;total count of dectape messages received

IFE PUPNUM,<
TO10QC:	0
TO10QH:	0
TO10QT:	TO10QH
>;IFE PUPNUM

IFE FTNDTE,<
DTEWAT:	0		;Negative total of accumulated wait counts from DTEXX
DTECNT:	0		;Total number of times DTEXX has passed 11 a cmd word
DTETMO:	0		;Number of times DTEXX has timed out waiting for 11
>;IFE FTNDTE

IFN FTNDTE,<
;DTE buffer parameters: DTE buffer holds commands waiting to be passed to the 11.
LDTBUF←←200	;Size of DTE buffer
↑DTEBUF:BLOCK LDTBUF	;Circular buffer of commands to be given to 11.
↑DTEBEG←←0	;Index of first word in buffer
↑DTEEND←←LDTBUF	;Index of word following end of buffer
↑DTEPTR:0	;Putr pointer: index of next buffer word to be filled with datum
↑DTETKR:0	;Takr pointer: index of next buffer word to be emptied
↑DTEBSY:0	;Non-zero while busy waiting for DTE in DTEXXW, locks out DTENXT
↑DTECCT:0	;Countdown timer (in seconds until time to check DTE for hung)
↑NDTHIT:0	;Number of cmds given to 11, used by clock hung checker
↑SDTHIT:0	;Value of NDTHIT saved by clock hung checker
↑SD2HIT:0	;Value of SDTHIT saved by clock hung checker, for re-ring check
↑NDTHNG:0	;Number of times clock hung checker found DTE hung
↑ND2HNG:0	;Number of times we re-rang 11's bell to re-try a cmd to 11
↑NDTFUL:0	;Number of cmds for 11 lost because of full DTE buffer
↑DTEWAT:0	;Negative total times looped busy waiting for 11 response
↑DTECNT:0	;Count of times got response of interest from 11 after busy wait
↑DTETMO:0	;Count of timeouts while busy waiting for 11 response of interest
↑DTEWA2:0	;Negative total times looped busy waiting for prev cmd finish
↑DTECN2:0	;Count of times 11 finished prev cmd while we were busy waiting
↑DTETM2:0	;Count of timeouts while busy waiting for prev cmd to finish
>;IFN FTNDTE

KLEAR:	0	;Remembered Error Address Register for parity errors.
KLEAR2:	0	;Actual physical address extracted from EAR for current error

KLPDTO:	0	;KLPAG's DATAO data for restoring ACs at ERRINT
KLPDAT:	0	;data of bad parity word
>;IFKL10
;⊗ PUPBSZ PUPDDB PTIMES PUPILS PUPBAL PUPMAL PUPNBA PUPNMA PUPRII PUPSII PUPHBA PUPHMA PUPIBC PUPICN PUPPMX PUPOLS PUPOCN PUPCID PUPRID PUPSID PUPLNK PUPCSB PUPTMO PUPMOD PUPDLS PUPDLN

IFN PUPNUM,<	;Whole page
↓PUPBSZ←←=128			; PUP buffer size (must be outside BEGIN)

BEGIN PUPDDB ↔ SUBTTL PUPDDB PUP DDB and data area

; Mark Crispin, December '80
; Reritten by Tovar, November '81


	REPEAT DDBSKW-2,<0>	; new words not used
	PUPDDB+DEVIOS		; DEVSPT
	DEVIBF!DEVSHR!DEVSTS!DEPCBC,,0	; DEVCMR
↑PUPDDB:PHASE 0
	SIXBIT/PUP/		; DEVNAM
	PUPBSZ+1		; DEVCHR
	0			; DEVIOS
	PUP.NX,,PUPDSP		; DEVSER
	DVLNG!DVIN!DVOUT,,164403; DEVMOD
	0			; DEVLOG
	0			; DEVBUF
	0			; DEVIAD
	0			; DEVOAD

;Following word must be in same position as TIMES word in IMPDDB because
;of shared use of byte pointers.  Some other words in pre-FTIP IMP DDB used
;to agree with PUPDDB, but they no longer do (ignore comments below).  IMP
;code does not use RFNM or IDLE timeouts.

↑PTIMES::BYTE (6)5,5,5,20,0,77	;CLS,RFNM,ALLOC,RFC,INPUT,IDLE timeouts
IFN FTIP,<
GLOBAL TIMES			;Stupid FAIL
IFN PTIMES-TIMES,<.FATAL PUP and IMP DDBs disagree>
>;IFN FTIP

↑PUPILS::0			; input list

↑PUPBAL::0			; Bit allocation
↑PUPMAL::0			; Message allocation

↑PUPNBA::=8*=4*=512		; Bit allocation (about 1 page worth of FS)
↑PUPNMA::=8			; Message allocation

;These two words are NOT compatable with IMP

↑PUPRII::0			; Current Pup receive interrupt ID
↑PUPSII::0			; Current Pup send interrupt ID

; These four words should be the same as IMPDDB
↑PUPHBA::0			; Foreign bit allocation
↑PUPHMA::0			; Foreign message allocation
↑PUPIBC::0			; Bits in input list
↑PUPICN::0			; Input list message counter

;Preceding words must agree with IMPDDB

↑PUPPMX::0			; Max. bytes permitted in message
↑PUPOLS::0			; Output list header
↑PUPOCN::0			; Output list message counter
↑PUPCID::0			; PUP connection ID, for End
↑PUPRID::0			; Current Pup receive ID
↑PUPSID::0			; Current Pup send ID
↑PUPLNK::-1			; Index into link tables (-1 means no link)
↑PUPCSB::0			; PUP clock subroutine (retry, etc.)
↑PUPTMO::0			; Hung timeout (PDVCNT isn't big enough)
↑PUPMOD::0			; Mode (BSP,EFTP,PKT)
↑PUPDLS←←.-1			; last word in PUP DDB
	DEPHASE
↑PUPDLN←←.-PUPDDB+DDBSKW	; length of a PUP DDB

>;IFN PUPNUM	;Whole page

;⊗ PUPMLK PUPCBG PUPLDB PUPLSK PUPFSK PUPHST PUPSTB PUPLKS PUPMH0 PUPNML PUPNPM PUPSMS PUPB11 PUPLMS PUPILF PUPPH0 PUPWHS PUPNXL PUPIPT PUPNER PUPBMS PUPNFS PUPBCK PUPBRD PUPBEN PUPBER PUPIRB PUPNEA PUPUNK PUPEFR LOC PPUPMN PPUPMX XPUPIB XPUPOB XPUPOE XPUPOC PUPFLG NPPMSS PPERCN PUPTEL PUPYET PUPHYT PUPCEN SUENNM SUEHST ENHADR ENNADR SUENNM SUEHST ENHADR ENNADR PUPIRT .PUPON SUSLNM ENNAD2 ENBADR ENBAD2 PSKMAP PUPSVR PUPPRV PUPERF PUPHDW ROUNET ROUGTW ROUINT ROUSIZ

IFN PUPNUM,<	;Whole page

↑PUPMLK←←=40			; current maximum number of Pup connections

↑PUPCBG←←.			; beginning of Puppy core zeroed at SYSINI time

; Per-link Pup storage

	BLOCK 1			; Link -1 is used for generating error packets.
↑PUPLDB:BLOCK PUPMLK+1		; DDB for this link
↑PUPLSK:BLOCK PUPMLK+1		; local socket
↑PUPFSK:BLOCK PUPMLK+1		; foreign socket
↑PUPHST:BLOCK PUPMLK+1		; foreign host
↑PUPSTB:BLOCK PUPMLK		; connection status
↑PUPLKS:BLOCK 1			; Number of links in use.


; Puppy performance statistics
↑PUPMH0:BLOCK 1			; # of messages from host 0
↑PUPNML:BLOCK 1			; # of messages for some other host
↑PUPNPM:BLOCK 1			; # of non-Pup messages received
↑PUPSMS:BLOCK 1			; # of short (below minimum Pup size) messages
↑PUPB11:BLOCK 1			; # of Pup/11 disagreement on message size
↑PUPLMS:BLOCK 1			; # of long (above maximum Pup size) messages
↑PUPILF:BLOCK 1			; # of times we got BSP packet with full input list
↑PUPPH0:BLOCK 1			; # of Pups from host 0
↑PUPWHS:BLOCK 1			; # of messages for the wrong host
↑PUPNXL:BLOCK 1			; # of Pups for a non-existent link
↑PUPIPT:BLOCK 1			; # of illegal Pup types
↑PUPNER:BLOCK 1			; # of Error Pups received
↑PUPBMS:BLOCK 1			; # of bad Mark sizes
↑PUPNFS:BLOCK 1			; # of free storage failures
↑PUPBCK:BLOCK 1			; # of bad checksums
↑PUPBRD:BLOCK 1			; # of broadcast packets received
↑PUPBEN:BLOCK 1			; # of bad End packets
↑PUPBER:BLOCK 1			; # of bad EndReply packets
↑PUPIRB:BLOCK 1			; # of unsolicited IntReply packets
↑PUPNEA:BLOCK 1			; # of EFTP Aborts seen
↑PUPUNK:BLOCK 1			; # of packets with unknown types
↑PUPEFR:BLOCK 1			; # of EFTP/RFC/BSPCLS packets retransmitted

IFN FTF2,<
;Following are used by PUPSRV.MAC

	DEFINE LS(LOC) <
↑LOC:	BLOCK 1		>;DEFINE LS

LS PUPCMD		;SAVED HARDWARE COMMAND REGISTER BITS
LS PUPLHN		;LOCAL HOST NUMBER
LS PUPLNN		;LOCAL NETWORK NUMBER
LS PUPBYT		;SAVED XMIT BUFFER BYTE ADDRESS FOR INTERFACE
LS PUPTXT		;TODCLK OF TRANSMIT OR ZERO IF NOT IN PROGRESS
LS PUPICC		;COUNT OF PUP INPUT CRC ERRORS
LS PUPIIC		;COUNT OF PUPS SUCCESSFULLY INPUT
LS PUPILC		;COUNT OF LOST PUPS BECAUSE NO INPUT BUFFERS
LS PUPIOC		;COUNT OF INPUT OVERFLOWS
LS PUPITC		;COUNT OF TOTAL INPUT ATTEMPTS
LS PUPIXC		;COUNT OF INPUT PUPS THAT WERE TOO BIG
LS PUPIZC		;COUNT OF INPUT PUPS WITH SOFTWARE CHECKSUM ERRORS
LS PUPOCC		;COUNT OF XMIT COLLISIONS
LS PUPOOC		;COUNT OF PUPS SUCCESSFULLY OUTPUT
LS PUPOXC		;COUNT OF EXCESS COLLISION OCCURANCES

PPUPMN==24		;MINIMUM NUMBER OF WORDS TO REALLY SEND
PPUPMX==400		;MAXIMUM NUMBER OF WORDS TO REALLY SEND

↑XPUPIB: BLOCK 1		;Input packet being processed
↑XPUPOB: BLOCK 1		;Beginning of output queue  (CAUTION: LF non-zero)
↑XPUPOE: BLOCK 1		;End of output queue
↑XPUPOC: BLOCK 1		;Number of packets in queue

↑PUPFLG: BLOCK 1		;Cause PUP interrupt if non-zero
>;IFN FTF2

; Other storage

↑NPPMSS←←5		        ; number of PUP error messages allowed per minute
↑PPERCN:BLOCK 1			; negative error count remaining for current minute
↑PUPTEL:BLOCK 1			; nonzero if want PUPDMP to list PUP contents
↑PUPYET:BLOCK 1			; Pup periodic task countdown
↑PUPHYT:BLOCK 1			; Subdivision of PUPYET for hung timeout

↑PUPCEN←←.-1			; end of Puppy core zeroed at SYSINI time

IFE FTF2,<			;Host address, SAIL
↑SUENNM←←126			;Ethernet network number for SAIL's 3MB net
↑SUEHST←←302			;SAIL's host number
↑ENHADR: 0			;Our Ethernet host address
↑ENNADR: 0			;Our Ethernet host address with network number
>;IFE FTF2

IFN FTF2,<			;Host address, CCRMA
↑SUENNM←←61			;Ethernet network number for CCRMA net
↑SUEHST←←300			;CCRMA's host number
↑ENHADR: SUEHST			;Our Ethernet host address
↑ENNADR: 400*SUENNM+SUEHST	;Our Ethernet host address with network number
↑PUPIRT: XWD SUENNM,SUEHST	;For FNTSRV
↑.PUPON: -1			;Enabled if -1
>;IFN FTF2

IFN FTETH2,<
↑SUSLNM←←76			;Unofficial serial link network number
↑ENNAD2: 400*SUSLNM+SUEHST	;Network address on serial link subnet
>;IFN FTETH2

↑ENBADR: 400*SUENNM		;For broadcast packets
IFN FTETH2,<
↑ENBAD2: 400*SUSLNM
>;IFN FTETH2

; Pup server fireup storage

↑PSKMAP:111			; Map of sockets we will sprout phantoms for
				; (Currently 1,4,7)

↑PUPSVR:SIXBIT/PUP000/		; filename
	SIXBIT/NETSYS/		; PPN
↑PUPPRV:LUPPRV,,0		; privileges
	0			; no special DDB to give to phantom

↑PUPERF: 0			; nonzero means list Error Pups on CTY

IFN FTETH2,<
;Serial line hackery
↑PUPEXF: 0		;If -1, take interrupt in PUPCHN to PUPEXP
↑PUPEXD: 0		;If non-zero, PUP DDB used for serial line communications
↑PUPEXQ: 0		;Queue of packets for serial line communication
↑PUPEXC: 0		;Number of items on PUPEXQ
>;IFN FTETH2

IFN FTETHX,<
↑EFSDDB: 0		;If -1, pass Yodanet packets to [EFSD]
>;IFN FTETHX

; First word of a PUP.  Second byte is filled in when we know our host number,
; currently by KLSER
↑PUPHDW:
IFE FTF2,<
	$PUP*1B31		; BYTE (8) 0,0 (16) $PUP
>;IFE FTF2
IFN FTF2,<
	BYTE (8) SUENNM		; BYTE (8) <network>,0 (16) <length>
>;IFN FTF2

; Routing table pointers.
;
; Address of table is setup at PUPINI to null routing table, and update by user
; program via SETROU MTAPE.

↑ROUNET: POINT 8,0(TAC1),7	;Target-net
↑ROUGTW: POINT 8,0(TAC1),23	;Gateway-net
↑ROUINT: POINT 0,0(TAC1),35	;Internal net number (currently only EtherNet here)
↑ROUSIZ: 1			;Size of routine table.  Must be ≥1

BEND PUPDDB

>;IFN PUPNUM	;Whole page
;⊗ PIOFFS PILOST

;JSR here after turning PIs off, to record where it's done.
↑PIOFFS:0
	JRST @PIOFFS

repeat 0,<	;save for debugging flakey hardware
↑PILOST:	0
	SYSPIFF
	EXCH P,ERRPDL
	PUSHACS
	PUSHJ P,DISGST
	PUSHJ P,DISMES
	 ASCIZ/Interrupting into a PI channel that is OFF!!!  /
	PUSHJ P,DISFLU
	POPACS
	PUSHJ P,FDDTCA
	EXCH P,ERRPDL
	SYSPIN
	JRST 4,.		;don't how offhand which CHn word to use
				;for returning
>;repeat 0
;⊗ WHOIMP WHOPUP WHOALL NETLST NNETS HSTLST NHOSTS NETARP NI.NAM NI.FNM NI.NAM NI.FNM NI.UP NI.OK NI.IP NI.PUP NI.NTN NI.NSN NI.IPA NI.NTM NI.NSM NI.TMX NI.GTW NI.GTN NI.PGW NI.GWT NI.RTS NI.PRE NI.REL NI.MAK NI.OUT NI.FNA NI.MRL IMPUP OKFLAG MYSITE NETETH NI.NAM NI.FNM NI.UP NI.OK NI.IP NI.PUP NI.NTN NI.NSN NI.IPA NI.NTM NI.NSM NI.NTM NI.NSM NI.TMX NI.GTW NI.GTN NI.PGW NI.GWT NI.RTS NI.PRE NI.REL NI.MAK NI.OUT NI.FNA NI.MRL NETETH NI.NAM NI.FNM NI.UP NI.OK NI.IP NI.PUP NI.NTN NI.NSN NI.IPA NI.NTM NI.NSM NI.NTM NI.NSM NI.TMX NI.GTW NI.GTN NI.PGW NI.GWT NI.RTS NI.PRE NI.REL NI.MAK NI.OUT NI.FNA NI.MRL NILIST NINUM

IFN FTIP,<
;Block of values to allow WHO to display status of IMP DDBs
;LH of lowcore loc 352 points here.
↑WHOIMP:RMTADR,,RMTPRT
	LCLADR,,LCLPRT
	STATE,,TTYLIN
	PTYIMP,,NETADR
	SNDUNA,,PROTCL
	SNDISS,,SNDNXT
	SNDWND,,RCVIRS
	RCVNXT,,RCVWND
	RTTIME,,0
	BLOCK 2		;patch space for more values
;> ↑WHOIMP ←← 0	;if no device IMP, then make ptr from 352 contain zero.

IFG PUPNUM,<
;Block of values to allow WHO to display status of PUP DDBs
;RH of lowcore loc 352 points here.
↑WHOPUP:PUPLDB,,PUPHST
	PUPLSK,,PUPFSK
	PUPSTB,,PUPLKS
	ROUNET,,ROUSIZ
IFE FTF2,<
	ENINQM,,QMP11M
>;IFE FTF2
IFN FTF2,<
	PUPIIC,,PUPOOC
>;IFN FTF2
	TCONLN,,PUPLNK
	BLOCK 2		;patch space for more values
;> ↑WHOPUP ←← 0	;if no device PUP, then make ptr from 352 contain zero.

;Block of values to allow WHO to display various things.
;LH of lowcore 356 points here.  This table of values can be extended freely.
↑WHOALL:USETP,,0	;value(s) for WHO

;List of networks our host is on, in HOSTS3 format.
;Lowcore 354 points to here for user programs to figure this stuff out.
↑NETLST:
IFN FTAIP,<
	IMPHST(0,0)		;ARPAnet or MILnet
>;IFN FTAIP
IFN FTEIP,<
	SUHOST(0,0)		;SU-Net-Temp or SU-Net
>;IFN FTEIP
IFG PUPNUM,<
	PUHOST(0,0)		;PUP Ethernet
>;IFG PUPNUM
↑NNETS←←.-NETLST	;Number of networks we're on
	BLOCK 1		;Patch space, if you patch here, you must patch 354's LH

;List of our host numbers, in HOSTS3 format.
;Lowcore 355 points to here for user programs to figure this stuff out.
↑HSTLST:
IFN FTAIP,<
	IMPHST(ARPA.H,ARPA.I)	;ARPAnet or MILnet IP address
>;IFN FTAIP
IFN FTEIP,<
	SUHOST(SUENNM,SUEHST)	;Ethernet IP address, written by KLSER when
				;we find our host number on the Ethernet.
>;IFN FTEIP
IFG PUPNUM,<
	PUHOST(SUENNM,SUEHST)	;Ethernet PUP address
>;IFG PUPNUM
↑NHOSTS←←.-HSTLST	;Number of host numbers
	BLOCK 1		;Patch space, if you patch here, you must patch 355's LH

;(Note: the NETLST and HSTLST tables preceded the more general network
;interface definitions below, but are being kept for compatibility.)


;To support multiple networks we define a set of network interfaces, which
;represent the hardware devices.  Each network interface is a table
;containing whatever information is needed by code that uses that network.

;Definitions of network interfaces.  Field names are repeated in each
;block so that FAIL will check consistency.

IFN FTSUAI!FTLLL,<
↑NETARP:PHASE 0			;Arpanet or Milnet IMP
IFN FTSUAI,<
NI.NAM::'ARPA  '		;Name
NI.FNM::[ASCIZ/Arpanet/]	;Fancy name
>;IFN FTSUAI
IFN FTLLL,<
NI.NAM::'MILNET'		;Name
NI.FNM::[ASCIZ/Milnet/]		;Fancy name
>;IFN FTLLL
NI.UP::	0			;Desired state: -1 up, 0 down
				;Set to +1 to tell IMPMAC.MAC to take it down
NI.OK::	0			;Actual current state
NI.IP::	-1			;-1 if network supports IP
NI.PUP::0			;-1 if network supports PUP
;IP definitions
NI.NTN::IMPHST(0,0)		;Network number
NI.NSN::IMPHST(0,0)		;Net and subnet number
NI.IPA::IMPHST(ARPA.H,ARPA.I)	;IP address
NI.NTM::IPHOST(377,0,0,0)	;Network mask
NI.NSM::IPHOST(377,0,0,0)	;Net and subnet mask
NI.TMX::<=8159/=32>*4-<=96/=8>-<IPLEN*4>-<TCPLEN*4> ;Maximum TCP segment length
;=8159 bits is the maximum size of a host-to-IMP message, =32 accounts for
;us sending 32 bit words, and there are =96 bits in the H-T-I leader.
NI.GTW::ARPAGW			;List of default gateways
NI.GTN::ARPAGN			;Number of default gateways
NI.PGW::ARPAGW			;Addr of current primary gateway
NI.GWT::0			;Gateway ICMP echo timer
NI.RTS::0			;Aobjn ptr to static routing entries
NI.PRE::IMPPRE			;Routine to preallocate output resources
NI.REL::BUFREL↑			;Routine to release output resources
NI.MAK::IMPMAK↑			;Routine to prepare IP packets for output
NI.OUT::GO1822↑			;Routine to queue or retransmit IP packets
NI.FNA::ARPFNA↑			;Routing to fix NETADR in header
NI.MRL::RELBUF↑			;Routine to release message after output
	DEPHASE

IMPUP←NETARP+NI.UP		;Symbols used in IMPSER.MAC
OKFLAG←NETARP+NI.OK
MYSITE←NETARP+NI.IPA		;TOPS-10 uses this for our Arpanet addr
>;IFN FTSUAI!FTLLL

IFN FTSUAI,<
↑NETETH:PHASE 0			;3MB Experimental Ethernet
NI.NAM::'ETHER '		;Name
NI.FNM::[ASCIZ/Ethernet/]	;Fancy name
NI.UP::	0			;Desired state: -1 up, 0 down
NI.OK::	0			;Actual current state
NI.IP::	-1			;-1 if network supports IP
NI.PUP::-1			;-1 if network supports PUP
;IP definitions
NI.NTN::SUHOST(0,0)		;Network number
NI.NSN::SUHOST(SUENNM,0)	;Net and subnet number
NI.IPA::SUHOST(SUENNM,SUEHST)	;IP address (written by KLSER when we find
				;our host number on the Ethernet)
IFE FTETHB,<
NI.NTM::IPHOST(377,0,0,0)	;Network mask (SU-NET-TEMP, class A)
NI.NSM::IPHOST(377,377,0,0)	;Net and subnet mask
>;IFE FTETHB
IFN FTETHB,<
NI.NTM::IPHOST(377,377,0,0)	;Network mask (SU-NET, class B)
NI.NSM::IPHOST(377,377,377,0)	;Net and subnet mask
>;IFN FTETHB
NI.TMX::=556-<IPLEN*4>-<TCPLEN*4> ;Maximum TCP segment length
NI.GTW::ETHGW			;List of default gateways
NI.GTN::ETHGN			;Number of default gateways
NI.PGW::ETHGW			;Addr of current primary gateway
NI.GWT::0			;Gateway ICMP echo timer
NI.RTS::-ETHRTN,,ETHRTS		;Aobjn ptr to static routing entries
NI.PRE::ETHPRE			;Routine to preallocate output resources
NI.REL::ETHREL			;Routine to release output resources
NI.MAK::EIPMAK↑			;Routine to prepare IP packets for output
NI.OUT::EIPOUT↑			;Routine to queue or retransmit IP packets
NI.FNA::ETHFNA↑			;Routing to fix NETADR in header
NI.MRL::ETHMRL↑			;Routine to release message after output
	DEPHASE
>;IFN FTSUAI

IFN FTCCRMA,<
↑NETETH:PHASE 0			;10MB Ethernet
NI.NAM::'ETHER '		;Name
NI.FNM::[ASCIZ/Ethernet/]	;Fancy name
NI.UP::	0			;Desired state: -1 up, 0 down
NI.OK::	0			;Actual current state
NI.IP::	0			;-1 if network supports IP
NI.PUP::-1			;-1 if network supports PUP
;IP definitions
NI.NTN::SUHOST(0,0)		;Network number
NI.NSN::SUHOST(SUENNM,0)	;Net and subnet number
NI.IPA::SUHOST(SUENNM,SUEHST)	;IP address
IFE FTETHB,<
NI.NTM::IPHOST(377,0,0,0)	;Network mask (SU-NET-TEMP, class A)
NI.NSM::IPHOST(377,377,0,0)	;Net and subnet mask
>;IFE FTETHB
IFN FTETHB,<
NI.NTM::IPHOST(377,377,0,0)	;Network mask (SU-NET, class B)
NI.NSM::IPHOST(377,377,377,0)	;Net and subnet mask
>;IFN FTETHB
PRINTX Finish definitions for CCRMA Ethernet IP
NI.TMX::0			;Maximum TCP segment length
NI.GTW::ETHGW			;List of default gateways
NI.GTN::ETHGN			;Number of default gateways
NI.PGW::ETHGW			;Addr of current primary gateway
NI.GWT::0			;Gateway ICMP echo timer
NI.RTS::0			;Aobjn ptr to static routing entries
NI.PRE::0			;Routine to preallocate output resources
NI.REL::0			;Routine to release output resources
NI.MAK::0			;Routine to prepare IP packets for output
NI.OUT::0			;Routine to queue or retransmit IP packets
NI.FNA::0			;Routing to fix NETADR in header
NI.MRL::0			;Routine to release message after output
	DEPHASE
>;IFN FTCCRMA

;List of network interfaces.  First entry is the "primary" interface, used
;for IP when we don't know a better route.

NILIST:
IFN FTAIP,<		NETARP>
IFN FTEIP!PUPNUM,<	NETETH>
↓NINUM←←.-NILIST		;Number of network interfaces

IFN FTIP,<			;Symbols used in TOPS-10 code
	INTERN NI.NAM,NI.FNM,NI.NTN,NI.NSN,NI.IPA,NI.NTM,NI.NSM
	INTERN NI.TMX,NI.GTW,NI.GTN,NI.PGW,NI.GWT,NI.RTS,NI.PRE
	INTERN NI.REL,NI.MAK,NI.OUT,NI.FNA,NI.MRL
IFN FTAIP,<
	INTERN NETARP,IMPUP,OKFLAG,MYSITE
>;IFN FTAIP
IFN FTEIP,<
	INTERN NETETH
>;IFN FTEIP
	INTERN NILIST
>;IFN FTIP
;⊗ DBGPTR DBGBE0 DBGBEG DBGEND DBGCNT UFDTS0 UFDTS1 UFDCT0 UFDCT1 NUFDLK UFDULO UFDLNO UFDUSO

;Data area for circular buffer of debugging information.  See DEBWD in COMCSS.
IFN FTDBGB,<
↑DBGPTR:	-1		;initial ptr (immediately wraps to beginning)
DBGBE0::			;label for WHO!<cr>; 450 below fits WHO's DD screen.
↑DBGBEG:	BLOCK 450	;arbitrary size block for debugging data, circular buffer
↑DBGEND::			;end of block
↑DBGCNT:	0		;number of items stored in buffer over time
>;IFN FTDBGB

IFN FTUFDB,<
↑UFDTS0:	'RMDSYS'	;name of a UFD to check interlocks on
↑UFDTS1:	'PNYACT'	;name of a UFD to check interlocks on

↑UFDCT0:	-1		;number of locks on UFDTS0
↑UFDCT1:	-1		;number of locks on UFDTS1

↑NUFDLK:	0		;number of UFDs locked up

↑UFDULO:	0		;UFDUSE saved
↑UFDLNO:	0		;UFDLNK saved
↑UFDUSO:	0		;DD.ULK saved

>;IFN FTUFDB
;⊗ DOMDDB DOMRRS DOMRRL DOMRRP DOMDLN RRLIST RRREFC RRLENG RR.HDR RRTYPE RRCLAS RRTTL RRDLEN RRNAME TY.XA TY.CNAME TY.ALL CL.ALL

IFN FTDOM,<

;Definitions and data for domain resource record cache.

;Model DDB for DOM device

	REPEAT DDBSKW-2,<0>	;Words not used
	DOMDDB+DEVIOS		;DEVSPT
	DEVSHR!DEPCBC,,0	;DEVCMR
↑DOMDDB:PHASE 0
	SIXBIT/DOM/		;DEVNAM
	RECSIZ+1		;DEVCHR, buffer size same as for DSK
	0			;DEVIOS
	DOM.NX,,DOMDSP		;DEVSER
	DVLNG!DVIN!DVOUT,,1	;DEVMOD
	0			;DEVLOG
	0			;DEVBUF
	0			;DEVIAD
	0			;DEVOAD
↑DOMRRS::BLOCK 20		;Addrs of RRs waiting for input
↑DOMRRL←←.-DOMRRS		;Max number of RRs to keep
	0			;Make sure list is terminated
↑DOMRRP::0			;Ptr to next RR addr for input
	DEPHASE
↑DOMDLN←←.-DOMDDB+DDBSKW

;Resource records are kept in a doubly-linked list.  Pointers to the
;beginning and end are in RRLIST.  Each record is a free storage block
;including a reference count, which prevents removing records while a
;job is waiting for them.

RRLIST:	XWD RRLIST,RRLIST	;Last record,,first record

;Resource record header words (not seen by user code).
;Word 0 contains back and forward links to other records.
RRREFC←←1			;Reference count
RRLENG←←2			;<LH of byte pos>,,<word count>
RR.HDR←←3			;Total number of header words

;Format of a resource record (as seen by user code and stored in cache).
;The name is stored in 8-bit domain format (see RFC 883), though never in
;the "compressed" format.  It is followed by the associated data.
RRTYPE←←0			;Type
RRCLAS←←1			;Class
RRTTL←←2			;Time to live (in seconds)
RRDLEN←←3			;Data length (in bytes)
RRNAME←←4			;Start of name

;Type definitions that we need (see NETWRK package for others).
TY.CNAME←←=5			;Canonical name
TY.ALL←←=255			;Any type

;Class definitions that we need.
CL.ALL←←=255			;Any class

>;IFN FTDOM
;⊗ CACEND

↑CACEND←←.	;END OF CACHED DATA AREA
